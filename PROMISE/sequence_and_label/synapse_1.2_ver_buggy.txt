package org . apache . synapse . endpoints ; import org . apache . axis2 . clustering . ClusterManager ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . endpoints . algorithms . AlgorithmContext ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import java . util . List ; public class LoadbalanceEndpoint implements Endpoint { private static final Log log = LogFactory . getLog ( LoadbalanceEndpoint . class ) ; private String name = null ; private List < Endpoint > endpoints = null ; private LoadbalanceAlgorithm algorithm = null ; private boolean failover = true ; private Endpoint parentEndpoint = null ; private final EndpointContext endpointContext = new EndpointContext ( ) ; private final AlgorithmContext algorithmContext = new AlgorithmContext ( ) ; public void send ( MessageContext synMessageContext ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Start : Load-balance Endpoint" ) ; } boolean isClusteringEnable = false ; org . apache . axis2 . context . MessageContext axisMC = ( ( Axis2MessageContext ) synMessageContext ) . getAxis2MessageContext ( ) ; ConfigurationContext cc = axisMC . getConfigurationContext ( ) ; ClusterManager clusterManager = cc . getAxisConfiguration ( ) . getClusterManager ( ) ; if ( clusterManager != null && clusterManager . getContextManager ( ) != null ) { isClusteringEnable = true ; } String endPointName = this . getName ( ) ; if ( endPointName == null ) { if ( isClusteringEnable ) { log . warn ( "In a clustering environment , the endpoint  name should be specified" + "even for anonymous endpoints. Otherwise , the clustering would not be " + "functioned correctly if there are more than one anonymous endpoints. " ) ; } endPointName = SynapseConstants . ANONYMOUS_ENDPOINT ; } if ( isClusteringEnable ) { if ( endpointContext . getConfigurationContext ( ) == null ) { endpointContext . setConfigurationContext ( cc ) ; endpointContext . setContextID ( endPointName ) ; } if ( algorithmContext . getConfigurationContext ( ) == null ) { algorithmContext . setConfigurationContext ( cc ) ; algorithmContext . setContextID ( endPointName ) ; } } Endpoint endpoint = algorithm . getNextEndpoint ( synMessageContext , algorithmContext ) ; if ( endpoint != null ) { if ( failover ) { synMessageContext . getEnvelope ( ) . build ( ) ; } endpoint . send ( synMessageContext ) ; } else { setActive ( false , synMessageContext ) ; if ( parentEndpoint != null ) { parentEndpoint . onChildEndpointFail ( this , synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name . trim ( ) ; } public LoadbalanceAlgorithm getAlgorithm ( ) { return algorithm ; } public void setAlgorithm ( LoadbalanceAlgorithm algorithm ) { this . algorithm = algorithm ; } public boolean isActive ( MessageContext synMessageContext ) { boolean active = endpointContext . isActive ( ) ; if ( ! active && endpoints != null ) { for ( Endpoint endpoint : endpoints ) { if ( endpoint . isActive ( synMessageContext ) ) { active = true ; endpointContext . setActive ( true ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Endpoint  '" + name + "' is in state ' " + active + " '" ) ; } return active ; } public void setActive ( boolean active , MessageContext synMessageContext ) { endpointContext . setActive ( active ) ; } public boolean isFailover ( ) { return failover ; } public void setFailover ( boolean failover ) { this . failover = failover ; } public List < Endpoint > getEndpoints ( ) { return endpoints ; } public void setEndpoints ( List < Endpoint > endpoints ) { this . endpoints = endpoints ; } public void setParentEndpoint ( Endpoint parentEndpoint ) { this . parentEndpoint = parentEndpoint ; } public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) { if ( failover ) { send ( synMessageContext ) ; } else { Object o = synMessageContext . getFaultStack ( ) . pop ( ) ; if ( o != null ) { ( ( FaultHandler ) o ) . handleFault ( synMessageContext ) ; } } } } 	1	['15', '1', '0', '18', '52', '37', '3', '15', '14', '0.75', '271', '1', '4', '0', '0.255102041', '0', '0', '16.53333333', '13', '2.0667', '1']
package org . apache . synapse . mediators ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; public abstract class AbstractMediator implements Mediator { protected Log log ; protected static final Log trace = LogFactory . getLog ( SynapseConstants . TRACE_LOGGER ) ; protected int traceState = SynapseConstants . TRACING_UNSET ; protected AbstractMediator ( ) { log = LogFactory . getLog ( this . getClass ( ) ) ; } public String getType ( ) { String cls = getClass ( ) . getName ( ) ; int p = cls . lastIndexOf ( "." ) ; if ( p == - 1 ) return cls ; else return cls . substring ( p + 1 ) ; } public int getTraceState ( ) { return traceState ; } public void setTraceState ( int traceState ) { this . traceState = traceState ; } public void setEffectiveTraceState ( MessageContext synCtx ) { if ( traceState != SynapseConstants . TRACING_UNSET ) { synCtx . setTracingState ( traceState ) ; } } public boolean shouldTrace ( int parentTraceState ) { return ( traceState == SynapseConstants . TRACING_ON ) || ( traceState == SynapseConstants . TRACING_UNSET && parentTraceState == SynapseConstants . TRACING_ON ) ; } protected boolean isTraceOn ( MessageContext msgCtx ) { return ( traceState == SynapseConstants . TRACING_ON ) || ( traceState == SynapseConstants . TRACING_UNSET && msgCtx . getTracingState ( ) == SynapseConstants . TRACING_ON ) ; } protected boolean isTraceOrDebugOn ( boolean isTraceOn ) { return isTraceOn || log . isDebugEnabled ( ) ; } protected void traceOrDebug ( boolean traceOn , String msg ) { if ( traceOn ) { trace . info ( msg ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( msg ) ; } } protected void traceOrDebugWarn ( boolean traceOn , String msg ) { if ( traceOn ) { trace . warn ( msg ) ; } if ( log . isDebugEnabled ( ) ) { log . warn ( msg ) ; } } protected void auditLog ( String msg , MessageContext msgContext ) { log . info ( msg ) ; if ( msgContext . getServiceLog ( ) != null ) { msgContext . getServiceLog ( ) . info ( msg ) ; } if ( shouldTrace ( msgContext . getTracingState ( ) ) ) { trace . info ( msg ) ; } } protected void handleException ( String msg , MessageContext msgContext ) { log . error ( msg ) ; if ( msgContext . getServiceLog ( ) != null ) { msgContext . getServiceLog ( ) . error ( msg ) ; } if ( shouldTrace ( msgContext . getTracingState ( ) ) ) { trace . error ( msg ) ; } throw new SynapseException ( msg ) ; } protected void auditWarn ( String msg , MessageContext msgContext ) { log . warn ( msg ) ; if ( msgContext . getServiceLog ( ) != null ) { msgContext . getServiceLog ( ) . warn ( msg ) ; } if ( shouldTrace ( msgContext . getTracingState ( ) ) ) { trace . warn ( msg ) ; } } protected void handleException ( String msg , Exception e , MessageContext msgContext ) { log . error ( msg , e ) ; if ( msgContext . getServiceLog ( ) != null ) { msgContext . getServiceLog ( ) . error ( msg , e ) ; } if ( shouldTrace ( msgContext . getTracingState ( ) ) ) { trace . error ( msg , e ) ; } throw new SynapseException ( msg , e ) ; } } 	1	['15', '1', '18', '23', '33', '7', '18', '5', '5', '0.476190476', '229', '1', '0', '0', '0.380952381', '0', '0', '14.06666667', '4', '2.3333', '4']
package org . apache . synapse . endpoints . algorithms ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . Endpoint ; public interface LoadbalanceAlgorithm { public Endpoint getNextEndpoint ( MessageContext synapseMessageContext , AlgorithmContext algorithmContext ) ; public void reset ( AlgorithmContext algorithmContext ) ; } 	1	['2', '1', '0', '11', '2', '1', '8', '3', '2', '2', '2', '0', '0', '0', '0.833333333', '0', '0', '0', '1', '1', '1']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . config . xml . endpoints . utils . LoadbalanceAlgorithmFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . LoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; public class LoadbalanceEndpointFactory extends EndpointFactory { private static LoadbalanceEndpointFactory instance = new LoadbalanceEndpointFactory ( ) ; private LoadbalanceEndpointFactory ( ) { } public static LoadbalanceEndpointFactory getInstance ( ) { return instance ; } protected Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { OMElement loadbalanceElement = epConfig . getFirstChildWithName ( new QName ( SynapseConstants . SYNAPSE_NAMESPACE , "loadbalance" ) ) ; if ( loadbalanceElement != null ) { LoadbalanceEndpoint loadbalanceEndpoint = new LoadbalanceEndpoint ( ) ; OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { loadbalanceEndpoint . setName ( name . getAttributeValue ( ) ) ; } ArrayList < Endpoint > endpoints = getEndpoints ( loadbalanceElement , loadbalanceEndpoint ) ; loadbalanceEndpoint . setEndpoints ( endpoints ) ; LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory . createLoadbalanceAlgorithm ( loadbalanceElement , endpoints ) ; loadbalanceEndpoint . setAlgorithm ( algorithm ) ; String failover = loadbalanceElement . getAttributeValue ( new QName ( "failover" ) ) ; if ( failover != null && failover . equalsIgnoreCase ( "false" ) ) { loadbalanceEndpoint . setFailover ( false ) ; } return loadbalanceEndpoint ; } return null ; } } 	1	['4', '2', '0', '7', '19', '4', '1', '7', '1', '0.666666667', '78', '1', '1', '0.818181818', '0.444444444', '1', '1', '18.25', '5', '1.5', '4']
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . axiom . om . impl . dom . DOOMAbstractFactory ; import org . apache . axiom . om . impl . dom . jaxp . DocumentBuilderFactoryImpl ; import org . apache . axiom . om . util . ElementHelper ; import org . apache . axiom . om . util . StAXUtils ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . impl . builder . StAXSOAPModelBuilder ; import org . apache . axis2 . AxisFault ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . apache . synapse . util . AXIOMUtils ; import org . apache . synapse . util . TemporaryData ; import org . apache . synapse . util . TextFileDataSource ; import org . jaxen . JaxenException ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . transform . * ; import javax . xml . transform . dom . DOMResult ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import java . io . * ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class XSLTMediator extends AbstractMediator { public static final String USE_DOM_SOURCE_AND_RESULTS = "http://ws.apache.org/ns/synapse/transform/feature/dom" ; private String xsltKey = null ; private String sourceXPathString = null ; private SynapseXPath source = null ; private String targetPropertyName = null ; private List < MediatorProperty > properties = new ArrayList < MediatorProperty > ( ) ; private List < MediatorProperty > explicitFeatures = new ArrayList < MediatorProperty > ( ) ; private Templates cachedTemplates = null ; private final TransformerFactory transFact = TransformerFactory . newInstance ( ) ; private final Object transformerLock = new Object ( ) ; private boolean useDOMSourceAndResults = false ; public static final String DEFAULT_XPATH = "s11:Body/child::*[position()=1] | " + "s12:Body/child::*[position()=1]" ; public XSLTMediator ( ) { try { this . source = new SynapseXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { String msg = "Error creating default source XPath expression : " + DEFAULT_XPATH ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : XSLT mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } try { performXSLT ( synCtx , traceOrDebugOn , traceOn ) ; } catch ( Exception e ) { handleException ( "Unable to perform XSLT transformation using : " + xsltKey + " against source XPath : " + ( sourceXPathString == null ? DEFAULT_XPATH : " source XPath : " + sourceXPathString ) , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : XSLT mediator" ) ; } return true ; } private void performXSLT ( MessageContext synCtx , final boolean traceOrDebugOn , final boolean traceOn ) { boolean reCreate = false ; OMNode sourceNode = getTransformSource ( synCtx ) ; TemporaryData tempTargetData = null ; OutputStream osForTarget ; boolean isSoapEnvelope = ( sourceNode == synCtx . getEnvelope ( ) ) ; boolean isSoapBody = ( sourceNode == synCtx . getEnvelope ( ) . getBody ( ) ) ; if ( traceOrDebugOn ) { trace . trace ( "Transformation source : " + sourceNode . toString ( ) ) ; } Source transformSrc ; Result transformTgt = null ; if ( useDOMSourceAndResults ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Using a DOMSource for transformation" ) ; } transformSrc = new DOMSource ( ( ( Element ) ElementHelper . importOMElement ( ( OMElement ) sourceNode , DOOMAbstractFactory . getOMFactory ( ) ) ) . getOwnerDocument ( ) ) ; DocumentBuilderFactoryImpl . setDOOMRequired ( true ) ; try { transformTgt = new DOMResult ( DocumentBuilderFactoryImpl . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ) ; } catch ( ParserConfigurationException e ) { handleException ( "Error creating a DOMResult for the transformation," + " Consider setting optimization feature : " + USE_DOM_SOURCE_AND_RESULTS + " off" , e , synCtx ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Using byte array serialization for transformation" ) ; } transformSrc = AXIOMUtils . asSource ( sourceNode ) ; tempTargetData = synCtx . getEnvironment ( ) . createTemporaryData ( ) ; osForTarget = tempTargetData . getOutputStream ( ) ; transformTgt = new StreamResult ( osForTarget ) ; } if ( transformTgt == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Was unable to get a javax.xml.transform.Result created" ) ; } return ; } Entry dp = synCtx . getConfiguration ( ) . getEntryDefinition ( xsltKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { reCreate = true ; } } synchronized ( transformerLock ) { if ( reCreate || cachedTemplates == null ) { try { cachedTemplates = transFact . newTemplates ( SynapseConfigUtils . getStreamSource ( synCtx . getEntry ( xsltKey ) ) ) ; if ( cachedTemplates == null ) { handleException ( "Error compiling the XSLT with key : " + xsltKey , synCtx ) ; } } catch ( Exception e ) { handleException ( "Error creating XSLT transformer using : " + xsltKey , e , synCtx ) ; } } } try { Transformer transformer = cachedTemplates . newTransformer ( ) ; if ( ! properties . isEmpty ( ) ) { for ( MediatorProperty prop : properties ) { if ( prop != null ) { if ( prop . getValue ( ) != null ) { transformer . setParameter ( prop . getName ( ) , prop . getValue ( ) ) ; } else { transformer . setParameter ( prop . getName ( ) , prop . getExpression ( ) . stringValueOf ( synCtx ) ) ; } } } } transformer . setErrorListener ( new ErrorListener ( ) { public void warning ( TransformerException e ) throws TransformerException { if ( traceOrDebugOn ) { traceOrDebugWarn ( traceOn , "Warning encountered during transformation : " + e ) ; } } public void error ( TransformerException e ) throws TransformerException { log . error ( "Error occured in XSLT transformation : " + e ) ; throw e ; } public void fatalError ( TransformerException e ) throws TransformerException { log . error ( "Fatal error occured in the XSLT transformation : " + e ) ; throw e ; } } ) ; transformer . transform ( transformSrc , transformTgt ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Transformation completed - processing result" ) ; } OMElement result = null ; if ( transformTgt instanceof DOMResult ) { Node node = ( ( DOMResult ) transformTgt ) . getNode ( ) ; if ( node == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( "Transformation result (DOMResult) was null" ) ) ; } return ; } Node resultNode = node . getFirstChild ( ) ; if ( resultNode == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( "Transformation result (DOMResult) was empty" ) ) ; } return ; } result = ElementHelper . importOMElement ( ( OMElement ) resultNode , OMAbstractFactory . getOMFactory ( ) ) ; } else { String outputMethod = transformer . getOutputProperty ( OutputKeys . METHOD ) ; String encoding = transformer . getOutputProperty ( OutputKeys . ENCODING ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "output method: " + outputMethod + "; encoding: " + encoding ) ; } if ( "text" . equals ( outputMethod ) ) { result = handleNonXMLResult ( tempTargetData , Charset . forName ( encoding ) , traceOrDebugOn , traceOn ) ; } else { try { XMLStreamReader reader = StAXUtils . createXMLStreamReader ( tempTargetData . getInputStream ( ) ) ; if ( isSoapEnvelope ) { result = new StAXSOAPModelBuilder ( reader ) . getSOAPEnvelope ( ) ; } else { result = new StAXOMBuilder ( reader ) . getDocumentElement ( ) ; } } catch ( XMLStreamException e ) { handleException ( "Error building result element from XSLT transformation" , e , synCtx ) ; } catch ( IOException e ) { handleException ( "Error reading temporary data" , e , synCtx ) ; } } } if ( result == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Transformation result was null" ) ; } return ; } else { if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Transformation result : " + result . toString ( ) ) ; } } if ( targetPropertyName != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Adding result as message context property : " + targetPropertyName ) ; } synCtx . setProperty ( targetPropertyName , result ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Replace " + ( isSoapEnvelope ? "SOAP envelope" : isSoapBody ? "SOAP body" : "node" ) + " with result" ) ; } if ( isSoapEnvelope ) { try { synCtx . setEnvelope ( ( SOAPEnvelope ) result ) ; } catch ( AxisFault ex ) { handleException ( "Unable to replace SOAP envelope with result" , ex , synCtx ) ; } } else if ( isSoapBody ) { for ( Iterator iter = synCtx . getEnvelope ( ) . getBody ( ) . getChildElements ( ) ; iter . hasNext ( ) ; ) { OMElement child = ( OMElement ) iter . next ( ) ; child . detach ( ) ; } for ( Iterator iter = result . getChildElements ( ) ; iter . hasNext ( ) ; ) { OMElement child = ( OMElement ) iter . next ( ) ; synCtx . getEnvelope ( ) . getBody ( ) . addChild ( child ) ; } } else { sourceNode . insertSiblingAfter ( result ) ; sourceNode . detach ( ) ; } } } catch ( TransformerException e ) { handleException ( "Error performing XSLT transformation using : " + xsltKey , e , synCtx ) ; } } private OMNode getTransformSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " did not result in an OMNode" , synCtx ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression : " + source , e , synCtx ) ; } return null ; } public SynapseXPath getSource ( ) { return source ; } public void setSource ( SynapseXPath source ) { this . source = source ; } public String getXsltKey ( ) { return xsltKey ; } public void setXsltKey ( String xsltKey ) { this . xsltKey = xsltKey ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addFeature ( String featureName , boolean isFeatureEnable ) { try { MediatorProperty mp = new MediatorProperty ( ) ; mp . setName ( featureName ) ; if ( isFeatureEnable ) { mp . setValue ( "true" ) ; } else { mp . setValue ( "false" ) ; } explicitFeatures . add ( mp ) ; if ( USE_DOM_SOURCE_AND_RESULTS . equals ( featureName ) ) { useDOMSourceAndResults = isFeatureEnable ; } else { transFact . setFeature ( featureName , isFeatureEnable ) ; } } catch ( TransformerConfigurationException e ) { String msg = "Error occured when setting features to the TransformerFactory" ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } private OMElement handleNonXMLResult ( TemporaryData tempData , Charset charset , boolean traceOrDebugOn , boolean traceOn ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Processing non SOAP/XML (text) transformation result" ) ; } if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Wrapping text transformation result" ) ; } return TextFileDataSource . createOMSourcedElement ( tempData , charset ) ; } public List < MediatorProperty > getFeatures ( ) { return explicitFeatures ; } public void addAllProperties ( List < MediatorProperty > list ) { properties . addAll ( list ) ; } public List < MediatorProperty > getProperties ( ) { return properties ; } public void setSourceXPathString ( String sourceXPathString ) { this . sourceXPathString = sourceXPathString ; } public String getTargetPropertyName ( ) { return targetPropertyName ; } public void setTargetPropertyName ( String targetPropertyName ) { this . targetPropertyName = targetPropertyName ; } } 	1	['20', '2', '0', '31', '107', '104', '3', '29', '14', '0.872807018', '844', '0.833333333', '1', '0.40625', '0.185', '0', '0', '40.6', '39', '3.5', '6']
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import org . wso2 . mercury . util . MercuryClientConstants ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class RMSequenceMediator extends AbstractMediator { private SynapseXPath correlation = null ; private SynapseXPath lastMessage = null ; private Boolean single = null ; private String version = null ; private static final String WSRM_SpecVersion_1_0 = "Spec_2005_02" ; private static final String WSRM_SpecVersion_1_1 = "Spec_2007_02" ; private static final long SEQUENCE_EXPIRY_TIME = 300000 ; private static Map sequenceMap = Collections . synchronizedMap ( new HashMap ( ) ) ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : RMSequence mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( ! ( synCtx instanceof Axis2MessageContext ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Only axis2 message contexts are supported" ) ; } } else { Axis2MessageContext axis2MessageCtx = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext orgMessageCtx = axis2MessageCtx . getAxis2MessageContext ( ) ; cleanupSequenceMap ( ) ; String version = getVersionValue ( ) ; orgMessageCtx . getOptions ( ) . setProperty ( SynapseConstants . MERCURY_SPEC_VERSION , version ) ; if ( isSingle ( ) ) { String sequenceID = UUIDGenerator . getUUID ( ) ; String offeredSeqID = UUIDGenerator . getUUID ( ) ; orgMessageCtx . getOptions ( ) . setProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY , sequenceID ) ; orgMessageCtx . getOptions ( ) . setProperty ( MercuryClientConstants . SEQUENCE_OFFER , offeredSeqID ) ; orgMessageCtx . getOptions ( ) . setProperty ( SynapseConstants . MERCURY_LAST_MESSAGE , "true" ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Using WS-RM version " + version + " and a single message sequence : " + sequenceID + " and offering sequence : " + offeredSeqID ) ; } } else { String correlationValue = getCorrelationValue ( synCtx ) ; boolean lastMessage = isLastMessage ( synCtx ) ; String offeredSeqID = null ; if ( ! sequenceMap . containsKey ( correlationValue ) ) { offeredSeqID = UUIDGenerator . getUUID ( ) ; orgMessageCtx . getOptions ( ) . setProperty ( MercuryClientConstants . SEQUENCE_OFFER , offeredSeqID ) ; } String sequenceID = retrieveSequenceID ( correlationValue ) ; orgMessageCtx . getOptions ( ) . setProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY , sequenceID ) ; if ( lastMessage ) { orgMessageCtx . getOptions ( ) . setProperty ( SynapseConstants . MERCURY_LAST_MESSAGE , "true" ) ; sequenceMap . remove ( correlationValue ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Correlation value : " + correlationValue + " last message = " + lastMessage + " using sequence : " + sequenceID + ( offeredSeqID != null ? " offering sequence : " + offeredSeqID : "" ) ) ; } } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : RMSequence mediator" ) ; } return true ; } private String retrieveSequenceID ( String correlationValue ) { String sequenceID = null ; if ( ! sequenceMap . containsKey ( correlationValue ) ) { sequenceID = UUIDGenerator . getUUID ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "setting sequenceID " + sequenceID + " for correlation " + correlationValue ) ; } Entry sequenceEntry = new Entry ( ) ; sequenceEntry . setValue ( sequenceID ) ; sequenceEntry . setExpiryTime ( System . currentTimeMillis ( ) + SEQUENCE_EXPIRY_TIME ) ; sequenceMap . put ( correlationValue , sequenceEntry ) ; } else { sequenceID = ( String ) ( ( Entry ) sequenceMap . get ( correlationValue ) ) . getValue ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "got sequenceID " + sequenceID + " for correlation " + correlationValue ) ; } } return sequenceID ; } private String getCorrelationValue ( MessageContext smc ) { OMElement node = null ; try { node = ( OMElement ) getCorrelation ( ) . selectSingleNode ( smc ) ; if ( node != null ) { return node . getText ( ) ; } else { handleException ( "XPath expression : " + getCorrelation ( ) + " did not return any node" , smc ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression to determine correlation : " + getCorrelation ( ) , e , smc ) ; } return null ; } private String getVersionValue ( ) { if ( XMLConfigConstants . SEQUENCE_VERSION_1_1 . equals ( getVersion ( ) ) ) { return WSRM_SpecVersion_1_1 ; } else { return WSRM_SpecVersion_1_0 ; } } private boolean isLastMessage ( MessageContext smc ) { if ( getLastMessage ( ) == null ) { return false ; } else { try { return getLastMessage ( ) . booleanValueOf ( smc ) ; } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression to determine if last message : " + getLastMessage ( ) , e , smc ) ; } return false ; } } private synchronized void cleanupSequenceMap ( ) { Iterator itKey = sequenceMap . keySet ( ) . iterator ( ) ; while ( itKey . hasNext ( ) ) { Object key = itKey . next ( ) ; Entry sequenceEntry = ( Entry ) sequenceMap . get ( key ) ; if ( sequenceEntry . isExpired ( ) ) { sequenceMap . remove ( key ) ; } } } public boolean isSingle ( ) { if ( getSingle ( ) != null && getSingle ( ) . booleanValue ( ) ) { return true ; } else { return false ; } } public SynapseXPath getCorrelation ( ) { return correlation ; } public void setCorrelation ( SynapseXPath correlation ) { this . correlation = correlation ; } public SynapseXPath getLastMessage ( ) { return lastMessage ; } public void setLastMessage ( SynapseXPath lastMessage ) { this . lastMessage = lastMessage ; } public Boolean getSingle ( ) { return single ; } public void setSingle ( Boolean single ) { this . single = single ; } public String getVersion ( ) { return version ; } public void setVersion ( String version ) { this . version = version ; } } 	1	['17', '2', '0', '14', '58', '100', '2', '12', '11', '0.90625', '444', '1', '2', '0.464285714', '0.3', '0', '0', '24.64705882', '12', '2.0588', '2']
package org . apache . synapse . mediators . db ; import org . apache . synapse . MessageContext ; import java . sql . PreparedStatement ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . sql . Connection ; import java . util . Iterator ; public class DBLookupMediator extends AbstractDBMediator { protected void processStatement ( Statement stmnt , MessageContext msgCtx ) { boolean traceOn = isTraceOn ( msgCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; Connection con = null ; try { PreparedStatement ps = getPreparedStatement ( stmnt , msgCtx ) ; con = ps . getConnection ( ) ; ResultSet rs = ps . executeQuery ( ) ; if ( rs . next ( ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Processing the first row returned : " + stmnt . getRawStatement ( ) ) ; } Iterator propNameIter = stmnt . getResultsMap ( ) . keySet ( ) . iterator ( ) ; while ( propNameIter . hasNext ( ) ) { String propName = ( String ) propNameIter . next ( ) ; String columnStr = ( String ) stmnt . getResultsMap ( ) . get ( propName ) ; Object obj = null ; try { int colNum = Integer . parseInt ( columnStr ) ; obj = rs . getObject ( colNum ) ; } catch ( NumberFormatException ignore ) { obj = rs . getObject ( columnStr ) ; } if ( obj != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Column : " + columnStr + " returned value : " + obj + " Setting this as the message property : " + propName ) ; } msgCtx . setProperty ( propName , obj . toString ( ) ) ; } else { if ( traceOrDebugOn ) { traceOrDebugWarn ( traceOn , "Column : " + columnStr + " returned null Skip setting message property : " + propName ) ; } } } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Statement : " + stmnt . getRawStatement ( ) + " returned 0 rows" ) ; } } } catch ( SQLException e ) { handleException ( "Error executing statement : " + stmnt . getRawStatement ( ) + " against DataSource : " + getDSName ( ) , e , msgCtx ) ; } finally { if ( con != null ) { try { con . close ( ) ; } catch ( SQLException ignore ) { } } } } } 	1	['2', '3', '0', '5', '30', '1', '3', '3', '1', '2', '183', '0', '0', '0.962962963', '0.666666667', '2', '5', '90.5', '9', '4.5', '1']
package org . apache . synapse . endpoints ; import org . apache . axis2 . clustering . ClusterManager ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . impl . EndPointStatisticsStack ; public class AddressEndpoint extends DefaultEndpoint { private final EndpointContext endpointContext = new EndpointContext ( ) ; public boolean isActive ( MessageContext synMessageContext ) { boolean active = endpointContext . isActive ( ) ; if ( ! active ) { long recoverOn = endpointContext . getRecoverOn ( ) ; if ( System . currentTimeMillis ( ) > recoverOn ) { active = true ; endpointContext . setActive ( true ) ; endpointContext . setRecoverOn ( 0 ) ; } } if ( log . isDebugEnabled ( ) ) { log . debug ( "AddressEndpoint with name '" + getName ( ) + "' is in " + ( active ? "active" : "inactive" ) + " state" ) ; } return active ; } public synchronized void setActive ( boolean active , MessageContext synMessageContext ) { if ( ! active ) { EndpointDefinition endpoint = getEndpoint ( ) ; if ( endpoint . getSuspendOnFailDuration ( ) != - 1 ) { endpointContext . setRecoverOn ( System . currentTimeMillis ( ) + endpoint . getSuspendOnFailDuration ( ) ) ; } else { endpointContext . setRecoverOn ( Long . MAX_VALUE ) ; } } this . endpointContext . setActive ( active ) ; } public void send ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Address Endpoint" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } boolean isClusteringEnable = false ; org . apache . axis2 . context . MessageContext axisMC = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; ConfigurationContext cc = axisMC . getConfigurationContext ( ) ; ClusterManager clusterManager = cc . getAxisConfiguration ( ) . getClusterManager ( ) ; if ( clusterManager != null && clusterManager . getContextManager ( ) != null ) { isClusteringEnable = true ; } String endPointName = this . getName ( ) ; if ( endPointName == null ) { if ( traceOrDebugOn && isClusteringEnable ) { log . warn ( SALoadbalanceEndpoint . WARN_MESSAGE ) ; } endPointName = SynapseConstants . ANONYMOUS_ENDPOINT ; } if ( isClusteringEnable ) { if ( endpointContext . getConfigurationContext ( ) == null ) { endpointContext . setConfigurationContext ( cc ) ; endpointContext . setContextID ( endPointName ) ; } } EndpointDefinition endpoint = getEndpoint ( ) ; boolean statisticsEnable = ( SynapseConstants . STATISTICS_ON == endpoint . getStatisticsState ( ) ) ; if ( statisticsEnable ) { EndPointStatisticsStack endPointStatisticsStack = null ; Object statisticsStackObj = synCtx . getProperty ( org . apache . synapse . SynapseConstants . ENDPOINT_STATS ) ; if ( statisticsStackObj == null ) { endPointStatisticsStack = new EndPointStatisticsStack ( ) ; synCtx . setProperty ( org . apache . synapse . SynapseConstants . ENDPOINT_STATS , endPointStatisticsStack ) ; } else if ( statisticsStackObj instanceof EndPointStatisticsStack ) { endPointStatisticsStack = ( EndPointStatisticsStack ) statisticsStackObj ; } if ( endPointStatisticsStack != null ) { boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; endPointStatisticsStack . put ( endPointName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statisticsEnable , isFault ) ; } } if ( endpoint . getAddress ( ) != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Sending message to endpoint : " + endPointName + " resolves to address = " + endpoint . getAddress ( ) ) ; traceOrDebug ( traceOn , "SOAPAction: " + ( synCtx . getSoapAction ( ) != null ? synCtx . getSoapAction ( ) : "null" ) ) ; traceOrDebug ( traceOn , "WSA-Action: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Envelope : \n" + synCtx . getEnvelope ( ) ) ; } } } synCtx . pushFaultHandler ( this ) ; synCtx . setProperty ( SynapseConstants . PROCESSED_ENDPOINT , this ) ; synCtx . getEnvironment ( ) . send ( endpoint , synCtx ) ; } public void onFault ( MessageContext synCtx ) { setActive ( false , synCtx ) ; super . onFault ( synCtx ) ; } } 	1	['5', '3', '0', '20', '51', '0', '4', '16', '5', '0', '319', '1', '1', '0.818181818', '0.666666667', '2', '3', '62.6', '23', '6.4', '1']
package org . apache . synapse . mediators ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . SynapseEnvironment ; import java . util . ArrayList ; import java . util . List ; public abstract class AbstractListMediator extends AbstractMediator implements ListMediator , ManagedLifecycle { protected List < Mediator > mediators = new ArrayList < Mediator > ( ) ; public boolean mediate ( MessageContext synCtx ) { int parentsEffectiveTraceState = synCtx . getTracingState ( ) ; setEffectiveTraceState ( synCtx ) ; int myEffectiveTraceState = synCtx . getTracingState ( ) ; try { if ( isTraceOrDebugOn ( isTraceOn ( synCtx ) ) ) { traceOrDebug ( isTraceOn ( synCtx ) , "Sequence <" + getType ( ) + "> :: mediate()" ) ; } for ( Mediator mediator : mediators ) { synCtx . setTracingState ( myEffectiveTraceState ) ; if ( ! mediator . mediate ( synCtx ) ) { return false ; } } } finally { synCtx . setTracingState ( parentsEffectiveTraceState ) ; } return true ; } public List getList ( ) { return mediators ; } public boolean addChild ( Mediator m ) { return mediators . add ( m ) ; } public boolean addAll ( List < Mediator > c ) { return mediators . addAll ( c ) ; } public Mediator getChild ( int pos ) { return mediators . get ( pos ) ; } public boolean removeChild ( Mediator m ) { return mediators . remove ( m ) ; } public Mediator removeChild ( int pos ) { return mediators . remove ( pos ) ; } public void init ( SynapseEnvironment se ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Initializing child mediators" ) ; } for ( Object mediator : mediators ) { Mediator m = ( Mediator ) mediator ; if ( m instanceof ManagedLifecycle ) { ( ( ManagedLifecycle ) m ) . init ( se ) ; } } } public void destroy ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Destroying child mediators" ) ; } for ( Mediator mediator : mediators ) { if ( mediator instanceof ManagedLifecycle ) { ( ( ManagedLifecycle ) mediator ) . destroy ( ) ; } } } } 	1	['10', '2', '7', '14', '35', '0', '7', '7', '10', '0', '176', '1', '0', '0.590909091', '0.283333333', '0', '0', '16.5', '3', '1.5', '2']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . OperationClient ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . context . ServiceGroupContext ; import org . apache . axis2 . description . AxisOperation ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisServiceGroup ; import org . apache . axis2 . description . WSDL2Constants ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . util . MessageHelper ; import javax . xml . namespace . QName ; import java . util . ArrayList ; public class Axis2FlexibleMEPClient { private static final Log log = LogFactory . getLog ( Axis2FlexibleMEPClient . class ) ; public static void send ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseOutMessageContext ) throws AxisFault { boolean separateListener = false ; boolean wsSecurityEnabled = false ; String wsSecPolicyKey = null ; boolean wsRMEnabled = false ; String wsRMPolicyKey = null ; boolean wsAddressingEnabled = false ; String wsAddressingVersion = null ; if ( endpoint != null ) { separateListener = endpoint . isUseSeparateListener ( ) ; wsSecurityEnabled = endpoint . isSecurityOn ( ) ; wsSecPolicyKey = endpoint . getWsSecPolicyKey ( ) ; wsRMEnabled = endpoint . isReliableMessagingOn ( ) ; wsRMPolicyKey = endpoint . getWsRMPolicyKey ( ) ; wsAddressingEnabled = endpoint . isAddressingOn ( ) || wsSecurityEnabled || wsRMEnabled ; wsAddressingVersion = endpoint . getAddressingVersion ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Sending [add = " + wsAddressingEnabled + "] [sec = " + wsSecurityEnabled + "] [rm = " + wsRMEnabled + ( endpoint != null ? "] [mtom = " + endpoint . isUseMTOM ( ) + "] [swa = " + endpoint . isUseSwa ( ) + "] [format = " + endpoint . getFormat ( ) + "] [force soap11=" + endpoint . isForceSOAP11 ( ) + "] [force soap12=" + endpoint . isForceSOAP12 ( ) + "] [pox=" + endpoint . isForcePOX ( ) + "] [get=" + endpoint . isForceGET ( ) + "] [encoding=" + endpoint . getCharSetEncoding ( ) : "" ) + "] [to " + synapseOutMessageContext . getTo ( ) + "]" ) ; } MessageContext originalInMsgCtx = ( ( Axis2MessageContext ) synapseOutMessageContext ) . getAxis2MessageContext ( ) ; MessageContext axisOutMsgCtx = cloneForSend ( originalInMsgCtx ) ; if ( endpoint != null ) { if ( SynapseConstants . FORMAT_POX . equals ( endpoint . getFormat ( ) ) ) { axisOutMsgCtx . setDoingREST ( true ) ; } else if ( SynapseConstants . FORMAT_GET . equals ( endpoint . getFormat ( ) ) ) { axisOutMsgCtx . setDoingREST ( true ) ; axisOutMsgCtx . setProperty ( Constants . Configuration . HTTP_METHOD , Constants . Configuration . HTTP_METHOD_GET ) ; } else if ( SynapseConstants . FORMAT_SOAP11 . equals ( endpoint . getFormat ( ) ) ) { axisOutMsgCtx . setDoingREST ( false ) ; axisOutMsgCtx . removeProperty ( org . apache . axis2 . Constants . Configuration . MESSAGE_TYPE ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } if ( ! axisOutMsgCtx . isSOAP11 ( ) ) { SOAPUtils . convertSOAP12toSOAP11 ( axisOutMsgCtx ) ; } } else if ( SynapseConstants . FORMAT_SOAP12 . equals ( endpoint . getFormat ( ) ) ) { axisOutMsgCtx . setDoingREST ( false ) ; axisOutMsgCtx . removeProperty ( org . apache . axis2 . Constants . Configuration . MESSAGE_TYPE ) ; if ( axisOutMsgCtx . getSoapAction ( ) == null && axisOutMsgCtx . getWSAAction ( ) != null ) { axisOutMsgCtx . setSoapAction ( axisOutMsgCtx . getWSAAction ( ) ) ; } if ( axisOutMsgCtx . isSOAP11 ( ) ) { SOAPUtils . convertSOAP11toSOAP12 ( axisOutMsgCtx ) ; } } if ( endpoint . isUseMTOM ( ) ) { axisOutMsgCtx . setDoingMTOM ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingMTOM ( true ) ; } else if ( endpoint . isUseSwa ( ) ) { axisOutMsgCtx . setDoingSwA ( true ) ; axisOutMsgCtx . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; axisOutMsgCtx . setDoingSwA ( true ) ; } if ( endpoint . getCharSetEncoding ( ) != null ) { axisOutMsgCtx . setProperty ( Constants . Configuration . CHARACTER_SET_ENCODING , endpoint . getCharSetEncoding ( ) ) ; } if ( endpoint . getAddress ( ) != null ) { axisOutMsgCtx . setTo ( new EndpointReference ( endpoint . getAddress ( ) ) ) ; } if ( endpoint . isUseSeparateListener ( ) ) { axisOutMsgCtx . getOptions ( ) . setUseSeparateListener ( true ) ; } } if ( wsAddressingEnabled ) { if ( wsAddressingVersion != null && SynapseConstants . ADDRESSING_VERSION_SUBMISSION . equals ( wsAddressingVersion ) ) { axisOutMsgCtx . setProperty ( AddressingConstants . WS_ADDRESSING_VERSION , AddressingConstants . Submission . WSA_NAMESPACE ) ; } else if ( wsAddressingVersion != null && SynapseConstants . ADDRESSING_VERSION_FINAL . equals ( wsAddressingVersion ) ) { axisOutMsgCtx . setProperty ( AddressingConstants . WS_ADDRESSING_VERSION , AddressingConstants . Final . WSA_NAMESPACE ) ; } axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } else { axisOutMsgCtx . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; } ConfigurationContext axisCfgCtx = axisOutMsgCtx . getConfigurationContext ( ) ; AxisConfiguration axisCfg = axisCfgCtx . getAxisConfiguration ( ) ; AxisService anoymousService = AnonymousServiceFactory . getAnonymousService ( synapseOutMessageContext . getConfiguration ( ) , axisCfg , wsAddressingEnabled , wsRMEnabled , wsSecurityEnabled ) ; ServiceGroupContext sgc = new ServiceGroupContext ( axisCfgCtx , ( AxisServiceGroup ) anoymousService . getParent ( ) ) ; ServiceContext serviceCtx = sgc . getServiceContext ( anoymousService ) ; boolean outOnlyMessage = "true" . equals ( synapseOutMessageContext . getProperty ( SynapseConstants . OUT_ONLY ) ) || WSDL2Constants . MEP_URI_IN_ONLY . equals ( originalInMsgCtx . getOperationContext ( ) . getAxisOperation ( ) . getMessageExchangePattern ( ) ) ; AxisOperation axisAnonymousOperation = anoymousService . getOperation ( outOnlyMessage ? new QName ( AnonymousServiceFactory . OUT_ONLY_OPERATION ) : new QName ( AnonymousServiceFactory . OUT_IN_OPERATION ) ) ; Options clientOptions = new Options ( ) ; clientOptions . setUseSeparateListener ( separateListener ) ; if ( wsRMEnabled ) { if ( wsRMPolicyKey != null ) { clientOptions . setProperty ( SynapseConstants . SANDESHA_POLICY , getPolicy ( synapseOutMessageContext , wsRMPolicyKey ) ) ; } copyRMOptions ( originalInMsgCtx , clientOptions ) ; } if ( wsSecurityEnabled ) { if ( wsSecPolicyKey != null ) { clientOptions . setProperty ( SynapseConstants . RAMPART_POLICY , getPolicy ( synapseOutMessageContext , wsSecPolicyKey ) ) ; } if ( axisOutMsgCtx . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = axisOutMsgCtx . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( axisOutMsgCtx . getEnvelope ( ) ) ; } } OperationClient mepClient = axisAnonymousOperation . createClient ( serviceCtx , clientOptions ) ; mepClient . addMessageContext ( axisOutMsgCtx ) ; axisOutMsgCtx . setAxisMessage ( axisAnonymousOperation . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; if ( ! outOnlyMessage ) { AsyncCallback callback = new AsyncCallback ( synapseOutMessageContext ) ; if ( endpoint != null ) { callback . setTimeOutOn ( System . currentTimeMillis ( ) + endpoint . getTimeoutDuration ( ) ) ; callback . setTimeOutAction ( endpoint . getTimeoutAction ( ) ) ; } else { callback . setTimeOutOn ( System . currentTimeMillis ( ) ) ; } mepClient . setCallback ( callback ) ; } originalInMsgCtx . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; mepClient . execute ( true ) ; } private static MessageContext cloneForSend ( MessageContext ori ) throws AxisFault { MessageContext newMC = MessageHelper . clonePartially ( ori ) ; newMC . setEnvelope ( ori . getEnvelope ( ) ) ; removeAddressingHeaders ( newMC ) ; newMC . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , ori . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ) ; return newMC ; } private static void copyRMOptions ( MessageContext oriContext , Options targetOptions ) { Options oriOptions = oriContext . getOptions ( ) ; if ( oriOptions . getProperty ( SynapseConstants . MERCURY_LAST_MESSAGE ) != null ) { targetOptions . setProperty ( SynapseConstants . MERCURY_LAST_MESSAGE , oriOptions . getProperty ( SynapseConstants . MERCURY_LAST_MESSAGE ) ) ; } if ( oriOptions . getProperty ( SynapseConstants . MERCURY_SPEC_VERSION ) != null ) { targetOptions . setProperty ( SynapseConstants . MERCURY_SPEC_VERSION , oriOptions . getProperty ( SynapseConstants . MERCURY_SPEC_VERSION ) ) ; } if ( oriOptions . getProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY ) != null ) { targetOptions . setProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY , oriOptions . getProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY ) ) ; } } private static Policy getPolicy ( org . apache . synapse . MessageContext synCtx , String propertyKey ) { Object property = synCtx . getEntry ( propertyKey ) ; if ( property != null && property instanceof OMElement ) { return PolicyEngine . getPolicy ( ( OMElement ) property ) ; } else { handleException ( "Cannot locate policy from the property : " + propertyKey ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public static SOAPEnvelope removeAddressingHeaders ( MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { for ( Object o : headerInformation ) { if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1	['9', '1', '0', '38', '102', '30', '1', '37', '3', '0.625', '620', '1', '0', '0', '0.196428571', '0', '0', '67.77777778', '6', '2.2222', '9']
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . apache . synapse . util . AXIOMUtils ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . DefaultHandler ; import javax . xml . XMLConstants ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import javax . xml . validation . Schema ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class ValidateMediator extends AbstractListMediator { private List < String > schemaKeys = new ArrayList < String > ( ) ; private SynapseXPath source = null ; private List < MediatorProperty > explicityFeatures = new ArrayList < MediatorProperty > ( ) ; private Schema cachedSchema ; private final Object validatorLock = new Object ( ) ; private SchemaFactory factory = SchemaFactory . newInstance ( XMLConstants . W3C_XML_SCHEMA_NS_URI ) ; public static final String DEFAULT_XPATH = "s11:Body/child::*[position()=1] | " + "s12:Body/child::*[position()=1]" ; public ValidateMediator ( ) { try { this . source = new SynapseXPath ( DEFAULT_XPATH ) ; this . source . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; this . source . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { String msg = "Error creating default source XPath expression : " + DEFAULT_XPATH ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Validate mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } Source validateSrc = getValidationSource ( synCtx , traceOrDebugOn , traceOn ) ; boolean reCreate = false ; for ( String propKey : schemaKeys ) { Entry dp = synCtx . getConfiguration ( ) . getEntryDefinition ( propKey ) ; if ( dp != null && dp . isDynamic ( ) ) { if ( ! dp . isCached ( ) || dp . isExpired ( ) ) { reCreate = true ; } } } MyErrorHandler errorHandler = new MyErrorHandler ( ) ; synchronized ( validatorLock ) { if ( reCreate || cachedSchema == null ) { factory . setErrorHandler ( errorHandler ) ; StreamSource [ ] sources = new StreamSource [ schemaKeys . size ( ) ] ; int i = 0 ; for ( String propName : schemaKeys ) { sources [ i ++ ] = SynapseConfigUtils . getStreamSource ( synCtx . getEntry ( propName ) ) ; } try { cachedSchema = factory . newSchema ( sources ) ; } catch ( SAXException e ) { handleException ( "Error creating a new schema objects for " + "schemas : " + schemaKeys . toString ( ) , e , synCtx ) ; } if ( errorHandler . isValidationError ( ) ) { errorHandler . setValidationError ( false ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Error creating a new schema objects for " + "schemas : " + schemaKeys . toString ( ) ) ; } } } } try { Validator validator = cachedSchema . newValidator ( ) ; validator . setErrorHandler ( errorHandler ) ; validator . validate ( validateSrc ) ; if ( errorHandler . isValidationError ( ) ) { if ( traceOrDebugOn ) { String msg = "Validation of element returned by XPath : " + source + " failed against the given schema(s) " + schemaKeys + "with error : " + errorHandler . getSaxParseException ( ) . getMessage ( ) + " Executing 'on-fail' sequence" ; traceOrDebug ( traceOn , msg ) ; synCtx . getServiceLog ( ) . warn ( msg ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { log . debug ( "Failed message envelope : " + synCtx . getEnvelope ( ) ) ; } } synCtx . setProperty ( SynapseConstants . ERROR_MESSAGE , errorHandler . getSaxParseException ( ) . getMessage ( ) ) ; synCtx . setProperty ( SynapseConstants . ERROR_EXCEPTION , errorHandler . getSaxParseException ( ) ) ; synCtx . setProperty ( SynapseConstants . ERROR_DETAIL , FaultHandler . getStackTrace ( errorHandler . getSaxParseException ( ) ) ) ; return super . mediate ( synCtx ) ; } } catch ( SAXException e ) { handleException ( "Error validating " + source + " element" , e , synCtx ) ; } catch ( IOException e ) { handleException ( "Error validating " + source + " element" , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Validation of element returned by the XPath expression : " + source + " succeeded against the given schemas and the current message" ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Validate mediator" ) ; } return true ; } private Source getValidationSource ( MessageContext synCtx , boolean traceOrDebugOn , boolean traceOn ) { try { OMNode validateSource = getValidateSource ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Validation source : " + validateSource . toString ( ) ) ; } return AXIOMUtils . asSource ( validateSource ) ; } catch ( Exception e ) { handleException ( "Error accessing source element : " + source , e , synCtx ) ; } return null ; } private class MyErrorHandler extends DefaultHandler { private boolean validationError = false ; private SAXParseException saxParseException = null ; public void error ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void fatalError ( SAXParseException exception ) throws SAXException { validationError = true ; saxParseException = exception ; } public void warning ( SAXParseException exception ) throws SAXException { } public boolean isValidationError ( ) { return validationError ; } public SAXParseException getSaxParseException ( ) { return saxParseException ; } public void setValidationError ( boolean validationError ) { this . validationError = validationError ; } } private OMNode getValidateSource ( MessageContext synCtx ) { try { Object o = source . evaluate ( synCtx ) ; if ( o instanceof OMNode ) { return ( OMNode ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMNode ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression " + source + " did not result in an OMNode : " + o , synCtx ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression : " + source , e , synCtx ) ; } return null ; } public Object getFeature ( String key ) { for ( MediatorProperty prop : explicityFeatures ) { if ( key . equals ( prop . getName ( ) ) ) { return prop . getValue ( ) ; } } return null ; } public void addFeature ( String featureName , boolean isFeatureEnable ) throws SAXException { MediatorProperty mp = new MediatorProperty ( ) ; mp . setName ( featureName ) ; if ( isFeatureEnable ) { mp . setValue ( "true" ) ; } else { mp . setValue ( "false" ) ; } explicityFeatures . add ( mp ) ; factory . setFeature ( featureName , isFeatureEnable ) ; } public void setSchemaKeys ( List < String > schemaKeys ) { this . schemaKeys = schemaKeys ; } public void setSource ( SynapseXPath source ) { this . source = source ; } public SynapseXPath getSource ( ) { return source ; } public List < String > getSchemaKeys ( ) { return schemaKeys ; } public List < MediatorProperty > getFeatures ( ) { return explicityFeatures ; } } 	1	['11', '3', '0', '18', '71', '1', '3', '16', '9', '0.814285714', '542', '0.857142857', '1', '0.6875', '0.303030303', '1', '3', '47.63636364', '16', '2.7273', '1']
package org . apache . synapse . endpoints ; import org . apache . axis2 . clustering . ClusteringFault ; import org . apache . axis2 . clustering . context . Replicator ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; public class EndpointContext { private static final Log log = LogFactory . getLog ( EndpointContext . class ) ; private static final String ACTIVE = "active" ; private static final String RECOVER_ON = "recover_on" ; private static final String UNDERSCORE_STRING = "_" ; private boolean active = true ; private long recoverOn = Long . MAX_VALUE ; private ConfigurationContext configCtx ; private String activePropertyKey ; private String recoverOnPropertyKey ; private boolean isClusteringEnable = false ; public boolean isActive ( ) { if ( this . isClusteringEnable ) { if ( this . activePropertyKey == null || "" . equals ( this . activePropertyKey ) ) { handleException ( "Cannot find the required key to find the " + "shared state of 'active' attribute" ) ; } Object value = this . configCtx . getPropertyNonReplicable ( this . activePropertyKey ) ; if ( value == null ) { return true ; } if ( value instanceof Boolean ) { return ( ( Boolean ) value ) . booleanValue ( ) ; } else if ( value instanceof String ) { return Boolean . parseBoolean ( ( String ) value ) ; } else { handleException ( "Unsupported object type for value" + value ) ; } } else { return active ; } throw new SynapseException ( "Invalid states in endpoint context" ) ; } public synchronized void setActive ( boolean active ) { if ( this . isClusteringEnable ) { setAndReplicateState ( this . activePropertyKey , active ) ; } else { this . active = active ; } } public long getRecoverOn ( ) { if ( this . isClusteringEnable ) { if ( this . recoverOnPropertyKey == null || "" . equals ( this . recoverOnPropertyKey ) ) { handleException ( "Cannot find the required key to find the " + "shared state of 'recoveOn' attribute" ) ; } Object value = this . configCtx . getPropertyNonReplicable ( this . recoverOnPropertyKey ) ; if ( value == null ) { return Long . MAX_VALUE ; } if ( value instanceof Long ) { return ( ( Long ) value ) . longValue ( ) ; } else if ( value instanceof String ) { try { return Long . parseLong ( ( String ) value ) ; } catch ( NumberFormatException e ) { return Long . MAX_VALUE ; } } else { handleException ( "Unsupported object type for value" + value ) ; } } else { return recoverOn ; } throw new SynapseException ( "Invalid states in endpoint context" ) ; } public void setRecoverOn ( long recoverOn ) { if ( this . isClusteringEnable ) { setAndReplicateState ( this . recoverOnPropertyKey , recoverOn ) ; } else { this . recoverOn = recoverOn ; } } public ConfigurationContext getConfigurationContext ( ) { return configCtx ; } public void setConfigurationContext ( ConfigurationContext configCtx ) { if ( configCtx == null ) { handleException ( "The ConfigurationContext cannot be null" + " when system in a cluster environment" ) ; } this . configCtx = configCtx ; this . isClusteringEnable = true ; } public void setContextID ( String contextID ) { if ( contextID == null || "" . equals ( contextID ) ) { handleException ( "The Context ID cannot be null when system in a cluster environment" ) ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( contextID ) ; buffer . append ( UNDERSCORE_STRING ) ; String prefix = buffer . toString ( ) ; this . recoverOnPropertyKey = prefix + RECOVER_ON ; this . activePropertyKey = prefix + ACTIVE ; } private void setAndReplicateState ( String key , Object value ) { if ( configCtx != null && key != null && value != null ) { try { if ( log . isDebugEnabled ( ) ) { log . debug ( "Start replicating the property with key : " + key + " value : " + value ) ; } configCtx . setProperty ( key , value ) ; Replicator . replicate ( configCtx , new String [ ] { key } ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Completed replication of the property with key : " + key ) ; } } catch ( ClusteringFault clusteringFault ) { handleException ( "Error during the replicating states " , clusteringFault ) ; } } } protected void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } protected void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1	['12', '1', '0', '12', '37', '2', '5', '7', '8', '0.772727273', '319', '1', '0', '0', '0.25974026', '0', '0', '24.75', '7', '2.5833', '1']
package org . apache . synapse . config . xml ; import java . util . Iterator ; import javax . xml . namespace . QName ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . ResourceMap ; public class ResourceMapFactory { private static final Log log = LogFactory . getLog ( ResourceMapFactory . class ) ; public static ResourceMap createResourceMap ( OMElement elem ) { ResourceMap resourceMap = null ; Iterator it = elem . getChildrenWithName ( new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "resource" ) ) ; while ( it . hasNext ( ) ) { if ( resourceMap == null ) { resourceMap = new ResourceMap ( ) ; } OMElement resourceElem = ( OMElement ) it . next ( ) ; OMAttribute location = resourceElem . getAttribute ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "location" ) ) ; if ( location == null ) { handleException ( "The 'location' attribute is required for a resource definition" ) ; } OMAttribute key = resourceElem . getAttribute ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "key" ) ) ; if ( key == null ) { handleException ( "The 'key' attribute is required for a resource definition" ) ; } resourceMap . addResource ( location . getAttributeValue ( ) , key . getAttributeValue ( ) ) ; } return resourceMap ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1	['4', '1', '0', '7', '16', '4', '1', '6', '2', '0.333333333', '76', '1', '0', '0', '0.333333333', '0', '0', '17.75', '5', '1.5', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . Startup ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . xml . endpoints . EndpointFactory ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . MediatorProperty ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . mediators . builtin . DropMediator ; import org . apache . synapse . mediators . builtin . LogMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import java . util . Iterator ; public class SynapseXMLConfigurationFactory implements ConfigurationFactory { private static Log log = LogFactory . getLog ( SynapseXMLConfigurationFactory . class ) ; public SynapseConfiguration getConfiguration ( OMElement definitions ) { if ( ! definitions . getQName ( ) . equals ( XMLConfigConstants . DEFINITIONS_ELT ) ) { throw new SynapseException ( "Wrong QName for this config factory " + definitions . getQName ( ) ) ; } SynapseConfiguration config = new SynapseConfiguration ( ) ; config . setDefaultQName ( definitions . getQName ( ) ) ; SequenceMediator rootSequence = new SequenceMediator ( ) ; rootSequence . setName ( org . apache . synapse . SynapseConstants . MAIN_SEQUENCE_KEY ) ; Iterator iter = definitions . getChildren ( ) ; while ( iter . hasNext ( ) ) { Object o = iter . next ( ) ; if ( o instanceof OMElement ) { OMElement elt = ( OMElement ) o ; if ( XMLConfigConstants . SEQUENCE_ELT . equals ( elt . getQName ( ) ) ) { String key = elt . getAttributeValue ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "key" ) ) ; if ( key != null ) { Mediator m = MediatorFactoryFinder . getInstance ( ) . getMediator ( elt ) ; rootSequence . addChild ( m ) ; } else { defineSequence ( config , elt ) ; } } else if ( XMLConfigConstants . ENDPOINT_ELT . equals ( elt . getQName ( ) ) ) { defineEndpoint ( config , elt ) ; } else if ( XMLConfigConstants . ENTRY_ELT . equals ( elt . getQName ( ) ) ) { defineEntry ( config , elt ) ; } else if ( XMLConfigConstants . PROXY_ELT . equals ( elt . getQName ( ) ) ) { defineProxy ( config , elt ) ; } else if ( XMLConfigConstants . REGISTRY_ELT . equals ( elt . getQName ( ) ) ) { defineRegistry ( config , elt ) ; } else if ( XMLConfigConstants . TASK_ELT . equals ( elt . getQName ( ) ) ) { defineStartup ( config , elt ) ; } else { Mediator m = MediatorFactoryFinder . getInstance ( ) . getMediator ( elt ) ; rootSequence . addChild ( m ) ; } } } if ( config . getLocalRegistry ( ) . isEmpty ( ) && config . getProxyServices ( ) . isEmpty ( ) && rootSequence . getList ( ) . isEmpty ( ) && config . getRegistry ( ) != null ) { OMNode remoteConfigNode = config . getRegistry ( ) . lookup ( "synapse.xml" ) ; try { config = XMLConfigurationBuilder . getConfiguration ( SynapseConfigUtils . getStreamSource ( remoteConfigNode ) . getInputStream ( ) ) ; } catch ( XMLStreamException xse ) { throw new SynapseException ( "Problem loading remote synapse.xml " , xse ) ; } } if ( ! config . getLocalRegistry ( ) . containsKey ( SynapseConstants . MAIN_SEQUENCE_KEY ) ) { if ( rootSequence . getList ( ) . isEmpty ( ) && config . getMainSequence ( ) == null ) { setDefaultMainSequence ( config ) ; } else { config . addSequence ( rootSequence . getName ( ) , rootSequence ) ; } } else if ( ! rootSequence . getList ( ) . isEmpty ( ) ) { handleException ( "Invalid Synapse Configuration : Conflict in resolving the \"main\" " + "mediator\n\tSynapse Configuration cannot have sequence named \"main\" and " + "toplevel mediators simultaniously" ) ; } if ( config . getFaultSequence ( ) == null ) { setDefaultFaultSequence ( config ) ; } return config ; } private static void defineRegistry ( SynapseConfiguration config , OMElement elem ) { if ( config . getRegistry ( ) != null ) { handleException ( "Only one remote registry can be defined within a configuration" ) ; } config . setRegistry ( RegistryFactory . createRegistry ( elem ) ) ; } private static void defineStartup ( SynapseConfiguration config , OMElement elem ) { Startup startup = StartupFinder . getInstance ( ) . getStartup ( elem ) ; if ( config . getStartup ( startup . getName ( ) ) != null ) { handleException ( "Duplicate startup with name : " + startup . getName ( ) ) ; } config . addStartup ( startup ) ; } private static void defineProxy ( SynapseConfiguration config , OMElement elem ) { ProxyService proxy = ProxyServiceFactory . createProxy ( elem ) ; if ( config . getProxyService ( proxy . getName ( ) ) != null ) { handleException ( "Duplicate proxy service with name : " + proxy . getName ( ) ) ; } config . addProxyService ( proxy . getName ( ) , proxy ) ; } private static void defineEntry ( SynapseConfiguration config , OMElement elem ) { Entry entry = EntryFactory . createEntry ( elem ) ; if ( config . getLocalRegistry ( ) . get ( entry . getKey ( ) ) != null ) { handleException ( "Duplicate registry entry definition for key : " + entry . getKey ( ) ) ; } config . addEntry ( entry . getKey ( ) , entry ) ; } public static void defineSequence ( SynapseConfiguration config , OMElement ele ) { String name = ele . getAttributeValue ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { if ( config . getLocalRegistry ( ) . get ( name ) != null ) { handleException ( "Duplicate sequence definition : " + name ) ; } Mediator mediator = MediatorFactoryFinder . getInstance ( ) . getMediator ( ele ) ; config . addSequence ( name , mediator ) ; if ( SynapseConstants . MANDATORY_SEQUENCE_KEY . equals ( name ) ) { config . setMandatorySequence ( mediator ) ; } } else { handleException ( "Invalid sequence definition without a name" ) ; } } public static void defineEndpoint ( SynapseConfiguration config , OMElement ele ) { String name = ele . getAttributeValue ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { if ( config . getLocalRegistry ( ) . get ( name . trim ( ) ) != null ) { handleException ( "Duplicate endpoint definition : " + name ) ; } Endpoint endpoint = EndpointFactory . getEndpointFromElement ( ele , false ) ; config . addEndpoint ( name . trim ( ) , endpoint ) ; } else { handleException ( "Invalid endpoint definition without a name" ) ; } } private static void setDefaultMainSequence ( SynapseConfiguration config ) { SequenceMediator main = new SequenceMediator ( ) ; main . setName ( SynapseConstants . MAIN_SEQUENCE_KEY ) ; main . addChild ( new LogMediator ( ) ) ; main . addChild ( new DropMediator ( ) ) ; config . addSequence ( SynapseConstants . MAIN_SEQUENCE_KEY , main ) ; } private static void setDefaultFaultSequence ( SynapseConfiguration config ) { SequenceMediator fault = new SequenceMediator ( ) ; fault . setName ( org . apache . synapse . SynapseConstants . FAULT_SEQUENCE_KEY ) ; LogMediator log = new LogMediator ( ) ; log . setLogLevel ( LogMediator . FULL ) ; MediatorProperty mp = new MediatorProperty ( ) ; mp . setName ( "MESSAGE" ) ; mp . setValue ( "Executing default \"fault\" sequence" ) ; log . addProperty ( mp ) ; mp = new MediatorProperty ( ) ; mp . setName ( "ERROR_CODE" ) ; try { mp . setExpression ( new SynapseXPath ( "get-property('ERROR_CODE')" ) ) ; } catch ( JaxenException ignore ) { } log . addProperty ( mp ) ; mp = new MediatorProperty ( ) ; mp . setName ( "ERROR_MESSAGE" ) ; try { mp . setExpression ( new SynapseXPath ( "get-property('ERROR_MESSAGE')" ) ) ; } catch ( JaxenException ignore ) { } log . addProperty ( mp ) ; fault . addChild ( log ) ; fault . addChild ( new DropMediator ( ) ) ; config . addSequence ( org . apache . synapse . SynapseConstants . FAULT_SEQUENCE_KEY , fault ) ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } public QName getTagQName ( ) { return XMLConfigConstants . DEFINITIONS_ELT ; } public Class getSerializerClass ( ) { return SynapseXMLConfigurationSerializer . class ; } } 	1	['15', '1', '0', '28', '84', '99', '0', '28', '6', '0.357142857', '507', '1', '0', '0', '0.314285714', '0', '0', '32.73333333', '19', '2.6', '2']
package org . apache . synapse . util . xpath ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . impl . llom . OMDocumentImpl ; import org . apache . axiom . om . impl . llom . OMElementImpl ; import org . apache . axiom . om . impl . llom . OMTextImpl ; import org . apache . axiom . om . xpath . AXIOMXPath ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . jaxen . * ; import org . jaxen . util . SingletonList ; import java . util . List ; public class SynapseXPath extends AXIOMXPath { private static final long serialVersionUID = 7639226137534334222L ; private static final Log log = LogFactory . getLog ( SynapseXPath . class ) ; public SynapseXPath ( String xpathString ) throws JaxenException { super ( xpathString ) ; } public String stringValueOf ( MessageContext synCtx ) { try { Object result = evaluate ( synCtx ) ; if ( result == null ) { return null ; } StringBuffer textValue = new StringBuffer ( ) ; if ( result instanceof List ) { List list = ( List ) result ; for ( Object o : list ) { if ( o == null && list . size ( ) == 1 ) { return null ; } if ( o instanceof OMTextImpl ) { textValue . append ( ( ( OMTextImpl ) o ) . getText ( ) ) ; } else if ( o instanceof OMElementImpl ) { String s = ( ( OMElementImpl ) o ) . getText ( ) ; if ( s . trim ( ) . length ( ) == 0 ) { s = o . toString ( ) ; } textValue . append ( s ) ; } else if ( o instanceof OMDocumentImpl ) { textValue . append ( ( ( OMDocumentImpl ) o ) . getOMDocumentElement ( ) . toString ( ) ) ; } } } else { textValue . append ( result . toString ( ) ) ; } return textValue . toString ( ) ; } catch ( JaxenException je ) { handleException ( "Evaluation of the XPath expression " + this . toString ( ) + " resulted in an error" , je ) ; } return null ; } public void addNamespace ( OMNamespace ns ) throws JaxenException { addNamespace ( ns . getPrefix ( ) , ns . getNamespaceURI ( ) ) ; } @ Override protected Context getContext ( Object obj ) { if ( obj instanceof MessageContext ) { MessageContext synCtx = ( MessageContext ) obj ; ContextSupport baseContextSupport = getContextSupport ( ) ; ContextSupport contextSupport = new ContextSupport ( baseContextSupport . getNamespaceContext ( ) , new SynapseXPathFunctionContext ( baseContextSupport . getFunctionContext ( ) , synCtx ) , new SynapseXPathVariableContext ( baseContextSupport . getVariableContext ( ) , synCtx ) , baseContextSupport . getNavigator ( ) ) ; Context context = new Context ( contextSupport ) ; context . setNodeSet ( new SingletonList ( synCtx . getEnvelope ( ) ) ) ; return context ; } else if ( obj instanceof SOAPEnvelope ) { SOAPEnvelope env = ( SOAPEnvelope ) obj ; ContextSupport baseContextSupport = getContextSupport ( ) ; ContextSupport contextSupport = new ContextSupport ( baseContextSupport . getNamespaceContext ( ) , baseContextSupport . getFunctionContext ( ) , new SynapseXPathVariableContext ( baseContextSupport . getVariableContext ( ) , env ) , baseContextSupport . getNavigator ( ) ) ; Context context = new Context ( contextSupport ) ; context . setNodeSet ( new SingletonList ( env ) ) ; return context ; } else { return super . getContext ( obj ) ; } } private void handleException ( String msg , Throwable e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1	['6', '3', '0', '71', '45', '13', '50', '21', '3', '0.9', '219', '1', '0', '0.870967742', '0.366666667', '2', '5', '35.16666667', '8', '2.1667', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . xml . sax . InputSource ; import javax . xml . stream . XMLStreamException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . Map ; public class ResourceMap { private static final Log log = LogFactory . getLog ( ResourceMap . class ) ; private final Map < String , String > resources = new LinkedHashMap < String , String > ( ) ; public void addResource ( String location , String key ) { resources . put ( location , key ) ; } public Map < String , String > getResources ( ) { return Collections . unmodifiableMap ( resources ) ; } public InputSource resolve ( SynapseConfiguration synCfg , String location ) { String key = ( String ) resources . get ( location ) ; if ( key == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "No resource mapping is defined for location '" + location + "'" ) ; } return null ; } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Resolving location '" + location + "' to registry item '" + key + "'" ) ; } synCfg . getEntryDefinition ( key ) ; Object keyObject = synCfg . getEntry ( key ) ; if ( keyObject instanceof OMElement ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { ( ( OMElement ) keyObject ) . serialize ( baos ) ; } catch ( XMLStreamException ex ) { String msg = "Unable to serialize registry item '" + key + "' for location '" + location + "'" ; log . error ( msg ) ; throw new SynapseException ( msg , ex ) ; } return new InputSource ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; } else { String msg = "Registry item '" + key + "' for location '" + location + "' is not an OMElement" ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } } } } 	1	['5', '1', '0', '13', '26', '0', '7', '6', '4', '0.5', '151', '1', '0', '0', '0.583333333', '0', '0', '28.8', '5', '1.4', '2']
package org . apache . synapse . mediators . base ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . MediatorFaultHandler ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . impl . SequenceStatisticsStack ; import java . util . Stack ; public class SequenceMediator extends AbstractListMediator { private String name = null ; private String key = null ; private String errorHandler = null ; private boolean dynamic = false ; private boolean initialized = false ; private String registryKey = null ; private int statisticsState = SynapseConstants . STATISTICS_UNSET ; public boolean mediate ( MessageContext synCtx ) { boolean statsOn = SynapseConstants . STATISTICS_ON == statisticsState ; boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Sequence " + ( name == null ? ( key == null ? "<anonymous" : "key=<" + key ) : "<" + name ) + ">" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( key == null ) { Mediator errorHandlerMediator = null ; if ( statsOn ) { StatisticsStack sequenceStack = ( StatisticsStack ) synCtx . getProperty ( SynapseConstants . SEQUENCE_STATS ) ; if ( sequenceStack == null ) { sequenceStack = new SequenceStatisticsStack ( ) ; synCtx . setProperty ( SynapseConstants . SEQUENCE_STATS , sequenceStack ) ; } String seqName = ( name == null ? SynapseConstants . ANONYMOUS_SEQUENCE : name ) ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; sequenceStack . put ( seqName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , statsOn , isFault ) ; } try { if ( errorHandler != null ) { errorHandlerMediator = synCtx . getSequence ( errorHandler ) ; if ( errorHandlerMediator != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting the onError handler : " + errorHandler + " for the sequence : " + name ) ; } synCtx . pushFaultHandler ( new MediatorFaultHandler ( errorHandlerMediator ) ) ; } else { auditWarn ( "onError handler : " + errorHandler + " for sequence : " + name + " cannot be found" , synCtx ) ; } } boolean result = super . mediate ( synCtx ) ; if ( errorHandlerMediator != null ) { Stack faultStack = synCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { Object o = faultStack . peek ( ) ; if ( o instanceof MediatorFaultHandler && errorHandlerMediator . equals ( ( ( MediatorFaultHandler ) o ) . getFaultMediator ( ) ) ) { faultStack . pop ( ) ; } } } if ( traceOrDebugOn ) { if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } traceOrDebug ( traceOn , "End : Sequence <" + ( name == null ? "anonymous" : name ) + ">" ) ; } return result ; } finally { if ( statsOn ) { StatisticsUtils . processSequenceStatistics ( synCtx ) ; } StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; } } else { Mediator m = synCtx . getSequence ( key ) ; if ( m == null ) { handleException ( "Sequence named " + key + " cannot be found" , synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Executing with key " + key ) ; } boolean result = m . mediate ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Sequence key=<" + key + ">" ) ; } return result ; } } return false ; } public synchronized void init ( SynapseEnvironment se ) { if ( ! initialized ) { super . init ( se ) ; initialized = true ; } } public synchronized void destroy ( ) { if ( initialized ) { super . destroy ( ) ; initialized = false ; } } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getErrorHandler ( ) { return errorHandler ; } public void setErrorHandler ( String errorHandler ) { this . errorHandler = errorHandler ; } public int getStatisticsState ( ) { return statisticsState ; } public void setStatisticsState ( int statisticsState ) { this . statisticsState = statisticsState ; } public boolean isDynamic ( ) { return dynamic ; } public void setDynamic ( boolean dynamic ) { this . dynamic = dynamic ; } public String getRegistryKey ( ) { return registryKey ; } public void setRegistryKey ( String registryKey ) { this . registryKey = registryKey ; } } 	1	['16', '3', '0', '34', '52', '60', '24', '12', '16', '0.828571429', '428', '1', '0', '0.594594595', '0.25', '1', '4', '25.3125', '29', '2.8125', '2']
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMDocument ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . soap . * ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import javax . xml . namespace . QName ; import java . net . URI ; import java . util . Iterator ; public class FaultMediator extends AbstractMediator { public static final String WSA_ACTION = "Action" ; public static final int SOAP11 = 1 ; public static final int SOAP12 = 2 ; public static final int POX = 3 ; private int soapVersion ; private QName faultCodeValue = null ; private SynapseXPath faultCodeExpr = null ; private String faultReasonValue = null ; private SynapseXPath faultReasonExpr = null ; private URI faultNode = null ; private URI faultRole = null ; private String faultDetail = null ; private SynapseXPath faultDetailExpr = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Fault mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } switch ( soapVersion ) { case SOAP11 : return makeSOAPFault ( synCtx , SOAP11 , traceOrDebugOn , traceOn ) ; case SOAP12 : return makeSOAPFault ( synCtx , SOAP12 , traceOrDebugOn , traceOn ) ; case POX : return makePOXFault ( synCtx , traceOrDebugOn , traceOn ) ; default : { if ( synCtx . isDoingPOX ( ) || synCtx . isDoingGET ( ) ) { return makePOXFault ( synCtx , traceOrDebugOn , traceOn ) ; } else { SOAPEnvelope envelop = synCtx . getEnvelope ( ) ; if ( envelop != null ) { if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelop . getNamespace ( ) . getNamespaceURI ( ) ) ) { soapVersion = SOAP12 ; return makeSOAPFault ( synCtx , SOAP12 , traceOrDebugOn , traceOn ) ; } else { soapVersion = SOAP11 ; return makeSOAPFault ( synCtx , SOAP11 , traceOrDebugOn , traceOn ) ; } } else { return makeSOAPFault ( synCtx , SOAP11 , traceOrDebugOn , traceOn ) ; } } } } } private boolean makePOXFault ( MessageContext synCtx , boolean traceOrDebugOn , boolean traceOn ) { OMFactory fac = synCtx . getEnvelope ( ) . getOMFactory ( ) ; OMElement faultPayload = fac . createOMElement ( new QName ( "Exception" ) ) ; if ( faultDetail != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting the fault detail : " + faultDetail + " as the POX Fault" ) ; } faultPayload . setText ( faultDetail ) ; } else if ( faultDetailExpr != null ) { String faultDetail = faultDetailExpr . stringValueOf ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting the fault detail : " + faultDetail + " as the POX Fault" ) ; } faultPayload . setText ( faultDetail ) ; } else if ( faultReasonValue != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting the fault reason : " + faultReasonValue + " as the POX Fault" ) ; } faultPayload . setText ( faultReasonValue ) ; } else if ( faultReasonExpr != null ) { String faultReason = faultReasonExpr . stringValueOf ( synCtx ) ; faultPayload . setText ( faultReason ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting the fault reason : " + faultReason + " as the POX Fault" ) ; } } SOAPBody body = synCtx . getEnvelope ( ) . getBody ( ) ; if ( body != null ) { if ( body . getFirstElement ( ) != null ) { body . getFirstElement ( ) . detach ( ) ; } synCtx . setFaultResponse ( true ) ; ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) . setProcessingFault ( true ) ; if ( traceOrDebugOn ) { String msg = "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) + "POXFault Message created : " + faultPayload . toString ( ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( msg ) ; } if ( log . isTraceEnabled ( ) ) { log . trace ( msg ) ; } } body . addChild ( faultPayload ) ; } return true ; } private boolean makeSOAPFault ( MessageContext synCtx , int soapVersion , boolean traceOrDebugOn , boolean traceOn ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating a SOAP " + ( soapVersion == SOAP11 ? "1.1" : "1.2" ) + " fault" ) ; } SOAPFactory factory = ( soapVersion == SOAP11 ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ) ; OMDocument soapFaultDocument = factory . createOMDocument ( ) ; SOAPEnvelope faultEnvelope = factory . getDefaultFaultEnvelope ( ) ; soapFaultDocument . addChild ( faultEnvelope ) ; SOAPFault fault = faultEnvelope . getBody ( ) . getFault ( ) ; if ( fault == null ) { fault = factory . createSOAPFault ( ) ; } setFaultCode ( synCtx , factory , fault ) ; setFaultResaon ( synCtx , factory , fault ) ; setFaultNode ( factory , fault ) ; setFaultRole ( factory , fault ) ; setFaultDetail ( synCtx , factory , fault ) ; if ( synCtx . getEnvelope ( ) != null ) { SOAPHeader soapHeader = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( soapHeader != null ) { for ( Iterator iter = soapHeader . examineAllHeaderBlocks ( ) ; iter . hasNext ( ) ; ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; faultEnvelope . getHeader ( ) . addChild ( header ) ; } else if ( o instanceof OMElement ) { faultEnvelope . getHeader ( ) . addChild ( ( OMElement ) o ) ; } } } } if ( traceOrDebugOn ) { String msg = "Original SOAP Message : " + synCtx . getEnvelope ( ) . toString ( ) + "Fault Message created : " + faultEnvelope . toString ( ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( msg ) ; } if ( log . isTraceEnabled ( ) ) { log . trace ( msg ) ; } } try { synCtx . setEnvelope ( faultEnvelope ) ; } catch ( AxisFault af ) { handleException ( "Error replacing current SOAP envelope " + "with the fault envelope" , af , synCtx ) ; } if ( synCtx . getFaultTo ( ) != null ) { synCtx . setTo ( synCtx . getFaultTo ( ) ) ; } else if ( synCtx . getReplyTo ( ) != null ) { synCtx . setTo ( synCtx . getReplyTo ( ) ) ; } else { synCtx . setTo ( null ) ; } if ( synCtx . getMessageID ( ) != null ) { RelatesTo relatesTo = new RelatesTo ( synCtx . getMessageID ( ) ) ; synCtx . setRelatesTo ( new RelatesTo [ ] { relatesTo } ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Fault mediator" ) ; } return true ; } private void setFaultCode ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { QName fault_code = null ; if ( faultCodeValue == null && faultCodeExpr == null ) { handleException ( "A valid fault code QName value or expression is required" , synCtx ) ; } else if ( faultCodeValue != null ) { fault_code = faultCodeValue ; } else { fault_code = QName . valueOf ( faultCodeExpr . stringValueOf ( synCtx ) ) ; } SOAPFaultCode code = factory . createSOAPFaultCode ( ) ; switch ( soapVersion ) { case SOAP11 : code . setText ( fault_code ) ; break ; case SOAP12 : SOAPFaultValue value = factory . createSOAPFaultValue ( code ) ; value . setText ( fault_code ) ; break ; } fault . setCode ( code ) ; } private void setFaultResaon ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { String reasonString = null ; if ( faultReasonValue == null && faultReasonExpr == null ) { handleException ( "A valid fault reason value or expression is required" , synCtx ) ; } else if ( faultReasonValue != null ) { reasonString = faultReasonValue ; } else { reasonString = faultReasonExpr . stringValueOf ( synCtx ) ; } SOAPFaultReason reason = factory . createSOAPFaultReason ( ) ; switch ( soapVersion ) { case SOAP11 : reason . setText ( reasonString ) ; break ; case SOAP12 : SOAPFaultText text = factory . createSOAPFaultText ( ) ; text . setText ( reasonString ) ; reason . addSOAPText ( text ) ; break ; } fault . setReason ( reason ) ; } private void setFaultNode ( SOAPFactory factory , SOAPFault fault ) { if ( faultNode != null ) { SOAPFaultNode soapfaultNode = factory . createSOAPFaultNode ( ) ; soapfaultNode . setNodeValue ( faultNode . toString ( ) ) ; fault . setNode ( soapfaultNode ) ; } } private void setFaultRole ( SOAPFactory factory , SOAPFault fault ) { if ( faultRole != null ) { SOAPFaultRole soapFaultRole = factory . createSOAPFaultRole ( ) ; soapFaultRole . setRoleValue ( faultRole . toString ( ) ) ; fault . setRole ( soapFaultRole ) ; } } private void setFaultDetail ( MessageContext synCtx , SOAPFactory factory , SOAPFault fault ) { if ( faultDetail != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetail ) ; fault . setDetail ( soapFaultDetail ) ; } else if ( faultDetailExpr != null ) { SOAPFaultDetail soapFaultDetail = factory . createSOAPFaultDetail ( ) ; soapFaultDetail . setText ( faultDetailExpr . stringValueOf ( synCtx ) ) ; fault . setDetail ( soapFaultDetail ) ; } else if ( fault . getDetail ( ) != null ) { fault . getDetail ( ) . detach ( ) ; } } public int getSoapVersion ( ) { return soapVersion ; } public void setSoapVersion ( int soapVersion ) { this . soapVersion = soapVersion ; } public QName getFaultCodeValue ( ) { return faultCodeValue ; } public void setFaultCodeValue ( QName faultCodeValue ) { if ( soapVersion == SOAP11 ) { this . faultCodeValue = faultCodeValue ; } else if ( SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( faultCodeValue . getNamespaceURI ( ) ) && ( SOAP12Constants . FAULT_CODE_DATA_ENCODING_UNKNOWN . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_MUST_UNDERSTAND . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_RECEIVER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_SENDER . equals ( faultCodeValue . getLocalPart ( ) ) || SOAP12Constants . FAULT_CODE_VERSION_MISMATCH . equals ( faultCodeValue . getLocalPart ( ) ) ) ) { this . faultCodeValue = faultCodeValue ; } else { handleException ( "Invalid Fault code value for a SOAP 1.2 fault : " + faultCodeValue ) ; } } public SynapseXPath getFaultCodeExpr ( ) { return faultCodeExpr ; } public void setFaultCodeExpr ( SynapseXPath faultCodeExpr ) { this . faultCodeExpr = faultCodeExpr ; } public String getFaultReasonValue ( ) { return faultReasonValue ; } public void setFaultReasonValue ( String faultReasonValue ) { this . faultReasonValue = faultReasonValue ; } public SynapseXPath getFaultReasonExpr ( ) { return faultReasonExpr ; } public void setFaultReasonExpr ( SynapseXPath faultReasonExpr ) { this . faultReasonExpr = faultReasonExpr ; } public URI getFaultNode ( ) { return faultNode ; } public void setFaultNode ( URI faultNode ) { if ( soapVersion == SOAP11 ) { handleException ( "A fault node does not apply to a SOAP 1.1 fault" ) ; } this . faultNode = faultNode ; } public URI getFaultRole ( ) { return faultRole ; } public void setFaultRole ( URI faultRole ) { this . faultRole = faultRole ; } public String getFaultDetail ( ) { return faultDetail ; } public void setFaultDetail ( String faultDetail ) { this . faultDetail = faultDetail ; } public SynapseXPath getFaultDetailExpr ( ) { return faultDetailExpr ; } public void setFaultDetailExpr ( SynapseXPath faultDetailExpr ) { this . faultDetailExpr = faultDetailExpr ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1	['28', '2', '0', '31', '106', '216', '2', '29', '20', '0.877492877', '828', '0.692307692', '3', '0.325', '0.203571429', '0', '0', '28.10714286', '17', '3.2143', '3']
package org . apache . synapse ; public class SynapseException extends RuntimeException { private static final long serialVersionUID = - 7244032125641596311L ; public SynapseException ( String string ) { super ( string ) ; } public SynapseException ( String msg , Throwable e ) { super ( msg , e ) ; } public SynapseException ( Throwable t ) { super ( t ) ; } } 	1	['3', '4', '0', '83', '6', '3', '83', '0', '3', '1.5', '17', '1', '0', '1', '0.777777778', '0', '0', '4.333333333', '0', '0', '1']
package org . apache . synapse . core . axis2 ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . ServerManager ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServlet ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; public class SynapseStartUpServlet extends HttpServlet { private static Log log = LogFactory . getLog ( SynapseStartUpServlet . class ) ; private static final String ALREADY_INITED = "synapseAlreadyInited" ; public void init ( ) throws ServletException { ServletConfig servletConfig = getServletConfig ( ) ; ServletContext servletContext = servletConfig . getServletContext ( ) ; if ( Boolean . TRUE . equals ( servletContext . getAttribute ( ALREADY_INITED ) ) ) { return ; } ServerManager serverManager = ServerManager . getInstance ( ) ; String synHome = loadParameter ( servletConfig , SynapseConstants . SYNAPSE_HOME , false ) ; if ( synHome == null ) { log . info ( "synapse.home not set; using web application root as default value" ) ; String webinfPath = servletContext . getRealPath ( "WEB-INF" ) ; if ( webinfPath == null || ! webinfPath . endsWith ( "WEB-INF" ) ) { handleException ( "Unable to determine web application root directory" ) ; } else { synHome = webinfPath . substring ( 0 , webinfPath . length ( ) - 7 ) ; log . info ( "Setting synapse.home to : " + synHome ) ; } } serverManager . setSynapseHome ( synHome ) ; serverManager . setSynapseXMLPath ( loadParameter ( servletConfig , SynapseConstants . SYNAPSE_XML , true ) ) ; String resolveRoot = loadParameter ( servletConfig , SynapseConstants . RESOLVE_ROOT , false ) ; if ( resolveRoot != null ) { serverManager . setResolveRoot ( resolveRoot ) ; } serverManager . setAxis2Repolocation ( loadParameter ( servletConfig , org . apache . axis2 . Constants . AXIS2_REPO , true ) ) ; serverManager . setAxis2Xml ( loadParameter ( servletConfig , org . apache . axis2 . Constants . AXIS2_CONF , true ) ) ; serverManager . setServerName ( loadParameter ( servletConfig , SynapseConstants . SERVER_NAME , false ) ) ; serverManager . start ( ) ; servletContext . setAttribute ( ALREADY_INITED , Boolean . TRUE ) ; } protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { } protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { } public void destroy ( ) { try { ServerManager serverManager = ServerManager . getInstance ( ) ; serverManager . stop ( ) ; getServletContext ( ) . removeAttribute ( ALREADY_INITED ) ; } catch ( Exception e ) { log . error ( "Error stopping the Synapse listener manager" , e ) ; } } private String loadParameter ( ServletConfig servletConfig , String name , boolean required ) throws ServletException { if ( System . getProperty ( name ) == null ) { String value = servletConfig . getInitParameter ( name ) ; log . debug ( "Init parameter '" + name + "' : " + value ) ; if ( ( value == null || value . trim ( ) . length ( ) == 0 ) && required ) { handleException ( "A valid system property or init parameter '" + name + "' is required" ) ; } else { return value ; } } else { return System . getProperty ( name ) ; } return null ; } private void handleException ( String message ) throws ServletException { log . error ( message ) ; log ( message ) ; throw new ServletException ( message ) ; } } 	1	['8', '3', '0', '3', '42', '8', '0', '3', '3', '0.785714286', '202', '1', '0', '0.806451613', '0.357142857', '3', '4', '24', '1', '0.75', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisMessage ; import org . apache . axis2 . description . OutOnlyAxisOperation ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import javax . xml . namespace . QName ; public class AnonymousServiceFactory { private static final Log log = LogFactory . getLog ( AnonymousServiceFactory . class ) ; private static final String NONE = "__NONE__" ; private static final String ADDR_ONLY = "__ADDR_ONLY__" ; private static final String RM_AND_ADDR = "__RM_AND_ADDR__" ; private static final String SEC_AND_ADDR = "__SEC_AND_ADDR__" ; private static final String RM_SEC_AND_ADDR = "__RM_SEC_AND_ADDR__" ; public static final String OUT_IN_OPERATION = "anonOutInOp" ; public static final String OUT_ONLY_OPERATION = "anonOutonlyOp" ; private static SynapseCallbackReceiver synapseCallbackReceiver = null ; public static AxisService getAnonymousService ( SynapseConfiguration synCfg , AxisConfiguration axisCfg , boolean wsAddrOn , boolean wsRMOn , boolean wsSecOn ) { String servicekey ; if ( ! wsAddrOn ) { servicekey = NONE ; } else { if ( ! wsSecOn && ! wsRMOn ) { servicekey = ADDR_ONLY ; } else if ( wsRMOn && ! wsSecOn ) { servicekey = RM_AND_ADDR ; } else if ( wsSecOn && ! wsRMOn ) { servicekey = SEC_AND_ADDR ; } else { servicekey = RM_SEC_AND_ADDR ; } } try { AxisService service = axisCfg . getService ( servicekey ) ; if ( service == null ) { synchronized ( AnonymousServiceFactory . class ) { service = axisCfg . getService ( servicekey ) ; if ( service != null ) { return service ; } service = createAnonymousService ( synCfg , axisCfg , servicekey ) ; if ( wsAddrOn ) { service . engageModule ( axisCfg . getModule ( SynapseConstants . ADDRESSING_MODULE_NAME ) , axisCfg ) ; if ( wsRMOn ) { service . engageModule ( axisCfg . getModule ( SynapseConstants . MERCURY_MODULE_NAME ) , axisCfg ) ; } if ( wsSecOn ) { service . engageModule ( axisCfg . getModule ( SynapseConstants . RAMPART_MODULE_NAME ) , axisCfg ) ; } } } } return service ; } catch ( AxisFault e ) { handleException ( "Error retrieving anonymous service for QoS : " + servicekey , e ) ; } return null ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static AxisService createAnonymousService ( SynapseConfiguration synCfg , AxisConfiguration axisCfg , String serviceKey ) { try { DynamicAxisOperation dynamicOperation = new DynamicAxisOperation ( new QName ( OUT_IN_OPERATION ) ) ; dynamicOperation . setMessageReceiver ( getCallbackReceiver ( synCfg ) ) ; AxisMessage inMsg = new AxisMessage ( ) ; inMsg . setName ( "in-message" ) ; inMsg . setParent ( dynamicOperation ) ; AxisMessage outMsg = new AxisMessage ( ) ; outMsg . setName ( "out-message" ) ; outMsg . setParent ( dynamicOperation ) ; dynamicOperation . addMessage ( inMsg , WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ; dynamicOperation . addMessage ( outMsg , WSDLConstants . MESSAGE_LABEL_IN_VALUE ) ; OutOnlyAxisOperation asyncOperation = new OutOnlyAxisOperation ( new QName ( OUT_ONLY_OPERATION ) ) ; asyncOperation . setMessageReceiver ( getCallbackReceiver ( synCfg ) ) ; AxisMessage outOnlyMsg = new AxisMessage ( ) ; outOnlyMsg . setName ( "out-message" ) ; outOnlyMsg . setParent ( asyncOperation ) ; asyncOperation . addMessage ( outMsg , WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ; AxisService axisAnonymousService = new AxisService ( serviceKey ) ; axisAnonymousService . addOperation ( dynamicOperation ) ; axisAnonymousService . addOperation ( asyncOperation ) ; axisCfg . addService ( axisAnonymousService ) ; axisCfg . getPhasesInfo ( ) . setOperationPhases ( dynamicOperation ) ; return axisAnonymousService ; } catch ( AxisFault e ) { handleException ( "Error occured while creating an anonymous service for QoS : " + serviceKey , e ) ; } return null ; } private static synchronized SynapseCallbackReceiver getCallbackReceiver ( SynapseConfiguration synCfg ) { if ( synapseCallbackReceiver == null ) { synapseCallbackReceiver = new SynapseCallbackReceiver ( synCfg ) ; } return synapseCallbackReceiver ; } } 	1	['6', '1', '0', '17', '32', '11', '1', '16', '2', '1.044444444', '242', '0.777777778', '1', '0', '0.333333333', '0', '0', '37.83333333', '13', '2.8333', '1']
package org . apache . synapse . core . axis2 ; import java . util . Iterator ; import java . util . List ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPFault ; import org . apache . axiom . soap . SOAPFaultCode ; import org . apache . axiom . soap . SOAPFaultReason ; import org . apache . axiom . soap . SOAPFaultText ; import org . apache . axiom . soap . SOAPFaultValue ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axis2 . AxisFault ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . util . MessageHelper ; public class SOAPUtils { private static final Log log = LogFactory . getLog ( SOAPUtils . class ) ; public static void convertSoapVersion ( org . apache . axis2 . context . MessageContext axisOutMsgCtx , String soapVersionURI ) throws AxisFault { if ( org . apache . axis2 . namespace . Constants . URI_SOAP12_ENV . equals ( soapVersionURI ) ) { convertSOAP11toSOAP12 ( axisOutMsgCtx ) ; } else if ( org . apache . axis2 . namespace . Constants . URI_SOAP11_ENV . equals ( soapVersionURI ) ) { convertSOAP12toSOAP11 ( axisOutMsgCtx ) ; } else { throw new SynapseException ( "Invalid soapVersionURI:" + soapVersionURI ) ; } } private static String SOAP_ATR_ACTOR = "actor" ; private static String SOAP_ATR_ROLE = "role" ; private static String SOAP_ATR_MUST_UNDERSTAND = "mustUnderstand" ; public static void convertSOAP11toSOAP12 ( org . apache . axis2 . context . MessageContext axisOutMsgCtx ) throws AxisFault { if ( log . isDebugEnabled ( ) ) { log . debug ( "convert SOAP11 to SOAP12" ) ; } SOAPEnvelope oldEnvelope = axisOutMsgCtx . getEnvelope ( ) ; SOAPFactory soap12Factory = OMAbstractFactory . getSOAP12Factory ( ) ; SOAPEnvelope newEnvelope = soap12Factory . getDefaultEnvelope ( ) ; if ( oldEnvelope . getHeader ( ) != null ) { Iterator itr = oldEnvelope . getHeader ( ) . getChildren ( ) ; while ( itr . hasNext ( ) ) { OMNode omNode = ( OMNode ) itr . next ( ) ; if ( omNode instanceof SOAPHeaderBlock ) { SOAPHeaderBlock soapHeader = ( SOAPHeaderBlock ) omNode ; SOAPHeaderBlock newSOAPHeader = soap12Factory . createSOAPHeaderBlock ( soapHeader . getLocalName ( ) , soapHeader . getNamespace ( ) ) ; Iterator allAttributes = soapHeader . getAllAttributes ( ) ; while ( allAttributes . hasNext ( ) ) { OMAttribute attr = ( OMAttribute ) allAttributes . next ( ) ; if ( attr . getNamespace ( ) != null && SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( attr . getNamespace ( ) . getNamespaceURI ( ) ) ) { String attrName = attr . getLocalName ( ) ; if ( SOAP_ATR_ACTOR . equals ( attrName ) ) { OMAttribute newAtr = omNode . getOMFactory ( ) . createOMAttribute ( SOAP_ATR_ROLE , newEnvelope . getNamespace ( ) , attr . getAttributeValue ( ) ) ; newSOAPHeader . addAttribute ( newAtr ) ; } else if ( SOAP_ATR_MUST_UNDERSTAND . equals ( attrName ) ) { boolean isMustUnderstand = soapHeader . getMustUnderstand ( ) ; newSOAPHeader . setMustUnderstand ( isMustUnderstand ) ; } else { log . warn ( "removed unsupported attribute from SOAP 1.1 " + "namespace when converting to SOAP 1.2:" + attrName ) ; } } else { newSOAPHeader . addAttribute ( attr ) ; } Iterator itrChildren = soapHeader . getChildren ( ) ; while ( itrChildren . hasNext ( ) ) { newSOAPHeader . addChild ( ( ( OMNode ) itrChildren . next ( ) ) ) ; } newEnvelope . getHeader ( ) . addChild ( newSOAPHeader ) ; } } else { newEnvelope . getHeader ( ) . addChild ( omNode ) ; } } } if ( oldEnvelope . getBody ( ) != null ) { Iterator itrBodyChildren = oldEnvelope . getBody ( ) . getChildren ( ) ; while ( itrBodyChildren . hasNext ( ) ) { OMNode omNode = ( OMNode ) itrBodyChildren . next ( ) ; if ( omNode instanceof SOAPFault ) { SOAPFault soapFault = ( SOAPFault ) omNode ; if ( soapFault != null ) { SOAPFault newSOAPFault = soap12Factory . createSOAPFault ( ) ; newEnvelope . getBody ( ) . addChild ( newSOAPFault ) ; SOAPFaultCode code = soapFault . getCode ( ) ; if ( code != null ) { SOAPFaultCode newSOAPFaultCode = soap12Factory . createSOAPFaultCode ( ) ; newSOAPFault . setCode ( newSOAPFaultCode ) ; String value = code . getText ( ) ; if ( value != null ) { SOAPFaultValue newSOAPFaultValue = soap12Factory . createSOAPFaultValue ( newSOAPFaultCode ) ; newSOAPFaultValue . setText ( value ) ; } } SOAPFaultReason reason = soapFault . getReason ( ) ; if ( reason != null ) { SOAPFaultReason newSOAPFaultReason = soap12Factory . createSOAPFaultReason ( newSOAPFault ) ; String reasonText = reason . getText ( ) ; if ( reasonText != null ) { SOAPFaultText newSOAPFaultText = soap12Factory . createSOAPFaultText ( newSOAPFaultReason ) ; newSOAPFaultText . setLang ( "en" ) ; newSOAPFaultText . setText ( reasonText ) ; } newSOAPFault . setReason ( newSOAPFaultReason ) ; } } } else { newEnvelope . getBody ( ) . addChild ( omNode ) ; } } } axisOutMsgCtx . setEnvelope ( newEnvelope ) ; } public static void convertSOAP12toSOAP11 ( org . apache . axis2 . context . MessageContext axisOutMsgCtx ) throws AxisFault { if ( log . isDebugEnabled ( ) ) { log . debug ( "convert SOAP12 to SOAP11" ) ; } SOAPEnvelope oldEnvelope = axisOutMsgCtx . getEnvelope ( ) ; SOAPFactory soap11Factory = OMAbstractFactory . getSOAP11Factory ( ) ; SOAPEnvelope newEnvelope = soap11Factory . getDefaultEnvelope ( ) ; if ( oldEnvelope . getHeader ( ) != null ) { Iterator itr = oldEnvelope . getHeader ( ) . getChildren ( ) ; while ( itr . hasNext ( ) ) { OMNode omNode = ( OMNode ) itr . next ( ) ; if ( omNode instanceof SOAPHeaderBlock ) { SOAPHeaderBlock soapHeaderBlock = ( SOAPHeaderBlock ) omNode ; SOAPHeaderBlock newSOAPHeader = soap11Factory . createSOAPHeaderBlock ( soapHeaderBlock . getLocalName ( ) , soapHeaderBlock . getNamespace ( ) ) ; Iterator allAttributes = soapHeaderBlock . getAllAttributes ( ) ; while ( allAttributes . hasNext ( ) ) { OMAttribute attr = ( OMAttribute ) allAttributes . next ( ) ; if ( attr . getNamespace ( ) != null && SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( attr . getNamespace ( ) . getNamespaceURI ( ) ) ) { String attrName = attr . getLocalName ( ) ; if ( SOAP_ATR_ROLE . equals ( attrName ) ) { OMAttribute newAtr = omNode . getOMFactory ( ) . createOMAttribute ( SOAP_ATR_ACTOR , newEnvelope . getNamespace ( ) , attr . getAttributeValue ( ) ) ; newSOAPHeader . addAttribute ( newAtr ) ; } else if ( SOAP_ATR_MUST_UNDERSTAND . equals ( attrName ) ) { boolean isMustUnderstand = soapHeaderBlock . getMustUnderstand ( ) ; newSOAPHeader . setMustUnderstand ( isMustUnderstand ) ; } else { log . warn ( "removed unsupported attribute from SOAP 1.2 " + "namespace when converting to SOAP 1.1:" + attrName ) ; } } else { newSOAPHeader . addAttribute ( attr ) ; } Iterator itrChildren = soapHeaderBlock . getChildren ( ) ; while ( itrChildren . hasNext ( ) ) { newSOAPHeader . addChild ( ( ( OMNode ) itrChildren . next ( ) ) ) ; } newEnvelope . getHeader ( ) . addChild ( newSOAPHeader ) ; } } else { newEnvelope . getHeader ( ) . addChild ( omNode ) ; } } } if ( oldEnvelope . getBody ( ) != null ) { Iterator itr = oldEnvelope . getBody ( ) . getChildren ( ) ; while ( itr . hasNext ( ) ) { OMNode omNode = ( OMNode ) itr . next ( ) ; if ( omNode instanceof SOAPFault ) { SOAPFault soapFault = ( SOAPFault ) omNode ; if ( soapFault != null ) { SOAPFault newSOAPFault = soap11Factory . createSOAPFault ( ) ; newEnvelope . getBody ( ) . addChild ( newSOAPFault ) ; SOAPFaultCode code = soapFault . getCode ( ) ; if ( code != null ) { SOAPFaultCode newSOAPFaultCode = soap11Factory . createSOAPFaultCode ( newSOAPFault ) ; SOAPFaultValue value = code . getValue ( ) ; if ( value != null ) { soap11Factory . createSOAPFaultValue ( newSOAPFaultCode ) ; if ( value . getText ( ) != null ) { newSOAPFaultCode . setText ( value . getText ( ) ) ; } } } SOAPFaultReason reason = soapFault . getReason ( ) ; if ( reason != null ) { SOAPFaultReason newSOAPFaultReason = soap11Factory . createSOAPFaultReason ( newSOAPFault ) ; List allSoapTexts = reason . getAllSoapTexts ( ) ; Iterator iterAllSoapTexts = allSoapTexts . iterator ( ) ; while ( iterAllSoapTexts . hasNext ( ) ) { SOAPFaultText soapFaultText = ( SOAPFaultText ) iterAllSoapTexts . next ( ) ; SOAPFaultText newSOAPFaultText = soap11Factory . createSOAPFaultText ( newSOAPFaultReason ) ; newSOAPFaultReason . setText ( soapFaultText . getText ( ) ) ; break ; } } } } else { newEnvelope . getBody ( ) . addChild ( omNode ) ; } } } axisOutMsgCtx . setEnvelope ( newEnvelope ) ; } } 	1	['5', '1', '0', '22', '66', '4', '2', '20', '4', '0.25', '493', '1', '0', '0', '0.416666667', '0', '0', '96.8', '1', '0.6', '1']
package org . apache . synapse . core . axis2 ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . ws . commons . schema . resolver . URIResolver ; import org . xml . sax . InputSource ; public class CustomURIResolver implements URIResolver { private ResourceMap resourceMap ; private SynapseConfiguration synCfg ; public CustomURIResolver ( ) { } public CustomURIResolver ( ResourceMap resourceMap , SynapseConfiguration synCfg ) { this ( ) ; this . resourceMap = resourceMap ; this . synCfg = synCfg ; } public InputSource resolveEntity ( String targetNamespace , String schemaLocation , String baseUri ) { InputSource result = null ; if ( resourceMap != null ) { result = resourceMap . resolve ( synCfg , schemaLocation ) ; } if ( result == null ) { result = new InputSource ( SynapseConfigUtils . resolveRelativeURI ( baseUri , schemaLocation ) ) ; } return result ; } } 	1	['3', '1', '0', '5', '7', '1', '1', '4', '3', '0.5', '40', '1', '2', '0', '0.5', '0', '0', '11.66666667', '3', '1', '1']
package org . apache . synapse . mediators . filters ; import org . apache . synapse . MessageContext ; import org . apache . synapse . config . xml . SwitchCase ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class SwitchMediator extends AbstractMediator { private SynapseXPath source = null ; private List cases = new ArrayList ( ) ; private SwitchCase defaultCase = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Switch mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } int parentsEffectiveTraceState = synCtx . getTracingState ( ) ; setEffectiveTraceState ( synCtx ) ; int myEffectiveTraceState = synCtx . getTracingState ( ) ; String sourceText = source . stringValueOf ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "XPath : " + source + " evaluates to : " + sourceText ) ; } try { if ( ( sourceText == null || cases . isEmpty ( ) ) && defaultCase != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Source XPath evaluated to : null or no switch " + "cases found. Executing the default case" ) ; } return defaultCase . mediate ( synCtx ) ; } else { for ( Iterator iter = cases . iterator ( ) ; iter . hasNext ( ) ; ) { SwitchCase swCase = ( SwitchCase ) iter . next ( ) ; if ( swCase != null ) { if ( swCase . matches ( sourceText ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Matching case found : " + swCase . getRegex ( ) ) ; } return swCase . mediate ( synCtx ) ; } } } if ( defaultCase != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "None of the switch cases matched - executing default" ) ; } return defaultCase . mediate ( synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "None of the switch cases matched - no default case" ) ; } } } } finally { synCtx . setTracingState ( parentsEffectiveTraceState ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Switch mediator" ) ; } return true ; } public void addCase ( SwitchCase m ) { cases . add ( m ) ; } public List getCases ( ) { return cases ; } public SynapseXPath getSource ( ) { return source ; } public void setSource ( SynapseXPath source ) { this . source = source ; } public SwitchCase getDefaultCase ( ) { return defaultCase ; } public void setDefaultCase ( SwitchCase defaultCase ) { this . defaultCase = defaultCase ; } } 	1	['8', '2', '0', '8', '32', '0', '2', '6', '8', '0.571428571', '219', '1', '2', '0.65', '0.375', '0', '0', '26', '15', '2.625', '2']
package org . apache . synapse . mediators . eip . aggregator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . mediators . eip . EIPConstants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . util . List ; import java . util . ArrayList ; import java . util . TimerTask ; public class Aggregate extends TimerTask { private static final Log log = LogFactory . getLog ( Aggregate . class ) ; private static final Log trace = LogFactory . getLog ( SynapseConstants . TRACE_LOGGER ) ; private long timeoutMillis = 0 ; private long expiryTimeMillis = 0 ; private int minCount = - 1 ; private int maxCount = - 1 ; private String correlation = null ; private AggregateMediator aggregateMediator = null ; private List < MessageContext > messages = new ArrayList < MessageContext > ( ) ; private boolean locked = false ; private boolean completed = false ; public Aggregate ( String corelation , long timeoutMillis , int min , int max , AggregateMediator mediator ) { this . correlation = corelation ; if ( timeoutMillis > 0 ) { expiryTimeMillis = System . currentTimeMillis ( ) + timeoutMillis ; } if ( min > 0 ) { minCount = min ; } if ( max > 0 ) { maxCount = max ; } this . aggregateMediator = mediator ; } public synchronized boolean addMessage ( MessageContext synCtx ) { if ( maxCount <= 0 || ( maxCount > 0 && messages . size ( ) < maxCount ) ) { messages . add ( synCtx ) ; return true ; } else { return false ; } } public synchronized boolean isComplete ( boolean traceOn , boolean traceOrDebugOn , Log trace , Log log ) { if ( ! completed ) { if ( ! messages . isEmpty ( ) ) { MessageContext mc = messages . get ( 0 ) ; Object prop = mc . getProperty ( EIPConstants . MESSAGE_SEQUENCE ) ; if ( prop != null && prop instanceof String ) { String [ ] msgSequence = prop . toString ( ) . split ( EIPConstants . MESSAGE_SEQUENCE_DELEMITER ) ; int total = Integer . parseInt ( msgSequence [ 1 ] ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , messages . size ( ) + " messages of " + total + " collected in current aggregation" ) ; } if ( messages . size ( ) >= total ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "Aggregation complete" ) ; } return true ; } } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "No messages collected in current aggregation" ) ; } } if ( minCount > 0 && messages . size ( ) >= minCount ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "Aggregation complete - the minimum : " + minCount + " messages has been reached" ) ; } return true ; } if ( maxCount > 0 && messages . size ( ) >= maxCount ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "Aggregation complete - the maximum : " + maxCount + " messages has been reached" ) ; } return true ; } if ( expiryTimeMillis > 0 && System . currentTimeMillis ( ) >= expiryTimeMillis ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "Aggregation complete - the aggregation has timed out" ) ; } return true ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , trace , log , "Aggregation already completed - this message will not be processed in aggregation" ) ; } } return false ; } private void traceOrDebug ( boolean traceOn , Log trace , Log log , String msg ) { if ( traceOn ) { trace . info ( msg ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( msg ) ; } } public long getTimeoutMillis ( ) { return timeoutMillis ; } public void setTimeoutMillis ( long timeoutMillis ) { this . timeoutMillis = timeoutMillis ; } public int getMinCount ( ) { return minCount ; } public void setMinCount ( int minCount ) { this . minCount = minCount ; } public int getMaxCount ( ) { return maxCount ; } public void setMaxCount ( int maxCount ) { this . maxCount = maxCount ; } public String getCorrelation ( ) { return correlation ; } public void setCorrelation ( String correlation ) { this . correlation = correlation ; } public List < MessageContext > getMessages ( ) { return messages ; } public void setMessages ( List < MessageContext > messages ) { this . messages = messages ; } public long getExpiryTimeMillis ( ) { return expiryTimeMillis ; } public void setExpiryTimeMillis ( long expiryTimeMillis ) { this . expiryTimeMillis = expiryTimeMillis ; } public void run ( ) { while ( true ) { if ( completed ) { break ; } if ( getLock ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Time : " + System . currentTimeMillis ( ) + " and this aggregator " + "expired at : " + expiryTimeMillis ) ; } aggregateMediator . completeAggregate ( this ) ; break ; } } } public synchronized boolean getLock ( ) { return ! locked ; } public void releaseLock ( ) { locked = false ; } public boolean isCompleted ( ) { return completed ; } public void setCompleted ( boolean completed ) { this . completed = completed ; } } 	1	['22', '2', '0', '4', '44', '135', '1', '4', '20', '0.878787879', '388', '1', '1', '0.130434783', '0.201058201', '0', '0', '16.13636364', '16', '2', '1']
package org . apache . synapse ; import org . apache . axis2 . Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; public class SynapseServer { private static final Log log = LogFactory . getLog ( SynapseServer . class ) ; private static final String USAGE_TXT = "Usage: SynapseServer <axis2_repository> <axis2_xml> <synapse_home> <synapse_xml> <resolve_root>" + "\n Opts: -? this message" ; public static void printUsage ( ) { System . out . println ( USAGE_TXT ) ; System . exit ( 1 ) ; } public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 && args . length != 4 && args . length != 5 && args . length != 6 ) { printUsage ( ) ; } ServerManager serverManager = ServerManager . getInstance ( ) ; serverManager . setAxis2Repolocation ( args [ 0 ] ) ; if ( args . length == 1 ) { log . warn ( "Configuring server manager using deprecated system properties; please update your configuration" ) ; serverManager . setAxis2Xml ( System . getProperty ( Constants . AXIS2_CONF ) ) ; serverManager . setSynapseHome ( System . getProperty ( SynapseConstants . SYNAPSE_HOME ) ) ; serverManager . setSynapseXMLPath ( System . getProperty ( SynapseConstants . SYNAPSE_XML ) ) ; serverManager . setResolveRoot ( System . getProperty ( SynapseConstants . RESOLVE_ROOT ) ) ; } else if ( args . length == 4 ) { serverManager . setAxis2Xml ( args [ 1 ] ) ; serverManager . setSynapseHome ( args [ 2 ] ) ; serverManager . setSynapseXMLPath ( args [ 3 ] ) ; serverManager . setResolveRoot ( args [ 2 ] + File . separator + "repository" ) ; } else if ( args . length == 5 ) { serverManager . setAxis2Xml ( args [ 1 ] ) ; serverManager . setSynapseHome ( args [ 2 ] ) ; serverManager . setSynapseXMLPath ( args [ 3 ] ) ; serverManager . setResolveRoot ( args [ 4 ] ) ; } else if ( args . length == 6 ) { serverManager . setAxis2Xml ( args [ 1 ] ) ; serverManager . setSynapseHome ( args [ 2 ] ) ; serverManager . setSynapseXMLPath ( args [ 3 ] ) ; serverManager . setResolveRoot ( args [ 4 ] ) ; serverManager . setServerName ( args [ 5 ] ) ; } serverManager . start ( ) ; addShutdownHook ( ) ; } private static void addShutdownHook ( ) { Thread shutdownHook = new Thread ( ) { public void run ( ) { log . info ( "Shutting down Apache Synapse ..." ) ; try { ServerManager . getInstance ( ) . stop ( ) ; log . info ( "Shutdown complete" ) ; log . info ( "Halting JVM" ) ; } catch ( Exception e ) { log . warn ( "Error occurred while shutting down Apache Synapse : " + e ) ; } } } ; Runtime . getRuntime ( ) . addShutdownHook ( shutdownHook ) ; } } 	1	['6', '1', '0', '4', '26', '9', '1', '4', '3', '0.9', '171', '1', '0', '0', '0.2', '0', '0', '27.16666667', '1', '0.6667', '2']
package org . apache . synapse ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . axis2 . description . Parameter ; import org . apache . axis2 . description . TransportInDescription ; import org . apache . axis2 . description . AxisService ; import org . apache . axis2 . description . AxisModule ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . engine . ListenerManager ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . format . BinaryBuilder ; import org . apache . synapse . format . PlainTextBuilder ; import org . apache . synapse . transport . nhttp . NhttpConstants ; import org . apache . synapse . util . ClasspathURLStreamHandler ; import org . apache . synapse . util . RMIRegistryController ; import java . io . File ; import java . net . * ; import java . util . Map ; public class ServerManager { private static final Log log = LogFactory . getLog ( ServerManager . class ) ; private static ServerManager instance = new ServerManager ( ) ; private String axis2Repolocation ; private String axis2Xml ; private String synapseHome ; private String synapseXMLPath ; private String resolveRoot ; private String serverName = "localhost" ; private ListenerManager listenerManager ; private ConfigurationContext configctx ; private SynapseConfiguration synConfig = null ; private Map callbackStore = null ; public static ServerManager getInstance ( ) { return instance ; } public void start ( ) { validate ( ) ; try { URL . setURLStreamHandlerFactory ( new URLStreamHandlerFactoryImpl ( ) ) ; } catch ( Throwable t ) { log . debug ( "Unable to register a URLStreamHandlerFactory - " + "Custom URL protocols may not work properly (e.g. classpath://)" ) ; } try { configctx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( axis2Repolocation , axis2Xml ) ; addDefaultBuildersAndFormatters ( configctx . getAxisConfiguration ( ) ) ; listenerManager = configctx . getListenerManager ( ) ; if ( listenerManager == null ) { listenerManager = new ListenerManager ( ) ; listenerManager . init ( configctx ) ; } for ( Object o : configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . keySet ( ) ) { String trp = ( String ) o ; TransportInDescription trsIn = ( TransportInDescription ) configctx . getAxisConfiguration ( ) . getTransportsIn ( ) . get ( trp ) ; String msg = "Starting transport " + trsIn . getName ( ) ; if ( trsIn . getParameter ( "port" ) != null ) { msg += " on port " + trsIn . getParameter ( "port" ) . getValue ( ) ; } log . info ( msg ) ; listenerManager . addListener ( trsIn , false ) ; } Parameter synEnv = configctx . getAxisConfiguration ( ) . getParameter ( SynapseConstants . SYNAPSE_ENV ) ; Parameter synCfg = configctx . getAxisConfiguration ( ) . getParameter ( SynapseConstants . SYNAPSE_CONFIG ) ; String message = "Unable to initialize the Synapse Configuration : Cannot find the " ; if ( synCfg == null || synCfg . getValue ( ) == null || ! ( synCfg . getValue ( ) instanceof SynapseConfiguration ) ) { log . fatal ( message + "Synapse Configuration" ) ; throw new SynapseException ( message + "Synapse Configuration" ) ; } else { synConfig = ( SynapseConfiguration ) synCfg . getValue ( ) ; } if ( synEnv == null || synEnv . getValue ( ) == null || ! ( synEnv . getValue ( ) instanceof SynapseEnvironment ) ) { log . fatal ( message + "Synapse Environment" ) ; throw new SynapseException ( message + "Synapse Environment" ) ; } else { ( ( SynapseEnvironment ) synEnv . getValue ( ) ) . setInitialized ( true ) ; for ( Startup stp : ( ( SynapseConfiguration ) synCfg . getValue ( ) ) . getStartups ( ) ) { if ( stp != null ) { stp . init ( ( SynapseEnvironment ) synEnv . getValue ( ) ) ; } } } log . info ( "Ready for processing" ) ; } catch ( Throwable t ) { log . fatal ( "Synaps startup failed..." , t ) ; throw new SynapseException ( "Synapse startup failed" , t ) ; } } private void addDefaultBuildersAndFormatters ( AxisConfiguration axisConf ) { if ( axisConf . getMessageBuilder ( "text/plain" ) == null ) { axisConf . addMessageBuilder ( "text/plain" , new PlainTextBuilder ( ) ) ; } if ( axisConf . getMessageBuilder ( "application/octet-stream" ) == null ) { axisConf . addMessageBuilder ( "application/octet-stream" , new BinaryBuilder ( ) ) ; } } public void stop ( ) { try { RMIRegistryController . getInstance ( ) . removeLocalRegistry ( ) ; if ( configctx != null && configctx . getAxisConfiguration ( ) != null ) { Map < String , AxisService > serviceMap = configctx . getAxisConfiguration ( ) . getServices ( ) ; for ( AxisService svc : serviceMap . values ( ) ) { svc . setActive ( false ) ; } Map < String , AxisModule > moduleMap = configctx . getAxisConfiguration ( ) . getModules ( ) ; for ( AxisModule mod : moduleMap . values ( ) ) { if ( mod . getModule ( ) != null && ! "synapse" . equals ( mod . getName ( ) ) ) { mod . getModule ( ) . shutdown ( configctx ) ; } } } if ( listenerManager != null ) { listenerManager . stop ( ) ; listenerManager . destroy ( ) ; } if ( configctx != null ) { configctx . terminate ( ) ; } } catch ( Exception e ) { log . error ( "Error stopping the ServerManager" , e ) ; } } public int pendingCallbacks ( ) { if ( callbackStore != null ) { return callbackStore . size ( ) ; } else { return 0 ; } } private static final class URLStreamHandlerFactoryImpl implements URLStreamHandlerFactory { public URLStreamHandler createURLStreamHandler ( String protocol ) { if ( protocol == null ) { throw new IllegalArgumentException ( "'protocol' cannot be null" ) ; } URLStreamHandler urlSH = null ; if ( protocol . equals ( "classpath" ) ) { urlSH = new ClasspathURLStreamHandler ( ) ; } return urlSH ; } } private void validate ( ) { if ( synapseHome == null || ! new File ( synapseHome ) . exists ( ) ) { handleFatal ( "Synapse home" ) ; } else { log . info ( "Using Synapse home as : " + synapseHome ) ; } if ( axis2Repolocation == null || ! new File ( axis2Repolocation ) . exists ( ) ) { handleFatal ( "Axis2 repository" ) ; } else { log . info ( "Using the Axis2 Repository : " + new File ( axis2Repolocation ) . getAbsolutePath ( ) ) ; } if ( axis2Xml == null || ! new File ( axis2Xml ) . exists ( ) ) { handleFatal ( "axis2.xml location" ) ; } else { log . info ( "Using the axis2.xml : " + new File ( axis2Xml ) . getAbsolutePath ( ) ) ; } if ( synapseXMLPath == null || ! new File ( synapseXMLPath ) . exists ( ) ) { handleFatal ( "synapse.xml path" ) ; } if ( serverName == null ) { try { serverName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException ignore ) { } log . info ( "The server name was not specified, defaulting to : " + serverName ) ; } else { log . info ( "Using server name : " + serverName ) ; } log . info ( "The timeout handler will run every : " + ( getTimeoutHandlerInterval ( ) / 1000 ) + "s" ) ; } public void handleFatal ( String msgPre ) { String msg = "The " + msgPre + " must be set as a system property or init-parameter" ; log . fatal ( msg ) ; throw new SynapseException ( msg ) ; } public ConfigurationContext getConfigurationContext ( ) { return configctx ; } public void setCallbackStore ( Map callbackStore ) { this . callbackStore = callbackStore ; } public void setAxis2Repolocation ( String axis2Repolocation ) { if ( ! new File ( axis2Repolocation ) . isAbsolute ( ) && synapseHome != null ) { this . axis2Repolocation = synapseHome + File . separator + axis2Repolocation ; } else { this . axis2Repolocation = axis2Repolocation ; } } public void setAxis2Xml ( String axis2Xml ) { if ( ! new File ( axis2Xml ) . isAbsolute ( ) && synapseHome != null ) { this . axis2Xml = synapseHome + File . separator + axis2Xml ; } else { this . axis2Xml = axis2Xml ; } } public String getSynapseHome ( ) { return synapseHome ; } public void setSynapseHome ( String synapseHome ) { this . synapseHome = synapseHome ; } public String getResolveRoot ( ) { return resolveRoot ; } public void setResolveRoot ( String resolveRoot ) { if ( ! new File ( resolveRoot ) . isAbsolute ( ) && synapseHome != null ) { this . resolveRoot = synapseHome + File . separator + resolveRoot ; } else { this . resolveRoot = resolveRoot ; } } public String getServerName ( ) { return serverName ; } public void setServerName ( String serverName ) { this . serverName = serverName ; } public String getSynapseXMLPath ( ) { return synapseXMLPath ; } public void setSynapseXMLPath ( String synapseXMLPath ) { if ( ! new File ( synapseXMLPath ) . isAbsolute ( ) && synapseHome != null ) { this . synapseXMLPath = synapseHome + File . separator + synapseXMLPath ; } else { this . synapseXMLPath = synapseXMLPath ; } } public int getConnectTimeout ( ) { if ( synConfig == null ) { return ( int ) SynapseConstants . DEFAULT_GLOBAL_TIMEOUT ; } else { return ( int ) synConfig . getProperty ( SynapseConstants . CONNECTTIMEOUT , SynapseConstants . DEFAULT_CONNECTTIMEOUT ) ; } } public int getReadTimeout ( ) { if ( synConfig == null ) { return SynapseConstants . DEFAULT_READTIMEOUT ; } else { return ( int ) synConfig . getProperty ( SynapseConstants . READTIMEOUT , SynapseConstants . DEFAULT_READTIMEOUT ) ; } } public long getTimeoutHandlerInterval ( ) { if ( synConfig == null ) { return SynapseConstants . DEFAULT_TIMEOUT_HANDLER_INTERVAL ; } else { return synConfig . getProperty ( SynapseConstants . TIMEOUT_HANDLER_INTERVAL , SynapseConstants . DEFAULT_TIMEOUT_HANDLER_INTERVAL ) ; } } public long getGlobalTimeoutInterval ( ) { if ( synConfig == null ) { return SynapseConstants . DEFAULT_GLOBAL_TIMEOUT ; } else { return synConfig . getProperty ( SynapseConstants . GLOBAL_TIMEOUT_INTERVAL , SynapseConstants . DEFAULT_GLOBAL_TIMEOUT ) ; } } } 	1	['25', '1', '0', '32', '86', '174', '11', '21', '22', '0.868055556', '740', '1', '2', '0', '0.333333333', '0', '0', '28.12', '11', '2.48', '3']
package org . apache . synapse . mediators . ext ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . mediators . AbstractMediator ; import java . util . HashMap ; import java . util . Map ; public class ClassMediator extends AbstractMediator implements ManagedLifecycle { private Mediator mediator = null ; private Map < String , Object > properties = new HashMap < String , Object > ( ) ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Class mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "invoking : " + mediator . getClass ( ) + ".mediate()" ) ; } boolean result ; try { result = mediator . mediate ( synCtx ) ; } catch ( Exception e ) { throw new SynapseException ( "Error occured in the mediation of the class mediator" , e ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Class mediator" ) ; } return result ; } public void destroy ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Destroying class mediator instance for : " + mediator . getClass ( ) ) ; } if ( mediator instanceof ManagedLifecycle ) { ( ( ManagedLifecycle ) mediator ) . destroy ( ) ; } } public void init ( SynapseEnvironment se ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Initializing class mediator instance for : " + mediator . getClass ( ) ) ; } if ( mediator == null ) { log . warn ( "init() called before mediator reference set" ) ; return ; } if ( mediator instanceof ManagedLifecycle ) { ( ( ManagedLifecycle ) mediator ) . init ( se ) ; } } public void setMediator ( Mediator mediator ) { this . mediator = mediator ; } public Mediator getMediator ( ) { return mediator ; } public void addProperty ( String name , Object value ) { properties . put ( name , value ) ; } public Map getProperties ( ) { return this . properties ; } } 	1	['8', '2', '0', '10', '29', '0', '2', '8', '8', '0.5', '167', '1', '1', '0.65', '0.270833333', '0', '0', '19.625', '6', '2.125', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . modules . Module ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . log4j . MDC ; import org . apache . neethi . Assertion ; import org . apache . neethi . Policy ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . ServerManager ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . SynapseConfigurationBuilder ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class SynapseInitializationModule implements Module { private static final Log log = LogFactory . getLog ( SynapseInitializationModule . class ) ; private SynapseConfiguration synCfg ; public void init ( ConfigurationContext configurationContext , AxisModule axisModule ) throws AxisFault { log . info ( "Initializing Synapse at : " + new Date ( ) ) ; try { InetAddress addr = InetAddress . getLocalHost ( ) ; if ( addr != null ) { String ipAddr = addr . getHostAddress ( ) ; if ( ipAddr != null ) { MDC . put ( "ip" , ipAddr ) ; } String hostname = addr . getHostName ( ) ; if ( hostname == null ) { hostname = ipAddr ; } MDC . put ( "host" , hostname ) ; } } catch ( UnknownHostException e ) { log . warn ( "Unable to determine hostname or IP address of the server for logging" , e ) ; } log . info ( "Loading mediator extensions..." ) ; configurationContext . getAxisConfiguration ( ) . getConfigurator ( ) . loadServices ( ) ; log . info ( "Initializing the Synapse configuration ..." ) ; synCfg = getConfiguration ( configurationContext ) ; log . info ( "Deploying the Synapse service.." ) ; AxisConfiguration axisCfg = configurationContext . getAxisConfiguration ( ) ; AxisService synapseService = new AxisService ( SynapseConstants . SYNAPSE_SERVICE_NAME ) ; AxisOperation mediateOperation = new InOutAxisOperation ( SynapseConstants . SYNAPSE_OPERATION_NAME ) ; mediateOperation . setMessageReceiver ( new SynapseMessageReceiver ( ) ) ; synapseService . addOperation ( mediateOperation ) ; List transports = new ArrayList ( ) ; transports . add ( Constants . TRANSPORT_HTTP ) ; transports . add ( Constants . TRANSPORT_HTTPS ) ; synapseService . setExposedTransports ( transports ) ; axisCfg . addService ( synapseService ) ; String thisServerName = ServerManager . getInstance ( ) . getServerName ( ) ; if ( thisServerName == null || thisServerName . equals ( "" ) ) { try { InetAddress addr = InetAddress . getLocalHost ( ) ; thisServerName = addr . getHostName ( ) ; } catch ( UnknownHostException e ) { log . warn ( "Could not get local host name" , e ) ; } if ( thisServerName == null || thisServerName . equals ( "" ) ) { thisServerName = "localhost" ; } } log . info ( "Synapse server name : " + thisServerName ) ; log . info ( "Deploying Proxy services..." ) ; for ( ProxyService proxy : synCfg . getProxyServices ( ) ) { List pinnedServers = proxy . getPinnedServers ( ) ; if ( pinnedServers != null && ! pinnedServers . isEmpty ( ) ) { if ( ! pinnedServers . contains ( thisServerName ) ) { log . info ( "Server name not in pinned servers list. Not deploying Proxy service : " + proxy . getName ( ) ) ; continue ; } } proxy . buildAxisService ( synCfg , axisCfg ) ; log . info ( "Deployed Proxy service : " + proxy . getName ( ) ) ; if ( ! proxy . isStartOnLoad ( ) ) { proxy . stop ( synCfg ) ; } } log . info ( "Synapse initialized successfully...!" ) ; } private static SynapseConfiguration getConfiguration ( ConfigurationContext cfgCtx ) { cfgCtx . setProperty ( "addressing.validateAction" , Boolean . FALSE ) ; AxisConfiguration axisConfiguration = cfgCtx . getAxisConfiguration ( ) ; SynapseConfiguration synapseConfiguration ; String config = ServerManager . getInstance ( ) . getSynapseXMLPath ( ) ; if ( config != null ) { synapseConfiguration = SynapseConfigurationBuilder . getConfiguration ( config ) ; } else { log . warn ( "System property or init-parameter '" + SynapseConstants . SYNAPSE_XML + "' is not specified. Using default configuration.." ) ; synapseConfiguration = SynapseConfigurationBuilder . getDefaultConfiguration ( ) ; } synapseConfiguration . setAxisConfiguration ( cfgCtx . getAxisConfiguration ( ) ) ; Parameter synapseCtxParam = new Parameter ( SynapseConstants . SYNAPSE_CONFIG , null ) ; synapseCtxParam . setValue ( synapseConfiguration ) ; MessageContextCreatorForAxis2 . setSynConfig ( synapseConfiguration ) ; Parameter synapseEnvParam = new Parameter ( SynapseConstants . SYNAPSE_ENV , null ) ; Axis2SynapseEnvironment synEnv = new Axis2SynapseEnvironment ( cfgCtx , synapseConfiguration ) ; synapseEnvParam . setValue ( synEnv ) ; MessageContextCreatorForAxis2 . setSynEnv ( synEnv ) ; try { axisConfiguration . addParameter ( synapseCtxParam ) ; axisConfiguration . addParameter ( synapseEnvParam ) ; } catch ( AxisFault e ) { String msg = "Could not set parameters '" + SynapseConstants . SYNAPSE_CONFIG + "' and/or '" + SynapseConstants . SYNAPSE_ENV + "'to the Axis2 configuration : " + e . getMessage ( ) ; log . fatal ( msg , e ) ; throw new SynapseException ( msg , e ) ; } synapseConfiguration . init ( synEnv ) ; return synapseConfiguration ; } public void engageNotify ( AxisDescription axisDescription ) throws AxisFault { } public boolean canSupportAssertion ( Assertion assertion ) { return false ; } public void applyPolicy ( Policy policy , AxisDescription axisDescription ) throws AxisFault { } public void shutdown ( ConfigurationContext configurationContext ) throws AxisFault { synCfg . destroy ( ) ; } } 	1	['8', '1', '0', '27', '64', '20', '0', '27', '6', '0.785714286', '313', '1', '1', '0', '0.333333333', '0', '0', '37.875', '2', '0.875', '1']
package org . apache . synapse . mediators ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . description . AxisOperation ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . jaxen . Context ; import org . jaxen . Function ; import org . jaxen . FunctionCallException ; import org . jaxen . Navigator ; import org . jaxen . function . StringFunction ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . text . Format ; import java . text . SimpleDateFormat ; public class GetPropertyFunction implements Function { private static final Log log = LogFactory . getLog ( GetPropertyFunction . class ) ; private static final Log trace = LogFactory . getLog ( SynapseConstants . TRACE_LOGGER ) ; public static final String NULL_STRING = "" ; private MessageContext synCtx = null ; public MessageContext getSynCtx ( ) { return synCtx ; } public void setSynCtx ( MessageContext synCtx ) { this . synCtx = synCtx ; } public Object call ( Context context , List args ) throws FunctionCallException { boolean traceOn = synCtx . getTracingState ( ) == SynapseConstants . TRACING_ON ; boolean traceOrDebugOn = traceOn || log . isDebugEnabled ( ) ; if ( args == null || args . size ( ) == 0 ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Property key value for lookup is not specified" ) ; } return NULL_STRING ; } else { int size = args . size ( ) ; if ( size == 1 ) { return evaluate ( XMLConfigConstants . SCOPE_DEFAULT , args . get ( 0 ) , null , context . getNavigator ( ) ) ; } else if ( size == 2 ) { String argOne = StringFunction . evaluate ( args . get ( 0 ) , context . getNavigator ( ) ) ; if ( argOne != null ) { if ( ! XMLConfigConstants . SCOPE_AXIS2 . equals ( argOne ) && ! XMLConfigConstants . SCOPE_DEFAULT . equals ( argOne ) && ! XMLConfigConstants . SCOPE_TRANSPORT . equals ( argOne ) ) { return evaluate ( XMLConfigConstants . SCOPE_DEFAULT , args . get ( 0 ) , args . get ( 1 ) , context . getNavigator ( ) ) ; } else { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , null , context . getNavigator ( ) ) ; } } } else if ( size == 3 ) { return evaluate ( args . get ( 0 ) , args . get ( 1 ) , args . get ( 2 ) , context . getNavigator ( ) ) ; } else { String msg = "Invalid arguments for synapse:get-property(prop-name) 0r  " + "synapse:get-property(scope, prop-name) XPath function " ; if ( traceOn ) { trace . error ( msg ) ; } log . error ( msg ) ; throw new FunctionCallException ( msg ) ; } } return NULL_STRING ; } public Object evaluate ( Object scopeObject , Object keyObject , Object dateformat , Navigator navigator ) { boolean traceOn = synCtx . getTracingState ( ) == SynapseConstants . TRACING_ON ; boolean traceOrDebugOn = traceOn || log . isDebugEnabled ( ) ; if ( synCtx == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Synapse message context has not been set for the " + "XPath extension function 'synapse:get-property(prop-name)'" ) ; } return null ; } String scope = StringFunction . evaluate ( scopeObject , navigator ) ; String key = StringFunction . evaluate ( keyObject , navigator ) ; if ( key == null || "" . equals ( key ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "property-name should be provided when executing synapse:get-property" + "(scope,prop-name) or synapse:get-property(prop-name) Xpath function" ) ; } return NULL_STRING ; } if ( SynapseConstants . SYSTEM_DATE . equals ( key ) ) { if ( dateformat != null ) { Format formatter = new SimpleDateFormat ( dateformat . toString ( ) ) ; return formatter . format ( new java . util . Date ( ) ) ; } else { Format formatter = new SimpleDateFormat ( ) ; return formatter . format ( new java . util . Date ( ) ) ; } } if ( SynapseConstants . SYSTEM_TIME . equals ( key ) ) { return Long . toString ( System . currentTimeMillis ( ) ) ; } if ( XMLConfigConstants . SCOPE_DEFAULT . equals ( scope ) ) { if ( SynapseConstants . HEADER_TO . equals ( key ) ) { EndpointReference toEPR = synCtx . getTo ( ) ; if ( toEPR != null ) { return toEPR . getAddress ( ) ; } else { return NULL_STRING ; } } else if ( SynapseConstants . HEADER_FROM . equals ( key ) ) { EndpointReference fromEPR = synCtx . getFrom ( ) ; if ( fromEPR != null ) { return fromEPR . getAddress ( ) ; } else { return NULL_STRING ; } } else if ( SynapseConstants . HEADER_ACTION . equals ( key ) ) { String wsaAction = synCtx . getWSAAction ( ) ; if ( wsaAction != null ) { return wsaAction ; } else { return NULL_STRING ; } } else if ( SynapseConstants . HEADER_FAULT . equals ( key ) ) { EndpointReference faultEPR = synCtx . getFaultTo ( ) ; if ( faultEPR != null ) { return faultEPR . getAddress ( ) ; } else { return NULL_STRING ; } } else if ( SynapseConstants . HEADER_REPLY_TO . equals ( key ) ) { EndpointReference replyToEPR = synCtx . getReplyTo ( ) ; if ( replyToEPR != null ) { return replyToEPR . getAddress ( ) ; } else { return NULL_STRING ; } } else if ( SynapseConstants . HEADER_MESSAGE_ID . equals ( key ) ) { String messageID = synCtx . getMessageID ( ) ; if ( messageID != null ) { return messageID ; } else { return NULL_STRING ; } } else if ( SynapseConstants . PROPERTY_MESSAGE_FORMAT . equals ( key ) ) { if ( synCtx . isDoingPOX ( ) ) return SynapseConstants . FORMAT_POX ; else if ( synCtx . isDoingGET ( ) ) return SynapseConstants . FORMAT_GET ; else if ( synCtx . isSOAP11 ( ) ) return SynapseConstants . FORMAT_SOAP11 ; else return SynapseConstants . FORMAT_SOAP12 ; } else if ( SynapseConstants . PROPERTY_OPERATION_NAME . equals ( key ) || SynapseConstants . PROPERTY_OPERATION_NAMESPACE . equals ( key ) ) { if ( synCtx instanceof Axis2MessageContext ) { AxisOperation axisOperation = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) . getAxisOperation ( ) ; if ( axisOperation != null ) { if ( SynapseConstants . PROPERTY_OPERATION_NAMESPACE . equals ( key ) ) { return axisOperation . getName ( ) . getNamespaceURI ( ) ; } else { return axisOperation . getName ( ) . getLocalPart ( ) ; } } } } else { Object result = synCtx . getProperty ( key ) ; if ( result != null ) { return result ; } else { return synCtx . getEntry ( key ) ; } } } else if ( XMLConfigConstants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; return axis2MessageContext . getProperty ( key ) ; } else if ( XMLConfigConstants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { org . apache . axis2 . context . MessageContext axis2MessageContext = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ; Object headers = axis2MessageContext . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( Map ) headers ; return headersMap . get ( key ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Invalid scope : '" + scope + "' has been set for the " + "synapse:get-property(scope,prop-name) XPath function" ) ; } } return NULL_STRING ; } private void traceOrDebug ( boolean traceOn , String msg ) { if ( traceOn ) { trace . info ( msg ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( msg ) ; } } } 	1	['7', '1', '0', '13', '50', '0', '1', '12', '5', '0.625', '488', '0.75', '1', '0', '0.270833333', '0', '0', '68.14285714', '39', '6.4286', '2']
package org . apache . synapse . mediators . ext ; import org . apache . synapse . Command ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . annotations . Namespaces ; import org . apache . synapse . mediators . annotations . ReadAndUpdate ; import org . apache . synapse . mediators . annotations . ReadFromMessage ; import org . apache . synapse . mediators . annotations . UpdateMessage ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class AnnotatedCommandMediator extends POJOCommandMediator { protected Map < Field , SynapseXPath > beforeFields ; protected Map < Method , SynapseXPath > beforeMethods ; protected Map < Field , SynapseXPath > afterFields ; protected Map < Method , SynapseXPath > afterMethods ; @ Override public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : POJOCommand mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating a new instance of POJO class : " + getCommand ( ) . getClass ( ) ) ; } Object commandObject = null ; try { commandObject = getCommand ( ) . newInstance ( ) ; } catch ( Exception e ) { handleException ( "Error creating an instance of the POJO command class : " + getCommand ( ) . getClass ( ) , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Instance created, setting static and dynamic properties" ) ; } for ( Iterator iter = getStaticSetterProperties ( ) . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; setInstanceProperty ( name , ( String ) getStaticSetterProperties ( ) . get ( name ) , commandObject , synCtx ) ; } for ( Field f : beforeFields . keySet ( ) ) { SynapseXPath xpath = beforeFields . get ( f ) ; Object v ; if ( f . getType ( ) . equals ( String . class ) ) { v = xpath . stringValueOf ( synCtx ) ; } else { throw new UnsupportedOperationException ( "non-String types not supportted yet" ) ; } try { f . set ( commandObject , v ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } for ( Method m : beforeMethods . keySet ( ) ) { SynapseXPath xpath = beforeMethods . get ( m ) ; Object v ; if ( m . getParameterTypes ( ) . length == 1 && m . getParameterTypes ( ) [ 0 ] . equals ( String . class ) ) { v = xpath . stringValueOf ( synCtx ) ; } else { throw new UnsupportedOperationException ( "non-String types not supportted yet" ) ; } try { m . invoke ( commandObject , v ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "POJO initialized successfully, invoking the execute() method" ) ; } if ( commandObject instanceof Command ) { try { ( ( Command ) commandObject ) . execute ( ) ; } catch ( Exception e ) { handleException ( "Error invoking POJO command class : " + getCommand ( ) . getClass ( ) , e , synCtx ) ; } } else { Method exeMethod = null ; try { exeMethod = getCommand ( ) . getMethod ( "execute" , new Class [ ] { } ) ; exeMethod . invoke ( commandObject , new Object [ ] { } ) ; } catch ( NoSuchMethodException e ) { handleException ( "Cannot locate an execute() method on POJO class : " + getCommand ( ) . getClass ( ) , e , synCtx ) ; } catch ( Exception e ) { handleException ( "Error invoking the execute() method on POJO class : " + getCommand ( ) . getClass ( ) , e , synCtx ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : POJOCommand mediator" ) ; } return true ; } @ Override public void setCommand ( Class commandClass ) { super . setCommand ( commandClass ) ; introspectClass ( commandClass ) ; } protected void introspectClass ( Class < ? > commandClass ) { beforeFields = new HashMap < Field , SynapseXPath > ( ) ; afterFields = new HashMap < Field , SynapseXPath > ( ) ; beforeMethods = new HashMap < Method , SynapseXPath > ( ) ; afterMethods = new HashMap < Method , SynapseXPath > ( ) ; for ( Field f : commandClass . getDeclaredFields ( ) ) { ReadFromMessage readFromMessage = f . getAnnotation ( ReadFromMessage . class ) ; if ( readFromMessage != null ) { SynapseXPath axiomXpath = createSynapseXPATH ( readFromMessage . value ( ) , f . getAnnotation ( Namespaces . class ) ) ; beforeFields . put ( f , axiomXpath ) ; } UpdateMessage updateMessage = f . getAnnotation ( UpdateMessage . class ) ; if ( updateMessage != null ) { SynapseXPath axiomXpath = createSynapseXPATH ( updateMessage . value ( ) , f . getAnnotation ( Namespaces . class ) ) ; afterFields . put ( f , axiomXpath ) ; } ReadAndUpdate readAndUpdate = f . getAnnotation ( ReadAndUpdate . class ) ; if ( readAndUpdate != null ) { SynapseXPath axiomXpath = createSynapseXPATH ( readAndUpdate . value ( ) , f . getAnnotation ( Namespaces . class ) ) ; beforeFields . put ( f , axiomXpath ) ; afterFields . put ( f , axiomXpath ) ; } } for ( Method m : commandClass . getDeclaredMethods ( ) ) { ReadFromMessage readFromMessage = m . getAnnotation ( ReadFromMessage . class ) ; if ( readFromMessage != null ) { SynapseXPath axiomXpath = createSynapseXPATH ( readFromMessage . value ( ) , m . getAnnotation ( Namespaces . class ) ) ; beforeMethods . put ( m , axiomXpath ) ; } UpdateMessage updateMessage = m . getAnnotation ( UpdateMessage . class ) ; if ( updateMessage != null ) { SynapseXPath axiomXpath = createSynapseXPATH ( updateMessage . value ( ) , m . getAnnotation ( Namespaces . class ) ) ; afterMethods . put ( m , axiomXpath ) ; } } } protected SynapseXPath createSynapseXPATH ( String xpath , Namespaces nsAnnotation ) { Map < String , String > namespaces = getNamespaces ( nsAnnotation ) ; try { SynapseXPath axiomXPath = new SynapseXPath ( xpath ) ; for ( String prefix : namespaces . keySet ( ) ) { axiomXPath . addNamespace ( prefix , namespaces . get ( prefix ) ) ; } return axiomXPath ; } catch ( JaxenException e ) { throw new RuntimeException ( "Error creating SynapseXPath: " + xpath , e ) ; } } protected Map < String , String > getNamespaces ( Namespaces namespaces ) { Map < String , String > allNamespaces = new HashMap < String , String > ( ) ; Namespaces defaultNamespaces = ( ( Class < ? > ) getCommand ( ) ) . getAnnotation ( Namespaces . class ) ; if ( defaultNamespaces != null ) { for ( String namespaceValue : defaultNamespaces . value ( ) ) { int i = namespaceValue . indexOf ( ':' ) ; if ( i > 0 ) { String prefix = namespaceValue . substring ( 0 , i ) ; String namespace = namespaceValue . substring ( i + 1 ) ; allNamespaces . put ( prefix , namespace ) ; } } } if ( namespaces != null ) { for ( String namespaceValue : namespaces . value ( ) ) { int i = namespaceValue . indexOf ( ':' ) ; if ( i > 0 ) { String prefix = namespaceValue . substring ( 0 , i ) ; String namespace = namespaceValue . substring ( i + 1 ) ; allNamespaces . put ( prefix , namespace ) ; } } } return allNamespaces ; } } 	1	['6', '3', '0', '12', '56', '13', '1', '11', '3', '0.7', '606', '1', '0', '0.848484848', '0.4', '2', '4', '99.33333333', '15', '5.5', '1']
package org . apache . synapse . mediators . eip . splitter ; import org . apache . synapse . MessageContext ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . util . MessageHelper ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . mediators . eip . Target ; import org . apache . synapse . mediators . eip . EIPConstants ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . context . OperationContext ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; public class CloneMediator extends AbstractMediator implements ManagedLifecycle { private boolean continueParent = false ; private List < Target > targets = new ArrayList < Target > ( ) ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Clone mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } Iterator < Target > iter = targets . iterator ( ) ; int i = 0 ; while ( iter . hasNext ( ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Submitting " + ( i + 1 ) + " of " + targets . size ( ) + " messages for processing in parallel" ) ; } iter . next ( ) . mediate ( getClonedMessageContext ( synCtx , i ++ , targets . size ( ) ) ) ; } OperationContext opCtx = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) . getOperationContext ( ) ; if ( ! continueParent && opCtx != null ) { opCtx . setProperty ( Constants . RESPONSE_WRITTEN , "SKIP" ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Clone mediator" ) ; } return continueParent ; } private MessageContext getClonedMessageContext ( MessageContext synCtx , int messageSequence , int messageCount ) { MessageContext newCtx = null ; try { newCtx = MessageHelper . cloneMessageContext ( synCtx ) ; newCtx . setProperty ( EIPConstants . MESSAGE_SEQUENCE , String . valueOf ( messageSequence ) + EIPConstants . MESSAGE_SEQUENCE_DELEMITER + messageCount ) ; } catch ( AxisFault axisFault ) { handleException ( "Error cloning the message context" , axisFault , synCtx ) ; } return newCtx ; } public boolean isContinueParent ( ) { return continueParent ; } public void setContinueParent ( boolean continueParent ) { this . continueParent = continueParent ; } public List < Target > getTargets ( ) { return targets ; } public void setTargets ( List < Target > targets ) { this . targets = targets ; } public void addTarget ( Target target ) { this . targets . add ( target ) ; } public void init ( SynapseEnvironment se ) { for ( Target target : targets ) { SequenceMediator seq = target . getSequence ( ) ; if ( seq != null ) { seq . init ( se ) ; } } } public void destroy ( ) { for ( Target target : targets ) { SequenceMediator seq = target . getSequence ( ) ; if ( seq != null ) { seq . destroy ( ) ; } } } } 	1	['10', '2', '0', '15', '39', '0', '2', '13', '9', '0.5', '210', '1', '0', '0.590909091', '0.242857143', '0', '0', '19.8', '9', '1.9', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . OperationContext ; import org . apache . axis2 . context . ServiceContext ; import org . apache . axis2 . description . InOutAxisOperation ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . mediators . MediatorWorker ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . statistics . StatisticsCollector ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . util . UUIDGenerator ; import org . apache . synapse . util . TemporaryData ; import org . apache . synapse . util . concurrent . SynapseThreadPool ; import java . util . concurrent . ExecutorService ; public class Axis2SynapseEnvironment implements SynapseEnvironment { private static final Log log = LogFactory . getLog ( Axis2SynapseEnvironment . class ) ; private SynapseConfiguration synapseConfig ; private ConfigurationContext configContext ; private ExecutorService executorService ; private boolean initialized = false ; private StatisticsCollector statisticsCollector ; public Axis2SynapseEnvironment ( SynapseConfiguration synCfg ) { int coreThreads = SynapseThreadPool . SYNAPSE_CORE_THREADS ; int maxThreads = SynapseThreadPool . SYNAPSE_MAX_THREADS ; long keepAlive = SynapseThreadPool . SYNAPSE_KEEP_ALIVE ; int qlength = SynapseThreadPool . SYNAPSE_THREAD_QLEN ; try { qlength = Integer . parseInt ( synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_QLEN ) ) ; } catch ( Exception ignore ) { } try { coreThreads = Integer . parseInt ( synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_CORE ) ) ; } catch ( Exception ignore ) { } try { maxThreads = Integer . parseInt ( synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_MAX ) ) ; } catch ( Exception ignore ) { } try { keepAlive = Long . parseLong ( synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_ALIVE ) ) ; } catch ( Exception ignore ) { } this . executorService = new SynapseThreadPool ( coreThreads , maxThreads , keepAlive , qlength , synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_GROUP , SynapseThreadPool . SYNAPSE_THREAD_GROUP ) , synCfg . getProperty ( SynapseThreadPool . SYN_THREAD_IDPREFIX , SynapseThreadPool . SYNAPSE_THREAD_ID_PREFIX ) ) ; } public Axis2SynapseEnvironment ( ConfigurationContext cfgCtx , SynapseConfiguration synapseConfig ) { this ( synapseConfig ) ; this . configContext = cfgCtx ; this . synapseConfig = synapseConfig ; } public boolean injectMessage ( final MessageContext synCtx ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Injecting MessageContext" ) ; } synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } Mediator mandatorySeq = synCtx . getConfiguration ( ) . getMandatorySequence ( ) ; if ( mandatorySeq != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Start mediating the message in the " + "pre-mediate state using the mandatory sequence" ) ; } if ( ! mandatorySeq . mediate ( synCtx ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( ( synCtx . isResponse ( ) ? "Response" : "Request" ) + " message for the " + ( synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) != null ? "proxy service " + synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) : "message mediation" ) + " dropped in the " + "pre-mediation state by the mandatory sequence : \n" + synCtx ) ; } return false ; } } if ( synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) != null ) { if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) != null ) { String sequenceName = synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) ) . getTargetOutSequence ( ) ; Mediator outSequence = synCtx . getSequence ( sequenceName ) ; if ( outSequence != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using the sequence named " + sequenceName + " for the outgoing message mediation of the proxy service " + synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) ) ; } outSequence . mediate ( synCtx ) ; } else { log . error ( "Unable to find the out-sequence " + "specified by the name " + sequenceName ) ; throw new SynapseException ( "Unable to find the " + "out-sequence specified by the name " + sequenceName ) ; } } else if ( synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using the anonymous out-sequence specified in the proxy service " + synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) + " for outgoing message mediation" ) ; } synCtx . getConfiguration ( ) . getProxyService ( ( String ) synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) ) . getTargetInLineOutSequence ( ) . mediate ( synCtx ) ; } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy service " + synCtx . getProperty ( SynapseConstants . PROXY_SERVICE ) + " does not specifies an out-sequence - sending the response back" ) ; } Axis2Sender . sendBack ( synCtx ) ; } } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using Main Sequence for injected message" ) ; } return synCtx . getMainSequence ( ) . mediate ( synCtx ) ; } return true ; } public void injectAsync ( final MessageContext synCtx , SequenceMediator seq ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Injecting MessageContext for asynchronous mediation using the : " + ( seq . getName ( ) == null ? "Anonymous" : seq . getName ( ) ) + " Sequence" ) ; } synCtx . setEnvironment ( this ) ; if ( synCtx . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processSequenceStatistics ( synCtx ) ; } executorService . execute ( new MediatorWorker ( seq , synCtx ) ) ; } public void send ( EndpointDefinition endpoint , MessageContext synCtx ) { if ( synCtx . isResponse ( ) ) { if ( endpoint != null ) { StatisticsUtils . processEndPointStatistics ( synCtx ) ; StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processAllSequenceStatistics ( synCtx ) ; Axis2Sender . sendOn ( endpoint , synCtx ) ; } else { Axis2Sender . sendBack ( synCtx ) ; } } else { Axis2Sender . sendOn ( endpoint , synCtx ) ; } } public MessageContext createMessageContext ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Creating Message Context" ) ; } org . apache . axis2 . context . MessageContext axis2MC = new org . apache . axis2 . context . MessageContext ( ) ; axis2MC . setConfigurationContext ( this . configContext ) ; ServiceContext svcCtx = new ServiceContext ( ) ; OperationContext opCtx = new OperationContext ( new InOutAxisOperation ( ) , svcCtx ) ; axis2MC . setServiceContext ( svcCtx ) ; axis2MC . setOperationContext ( opCtx ) ; MessageContext mc = new Axis2MessageContext ( axis2MC , synapseConfig , this ) ; mc . setMessageID ( UUIDGenerator . getUUID ( ) ) ; try { mc . setEnvelope ( OMAbstractFactory . getSOAP12Factory ( ) . createSOAPEnvelope ( ) ) ; mc . getEnvelope ( ) . addChild ( OMAbstractFactory . getSOAP12Factory ( ) . createSOAPBody ( ) ) ; } catch ( Exception e ) { handleException ( "Unable to attach the SOAP envelope to " + "the created new message context" , e ) ; } return mc ; } public TemporaryData createTemporaryData ( ) { String chkSize = synapseConfig . getProperty ( SynapseConstants . CHUNK_SIZE ) ; String chukNumber = synapseConfig . getProperty ( SynapseConstants . THRESHOLD_CHUNKS ) ; int numberOfChunks = SynapseConstants . DEFAULT_THRESHOLD_CHUNKS ; int chunkSize = SynapseConstants . DEFAULT_CHUNK_SIZE ; if ( chkSize != null ) { chunkSize = Integer . parseInt ( chkSize ) ; } if ( chukNumber != null ) { numberOfChunks = Integer . parseInt ( chukNumber ) ; } String tempPrefix = synapseConfig . getProperty ( SynapseConstants . TEMP_FILE_PREFIX , SynapseConstants . DEFAULT_TEMPFILE_PREFIX ) ; String tempSuffix = synapseConfig . getProperty ( SynapseConstants . TEMP_FILE_SUFIX , SynapseConstants . DEFAULT_TEMPFILE_SUFIX ) ; return new TemporaryData ( numberOfChunks , chunkSize , tempPrefix , tempSuffix ) ; } public StatisticsCollector getStatisticsCollector ( ) { return statisticsCollector ; } public void setStatisticsCollector ( StatisticsCollector collector ) { this . statisticsCollector = collector ; } public ExecutorService getExecutorService ( ) { return executorService ; } public boolean isInitialized ( ) { return initialized ; } public void setInitialized ( boolean state ) { this . initialized = state ; } private void handleException ( String message , Throwable e ) { log . error ( message , e ) ; throw new SynapseException ( message , e ) ; } } 	1	['14', '1', '0', '30', '69', '51', '1', '29', '12', '0.820512821', '511', '1', '2', '0', '0.192307692', '0', '0', '35.07142857', '17', '2.5', '1']
package org . apache . synapse . mediators . builtin ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . axis2 . context . OperationContext ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . clustering . ClusterManager ; import java . util . List ; import java . util . Iterator ; public class SendMediator extends AbstractMediator { private Endpoint endpoint = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Send mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( synCtx . isResponse ( ) ) { Axis2MessageContext axis2MsgCtx = ( Axis2MessageContext ) synCtx ; OperationContext opCtx = axis2MsgCtx . getAxis2MessageContext ( ) . getOperationContext ( ) ; boolean isClusteringEnable = false ; org . apache . axis2 . context . MessageContext axisMC = axis2MsgCtx . getAxis2MessageContext ( ) ; ConfigurationContext cc = axisMC . getConfigurationContext ( ) ; ClusterManager clusterManager = cc . getAxisConfiguration ( ) . getClusterManager ( ) ; if ( clusterManager != null && clusterManager . getContextManager ( ) != null ) { isClusteringEnable = true ; } if ( isClusteringEnable ) { Object epNames = opCtx . getPropertyNonReplicable ( SALoadbalanceEndpoint . ENDPOINT_NAME_LIST ) ; if ( epNames != null && epNames instanceof List ) { List epNameList = ( List ) epNames ; Object obj = epNameList . remove ( 0 ) ; if ( obj != null && obj instanceof String ) { Object rootEPObj = opCtx . getPropertyNonReplicable ( SALoadbalanceEndpoint . ROOT_ENDPOINT ) ; if ( rootEPObj != null && rootEPObj instanceof Endpoint ) { String name = ( ( Endpoint ) rootEPObj ) . getName ( ) ; if ( name != null && name . equals ( obj ) ) { Endpoint rootEP = ( ( Endpoint ) rootEPObj ) ; if ( rootEP instanceof SALoadbalanceEndpoint ) { SALoadbalanceEndpoint salEP = ( SALoadbalanceEndpoint ) rootEP ; salEP . updateSession ( synCtx , epNameList , isClusteringEnable ) ; } } } } opCtx . setProperty ( SALoadbalanceEndpoint . ENDPOINT_NAME_LIST , epNames ) ; } } else { Object o = opCtx . getProperty ( SALoadbalanceEndpoint . ENDPOINT_LIST ) ; if ( o != null && o instanceof List ) { List epList = ( List ) o ; Object e = epList . remove ( 0 ) ; if ( e != null ) { if ( e instanceof SALoadbalanceEndpoint ) { SALoadbalanceEndpoint salEP = ( SALoadbalanceEndpoint ) e ; salEP . updateSession ( synCtx , epList , isClusteringEnable ) ; } } } } } if ( endpoint == null ) { if ( traceOrDebugOn ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "Sending " + ( synCtx . isResponse ( ) ? "response" : "request" ) + " message using implicit message properties.." ) ; sb . append ( "\nSending To: " + ( synCtx . getTo ( ) != null ? synCtx . getTo ( ) . getAddress ( ) : "null" ) ) ; sb . append ( "\nSOAPAction: " + ( synCtx . getWSAAction ( ) != null ? synCtx . getWSAAction ( ) : "null" ) ) ; traceOrDebug ( traceOn , sb . toString ( ) ) ; } if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Envelope : " + synCtx . getEnvelope ( ) ) ; } synCtx . getEnvironment ( ) . send ( null , synCtx ) ; } else { endpoint . send ( synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Send mediator" ) ; } return true ; } public Endpoint getEndpoint ( ) { return endpoint ; } public void setEndpoint ( Endpoint endpoint ) { this . endpoint = endpoint ; } } 	1	['4', '2', '0', '18', '38', '0', '2', '16', '4', '0', '268', '1', '1', '0.8125', '0.5', '0', '0', '65.75', '27', '7.25', '2']
package org . apache . synapse . config . xml ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Collection ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . axiom . om . OMNamespace ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . config . xml . endpoints . EndpointSerializer ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . Startup ; public class SynapseXMLConfigurationSerializer implements ConfigurationSerializer { private static final Log log = LogFactory . getLog ( XMLConfigurationSerializer . class ) ; private static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; private static final OMNamespace synNS = fac . createOMNamespace ( XMLConfigConstants . SYNAPSE_NAMESPACE , "syn" ) ; private static final OMNamespace nullNS = fac . createOMNamespace ( XMLConfigConstants . NULL_NAMESPACE , "" ) ; public OMElement serializeConfiguration ( SynapseConfiguration synCfg ) { OMElement definitions = fac . createOMElement ( "definitions" , synNS ) ; if ( synCfg . getRegistry ( ) != null ) { RegistrySerializer . serializeRegistry ( definitions , synCfg . getRegistry ( ) ) ; } Iterator iter = synCfg . getProxyServices ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ProxyService service = ( ProxyService ) iter . next ( ) ; ProxyServiceSerializer . serializeProxy ( definitions , service ) ; } Map entries = new HashMap ( ) ; Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; Map sequences = new HashMap ( ) ; iter = synCfg . getLocalRegistry ( ) . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; Object o = synCfg . getLocalRegistry ( ) . get ( key ) ; if ( o instanceof Mediator ) { sequences . put ( key , o ) ; } else if ( o instanceof Endpoint ) { endpoints . put ( key . toString ( ) , ( Endpoint ) o ) ; } else if ( o instanceof Entry ) { entries . put ( key , o ) ; } else { handleException ( "Unknown object : " + o . getClass ( ) + " for serialization into Synapse configuration" ) ; } } serializeEntries ( definitions , entries ) ; serializeEndpoints ( definitions , endpoints ) ; serializeSequences ( definitions , sequences ) ; serializeStartups ( definitions , synCfg . getStartups ( ) ) ; return definitions ; } private static void serializeEntries ( OMElement definitions , Map entries ) { Iterator iter = entries . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; EntrySerializer . serializeEntry ( ( Entry ) entries . get ( key ) , definitions ) ; } } private static void serializeStartups ( OMElement definitions , Collection startups ) { Iterator it = startups . iterator ( ) ; while ( it . hasNext ( ) ) { Startup s = ( Startup ) it . next ( ) ; StartupFinder . getInstance ( ) . serializeStartup ( definitions , s ) ; } } private static void serializeEndpoints ( OMElement definitions , Map < String , Endpoint > endpoints ) { for ( Endpoint endpoint : endpoints . values ( ) ) { definitions . addChild ( EndpointSerializer . getElementFromEndpoint ( endpoint ) ) ; } } private static void serializeSequences ( OMElement definitions , Map sequences ) { Iterator iter = sequences . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = ( String ) iter . next ( ) ; Mediator mediator = ( Mediator ) sequences . get ( key ) ; MediatorSerializerFinder . getInstance ( ) . getSerializer ( mediator ) . serializeMediator ( definitions , mediator ) ; } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } public QName getTagQName ( ) { return XMLConfigConstants . DEFINITIONS_ELT ; } } 	1	['9', '1', '0', '24', '45', '32', '0', '24', '3', '0.875', '235', '1', '0', '0', '0.270833333', '0', '0', '24.66666667', '7', '1.8889', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . deployment . Deployer ; import org . apache . axis2 . deployment . DeploymentClassLoader ; import org . apache . axis2 . deployment . DeploymentException ; import org . apache . axis2 . deployment . repository . util . DeploymentFileData ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . config . xml . MediatorFactory ; import org . apache . synapse . config . xml . MediatorFactoryFinder ; import org . apache . synapse . config . xml . MediatorSerializer ; import org . apache . synapse . config . xml . MediatorSerializerFinder ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; public class MediatorDeployer implements Deployer { private static final Log log = LogFactory . getLog ( MediatorDeployer . class ) ; private ConfigurationContext cfgCtx = null ; public void init ( ConfigurationContext configurationContext ) { this . cfgCtx = configurationContext ; } public void deploy ( DeploymentFileData deploymentFileData ) throws DeploymentException { log . info ( "Loading mediator from: " + deploymentFileData . getAbsolutePath ( ) ) ; ClassLoader prevCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { DeploymentClassLoader urlCl = new DeploymentClassLoader ( new URL [ ] { deploymentFileData . getFile ( ) . toURL ( ) } , null , prevCl ) ; Thread . currentThread ( ) . setContextClassLoader ( urlCl ) ; URL facURL = urlCl . findResource ( "META-INF/services/org.apache.synapse.config.xml.MediatorFactory" ) ; if ( facURL != null ) { InputStream facStream = facURL . openStream ( ) ; InputStreamReader facreader = new InputStreamReader ( facStream ) ; StringBuffer facSB = new StringBuffer ( ) ; int c ; while ( ( c = facreader . read ( ) ) != - 1 ) { facSB . append ( ( char ) c ) ; } String [ ] facClassNames = facSB . toString ( ) . split ( "\n" ) ; for ( String facClassName : facClassNames ) { log . info ( "Registering the Mediator factory: " + facClassName ) ; Class facClass = urlCl . loadClass ( facClassName ) ; MediatorFactory facInst = ( MediatorFactory ) facClass . newInstance ( ) ; MediatorFactoryFinder . getInstance ( ) . getFactoryMap ( ) . put ( facInst . getTagQName ( ) , facClass ) ; log . info ( "Mediator loaded and registered for " + "the tag name: " + facInst . getTagQName ( ) ) ; } } else { handleException ( "Unable to find the MediatorFactory implementation. " + "Unable to register the MediatorFactory with the FactoryFinder" ) ; } URL serURL = urlCl . findResource ( "META-INF/services/org.apache.synapse.config.xml.MediatorSerializer" ) ; if ( serURL != null ) { InputStream serStream = serURL . openStream ( ) ; InputStreamReader serReader = new InputStreamReader ( serStream ) ; StringBuffer serSB = new StringBuffer ( ) ; int c ; while ( ( c = serReader . read ( ) ) != - 1 ) { serSB . append ( ( char ) c ) ; } String [ ] serClassNames = serSB . toString ( ) . split ( "\n" ) ; for ( String serClassName : serClassNames ) { log . info ( "Registering the Mediator serializer: " + serClassName ) ; Class serClass = urlCl . loadClass ( serClassName ) ; MediatorSerializer serInst = ( MediatorSerializer ) serClass . newInstance ( ) ; MediatorSerializerFinder . getInstance ( ) . getSerializerMap ( ) . put ( serInst . getMediatorClassName ( ) , serInst ) ; log . info ( "Mediator loaded and registered for " + "the serialization as: " + serInst . getMediatorClassName ( ) ) ; } } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Unable to find the MediatorSerializer implementation. " + "Unable to register the MediatorSerializer with the SerializerFinder" ) ; } } } catch ( IOException e ) { handleException ( "I/O error in reading the mediator jar file" , e ) ; } catch ( ClassNotFoundException e ) { handleException ( "Unable to find the specified class on the path or in the jar file" , e ) ; } catch ( IllegalAccessException e ) { handleException ( "Unable to load the class from the jar" , e ) ; } catch ( InstantiationException e ) { handleException ( "Unable to instantiate the class specified" , e ) ; } finally { if ( log . isDebugEnabled ( ) ) { log . debug ( "Restoring the context class loader to the original" ) ; } Thread . currentThread ( ) . setContextClassLoader ( prevCl ) ; } } public void setDirectory ( String string ) { } public void setExtension ( String string ) { } public void unDeploy ( String string ) throws DeploymentException { } private void handleException ( String message , Exception e ) throws DeploymentException { if ( log . isDebugEnabled ( ) ) { log . debug ( message , e ) ; } throw new DeploymentException ( message , e ) ; } private void handleException ( String message ) throws DeploymentException { if ( log . isDebugEnabled ( ) ) { log . debug ( message ) ; } throw new DeploymentException ( message ) ; } } 	1	['9', '1', '0', '11', '45', '22', '0', '11', '6', '0.75', '351', '1', '0', '0', '0.4', '0', '0', '37.77777778', '1', '0.7778', '2']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . LoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import java . util . List ; public class LoadbalanceEndpointSerializer extends EndpointSerializer { protected OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof LoadbalanceEndpoint ) ) { throw new SynapseException ( "Invalid endpoint type." ) ; } fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; LoadbalanceEndpoint loadbalanceEndpoint = ( LoadbalanceEndpoint ) endpoint ; String name = loadbalanceEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } OMElement loadbalanceElement = fac . createOMElement ( "loadbalance" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; endpointElement . addChild ( loadbalanceElement ) ; LoadbalanceAlgorithm algorithm = loadbalanceEndpoint . getAlgorithm ( ) ; String algorithmName = "roundRobin" ; if ( algorithm instanceof RoundRobin ) { algorithmName = "roundRobin" ; } loadbalanceElement . addAttribute ( XMLConfigConstants . ALGORITHM_NAME , algorithmName , null ) ; if ( ! loadbalanceEndpoint . isFailover ( ) ) { loadbalanceElement . addAttribute ( "failover" , "false" , null ) ; } for ( Endpoint childEndpoint : loadbalanceEndpoint . getEndpoints ( ) ) { loadbalanceElement . addChild ( EndpointSerializer . getElementFromEndpoint ( childEndpoint ) ) ; } return endpointElement ; } } 	1	['2', '2', '0', '13', '16', '1', '1', '13', '1', '2', '88', '0', '0', '0.857142857', '0.75', '1', '2', '43', '6', '3', '1']
package org . apache . synapse . mediators . eip . aggregator ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . soap . SOAP12Constants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . mediators . eip . EIPConstants ; import org . apache . synapse . mediators . eip . EIPUtils ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class AggregateMediator extends AbstractMediator { private static final Log log = LogFactory . getLog ( AggregateMediator . class ) ; private static final Log trace = LogFactory . getLog ( SynapseConstants . TRACE_LOGGER ) ; private long completionTimeoutMillis = 0 ; private int minMessagesToComplete = - 1 ; private int maxMessagesToComplete = - 1 ; private SynapseXPath correlateExpression = null ; private SynapseXPath aggregationExpression = null ; private String onCompleteSequenceRef = null ; private SequenceMediator onCompleteSequence = null ; private Map < String , Aggregate > activeAggregates = Collections . synchronizedMap ( new HashMap < String , Aggregate > ( ) ) ; private final Object lock = new Object ( ) ; public AggregateMediator ( ) { try { aggregationExpression = new SynapseXPath ( "s11:Body/child::*[position()=1] | " + "s12:Body/child::*[position()=1]" ) ; aggregationExpression . addNamespace ( "s11" , SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; aggregationExpression . addNamespace ( "s12" , SOAP12Constants . SOAP_ENVELOPE_NAMESPACE_URI ) ; } catch ( JaxenException e ) { if ( log . isDebugEnabled ( ) ) { handleException ( "Unable to set the default " + "aggregationExpression for the aggregation" , e , null ) ; } } } public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Aggregate mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } try { Aggregate aggregate = null ; if ( correlateExpression != null && correlateExpression . evaluate ( synCtx ) != null ) { while ( aggregate == null ) { synchronized ( lock ) { if ( activeAggregates . containsKey ( correlateExpression . toString ( ) ) ) { aggregate = activeAggregates . get ( correlateExpression . toString ( ) ) ; if ( aggregate != null ) { if ( ! aggregate . getLock ( ) ) { aggregate = null ; } } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating new Aggregator - " + ( completionTimeoutMillis > 0 ? "expires in : " + ( completionTimeoutMillis / 1000 ) + "secs" : "without expiry time" ) ) ; } aggregate = new Aggregate ( correlateExpression . toString ( ) , completionTimeoutMillis , minMessagesToComplete , maxMessagesToComplete , this ) ; if ( completionTimeoutMillis > 0 ) { synCtx . getConfiguration ( ) . getSynapseTimer ( ) . schedule ( aggregate , completionTimeoutMillis ) ; } aggregate . getLock ( ) ; activeAggregates . put ( correlateExpression . toString ( ) , aggregate ) ; } } } } else if ( synCtx . getProperty ( EIPConstants . AGGREGATE_CORRELATION ) != null ) { Object o = synCtx . getProperty ( EIPConstants . AGGREGATE_CORRELATION ) ; String correlation ; if ( o != null && o instanceof String ) { correlation = ( String ) o ; while ( aggregate == null ) { synchronized ( lock ) { if ( activeAggregates . containsKey ( correlation ) ) { aggregate = activeAggregates . get ( correlation ) ; if ( aggregate != null ) { if ( ! aggregate . getLock ( ) ) { aggregate = null ; } } else { break ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating new Aggregator - " + ( completionTimeoutMillis > 0 ? "expires in : " + ( completionTimeoutMillis / 1000 ) + "secs" : "without expiry time" ) ) ; } aggregate = new Aggregate ( correlation , completionTimeoutMillis , minMessagesToComplete , maxMessagesToComplete , this ) ; if ( completionTimeoutMillis > 0 ) { synCtx . getConfiguration ( ) . getSynapseTimer ( ) . schedule ( aggregate , completionTimeoutMillis ) ; } aggregate . getLock ( ) ; activeAggregates . put ( correlation , aggregate ) ; } } } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Unable to find aggrgation correlation property" ) ; } return true ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Unable to find aggrgation correlation XPath or property" ) ; } return true ; } if ( aggregate != null ) { boolean collected = aggregate . addMessage ( synCtx ) ; if ( traceOrDebugOn ) { if ( collected ) { traceOrDebug ( traceOn , "Collected a message during aggregation" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Collected message : " + synCtx ) ; } } } if ( aggregate . isComplete ( traceOn , traceOrDebugOn , trace , log ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Aggregation completed - invoking onComplete" ) ; } completeAggregate ( aggregate ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Aggregate mediator" ) ; } return true ; } else { aggregate . releaseLock ( ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Unable to find an aggregate for this message - skip" ) ; } return true ; } } catch ( JaxenException e ) { handleException ( "Unable to execute the XPATH over the message" , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Aggregate mediator" ) ; } return false ; } public synchronized void completeAggregate ( Aggregate aggregate ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Aggregation completed or timed out" ) ; } aggregate . cancel ( ) ; aggregate . setCompleted ( true ) ; MessageContext newSynCtx = getAggregatedMessage ( aggregate ) ; if ( newSynCtx == null ) { log . warn ( "An aggregation of messages timed out with no aggregated messages" , null ) ; return ; } activeAggregates . remove ( aggregate . getCorrelation ( ) ) ; if ( ( correlateExpression != null && ! correlateExpression . toString ( ) . equals ( aggregate . getCorrelation ( ) ) ) || correlateExpression == null ) { if ( onCompleteSequence != null ) { onCompleteSequence . mediate ( newSynCtx ) ; } else if ( onCompleteSequenceRef != null && newSynCtx . getSequence ( onCompleteSequenceRef ) != null ) { newSynCtx . getSequence ( onCompleteSequenceRef ) . mediate ( newSynCtx ) ; } else { handleException ( "Unable to find the sequence for the mediation " + "of the aggregated message" , newSynCtx ) ; } } } private MessageContext getAggregatedMessage ( Aggregate aggregate ) { MessageContext newCtx = null ; for ( MessageContext synCtx : aggregate . getMessages ( ) ) { if ( newCtx == null ) { newCtx = synCtx ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Generating Aggregated message from : " + newCtx . getEnvelope ( ) ) ; } } else { try { if ( log . isDebugEnabled ( ) ) { log . debug ( "Merging message : " + synCtx . getEnvelope ( ) + " using XPath : " + aggregationExpression ) ; } EIPUtils . enrichEnvelope ( newCtx . getEnvelope ( ) , synCtx . getEnvelope ( ) , aggregationExpression ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Merged result : " + newCtx . getEnvelope ( ) ) ; } } catch ( JaxenException e ) { handleException ( "Error merging aggregation results using XPath : " + aggregationExpression . toString ( ) , e , synCtx ) ; } } } return newCtx ; } public SynapseXPath getCorrelateExpression ( ) { return correlateExpression ; } public void setCorrelateExpression ( SynapseXPath correlateExpression ) { this . correlateExpression = correlateExpression ; } public long getCompletionTimeoutMillis ( ) { return completionTimeoutMillis ; } public void setCompletionTimeoutMillis ( long completionTimeoutMillis ) { this . completionTimeoutMillis = completionTimeoutMillis ; } public int getMinMessagesToComplete ( ) { return minMessagesToComplete ; } public void setMinMessagesToComplete ( int minMessagesToComplete ) { this . minMessagesToComplete = minMessagesToComplete ; } public int getMaxMessagesToComplete ( ) { return maxMessagesToComplete ; } public void setMaxMessagesToComplete ( int maxMessagesToComplete ) { this . maxMessagesToComplete = maxMessagesToComplete ; } public SynapseXPath getAggregationExpression ( ) { return aggregationExpression ; } public void setAggregationExpression ( SynapseXPath aggregationExpression ) { this . aggregationExpression = aggregationExpression ; } public String getOnCompleteSequenceRef ( ) { return onCompleteSequenceRef ; } public void setOnCompleteSequenceRef ( String onCompleteSequenceRef ) { this . onCompleteSequenceRef = onCompleteSequenceRef ; } public SequenceMediator getOnCompleteSequence ( ) { return onCompleteSequence ; } public void setOnCompleteSequence ( SequenceMediator onCompleteSequence ) { this . onCompleteSequence = onCompleteSequence ; } public Map getActiveAggregates ( ) { return activeAggregates ; } } 	1	['20', '2', '0', '14', '71', '90', '3', '12', '18', '0.837320574', '677', '1', '3', '0.419354839', '0.190789474', '0', '0', '32.3', '34', '3.1', '2']
package org . apache . synapse . endpoints ; import org . apache . synapse . MessageContext ; public interface Endpoint { public void send ( MessageContext synMessageContext ) ; public void onChildEndpointFail ( Endpoint endpoint , MessageContext synMessageContext ) ; public void setParentEndpoint ( Endpoint parentEndpoint ) ; public String getName ( ) ; public void setName ( String name ) ; public boolean isActive ( MessageContext synMessageContext ) ; public void setActive ( boolean active , MessageContext synMessageContext ) ; } 	1	['7', '1', '0', '48', '7', '21', '48', '1', '7', '2', '7', '0', '0', '0', '0.428571429', '0', '0', '0', '1', '1', '1']
package org . apache . synapse . config . xml ; import java . util . Map ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . core . axis2 . ResourceMap ; public class ResourceMapSerializer { private static final OMFactory fac = OMAbstractFactory . getOMFactory ( ) ; public static void serializeResourceMap ( OMElement parent , ResourceMap resourceMap ) { if ( resourceMap != null ) { for ( Map . Entry < String , String > entry : resourceMap . getResources ( ) . entrySet ( ) ) { OMElement resource = fac . createOMElement ( "resource" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; resource . addAttribute ( "location" , ( String ) entry . getKey ( ) , null ) ; resource . addAttribute ( "key" , ( String ) entry . getValue ( ) , null ) ; parent . addChild ( resource ) ; } } } } 	1	['3', '1', '0', '9', '15', '1', '1', '8', '2', '0.5', '50', '1', '0', '0', '0.5', '0', '0', '15.33333333', '3', '1', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMNode ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . description . * ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . axis2 . engine . AxisEvent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . neethi . Policy ; import org . apache . neethi . PolicyEngine ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . ServerManager ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . util . PolicyInfo ; import org . xml . sax . InputSource ; import javax . xml . namespace . QName ; import javax . xml . stream . XMLStreamException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URL ; import java . util . * ; public class ProxyService { private static final Log log = LogFactory . getLog ( ProxyService . class ) ; private static final Log trace = LogFactory . getLog ( SynapseConstants . TRACE_LOGGER ) ; private final Log serviceLog ; private String name ; private String description ; private ArrayList transports ; private List pinnedServers = new ArrayList ( ) ; private String targetEndpoint = null ; private String targetInSequence = null ; private String targetOutSequence = null ; private String targetFaultSequence = null ; private Endpoint targetInLineEndpoint = null ; private SequenceMediator targetInLineInSequence = null ; private SequenceMediator targetInLineOutSequence = null ; private SequenceMediator targetInLineFaultSequence = null ; private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private String wsdlKey ; private URI wsdlURI ; private Object inLineWSDL ; private ResourceMap resourceMap ; private List < PolicyInfo > policies = new ArrayList < PolicyInfo > ( ) ; private List < String > serviceLevelPolicies = new ArrayList < String > ( ) ; private List < String > inMessagePolicies = new ArrayList < String > ( ) ; private List < String > outMessagePolicies = new ArrayList < String > ( ) ; private boolean wsRMEnabled = false ; private boolean wsSecEnabled = false ; private boolean startOnLoad = true ; private boolean running = false ; public static final String ALL_TRANSPORTS = "all" ; private int statisticsState = SynapseConstants . STATISTICS_UNSET ; protected int traceState = SynapseConstants . TRACING_UNSET ; public ProxyService ( String name ) { this . name = name ; serviceLog = LogFactory . getLog ( SynapseConstants . SERVICE_LOGGER_PREFIX + name ) ; } public AxisService buildAxisService ( SynapseConfiguration synCfg , AxisConfiguration axisCfg ) { auditInfo ( "Building Axis service for Proxy service : " + name ) ; AxisService proxyService = null ; if ( trace ( ) ) { trace . info ( "Loading the WSDL : " + ( wsdlKey != null ? " key = " + wsdlKey : ( wsdlURI != null ? " URI = " + wsdlURI : " <Inlined>" ) ) ) ; } InputStream wsdlInputStream = null ; OMElement wsdlElement = null ; boolean wsdlFound = false ; if ( wsdlKey != null ) { synCfg . getEntryDefinition ( wsdlKey ) ; Object keyObject = synCfg . getEntry ( wsdlKey ) ; if ( keyObject instanceof OMElement ) { wsdlElement = ( OMElement ) keyObject ; } wsdlFound = true ; } else if ( inLineWSDL != null ) { wsdlElement = ( OMElement ) inLineWSDL ; wsdlFound = true ; } else if ( wsdlURI != null ) { try { URL url = wsdlURI . toURL ( ) ; OMNode node = SynapseConfigUtils . getOMElementFromURL ( url . toString ( ) ) ; if ( node instanceof OMElement ) { wsdlElement = ( OMElement ) node ; } wsdlFound = true ; } catch ( MalformedURLException e ) { handleException ( "Malformed URI for wsdl" , e ) ; } catch ( IOException e ) { handleException ( "Error reading from wsdl URI" , e ) ; } } else { if ( trace ( ) ) trace . info ( "Did not find a WSDL. Assuming a POX or Legacy service" ) ; proxyService = new AxisService ( ) ; AxisOperation mediateOperation = new InOutAxisOperation ( new QName ( "mediate" ) ) ; proxyService . addOperation ( mediateOperation ) ; } if ( wsdlElement != null ) { OMNamespace wsdlNamespace = wsdlElement . getNamespace ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { if ( trace ( ) ) trace . info ( "Serializing wsdlElement found to build an Axis2 service" ) ; wsdlElement . serialize ( baos ) ; wsdlInputStream = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } if ( wsdlInputStream != null ) { try { if ( trace ( ) ) trace . info ( "WSDL Namespace is : " + wsdlNamespace . getNamespaceURI ( ) ) ; if ( wsdlNamespace != null ) { boolean isWSDL11 = false ; WSDLToAxisServiceBuilder wsdlToAxisServiceBuilder = null ; if ( WSDL2Constants . WSDL_NAMESPACE . equals ( wsdlNamespace . getNamespaceURI ( ) ) ) { wsdlToAxisServiceBuilder = new WSDL20ToAxisServiceBuilder ( wsdlInputStream , null , null ) ; } else if ( org . apache . axis2 . namespace . Constants . NS_URI_WSDL11 . equals ( wsdlNamespace . getNamespaceURI ( ) ) ) { wsdlToAxisServiceBuilder = new WSDL11ToAxisServiceBuilder ( wsdlInputStream ) ; isWSDL11 = true ; } else { handleException ( "Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0" ) ; } if ( wsdlToAxisServiceBuilder == null ) { throw new SynapseException ( "Could not get the WSDL to Axis Service Builder" ) ; } wsdlToAxisServiceBuilder . setBaseUri ( wsdlURI != null ? wsdlURI . toString ( ) : ServerManager . getInstance ( ) . getSynapseHome ( ) ) ; if ( trace ( ) ) { trace . info ( "Setting up custom resolvers" ) ; } if ( resourceMap != null ) { wsdlToAxisServiceBuilder . setCustomResolver ( new CustomURIResolver ( resourceMap , synCfg ) ) ; if ( wsdlToAxisServiceBuilder instanceof WSDL11ToAxisServiceBuilder ) { ( ( WSDL11ToAxisServiceBuilder ) wsdlToAxisServiceBuilder ) . setCustomWSLD4JResolver ( new CustomWSDLLocator ( new InputSource ( wsdlInputStream ) , wsdlURI != null ? wsdlURI . toString ( ) : "" , resourceMap , synCfg ) ) ; } } else { wsdlToAxisServiceBuilder . setCustomResolver ( new CustomURIResolver ( ) ) ; if ( wsdlToAxisServiceBuilder instanceof WSDL11ToAxisServiceBuilder ) { ( ( WSDL11ToAxisServiceBuilder ) wsdlToAxisServiceBuilder ) . setCustomWSLD4JResolver ( new CustomWSDLLocator ( new InputSource ( wsdlInputStream ) , wsdlURI != null ? wsdlURI . toString ( ) : "" ) ) ; } } if ( trace ( ) ) { trace . info ( "Populating Axis2 service using WSDL" ) ; if ( trace . isTraceEnabled ( ) ) { trace . trace ( "WSDL : " + wsdlElement . toString ( ) ) ; } } proxyService = wsdlToAxisServiceBuilder . populateService ( ) ; proxyService . getEndpoints ( ) . clear ( ) ; } else { handleException ( "Unknown WSDL format.. not WSDL 1.1 or WSDL 2.0" ) ; } } catch ( AxisFault af ) { handleException ( "Error building service from WSDL" , af ) ; } catch ( IOException ioe ) { handleException ( "Error reading WSDL" , ioe ) ; } } } else if ( wsdlFound ) { handleException ( "Couldn't build the proxy service : " + name + ". Unable to locate the specified WSDL to build the service" ) ; } if ( proxyService == null ) { throw new SynapseException ( "Could not create a proxy service" ) ; } proxyService . setName ( name ) ; if ( description != null ) { proxyService . setDocumentation ( description ) ; } if ( transports == null || transports . size ( ) == 0 ) { } else { if ( trace ( ) ) trace . info ( "Exposing transports : " + transports ) ; proxyService . setExposedTransports ( transports ) ; } if ( trace ( ) && parameters . size ( ) > 0 ) { trace . info ( "Setting service parameters : " + parameters ) ; } for ( Object o : parameters . keySet ( ) ) { String name = ( String ) o ; Object value = parameters . get ( name ) ; Parameter p = new Parameter ( ) ; p . setName ( name ) ; p . setValue ( value ) ; try { proxyService . addParameter ( p ) ; } catch ( AxisFault af ) { handleException ( "Error setting parameter : " + name + "" + "to proxy service as a Parameter" , af ) ; } } if ( ! policies . isEmpty ( ) ) { for ( PolicyInfo pi : policies ) { if ( pi . isServicePolicy ( ) ) { proxyService . getPolicyInclude ( ) . addPolicyElement ( PolicyInclude . AXIS_SERVICE_POLICY , getPolicyFromKey ( pi . getPolicyKey ( ) , synCfg ) ) ; } else if ( pi . isOperationPolicy ( ) ) { AxisOperation op = proxyService . getOperation ( pi . getOperation ( ) ) ; if ( op != null ) { op . getPolicyInclude ( ) . addPolicyElement ( PolicyInclude . AXIS_OPERATION_POLICY , getPolicyFromKey ( pi . getPolicyKey ( ) , synCfg ) ) ; } else { handleException ( "Couldn't find the operation specified " + "by the QName : " + pi . getOperation ( ) ) ; } } else if ( pi . isMessagePolicy ( ) ) { if ( pi . getOperation ( ) != null ) { AxisOperation op = proxyService . getOperation ( pi . getOperation ( ) ) ; if ( op != null ) { op . getMessage ( pi . getMessageLable ( ) ) . getPolicyInclude ( ) . addPolicyElement ( PolicyInclude . MESSAGE_POLICY , getPolicyFromKey ( pi . getPolicyKey ( ) , synCfg ) ) ; } else { handleException ( "Couldn't find the operation " + "specified by the QName : " + pi . getOperation ( ) ) ; } } else { for ( Iterator itr = proxyService . getOperations ( ) ; itr . hasNext ( ) ; ) { Object obj = itr . next ( ) ; if ( obj instanceof AxisOperation ) { if ( ! ( ( obj instanceof OutOnlyAxisOperation && pi . getType ( ) == PolicyInfo . MESSAGE_TYPE_IN ) || ( obj instanceof InOnlyAxisOperation && pi . getType ( ) == PolicyInfo . MESSAGE_TYPE_OUT ) ) ) { AxisMessage message = ( ( AxisOperation ) obj ) . getMessage ( pi . getMessageLable ( ) ) ; message . getPolicyInclude ( ) . addPolicyElement ( PolicyInclude . AXIS_MESSAGE_POLICY , getPolicyFromKey ( pi . getPolicyKey ( ) , synCfg ) ) ; } } } } } else { handleException ( "Undefined Policy type" ) ; } } } ProxyServiceMessageReceiver msgRcvr = new ProxyServiceMessageReceiver ( ) ; msgRcvr . setName ( name ) ; msgRcvr . setProxy ( this ) ; Iterator iter = proxyService . getOperations ( ) ; while ( iter . hasNext ( ) ) { AxisOperation op = ( AxisOperation ) iter . next ( ) ; op . setMessageReceiver ( msgRcvr ) ; } try { auditInfo ( "Adding service " + name + " to the Axis2 configuration" ) ; axisCfg . addService ( proxyService ) ; this . setRunning ( true ) ; } catch ( AxisFault axisFault ) { try { if ( axisCfg . getService ( proxyService . getName ( ) ) != null ) { if ( trace ( ) ) trace . info ( "Removing service " + name + " due to error : " + axisFault . getMessage ( ) ) ; axisCfg . removeService ( proxyService . getName ( ) ) ; } } catch ( AxisFault ignore ) { } handleException ( "Error adding Proxy service to the Axis2 engine" , axisFault ) ; } if ( wsRMEnabled ) { auditInfo ( "WS-Reliable messaging is enabled for service : " + name ) ; try { proxyService . engageModule ( axisCfg . getModule ( SynapseConstants . MERCURY_MODULE_NAME ) , axisCfg ) ; } catch ( AxisFault axisFault ) { handleException ( "Error loading WS RM module on proxy service : " + name , axisFault ) ; } } if ( wsSecEnabled ) { auditInfo ( "WS-Security is enabled for service : " + name ) ; try { proxyService . engageModule ( axisCfg . getModule ( SynapseConstants . RAMPART_MODULE_NAME ) , axisCfg ) ; } catch ( AxisFault axisFault ) { handleException ( "Error loading WS Sec module on proxy service : " + name , axisFault ) ; } } auditInfo ( "Successfully created the Axis2 service for Proxy service : " + name ) ; return proxyService ; } private Policy getPolicyFromKey ( String key , SynapseConfiguration synCfg ) { synCfg . getEntryDefinition ( key ) ; return PolicyEngine . getPolicy ( SynapseConfigUtils . getStreamSource ( synCfg . getEntry ( key ) ) . getInputStream ( ) ) ; } public void start ( SynapseConfiguration synCfg ) { AxisConfiguration axisConfig = synCfg . getAxisConfiguration ( ) ; if ( axisConfig != null ) { Parameter param = axisConfig . getParameter ( SynapseConstants . SYNAPSE_ENV ) ; if ( param != null && param . getValue ( ) instanceof SynapseEnvironment ) { SynapseEnvironment env = ( SynapseEnvironment ) param . getValue ( ) ; if ( targetInLineInSequence != null ) { targetInLineInSequence . init ( env ) ; } if ( targetInLineOutSequence != null ) { targetInLineOutSequence . init ( env ) ; } if ( targetInLineFaultSequence != null ) { targetInLineFaultSequence . init ( env ) ; } } else { auditWarn ( "Unable to find the SynapseEnvironment. " + "Components of the proxy service may not be initialized" ) ; } AxisService as = axisConfig . getServiceForActivation ( this . getName ( ) ) ; as . setActive ( true ) ; axisConfig . notifyObservers ( AxisEvent . SERVICE_START , as ) ; this . setRunning ( true ) ; auditInfo ( "Started the proxy service : " + name ) ; } else { auditWarn ( "Unable to start proxy service : " + name + ". Couldn't access Axis configuration" ) ; } } public void stop ( SynapseConfiguration synCfg ) { AxisConfiguration axisConfig = synCfg . getAxisConfiguration ( ) ; if ( axisConfig != null ) { if ( targetInLineInSequence != null ) { targetInLineInSequence . destroy ( ) ; } if ( targetInLineOutSequence != null ) { targetInLineOutSequence . destroy ( ) ; } if ( targetInLineFaultSequence != null ) { targetInLineFaultSequence . destroy ( ) ; } try { AxisService as = axisConfig . getService ( this . getName ( ) ) ; if ( as != null ) { as . setActive ( false ) ; axisConfig . notifyObservers ( AxisEvent . SERVICE_STOP , as ) ; } this . setRunning ( false ) ; auditInfo ( "Stopped the proxy service : " + name ) ; } catch ( AxisFault axisFault ) { handleException ( "Error stopping the proxy service : " + name , axisFault ) ; } } else { auditWarn ( "Unable to stop proxy service : " + name + ". Couldn't access Axis configuration" ) ; } } private void handleException ( String msg ) { serviceLog . error ( msg ) ; log . error ( msg ) ; if ( trace ( ) ) trace . error ( msg ) ; throw new SynapseException ( msg ) ; } private void handleException ( String msg , Exception e ) { serviceLog . error ( msg ) ; log . error ( msg , e ) ; if ( trace ( ) ) trace . error ( msg + " :: " + e . getMessage ( ) ) ; throw new SynapseException ( msg , e ) ; } private void auditInfo ( String message ) { log . info ( message ) ; serviceLog . info ( message ) ; if ( trace ( ) ) { trace . info ( message ) ; } } private void auditWarn ( String message ) { log . warn ( message ) ; serviceLog . warn ( message ) ; if ( trace ( ) ) { trace . warn ( message ) ; } } private boolean trace ( ) { return traceState == SynapseConstants . TRACING_ON ; } public String getName ( ) { return name ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public ArrayList getTransports ( ) { return transports ; } public void addParameter ( String name , Object value ) { parameters . put ( name , value ) ; } public Map < String , Object > getParameterMap ( ) { return this . parameters ; } public void setTransports ( ArrayList transports ) { this . transports = transports ; } public String getTargetEndpoint ( ) { return targetEndpoint ; } public void setTargetEndpoint ( String targetEndpoint ) { this . targetEndpoint = targetEndpoint ; } public String getTargetInSequence ( ) { return targetInSequence ; } public void setTargetInSequence ( String targetInSequence ) { this . targetInSequence = targetInSequence ; } public String getTargetOutSequence ( ) { return targetOutSequence ; } public void setTargetOutSequence ( String targetOutSequence ) { this . targetOutSequence = targetOutSequence ; } public String getWSDLKey ( ) { return wsdlKey ; } public void setWSDLKey ( String wsdlKey ) { this . wsdlKey = wsdlKey ; } public List < String > getServiceLevelPolicies ( ) { return serviceLevelPolicies ; } public void addServiceLevelPolicy ( String serviceLevelPolicy ) { this . serviceLevelPolicies . add ( serviceLevelPolicy ) ; } public boolean isWsRMEnabled ( ) { return wsRMEnabled ; } public void setWsRMEnabled ( boolean wsRMEnabled ) { this . wsRMEnabled = wsRMEnabled ; } public boolean isWsSecEnabled ( ) { return wsSecEnabled ; } public void setWsSecEnabled ( boolean wsSecEnabled ) { this . wsSecEnabled = wsSecEnabled ; } public boolean isStartOnLoad ( ) { return startOnLoad ; } public void setStartOnLoad ( boolean startOnLoad ) { this . startOnLoad = startOnLoad ; } public boolean isRunning ( ) { return running ; } public void setRunning ( boolean running ) { this . running = running ; } public int getStatisticsState ( ) { return statisticsState ; } public void setStatisticsState ( int statisticsState ) { this . statisticsState = statisticsState ; } public int getTraceState ( ) { return traceState ; } public void setTraceState ( int traceState ) { this . traceState = traceState ; } public String getTargetFaultSequence ( ) { return targetFaultSequence ; } public void setTargetFaultSequence ( String targetFaultSequence ) { this . targetFaultSequence = targetFaultSequence ; } public Object getInLineWSDL ( ) { return inLineWSDL ; } public void setInLineWSDL ( Object inLineWSDL ) { this . inLineWSDL = inLineWSDL ; } public URI getWsdlURI ( ) { return wsdlURI ; } public void setWsdlURI ( URI wsdlURI ) { this . wsdlURI = wsdlURI ; } public Endpoint getTargetInLineEndpoint ( ) { return targetInLineEndpoint ; } public void setTargetInLineEndpoint ( Endpoint targetInLineEndpoint ) { this . targetInLineEndpoint = targetInLineEndpoint ; } public SequenceMediator getTargetInLineInSequence ( ) { return targetInLineInSequence ; } public void setTargetInLineInSequence ( SequenceMediator targetInLineInSequence ) { this . targetInLineInSequence = targetInLineInSequence ; } public SequenceMediator getTargetInLineOutSequence ( ) { return targetInLineOutSequence ; } public void setTargetInLineOutSequence ( SequenceMediator targetInLineOutSequence ) { this . targetInLineOutSequence = targetInLineOutSequence ; } public SequenceMediator getTargetInLineFaultSequence ( ) { return targetInLineFaultSequence ; } public void setTargetInLineFaultSequence ( SequenceMediator targetInLineFaultSequence ) { this . targetInLineFaultSequence = targetInLineFaultSequence ; } public List getPinnedServers ( ) { return pinnedServers ; } public void setPinnedServers ( List pinnedServers ) { this . pinnedServers = pinnedServers ; } public ResourceMap getResourceMap ( ) { return resourceMap ; } public void setResourceMap ( ResourceMap resourceMap ) { this . resourceMap = resourceMap ; } public List < String > getInMessagePolicies ( ) { return inMessagePolicies ; } public void setInMessagePolicies ( List < String > inMessagePolicies ) { this . inMessagePolicies = inMessagePolicies ; } public void addInMessagePolicy ( String messagePolicy ) { this . inMessagePolicies . add ( messagePolicy ) ; } public List < String > getOutMessagePolicies ( ) { return outMessagePolicies ; } public void setOutMessagePolicies ( List < String > outMessagePolicies ) { this . outMessagePolicies = outMessagePolicies ; } public void addOutMessagePolicy ( String messagePolicy ) { this . outMessagePolicies . add ( messagePolicy ) ; } public List < PolicyInfo > getPolicies ( ) { return policies ; } public void setPolicies ( List < PolicyInfo > policies ) { this . policies = policies ; } public void addPolicyInfo ( PolicyInfo pi ) { this . policies . add ( pi ) ; } } 	1	['67', '1', '0', '44', '172', '1931', '9', '37', '60', '0.952101662', '1449', '0.967741935', '5', '0', '0.109090909', '0', '0', '20.1641791', '49', '1.9104', '3']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . FaultMediator ; public class FaultMediatorSerializer extends AbstractMediatorSerializer { private static final String SOAP11 = "soap11" ; private static final String SOAP12 = "soap12" ; private static final String POX = "pox" ; public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof FaultMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } FaultMediator mediator = ( FaultMediator ) m ; OMElement fault = fac . createOMElement ( "makefault" , synNS ) ; saveTracingState ( fault , mediator ) ; if ( mediator . getSoapVersion ( ) == FaultMediator . SOAP11 ) { fault . addAttribute ( fac . createOMAttribute ( "version" , nullNS , SOAP11 ) ) ; } else if ( mediator . getSoapVersion ( ) == FaultMediator . SOAP12 ) { fault . addAttribute ( fac . createOMAttribute ( "version" , nullNS , SOAP12 ) ) ; } else if ( mediator . getSoapVersion ( ) == FaultMediator . POX ) { fault . addAttribute ( fac . createOMAttribute ( "version" , nullNS , POX ) ) ; } OMElement code = fac . createOMElement ( "code" , synNS , fault ) ; if ( mediator . getFaultCodeValue ( ) != null ) { code . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getFaultCodeValue ( ) . getPrefix ( ) + ":" + mediator . getFaultCodeValue ( ) . getLocalPart ( ) ) ) ; code . declareNamespace ( mediator . getFaultCodeValue ( ) . getNamespaceURI ( ) , mediator . getFaultCodeValue ( ) . getPrefix ( ) ) ; } else if ( mediator . getFaultCodeExpr ( ) != null ) { SynapseXPathSerializer . serializeXPath ( mediator . getFaultCodeExpr ( ) , code , "expression" ) ; } else if ( mediator . getSoapVersion ( ) != FaultMediator . POX ) { handleException ( "Fault code is required for a fault " + "mediator unless it is a pox fault" ) ; } OMElement reason = fac . createOMElement ( "reason" , synNS , fault ) ; if ( mediator . getFaultReasonValue ( ) != null ) { reason . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mediator . getFaultReasonValue ( ) ) ) ; } else if ( mediator . getFaultReasonExpr ( ) != null ) { SynapseXPathSerializer . serializeXPath ( mediator . getFaultReasonExpr ( ) , reason , "expression" ) ; } else if ( mediator . getSoapVersion ( ) != FaultMediator . POX ) { handleException ( "Fault reason is required for a fault " + "mediator unless it is a pox fault" ) ; } if ( mediator . getFaultNode ( ) != null ) { OMElement node = fac . createOMElement ( "node" , synNS , fault ) ; node . setText ( mediator . getFaultNode ( ) . toString ( ) ) ; } if ( mediator . getFaultRole ( ) != null ) { OMElement role = fac . createOMElement ( "role" , synNS , fault ) ; role . setText ( mediator . getFaultRole ( ) . toString ( ) ) ; } if ( mediator . getFaultDetailExpr ( ) != null ) { OMElement detail = fac . createOMElement ( "detail" , synNS , fault ) ; SynapseXPathSerializer . serializeXPath ( mediator . getFaultDetailExpr ( ) , detail , "expression" ) ; } else if ( mediator . getFaultDetail ( ) != null ) { OMElement detail = fac . createOMElement ( "detail" , synNS , fault ) ; detail . setText ( mediator . getFaultDetail ( ) ) ; } if ( parent != null ) { parent . addChild ( fault ) ; } return fault ; } public String getMediatorClassName ( ) { return FaultMediator . class . getName ( ) ; } } 	1	['3', '2', '0', '11', '32', '3', '0', '11', '3', '1.5', '232', '1', '0', '0.75', '0.555555556', '0', '0', '75.33333333', '16', '5.6667', '2']
package org . apache . synapse . config . xml ; import org . apache . synapse . SynapseConstants ; import javax . xml . namespace . QName ; public class XMLConfigConstants { public static final String SYNAPSE_NAMESPACE = SynapseConstants . SYNAPSE_NAMESPACE ; public static final String SCOPE_DEFAULT = "default" ; public static final String SCOPE_AXIS2 = "axis2" ; public static final String SCOPE_CLIENT = "axis2-client" ; public static final String SCOPE_TRANSPORT = "transport" ; public static final String SEQUENCE_VERSION_1_0 = "1.0" ; public static final String SEQUENCE_VERSION_1_1 = "1.1" ; public static final QName DEFINITIONS_ELT = new QName ( SYNAPSE_NAMESPACE , "definitions" ) ; public static final QName SEQUENCE_ELT = new QName ( SYNAPSE_NAMESPACE , "sequence" ) ; public static final QName ENDPOINT_ELT = new QName ( SYNAPSE_NAMESPACE , "endpoint" ) ; public static final QName ENTRY_ELT = new QName ( SYNAPSE_NAMESPACE , "localEntry" ) ; public static final QName REGISTRY_ELT = new QName ( SYNAPSE_NAMESPACE , "registry" ) ; public static final QName TASK_ELT = new QName ( SYNAPSE_NAMESPACE , "task" ) ; public static final QName PROXY_ELT = new QName ( SYNAPSE_NAMESPACE , "proxy" ) ; public static final String NULL_NAMESPACE = "" ; public static final Object QUARTZ_QNAME = new QName ( "http://www.opensymphony.com/quartz/JobSchedulingData" , "quartz" ) ; public static final String TRACE_ATTRIB_NAME = "trace" ; public static final String TRACE_ENABLE = "enable" ; public static final String TRACE_DISABLE = "disable" ; public static final String STATISTICS_ATTRIB_NAME = "statistics" ; public static final String STATISTICS_ENABLE = "enable" ; public static final String STATISTICS_DISABLE = "disable" ; public static final String SUSPEND_DURATION_ON_FAILURE = "suspendDurationOnFailure" ; public static final String ALGORITHM_NAME = "policy" ; public static final String ONREJECT = "onReject" ; public static final String ONACCEPT = "onAccept" ; public static final QName ATT_XPATH_RELATIVE = new QName ( "relative" ) ; public static final String XPATH_BODY_RELATIVE = "body" ; public static final String XPATH_ENVELOPE_RELATIVE = "envelope" ; } 	1	['2', '1', '0', '4', '5', '1', '4', '0', '1', '1.689655172', '88', '0', '0', '0', '1', '0', '0', '28.5', '0', '0', '2']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . XSLTMediator ; import org . apache . synapse . mediators . MediatorProperty ; import org . apache . synapse . config . xml . AbstractMediatorSerializer ; import java . util . List ; public class XSLTMediatorSerializer extends AbstractMediatorSerializer { public OMElement serializeMediator ( OMElement parent , Mediator m ) { if ( ! ( m instanceof XSLTMediator ) ) { handleException ( "Unsupported mediator passed in for serialization : " + m . getType ( ) ) ; } XSLTMediator mediator = ( XSLTMediator ) m ; OMElement xslt = fac . createOMElement ( "xslt" , synNS ) ; if ( mediator . getXsltKey ( ) != null ) { xslt . addAttribute ( fac . createOMAttribute ( "key" , nullNS , mediator . getXsltKey ( ) ) ) ; } else { handleException ( "Invalid XSLT mediator. XSLT registry key is required" ) ; } saveTracingState ( xslt , mediator ) ; if ( mediator . getSource ( ) != null && ! XSLTMediator . DEFAULT_XPATH . equals ( mediator . getSource ( ) . toString ( ) ) ) { SynapseXPathSerializer . serializeXPath ( mediator . getSource ( ) , xslt , "source" ) ; } if ( mediator . getTargetPropertyName ( ) != null ) { xslt . addAttribute ( fac . createOMAttribute ( "target" , nullNS , mediator . getTargetPropertyName ( ) ) ) ; } serializeProperties ( xslt , mediator . getProperties ( ) ) ; List < MediatorProperty > features = mediator . getFeatures ( ) ; if ( ! features . isEmpty ( ) ) { for ( MediatorProperty mp : features ) { OMElement prop = fac . createOMElement ( "feature" , synNS , xslt ) ; if ( mp . getName ( ) != null ) { prop . addAttribute ( fac . createOMAttribute ( "name" , nullNS , mp . getName ( ) ) ) ; } else { handleException ( "The Feature name is missing" ) ; } if ( mp . getValue ( ) != null ) { prop . addAttribute ( fac . createOMAttribute ( "value" , nullNS , mp . getValue ( ) ) ) ; } else { handleException ( "The Feature value is missing" ) ; } } } if ( parent != null ) { parent . addChild ( xslt ) ; } return xslt ; } public String getMediatorClassName ( ) { return XSLTMediator . class . getName ( ) ; } } 	1	['3', '2', '0', '12', '31', '3', '0', '12', '3', '2', '144', '0', '0', '0.75', '0.555555556', '0', '0', '47', '11', '4', '1']
package org . apache . synapse . mediators . builtin ; import org . apache . synapse . MessageContext ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class PropertyMediator extends AbstractMediator { private String name = null ; private String value = null ; private SynapseXPath expression = null ; private String scope = null ; public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private int action = ACTION_SET ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Property mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( action == ACTION_SET ) { String resultValue = ( value != null ? value : expression . stringValueOf ( synCtx ) ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting property : " + name + " at scope : " + ( scope == null ? "default" : scope ) + " to : " + resultValue + " (i.e. " + ( value != null ? "constant : " + value : "result of expression : " + expression ) + ")" ) ; } if ( scope == null || XMLConfigConstants . SCOPE_DEFAULT . equals ( scope ) ) { synCtx . setProperty ( name , resultValue ) ; } else if ( XMLConfigConstants . SCOPE_AXIS2 . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . setProperty ( name , resultValue ) ; } else if ( XMLConfigConstants . SCOPE_CLIENT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . getOptions ( ) . setProperty ( name , resultValue ) ; } else if ( XMLConfigConstants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . put ( name , resultValue ) ; } if ( headers == null ) { Map headersMap = new HashMap ( ) ; headersMap . put ( name , resultValue ) ; axis2MessageCtx . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , headersMap ) ; } } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Removing property : " + name + " (scope:" + ( scope == null ? "default" : scope ) + ")" ) ; } if ( scope == null || XMLConfigConstants . SCOPE_DEFAULT . equals ( scope ) ) { Set pros = synCtx . getPropertyKeySet ( ) ; if ( pros != null ) { pros . remove ( name ) ; } } else if ( ( XMLConfigConstants . SCOPE_AXIS2 . equals ( scope ) || XMLConfigConstants . SCOPE_CLIENT . equals ( scope ) ) && synCtx instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . removeProperty ( name ) ; } else if ( XMLConfigConstants . SCOPE_TRANSPORT . equals ( scope ) && synCtx instanceof Axis2MessageContext ) { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; Object headers = axis2MessageCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; if ( headers != null && headers instanceof Map ) { Map headersMap = ( HashMap ) headers ; headersMap . remove ( name ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "No transport headers found for the message" ) ; } } } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Property mediator" ) ; } return true ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public SynapseXPath getExpression ( ) { return expression ; } public void setExpression ( SynapseXPath expression ) { this . expression = expression ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } } 	1	['12', '2', '0', '10', '37', '14', '2', '8', '12', '0.831168831', '390', '0.714285714', '1', '0.541666667', '0.3', '0', '0', '30.91666667', '30', '3.3333', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import javax . xml . namespace . QName ; import java . lang . reflect . Method ; public class PropertyHelper { private static final Log log = LogFactory . getLog ( PropertyHelper . class ) ; public static void setInstanceProperty ( String name , Object val , Object obj ) { String mName = "set" + Character . toUpperCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; Method method = null ; try { Method [ ] methods = obj . getClass ( ) . getMethods ( ) ; boolean invoked = false ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( mName . equals ( methods [ i ] . getName ( ) ) ) { Class [ ] params = methods [ i ] . getParameterTypes ( ) ; if ( params . length != 1 ) { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" ) ; } else if ( val instanceof String ) { String value = ( String ) val ; if ( params [ 0 ] . equals ( String . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { String . class } ) ; method . invoke ( obj , new String [ ] { value } ) ; } else if ( params [ 0 ] . equals ( int . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { int . class } ) ; method . invoke ( obj , new Integer [ ] { new Integer ( value ) } ) ; } else if ( params [ 0 ] . equals ( long . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { long . class } ) ; method . invoke ( obj , new Long [ ] { new Long ( value ) } ) ; } else if ( params [ 0 ] . equals ( float . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { float . class } ) ; method . invoke ( obj , new Float [ ] { new Float ( value ) } ) ; } else if ( params [ 0 ] . equals ( double . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { double . class } ) ; method . invoke ( obj , new Double [ ] { new Double ( value ) } ) ; } else if ( params [ 0 ] . equals ( boolean . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { boolean . class } ) ; method . invoke ( obj , new Boolean [ ] { new Boolean ( value ) } ) ; } else { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" ) ; } } else { if ( params [ 0 ] . equals ( OMElement . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { OMElement . class } ) ; method . invoke ( obj , new OMElement [ ] { ( OMElement ) val } ) ; } } invoked = true ; } } if ( ! invoked ) { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" ) ; } } catch ( Exception e ) { handleException ( "Error invoking setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" , e ) ; } } public static void setStaticProperty ( OMElement property , Object o ) { if ( property . getLocalName ( ) . toLowerCase ( ) . equals ( "property" ) ) { String propertyName = property . getAttributeValue ( new QName ( "name" ) ) ; String mName = "set" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; if ( property . getAttributeValue ( new QName ( "value" ) ) != null ) { String value = property . getAttributeValue ( new QName ( "value" ) ) ; try { Method method = o . getClass ( ) . getMethod ( mName , new Class [ ] { String . class } ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting property :: invoking method " + mName + "(" + value + ")" ) ; } method . invoke ( o , new Object [ ] { value } ) ; } catch ( Exception e ) { handleException ( "Error setting property : " + propertyName + " as a String property into class mediator : " + o . getClass ( ) + " : " + e . getMessage ( ) , e ) ; } } else { OMElement value = property . getFirstElement ( ) ; if ( value != null ) { try { Method method = o . getClass ( ) . getMethod ( mName , new Class [ ] { OMElement . class } ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting property :: invoking method " + mName + "(" + value + ")" ) ; } method . invoke ( o , new Object [ ] { value } ) ; } catch ( Exception e ) { handleException ( "Error setting property : " + propertyName + " as an OMElement property into class mediator : " + o . getClass ( ) + " : " + e . getMessage ( ) , e ) ; } } } } } public static boolean isStaticProperty ( OMElement property ) { return "property" . equals ( property . getLocalName ( ) . toLowerCase ( ) ) && ( property . getAttributeValue ( new QName ( "expression" ) ) == null ) ; } private static void handleException ( String message , Throwable e ) { log . error ( message + e . getMessage ( ) ) ; throw new SynapseException ( message , e ) ; } private static void handleException ( String message ) { log . error ( message ) ; throw new SynapseException ( message ) ; } } 	1	['7', '1', '0', '7', '42', '9', '3', '4', '4', '0.333333333', '558', '1', '0', '0', '0.3', '0', '0', '78.57142857', '12', '3.2857', '1']
package org . apache . synapse . mediators . ext ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . synapse . Command ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . eip . EIPUtils ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class POJOCommandMediator extends AbstractMediator { private Class command = null ; private Map < String , Object > staticSetterProperties = new HashMap < String , Object > ( ) ; private Map < String , SynapseXPath > messageSetterProperties = new HashMap < String , SynapseXPath > ( ) ; private Map < String , String > contextSetterProperties = new HashMap < String , String > ( ) ; private Map < String , String > contextGetterProperties = new HashMap < String , String > ( ) ; private Map < String , SynapseXPath > messageGetterProperties = new HashMap < String , SynapseXPath > ( ) ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : POJOCommand mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating a new instance of POJO class : " + command . getClass ( ) ) ; } Object commandObject = null ; try { commandObject = command . newInstance ( ) ; } catch ( Exception e ) { handleException ( "Error creating an instance of the POJO command class : " + command . getClass ( ) , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Instance created, setting static and dynamic properties" ) ; } for ( String name : staticSetterProperties . keySet ( ) ) { setInstanceProperty ( name , staticSetterProperties . get ( name ) , commandObject , synCtx ) ; } for ( String name : contextSetterProperties . keySet ( ) ) { setInstanceProperty ( name , synCtx . getProperty ( contextSetterProperties . get ( name ) ) , commandObject , synCtx ) ; } for ( String name : messageSetterProperties . keySet ( ) ) { SynapseXPath xpath = messageSetterProperties . get ( name ) ; String value = xpath . stringValueOf ( synCtx ) ; setInstanceProperty ( name , value , commandObject , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "POJO initialized successfully, invoking the execute() method" ) ; } if ( commandObject instanceof Command ) { try { ( ( Command ) commandObject ) . execute ( ) ; } catch ( Exception e ) { handleException ( "Error invoking POJO command class : " + command . getClass ( ) , e , synCtx ) ; } } else { Method exeMethod = null ; try { exeMethod = command . getMethod ( "execute" , new Class [ ] { } ) ; exeMethod . invoke ( commandObject , new Object [ ] { } ) ; } catch ( NoSuchMethodException e ) { handleException ( "Cannot locate an execute() method on POJO class : " + command . getClass ( ) , e , synCtx ) ; } catch ( Exception e ) { handleException ( "Error invoking the execute() method on POJO class : " + command . getClass ( ) , e , synCtx ) ; } } for ( String name : contextGetterProperties . keySet ( ) ) { synCtx . setProperty ( contextGetterProperties . get ( name ) , getInstanceProperty ( name , commandObject , synCtx ) ) ; } for ( String name : messageGetterProperties . keySet ( ) ) { SynapseXPath xpath = messageGetterProperties . get ( name ) ; Object resultValue = getInstanceProperty ( name , commandObject , synCtx ) ; try { List list = EIPUtils . getMatchingElements ( synCtx . getEnvelope ( ) , xpath ) ; if ( list . size ( ) > 0 ) { Object o = list . get ( 0 ) ; if ( resultValue instanceof String ) { OMAbstractFactory . getOMFactory ( ) . createOMText ( ( ( OMNode ) o ) . getParent ( ) , ( String ) resultValue ) ; ( ( OMNode ) o ) . detach ( ) ; } else if ( resultValue instanceof OMNode ) { ( ( OMNode ) o ) . insertSiblingAfter ( ( OMNode ) resultValue ) ; ( ( OMNode ) o ) . detach ( ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Unable to set the message property " + resultValue + "back to the message : Specified element by the xpath " + xpath + " can not be found" ) ; } } } catch ( JaxenException e ) { handleException ( "Unable to set the command property " + name + " back to the message" , e , synCtx ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : POJOCommand mediator" ) ; } return true ; } private Object getInstanceProperty ( String name , Object obj , MessageContext synCtx ) { String mName = "get" + Character . toUpperCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; try { Method [ ] methods = obj . getClass ( ) . getMethods ( ) ; for ( Method method : methods ) { if ( mName . equals ( method . getName ( ) ) ) { return method . invoke ( obj ) ; } } } catch ( InvocationTargetException e ) { handleException ( "Unable to get the command property '" + name + "' back to the message" , e , synCtx ) ; } catch ( IllegalAccessException e ) { handleException ( "Unable to get the command property '" + name + "' back to the message" , e , synCtx ) ; } return null ; } protected void setInstanceProperty ( String name , Object value , Object obj , MessageContext synCtx ) { String mName = "set" + Character . toUpperCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; Method method = null ; try { Method [ ] methods = obj . getClass ( ) . getMethods ( ) ; boolean invoked = false ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( mName . equals ( methods [ i ] . getName ( ) ) ) { Class [ ] params = methods [ i ] . getParameterTypes ( ) ; if ( params . length != 1 ) { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean or OMElement parameter" , synCtx ) ; } else if ( value instanceof String ) { if ( params [ 0 ] . equals ( String . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { String . class } ) ; method . invoke ( obj , new String [ ] { ( String ) value } ) ; } else if ( params [ 0 ] . equals ( int . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { int . class } ) ; method . invoke ( obj , new Integer [ ] { new Integer ( ( String ) value ) } ) ; } else if ( params [ 0 ] . equals ( long . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { long . class } ) ; method . invoke ( obj , new Long [ ] { new Long ( ( String ) value ) } ) ; } else if ( params [ 0 ] . equals ( float . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { float . class } ) ; method . invoke ( obj , new Float [ ] { new Float ( ( String ) value ) } ) ; } else if ( params [ 0 ] . equals ( double . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { double . class } ) ; method . invoke ( obj , new Double [ ] { new Double ( ( String ) value ) } ) ; } else if ( params [ 0 ] . equals ( boolean . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { boolean . class } ) ; method . invoke ( obj , new Boolean [ ] { new Boolean ( ( String ) value ) } ) ; } else { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" , synCtx ) ; } } else if ( value instanceof OMElement ) { if ( params [ 0 ] . equals ( OMElement . class ) ) { method = obj . getClass ( ) . getMethod ( mName , new Class [ ] { OMElement . class } ) ; method . invoke ( obj , new OMElement [ ] { ( OMElement ) value } ) ; } else { handleException ( "Did not find a setter method named : " + mName + "() that takes an OMElement as the parameter" , synCtx ) ; } } else { handleException ( "Can not handle the value type : " + value . getClass ( ) , synCtx ) ; } invoked = true ; } } if ( ! invoked ) { handleException ( "Did not find a setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" , synCtx ) ; } } catch ( Exception e ) { handleException ( "Error invoking setter method named : " + mName + "() that takes a single String, int, long, float, double " + "or boolean parameter" , e , synCtx ) ; } } public Class getCommand ( ) { return command ; } public void setCommand ( Class command ) { this . command = command ; } public void addStaticSetterProperty ( String name , Object value ) { this . staticSetterProperties . put ( name , value ) ; } public void addMessageSetterProperty ( String name , SynapseXPath xpath ) { this . messageSetterProperties . put ( name , xpath ) ; } public void addContextSetterProperty ( String name , String ctxName ) { this . contextSetterProperties . put ( name , ctxName ) ; } public void addContextGetterProperty ( String name , String value ) { this . contextGetterProperties . put ( name , value ) ; } public void addMessageGetterProperty ( String name , SynapseXPath xpath ) { this . messageGetterProperties . put ( name , xpath ) ; } public Map < String , Object > getStaticSetterProperties ( ) { return this . staticSetterProperties ; } public Map < String , SynapseXPath > getMessageSetterProperties ( ) { return this . messageSetterProperties ; } public Map < String , String > getContextSetterProperties ( ) { return this . contextSetterProperties ; } public Map < String , String > getContextGetterProperties ( ) { return this . contextGetterProperties ; } public Map < String , SynapseXPath > getMessageGetterProperties ( ) { return this . messageGetterProperties ; } } 	1	['16', '2', '1', '17', '66', '58', '3', '14', '14', '0.8', '918', '1', '0', '0.464285714', '0.333333333', '0', '0', '56', '16', '2.6875', '1']
package org . apache . synapse . endpoints . algorithms ; import org . apache . axis2 . clustering . ClusteringFault ; import org . apache . axis2 . clustering . context . Replicator ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; public class AlgorithmContext { private static final Log log = LogFactory . getLog ( AlgorithmContext . class ) ; private static final String UNDERSCORE_STRING = "_" ; private static final String CURRENT_EPR = "currentEPR" ; private ConfigurationContext configCtx ; private boolean isClusteringEnable = false ; private String currentEPRPropertyKey ; private int currentEPR = 0 ; public int getCurrentEndpointIndex ( ) { if ( this . isClusteringEnable ) { if ( this . currentEPRPropertyKey == null || "" . equals ( this . currentEPRPropertyKey ) ) { handleException ( "Cannot find the required key to find the " + "shared state of the 'currentEPR' attribute" ) ; } Object value = this . configCtx . getPropertyNonReplicable ( this . currentEPRPropertyKey ) ; if ( value == null ) { return 0 ; } try { if ( value instanceof Integer ) { return ( ( Integer ) value ) . intValue ( ) ; } else if ( value instanceof String ) { return Integer . parseInt ( ( String ) value ) ; } } catch ( NumberFormatException e ) { handleException ( "The invalid value for the 'currentEPR' attribute" ) ; } } else { return currentEPR ; } return 0 ; } public void setCurrentEPR ( int currentEPR ) { if ( isClusteringEnable ) { if ( currentEPRPropertyKey != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting the current EPR " + currentEPR + " with the key " + currentEPRPropertyKey ) ; } setAndReplicateState ( currentEPRPropertyKey , currentEPR ) ; } } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Setting the current EPR " + currentEPR ) ; } this . currentEPR = currentEPR ; } } public ConfigurationContext getConfigurationContext ( ) { return configCtx ; } public void setConfigurationContext ( ConfigurationContext configCtx ) { if ( configCtx == null ) { handleException ( "The ConfigurationContext cannot be null when system " + "in a cluster environment" ) ; } this . configCtx = configCtx ; this . isClusteringEnable = true ; } public void setContextID ( String contextID ) { if ( contextID == null || "" . equals ( contextID ) ) { handleException ( "The Context ID cannot be null when system in a cluster environment" ) ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( contextID ) ; buffer . append ( UNDERSCORE_STRING ) ; buffer . append ( CURRENT_EPR ) ; currentEPRPropertyKey = buffer . toString ( ) ; } protected void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } protected void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private void setAndReplicateState ( String key , Object value ) { if ( configCtx != null && key != null && value != null ) { try { if ( log . isDebugEnabled ( ) ) { log . debug ( "Start replicating the property with key : " + key + " value : " + value ) ; } configCtx . setProperty ( key , value ) ; Replicator . replicate ( configCtx , new String [ ] { key } ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Completed replication of the property with key : " + key ) ; } } catch ( ClusteringFault clusteringFault ) { handleException ( "Error during the replicating states " , clusteringFault ) ; } } } } 	1	['10', '1', '0', '11', '33', '0', '4', '7', '6', '0.746031746', '248', '1', '0', '0', '0.314814815', '0', '0', '23.1', '6', '2.4', '1']
package org . apache . synapse . util ; import org . apache . commons . io . IOUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . * ; public class TemporaryData { private static final Log log = LogFactory . getLog ( TemporaryData . class ) ; class OutputStreamImpl extends OutputStream { private FileOutputStream fileOutputStream ; public void write ( byte [ ] b , int off , int len ) throws IOException { if ( fileOutputStream != null ) { fileOutputStream . write ( b , off , len ) ; } else if ( len > ( chunks . length - chunkIndex ) * chunkSize - chunkOffset ) { fileOutputStream = switchToTempFile ( ) ; fileOutputStream . write ( b , off , len ) ; } else { while ( len > 0 ) { byte [ ] chunk = getCurrentChunk ( ) ; int c = Math . min ( len , chunkSize - chunkOffset ) ; System . arraycopy ( b , off , chunk , chunkOffset , c ) ; len -= c ; off += c ; chunkOffset += c ; if ( chunkOffset == chunkSize ) { chunkIndex ++ ; chunkOffset = 0 ; } } } } public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } public void write ( int b ) throws IOException { write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; } public void flush ( ) throws IOException { if ( fileOutputStream != null ) { fileOutputStream . flush ( ) ; } } public void close ( ) throws IOException { if ( fileOutputStream != null ) { fileOutputStream . close ( ) ; } } } class InputStreamImpl extends InputStream { private int currentChunkIndex ; private int currentChunkOffset ; private int markChunkIndex ; private int markChunkOffset ; public int available ( ) throws IOException { return ( chunkIndex - currentChunkIndex ) * chunkSize + chunkOffset - currentChunkOffset ; } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( len == 0 ) { return 0 ; } int read = 0 ; while ( len > 0 && ! ( currentChunkIndex == chunkIndex && currentChunkOffset == chunkOffset ) ) { int c ; if ( currentChunkIndex == chunkIndex ) { c = Math . min ( len , chunkOffset - currentChunkOffset ) ; } else { c = Math . min ( len , chunkSize - currentChunkOffset ) ; } System . arraycopy ( chunks [ currentChunkIndex ] , currentChunkOffset , b , off , c ) ; len -= c ; off += c ; currentChunkOffset += c ; read += c ; if ( currentChunkOffset == chunkSize ) { currentChunkIndex ++ ; currentChunkOffset = 0 ; } } if ( read == 0 ) { return - 1 ; } else { return read ; } } public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; } public int read ( ) throws IOException { byte [ ] b = new byte [ 1 ] ; return read ( b ) == - 1 ? - 1 : ( int ) b [ 0 ] & 0xFF ; } public boolean markSupported ( ) { return true ; } public void mark ( int readlimit ) { markChunkIndex = currentChunkIndex ; markChunkOffset = currentChunkOffset ; } public void reset ( ) throws IOException { currentChunkIndex = markChunkIndex ; currentChunkOffset = markChunkOffset ; } public long skip ( long n ) throws IOException { int available = available ( ) ; int c = n < available ? ( int ) n : available ; int newOffset = currentChunkOffset + c ; int chunkDelta = newOffset / chunkSize ; currentChunkIndex += chunkDelta ; currentChunkOffset = newOffset - ( chunkDelta * chunkSize ) ; return c ; } public void close ( ) throws IOException { } } final int chunkSize ; final String tempPrefix ; final String tempSuffix ; byte [ ] [ ] chunks ; int chunkIndex ; int chunkOffset ; File temporaryFile ; public TemporaryData ( int numberOfChunks , int chunkSize , String tempPrefix , String tempSuffix ) { this . chunkSize = chunkSize ; this . tempPrefix = tempPrefix ; this . tempSuffix = tempSuffix ; chunks = new byte [ numberOfChunks ] [ ] ; } byte [ ] getCurrentChunk ( ) { if ( chunkOffset == 0 ) { byte [ ] chunk = new byte [ chunkSize ] ; chunks [ chunkIndex ] = chunk ; return chunk ; } else { return chunks [ chunkIndex ] ; } } FileOutputStream switchToTempFile ( ) throws IOException { temporaryFile = File . createTempFile ( tempPrefix , tempSuffix ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Using temporary file " + temporaryFile ) ; } temporaryFile . deleteOnExit ( ) ; FileOutputStream fileOutputStream = new FileOutputStream ( temporaryFile ) ; for ( int i = 0 ; i < chunkIndex ; i ++ ) { fileOutputStream . write ( chunks [ i ] ) ; } if ( chunkOffset > 0 ) { fileOutputStream . write ( chunks [ chunkIndex ] , 0 , chunkOffset ) ; } chunks = null ; return fileOutputStream ; } public OutputStream getOutputStream ( ) { return new OutputStreamImpl ( ) ; } public void readFrom ( InputStream in ) throws IOException { while ( true ) { int c = in . read ( getCurrentChunk ( ) , chunkOffset , chunkSize - chunkOffset ) ; if ( c == - 1 ) { break ; } chunkOffset += c ; if ( chunkOffset == chunkSize ) { chunkIndex ++ ; chunkOffset = 0 ; if ( chunkIndex == chunks . length ) { FileOutputStream fileOutputStream = switchToTempFile ( ) ; IOUtils . copy ( in , fileOutputStream ) ; fileOutputStream . close ( ) ; break ; } } } } public InputStream getInputStream ( ) throws IOException { if ( temporaryFile != null ) { return new FileInputStream ( temporaryFile ) ; } else { return new InputStreamImpl ( ) ; } } public void release ( ) { if ( temporaryFile != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Deleting temporary file " + temporaryFile ) ; } temporaryFile . delete ( ) ; } } protected void finalize ( ) throws Throwable { if ( temporaryFile != null ) { log . warn ( "Cleaning up unreleased temporary file " + temporaryFile ) ; temporaryFile . delete ( ) ; } } } 	1	['9', '1', '0', '10', '30', '6', '7', '5', '5', '0.671875', '235', '0.125', '0', '0', '0.34375', '0', '0', '24.22222222', '3', '1.1111', '1']
package org . apache . synapse . config ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . util . DataSourceRegistrar ; import org . apache . synapse . config . xml . XMLConfigurationBuilder ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . mediators . builtin . DropMediator ; import org . apache . synapse . mediators . builtin . LogMediator ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; public class SynapseConfigurationBuilder { private static Log log = LogFactory . getLog ( SynapseConfigurationBuilder . class ) ; public static SynapseConfiguration getDefaultConfiguration ( ) { SynapseConfiguration config = new SynapseConfiguration ( ) ; SequenceMediator mainmediator = new SequenceMediator ( ) ; mainmediator . addChild ( new LogMediator ( ) ) ; mainmediator . addChild ( new DropMediator ( ) ) ; config . addSequence ( SynapseConstants . MAIN_SEQUENCE_KEY , mainmediator ) ; SequenceMediator faultmediator = new SequenceMediator ( ) ; LogMediator fault = new LogMediator ( ) ; fault . setLogLevel ( LogMediator . FULL ) ; faultmediator . addChild ( fault ) ; config . addSequence ( SynapseConstants . FAULT_SEQUENCE_KEY , faultmediator ) ; return config ; } public static SynapseConfiguration getConfiguration ( String configFile ) { try { Properties synapseProperties = loadSynapseProperties ( ) ; DataSourceRegistrar . registerDataSources ( synapseProperties ) ; SynapseConfiguration synCfg = XMLConfigurationBuilder . getConfiguration ( new FileInputStream ( configFile ) ) ; log . info ( "Loaded Synapse configuration from : " + configFile ) ; synCfg . setPathToConfigFile ( new File ( configFile ) . getAbsolutePath ( ) ) ; synCfg . setProperties ( synapseProperties ) ; return synCfg ; } catch ( FileNotFoundException fnf ) { handleException ( "Cannot load Synapse configuration from : " + configFile , fnf ) ; } catch ( Exception e ) { handleException ( "Could not initialize Synapse : " + e . getMessage ( ) , e ) ; } return null ; } private static Properties loadSynapseProperties ( ) { try { Properties properties = new Properties ( ) ; ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "synapse.properties file is loading from classpath" ) ; } InputStream in = cl . getResourceAsStream ( SynapseConstants . SYNAPSE_PROPERTIES ) ; if ( in == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Unable to load synapse.propeties file" ) ; } String path = SynapseConstants . CONF_DIRECTORY + File . separatorChar + SynapseConstants . SYNAPSE_PROPERTIES ; if ( log . isDebugEnabled ( ) ) { log . debug ( "synapse.properties file is loading from classpath" + " with resource path '" + path + " '" ) ; } in = cl . getResourceAsStream ( path ) ; if ( in == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Unable to load the synapse.properties file from classpath" + " with resource name '" + path + " '" ) ; } } } if ( in != null ) { properties . load ( in ) ; } return properties ; } catch ( Exception e ) { log . info ( "Using the default tuning parameters for Synapse" ) ; } return new Properties ( ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1	['6', '1', '0', '11', '37', '3', '1', '10', '3', '0.4', '214', '1', '0', '0', '0.266666667', '0', '0', '34.5', '8', '1.8333', '1']
package org . apache . synapse . mediators . filters ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; import org . apache . synapse . mediators . ListMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class FilterMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { private SynapseXPath source = null ; private Pattern regex = null ; private SynapseXPath xpath = null ; private ListMediator elseMediator = null ; private boolean thenElementPresent = false ; private String thenKey = null ; private String elseKey = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Filter mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } boolean result = false ; if ( test ( synCtx ) ) { if ( thenKey != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( xpath == null ? "Source : " + source + " against : " + regex . pattern ( ) + " matches" : "XPath expression : " + xpath + " evaluates to true" ) + " - executing then sequence with key : " + thenKey ) ; } Mediator seq = synCtx . getSequence ( thenKey ) ; if ( seq != null ) { result = seq . mediate ( synCtx ) ; } else { handleException ( "Couldn't find the referred then sequence with key : " + thenKey , synCtx ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( xpath == null ? "Source : " + source + " against : " + regex . pattern ( ) + " matches" : "XPath expression : " + xpath + " evaluates to true" ) + " - executing child mediators" ) ; } result = super . mediate ( synCtx ) ; } } else { if ( elseKey != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( xpath == null ? "Source : " + source + " against : " + regex . pattern ( ) + " does not match" : "XPath expression : " + xpath + " evaluates to false" ) + " - executing the else sequence with key : " + elseKey ) ; } Mediator elseSeq = synCtx . getSequence ( elseKey ) ; if ( elseSeq != null ) { result = elseSeq . mediate ( synCtx ) ; } else { handleException ( "Couldn't find the referred else sequence with key : " + elseKey , synCtx ) ; } } else if ( elseMediator != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( xpath == null ? "Source : " + source + " against : " + regex . pattern ( ) + " does not match" : "XPath expression : " + xpath + " evaluates to false" ) + " - executing the else path child mediators" ) ; } result = elseMediator . mediate ( synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , ( xpath == null ? "Source : " + source + " against : " + regex . pattern ( ) + " does not match" : "XPath expression : " + xpath + " evaluates to false and no else path" ) + " - skipping child mediators" ) ; } result = true ; } } if ( traceOrDebugOn ) { trace . trace ( "End : Filter mediator " ) ; } return result ; } public boolean test ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( xpath != null ) { try { return xpath . booleanValueOf ( synCtx ) ; } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression : " + xpath , e , synCtx ) ; } } else if ( source != null && regex != null ) { String sourceString = source . stringValueOf ( synCtx ) ; if ( sourceString == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Source String : " + source + " evaluates to null" ) ; } return false ; } Matcher matcher = regex . matcher ( sourceString ) ; if ( matcher == null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Regex pattren matcher for : " + regex . pattern ( ) + "against source : " + sourceString + " is null" ) ; } return false ; } return matcher . matches ( ) ; } return false ; } public SynapseXPath getSource ( ) { return source ; } public void setSource ( SynapseXPath source ) { this . source = source ; } public Pattern getRegex ( ) { return regex ; } public void setRegex ( Pattern regex ) { this . regex = regex ; } public SynapseXPath getXpath ( ) { return xpath ; } public void setXpath ( SynapseXPath xpath ) { this . xpath = xpath ; } public ListMediator getElseMediator ( ) { return elseMediator ; } public void setElseMediator ( ListMediator elseMediator ) { this . elseMediator = elseMediator ; } public boolean isThenElementPresent ( ) { return thenElementPresent ; } public void setThenElementPresent ( boolean thenElementPresent ) { this . thenElementPresent = thenElementPresent ; } public String getThenKey ( ) { return thenKey ; } public void setThenKey ( String thenKey ) { this . thenKey = thenKey ; } public String getElseKey ( ) { return elseKey ; } public void setElseKey ( String elseKey ) { this . elseKey = elseKey ; } } 	1	['17', '3', '0', '11', '39', '52', '2', '9', '17', '0.794642857', '535', '1', '3', '0.578947368', '0.218487395', '1', '3', '30.05882353', '21', '2.5294', '1']
package org . apache . synapse . core . axis2 ; import org . apache . synapse . config . SynapseConfigUtils ; import org . apache . synapse . config . SynapseConfiguration ; import org . xml . sax . InputSource ; import javax . wsdl . xml . WSDLLocator ; public class CustomWSDLLocator implements WSDLLocator { private final InputSource baseInputSource ; private final String baseURI ; private ResourceMap resourceMap ; private SynapseConfiguration synCfg ; private String latestImportURI ; public CustomWSDLLocator ( InputSource baseInputSource , String baseURI ) { this . baseInputSource = baseInputSource ; this . baseURI = baseURI ; } public CustomWSDLLocator ( InputSource baseInputSource , String baseURI , ResourceMap resourceMap , SynapseConfiguration synCfg ) { this ( baseInputSource , baseURI ) ; this . resourceMap = resourceMap ; this . synCfg = synCfg ; } public InputSource getBaseInputSource ( ) { return baseInputSource ; } public String getBaseURI ( ) { return baseURI ; } public InputSource getImportInputSource ( String parentLocation , String relativeLocation ) { InputSource result = null ; if ( resourceMap != null ) { result = resourceMap . resolve ( synCfg , relativeLocation ) ; } if ( result == null ) { result = new InputSource ( SynapseConfigUtils . resolveRelativeURI ( parentLocation , relativeLocation ) ) ; } this . latestImportURI = relativeLocation ; return result ; } public String getLatestImportURI ( ) { return latestImportURI ; } public void close ( ) { } } 	1	['7', '1', '0', '5', '11', '13', '2', '3', '7', '0.766666667', '68', '1', '2', '0', '0.4', '0', '0', '8', '3', '1', '2']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import org . apache . synapse . endpoints . dispatch . Dispatcher ; import org . apache . synapse . endpoints . dispatch . HttpSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SimpleClientSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SoapSessionDispatcher ; public class SALoadbalanceEndpointSerializer extends EndpointSerializer { protected OMElement serializeEndpoint ( Endpoint endpoint ) { if ( ! ( endpoint instanceof SALoadbalanceEndpoint ) ) { handleException ( "Invalid endpoint type for serializing. " + "Expected: SALoadbalanceEndpoint Found: " + endpoint . getClass ( ) . getName ( ) ) ; } SALoadbalanceEndpoint loadbalanceEndpoint = ( SALoadbalanceEndpoint ) endpoint ; fac = OMAbstractFactory . getOMFactory ( ) ; OMElement endpointElement = fac . createOMElement ( "endpoint" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; String name = loadbalanceEndpoint . getName ( ) ; if ( name != null ) { endpointElement . addAttribute ( "name" , name , null ) ; } Dispatcher dispatcher = loadbalanceEndpoint . getDispatcher ( ) ; if ( dispatcher instanceof SoapSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "soap" , null ) ; endpointElement . addChild ( sessionElement ) ; } else if ( dispatcher instanceof HttpSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "http" , null ) ; endpointElement . addChild ( sessionElement ) ; } else if ( dispatcher instanceof SimpleClientSessionDispatcher ) { OMElement sessionElement = fac . createOMElement ( "session" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; sessionElement . addAttribute ( "type" , "simpleClientSession" , null ) ; endpointElement . addChild ( sessionElement ) ; } OMElement loadbalanceElement = fac . createOMElement ( "loadbalance" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; endpointElement . addChild ( loadbalanceElement ) ; LoadbalanceAlgorithm algorithm = loadbalanceEndpoint . getAlgorithm ( ) ; String algorithmName = "roundRobin" ; if ( algorithm instanceof RoundRobin ) { algorithmName = "roundRobin" ; } loadbalanceElement . addAttribute ( "algorithm" , algorithmName , null ) ; for ( Endpoint childEndpoint : loadbalanceEndpoint . getEndpoints ( ) ) { loadbalanceElement . addChild ( EndpointSerializer . getElementFromEndpoint ( childEndpoint ) ) ; } return endpointElement ; } } 	1	['2', '2', '0', '16', '21', '1', '1', '16', '1', '2', '145', '0', '0', '0.857142857', '0.75', '1', '3', '71.5', '8', '4', '1']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMFactory ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . endpoints . * ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; public abstract class EndpointSerializer { private static Log log = LogFactory . getLog ( EndpointSerializer . class ) ; protected OMFactory fac ; public static OMElement getElementFromEndpoint ( Endpoint endpoint ) { return getEndpointSerializer ( endpoint ) . serializeEndpoint ( endpoint ) ; } protected abstract OMElement serializeEndpoint ( Endpoint endpoint ) ; protected void serializeCommonEndpointProperties ( EndpointDefinition endpointDefinition , OMElement element ) { if ( endpointDefinition . getStatisticsState ( ) == SynapseConstants . STATISTICS_ON ) { element . addAttribute ( fac . createOMAttribute ( XMLConfigConstants . STATISTICS_ATTRIB_NAME , null , XMLConfigConstants . STATISTICS_ENABLE ) ) ; } else if ( endpointDefinition . getStatisticsState ( ) == SynapseConstants . STATISTICS_OFF ) { element . addAttribute ( fac . createOMAttribute ( XMLConfigConstants . STATISTICS_ATTRIB_NAME , null , XMLConfigConstants . STATISTICS_DISABLE ) ) ; } if ( endpointDefinition . getTraceState ( ) == SynapseConstants . TRACING_ON ) { element . addAttribute ( fac . createOMAttribute ( XMLConfigConstants . TRACE_ATTRIB_NAME , null , XMLConfigConstants . TRACE_ENABLE ) ) ; } else if ( endpointDefinition . getStatisticsState ( ) == SynapseConstants . TRACING_OFF ) { element . addAttribute ( fac . createOMAttribute ( XMLConfigConstants . TRACE_ATTRIB_NAME , null , XMLConfigConstants . TRACE_DISABLE ) ) ; } if ( endpointDefinition . isUseSwa ( ) ) { element . addAttribute ( fac . createOMAttribute ( "optimize" , null , "swa" ) ) ; } else if ( endpointDefinition . isUseMTOM ( ) ) { element . addAttribute ( fac . createOMAttribute ( "optimize" , null , "mtom" ) ) ; } if ( endpointDefinition . getCharSetEncoding ( ) != null ) { element . addAttribute ( fac . createOMAttribute ( "encoding" , null , endpointDefinition . getCharSetEncoding ( ) ) ) ; } if ( endpointDefinition . isAddressingOn ( ) ) { OMElement addressing = fac . createOMElement ( "enableAddressing" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getAddressingVersion ( ) != null ) { addressing . addAttribute ( fac . createOMAttribute ( "version" , null , endpointDefinition . getAddressingVersion ( ) ) ) ; } if ( endpointDefinition . isUseSeparateListener ( ) ) { addressing . addAttribute ( fac . createOMAttribute ( "separateListener" , null , "true" ) ) ; } element . addChild ( addressing ) ; } if ( endpointDefinition . isReliableMessagingOn ( ) ) { OMElement rm = fac . createOMElement ( "enableRM" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getWsRMPolicyKey ( ) != null ) { rm . addAttribute ( fac . createOMAttribute ( "policy" , null , endpointDefinition . getWsRMPolicyKey ( ) ) ) ; } element . addChild ( rm ) ; } if ( endpointDefinition . isSecurityOn ( ) ) { OMElement sec = fac . createOMElement ( "enableSec" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getWsSecPolicyKey ( ) != null ) { sec . addAttribute ( fac . createOMAttribute ( "policy" , null , endpointDefinition . getWsSecPolicyKey ( ) ) ) ; } element . addChild ( sec ) ; } if ( endpointDefinition . getTimeoutAction ( ) != SynapseConstants . NONE ) { OMElement timeout = fac . createOMElement ( "timeout" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; element . addChild ( timeout ) ; OMElement duration = fac . createOMElement ( "duration" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; duration . setText ( Long . toString ( endpointDefinition . getTimeoutDuration ( ) / 1000 ) ) ; timeout . addChild ( duration ) ; OMElement action = fac . createOMElement ( "action" , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; if ( endpointDefinition . getTimeoutAction ( ) == SynapseConstants . DISCARD ) { action . setText ( "discard" ) ; } else if ( endpointDefinition . getTimeoutAction ( ) == SynapseConstants . DISCARD_AND_FAULT ) { action . setText ( "fault" ) ; } timeout . addChild ( action ) ; } long suspendDuration = endpointDefinition . getSuspendOnFailDuration ( ) ; if ( suspendDuration != - 1 ) { OMElement suspendElement = fac . createOMElement ( org . apache . synapse . config . xml . XMLConfigConstants . SUSPEND_DURATION_ON_FAILURE , SynapseConstants . SYNAPSE_OMNAMESPACE ) ; suspendElement . setText ( Long . toString ( suspendDuration / 1000 ) ) ; element . addChild ( suspendElement ) ; } } protected void serializeSpecificEndpointProperties ( EndpointDefinition endpointDefinition , OMElement element ) { } protected void handleException ( String message ) { log . error ( message ) ; throw new SynapseException ( message ) ; } public static EndpointSerializer getEndpointSerializer ( Endpoint endpoint ) { if ( endpoint instanceof AddressEndpoint ) { return new AddressEndpointSerializer ( ) ; } else if ( endpoint instanceof WSDLEndpoint ) { return new WSDLEndpointSerializer ( ) ; } else if ( endpoint instanceof IndirectEndpoint ) { return new IndirectEndpointSerializer ( ) ; } else if ( endpoint instanceof LoadbalanceEndpoint ) { return new LoadbalanceEndpointSerializer ( ) ; } else if ( endpoint instanceof SALoadbalanceEndpoint ) { return new SALoadbalanceEndpointSerializer ( ) ; } else if ( endpoint instanceof FailoverEndpoint ) { return new FailoverEndpointSerializer ( ) ; } throw new SynapseException ( "Serializer for endpoint " + endpoint . getClass ( ) . toString ( ) + " is not defined." ) ; } } 	1	['8', '1', '6', '28', '44', '26', '10', '23', '3', '0.928571429', '342', '1', '0', '0', '0.371428571', '0', '0', '41.5', '19', '3.75', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . AddressingHelper ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . engine . AxisEngine ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . rampart . handler . WSSHandlerConstants ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . transport . nhttp . NhttpConstants ; import org . apache . synapse . util . POXUtils ; import org . apache . synapse . util . UUIDGenerator ; public class Axis2Sender { private static final Log log = LogFactory . getLog ( Axis2Sender . class ) ; public static void sendOn ( EndpointDefinition endpoint , org . apache . synapse . MessageContext synapseInMessageContext ) { try { Axis2FlexibleMEPClient . send ( endpoint , synapseInMessageContext ) ; } catch ( Exception e ) { handleException ( "Unexpected error during sending message out" , e ) ; } } public static void sendBack ( org . apache . synapse . MessageContext smc ) { MessageContext messageContext = ( ( Axis2MessageContext ) smc ) . getAxis2MessageContext ( ) ; if ( messageContext . isPropertyTrue ( NhttpConstants . SC_ACCEPTED ) && messageContext . getTransportOut ( ) != null && ! messageContext . getTransportOut ( ) . getName ( ) . startsWith ( Constants . TRANSPORT_HTTP ) ) { return ; } if ( messageContext . isDoingREST ( ) && messageContext . isFault ( ) ) { POXUtils . convertSOAPFaultToPOX ( messageContext ) ; } try { messageContext . setProperty ( SynapseConstants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; if ( smc . isResponse ( ) ) { StatisticsUtils . processEndPointStatistics ( smc ) ; StatisticsUtils . processProxyServiceStatistics ( smc ) ; StatisticsUtils . processAllSequenceStatistics ( smc ) ; } if ( AddressingHelper . isReplyRedirected ( messageContext ) && ! messageContext . getReplyTo ( ) . hasNoneAddress ( ) ) { messageContext . setTo ( messageContext . getReplyTo ( ) ) ; messageContext . setReplyTo ( null ) ; messageContext . setWSAAction ( "" ) ; messageContext . setSoapAction ( "" ) ; messageContext . setProperty ( NhttpConstants . IGNORE_SC_ACCEPTED , Constants . VALUE_TRUE ) ; messageContext . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } if ( messageContext . getEnvelope ( ) . hasFault ( ) && AddressingHelper . isFaultRedirected ( messageContext ) && ! messageContext . getFaultTo ( ) . hasNoneAddress ( ) ) { messageContext . setTo ( messageContext . getFaultTo ( ) ) ; messageContext . setFaultTo ( null ) ; messageContext . setWSAAction ( "" ) ; messageContext . setSoapAction ( "" ) ; messageContext . setProperty ( NhttpConstants . IGNORE_SC_ACCEPTED , Constants . VALUE_TRUE ) ; messageContext . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . FALSE ) ; } Axis2FlexibleMEPClient . removeAddressingHeaders ( messageContext ) ; messageContext . setMessageID ( UUIDGenerator . getUUID ( ) ) ; if ( messageContext . isEngaged ( WSSHandlerConstants . SECURITY_MODULE_NAME ) && messageContext . getEnvelope ( ) . getHeader ( ) == null ) { SOAPFactory fac = messageContext . isSOAP11 ( ) ? OMAbstractFactory . getSOAP11Factory ( ) : OMAbstractFactory . getSOAP12Factory ( ) ; fac . createSOAPHeader ( messageContext . getEnvelope ( ) ) ; } AxisEngine . send ( messageContext ) ; } catch ( AxisFault e ) { handleException ( "Unexpected error sending message back" , e ) ; } } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1	['5', '1', '0', '22', '45', '8', '2', '20', '3', '0.25', '165', '1', '0', '0', '0.3', '0', '0', '31.8', '15', '3.4', '2']
package org . apache . synapse . mediators . eip . splitter ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . context . OperationContext ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . MessageContext ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . eip . EIPConstants ; import org . apache . synapse . mediators . eip . EIPUtils ; import org . apache . synapse . mediators . eip . Target ; import org . apache . synapse . util . MessageHelper ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . util . Iterator ; import java . util . List ; public class IterateMediator extends AbstractMediator implements ManagedLifecycle { private boolean continueParent = false ; private boolean preservePayload = false ; private SynapseXPath expression = null ; private SynapseXPath attachPath = null ; private Target target = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Iterate mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } try { SOAPEnvelope envelope = MessageHelper . cloneSOAPEnvelope ( synCtx . getEnvelope ( ) ) ; List splitElements = EIPUtils . getDetachedMatchingElements ( envelope , expression ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Splitting with XPath : " + expression + " resulted in " + splitElements . size ( ) + " elements" ) ; } if ( ! preservePayload && envelope . getBody ( ) != null ) { for ( Iterator itr = envelope . getBody ( ) . getChildren ( ) ; itr . hasNext ( ) ; ) { ( ( OMNode ) itr . next ( ) ) . detach ( ) ; } } int msgCount = splitElements . size ( ) ; int msgNumber = 0 ; for ( Object o : splitElements ) { if ( ! ( o instanceof OMNode ) ) { handleException ( "Error splitting message with XPath : " + expression + " - result not an OMNode" , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Submitting " + ( msgNumber + 1 ) + " of " + msgNumber + " messages for processing in parallel" ) ; } target . mediate ( getIteratedMessage ( synCtx , msgNumber ++ , msgCount , envelope , ( OMNode ) o ) ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating split XPath expression : " + expression , e , synCtx ) ; } catch ( AxisFault af ) { handleException ( "Error creating an iterated copy of the message" , af , synCtx ) ; } OperationContext opCtx = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) . getOperationContext ( ) ; if ( ! continueParent && opCtx != null ) { opCtx . setProperty ( Constants . RESPONSE_WRITTEN , "SKIP" ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Iterate mediator" ) ; } return continueParent ; } private MessageContext getIteratedMessage ( MessageContext synCtx , int msgNumber , int msgCount , SOAPEnvelope envelope , OMNode o ) throws AxisFault , JaxenException { MessageContext newCtx = MessageHelper . cloneMessageContext ( synCtx ) ; newCtx . setProperty ( EIPConstants . MESSAGE_SEQUENCE , msgNumber + EIPConstants . MESSAGE_SEQUENCE_DELEMITER + msgCount ) ; SOAPEnvelope newEnvelope = MessageHelper . cloneSOAPEnvelope ( envelope ) ; if ( preservePayload ) { Object attachElem = attachPath . evaluate ( newEnvelope ) ; if ( attachElem != null && attachElem instanceof List && ! ( ( List ) attachElem ) . isEmpty ( ) ) { attachElem = ( ( List ) attachElem ) . get ( 0 ) ; } if ( attachElem != null && attachElem instanceof OMElement ) { ( ( OMElement ) attachElem ) . addChild ( o ) ; } else { handleException ( "Error in attaching the splitted elements :: " + "Unable to get the attach path specified by the expression " + attachPath , synCtx ) ; } } else if ( newEnvelope . getBody ( ) != null ) { newEnvelope . getBody ( ) . addChild ( o ) ; } newCtx . setEnvelope ( newEnvelope ) ; return newCtx ; } public boolean isContinueParent ( ) { return continueParent ; } public void setContinueParent ( boolean continueParent ) { this . continueParent = continueParent ; } public boolean isPreservePayload ( ) { return preservePayload ; } public void setPreservePayload ( boolean preservePayload ) { this . preservePayload = preservePayload ; } public SynapseXPath getExpression ( ) { return expression ; } public void setExpression ( SynapseXPath expression ) { this . expression = expression ; } public SynapseXPath getAttachPath ( ) { return attachPath ; } public void setAttachPath ( SynapseXPath attachPath ) { this . attachPath = attachPath ; } public Target getTarget ( ) { return target ; } public void setTarget ( Target target ) { this . target = target ; } public void init ( SynapseEnvironment se ) { if ( target . getSequence ( ) != null ) { target . getSequence ( ) . init ( se ) ; } } public void destroy ( ) { if ( target . getSequence ( ) != null ) { target . getSequence ( ) . destroy ( ) ; } } } 	1	['15', '2', '0', '21', '53', '27', '2', '19', '14', '0.728571429', '357', '1', '3', '0.481481481', '0.192592593', '0', '0', '22.46666667', '13', '1.8667', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . commons . dbcp . BasicDataSource ; import org . apache . synapse . mediators . db . AbstractDBMediator ; import org . apache . synapse . mediators . db . Statement ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import javax . naming . Context ; import javax . naming . InitialContext ; import javax . naming . NamingException ; import javax . sql . DataSource ; import javax . xml . namespace . QName ; import java . sql . Connection ; import java . util . Hashtable ; import java . util . Iterator ; public abstract class AbstractDBMediatorFactory extends AbstractMediatorFactory { public static final QName URL_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "url" ) ; static final QName DRIVER_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "driver" ) ; static final QName USER_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "user" ) ; static final QName PASS_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "password" ) ; static final QName DSNAME_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "dsName" ) ; static final QName ICCLASS_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "icClass" ) ; static final QName STMNT_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "statement" ) ; static final QName SQL_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "sql" ) ; static final QName PARAM_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "parameter" ) ; static final QName RESULT_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "result" ) ; static final QName ATT_COLUMN = new QName ( "column" ) ; static final QName ATT_TYPE = new QName ( "type" ) ; protected void buildDataSource ( OMElement elem , AbstractDBMediator mediator ) { OMElement pool = null ; try { SynapseXPath xpath = new SynapseXPath ( "self::node()/syn:connection/syn:pool" ) ; xpath . addNamespace ( "syn" , XMLConfigConstants . SYNAPSE_NAMESPACE ) ; pool = ( OMElement ) xpath . selectSingleNode ( elem ) ; if ( pool . getFirstChildWithName ( DRIVER_Q ) != null ) { mediator . setDataSource ( createCustomDataSource ( pool , mediator ) ) ; } else if ( pool . getFirstChildWithName ( ICCLASS_Q ) != null && pool . getFirstChildWithName ( DSNAME_Q ) != null ) { mediator . setDataSource ( lookupDataSource ( pool , mediator ) ) ; } else { handleException ( "The DataSource connection information must be specified for " + "using a custom DataSource connection pool or for a JNDI lookup" ) ; } } catch ( JaxenException e ) { handleException ( "Error looking up DataSource connection information" , e ) ; } } private DataSource lookupDataSource ( OMElement pool , AbstractDBMediator mediator ) { Hashtable props = new Hashtable ( ) ; props . put ( Context . INITIAL_CONTEXT_FACTORY , ( getValue ( pool , ICCLASS_Q ) ) ) ; props . put ( Context . SECURITY_PRINCIPAL , getValue ( pool , USER_Q ) ) ; props . put ( Context . SECURITY_CREDENTIALS , getValue ( pool , PASS_Q ) ) ; props . put ( Context . PROVIDER_URL , getValue ( pool , URL_Q ) ) ; String dsName = getValue ( pool , DSNAME_Q ) ; mediator . addDataSourceProperty ( ICCLASS_Q , getValue ( pool , ICCLASS_Q ) ) ; mediator . addDataSourceProperty ( DSNAME_Q , getValue ( pool , DSNAME_Q ) ) ; mediator . addDataSourceProperty ( URL_Q , getValue ( pool , URL_Q ) ) ; mediator . addDataSourceProperty ( USER_Q , getValue ( pool , USER_Q ) ) ; mediator . addDataSourceProperty ( PASS_Q , getValue ( pool , PASS_Q ) ) ; try { Context ctx = new InitialContext ( props ) ; Object ds = ctx . lookup ( dsName ) ; if ( ds != null && ds instanceof DataSource ) { return ( DataSource ) ds ; } else { handleException ( "DataSource : " + dsName + " not found when looking up" + " using JNDI properties : " + props ) ; } } catch ( NamingException e ) { handleException ( "Error looking up DataSource : " + dsName + " using JNDI properties : " + props , e ) ; } return null ; } private DataSource createCustomDataSource ( OMElement pool , AbstractDBMediator mediator ) { BasicDataSource ds = new BasicDataSource ( ) ; ds . setDriverClassName ( getValue ( pool , DRIVER_Q ) ) ; ds . setUsername ( getValue ( pool , USER_Q ) ) ; ds . setPassword ( getValue ( pool , PASS_Q ) ) ; ds . setUrl ( getValue ( pool , URL_Q ) ) ; mediator . addDataSourceProperty ( DRIVER_Q , getValue ( pool , DRIVER_Q ) ) ; mediator . addDataSourceProperty ( URL_Q , getValue ( pool , URL_Q ) ) ; mediator . addDataSourceProperty ( USER_Q , getValue ( pool , USER_Q ) ) ; mediator . addDataSourceProperty ( PASS_Q , getValue ( pool , PASS_Q ) ) ; Iterator props = pool . getChildrenWithName ( PROP_Q ) ; while ( props . hasNext ( ) ) { OMElement prop = ( OMElement ) props . next ( ) ; String name = prop . getAttribute ( ATT_NAME ) . getAttributeValue ( ) ; String value = prop . getAttribute ( ATT_VALUE ) . getAttributeValue ( ) ; mediator . addDataSourceProperty ( name , value ) ; if ( "autocommit" . equals ( name ) ) { if ( "true" . equals ( value ) ) { ds . setDefaultAutoCommit ( true ) ; } else if ( "false" . equals ( value ) ) { ds . setDefaultAutoCommit ( false ) ; } } else if ( "isolation" . equals ( name ) ) { try { if ( "Connection.TRANSACTION_NONE" . equals ( value ) ) { ds . setDefaultTransactionIsolation ( Connection . TRANSACTION_NONE ) ; } else if ( "Connection.TRANSACTION_READ_COMMITTED" . equals ( value ) ) { ds . setDefaultTransactionIsolation ( Connection . TRANSACTION_READ_COMMITTED ) ; } else if ( "Connection.TRANSACTION_READ_UNCOMMITTED" . equals ( value ) ) { ds . setDefaultTransactionIsolation ( Connection . TRANSACTION_READ_UNCOMMITTED ) ; } else if ( "Connection.TRANSACTION_REPEATABLE_READ" . equals ( value ) ) { ds . setDefaultTransactionIsolation ( Connection . TRANSACTION_REPEATABLE_READ ) ; } else if ( "Connection.TRANSACTION_SERIALIZABLE" . equals ( value ) ) { ds . setDefaultTransactionIsolation ( Connection . TRANSACTION_SERIALIZABLE ) ; } } catch ( NumberFormatException ignore ) { } } else if ( "initialsize" . equals ( name ) ) { try { ds . setInitialSize ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "maxactive" . equals ( name ) ) { try { ds . setMaxActive ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "maxidle" . equals ( name ) ) { try { ds . setMaxIdle ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "maxopenstatements" . equals ( name ) ) { try { ds . setMaxOpenPreparedStatements ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "maxwait" . equals ( name ) ) { try { ds . setMaxWait ( Long . parseLong ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "minidle" . equals ( name ) ) { try { ds . setMinIdle ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException ignore ) { } } else if ( "poolstatements" . equals ( name ) ) { if ( "true" . equals ( value ) ) { ds . setPoolPreparedStatements ( true ) ; } else if ( "false" . equals ( value ) ) { ds . setPoolPreparedStatements ( false ) ; } } else if ( "testonborrow" . equals ( name ) ) { if ( "true" . equals ( value ) ) { ds . setTestOnBorrow ( true ) ; } else if ( "false" . equals ( value ) ) { ds . setTestOnBorrow ( false ) ; } } else if ( "testonreturn" . equals ( name ) ) { if ( "true" . equals ( value ) ) { ds . setTestOnReturn ( true ) ; } else if ( "false" . equals ( value ) ) { ds . setTestOnReturn ( false ) ; } } else if ( "testwhileidle" . equals ( name ) ) { if ( "true" . equals ( value ) ) { ds . setTestWhileIdle ( true ) ; } else if ( "false" . equals ( value ) ) { ds . setTestWhileIdle ( false ) ; } } else if ( "validationquery" . equals ( name ) ) { ds . setValidationQuery ( value ) ; } } return ds ; } protected void processStatements ( OMElement elem , AbstractDBMediator mediator ) { Iterator iter = elem . getChildrenWithName ( STMNT_Q ) ; while ( iter . hasNext ( ) ) { OMElement stmntElt = ( OMElement ) iter . next ( ) ; Statement statement = new Statement ( getValue ( stmntElt , SQL_Q ) ) ; Iterator paramIter = stmntElt . getChildrenWithName ( PARAM_Q ) ; while ( paramIter . hasNext ( ) ) { OMElement paramElt = ( OMElement ) paramIter . next ( ) ; String xpath = getAttribute ( paramElt , ATT_EXPRN ) ; String value = getAttribute ( paramElt , ATT_VALUE ) ; if ( xpath != null || value != null ) { SynapseXPath xp = null ; if ( xpath != null ) { try { xp = SynapseXPathFactory . getSynapseXPath ( paramElt , ATT_EXPRN ) ; } catch ( JaxenException e ) { handleException ( "Invalid XPath specified for the source attribute : " + xpath ) ; } } statement . addParameter ( value , xp , getAttribute ( paramElt , ATT_TYPE ) ) ; } } Iterator resultIter = stmntElt . getChildrenWithName ( RESULT_Q ) ; while ( resultIter . hasNext ( ) ) { OMElement resultElt = ( OMElement ) resultIter . next ( ) ; statement . addResult ( getAttribute ( resultElt , ATT_NAME ) , getAttribute ( resultElt , ATT_COLUMN ) ) ; } mediator . addStatement ( statement ) ; } } protected String getValue ( OMElement elt , QName qName ) { OMElement e = elt . getFirstChildWithName ( qName ) ; if ( e != null ) { return e . getText ( ) ; } else { handleException ( "Unable to read configuration value for : " + qName ) ; } return null ; } protected String getAttribute ( OMElement elt , QName qName ) { OMAttribute a = elt . getAttribute ( qName ) ; if ( a != null ) { return a . getAttributeValue ( ) ; } return null ; } } 	1	['8', '2', '2', '12', '60', '12', '4', '9', '1', '0.75', '709', '0', '0', '0.333333333', '0.678571429', '0', '0', '86.125', '23', '5', '2']
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . transport . http . HTTPConstants ; import org . apache . axis2 . description . Parameter ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . client . ServiceClient ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . context . ConfigurationContextFactory ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . MessageHelper ; import org . apache . synapse . util . xpath . SynapseXPath ; import org . jaxen . JaxenException ; import java . util . List ; public class CalloutMediator extends AbstractMediator implements ManagedLifecycle { private ServiceClient sc = null ; private String serviceURL = null ; private String action = null ; private String requestKey = null ; private SynapseXPath requestXPath = null ; private SynapseXPath targetXPath = null ; private String targetKey = null ; private String clientRepository = null ; private String axis2xml = null ; public static String DEFAULT_CLIENT_REPO = "./samples/axis2Client/client_repo" ; public static String DEFAULT_AXIS2_XML = "./samples/axis2Client/client_repo/conf/axis2.xml" ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Callout mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } try { Options options = new Options ( ) ; options . setTo ( new EndpointReference ( serviceURL ) ) ; if ( action != null ) { options . setAction ( action ) ; } else { if ( synCtx . isSOAP11 ( ) ) { options . setProperty ( Constants . Configuration . DISABLE_SOAP_ACTION , true ) ; } else { Axis2MessageContext axis2smc = ( Axis2MessageContext ) synCtx ; org . apache . axis2 . context . MessageContext axis2MessageCtx = axis2smc . getAxis2MessageContext ( ) ; axis2MessageCtx . getTransportOut ( ) . addParameter ( new Parameter ( HTTPConstants . OMIT_SOAP_12_ACTION , true ) ) ; } } options . setProperty ( AddressingConstants . DISABLE_ADDRESSING_FOR_OUT_MESSAGES , Boolean . TRUE ) ; sc . setOptions ( options ) ; OMElement request = getRequestPayload ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "About to invoke service : " + serviceURL + ( action != null ? " with action : " + action : "" ) ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Request message payload : " + request ) ; } } OMElement result = sc . sendReceive ( request ) ; if ( traceOrDebugOn ) { if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Response payload received : " + result ) ; } } if ( result != null ) { if ( targetXPath != null ) { Object o = targetXPath . evaluate ( synCtx ) ; if ( o != null && o instanceof OMElement ) { OMNode tgtNode = ( OMElement ) o ; tgtNode . insertSiblingAfter ( result ) ; tgtNode . detach ( ) ; } else if ( o != null && o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { OMNode tgtNode = ( OMElement ) ( ( List ) o ) . get ( 0 ) ; tgtNode . insertSiblingAfter ( result ) ; tgtNode . detach ( ) ; } else { handleException ( "Evaluation of target XPath expression : " + targetXPath . toString ( ) + " did not yeild an OMNode" , synCtx ) ; } } if ( targetKey != null ) { synCtx . setProperty ( targetKey , result ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Service returned a null response" ) ; } } } catch ( Exception e ) { handleException ( "Error invoking service : " + serviceURL + ( action != null ? " with action : " + action : "" ) , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Callout mediator" ) ; } return true ; } private OMElement getRequestPayload ( MessageContext synCtx ) throws AxisFault { if ( requestKey != null ) { Object request = synCtx . getProperty ( requestKey ) ; if ( request == null ) { request = synCtx . getEntry ( requestKey ) ; } if ( request != null && request instanceof OMElement ) { return ( OMElement ) request ; } else { handleException ( "The property : " + requestKey + " is not an OMElement" , synCtx ) ; } } else if ( requestXPath != null ) { try { Object o = null ; o = requestXPath . evaluate ( MessageHelper . cloneMessageContext ( synCtx ) ) ; if ( o instanceof OMElement ) { return ( OMElement ) o ; } else if ( o instanceof List && ! ( ( List ) o ) . isEmpty ( ) ) { return ( OMElement ) ( ( List ) o ) . get ( 0 ) ; } else { handleException ( "The evaluation of the XPath expression : " + requestXPath . toString ( ) + " did not result in an OMElement" , synCtx ) ; } } catch ( JaxenException e ) { handleException ( "Error evaluating XPath expression : " + requestXPath . toString ( ) , e , synCtx ) ; } } return null ; } public void init ( SynapseEnvironment synEnv ) { try { ConfigurationContext cfgCtx = ConfigurationContextFactory . createConfigurationContextFromFileSystem ( clientRepository != null ? clientRepository : DEFAULT_CLIENT_REPO , axis2xml != null ? axis2xml : DEFAULT_AXIS2_XML ) ; sc = new ServiceClient ( cfgCtx , null ) ; } catch ( AxisFault e ) { String msg = "Error initializing callout mediator : " + e . getMessage ( ) ; log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } public void destroy ( ) { try { sc . cleanup ( ) ; } catch ( AxisFault ignore ) { } } public String getServiceURL ( ) { return serviceURL ; } public void setServiceURL ( String serviceURL ) { this . serviceURL = serviceURL ; } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } public String getRequestKey ( ) { return requestKey ; } public void setRequestKey ( String requestKey ) { this . requestKey = requestKey ; } public void setRequestXPath ( SynapseXPath requestXPath ) throws JaxenException { this . requestXPath = requestXPath ; } public void setTargetXPath ( SynapseXPath targetXPath ) throws JaxenException { this . targetXPath = targetXPath ; } public String getTargetKey ( ) { return targetKey ; } public void setTargetKey ( String targetKey ) { this . targetKey = targetKey ; } public SynapseXPath getRequestXPath ( ) { return requestXPath ; } public SynapseXPath getTargetXPath ( ) { return targetXPath ; } public String getClientRepository ( ) { return clientRepository ; } public void setClientRepository ( String clientRepository ) { this . clientRepository = clientRepository ; } public String getAxis2xml ( ) { return axis2xml ; } public void setAxis2xml ( String axis2xml ) { this . axis2xml = axis2xml ; } } 	1	['22', '2', '0', '25', '64', '135', '2', '23', '20', '0.865800866', '544', '0.818181818', '2', '0.393939394', '0.304761905', '0', '0', '23.22727273', '22', '1.9545', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNode ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import org . apache . synapse . config . XMLToObjectMapper ; import sun . misc . Service ; import javax . xml . namespace . QName ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class MediatorFactoryFinder implements XMLToObjectMapper { private static final Log log = LogFactory . getLog ( MediatorFactoryFinder . class ) ; private static final Class [ ] mediatorFactories = { SequenceMediatorFactory . class , LogMediatorFactory . class , SendMediatorFactory . class , FilterMediatorFactory . class , SynapseMediatorFactory . class , DropMediatorFactory . class , HeaderMediatorFactory . class , FaultMediatorFactory . class , PropertyMediatorFactory . class , SwitchMediatorFactory . class , InMediatorFactory . class , OutMediatorFactory . class , RMSequenceMediatorFactory . class , ClassMediatorFactory . class , ValidateMediatorFactory . class , XSLTMediatorFactory . class , AnnotatedCommandMediatorFactory . class , POJOCommandMediatorFactory . class , CloneMediatorFactory . class , IterateMediatorFactory . class , AggregateMediatorFactory . class , DBReportMediatorFactory . class , DBLookupMediatorFactory . class , CacheMediatorFactory . class , CalloutMediatorFactory . class } ; private static MediatorFactoryFinder instance = null ; private static Map < QName , Class > factoryMap = new HashMap < QName , Class > ( ) ; public static synchronized MediatorFactoryFinder getInstance ( ) { if ( instance == null ) { instance = new MediatorFactoryFinder ( ) ; } return instance ; } public synchronized void reset ( ) { factoryMap . clear ( ) ; instance = null ; } private MediatorFactoryFinder ( ) { factoryMap = new HashMap < QName , Class > ( ) ; for ( Class c : mediatorFactories ) { try { MediatorFactory fac = ( MediatorFactory ) c . newInstance ( ) ; factoryMap . put ( fac . getTagQName ( ) , c ) ; } catch ( Exception e ) { throw new SynapseException ( "Error instantiating " + c . getName ( ) , e ) ; } } registerExtensions ( ) ; } private void registerExtensions ( ) { Iterator it = Service . providers ( MediatorFactory . class ) ; while ( it . hasNext ( ) ) { MediatorFactory mf = ( MediatorFactory ) it . next ( ) ; QName tag = mf . getTagQName ( ) ; factoryMap . put ( tag , mf . getClass ( ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Added MediatorFactory " + mf . getClass ( ) + " to handle " + tag ) ; } } } public Mediator getMediator ( OMElement element ) { String localName = element . getLocalName ( ) ; QName qName ; if ( element . getNamespace ( ) != null ) { qName = new QName ( element . getNamespace ( ) . getNamespaceURI ( ) , localName ) ; } else { qName = new QName ( localName ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "getMediator(" + qName + ")" ) ; } Class cls = factoryMap . get ( qName ) ; if ( cls == null && localName . indexOf ( '.' ) > - 1 ) { String newLocalName = localName . substring ( 0 , localName . indexOf ( '.' ) ) ; qName = new QName ( element . getNamespace ( ) . getNamespaceURI ( ) , newLocalName ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "getMediator.2(" + qName + ")" ) ; } cls = factoryMap . get ( qName ) ; } if ( cls == null ) { String msg = "Unknown mediator referenced by configuration element : " + qName ; log . error ( msg ) ; throw new SynapseException ( msg ) ; } try { MediatorFactory mf = ( MediatorFactory ) cls . newInstance ( ) ; return mf . createMediator ( element ) ; } catch ( InstantiationException e ) { String msg = "Error initializing mediator factory : " + cls ; log . error ( msg ) ; throw new SynapseException ( msg , e ) ; } catch ( IllegalAccessException e ) { String msg = "Error initializing mediator factory : " + cls ; log . error ( msg ) ; throw new SynapseException ( msg , e ) ; } } public Map < QName , Class > getFactoryMap ( ) { return factoryMap ; } public Object getObjectFromOMNode ( OMNode om ) { if ( om instanceof OMElement ) { return getMediator ( ( OMElement ) om ) ; } else { handleException ( "Invalid mediator configuration XML : " + om ) ; } return null ; } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1	['9', '1', '0', '14', '39', '0', '4', '10', '5', '0.5', '406', '1', '1', '0', '0.3125', '0', '0', '43.66666667', '7', '1.7778', '2']
package org . apache . synapse . mediators . db ; import org . apache . commons . dbcp . BasicDataSource ; import org . apache . commons . dbcp . datasources . PerUserPoolDataSource ; import org . apache . commons . logging . Log ; import org . apache . synapse . ManagedLifecycle ; import org . apache . synapse . MessageContext ; import org . apache . synapse . config . xml . AbstractDBMediatorFactory ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . mediators . AbstractMediator ; import javax . sql . DataSource ; import javax . xml . namespace . QName ; import java . math . BigDecimal ; import java . sql . * ; import java . sql . Date ; import java . util . * ; public abstract class AbstractDBMediator extends AbstractMediator implements ManagedLifecycle { protected Map dataSourceProps = new HashMap ( ) ; private DataSource dataSource = null ; List statementList = new ArrayList ( ) ; public void init ( SynapseEnvironment se ) { } public void destroy ( ) { if ( this . dataSource instanceof BasicDataSource ) { try { ( ( BasicDataSource ) this . dataSource ) . close ( ) ; log . info ( "Successfully shut down DB connection pool for URL : " + getDSName ( ) ) ; } catch ( SQLException e ) { log . warn ( "Error shutting down DB connection pool for URL : " + getDSName ( ) ) ; } } else if ( this . dataSource instanceof PerUserPoolDataSource ) { ( ( PerUserPoolDataSource ) this . dataSource ) . close ( ) ; log . info ( "Successfully shut down DB connection pool for URL : " + getDSName ( ) ) ; } } public boolean mediate ( MessageContext synCtx ) { String name = ( this instanceof DBLookupMediator ? "DBLookup" : "DBReport" ) ; boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : " + name + " mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } for ( Iterator iter = statementList . iterator ( ) ; iter . hasNext ( ) ; ) { processStatement ( ( Statement ) iter . next ( ) , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : " + name + " mediator" ) ; } return true ; } abstract protected void processStatement ( Statement query , MessageContext msgCtx ) ; protected String getDSName ( ) { return ( String ) dataSourceProps . get ( AbstractDBMediatorFactory . URL_Q ) ; } public DataSource getDataSource ( ) { return dataSource ; } public void setDataSource ( DataSource dataSource ) { this . dataSource = dataSource ; } public void addDataSourceProperty ( QName name , String value ) { dataSourceProps . put ( name , value ) ; } public void addDataSourceProperty ( String name , String value ) { dataSourceProps . put ( name , value ) ; } public Map getDataSourceProps ( ) { return dataSourceProps ; } public void addStatement ( Statement stmnt ) { statementList . add ( stmnt ) ; } public List getStatementList ( ) { return statementList ; } protected PreparedStatement getPreparedStatement ( Statement stmnt , MessageContext msgCtx ) throws SQLException { boolean traceOn = isTraceOn ( msgCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; Log serviceLog = msgCtx . getServiceLog ( ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Getting a connection from DataSource " + getDSName ( ) + " and preparing statement : " + stmnt . getRawStatement ( ) ) ; } Connection con = getDataSource ( ) . getConnection ( ) ; PreparedStatement ps = con . prepareStatement ( stmnt . getRawStatement ( ) ) ; List params = stmnt . getParameters ( ) ; int column = 1 ; for ( Iterator pi = params . iterator ( ) ; pi . hasNext ( ) ; ) { Statement . Parameter param = ( Statement . Parameter ) pi . next ( ) ; String value = ( param . getPropertyName ( ) != null ? param . getPropertyName ( ) : param . getXpath ( ) . stringValueOf ( msgCtx ) ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Setting as parameter : " + column + " value : " + value + " as JDBC Type : " + param . getType ( ) + "(see java.sql.Types for valid types)" ) ; } switch ( param . getType ( ) ) { case Types . CHAR : case Types . VARCHAR : case Types . LONGVARCHAR : { ps . setString ( column ++ , value ) ; break ; } case Types . NUMERIC : case Types . DECIMAL : { ps . setBigDecimal ( column ++ , new BigDecimal ( value ) ) ; break ; } case Types . BIT : { ps . setBoolean ( column ++ , Boolean . parseBoolean ( value ) ) ; break ; } case Types . TINYINT : { ps . setByte ( column ++ , Byte . parseByte ( value ) ) ; break ; } case Types . SMALLINT : { ps . setShort ( column ++ , Short . parseShort ( value ) ) ; break ; } case Types . INTEGER : { ps . setInt ( column ++ , Integer . parseInt ( value ) ) ; break ; } case Types . BIGINT : { ps . setLong ( column ++ , Long . parseLong ( value ) ) ; break ; } case Types . REAL : { ps . setFloat ( column ++ , Float . parseFloat ( value ) ) ; break ; } case Types . FLOAT : { ps . setDouble ( column ++ , Double . parseDouble ( value ) ) ; break ; } case Types . DOUBLE : { ps . setDouble ( column ++ , Double . parseDouble ( value ) ) ; break ; } case Types . DATE : { ps . setDate ( column ++ , Date . valueOf ( value ) ) ; break ; } case Types . TIME : { ps . setTime ( column ++ , Time . valueOf ( value ) ) ; break ; } case Types . TIMESTAMP : { ps . setTimestamp ( column ++ , Timestamp . valueOf ( value ) ) ; break ; } default : { String msg = "Trying to set an un-supported JDBC Type : " + param . getType ( ) + " against column : " + column + " and statement : " + stmnt . getRawStatement ( ) + " used by a DB mediator against DataSource : " + getDSName ( ) + " (see java.sql.Types for valid type values)" ; handleException ( msg , msgCtx ) ; } } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Successfully prepared statement : " + stmnt . getRawStatement ( ) + " against DataSource : " + getDSName ( ) ) ; } return ps ; } } 	1	['14', '2', '2', '19', '71', '47', '8', '13', '11', '0.666666667', '442', '0.666666667', '0', '0.5', '0.255102041', '0', '0', '30.35714286', '7', '1.5', '2']
package org . apache . synapse . mediators . filters ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; public class InMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : In mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } boolean result = true ; if ( test ( synCtx ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Current message is incoming - executing child mediators" ) ; } result = super . mediate ( synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Current message is a response - skipping child mediators" ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : In mediator" ) ; } return result ; } public boolean test ( MessageContext synCtx ) { return ! synCtx . isResponse ( ) ; } } 	1	['3', '3', '0', '7', '16', '3', '2', '5', '3', '2', '74', '0', '0', '0.916666667', '0.833333333', '1', '2', '23.66666667', '8', '3.3333', '1']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . endpoints . AddressEndpoint ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import javax . xml . namespace . QName ; public class AddressEndpointFactory extends DefaultEndpointFactory { private static AddressEndpointFactory instance = new AddressEndpointFactory ( ) ; private AddressEndpointFactory ( ) { } public static AddressEndpointFactory getInstance ( ) { return instance ; } protected Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { AddressEndpoint addressEndpoint = new AddressEndpoint ( ) ; OMAttribute name = epConfig . getAttribute ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { addressEndpoint . setName ( name . getAttributeValue ( ) ) ; } OMElement addressElement = epConfig . getFirstChildWithName ( new QName ( SynapseConstants . SYNAPSE_NAMESPACE , "address" ) ) ; if ( addressElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( addressElement ) ; addressEndpoint . setEndpoint ( endpoint ) ; } return addressEndpoint ; } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { OMAttribute address = elem . getAttribute ( new QName ( "uri" ) ) ; EndpointDefinition endpointDefinition = new EndpointDefinition ( ) ; if ( address != null ) { endpointDefinition . setAddress ( address . getAttributeValue ( ) ) ; } extractCommonEndpointProperties ( endpointDefinition , elem ) ; extractSpecificEndpointProperties ( endpointDefinition , elem ) ; return endpointDefinition ; } } 	1	['5', '3', '0', '7', '18', '8', '1', '6', '2', '0.75', '80', '1', '1', '0.8125', '0.5', '2', '5', '14.8', '3', '1.2', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axis2 . transport . http . AxisServlet ; import org . apache . axis2 . transport . http . ListingAgent ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . ServerManager ; import javax . servlet . ServletConfig ; import javax . servlet . ServletContext ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; public class SynapseAxisServlet extends AxisServlet { private final static Log log = LogFactory . getLog ( SynapseAxisServlet . class ) ; public void init ( ServletConfig config ) throws ServletException { ServletContext servletContext = config . getServletContext ( ) ; this . configContext = ServerManager . getInstance ( ) . getConfigurationContext ( ) ; this . axisConfiguration = this . configContext . getAxisConfiguration ( ) ; servletContext . setAttribute ( this . getClass ( ) . getName ( ) , this ) ; this . servletConfig = config ; agent = new ListingAgent ( configContext ) ; initParams ( ) ; } public void initContextRoot ( HttpServletRequest req ) { this . configContext . setContextRoot ( "/" ) ; } } 	1	['4', '4', '0', '7', '16', '4', '0', '7', '3', '1', '48', '1', '0', '0.964285714', '0.555555556', '1', '6', '10.75', '1', '0.5', '1']
package org . apache . synapse . config . xml . endpoints . utils ; import org . apache . axiom . om . OMElement ; import org . apache . axis2 . util . XMLUtils ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . CustomWSDLLocator ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import org . w3c . dom . Document ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import javax . wsdl . Definition ; import javax . wsdl . Port ; import javax . wsdl . Service ; import javax . wsdl . WSDLException ; import javax . wsdl . extensions . soap . SOAPAddress ; import javax . wsdl . extensions . soap12 . SOAP12Address ; import javax . wsdl . factory . WSDLFactory ; import javax . wsdl . xml . WSDLLocator ; import javax . wsdl . xml . WSDLReader ; import javax . xml . namespace . QName ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . stream . XMLStreamException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class WSDL11EndpointBuilder { private static Log log = LogFactory . getLog ( WSDL11EndpointBuilder . class ) ; public EndpointDefinition createEndpointDefinitionFromWSDL ( String baseUri , OMElement wsdl , String service , String port ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { wsdl . serialize ( baos ) ; InputStream in = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; InputSource inputSource = new InputSource ( in ) ; WSDLLocator wsdlLocator = new CustomWSDLLocator ( inputSource , baseUri ) ; Document doc = null ; try { doc = XMLUtils . newDocument ( inputSource ) ; } catch ( ParserConfigurationException e ) { handleException ( "Parser Configuration Error" , e ) ; } catch ( SAXException e ) { handleException ( "Parser SAX Error" , e ) ; } catch ( IOException e ) { handleException ( WSDLException . INVALID_WSDL + "IO Error" , e ) ; } if ( doc != null ) { WSDLFactory fac = WSDLFactory . newInstance ( ) ; WSDLReader reader = fac . newWSDLReader ( ) ; Definition definition = reader . readWSDL ( wsdlLocator , doc . getDocumentElement ( ) ) ; return createEndpointDefinitionFromWSDL ( definition , service , port ) ; } } catch ( XMLStreamException e ) { handleException ( "Error retrieving the WSDL definition from the inline WSDL." ) ; } catch ( WSDLException e ) { handleException ( "Error retrieving the WSDL definition from the inline WSDL." ) ; } return null ; } private EndpointDefinition createEndpointDefinitionFromWSDL ( String wsdlURI , String service , String port ) { try { WSDLFactory fac = WSDLFactory . newInstance ( ) ; WSDLReader reader = fac . newWSDLReader ( ) ; Definition definition = reader . readWSDL ( wsdlURI ) ; return createEndpointDefinitionFromWSDL ( definition , service , port ) ; } catch ( WSDLException e ) { handleException ( "Error retrieving the WSDL definition from the WSDL URI." ) ; } return null ; } private EndpointDefinition createEndpointDefinitionFromWSDL ( Definition definition , String serviceName , String portName ) { if ( definition == null ) { handleException ( "WSDL is not specified." ) ; } if ( serviceName == null ) { handleException ( "Service of the WSDL document is not specified." ) ; } if ( portName == null ) { handleException ( "Port of the WSDL document is not specified." ) ; } String serviceURL = null ; String format = null ; String tns = definition . getTargetNamespace ( ) ; Service service = definition . getService ( new QName ( tns , serviceName ) ) ; if ( service != null ) { Port port = service . getPort ( portName ) ; if ( port != null ) { List ext = port . getExtensibilityElements ( ) ; for ( int i = 0 ; i < ext . size ( ) ; i ++ ) { Object o = ext . get ( i ) ; if ( o instanceof SOAPAddress ) { SOAPAddress address = ( SOAPAddress ) o ; serviceURL = address . getLocationURI ( ) ; format = SynapseConstants . FORMAT_SOAP11 ; break ; } else if ( o instanceof SOAP12Address ) { SOAP12Address address = ( SOAP12Address ) o ; serviceURL = address . getLocationURI ( ) ; format = SynapseConstants . FORMAT_SOAP12 ; break ; } } } } if ( serviceURL != null ) { EndpointDefinition endpointDefinition = new EndpointDefinition ( ) ; endpointDefinition . setAddress ( serviceURL ) ; if ( SynapseConstants . FORMAT_SOAP11 . equals ( format ) ) { endpointDefinition . setForceSOAP11 ( true ) ; } else if ( SynapseConstants . FORMAT_SOAP12 . equals ( format ) ) { endpointDefinition . setForceSOAP12 ( true ) ; } else { handleException ( "format value -\"" + format + "\" not yet implemented" ) ; } endpointDefinition . setFormat ( format ) ; return endpointDefinition ; } else { handleException ( "Couldn't retrieve endpoint information from the WSDL." ) ; } return null ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } } 	1	['7', '1', '0', '8', '43', '15', '1', '7', '2', '0.166666667', '245', '1', '0', '0', '0.4', '0', '0', '33.85714286', '12', '2.2857', '1']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . endpoints . DefaultEndpoint ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . utils . EndpointDefinition ; import javax . xml . namespace . QName ; public class DefaultEndpointFactory extends EndpointFactory { private static DefaultEndpointFactory instance = new DefaultEndpointFactory ( ) ; protected DefaultEndpointFactory ( ) { } public static DefaultEndpointFactory getInstance ( ) { return instance ; } protected Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { DefaultEndpoint defaultEndpoint = new DefaultEndpoint ( ) ; OMAttribute name = epConfig . getAttribute ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { defaultEndpoint . setName ( name . getAttributeValue ( ) ) ; } OMElement defaultElement = epConfig . getFirstChildWithName ( new QName ( SynapseConstants . SYNAPSE_NAMESPACE , "default" ) ) ; if ( defaultElement != null ) { EndpointDefinition endpoint = createEndpointDefinition ( defaultElement ) ; defaultEndpoint . setEndpoint ( endpoint ) ; } return defaultEndpoint ; } protected void extractSpecificEndpointProperties ( EndpointDefinition definition , OMElement elem ) { OMAttribute format = elem . getAttribute ( new QName ( XMLConfigConstants . NULL_NAMESPACE , "format" ) ) ; if ( format != null ) { String forceValue = format . getAttributeValue ( ) . trim ( ) . toLowerCase ( ) ; if ( SynapseConstants . FORMAT_POX . equals ( forceValue ) ) { definition . setForcePOX ( true ) ; definition . setFormat ( SynapseConstants . FORMAT_POX ) ; } else if ( SynapseConstants . FORMAT_GET . equals ( forceValue ) ) { definition . setForceGET ( true ) ; definition . setFormat ( SynapseConstants . FORMAT_GET ) ; } else if ( SynapseConstants . FORMAT_SOAP11 . equals ( forceValue ) ) { definition . setForceSOAP11 ( true ) ; definition . setFormat ( SynapseConstants . FORMAT_SOAP11 ) ; } else if ( SynapseConstants . FORMAT_SOAP12 . equals ( forceValue ) ) { definition . setForceSOAP12 ( true ) ; definition . setFormat ( SynapseConstants . FORMAT_SOAP12 ) ; } else { handleException ( "force value -\"" + forceValue + "\" not yet implemented" ) ; } } } public EndpointDefinition createEndpointDefinition ( OMElement elem ) { EndpointDefinition endpointDefinition = new EndpointDefinition ( ) ; extractCommonEndpointProperties ( endpointDefinition , elem ) ; extractSpecificEndpointProperties ( endpointDefinition , elem ) ; return endpointDefinition ; } } 	1	['6', '2', '1', '7', '28', '13', '2', '6', '2', '0.8', '139', '1', '1', '0.692307692', '0.45', '2', '3', '22', '6', '1.8333', '1']
package org . apache . synapse . config . xml . endpoints ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . xml . XMLConfigConstants ; import org . apache . synapse . config . xml . endpoints . utils . LoadbalanceAlgorithmFactory ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . endpoints . SALoadbalanceEndpoint ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . dispatch . Dispatcher ; import org . apache . synapse . endpoints . dispatch . HttpSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SimpleClientSessionDispatcher ; import org . apache . synapse . endpoints . dispatch . SoapSessionDispatcher ; import javax . xml . namespace . QName ; import java . util . ArrayList ; import java . util . Iterator ; public class SALoadbalanceEndpointFactory extends EndpointFactory { private static SALoadbalanceEndpointFactory instance = new SALoadbalanceEndpointFactory ( ) ; private SALoadbalanceEndpointFactory ( ) { } public static SALoadbalanceEndpointFactory getInstance ( ) { return instance ; } protected Endpoint createEndpoint ( OMElement epConfig , boolean anonymousEndpoint ) { SALoadbalanceEndpoint loadbalanceEndpoint = new SALoadbalanceEndpoint ( ) ; OMElement sessionElement = epConfig . getFirstChildWithName ( new QName ( SynapseConstants . SYNAPSE_NAMESPACE , "session" ) ) ; if ( sessionElement != null ) { String type = sessionElement . getAttributeValue ( new QName ( "type" ) ) ; if ( type . equalsIgnoreCase ( "soap" ) ) { Dispatcher soapDispatcher = new SoapSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( soapDispatcher ) ; } else if ( type . equalsIgnoreCase ( "http" ) ) { Dispatcher httpDispatcher = new HttpSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( httpDispatcher ) ; } else if ( type . equalsIgnoreCase ( "simpleClientSession" ) ) { Dispatcher csDispatcher = new SimpleClientSessionDispatcher ( ) ; loadbalanceEndpoint . setDispatcher ( csDispatcher ) ; } } else { handleException ( "Session affinity endpoints should " + "have a session element in the configuration." ) ; } OMAttribute name = epConfig . getAttribute ( new QName ( org . apache . synapse . config . xml . XMLConfigConstants . NULL_NAMESPACE , "name" ) ) ; if ( name != null ) { loadbalanceEndpoint . setName ( name . getAttributeValue ( ) ) ; } OMElement loadbalanceElement ; loadbalanceElement = epConfig . getFirstChildWithName ( new QName ( SynapseConstants . SYNAPSE_NAMESPACE , "loadbalance" ) ) ; if ( loadbalanceElement != null ) { ArrayList < Endpoint > endpoints = getEndpoints ( loadbalanceElement , loadbalanceEndpoint ) ; loadbalanceEndpoint . setEndpoints ( endpoints ) ; LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory . createLoadbalanceAlgorithm ( loadbalanceElement , endpoints ) ; loadbalanceEndpoint . setAlgorithm ( algorithm ) ; return loadbalanceEndpoint ; } return null ; } } 	1	['4', '2', '0', '11', '23', '4', '1', '11', '1', '0.666666667', '117', '1', '1', '0.818181818', '0.444444444', '1', '2', '28', '6', '1.75', '1']
package org . apache . synapse . endpoints . algorithms ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import org . apache . synapse . endpoints . Endpoint ; import java . util . ArrayList ; public class RoundRobin implements LoadbalanceAlgorithm { private static final Log log = LogFactory . getLog ( RoundRobin . class ) ; private ArrayList endpoints = null ; public RoundRobin ( ArrayList endpoints ) { this . endpoints = endpoints ; } public Endpoint getNextEndpoint ( MessageContext synapseMessageContext , AlgorithmContext algorithmContext ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using the Round Robin loadbalancing algorithm to select the next endpoint" ) ; } Endpoint nextEndpoint ; int attempts = 0 ; int currentEPR = algorithmContext . getCurrentEndpointIndex ( ) ; do { synchronized ( this ) { nextEndpoint = ( Endpoint ) endpoints . get ( currentEPR ) ; if ( currentEPR == endpoints . size ( ) - 1 ) { currentEPR = 0 ; } else { currentEPR ++ ; } algorithmContext . setCurrentEPR ( currentEPR ) ; } attempts ++ ; if ( attempts > endpoints . size ( ) ) { log . warn ( "Couldn't find an endpoint from the Round Robin loadbalancing algorithm" ) ; return null ; } } while ( ! nextEndpoint . isActive ( synapseMessageContext ) ) ; return nextEndpoint ; } public void reset ( AlgorithmContext algorithmContext ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Resetting the Round Robin loadbalancing algorithm ..." ) ; } algorithmContext . setCurrentEPR ( 0 ) ; } } 	1	['4', '1', '0', '9', '14', '0', '3', '6', '3', '0.5', '89', '1', '0', '0', '0.583333333', '0', '0', '20.75', '5', '1.75', '3']
package org . apache . synapse . config ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . engine . AxisConfiguration ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . * ; import org . apache . synapse . config . xml . MediatorFactoryFinder ; import org . apache . synapse . config . xml . endpoints . XMLToEndpointMapper ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . core . axis2 . ProxyService ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . registry . Registry ; import javax . xml . namespace . QName ; import java . io . IOException ; import java . util . * ; public class SynapseConfiguration implements ManagedLifecycle { private static final Log log = LogFactory . getLog ( SynapseConfiguration . class ) ; Registry registry = null ; private QName defaultQName = null ; private Mediator mandatorySequence = null ; private Map < String , ProxyService > proxyServices = new HashMap < String , ProxyService > ( ) ; private Map < String , Startup > startups = new HashMap < String , Startup > ( ) ; private Map < String , Object > localRegistry = new HashMap < String , Object > ( ) ; private Properties properties = new Properties ( ) ; private Timer synapseTimer = new Timer ( true ) ; private AxisConfiguration axisConfiguration = null ; private String pathToConfigFile = null ; public void addSequence ( String key , Mediator mediator ) { localRegistry . put ( key , mediator ) ; } public void addSequence ( String key , Entry entry ) { localRegistry . put ( key , entry ) ; } public Map < String , SequenceMediator > getDefinedSequences ( ) { Map < String , SequenceMediator > definedSequences = new HashMap < String , SequenceMediator > ( ) ; for ( Object o : localRegistry . values ( ) ) { if ( o instanceof SequenceMediator ) { SequenceMediator seq = ( SequenceMediator ) o ; definedSequences . put ( seq . getName ( ) , seq ) ; } } return definedSequences ; } public Mediator getMandatorySequence ( ) { return mandatorySequence ; } public void setMandatorySequence ( Mediator mandatorySequence ) { this . mandatorySequence = mandatorySequence ; } public Mediator getSequence ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } Entry entry ; if ( o != null && o instanceof Entry ) { entry = ( Entry ) o ; } else { entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; entry . setMapper ( MediatorFactoryFinder . getInstance ( ) ) ; } if ( registry != null ) { o = registry . getResource ( entry ) ; if ( o != null && o instanceof Mediator ) { localRegistry . put ( key , entry ) ; return ( Mediator ) o ; } } return null ; } public void removeSequence ( String key ) { localRegistry . remove ( key ) ; } public Mediator getMainSequence ( ) { return getSequence ( SynapseConstants . MAIN_SEQUENCE_KEY ) ; } public Mediator getFaultSequence ( ) { return getSequence ( SynapseConstants . FAULT_SEQUENCE_KEY ) ; } public void addEntry ( String key , Entry entry ) { if ( entry . getType ( ) == Entry . URL_SRC && entry . getValue ( ) == null ) { try { entry . setValue ( SynapseConfigUtils . getOMElementFromURL ( entry . getSrc ( ) . toString ( ) ) ) ; localRegistry . put ( key , entry ) ; } catch ( IOException e ) { handleException ( "Can not read from source URL : " + entry . getSrc ( ) ) ; } } else { localRegistry . put ( key , entry ) ; } } public Map < String , Entry > getCachedEntries ( ) { Map < String , Entry > cachedEntries = new HashMap < String , Entry > ( ) ; for ( Object o : localRegistry . values ( ) ) { if ( o != null && o instanceof Entry ) { Entry entry = ( Entry ) o ; if ( entry . isDynamic ( ) && entry . isCached ( ) ) { cachedEntries . put ( entry . getKey ( ) , entry ) ; } } } return cachedEntries ; } public Map < String , Entry > getDefinedEntries ( ) { Map < String , Entry > definedEntries = new HashMap < String , Entry > ( ) ; for ( Object o : localRegistry . values ( ) ) { if ( o instanceof Entry && ( ( Entry ) o ) . getType ( ) != Entry . REMOTE_ENTRY ) { Entry entry = ( Entry ) o ; definedEntries . put ( entry . getKey ( ) , entry ) ; } } return definedEntries ; } public Object getEntry ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Entry ) { Entry entry = ( Entry ) o ; if ( entry . isDynamic ( ) ) { if ( entry . isCached ( ) && ! entry . isExpired ( ) ) { return entry . getValue ( ) ; } else if ( registry != null ) { o = registry . getResource ( entry ) ; } else { if ( log . isDebugEnabled ( ) ) { log . debug ( "Will not  evaluate the value of the remote entry with a key " + key + ",  because the registry is not available" ) ; } return null ; } } else { return entry . getValue ( ) ; } } return o ; } public Entry getEntryDefinition ( String key ) { Object o = localRegistry . get ( key ) ; if ( o == null || o instanceof Entry ) { if ( o == null ) { Entry entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; addEntry ( key , entry ) ; return entry ; } return ( Entry ) o ; } else { handleException ( "Invalid local registry entry : " + key ) ; return null ; } } public void removeEntry ( String key ) { localRegistry . remove ( key ) ; } public void clearCachedEntry ( String key ) { Entry entry = getEntryDefinition ( key ) ; if ( entry . isDynamic ( ) && entry . isCached ( ) ) { entry . clearCache ( ) ; } } public void clearCache ( ) { for ( Object o : localRegistry . values ( ) ) { if ( o != null && o instanceof Entry ) { Entry entry = ( Entry ) o ; if ( entry . isDynamic ( ) && entry . isCached ( ) ) { entry . clearCache ( ) ; } } } } public void addEndpoint ( String key , Endpoint endpoint ) { localRegistry . put ( key , endpoint ) ; } public void addEndpoint ( String key , Entry entry ) { localRegistry . put ( key , entry ) ; } public Map < String , Endpoint > getDefinedEndpoints ( ) { Map < String , Endpoint > definedEndpoints = new HashMap < String , Endpoint > ( ) ; for ( Object o : localRegistry . values ( ) ) { if ( o instanceof Endpoint ) { Endpoint ep = ( Endpoint ) o ; definedEndpoints . put ( ep . getName ( ) , ep ) ; } } return definedEndpoints ; } public Endpoint getEndpoint ( String key ) { Object o = localRegistry . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } Entry entry ; if ( o != null && o instanceof Entry ) { entry = ( Entry ) o ; } else { entry = new Entry ( key ) ; entry . setType ( Entry . REMOTE_ENTRY ) ; entry . setMapper ( XMLToEndpointMapper . getInstance ( ) ) ; } if ( registry != null ) { o = registry . getResource ( entry ) ; if ( o != null && o instanceof Endpoint ) { localRegistry . put ( key , entry ) ; return ( Endpoint ) o ; } } return null ; } public void removeEndpoint ( String key ) { localRegistry . remove ( key ) ; } public void addProxyService ( String name , ProxyService proxy ) { proxyServices . put ( name , proxy ) ; } public ProxyService getProxyService ( String name ) { return proxyServices . get ( name ) ; } public void removeProxyService ( String name ) { Object o = proxyServices . get ( name ) ; if ( o == null ) { handleException ( "Unknown proxy service for name : " + name ) ; } else { try { if ( getAxisConfiguration ( ) . getServiceForActivation ( name ) != null ) { if ( getAxisConfiguration ( ) . getServiceForActivation ( name ) . isActive ( ) ) { getAxisConfiguration ( ) . getService ( name ) . setActive ( false ) ; } getAxisConfiguration ( ) . removeService ( name ) ; } proxyServices . remove ( name ) ; } catch ( AxisFault axisFault ) { handleException ( axisFault . getMessage ( ) ) ; } } } public Collection < ProxyService > getProxyServices ( ) { return proxyServices . values ( ) ; } public Map getLocalRegistry ( ) { return Collections . unmodifiableMap ( localRegistry ) ; } public Registry getRegistry ( ) { return registry ; } public void setRegistry ( Registry registry ) { this . registry = registry ; } public void setAxisConfiguration ( AxisConfiguration axisConfig ) { this . axisConfiguration = axisConfig ; } public AxisConfiguration getAxisConfiguration ( ) { return axisConfiguration ; } public String getPathToConfigFile ( ) { return pathToConfigFile ; } public void setPathToConfigFile ( String pathToConfigFile ) { this . pathToConfigFile = pathToConfigFile ; } public void setDefaultQName ( QName defaultQName ) { this . defaultQName = defaultQName ; } public QName getDefaultQName ( ) { return defaultQName ; } public Timer getSynapseTimer ( ) { return synapseTimer ; } public Collection < Startup > getStartups ( ) { return startups . values ( ) ; } public Startup getStartup ( String id ) { return startups . get ( id ) ; } public void addStartup ( Startup startup ) { startups . put ( startup . getName ( ) , startup ) ; } public void removeStartup ( String name ) { startups . remove ( name ) ; } public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } public String getProperty ( String propKey , String def ) { String val = System . getProperty ( propKey ) ; if ( val == null ) { val = properties . getProperty ( propKey ) ; } if ( val != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using synapse tuning parameter : " + propKey + " = " + val ) ; } return val ; } return def ; } public long getProperty ( String propKey , long def ) { String val = System . getProperty ( propKey ) ; if ( val == null ) { val = properties . getProperty ( propKey ) ; } if ( val != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using synapse tuning parameter : " + propKey + " = " + val ) ; } return Long . valueOf ( val ) ; } return def ; } public String getProperty ( String propKey ) { String val = System . getProperty ( propKey ) ; if ( val == null ) { val = properties . getProperty ( propKey ) ; } if ( val != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Using synapse tuning parameter : " + propKey + " = " + val ) ; } return val ; } return null ; } public void destroy ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Destroying the Synapse Configuration" ) ; } synapseTimer . cancel ( ) ; synapseTimer = null ; for ( ProxyService p : getProxyServices ( ) ) { if ( p . getTargetInLineInSequence ( ) != null ) { p . getTargetInLineInSequence ( ) . destroy ( ) ; } if ( p . getTargetInLineOutSequence ( ) != null ) { p . getTargetInLineOutSequence ( ) . destroy ( ) ; } } for ( SequenceMediator seq : getDefinedSequences ( ) . values ( ) ) { if ( seq != null ) { seq . destroy ( ) ; } } if ( startups != null ) { for ( Startup stp : startups . values ( ) ) { if ( stp != null ) { stp . destroy ( ) ; } } } } public void init ( SynapseEnvironment se ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Initializing the Synapse Configuration" ) ; } if ( registry != null && registry instanceof ManagedLifecycle ) { ( ( ManagedLifecycle ) registry ) . init ( se ) ; } for ( ProxyService p : getProxyServices ( ) ) { if ( p . getTargetInLineInSequence ( ) != null ) { p . getTargetInLineInSequence ( ) . init ( se ) ; } if ( p . getTargetInLineOutSequence ( ) != null ) { p . getTargetInLineOutSequence ( ) . init ( se ) ; } } for ( SequenceMediator seq : getDefinedSequences ( ) . values ( ) ) { if ( seq != null ) { seq . init ( se ) ; } } } private void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1	['50', '1', '0', '46', '108', '697', '27', '20', '48', '0.871985158', '976', '0.909090909', '2', '0', '0.135007849', '0', '0', '18.3', '8', '2.1', '4']
package org . apache . synapse . mediators . db ; import org . apache . synapse . MessageContext ; import java . sql . PreparedStatement ; import java . sql . SQLException ; import java . sql . Connection ; public class DBReportMediator extends AbstractDBMediator { protected void processStatement ( Statement stmnt , MessageContext msgCtx ) { boolean traceOn = isTraceOn ( msgCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; Connection con = null ; try { PreparedStatement ps = getPreparedStatement ( stmnt , msgCtx ) ; con = ps . getConnection ( ) ; int count = ps . executeUpdate ( ) ; if ( count > 0 ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Inserted " + count + " row/s using statement : " + stmnt . getRawStatement ( ) ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "No rows were inserted for statement : " + stmnt . getRawStatement ( ) ) ; } } con . commit ( ) ; } catch ( SQLException e ) { handleException ( "Error execuring insert statement : " + stmnt . getRawStatement ( ) + " against DataSource : " + getDSName ( ) , e , msgCtx ) ; } finally { if ( con != null ) { try { con . close ( ) ; } catch ( SQLException ignore ) { } } } } } 	1	['2', '3', '0', '5', '18', '1', '2', '3', '1', '2', '106', '0', '0', '0.962962963', '0.666666667', '2', '5', '52', '7', '3.5', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . mediators . transform . XSLTMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . util . Iterator ; public class XSLTMediatorFactory extends AbstractMediatorFactory { private static final QName TAG_NAME = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "xslt" ) ; public QName getTagQName ( ) { return TAG_NAME ; } public Mediator createMediator ( OMElement elem ) { XSLTMediator transformMediator = new XSLTMediator ( ) ; OMAttribute attXslt = elem . getAttribute ( ATT_KEY ) ; OMAttribute attSource = elem . getAttribute ( ATT_SOURCE ) ; OMAttribute attTarget = elem . getAttribute ( ATT_TARGET ) ; if ( attXslt != null ) { transformMediator . setXsltKey ( attXslt . getAttributeValue ( ) ) ; } else { handleException ( "The 'key' attribute is required for the XSLT mediator" ) ; } if ( attSource != null ) { try { transformMediator . setSourceXPathString ( attSource . getAttributeValue ( ) ) ; transformMediator . setSource ( SynapseXPathFactory . getSynapseXPath ( elem , ATT_SOURCE ) ) ; } catch ( JaxenException e ) { handleException ( "Invalid XPath specified for the source attribute : " + attSource . getAttributeValue ( ) ) ; } } if ( attTarget != null ) { transformMediator . setTargetPropertyName ( attTarget . getAttributeValue ( ) ) ; } processTraceState ( transformMediator , elem ) ; Iterator iter = elem . getChildrenWithName ( FEATURE_Q ) ; while ( iter . hasNext ( ) ) { OMElement featureElem = ( OMElement ) iter . next ( ) ; OMAttribute attName = featureElem . getAttribute ( ATT_NAME ) ; OMAttribute attValue = featureElem . getAttribute ( ATT_VALUE ) ; if ( attName != null && attValue != null ) { String name = attName . getAttributeValue ( ) ; String value = attValue . getAttributeValue ( ) ; if ( name != null && value != null ) { if ( "true" . equals ( value . trim ( ) ) ) { transformMediator . addFeature ( name . trim ( ) , true ) ; } else if ( "false" . equals ( value . trim ( ) ) ) { transformMediator . addFeature ( name . trim ( ) , false ) ; } else { handleException ( "The feature must have value true or false" ) ; } } else { handleException ( "The valid values for both of the name and value are need" ) ; } } else { handleException ( "Both of the name and value attribute are required for a feature" ) ; } } transformMediator . addAllProperties ( MediatorPropertyFactory . getMediatorProperties ( elem ) ) ; return transformMediator ; } } 	1	['4', '2', '0', '9', '27', '4', '0', '9', '3', '0.666666667', '150', '1', '0', '0.6', '0.666666667', '0', '0', '36.25', '11', '3', '1']
package org . apache . synapse . mediators . transform ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFactory ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . util . xpath . SynapseXPath ; import javax . xml . namespace . QName ; import java . util . Iterator ; import java . util . List ; public class HeaderMediator extends AbstractMediator { public static final int ACTION_SET = 0 ; public static final int ACTION_REMOVE = 1 ; private QName qName = null ; private String value = null ; private int action = ACTION_SET ; private SynapseXPath expression = null ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Header mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( action == ACTION_SET ) { String value = ( getExpression ( ) == null ? getValue ( ) : expression . stringValueOf ( synCtx ) ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Set SOAP header : " + qName + " to : " + value ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( SynapseConstants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( new EndpointReference ( value ) ) ; } else if ( SynapseConstants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( new EndpointReference ( value ) ) ; } else if ( SynapseConstants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( value ) ; } else if ( SynapseConstants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( new EndpointReference ( value ) ) ; } else if ( SynapseConstants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( new EndpointReference ( value ) ) ; } else if ( SynapseConstants . HEADER_RELATES_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setRelatesTo ( new RelatesTo [ ] { new RelatesTo ( value ) } ) ; } else { addCustomHeader ( synCtx , value ) ; } } else { addCustomHeader ( synCtx , value ) ; } } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Removing SOAP Header : " + qName ) ; } if ( qName . getNamespaceURI ( ) == null || "" . equals ( qName . getNamespaceURI ( ) ) ) { if ( SynapseConstants . HEADER_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setTo ( null ) ; } else if ( SynapseConstants . HEADER_FROM . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFrom ( null ) ; } else if ( SynapseConstants . HEADER_ACTION . equals ( qName . getLocalPart ( ) ) ) { synCtx . setWSAAction ( null ) ; } else if ( SynapseConstants . HEADER_FAULT . equals ( qName . getLocalPart ( ) ) ) { synCtx . setFaultTo ( null ) ; } else if ( SynapseConstants . HEADER_REPLY_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setReplyTo ( null ) ; } else if ( SynapseConstants . HEADER_RELATES_TO . equals ( qName . getLocalPart ( ) ) ) { synCtx . setRelatesTo ( null ) ; } else { SOAPEnvelope envelope = synCtx . getEnvelope ( ) ; if ( envelope != null ) { SOAPHeader header = envelope . getHeader ( ) ; if ( header != null ) { removeFromHeaderList ( header . getHeaderBlocksWithNSURI ( "" ) ) ; } } } } else { SOAPEnvelope envelope = synCtx . getEnvelope ( ) ; if ( envelope != null ) { SOAPHeader header = envelope . getHeader ( ) ; if ( header != null ) { removeFromHeaderList ( header . getHeaderBlocksWithNSURI ( qName . getNamespaceURI ( ) ) ) ; } } } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Header mediator" ) ; } return true ; } private void addCustomHeader ( MessageContext synCtx , String value ) { SOAPEnvelope env = synCtx . getEnvelope ( ) ; if ( env == null ) { return ; } SOAPFactory fac = ( SOAPFactory ) env . getOMFactory ( ) ; SOAPHeader header = env . getHeader ( ) ; if ( header == null ) { header = fac . createSOAPHeader ( env ) ; } SOAPHeaderBlock hb = header . addHeaderBlock ( qName . getLocalPart ( ) , fac . createOMNamespace ( qName . getNamespaceURI ( ) , qName . getPrefix ( ) ) ) ; hb . setText ( value ) ; } private void removeFromHeaderList ( List headersList ) { if ( headersList == null || headersList . isEmpty ( ) ) { return ; } for ( Iterator iter = headersList . iterator ( ) ; iter . hasNext ( ) ; ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock header = ( SOAPHeaderBlock ) o ; if ( header . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { header . detach ( ) ; } } else if ( o instanceof OMElement ) { OMElement omElem = ( OMElement ) o ; if ( omElem . getLocalName ( ) . equals ( qName . getLocalPart ( ) ) ) { omElem . detach ( ) ; } } } } public int getAction ( ) { return action ; } public void setAction ( int action ) { this . action = action ; } public QName getQName ( ) { return qName ; } public void setQName ( QName qName ) { this . qName = qName ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public SynapseXPath getExpression ( ) { return expression ; } public void setExpression ( SynapseXPath expression ) { this . expression = expression ; } } 	1	['12', '2', '0', '16', '51', '10', '2', '14', '10', '0.818181818', '435', '0.666666667', '1', '0.541666667', '0.238095238', '0', '0', '34.75', '27', '3.5833', '1']
package org . apache . synapse . config . xml ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseException ; import org . apache . synapse . Mediator ; import sun . misc . Service ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class MediatorSerializerFinder { private static final Log log = LogFactory . getLog ( MediatorSerializerFinder . class ) ; private static final Class [ ] mediatorSerializers = { SequenceMediatorSerializer . class , LogMediatorSerializer . class , SendMediatorSerializer . class , FilterMediatorSerializer . class , SynapseMediatorSerializer . class , DropMediatorSerializer . class , HeaderMediatorSerializer . class , FaultMediatorSerializer . class , PropertyMediatorSerializer . class , SwitchMediatorSerializer . class , InMediatorSerializer . class , OutMediatorSerializer . class , RMSequenceMediatorSerializer . class , ClassMediatorSerializer . class , ValidateMediatorSerializer . class , XSLTMediatorSerializer . class , POJOCommandMediatorSerializer . class , CloneMediatorSerializer . class , IterateMediatorSerializer . class , AggregateMediatorSerializer . class , DBLookupMediatorSerializer . class , DBReportMediatorSerializer . class , CacheMediatorSerializer . class , CalloutMediatorSerializer . class } ; private static MediatorSerializerFinder instance = null ; private static Map < String , MediatorSerializer > serializerMap = new HashMap < String , MediatorSerializer > ( ) ; public static synchronized MediatorSerializerFinder getInstance ( ) { if ( instance == null ) { instance = new MediatorSerializerFinder ( ) ; } return instance ; } public MediatorSerializer getSerializer ( Mediator mediator ) { return serializerMap . get ( mediator . getClass ( ) . getName ( ) ) ; } private MediatorSerializerFinder ( ) { serializerMap = new HashMap < String , MediatorSerializer > ( ) ; for ( Class c : mediatorSerializers ) { try { MediatorSerializer ser = ( MediatorSerializer ) c . newInstance ( ) ; serializerMap . put ( ser . getMediatorClassName ( ) , ser ) ; } catch ( Exception e ) { throw new SynapseException ( "Error instantiating " + c . getName ( ) , e ) ; } } registerExtensions ( ) ; } private void registerExtensions ( ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Registering mediator extensions found in the classpath.. " ) ; } Iterator it = Service . providers ( MediatorSerializer . class ) ; while ( it . hasNext ( ) ) { MediatorSerializer ms = ( MediatorSerializer ) it . next ( ) ; String name = ms . getMediatorClassName ( ) ; try { serializerMap . put ( name , ms . getClass ( ) . newInstance ( ) ) ; } catch ( InstantiationException e ) { handleException ( "Error instantiating mediator serializer : " + ms ) ; } catch ( IllegalAccessException e ) { handleException ( "Error instantiating mediator serializer : " + ms ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Added MediatorSerializer " + ms . getClass ( ) . getName ( ) + " to handle " + name ) ; } } } public Map < String , MediatorSerializer > getSerializerMap ( ) { return serializerMap ; } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } } 	1	['7', '1', '0', '9', '28', '0', '3', '6', '3', '0.541666667', '265', '1', '1', '0', '0.333333333', '0', '0', '36.28571429', '3', '1.1429', '2']
package org . apache . synapse . mediators . builtin ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . mediators . AbstractMediator ; public class DropMediator extends AbstractMediator { public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Drop mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } StatisticsUtils . processProxyServiceStatistics ( synCtx ) ; StatisticsUtils . processAllSequenceStatistics ( synCtx ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Drop mediator" ) ; } synCtx . setTo ( null ) ; return false ; } } 	1	['2', '2', '0', '11', '16', '1', '5', '6', '2', '2', '50', '0', '0', '0.928571429', '0.75', '0', '0', '24', '5', '2.5', '1']
package org . apache . synapse . mediators . base ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . statistics . StatisticsStack ; import org . apache . synapse . statistics . StatisticsUtils ; import org . apache . synapse . statistics . impl . SequenceStatisticsStack ; import org . apache . synapse . mediators . AbstractListMediator ; public class SynapseMediator extends AbstractListMediator { public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Mediation using '" + SynapseConstants . MAIN_SEQUENCE_KEY + "' sequence Message is a : " + ( synCtx . isResponse ( ) ? "response" : "request" ) ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } if ( synCtx . isResponse ( ) ) { StatisticsUtils . processAllSequenceStatistics ( synCtx ) ; } StatisticsStack sequenceStack = ( StatisticsStack ) synCtx . getProperty ( SynapseConstants . SEQUENCE_STATS ) ; if ( sequenceStack == null ) { sequenceStack = new SequenceStatisticsStack ( ) ; synCtx . setProperty ( SynapseConstants . SEQUENCE_STATS , sequenceStack ) ; } String seqName = "MainSequence" ; boolean isFault = synCtx . getEnvelope ( ) . getBody ( ) . hasFault ( ) ; sequenceStack . put ( seqName , System . currentTimeMillis ( ) , ! synCtx . isResponse ( ) , true , isFault ) ; boolean result = super . mediate ( synCtx ) ; if ( traceOrDebugOn ) { if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } traceOrDebug ( traceOn , "End : Mediation using '" + SynapseConstants . MAIN_SEQUENCE_KEY + "' sequence" ) ; } return result ; } } 	1	['2', '3', '0', '10', '23', '1', '2', '8', '2', '2', '114', '0', '0', '0.956521739', '0.75', '1', '2', '56', '11', '5.5', '1']
package org . apache . synapse . mediators . builtin ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . clustering . ClusteringFault ; import org . apache . axis2 . clustering . context . Replicator ; import org . apache . axis2 . context . ConfigurationContext ; import org . apache . axis2 . saaj . util . SAAJUtil ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseException ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . synapse . core . axis2 . Axis2Sender ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . base . SequenceMediator ; import org . apache . synapse . util . FixedByteArrayOutputStream ; import org . apache . synapse . util . MessageHelper ; import org . wso2 . caching . CacheManager ; import org . wso2 . caching . CachedObject ; import org . wso2 . caching . CachingConstants ; import org . wso2 . caching . CachingException ; import org . wso2 . caching . digest . DigestGenerator ; import javax . xml . soap . MessageFactory ; import javax . xml . soap . MimeHeaders ; import javax . xml . soap . SOAPException ; import javax . xml . soap . SOAPMessage ; import javax . xml . stream . XMLStreamException ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; public class CacheMediator extends AbstractMediator { private String id = null ; private String scope = CachingConstants . SCOPE_PER_HOST ; private boolean collector = false ; private DigestGenerator digestGenerator = CachingConstants . DEFAULT_XML_IDENTIFIER ; private int inMemoryCacheSize = CachingConstants . DEFAULT_CACHE_SIZE ; private int diskCacheSize = 0 ; private long timeout = 0L ; private SequenceMediator onCacheHitSequence = null ; private String onCacheHitRef = null ; private int maxMessageSize = 0 ; private String cacheManagerKey = CachingConstants . CACHE_MANAGER ; private static final String CACHE_MANAGER_PREFIX = "synapse.cache_manager_" ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Cache mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } FixedByteArrayOutputStream fbaos = null ; if ( maxMessageSize > 0 ) { fbaos = new FixedByteArrayOutputStream ( maxMessageSize ) ; try { MessageHelper . cloneSOAPEnvelope ( synCtx . getEnvelope ( ) ) . serialize ( fbaos ) ; } catch ( XMLStreamException e ) { handleException ( "Error in checking the message size" , e , synCtx ) ; } catch ( SynapseException syne ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Message size exceeds the upper bound for caching, " + "request will not be cached" ) ; return true ; } } } ConfigurationContext cfgCtx = ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) . getConfigurationContext ( ) ; if ( cfgCtx == null ) { handleException ( "Unable to perform caching, " + " ConfigurationContext cannot be found" , synCtx ) ; return false ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Looking up cache at scope : " + scope + " with ID : " + cacheManagerKey ) ; } Object prop = cfgCtx . getPropertyNonReplicable ( cacheManagerKey ) ; CacheManager cacheManager ; if ( prop != null && prop instanceof CacheManager ) { cacheManager = ( CacheManager ) prop ; } else { synchronized ( cfgCtx ) { prop = cfgCtx . getPropertyNonReplicable ( cacheManagerKey ) ; if ( prop != null && prop instanceof CacheManager ) { cacheManager = ( CacheManager ) prop ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Creating/recreating the cache object" ) ; } cacheManager = new CacheManager ( ) ; cfgCtx . setProperty ( cacheManagerKey , cacheManager ) ; } } } boolean result = true ; try { if ( synCtx . isResponse ( ) ) { processResponseMessage ( synCtx , cfgCtx , traceOrDebugOn , traceOn , cacheManager ) ; } else { result = processRequestMessage ( synCtx , cfgCtx , traceOrDebugOn , traceOn , cacheManager ) ; } } catch ( ClusteringFault clusteringFault ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Unable to replicate Cache mediator state among the cluster" ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Cache mediator" ) ; } return result ; } private void processResponseMessage ( MessageContext synCtx , ConfigurationContext cfgCtx , boolean traceOrDebugOn , boolean traceOn , CacheManager cacheManager ) throws ClusteringFault { if ( ! collector ) { handleException ( "Response messages cannot be handled in a non collector cache" , synCtx ) ; } String requestHash = ( String ) synCtx . getProperty ( CachingConstants . REQUEST_HASH ) ; if ( requestHash != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Storing the response message into the cache at scope : " + scope + " with ID : " + cacheManagerKey + " for request hash : " + requestHash ) ; } CachedObject cachedObj = cacheManager . getResponseForKey ( requestHash , cfgCtx ) ; if ( cachedObj != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Storing the response for the message with ID : " + synCtx . getMessageID ( ) + " with request hash ID : " + cachedObj . getRequestHash ( ) + " in the cache : " + cacheManagerKey ) ; } ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; try { MessageHelper . cloneSOAPEnvelope ( synCtx . getEnvelope ( ) ) . serialize ( outStream ) ; cachedObj . setResponseEnvelope ( outStream . toByteArray ( ) ) ; } catch ( XMLStreamException e ) { handleException ( "Unable to set the response to the Cache" , e , synCtx ) ; } if ( cachedObj . getTimeout ( ) > 0 ) { cachedObj . setExpireTimeMillis ( System . currentTimeMillis ( ) + cachedObj . getTimeout ( ) ) ; } cfgCtx . setProperty ( cacheManagerKey , cacheManager ) ; Replicator . replicate ( cfgCtx ) ; } else { auditWarn ( "A response message without a valid mapping to the " + "request hash found. Unable to store the response in cache" , synCtx ) ; } } else { auditWarn ( "A response message without a mapping to the " + "request hash found. Unable to store the response in cache" , synCtx ) ; } } private boolean processRequestMessage ( MessageContext synCtx , ConfigurationContext cfgCtx , boolean traceOrDebugOn , boolean traceOn , CacheManager cacheManager ) throws ClusteringFault { if ( collector ) { handleException ( "Request messages cannot be handled in a collector cache" , synCtx ) ; } String requestHash = null ; try { requestHash = digestGenerator . getDigest ( ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ) ; synCtx . setProperty ( CachingConstants . REQUEST_HASH , requestHash ) ; } catch ( CachingException e ) { handleException ( "Error in calculating the hash value of the request" , e , synCtx ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Generated request hash : " + requestHash ) ; } if ( cacheManager . containsKey ( requestHash ) && cacheManager . getResponseForKey ( requestHash , cfgCtx ) != null ) { CachedObject cachedObj = cacheManager . getResponseForKey ( requestHash , cfgCtx ) ; if ( ! cachedObj . isExpired ( ) && cachedObj . getResponseEnvelope ( ) != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Cache-hit for message ID : " + synCtx . getMessageID ( ) ) ; } synCtx . setResponse ( true ) ; try { MessageFactory mf = MessageFactory . newInstance ( ) ; SOAPMessage smsg = mf . createMessage ( new MimeHeaders ( ) , new ByteArrayInputStream ( cachedObj . getResponseEnvelope ( ) ) ) ; org . apache . axiom . soap . SOAPEnvelope omSOAPEnv = SAAJUtil . toOMSOAPEnvelope ( smsg . getSOAPPart ( ) . getDocumentElement ( ) ) ; synCtx . setEnvelope ( omSOAPEnv ) ; } catch ( AxisFault axisFault ) { handleException ( "Error setting response envelope from cache : " + cacheManagerKey , synCtx ) ; } catch ( IOException ioe ) { handleException ( "Error setting response envelope from cache : " + cacheManagerKey , ioe , synCtx ) ; } catch ( SOAPException soape ) { handleException ( "Error setting response envelope from cache : " + cacheManagerKey , soape , synCtx ) ; } if ( onCacheHitSequence != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Delegating message to the onCachingHit " + "Anonymous sequence" ) ; } onCacheHitSequence . mediate ( synCtx ) ; } else if ( onCacheHitRef != null ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Delegating message to the onCachingHit " + "sequence : " + onCacheHitRef ) ; } synCtx . getSequence ( onCacheHitRef ) . mediate ( synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Request message " + synCtx . getMessageID ( ) + " was served from the cache : " + cacheManagerKey ) ; } synCtx . setTo ( null ) ; Axis2Sender . sendBack ( synCtx ) ; } return false ; } else { cachedObj . expire ( ) ; cachedObj . setTimeout ( timeout ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Existing cached response has expired. Reset cache element" ) ; } cfgCtx . setProperty ( cacheManagerKey , cacheManager ) ; Replicator . replicate ( cfgCtx ) ; } } else { if ( cacheManager . getCacheKeys ( ) . size ( ) == inMemoryCacheSize ) { cacheManager . removeExpiredResponses ( cfgCtx ) ; if ( cacheManager . getCacheKeys ( ) . size ( ) == inMemoryCacheSize ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "In-memory cache is full. Unable to cache" ) ; } } else { storeRequestToCache ( cfgCtx , requestHash , cacheManager ) ; } } else { storeRequestToCache ( cfgCtx , requestHash , cacheManager ) ; } } return true ; } private void storeRequestToCache ( ConfigurationContext cfgCtx , String requestHash , CacheManager cacheManager ) throws ClusteringFault { CachedObject cachedObj = new CachedObject ( ) ; cachedObj . setRequestHash ( requestHash ) ; cachedObj . setTimeout ( timeout ) ; cacheManager . addResponseWithKey ( requestHash , cachedObj , cfgCtx ) ; cfgCtx . setProperty ( cacheManagerKey , cacheManager ) ; Replicator . replicate ( cfgCtx ) ; } public String getId ( ) { return id ; } public void setId ( String id ) { this . id = id ; } public String getScope ( ) { return scope ; } public void setScope ( String scope ) { this . scope = scope ; if ( CachingConstants . SCOPE_PER_MEDIATOR . equals ( scope ) ) { cacheManagerKey = CACHE_MANAGER_PREFIX + id ; } } public boolean isCollector ( ) { return collector ; } public void setCollector ( boolean collector ) { this . collector = collector ; } public DigestGenerator getDigestGenerator ( ) { return digestGenerator ; } public void setDigestGenerator ( DigestGenerator digestGenerator ) { this . digestGenerator = digestGenerator ; } public int getInMemoryCacheSize ( ) { return inMemoryCacheSize ; } public void setInMemoryCacheSize ( int inMemoryCacheSize ) { this . inMemoryCacheSize = inMemoryCacheSize ; } public int getDiskCacheSize ( ) { return diskCacheSize ; } public void setDiskCacheSize ( int diskCacheSize ) { this . diskCacheSize = diskCacheSize ; } public long getTimeout ( ) { return timeout / 1000 ; } public void setTimeout ( long timeout ) { this . timeout = timeout * 1000 ; } public SequenceMediator getOnCacheHitSequence ( ) { return onCacheHitSequence ; } public void setOnCacheHitSequence ( SequenceMediator onCacheHitSequence ) { this . onCacheHitSequence = onCacheHitSequence ; } public String getOnCacheHitRef ( ) { return onCacheHitRef ; } public void setOnCacheHitRef ( String onCacheHitRef ) { this . onCacheHitRef = onCacheHitRef ; } public int getMaxMessageSize ( ) { return maxMessageSize ; } public void setMaxMessageSize ( int maxMessageSize ) { this . maxMessageSize = maxMessageSize ; } } 	1	['25', '2', '0', '26', '87', '168', '2', '24', '22', '0.854166667', '753', '1', '1', '0.351351351', '0.188', '0', '0', '28.64', '16', '1.6', '2']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPFault ; import org . apache . axiom . soap . SOAPFaultReason ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . axis2 . client . Options ; import org . apache . axis2 . client . async . AxisCallback ; import org . apache . axis2 . context . MessageContext ; import org . apache . axis2 . engine . MessageReceiver ; import org . apache . axis2 . wsdl . WSDLConstants ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . ServerManager ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . transport . nhttp . NhttpConstants ; import org . apache . synapse . transport . nhttp . util . ResponseAcceptEncodingProcessor ; import java . util . * ; public class SynapseCallbackReceiver implements MessageReceiver { private static final Log log = LogFactory . getLog ( SynapseCallbackReceiver . class ) ; private Map < String , AxisCallback > callbackStore ; public SynapseCallbackReceiver ( SynapseConfiguration synCfg ) { callbackStore = Collections . synchronizedMap ( new HashMap < String , AxisCallback > ( ) ) ; ServerManager . getInstance ( ) . setCallbackStore ( callbackStore ) ; TimeoutHandler timeoutHandler = new TimeoutHandler ( callbackStore ) ; Timer timeOutTimer = synCfg . getSynapseTimer ( ) ; long timeoutHandlerInterval = ServerManager . getInstance ( ) . getTimeoutHandlerInterval ( ) ; timeOutTimer . schedule ( timeoutHandler , 0 , timeoutHandlerInterval ) ; } public void addCallback ( String MsgID , AxisCallback callback ) { callbackStore . put ( MsgID , callback ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Callback added. Total callbacks waiting for : " + callbackStore . size ( ) ) ; } } public void receive ( MessageContext messageCtx ) throws AxisFault { String messageID = null ; if ( messageCtx . getOptions ( ) != null && messageCtx . getOptions ( ) . getRelatesTo ( ) != null ) { Options options = messageCtx . getOptions ( ) ; if ( options != null ) { RelatesTo relatesTo = options . getRelatesTo ( ) ; if ( relatesTo != null ) { messageID = relatesTo . getValue ( ) ; } } } else if ( messageCtx . getProperty ( SynapseConstants . MERCURY_SEQUENCE_KEY ) == null ) { messageID = ( String ) messageCtx . getProperty ( SynapseConstants . RELATES_TO_FOR_POX ) ; } if ( messageID != null ) { AxisCallback callback = callbackStore . remove ( messageID ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Callback removed. Pending callbacks count : " + callbackStore . size ( ) ) ; } RelatesTo [ ] relates = messageCtx . getRelationships ( ) ; if ( relates != null && relates . length > 1 ) { removeDuplicateRelatesTo ( messageCtx , relates ) ; } if ( callback != null ) { handleMessage ( messageCtx , ( ( AsyncCallback ) callback ) . getSynapseOutMsgCtx ( ) ) ; } else { log . warn ( "Synapse received a response for the request with message Id : " + messageID + " But a callback is not registered (anymore) to process this response" ) ; } } else if ( ! messageCtx . isPropertyTrue ( NhttpConstants . SC_ACCEPTED ) ) { log . warn ( "Synapse received a response message without a message Id" ) ; } } private void handleMessage ( MessageContext response , org . apache . synapse . MessageContext synapseOutMsgCtx ) throws AxisFault { Object o = response . getProperty ( NhttpConstants . SENDING_FAULT ) ; if ( o != null && Boolean . TRUE . equals ( o ) ) { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) ) { SOAPEnvelope envelope = response . getEnvelope ( ) ; if ( envelope != null ) { SOAPFault fault = envelope . getBody ( ) . getFault ( ) ; if ( fault != null ) { Exception e = fault . getException ( ) ; if ( e == null ) { SOAPFaultReason reason = fault . getReason ( ) ; if ( reason != null ) { e = new Exception ( reason . getText ( ) ) ; } } synapseOutMsgCtx . setProperty ( SynapseConstants . ERROR_CODE , SynapseConstants . SENDING_FAULT ) ; SOAPFaultReason faultReason = fault . getReason ( ) ; if ( faultReason != null ) { synapseOutMsgCtx . setProperty ( SynapseConstants . ERROR_MESSAGE , faultReason . getText ( ) ) ; } if ( fault . getException ( ) != null ) { synapseOutMsgCtx . setProperty ( SynapseConstants . ERROR_EXCEPTION , fault . getException ( ) ) ; } ( ( FaultHandler ) faultStack . pop ( ) ) . handleFault ( synapseOutMsgCtx , e ) ; } } } } else { Stack faultStack = synapseOutMsgCtx . getFaultStack ( ) ; if ( faultStack != null && ! faultStack . isEmpty ( ) && faultStack . peek ( ) instanceof Endpoint ) { faultStack . pop ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Synapse received an asynchronous response message" ) ; log . debug ( "Received To: " + ( response . getTo ( ) != null ? response . getTo ( ) . getAddress ( ) : "null" ) ) ; log . debug ( "SOAPAction: " + ( response . getSoapAction ( ) != null ? response . getSoapAction ( ) : "null" ) ) ; log . debug ( "WSA-Action: " + ( response . getWSAAction ( ) != null ? response . getWSAAction ( ) : "null" ) ) ; String [ ] cids = response . getAttachmentMap ( ) . getAllContentIDs ( ) ; if ( cids != null && cids . length > 0 ) { for ( String cid : cids ) { log . debug ( "Attachment : " + cid ) ; } } log . debug ( "Body : \n" + response . getEnvelope ( ) ) ; } MessageContext axisOutMsgCtx = ( ( Axis2MessageContext ) synapseOutMsgCtx ) . getAxis2MessageContext ( ) ; ResponseAcceptEncodingProcessor . process ( response , axisOutMsgCtx ) ; response . setServiceContext ( null ) ; response . setOperationContext ( axisOutMsgCtx . getOperationContext ( ) ) ; response . setAxisMessage ( axisOutMsgCtx . getAxisOperation ( ) . getMessage ( WSDLConstants . MESSAGE_LABEL_OUT_VALUE ) ) ; response . setServerSide ( true ) ; response . setProperty ( SynapseConstants . ISRESPONSE_PROPERTY , Boolean . TRUE ) ; response . setProperty ( MessageContext . TRANSPORT_OUT , axisOutMsgCtx . getProperty ( MessageContext . TRANSPORT_OUT ) ) ; response . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; response . setTransportIn ( axisOutMsgCtx . getTransportIn ( ) ) ; response . setTransportOut ( axisOutMsgCtx . getTransportOut ( ) ) ; response . setDoingREST ( axisOutMsgCtx . isDoingREST ( ) ) ; if ( axisOutMsgCtx . isDoingMTOM ( ) ) { response . setDoingMTOM ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , org . apache . axis2 . Constants . VALUE_TRUE ) ; } if ( axisOutMsgCtx . isDoingSwA ( ) ) { response . setDoingSwA ( true ) ; response . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , org . apache . axis2 . Constants . VALUE_TRUE ) ; } response . setProperty ( org . apache . axis2 . Constants . Configuration . MESSAGE_TYPE , axisOutMsgCtx . getProperty ( org . apache . axis2 . Constants . Configuration . MESSAGE_TYPE ) ) ; if ( axisOutMsgCtx . isSOAP11 ( ) != response . isSOAP11 ( ) ) { if ( axisOutMsgCtx . isSOAP11 ( ) ) { SOAPUtils . convertSOAP12toSOAP11 ( response ) ; } else { SOAPUtils . convertSOAP11toSOAP12 ( response ) ; } } if ( axisOutMsgCtx . getMessageID ( ) != null ) { response . setRelationships ( new RelatesTo [ ] { new RelatesTo ( axisOutMsgCtx . getMessageID ( ) ) } ) ; } response . setReplyTo ( axisOutMsgCtx . getReplyTo ( ) ) ; response . setFaultTo ( axisOutMsgCtx . getFaultTo ( ) ) ; if ( axisOutMsgCtx . isPropertyTrue ( NhttpConstants . IGNORE_SC_ACCEPTED ) ) { response . setProperty ( NhttpConstants . FORCE_SC_ACCEPTED , Constants . VALUE_TRUE ) ; } Axis2MessageContext synapseInMessageContext = new Axis2MessageContext ( response , synapseOutMsgCtx . getConfiguration ( ) , synapseOutMsgCtx . getEnvironment ( ) ) ; synapseInMessageContext . setResponse ( true ) ; synapseInMessageContext . setTo ( new EndpointReference ( AddressingConstants . Final . WSA_ANONYMOUS_URL ) ) ; synapseInMessageContext . setTracingState ( synapseOutMsgCtx . getTracingState ( ) ) ; for ( Object key : synapseOutMsgCtx . getPropertyKeySet ( ) ) { synapseInMessageContext . setProperty ( ( String ) key , synapseOutMsgCtx . getProperty ( ( String ) key ) ) ; } try { synapseOutMsgCtx . getEnvironment ( ) . injectMessage ( synapseInMessageContext ) ; } catch ( SynapseException syne ) { Stack stack = synapseInMessageContext . getFaultStack ( ) ; if ( stack != null && ! stack . isEmpty ( ) ) { ( ( FaultHandler ) stack . pop ( ) ) . handleFault ( synapseInMessageContext , syne ) ; } else { log . error ( "Synapse encountered an exception, " + "No error handlers found - [Message Dropped]\n" + syne . getMessage ( ) ) ; } } } } private void removeDuplicateRelatesTo ( MessageContext mc , RelatesTo [ ] relates ) { int insertPos = 0 ; RelatesTo [ ] newRelates = new RelatesTo [ relates . length ] ; for ( RelatesTo current : relates ) { boolean found = false ; for ( int j = 0 ; j < newRelates . length && j < insertPos ; j ++ ) { if ( newRelates [ j ] . equals ( current ) || newRelates [ j ] . getValue ( ) . equals ( current . getValue ( ) ) ) { found = true ; break ; } } if ( ! found ) { newRelates [ insertPos ++ ] = current ; } } RelatesTo [ ] trimmedRelates = new RelatesTo [ insertPos ] ; System . arraycopy ( newRelates , 0 , trimmedRelates , 0 , insertPos ) ; mc . setRelationships ( trimmedRelates ) ; } } 	1	['6', '1', '0', '34', '105', '0', '2', '32', '3', '0.5', '620', '1', '0', '0', '0.371428571', '0', '0', '102', '7', '1.8333', '1']
package org . apache . synapse . util ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . eip . EIPConstants ; import org . apache . synapse . core . axis2 . Axis2MessageContext ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAP11Constants ; import org . apache . axiom . attachments . Attachments ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMNamespace ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMNode ; import org . apache . axis2 . addressing . AddressingConstants ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Map ; import java . util . HashMap ; public class MessageHelper { public static MessageContext cloneMessageContext ( MessageContext synCtx ) throws AxisFault { MessageContext newCtx = synCtx . getEnvironment ( ) . createMessageContext ( ) ; Axis2MessageContext axis2MC = ( Axis2MessageContext ) newCtx ; axis2MC . setAxis2MessageContext ( cloneAxis2MessageContext ( ( ( Axis2MessageContext ) synCtx ) . getAxis2MessageContext ( ) ) ) ; newCtx . setConfiguration ( synCtx . getConfiguration ( ) ) ; newCtx . setEnvironment ( synCtx . getEnvironment ( ) ) ; newCtx . setContextEntries ( synCtx . getContextEntries ( ) ) ; newCtx . setProperty ( EIPConstants . AGGREGATE_CORRELATION , synCtx . getMessageID ( ) ) ; newCtx . setTo ( synCtx . getTo ( ) ) ; newCtx . setReplyTo ( synCtx . getReplyTo ( ) ) ; newCtx . setSoapAction ( synCtx . getSoapAction ( ) ) ; newCtx . setWSAAction ( synCtx . getWSAAction ( ) ) ; newCtx . setResponse ( synCtx . isResponse ( ) ) ; for ( Object o : synCtx . getPropertyKeySet ( ) ) { if ( o instanceof String ) { newCtx . setProperty ( ( String ) o , synCtx . getProperty ( ( String ) o ) ) ; } } return newCtx ; } public static org . apache . axis2 . context . MessageContext cloneAxis2MessageContext ( org . apache . axis2 . context . MessageContext mc ) throws AxisFault { org . apache . axis2 . context . MessageContext newMC = clonePartially ( mc ) ; newMC . setEnvelope ( cloneSOAPEnvelope ( mc . getEnvelope ( ) ) ) ; newMC . setServiceContext ( mc . getServiceContext ( ) ) ; newMC . setOperationContext ( mc . getOperationContext ( ) ) ; newMC . setAxisMessage ( mc . getAxisMessage ( ) ) ; if ( newMC . getAxisMessage ( ) != null ) { newMC . getAxisMessage ( ) . setParent ( mc . getAxisOperation ( ) ) ; } newMC . setAxisService ( mc . getAxisService ( ) ) ; newMC . setTransportIn ( mc . getTransportIn ( ) ) ; newMC . setTransportOut ( mc . getTransportOut ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO , mc . getProperty ( org . apache . axis2 . Constants . OUT_TRANSPORT_INFO ) ) ; newMC . setProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS , getClonedTransportHeaders ( mc ) ) ; return newMC ; } public static Map getClonedTransportHeaders ( org . apache . axis2 . context . MessageContext msgCtx ) { Map headers = ( Map ) msgCtx . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; Map clonedHeaders = new HashMap ( ) ; if ( headers != null && headers . isEmpty ( ) ) { for ( Object o : headers . keySet ( ) ) { String headerName = ( String ) o ; clonedHeaders . put ( headerName , headers . get ( headerName ) ) ; } } return clonedHeaders ; } public static org . apache . axis2 . context . MessageContext clonePartially ( org . apache . axis2 . context . MessageContext ori ) throws AxisFault { org . apache . axis2 . context . MessageContext newMC = new org . apache . axis2 . context . MessageContext ( ) ; newMC . setConfigurationContext ( ori . getConfigurationContext ( ) ) ; newMC . setMessageID ( UUIDGenerator . getUUID ( ) ) ; newMC . setTo ( ori . getTo ( ) ) ; newMC . setSoapAction ( ori . getSoapAction ( ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING , ori . getProperty ( org . apache . axis2 . Constants . Configuration . CHARACTER_SET_ENCODING ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_MTOM ) ) ; newMC . setProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA , ori . getProperty ( org . apache . axis2 . Constants . Configuration . ENABLE_SWA ) ) ; newMC . setProperty ( Constants . Configuration . HTTP_METHOD , ori . getProperty ( Constants . Configuration . HTTP_METHOD ) ) ; newMC . setProperty ( Constants . Configuration . MESSAGE_TYPE , ori . getProperty ( Constants . Configuration . MESSAGE_TYPE ) ) ; newMC . setDoingREST ( ori . isDoingREST ( ) ) ; newMC . setDoingMTOM ( ori . isDoingMTOM ( ) ) ; newMC . setDoingSwA ( ori . isDoingSwA ( ) ) ; Attachments attachments = ori . getAttachmentMap ( ) ; if ( attachments != null && attachments . getAllContentIDs ( ) . length > 0 ) { String [ ] cIDs = attachments . getAllContentIDs ( ) ; String soapPart = attachments . getSOAPPartContentID ( ) ; for ( String cID : cIDs ) { if ( ! cID . equals ( soapPart ) ) { newMC . addAttachment ( cID , attachments . getDataHandler ( cID ) ) ; } } } for ( Object o : ori . getOptions ( ) . getProperties ( ) . keySet ( ) ) { String key = ( String ) o ; newMC . getOptions ( ) . setProperty ( key , ori . getOptions ( ) . getProperty ( key ) ) ; } Iterator itr = ori . getPropertyNames ( ) ; while ( itr . hasNext ( ) ) { String key = ( String ) itr . next ( ) ; if ( key != null ) { newMC . setNonReplicableProperty ( key , ori . getPropertyNonReplicable ( key ) ) ; } } newMC . setServerSide ( false ) ; return newMC ; } public static SOAPEnvelope cloneSOAPEnvelope ( SOAPEnvelope envelope ) { SOAPEnvelope newEnvelope ; if ( SOAP11Constants . SOAP_ENVELOPE_NAMESPACE_URI . equals ( envelope . getBody ( ) . getNamespace ( ) . getNamespaceURI ( ) ) ) { newEnvelope = OMAbstractFactory . getSOAP11Factory ( ) . getDefaultEnvelope ( ) ; } else { newEnvelope = OMAbstractFactory . getSOAP12Factory ( ) . getDefaultEnvelope ( ) ; } if ( envelope . getHeader ( ) != null ) { Iterator itr = envelope . getHeader ( ) . cloneOMElement ( ) . getChildren ( ) ; while ( itr . hasNext ( ) ) { newEnvelope . getHeader ( ) . addChild ( ( OMNode ) itr . next ( ) ) ; } } if ( envelope . getBody ( ) != null ) { Iterator itr = envelope . getBody ( ) . cloneOMElement ( ) . getChildren ( ) ; while ( itr . hasNext ( ) ) { newEnvelope . getBody ( ) . addChild ( ( OMNode ) itr . next ( ) ) ; } } return newEnvelope ; } public static SOAPEnvelope removeAddressingHeaders ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { SOAPEnvelope env = axisMsgCtx . getEnvelope ( ) ; SOAPHeader soapHeader = env . getHeader ( ) ; ArrayList addressingHeaders ; if ( soapHeader != null ) { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Submission . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } else { addressingHeaders = soapHeader . getHeaderBlocksWithNSURI ( AddressingConstants . Final . WSA_NAMESPACE ) ; if ( addressingHeaders != null && addressingHeaders . size ( ) != 0 ) { detachAddressingInformation ( addressingHeaders ) ; } } } return env ; } private static void detachAddressingInformation ( ArrayList headerInformation ) { for ( Object o : headerInformation ) { if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; headerBlock . detach ( ) ; } else if ( o instanceof OMElement ) { OMElement om = ( OMElement ) o ; OMNamespace ns = om . getNamespace ( ) ; if ( ns != null && ( AddressingConstants . Submission . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) || AddressingConstants . Final . WSA_NAMESPACE . equals ( ns . getNamespaceURI ( ) ) ) ) { om . detach ( ) ; } } } } } 	1	['8', '1', '0', '33', '105', '28', '5', '28', '7', '2', '455', '0', '0', '0', '0.2', '0', '0', '55.875', '6', '2.875', '3']
package org . apache . synapse . config . xml . endpoints . utils ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . om . OMAttribute ; import org . apache . synapse . endpoints . algorithms . LoadbalanceAlgorithm ; import org . apache . synapse . endpoints . algorithms . RoundRobin ; import org . apache . synapse . config . xml . XMLConfigConstants ; import javax . xml . namespace . QName ; import java . util . ArrayList ; public class LoadbalanceAlgorithmFactory { public static LoadbalanceAlgorithm createLoadbalanceAlgorithm ( OMElement loadbalanceElement , ArrayList endpoints ) { LoadbalanceAlgorithm algorithm = null ; String algorithmName = "roundRobin" ; OMAttribute algoAttribute = loadbalanceElement . getAttribute ( new QName ( null , XMLConfigConstants . ALGORITHM_NAME ) ) ; if ( algoAttribute != null ) { algorithmName = algoAttribute . getAttributeValue ( ) ; } if ( algorithmName . equalsIgnoreCase ( "roundRobin" ) ) { algorithm = new RoundRobin ( endpoints ) ; } return algorithm ; } } 	1	['2', '1', '0', '6', '8', '1', '2', '4', '2', '2', '33', '0', '0', '0', '0.5', '0', '0', '15.5', '3', '1.5', '3']
package org . apache . synapse . config . xml ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . MessageContext ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class SwitchCase { private static final Log log = LogFactory . getLog ( SwitchCase . class ) ; private Pattern regex = null ; private AnonymousListMediator caseMediator ; public boolean mediate ( MessageContext synCtx ) { return caseMediator != null ? caseMediator . mediate ( synCtx ) : true ; } public AnonymousListMediator getCaseMediator ( ) { return caseMediator ; } public void setCaseMediator ( AnonymousListMediator caseMediator ) { this . caseMediator = caseMediator ; } public Pattern getRegex ( ) { return regex ; } public void setRegex ( Pattern regex ) { this . regex = regex ; } public boolean matches ( String value ) { if ( value == null ) { log . warn ( "Provided character sequence for switch case condition is 'null'." + " Switch case will not be executed." ) ; return false ; } Matcher matcher = regex . matcher ( value ) ; if ( matcher == null ) { log . warn ( "Matcher for the provided character sequence and the pattern ' " + regex + " '" + " cannot be found. Switch case will not be executed." ) ; return false ; } return matcher . matches ( ) ; } } 	1	['8', '1', '0', '7', '18', '8', '3', '4', '7', '0.714285714', '79', '1', '1', '0', '0.314285714', '0', '0', '8.5', '3', '1.125', '1']
package org . apache . synapse . core . axis2 ; import org . apache . axiom . om . OMElement ; import org . apache . axiom . soap . SOAPBody ; import org . apache . axiom . soap . SOAPEnvelope ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axis2 . AxisFault ; import org . apache . axis2 . Constants ; import org . apache . axis2 . addressing . EndpointReference ; import org . apache . axis2 . addressing . RelatesTo ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . FaultHandler ; import org . apache . synapse . Mediator ; import org . apache . synapse . MessageContext ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . config . Entry ; import org . apache . synapse . config . SynapseConfiguration ; import org . apache . synapse . core . SynapseEnvironment ; import org . apache . synapse . endpoints . Endpoint ; import org . apache . synapse . mediators . MediatorFaultHandler ; import java . util . * ; public class Axis2MessageContext implements MessageContext { private SynapseConfiguration synCfg = null ; private SynapseEnvironment synEnv = null ; private Map < String , Object > properties = new HashMap < String , Object > ( ) ; private Map < String , Object > localEntries = new HashMap < String , Object > ( ) ; private Stack < FaultHandler > faultStack = new Stack < FaultHandler > ( ) ; private org . apache . axis2 . context . MessageContext axis2MessageContext = null ; private boolean response = false ; private boolean faultResponse = false ; private int tracingState = SynapseConstants . TRACING_UNSET ; private Log serviceLog = null ; public SynapseConfiguration getConfiguration ( ) { return synCfg ; } public void setConfiguration ( SynapseConfiguration synCfg ) { this . synCfg = synCfg ; } public SynapseEnvironment getEnvironment ( ) { return synEnv ; } public void setEnvironment ( SynapseEnvironment synEnv ) { this . synEnv = synEnv ; } public Map getContextEntries ( ) { return localEntries ; } public void setContextEntries ( Map < String , Object > entries ) { this . localEntries = entries ; } public Mediator getMainSequence ( ) { Object o = localEntries . get ( SynapseConstants . MAIN_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator main = getConfiguration ( ) . getMainSequence ( ) ; localEntries . put ( SynapseConstants . MAIN_SEQUENCE_KEY , main ) ; return main ; } } public Mediator getFaultSequence ( ) { Object o = localEntries . get ( SynapseConstants . FAULT_SEQUENCE_KEY ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator fault = getConfiguration ( ) . getFaultSequence ( ) ; localEntries . put ( SynapseConstants . FAULT_SEQUENCE_KEY , fault ) ; return fault ; } } public Mediator getSequence ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Mediator ) { return ( Mediator ) o ; } else { Mediator m = getConfiguration ( ) . getSequence ( key ) ; localEntries . put ( key , m ) ; return m ; } } public Endpoint getEndpoint ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Endpoint ) { return ( Endpoint ) o ; } else { Endpoint e = getConfiguration ( ) . getEndpoint ( key ) ; localEntries . put ( key , e ) ; return e ; } } public Object getEntry ( String key ) { Object o = localEntries . get ( key ) ; if ( o != null && o instanceof Entry ) { return ( ( Entry ) o ) . getValue ( ) ; } else { Object e = getConfiguration ( ) . getEntry ( key ) ; if ( e != null ) { localEntries . put ( key , e ) ; return e ; } else { getConfiguration ( ) . getEntryDefinition ( key ) ; return getConfiguration ( ) . getEntry ( key ) ; } } } public Object getProperty ( String key ) { return properties . get ( key ) ; } public void setProperty ( String key , Object value ) { properties . put ( key , value ) ; if ( SynapseConstants . RESPONSE . equals ( key ) && getAxis2MessageContext ( ) . getOperationContext ( ) != null ) { getAxis2MessageContext ( ) . getOperationContext ( ) . setProperty ( org . apache . axis2 . Constants . RESPONSE_WRITTEN , "SKIP" ) ; } } public Set getPropertyKeySet ( ) { return properties . keySet ( ) ; } public Axis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx , SynapseConfiguration synCfg , SynapseEnvironment synEnv ) { setAxis2MessageContext ( axisMsgCtx ) ; this . synCfg = synCfg ; this . synEnv = synEnv ; this . pushFaultHandler ( new MediatorFaultHandler ( synCfg . getFaultSequence ( ) ) ) ; } public EndpointReference getFaultTo ( ) { return axis2MessageContext . getFaultTo ( ) ; } public void setFaultTo ( EndpointReference reference ) { axis2MessageContext . setFaultTo ( reference ) ; } public EndpointReference getFrom ( ) { return axis2MessageContext . getFrom ( ) ; } public void setFrom ( EndpointReference reference ) { axis2MessageContext . setFrom ( reference ) ; } public SOAPEnvelope getEnvelope ( ) { return axis2MessageContext . getEnvelope ( ) ; } public void setEnvelope ( SOAPEnvelope envelope ) throws AxisFault { axis2MessageContext . setEnvelope ( envelope ) ; } public String getMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public void setMessageID ( String string ) { axis2MessageContext . setMessageID ( string ) ; } public RelatesTo getRelatesTo ( ) { return axis2MessageContext . getRelatesTo ( ) ; } public void setRelatesTo ( RelatesTo [ ] reference ) { axis2MessageContext . setRelationships ( reference ) ; } public EndpointReference getReplyTo ( ) { return axis2MessageContext . getReplyTo ( ) ; } public void setReplyTo ( EndpointReference reference ) { axis2MessageContext . setReplyTo ( reference ) ; } public EndpointReference getTo ( ) { return axis2MessageContext . getTo ( ) ; } public void setTo ( EndpointReference reference ) { axis2MessageContext . setTo ( reference ) ; } public void setWSAAction ( String actionURI ) { axis2MessageContext . setWSAAction ( actionURI ) ; } public String getWSAAction ( ) { return axis2MessageContext . getWSAAction ( ) ; } public void setWSAMessageID ( String messageID ) { axis2MessageContext . setWSAMessageId ( messageID ) ; } public String getWSAMessageID ( ) { return axis2MessageContext . getMessageID ( ) ; } public String getSoapAction ( ) { return axis2MessageContext . getSoapAction ( ) ; } public void setSoapAction ( String string ) { axis2MessageContext . setSoapAction ( string ) ; } public boolean isDoingMTOM ( ) { return axis2MessageContext . isDoingMTOM ( ) ; } public boolean isDoingSWA ( ) { return axis2MessageContext . isDoingSwA ( ) ; } public void setDoingMTOM ( boolean b ) { axis2MessageContext . setDoingMTOM ( b ) ; } public void setDoingSWA ( boolean b ) { axis2MessageContext . setDoingSwA ( b ) ; } public boolean isDoingPOX ( ) { return axis2MessageContext . isDoingREST ( ) ; } public void setDoingPOX ( boolean b ) { axis2MessageContext . setDoingREST ( b ) ; } public boolean isDoingGET ( ) { return Constants . Configuration . HTTP_METHOD_GET . equals ( axis2MessageContext . getProperty ( Constants . Configuration . HTTP_METHOD ) ) && axis2MessageContext . isDoingREST ( ) ; } public void setDoingGET ( boolean b ) { if ( b ) { axis2MessageContext . setDoingREST ( b ) ; axis2MessageContext . setProperty ( Constants . Configuration . HTTP_METHOD , Constants . Configuration . HTTP_METHOD_GET ) ; } else { axis2MessageContext . removeProperty ( Constants . Configuration . HTTP_METHOD ) ; } } public boolean isSOAP11 ( ) { return axis2MessageContext . isSOAP11 ( ) ; } public void setResponse ( boolean b ) { response = b ; axis2MessageContext . setProperty ( SynapseConstants . ISRESPONSE_PROPERTY , b ) ; } public boolean isResponse ( ) { Object o = properties . get ( SynapseConstants . RESPONSE ) ; return o != null && o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) || response ; } public void setFaultResponse ( boolean b ) { this . faultResponse = b ; } public boolean isFaultResponse ( ) { return this . faultResponse ; } public int getTracingState ( ) { return tracingState ; } public void setTracingState ( int tracingState ) { this . tracingState = tracingState ; } public Stack getFaultStack ( ) { return this . faultStack ; } public void pushFaultHandler ( FaultHandler fault ) { this . faultStack . push ( fault ) ; } public Log getServiceLog ( ) { if ( serviceLog != null ) { return serviceLog ; } else { String serviceName = ( String ) getProperty ( SynapseConstants . PROXY_SERVICE ) ; if ( serviceName != null && synCfg . getProxyService ( serviceName ) != null ) { serviceLog = LogFactory . getLog ( SynapseConstants . SERVICE_LOGGER_PREFIX + serviceName ) ; return serviceLog ; } else { serviceLog = LogFactory . getLog ( SynapseConstants . SERVICE_LOGGER_PREFIX . substring ( 0 , SynapseConstants . SERVICE_LOGGER_PREFIX . length ( ) - 1 ) ) ; return serviceLog ; } } } public void setServiceLog ( Log serviceLog ) { this . serviceLog = serviceLog ; } public org . apache . axis2 . context . MessageContext getAxis2MessageContext ( ) { return axis2MessageContext ; } public void setAxis2MessageContext ( org . apache . axis2 . context . MessageContext axisMsgCtx ) { this . axis2MessageContext = axisMsgCtx ; Boolean resp = ( Boolean ) axisMsgCtx . getProperty ( SynapseConstants . ISRESPONSE_PROPERTY ) ; if ( resp != null ) { response = resp ; } } public void setPaused ( boolean value ) { axis2MessageContext . setPaused ( value ) ; } public boolean isPaused ( ) { return axis2MessageContext . isPaused ( ) ; } public boolean isServerSide ( ) { return axis2MessageContext . isServerSide ( ) ; } public void setServerSide ( boolean value ) { axis2MessageContext . setServerSide ( value ) ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; String separator = "\n" ; if ( getTo ( ) != null ) { sb . append ( "To : " ) . append ( getTo ( ) . getAddress ( ) ) ; } else { sb . append ( "To : " ) ; } if ( getFrom ( ) != null ) { sb . append ( separator ) . append ( "From : " ) . append ( getFrom ( ) . getAddress ( ) ) ; } if ( getWSAAction ( ) != null ) { sb . append ( separator ) . append ( "WSAction : " ) . append ( getWSAAction ( ) ) ; } if ( getSoapAction ( ) != null ) { sb . append ( separator ) . append ( "SOAPAction : " ) . append ( getSoapAction ( ) ) ; } if ( getReplyTo ( ) != null ) { sb . append ( separator ) . append ( "ReplyTo : " ) . append ( getReplyTo ( ) . getAddress ( ) ) ; } if ( getMessageID ( ) != null ) { sb . append ( separator ) . append ( "MessageID : " ) . append ( getMessageID ( ) ) ; } SOAPHeader soapHeader = getEnvelope ( ) . getHeader ( ) ; if ( soapHeader != null ) { sb . append ( separator ) . append ( "Headers : " ) ; for ( Iterator iter = soapHeader . examineAllHeaderBlocks ( ) ; iter . hasNext ( ) ; ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlock = ( SOAPHeaderBlock ) o ; sb . append ( separator ) . append ( "\t" ) . append ( headerBlock . getLocalName ( ) ) . append ( " : " ) . append ( headerBlock . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator ) . append ( "\t" ) . append ( headerElem . getLocalName ( ) ) . append ( " : " ) . append ( headerElem . getText ( ) ) ; } } } SOAPBody soapBody = getEnvelope ( ) . getBody ( ) ; if ( soapBody != null ) { sb . append ( separator ) . append ( "Body : " ) . append ( soapBody . toString ( ) ) ; } return sb . toString ( ) ; } } 	1	['61', '1', '0', '46', '136', '378', '25', '21', '61', '0.881666667', '776', '1', '2', '0', '0.111241218', '0', '0', '11.55737705', '11', '1.541', '1']
package org . apache . synapse . mediators . builtin ; import org . apache . axiom . soap . SOAPHeaderBlock ; import org . apache . axiom . soap . SOAPHeader ; import org . apache . axiom . om . OMElement ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractMediator ; import org . apache . synapse . mediators . MediatorProperty ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class LogMediator extends AbstractMediator { public static final int CUSTOM = 0 ; public static final int SIMPLE = 1 ; public static final int HEADERS = 2 ; public static final int FULL = 3 ; public static final String DEFAULT_SEP = ", " ; private int logLevel = SIMPLE ; private String separator = DEFAULT_SEP ; private List properties = new ArrayList ( ) ; public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Log mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } String logMessage = getLogMessage ( synCtx ) ; synCtx . getServiceLog ( ) . info ( logMessage ) ; if ( log . isInfoEnabled ( ) ) { log . info ( logMessage ) ; } if ( traceOn ) { trace . info ( "Log message : " + logMessage ) ; } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Log mediator" ) ; } return true ; } private String getLogMessage ( MessageContext synCtx ) { switch ( logLevel ) { case CUSTOM : return getCustomLogMessage ( synCtx ) ; case SIMPLE : return getSimpleLogMessage ( synCtx ) ; case HEADERS : return getHeadersLogMessage ( synCtx ) ; case FULL : return getFullLogMessage ( synCtx ) ; default : return "Invalid log level specified" ; } } private String getCustomLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getSimpleLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; if ( synCtx . getTo ( ) != null ) sb . append ( "To: " + synCtx . getTo ( ) . getAddress ( ) ) ; else sb . append ( "To: " ) ; if ( synCtx . getFrom ( ) != null ) sb . append ( separator + "From: " + synCtx . getFrom ( ) . getAddress ( ) ) ; if ( synCtx . getWSAAction ( ) != null ) sb . append ( separator + "WSAction: " + synCtx . getWSAAction ( ) ) ; if ( synCtx . getSoapAction ( ) != null ) sb . append ( separator + "SOAPAction: " + synCtx . getSoapAction ( ) ) ; if ( synCtx . getReplyTo ( ) != null ) sb . append ( separator + "ReplyTo: " + synCtx . getReplyTo ( ) . getAddress ( ) ) ; if ( synCtx . getMessageID ( ) != null ) sb . append ( separator + "MessageID: " + synCtx . getMessageID ( ) ) ; sb . append ( separator + "Direction: " + ( synCtx . isResponse ( ) ? "response" : "request" ) ) ; setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getHeadersLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; if ( synCtx . getEnvelope ( ) != null ) { SOAPHeader header = synCtx . getEnvelope ( ) . getHeader ( ) ; if ( header != null ) { for ( Iterator iter = header . examineAllHeaderBlocks ( ) ; iter . hasNext ( ) ; ) { Object o = iter . next ( ) ; if ( o instanceof SOAPHeaderBlock ) { SOAPHeaderBlock headerBlk = ( SOAPHeaderBlock ) o ; sb . append ( separator + headerBlk . getLocalName ( ) + " : " + headerBlk . getText ( ) ) ; } else if ( o instanceof OMElement ) { OMElement headerElem = ( OMElement ) o ; sb . append ( separator + headerElem . getLocalName ( ) + " : " + headerElem . getText ( ) ) ; } } } } setCustomProperties ( sb , synCtx ) ; return trimLeadingSeparator ( sb ) ; } private String getFullLogMessage ( MessageContext synCtx ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( getSimpleLogMessage ( synCtx ) ) ; if ( synCtx . getEnvelope ( ) != null ) sb . append ( separator + "Envelope: " + synCtx . getEnvelope ( ) ) ; return trimLeadingSeparator ( sb ) ; } private void setCustomProperties ( StringBuffer sb , MessageContext synCtx ) { if ( properties != null && ! properties . isEmpty ( ) ) { for ( Iterator iter = properties . iterator ( ) ; iter . hasNext ( ) ; ) { MediatorProperty prop = ( MediatorProperty ) iter . next ( ) ; sb . append ( separator + prop . getName ( ) + " = " + ( prop . getValue ( ) != null ? prop . getValue ( ) : prop . getEvaluatedExpression ( synCtx ) ) ) ; } } } public int getLogLevel ( ) { return logLevel ; } public void setLogLevel ( int logLevel ) { this . logLevel = logLevel ; } public String getSeparator ( ) { return separator ; } public void setSeparator ( String separator ) { this . separator = separator ; } public void addProperty ( MediatorProperty p ) { properties . add ( p ) ; } public void addAllProperties ( List list ) { properties . addAll ( list ) ; } public List getProperties ( ) { return properties ; } private String trimLeadingSeparator ( StringBuffer sb ) { String retStr = sb . toString ( ) ; if ( retStr . startsWith ( separator ) ) { return retStr . substring ( separator . length ( ) ) ; } else { return retStr ; } } } 	1	['16', '2', '0', '13', '60', '34', '4', '9', '9', '0.866666667', '483', '0.375', '0', '0.464285714', '0.258928571', '0', '0', '28.6875', '8', '2.4375', '1']
package org . apache . synapse ; import org . apache . axiom . om . OMAbstractFactory ; import org . apache . axiom . om . OMNamespace ; import javax . xml . namespace . QName ; public final class SynapseConstants { public static final String SYNAPSE_NAMESPACE = "http://ws.apache.org/ns/synapse" ; public static final OMNamespace SYNAPSE_OMNAMESPACE = OMAbstractFactory . getOMFactory ( ) . createOMNamespace ( SYNAPSE_NAMESPACE , "syn" ) ; public static final String MAIN_SEQUENCE_KEY = "main" ; public static final String FAULT_SEQUENCE_KEY = "fault" ; public static final String MANDATORY_SEQUENCE_KEY = "pre-mediate" ; public static final String SYNAPSE_SERVICE_NAME = "__SynapseService" ; public static final QName SYNAPSE_OPERATION_NAME = new QName ( "mediate" ) ; public static final String MERCURY_MODULE_NAME = "Mercury" ; public static final String ADDRESSING_MODULE_NAME = "addressing" ; public static final String RAMPART_MODULE_NAME = "rampart" ; public static final String HEADER_TO = "To" ; public static final String HEADER_FROM = "From" ; public static final String HEADER_FAULT = "FaultTo" ; public static final String HEADER_ACTION = "Action" ; public static final String HEADER_REPLY_TO = "ReplyTo" ; public static final String HEADER_RELATES_TO = "RelatesTo" ; public static final String HEADER_MESSAGE_ID = "MessageID" ; public static final String PROPERTY_MESSAGE_FORMAT = "MESSAGE_FORMAT" ; public static final String PROPERTY_OPERATION_NAME = "OperationName" ; public static final String PROPERTY_OPERATION_NAMESPACE = "OperationNamespace" ; public static final String SYSTEM_TIME = "SYSTEM_TIME" ; public static final String SYSTEM_DATE = "SYSTEM_DATE" ; public static final String ADDRESSING_VERSION_FINAL = "final" ; public static final String ADDRESSING_VERSION_SUBMISSION = "submission" ; public static final String RAMPART_POLICY = "rampartPolicy" ; public static final String SANDESHA_POLICY = "sandeshaPolicy" ; public static final String SYNAPSE_CONFIG = "synapse.config" ; public static final String SYNAPSE_ENV = "synapse.env" ; public static final String SYNAPSE_HOME = "synapse.home" ; public static final String SYNAPSE_XML = "synapse.xml" ; public static final String SYNAPSE_PROPERTIES = "synapse.properties" ; public static final String CONF_DIRECTORY = "conf" ; public static final String PROXY_SERVICE = "proxy.name" ; public static final String RESPONSE = "RESPONSE" ; public static final String OUT_ONLY = "OUT_ONLY" ; public static final String ERROR_CODE = "ERROR_CODE" ; public static final String ERROR_MESSAGE = "ERROR_MESSAGE" ; public static final String ERROR_DETAIL = "ERROR_DETAIL" ; public static final String ERROR_EXCEPTION = "ERROR_EXCEPTION" ; public static final String MERCURY_LAST_MESSAGE = "MercuryLastMessage" ; public static final String MERCURY_SEQUENCE_KEY = "MercurySequenceKey" ; public static final String MERCURY_SPEC_VERSION = "MercuryRMSpecVersion" ; public static final String RELATES_TO_FOR_POX = "synapse.RelatesToForPox" ; public static final String ISRESPONSE_PROPERTY = "synapse.isresponse" ; public static final String TRACE_LOGGER = "TRACE_LOGGER" ; public static final String SERVICE_LOGGER_PREFIX = "SERVICE_LOGGER." ; public static final int TRACING_OFF = 0 ; public static final int TRACING_ON = 1 ; public static final int TRACING_UNSET = 2 ; public static final int STATISTICS_OFF = 0 ; public static final int STATISTICS_ON = 1 ; public static final int STATISTICS_UNSET = 2 ; public static final String SEQUENCE_STATS = "synapse.sequence.stats" ; public static final String PROXY_STATS = "synapse.proxy.stats" ; public static final String SERVICE_STATS = "synapse.service.stats" ; public static final String ENDPOINT_STATS = "synapse.endpoint.stats" ; public static final int SEQUENCE_STATISTICS = 0 ; public static final int PROXYSERVICE_STATISTICS = 1 ; public static final int ENDPOINT_STATISTICS = 2 ; public static final String TIMEOUT_HANDLER_INTERVAL = "synapse.timeout_handler_interval" ; public static final long DEFAULT_TIMEOUT_HANDLER_INTERVAL = 15000 ; public static final String GLOBAL_TIMEOUT_INTERVAL = "synapse.global_timeout_interval" ; public static final long DEFAULT_GLOBAL_TIMEOUT = 24 * 60 * 60 * 1000 ; public static final int NONE = 100 ; public static final int DISCARD = 101 ; public static final int DISCARD_AND_FAULT = 102 ; public static final String TIME_OUT = "504" ; public static final String SENDING_FAULT = "503" ; public static final String PROCESSED_ENDPOINT = "processed_endpoint" ; public static final String ANONYMOUS_ENDPOINT = "AnonymousEndpoint" ; public static final String ANONYMOUS_SEQUENCE = "AnonymousSequence" ; public static final String FORMAT_POX = "pox" ; public static final String FORMAT_GET = "get" ; public static final String FORMAT_SOAP11 = "soap11" ; public static final String FORMAT_SOAP12 = "soap12" ; public static final String SERVER_NAME = "serverName" ; public static final String SYNAPSE_DATASOURCES = "synapse.datasources" ; public static final String RESOLVE_ROOT = "resolve.root" ; public static final int DEFAULT_READTIMEOUT = 100000 ; public static final int DEFAULT_CONNECTTIMEOUT = 20000 ; public static final String READTIMEOUT = "synapse.connection.read_timeout" ; public static final String CONNECTTIMEOUT = "synapse.connection.connect_timeout" ; public static final int DEFAULT_THRESHOLD_CHUNKS = 8 ; public static final int DEFAULT_CHUNK_SIZE = 1024 ; public static final String DEFAULT_TEMPFILE_PREFIX = "tmp_" ; public static final String DEFAULT_TEMPFILE_SUFIX = ".dat" ; public static final String THRESHOLD_CHUNKS = "synapse.temp_data.chunk.threshold" ; public static final String CHUNK_SIZE = "synapse.temp_data.chunk.size" ; public static final String TEMP_FILE_PREFIX = "synapse.tempfile.prefix" ; public static final String TEMP_FILE_SUFIX = "synapse.tempfile.sufix" ; } 	1	['2', '1', '0', '14', '6', '1', '11', '3', '1', '1.977777778', '106', '0', '0', '0', '1', '0', '0', '7', '0', '0', '4']
package org . apache . synapse . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . commons . pool . impl . GenericObjectPool ; import org . apache . commons . pool . impl . GenericKeyedObjectPool ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import javax . naming . * ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Properties ; import java . util . Hashtable ; import java . io . * ; public class DataSourceRegistrar { public static final Log log = LogFactory . getLog ( DataSourceRegistrar . class ) ; private static final String PROP_ICFACTORY = "icFactory" ; private static final String PROP_PROVIDER_URL = "providerUrl" ; private static final String PROP_PROVIDER_PORT = "providerPort" ; private static final String DOT_STRING = "." ; private static final String PROP_USER_NAME = "username" ; private static final String PROP_PASSWORD = "password" ; private static final String PROP_DRIVER_CLS_NAME = "driverClassName" ; private static final String PROP_DSNAME = "dsName" ; private static final String PROP_URL = "url" ; private static final String PROP_DRIVER = "driver" ; private static final String PROP_USER = "user" ; private static final String PROP_CPDSADAPTER = "cpdsadapter" ; private static final String PROP_JNDI_ENV = "jndiEnvironment" ; private static final String PROP_DEFAULTMAXACTIVE = "defaultMaxActive" ; private static final String PROP_DEFAULTMAXIDLE = "defaultMaxIdle" ; private static final String PROP_DEFAULTMAXWAIT = "defaultMaxWait" ; private static final String PROP_DATA_SOURCE_NAME = "dataSourceName" ; private final static String PROP_DEFAULTAUTOCOMMIT = "defaultAutoCommit" ; private final static String PROP_DEFAULTREADONLY = "defaultReadOnly" ; private final static String PROP_TESTONBORROW = "testOnBorrow" ; private final static String PROP_TESTONRETURN = "testOnReturn" ; private final static String PROP_TIMEBETWEENEVICTIONRUNSMILLIS = "timeBetweenEvictionRunsMillis" ; private final static String PROP_NUMTESTSPEREVICTIONRUN = "numTestsPerEvictionRun" ; private final static String PROP_MINEVICTABLEIDLETIMEMILLIS = "minEvictableIdleTimeMillis" ; private final static String PROP_TESTWHILEIDLE = "testWhileIdle" ; private final static String PROP_VALIDATIONQUERY = "validationQuery" ; private final static String PROP_MAXACTIVE = "maxActive" ; private final static String PROP_MAXIDLE = "maxIdle" ; private final static String PROP_MAXWAIT = "maxWait" ; private final static String PROP_MINIDLE = "minIdle" ; private final static String PROP_INITIALSIZE = "initialSize" ; private final static String PROP_DEFAULTTRANSACTIONISOLATION = "defaultTransactionIsolation" ; private final static String PROP_DEFAULTCATALOG = "defaultCatalog" ; private final static String PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED = "accessToUnderlyingConnectionAllowed" ; private final static String PROP_REMOVEABANDONED = "removeAbandoned" ; private final static String PROP_REMOVEABANDONEDTIMEOUT = "removeAbandonedTimeout" ; private final static String PROP_LOGABANDONED = "logAbandoned" ; private final static String PROP_POOLPREPAREDSTATEMENTS = "poolPreparedStatements" ; private final static String PROP_MAXOPENPREPAREDSTATEMENTS = "maxOpenPreparedStatements" ; private final static String PROP_CONNECTIONPROPERTIES = "connectionProperties" ; public static void registerDataSources ( Properties dsProperties ) { if ( dsProperties == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DataSource properties cannot be found.." ) ; } return ; } String dataSources = getProperty ( dsProperties , SynapseConstants . SYNAPSE_DATASOURCES , null ) ; if ( dataSources == null || "" . equals ( dataSources ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "No DataSources defined for initialization.." ) ; } return ; } String [ ] dataSourcesNames = dataSources . split ( "," ) ; if ( dataSourcesNames == null || dataSourcesNames . length == 0 ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "No DataSource definitions found for initialization.." ) ; } return ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( SynapseConstants . SYNAPSE_DATASOURCES ) ; buffer . append ( DOT_STRING ) ; String rootPrefix = buffer . toString ( ) ; Hashtable props = new Hashtable ( ) ; Properties jndiEvn = new Properties ( ) ; String namingFactory = getProperty ( dsProperties , rootPrefix + PROP_ICFACTORY , "com.sun.jndi.rmi.registry.RegistryContextFactory" ) ; props . put ( Context . INITIAL_CONTEXT_FACTORY , namingFactory ) ; jndiEvn . put ( Context . INITIAL_CONTEXT_FACTORY , namingFactory ) ; String providerHost = "localhost" ; try { InetAddress addr = InetAddress . getLocalHost ( ) ; if ( addr != null ) { String hostname = addr . getHostName ( ) ; if ( hostname == null ) { String ipAddr = addr . getHostAddress ( ) ; if ( ipAddr != null ) { providerHost = ipAddr ; } } else { providerHost = hostname ; } } } catch ( UnknownHostException e ) { log . warn ( "Unable to determine hostname or IP address.. Using localhost" , e ) ; } int port = 2199 ; String providerPort = getProperty ( dsProperties , rootPrefix + PROP_PROVIDER_PORT , String . valueOf ( port ) ) ; try { port = Integer . parseInt ( providerPort ) ; } catch ( NumberFormatException ignored ) { } RMIRegistryController . getInstance ( ) . createLocalRegistry ( port ) ; String providerUrl = getProperty ( dsProperties , rootPrefix + PROP_PROVIDER_URL , "rmi://" + providerHost + ":" + providerPort ) ; props . put ( Context . PROVIDER_URL , providerUrl ) ; jndiEvn . put ( Context . PROVIDER_URL , providerUrl ) ; log . info ( "DataSources will be registered in the JNDI context with provider PROP_URL : " + providerUrl ) ; try { InitialContext initialContext = new InitialContext ( props ) ; for ( int i = 0 ; i < dataSourcesNames . length ; i ++ ) { registerDataSource ( dataSourcesNames [ i ] , dsProperties , initialContext , jndiEvn ) ; } } catch ( NamingException e ) { String msg = "Error constructing an InitialContext to register DataSources" ; handleException ( msg , e ) ; } } private static void registerDataSource ( String dsName , Properties dsProperties , InitialContext initialContext , Properties jndiEnv ) { if ( dsName == null || "" . equals ( dsName ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "DataSource name is either empty or null, ignoring.." ) ; } return ; } StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( SynapseConstants . SYNAPSE_DATASOURCES ) ; buffer . append ( DOT_STRING ) ; buffer . append ( dsName ) ; buffer . append ( DOT_STRING ) ; String prefix = buffer . toString ( ) ; String driver = getProperty ( dsProperties , prefix + PROP_DRIVER_CLS_NAME , null ) ; if ( driver == null ) { handleException ( prefix + PROP_DRIVER_CLS_NAME + " cannot be found." ) ; } String url = getProperty ( dsProperties , prefix + PROP_URL , null ) ; if ( url == null ) { handleException ( prefix + PROP_URL + " cannot be found." ) ; } String user = getProperty ( dsProperties , prefix + PROP_USER_NAME , "synapse" ) ; String password = getProperty ( dsProperties , prefix + PROP_PASSWORD , "synapse" ) ; String dataSourceName = getProperty ( dsProperties , prefix + PROP_DSNAME , dsName ) ; populateContextTree ( initialContext , dataSourceName ) ; String dsType = getProperty ( dsProperties , prefix + "type" , "BasicDataSource" ) ; String maxActive = getProperty ( dsProperties , prefix + PROP_MAXACTIVE , String . valueOf ( GenericObjectPool . DEFAULT_MAX_ACTIVE ) ) ; String maxIdle = getProperty ( dsProperties , prefix + PROP_MAXIDLE , String . valueOf ( GenericObjectPool . DEFAULT_MAX_IDLE ) ) ; String maxWait = getProperty ( dsProperties , prefix + PROP_MAXWAIT , String . valueOf ( GenericObjectPool . DEFAULT_MAX_WAIT ) ) ; if ( "BasicDataSource" . equals ( dsType ) ) { Reference ref = new Reference ( "javax.sql.DataSource" , "org.apache.commons.dbcp.BasicDataSourceFactory" , null ) ; ref . add ( new StringRefAddr ( PROP_DRIVER_CLS_NAME , driver ) ) ; ref . add ( new StringRefAddr ( PROP_URL , url ) ) ; ref . add ( new StringRefAddr ( PROP_USER_NAME , user ) ) ; ref . add ( new StringRefAddr ( PROP_PASSWORD , password ) ) ; ref . add ( new StringRefAddr ( PROP_MAXACTIVE , maxActive ) ) ; ref . add ( new StringRefAddr ( PROP_MAXIDLE , maxIdle ) ) ; ref . add ( new StringRefAddr ( PROP_MAXWAIT , maxWait ) ) ; setBasicDataSourceParameters ( ref , dsProperties , prefix ) ; setCommonParameters ( ref , dsProperties , prefix ) ; try { initialContext . rebind ( dataSourceName , ref ) ; } catch ( NamingException e ) { String msg = " Error binding name ' " + dataSourceName + " ' to " + "the DataSource(BasicDataSource) reference" ; handleException ( msg , e ) ; } } else if ( "PerUserPoolDataSource" . equals ( dsType ) ) { String className = getProperty ( dsProperties , prefix + PROP_CPDSADAPTER + DOT_STRING + "className" , "org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS" ) ; String factory = getProperty ( dsProperties , prefix + PROP_CPDSADAPTER + DOT_STRING + "factory" , "org.apache.commons.dbcp.cpdsadapter.DriverAdapterCPDS" ) ; String name = getProperty ( dsProperties , prefix + PROP_CPDSADAPTER + DOT_STRING + "name" , "cpds" ) ; Reference cpdsRef = new Reference ( className , factory , null ) ; cpdsRef . add ( new StringRefAddr ( PROP_DRIVER , driver ) ) ; cpdsRef . add ( new StringRefAddr ( PROP_URL , url ) ) ; cpdsRef . add ( new StringRefAddr ( PROP_USER , user ) ) ; cpdsRef . add ( new StringRefAddr ( PROP_PASSWORD , password ) ) ; try { initialContext . rebind ( name , cpdsRef ) ; } catch ( NamingException e ) { String msg = "Error binding name '" + name + "' to " + "the DriverAdapterCPDS reference" ; handleException ( msg , e ) ; } Reference ref = new Reference ( "org.apache.commons.dbcp.datasources.PerUserPoolDataSource" , "org.apache.commons.dbcp.datasources.PerUserPoolDataSourceFactory" , null ) ; ref . add ( new BinaryRefAddr ( PROP_JNDI_ENV , serialize ( jndiEnv ) ) ) ; ref . add ( new StringRefAddr ( PROP_DATA_SOURCE_NAME , name ) ) ; ref . add ( new StringRefAddr ( PROP_DEFAULTMAXACTIVE , maxActive ) ) ; ref . add ( new StringRefAddr ( PROP_DEFAULTMAXIDLE , maxIdle ) ) ; ref . add ( new StringRefAddr ( PROP_DEFAULTMAXWAIT , maxWait ) ) ; setCommonParameters ( ref , dsProperties , prefix ) ; try { initialContext . rebind ( dataSourceName , ref ) ; } catch ( NamingException e ) { String msg = "Error binding name ' " + dataSourceName + " ' to " + "the PerUserPoolDataSource reference" ; handleException ( msg , e ) ; } } else { handleException ( "Unsupported data source type : " + dsType ) ; } } private static byte [ ] serialize ( Object data ) { ObjectOutputStream outputStream = null ; ByteArrayOutputStream binOut = null ; byte [ ] result = null ; try { binOut = new ByteArrayOutputStream ( ) ; outputStream = new ObjectOutputStream ( binOut ) ; outputStream . writeObject ( data ) ; result = binOut . toByteArray ( ) ; } catch ( IOException e ) { handleException ( "Error serializing object :" + data ) ; } finally { if ( binOut != null ) { try { binOut . close ( ) ; } catch ( IOException ex ) { } } if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException ex ) { } } } return result ; } private static void setCommonParameters ( Reference reference , Properties properties , String prefix ) { String defaultAutoCommit = getProperty ( properties , prefix + PROP_DEFAULTAUTOCOMMIT , String . valueOf ( true ) ) ; String defaultReadOnly = getProperty ( properties , prefix + PROP_DEFAULTREADONLY , String . valueOf ( false ) ) ; String testOnBorrow = getProperty ( properties , prefix + PROP_TESTONBORROW , String . valueOf ( true ) ) ; String testOnReturn = getProperty ( properties , prefix + PROP_TESTONRETURN , String . valueOf ( false ) ) ; String timeBetweenEvictionRunsMillis = getProperty ( properties , prefix + PROP_TIMEBETWEENEVICTIONRUNSMILLIS , String . valueOf ( GenericObjectPool . DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS ) ) ; String numTestsPerEvictionRun = getProperty ( properties , prefix + PROP_NUMTESTSPEREVICTIONRUN , String . valueOf ( GenericObjectPool . DEFAULT_NUM_TESTS_PER_EVICTION_RUN ) ) ; String minEvictableIdleTimeMillis = getProperty ( properties , prefix + PROP_MINEVICTABLEIDLETIMEMILLIS , String . valueOf ( GenericObjectPool . DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS ) ) ; String testWhileIdle = getProperty ( properties , prefix + PROP_TESTWHILEIDLE , String . valueOf ( false ) ) ; String validationQuery = getProperty ( properties , prefix + PROP_VALIDATIONQUERY , null ) ; reference . add ( new StringRefAddr ( PROP_DEFAULTAUTOCOMMIT , defaultAutoCommit ) ) ; reference . add ( new StringRefAddr ( PROP_DEFAULTREADONLY , defaultReadOnly ) ) ; reference . add ( new StringRefAddr ( PROP_TESTONBORROW , testOnBorrow ) ) ; reference . add ( new StringRefAddr ( PROP_TESTONRETURN , testOnReturn ) ) ; reference . add ( new StringRefAddr ( PROP_TIMEBETWEENEVICTIONRUNSMILLIS , timeBetweenEvictionRunsMillis ) ) ; reference . add ( new StringRefAddr ( PROP_NUMTESTSPEREVICTIONRUN , numTestsPerEvictionRun ) ) ; reference . add ( new StringRefAddr ( PROP_MINEVICTABLEIDLETIMEMILLIS , minEvictableIdleTimeMillis ) ) ; reference . add ( new StringRefAddr ( PROP_TESTWHILEIDLE , testWhileIdle ) ) ; if ( validationQuery != null && ! "" . equals ( validationQuery ) ) { reference . add ( new StringRefAddr ( PROP_VALIDATIONQUERY , validationQuery ) ) ; } } private static void setBasicDataSourceParameters ( Reference reference , Properties properties , String prefix ) { String minIdle = getProperty ( properties , prefix + PROP_MINIDLE , String . valueOf ( GenericObjectPool . DEFAULT_MIN_IDLE ) ) ; String initialSize = getProperty ( properties , prefix + PROP_INITIALSIZE , String . valueOf ( 0 ) ) ; String defaultTransactionIsolation = getProperty ( properties , prefix + PROP_DEFAULTTRANSACTIONISOLATION , null ) ; String defaultCatalog = getProperty ( properties , prefix + PROP_DEFAULTCATALOG , null ) ; String accessToUnderlyingConnectionAllowed = getProperty ( properties , prefix + PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED , String . valueOf ( false ) ) ; String removeAbandoned = getProperty ( properties , prefix + PROP_REMOVEABANDONED , String . valueOf ( false ) ) ; String removeAbandonedTimeout = getProperty ( properties , prefix + PROP_REMOVEABANDONEDTIMEOUT , String . valueOf ( 300 ) ) ; String logAbandoned = getProperty ( properties , prefix + PROP_LOGABANDONED , String . valueOf ( false ) ) ; String poolPreparedStatements = getProperty ( properties , prefix + PROP_POOLPREPAREDSTATEMENTS , String . valueOf ( false ) ) ; String maxOpenPreparedStatements = getProperty ( properties , prefix + PROP_MAXOPENPREPAREDSTATEMENTS , String . valueOf ( GenericKeyedObjectPool . DEFAULT_MAX_TOTAL ) ) ; reference . add ( new StringRefAddr ( PROP_MINIDLE , minIdle ) ) ; if ( defaultTransactionIsolation != null && ! "" . equals ( defaultTransactionIsolation ) ) { reference . add ( new StringRefAddr ( PROP_DEFAULTTRANSACTIONISOLATION , defaultTransactionIsolation ) ) ; } reference . add ( new StringRefAddr ( PROP_ACCESSTOUNDERLYINGCONNECTIONALLOWED , accessToUnderlyingConnectionAllowed ) ) ; reference . add ( new StringRefAddr ( PROP_REMOVEABANDONED , removeAbandoned ) ) ; reference . add ( new StringRefAddr ( PROP_REMOVEABANDONEDTIMEOUT , removeAbandonedTimeout ) ) ; reference . add ( new StringRefAddr ( PROP_LOGABANDONED , logAbandoned ) ) ; reference . add ( new StringRefAddr ( PROP_POOLPREPAREDSTATEMENTS , poolPreparedStatements ) ) ; reference . add ( new StringRefAddr ( PROP_MAXOPENPREPAREDSTATEMENTS , maxOpenPreparedStatements ) ) ; reference . add ( new StringRefAddr ( PROP_INITIALSIZE , initialSize ) ) ; if ( defaultCatalog != null && ! "" . equals ( defaultCatalog ) ) { reference . add ( new StringRefAddr ( PROP_DEFAULTCATALOG , defaultCatalog ) ) ; } } private static void populateContextTree ( InitialContext initialContext , String path ) { String [ ] paths = path . split ( "/" ) ; if ( paths != null && paths . length > 1 ) { Context context = initialContext ; for ( int i = 0 ; i < paths . length ; i ++ ) { try { context = context . createSubcontext ( paths [ i ] ) ; if ( context == null ) { handleException ( "sub context " + paths [ i ] + " could not be created" ) ; } } catch ( NamingException e ) { handleException ( "Unable to create sub context : " + paths [ i ] , e ) ; } } } } private static void handleException ( String msg ) { log . error ( msg ) ; throw new SynapseException ( msg ) ; } private static void handleException ( String msg , Exception e ) { log . error ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static String getProperty ( Properties dsProperties , String name , String def ) { String result = dsProperties . getProperty ( name ) ; if ( ( result == null || result . length ( ) == 0 || "" . equals ( result ) ) && def != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "The name with ' " + name + " ' cannot be found. " + "Using default value " + def ) ; } result = def ; } if ( result != null ) { return result . trim ( ) ; } else { return def ; } } } 	1	['11', '1', '0', '5', '59', '25', '1', '4', '2', '1.075609756', '1312', '0.975609756', '0', '0', '0.271428571', '0', '0', '114.5454545', '10', '4.1818', '1']
package org . apache . synapse . config . xml ; import org . apache . axiom . om . OMAttribute ; import org . apache . axiom . om . OMElement ; import org . apache . synapse . Mediator ; import org . apache . synapse . SynapseException ; import org . apache . synapse . mediators . transform . FaultMediator ; import org . jaxen . JaxenException ; import javax . xml . namespace . QName ; import java . net . URI ; import java . net . URISyntaxException ; public class FaultMediatorFactory extends AbstractMediatorFactory { private static final QName FAULT_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "makefault" ) ; private static final QName ATT_VERSION_Q = new QName ( XMLConfigConstants . NULL_NAMESPACE , "version" ) ; private static final QName CODE_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "code" ) ; private static final QName REASON_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "reason" ) ; private static final QName NODE_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "node" ) ; private static final QName ROLE_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "role" ) ; private static final QName DETAIL_Q = new QName ( XMLConfigConstants . SYNAPSE_NAMESPACE , "detail" ) ; private static final String SOAP11 = "soap11" ; private static final String SOAP12 = "soap12" ; private static final String POX = "pox" ; public Mediator createMediator ( OMElement elem ) { FaultMediator faultMediator = new FaultMediator ( ) ; OMAttribute version = elem . getAttribute ( ATT_VERSION_Q ) ; if ( version != null ) { if ( SOAP11 . equals ( version . getAttributeValue ( ) ) ) { faultMediator . setSoapVersion ( FaultMediator . SOAP11 ) ; } else if ( SOAP12 . equals ( version . getAttributeValue ( ) ) ) { faultMediator . setSoapVersion ( FaultMediator . SOAP12 ) ; } else if ( POX . equals ( version . getAttributeValue ( ) ) ) { faultMediator . setSoapVersion ( FaultMediator . POX ) ; } else { handleException ( "Invalid SOAP version" ) ; } } OMElement code = elem . getFirstChildWithName ( CODE_Q ) ; if ( code != null ) { OMAttribute value = code . getAttribute ( ATT_VALUE ) ; OMAttribute expression = code . getAttribute ( ATT_EXPRN ) ; if ( value != null ) { String strValue = value . getAttributeValue ( ) ; String prefix = null ; String name = null ; if ( strValue . indexOf ( ":" ) != - 1 ) { prefix = strValue . substring ( 0 , strValue . indexOf ( ":" ) ) ; name = strValue . substring ( strValue . indexOf ( ":" ) + 1 ) ; } else { handleException ( "A QName is expected for fault code as prefix:name" ) ; } String namespaceURI = OMElementUtils . getNameSpaceWithPrefix ( prefix , code ) ; if ( namespaceURI == null ) { handleException ( "Invalid namespace prefix '" + prefix + "' in code attribute" ) ; } faultMediator . setFaultCodeValue ( new QName ( namespaceURI , name , prefix ) ) ; } else if ( expression != null ) { try { faultMediator . setFaultCodeExpr ( SynapseXPathFactory . getSynapseXPath ( code , ATT_EXPRN ) ) ; } catch ( JaxenException je ) { handleException ( "Invalid fault code expression : " + je . getMessage ( ) , je ) ; } } else { handleException ( "A 'value' or 'expression' attribute must specify the fault code" ) ; } } else if ( faultMediator . getSoapVersion ( ) != FaultMediator . POX ) { handleException ( "The fault code is a required attribute for the " + "makefault mediator unless it is a pox fault" ) ; } OMElement reason = elem . getFirstChildWithName ( REASON_Q ) ; if ( reason != null ) { OMAttribute value = reason . getAttribute ( ATT_VALUE ) ; OMAttribute expression = reason . getAttribute ( ATT_EXPRN ) ; if ( value != null ) { faultMediator . setFaultReasonValue ( value . getAttributeValue ( ) ) ; } else if ( expression != null ) { try { faultMediator . setFaultReasonExpr ( SynapseXPathFactory . getSynapseXPath ( reason , ATT_EXPRN ) ) ; } catch ( JaxenException je ) { handleException ( "Invalid fault reason expression : " + je . getMessage ( ) , je ) ; } } else { handleException ( "A 'value' or 'expression' attribute must specify the fault code" ) ; } } else if ( faultMediator . getSoapVersion ( ) != FaultMediator . POX ) { handleException ( "The fault reason is a required attribute for the " + "makefault mediator unless it is a pox fault" ) ; } processTraceState ( faultMediator , elem ) ; OMElement node = elem . getFirstChildWithName ( NODE_Q ) ; if ( node != null && node . getText ( ) != null ) { try { faultMediator . setFaultNode ( new URI ( node . getText ( ) ) ) ; } catch ( URISyntaxException e ) { handleException ( "Invalid URI specified for fault node : " + node . getText ( ) , e ) ; } } OMElement role = elem . getFirstChildWithName ( ROLE_Q ) ; if ( role != null && role . getText ( ) != null ) { try { faultMediator . setFaultRole ( new URI ( role . getText ( ) ) ) ; } catch ( URISyntaxException e ) { handleException ( "Invalid URI specified for fault role : " + role . getText ( ) , e ) ; } } OMElement detail = elem . getFirstChildWithName ( DETAIL_Q ) ; if ( detail != null ) { OMAttribute detailExpr = detail . getAttribute ( ATT_EXPRN ) ; if ( detailExpr != null && detailExpr . getAttributeValue ( ) != null ) { try { faultMediator . setFaultDetailExpr ( SynapseXPathFactory . getSynapseXPath ( detail , ATT_EXPRN ) ) ; } catch ( JaxenException e ) { handleException ( "Unable to build the XPath for fault detail " + "from the expression : " + detailExpr . getAttributeValue ( ) , e ) ; } } else if ( detail . getText ( ) != null ) { faultMediator . setFaultDetail ( detail . getText ( ) ) ; } } return faultMediator ; } public QName getTagQName ( ) { return FAULT_Q ; } } 	1	['4', '2', '0', '9', '36', '2', '0', '9', '3', '0.866666667', '371', '1', '0', '0.6', '0.666666667', '0', '0', '89.25', '23', '6', '2']
package org . apache . synapse . mediators . filters ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . MessageContext ; import org . apache . synapse . mediators . AbstractListMediator ; public class OutMediator extends AbstractListMediator implements org . apache . synapse . mediators . FilterMediator { public boolean mediate ( MessageContext synCtx ) { boolean traceOn = isTraceOn ( synCtx ) ; boolean traceOrDebugOn = isTraceOrDebugOn ( traceOn ) ; if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Start : Out mediator" ) ; if ( traceOn && trace . isTraceEnabled ( ) ) { trace . trace ( "Message : " + synCtx . getEnvelope ( ) ) ; } } boolean result = true ; if ( test ( synCtx ) ) { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Current message is outgoing - executing child mediators" ) ; } result = super . mediate ( synCtx ) ; } else { if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "Current message is a request - skipping child mediators" ) ; } } if ( traceOrDebugOn ) { traceOrDebug ( traceOn , "End : Out mediator" ) ; } return result ; } public boolean test ( MessageContext synCtx ) { return synCtx . isResponse ( ) ; } } 	1	['3', '3', '0', '7', '16', '3', '2', '5', '3', '2', '70', '0', '0', '0.916666667', '0.833333333', '1', '2', '22.33333333', '8', '3', '1']
package org . apache . synapse . config ; import org . apache . axiom . om . * ; import org . apache . axiom . om . impl . builder . StAXOMBuilder ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . apache . synapse . SynapseConstants ; import org . apache . synapse . SynapseException ; import org . apache . synapse . ServerManager ; import org . apache . synapse . util . SynapseBinaryDataSource ; import org . xml . sax . InputSource ; import javax . xml . stream . XMLInputFactory ; import javax . xml . stream . XMLStreamException ; import javax . xml . stream . XMLStreamReader ; import javax . xml . transform . stream . StreamSource ; import javax . activation . DataHandler ; import java . io . * ; import java . net . * ; public class SynapseConfigUtils { private static final Log log = LogFactory . getLog ( SynapseConfigUtils . class ) ; public static StreamSource getStreamSource ( Object o ) { if ( o == null ) { handleException ( "Cannot convert null to a StreamSource" ) ; } else if ( o instanceof OMElement ) { OMElement omElement = ( OMElement ) o ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { omElement . serialize ( baos ) ; return new StreamSource ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } } else if ( o instanceof OMText ) { DataHandler dataHandler = ( DataHandler ) ( ( OMText ) o ) . getDataHandler ( ) ; if ( dataHandler != null ) { try { return new StreamSource ( dataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { handleException ( "Error in reading content as a stream " ) ; } } } else { handleException ( "Cannot convert object to a StreamSource" ) ; } return null ; } public static InputStream getInputStream ( Object o ) { if ( o == null ) { handleException ( "Cannot convert null to a StreamSource" ) ; } else if ( o instanceof OMElement ) { OMElement omElement = ( OMElement ) o ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { omElement . serialize ( baos ) ; return new ByteArrayInputStream ( baos . toByteArray ( ) ) ; } catch ( XMLStreamException e ) { handleException ( "Error converting to a StreamSource" , e ) ; } } else if ( o instanceof OMText ) { DataHandler dataHandler = ( DataHandler ) ( ( OMText ) o ) . getDataHandler ( ) ; if ( dataHandler != null ) { try { return dataHandler . getInputStream ( ) ; } catch ( IOException e ) { handleException ( "Error in reading content as a stream " ) ; } } } else if ( o instanceof URI ) { try { return ( ( URI ) ( o ) ) . toURL ( ) . openStream ( ) ; } catch ( IOException e ) { handleException ( "Error opening stream form URI" , e ) ; } } else { handleException ( "Cannot convert object to a StreamSource" ) ; } return null ; } public static Object getObject ( URL url ) { try { if ( url != null && "file" . equals ( url . getProtocol ( ) ) ) { try { url . openStream ( ) ; } catch ( IOException ignored ) { String path = url . getPath ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Can not open a connection to the URL with a path :" + path ) ; } String synapseHome = ServerManager . getInstance ( ) . getSynapseHome ( ) ; if ( synapseHome != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Trying  to resolve an absolute path of the " + " URL using the synapse.home : " + synapseHome ) ; } if ( synapseHome . endsWith ( "/" ) ) { synapseHome = synapseHome . substring ( 0 , synapseHome . lastIndexOf ( "/" ) ) ; } url = new URL ( url . getProtocol ( ) + ":" + synapseHome + "/" + path ) ; try { url . openStream ( ) ; } catch ( IOException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Faild to resolve an absolute path of the " + " URL using the synapse.home : " + synapseHome ) ; } log . warn ( "IO Error reading from URL " + url . getPath ( ) + e ) ; } } } } if ( url == null ) { return null ; } URLConnection urlc = url . openConnection ( ) ; XMLToObjectMapper xmlToObject = getXmlToObjectMapper ( urlc . getContentType ( ) ) ; InputStream inputStream = urlc . getInputStream ( ) ; try { XMLStreamReader parser = XMLInputFactory . newInstance ( ) . createXMLStreamReader ( inputStream ) ; StAXOMBuilder builder = new StAXOMBuilder ( parser ) ; OMElement omElem = builder . getDocumentElement ( ) ; omElem . build ( ) ; if ( xmlToObject != null ) { return xmlToObject . getObjectFromOMNode ( omElem ) ; } else { return omElem ; } } catch ( XMLStreamException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Content at URL : " + url + " is non XML.." ) ; } return readNonXML ( url ) ; } catch ( OMException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Content at URL : " + url + " is non XML.." ) ; } return readNonXML ( url ) ; } finally { inputStream . close ( ) ; } } catch ( IOException e ) { handleException ( "Error connecting to URL : " + url , e ) ; } return null ; } public static OMNode readNonXML ( URL url ) { try { URLConnection newConnection = url . openConnection ( ) ; BufferedInputStream newInputStream = new BufferedInputStream ( newConnection . getInputStream ( ) ) ; OMFactory omFactory = OMAbstractFactory . getOMFactory ( ) ; return omFactory . createOMText ( new DataHandler ( new SynapseBinaryDataSource ( newInputStream , newConnection . getContentType ( ) ) ) , true ) ; } catch ( IOException e ) { handleException ( "Error when getting a stream from resource's content" , e ) ; } return null ; } public static OMNode getOMElementFromURL ( String urlStr ) throws IOException { URL url = getURLFromPath ( urlStr ) ; if ( url == null ) { return null ; } URLConnection conn = url . openConnection ( ) ; conn . setReadTimeout ( getReadTimeout ( ) ) ; conn . setConnectTimeout ( getConnectionTimeout ( ) ) ; conn . setRequestProperty ( "Connection" , "close" ) ; BufferedInputStream urlInStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; try { StAXOMBuilder builder = new StAXOMBuilder ( urlInStream ) ; OMElement doc = builder . getDocumentElement ( ) ; doc . build ( ) ; return doc ; } catch ( Exception e ) { if ( log . isDebugEnabled ( ) ) { log . info ( "Content at URL : " + url + " is non XML.." ) ; } Object content = readNonXML ( url ) ; if ( content instanceof OMNode ) { return ( OMNode ) content ; } } finally { try { urlInStream . close ( ) ; } catch ( IOException ignore ) { } } return null ; } public static InputSource getInputSourceFormURI ( URI uri ) { if ( uri == null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Can not create a URL from 'null' " ) ; } return null ; } try { URL url = uri . toURL ( ) ; String protocol = url . getProtocol ( ) ; String path = url . getPath ( ) ; if ( protocol == null || "" . equals ( protocol ) ) { url = new URL ( "file:" + path ) ; } URLConnection conn = url . openConnection ( ) ; conn . setReadTimeout ( getReadTimeout ( ) ) ; conn . setConnectTimeout ( getConnectionTimeout ( ) ) ; conn . setRequestProperty ( "Connection" , "close" ) ; BufferedInputStream urlInStream = new BufferedInputStream ( conn . getInputStream ( ) ) ; return new InputSource ( urlInStream ) ; } catch ( MalformedURLException e ) { handleException ( "Invalid URL ' " + uri + " '" , e ) ; } catch ( IOException e ) { handleException ( "Error reading at URI ' " + uri + " ' " , e ) ; } return null ; } private static int getReadTimeout ( ) { return ServerManager . getInstance ( ) . getReadTimeout ( ) ; } private static int getConnectionTimeout ( ) { return ServerManager . getInstance ( ) . getConnectTimeout ( ) ; } private static void handleException ( String msg , Exception e ) { log . warn ( msg , e ) ; throw new SynapseException ( msg , e ) ; } private static void handleException ( String msg ) { log . warn ( msg ) ; throw new SynapseException ( msg ) ; } public static XMLToObjectMapper getXmlToObjectMapper ( String contentType ) { return null ; } public static URL getURLFromPath ( String path ) { if ( path == null || "null" . equals ( path ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Can not create a URL from 'null' " ) ; } return null ; } URL url = null ; try { url = new URL ( path ) ; if ( "file" . equals ( url . getProtocol ( ) ) ) { try { url . openStream ( ) ; } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference : " + path , e ) ; } catch ( IOException ignored ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Can not open a connection to the URL with a path :" + path ) ; } String synapseHome = ServerManager . getInstance ( ) . getSynapseHome ( ) ; if ( synapseHome != null ) { if ( synapseHome . endsWith ( "/" ) ) { synapseHome = synapseHome . substring ( 0 , synapseHome . lastIndexOf ( "/" ) ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Trying  to resolve an absolute path of the " + " URL using the synapse.home : " + synapseHome ) ; } try { url = new URL ( url . getProtocol ( ) + ":" + synapseHome + "/" + url . getPath ( ) ) ; url . openStream ( ) ; } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference " + url . getPath ( ) + e ) ; } catch ( IOException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Faild to resolve an absolute path of the " + " URL using the synapse.home : " + synapseHome ) ; } log . warn ( "IO Error reading from URL : " + url . getPath ( ) + e ) ; } } } } } catch ( MalformedURLException e ) { handleException ( "Invalid URL reference :  " + path , e ) ; } catch ( IOException e ) { handleException ( "IO Error reading from URL : " + path , e ) ; } return url ; } public static String resolveRelativeURI ( String parentLocation , String relativeLocation ) { if ( relativeLocation == null ) { throw new IllegalArgumentException ( "Import URI cannot be null" ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Resolving import URI ' " + parentLocation + " '  against base URI ' " + relativeLocation + " '  " ) ; } URI importUri = null ; try { importUri = new URI ( relativeLocation ) ; if ( importUri . isAbsolute ( ) ) { return importUri . toString ( ) ; } } catch ( URISyntaxException e ) { handleException ( "Invalid URI : " + relativeLocation , e ) ; } if ( parentLocation == null ) { return importUri . toString ( ) ; } else { if ( relativeLocation . startsWith ( "/" ) || relativeLocation . startsWith ( "\\" ) ) { if ( importUri != null && ! importUri . isAbsolute ( ) ) { try { importUri = new URI ( "file:" + relativeLocation ) ; return importUri . toString ( ) ; } catch ( URISyntaxException e ) { handleException ( "Invalid URI ' " + importUri . getPath ( ) + " '" , e ) ; } } } else { int index = parentLocation . lastIndexOf ( "/" ) ; if ( index == - 1 ) { index = parentLocation . lastIndexOf ( "\\" ) ; } if ( index != - 1 ) { String basepath = parentLocation . substring ( 0 , index + 1 ) ; String resolvedPath = basepath + relativeLocation ; try { URI resolvedUri = new URI ( resolvedPath ) ; if ( ! resolvedUri . isAbsolute ( ) ) { resolvedUri = new URI ( "file:" + resolvedPath ) ; } return resolvedUri . toString ( ) ; } catch ( URISyntaxException e ) { handleException ( "Invalid URI ' " + resolvedPath + " '" , e ) ; } } else { return importUri . toString ( ) ; } } } return null ; } } 	1	['15', '1', '0', '23', '75', '49', '10', '13', '10', '0.285714286', '940', '1', '0', '0', '0.154761905', '0', '0', '61.6', '12', '3.4667', '2']
