package org . apache . tools . ant . input ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '3', '19', '0', '0', '3', '2', '0.75', '104', '0.5', '0', '0', '0.666666667', '0', '0', '33', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . filters . util ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public final class ChainReaderHelper { private static final int DEFAULT_BUFFER_SIZE = 8192 ; public Reader primaryReader ; public int bufferSize = DEFAULT_BUFFER_SIZE ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public final void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public final void setProject ( final Project project ) { this . project = project ; } public final Project getProject ( ) { return project ; } public final void setBufferSize ( int size ) { bufferSize = size ; } public final void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public final Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project project = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = project . createClassLoader ( classpath ) ; clazz = Class . forName ( className , true , al ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; boolean consPresent = false ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { consPresent = true ; break ; } } if ( ! consPresent ) { throw new BuildException ( className + " does not define a public constructor" + " that takes in a Reader as its " + "single argument." ) ; } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( rdr ) ; setProjectOnObject ( instream ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader ) { setProjectOnObject ( o ) ; instream = ( ( ChainableReader ) o ) . chain ( instream ) ; setProjectOnObject ( instream ) ; } } } return instream ; } private void setProjectOnObject ( Object obj ) { if ( project == null ) { return ; } if ( obj instanceof BaseFilterReader ) { ( ( BaseFilterReader ) obj ) . setProject ( project ) ; return ; } project . setProjectReference ( obj ) ; } public final String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	0	['10', '1', '0', '15', '39', '19', '4', '12', '8', '0.888888889', '344', '0.25', '1', '0', '0.228571429', '0', '0', '32.6', '3', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . JavaEnvUtils ; public class SignJar extends Task { protected File jar ; protected String alias ; private String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected File signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; private String maxMemory ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setMaxmemory ( String max ) { maxMemory = max ; } public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && filesets . size ( ) == 0 ) { throw new BuildException ( "jar must be set through jar attribute " + "or nested filesets" ) ; } if ( null != jar ) { if ( filesets . size ( ) != 0 ) { log ( "nested filesets will be ignored if the jar attribute has" + " been specified." , Project . MSG_WARN ) ; } doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( new File ( fs . getDir ( getProject ( ) ) , jarFiles [ j ] ) , null ) ; } } } } private void doOneJar ( File jarSource , File jarTarget ) throws BuildException { if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) { return ; } final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "jarsigner" ) ) ; if ( maxMemory != null ) { cmd . createArg ( ) . setValue ( "-J-Xmx" + maxMemory ) ; } if ( null != keystore ) { File keystoreFile = getProject ( ) . resolveFile ( keystore ) ; if ( keystoreFile . exists ( ) ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystoreFile . getPath ( ) ) ; } else { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget . toString ( ) ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource . toString ( ) ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + jarSource . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile ) { return false ; } if ( null != signedjarFile ) { if ( ! jarFile . exists ( ) ) { return false ; } if ( ! signedjarFile . exists ( ) ) { return false ; } if ( jarFile . equals ( signedjarFile ) ) { return false ; } if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) { return true ; } } else { if ( lazy ) { return isSigned ( jarFile ) ; } } return false ; } protected boolean isSigned ( File file ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['19', '3', '0', '10', '61', '135', '0', '10', '16', '0.888888889', '504', '1', '0', '0.672727273', '0.378947368', '1', '1', '24.78947368', '13', '1.9474', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '30', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.666666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private Vector filelists = new Vector ( ) ; private boolean relative = false ; private boolean parallel = false ; private boolean forwardSlash = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; private int maxParallel = - 1 ; private boolean addSourceFile = true ; private boolean verbose = false ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addDirset ( DirSet set ) { filesets . addElement ( set ) ; } public void addFilelist ( FileList list ) { filelists . addElement ( list ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setForwardslash ( boolean forwardSlash ) { this . forwardSlash = forwardSlash ; } public void setMaxParallel ( int max ) { maxParallel = max ; } public void setAddsourcefile ( boolean b ) { addSourceFile = b ; } public void setVerbose ( boolean b ) { verbose = b ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "srcfile elements." , getLocation ( ) ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "targetfile elements." , getLocation ( ) ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( getTaskName ( ) ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 && filelists . size ( ) == 0 ) { throw new BuildException ( "no filesets and no filelists specified" , getLocation ( ) ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , getLocation ( ) ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { int totalFiles = 0 ; int totalDirs = 0 ; boolean haveExecuted = false ; try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { String currentType = type ; AbstractFileSet fs = ( AbstractFileSet ) filesets . elementAt ( i ) ; if ( fs instanceof DirSet ) { if ( ! "dir" . equals ( type ) ) { log ( "Found a nested dirset but type is " + type + ". " + "Temporarily switching to type=\"dir\" on the" + " assumption that you really did mean" + " <dirset> not <fileset>." , Project . MSG_DEBUG ) ; currentType = "dir" ; } } File base = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; if ( ! "dir" . equals ( currentType ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalFiles ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( currentType ) ) { String [ ] s = getDirs ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalDirs ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } for ( int i = 0 ; i < filelists . size ( ) ; i ++ ) { FileList list = ( FileList ) filelists . elementAt ( i ) ; File base = list . getDir ( getProject ( ) ) ; String [ ] names = list . getFiles ( getProject ( ) ) ; for ( int j = 0 ; j < names . length ; j ++ ) { File f = new File ( base , names [ j ] ) ; if ( ( f . isFile ( ) && ! "dir" . equals ( type ) ) || ( f . isDirectory ( ) && ! "file" . equals ( type ) ) ) { if ( f . isFile ( ) ) { totalFiles ++ ; } else { totalDirs ++ ; } fileNames . addElement ( names [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping filelist for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { runParallel ( exe , fileNames , baseDirs ) ; haveExecuted = true ; } if ( haveExecuted ) { log ( "Applied " + cmdl . getExecutable ( ) + " to " + totalFiles + " file" + ( totalFiles != 1 ? "s" : "" ) + " and " + totalDirs + " director" + ( totalDirs != 1 ? "ies" : "y" ) + "." , verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { final char fileSeparator = File . separatorChar ; Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( forwardSlash && fileSeparator != '/' ) { name = name . replace ( fileSeparator , '/' ) ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; if ( ! addSourceFile ) { srcFiles = new String [ 0 ] ; } String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } if ( forwardSlash && fileSeparator != '/' ) { result [ srcIndex + i ] = result [ srcIndex + i ] . replace ( fileSeparator , '/' ) ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } protected void runParallel ( Execute exe , Vector fileNames , Vector baseDirs ) throws IOException , BuildException { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; if ( maxParallel <= 0 || s . length == 0 ) { String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } else { int stillToDo = fileNames . size ( ) ; int currentOffset = 0 ; while ( stillToDo > 0 ) { int currentAmount = Math . min ( stillToDo , maxParallel ) ; String [ ] cs = new String [ currentAmount ] ; System . arraycopy ( s , currentOffset , cs , 0 , currentAmount ) ; File [ ] cb = new File [ currentAmount ] ; System . arraycopy ( b , currentOffset , cb , 0 , currentAmount ) ; String [ ] command = getCommandline ( cs , cb ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( currentOffset > 0 ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; stillToDo -= currentAmount ; currentOffset += currentAmount ; } } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['23', '4', '2', '22', '77', '149', '2', '20', '16', '0.826704545', '1164', '1', '4', '0.777777778', '0.142857143', '3', '7', '48.91304348', '19', '2.3043', '0']
package org . apache . tools . bzip2 ; class CRC { public static int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; public CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } int globalCrc ; } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '1', '0.5', '1082', '0', '0', '0', '0.666666667', '0', '0', '153.2857143', '2', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public ExecuteWatchdog ( int timeout ) { this ( ( long ) timeout ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; watch = false ; process = null ; } public void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['9', '1', '0', '8', '23', '0', '5', '3', '8', '0.5', '148', '1', '1', '0', '0.288888889', '0', '0', '14.88888889', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['3', '6', '0', '7', '11', '3', '5', '3', '3', '2', '37', '0', '0', '0.96969697', '1', '2', '3', '11.33333333', '2', '1.3333', '0']
package org . apache . tools . ant . types ; import java . lang . reflect . Method ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; private Path catalogPath ; public static final String APACHE_RESOLVER = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver" ; public static final String CATALOG_RESOLVER = "org.apache.xml.resolver.tools.CatalogResolver" ; public XMLCatalog ( ) { setChecked ( false ) ; } private Vector getElements ( ) { return getRef ( ) . elements ; } private Path getClasspath ( ) { return getRef ( ) . classpath ; } private void setElements ( Vector aVector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements = aVector ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } setChecked ( false ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path createCatalogPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . catalogPath == null ) { this . catalogPath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . catalogPath . createPath ( ) ; } public void setCatalogPathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createCatalogPath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path getCatalogPath ( ) { return getRef ( ) . catalogPath ; } public void addDTD ( ResourceLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; setChecked ( false ) ; } public void addEntity ( ResourceLocation entity ) throws BuildException { addDTD ( entity ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration e = newElements . elements ( ) ; while ( e . hasMoreElements ( ) ) { ourElements . addElement ( e . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; Path nestedCatalogPath = catalog . getCatalogPath ( ) ; createCatalogPath ( ) . append ( nestedCatalogPath ) ; setChecked ( false ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( isReference ( ) ) { return getRef ( ) . resolveEntity ( publicId , systemId ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = getCatalogResolver ( ) . resolveEntity ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( isReference ( ) ) { return getRef ( ) . resolve ( href , base ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = ( SAXSource ) getCatalogResolver ( ) . resolve ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; URL baseURL = null ; try { if ( base == null ) { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } else { baseURL = new URL ( base ) ; } URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private XMLCatalog getRef ( ) { if ( ! isReference ( ) ) { return this ; } return ( XMLCatalog ) getCheckedRef ( XMLCatalog . class , "xmlcatalog" ) ; } private CatalogResolver catalogResolver = null ; private CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { AntClassLoader loader = null ; loader = getProject ( ) . createClassLoader ( Path . systemClasspath ) ; try { Class clazz = Class . forName ( APACHE_RESOLVER , true , loader ) ; ClassLoader apacheResolverLoader = clazz . getClassLoader ( ) ; Class baseResolverClass = Class . forName ( CATALOG_RESOLVER , true , apacheResolverLoader ) ; ClassLoader baseResolverLoader = baseResolverClass . getClassLoader ( ) ; clazz = Class . forName ( APACHE_RESOLVER , true , baseResolverLoader ) ; Object obj = clazz . newInstance ( ) ; catalogResolver = new ExternalResolver ( clazz , obj ) ; } catch ( Throwable ex ) { catalogResolver = new InternalResolver ( ) ; if ( getCatalogPath ( ) != null && getCatalogPath ( ) . list ( ) . length != 0 ) { log ( "Warning: catalogpath listing external catalogs" + " will be ignored" , Project . MSG_WARN ) ; } log ( "Failed to load Apache resolver: " + ex , Project . MSG_DEBUG ) ; } } return catalogResolver ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private ResourceLocation findMatchingEntry ( String publicId ) { Enumeration e = getElements ( ) . elements ( ) ; ResourceLocation element = null ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof ResourceLocation ) { element = ( ResourceLocation ) o ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } } return null ; } private String removeFragment ( String uri ) { String result = uri ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; } return result ; } private InputSource filesystemLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; uri = uri . replace ( File . separatorChar , '/' ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { File testFile = new File ( uri ) ; if ( testFile . exists ( ) && testFile . canRead ( ) ) { log ( "uri : '" + uri + "' matches a readable file" , Project . MSG_DEBUG ) ; try { url = fileUtils . getFileURL ( testFile ) ; } catch ( MalformedURLException ex1 ) { throw new BuildException ( "could not find an URL for :" + testFile . getAbsolutePath ( ) ) ; } } else { log ( "uri : '" + uri + "' does not match a readable file" , Project . MSG_DEBUG ) ; } } if ( url != null ) { String fileName = url . getFile ( ) ; if ( fileName != null ) { log ( "fileName " + fileName , Project . MSG_DEBUG ) ; File resFile = new File ( fileName ) ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; String sysid = JAXPUtils . getSystemId ( resFile ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( IOException ex ) { } } } } return source ; } private InputSource classpathLookup ( ResourceLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; Path cp = classpath ; if ( cp != null ) { cp = classpath . concatSystemClasspath ( "ignore" ) ; } else { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } loader = getProject ( ) . createClassLoader ( cp ) ; InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private interface CatalogResolver extends URIResolver , EntityResolver { InputSource resolveEntity ( String publicId , String systemId ) ; Source resolve ( String href , String base ) throws TransformerException ; } private class InternalResolver implements CatalogResolver { public InternalResolver ( ) { log ( "Apache resolver library not found, internal resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source == null ) { source = urlLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } private class ExternalResolver implements CatalogResolver { private Method setXMLCatalog = null ; private Method parseCatalog = null ; private Method resolveEntity = null ; private Method resolve = null ; private Object resolverImpl = null ; private boolean externalCatalogsProcessed = false ; public ExternalResolver ( Class resolverImplClass , Object resolverImpl ) { this . resolverImpl = resolverImpl ; try { setXMLCatalog = resolverImplClass . getMethod ( "setXMLCatalog" , new Class [ ] { XMLCatalog . class } ) ; parseCatalog = resolverImplClass . getMethod ( "parseCatalog" , new Class [ ] { String . class } ) ; resolveEntity = resolverImplClass . getMethod ( "resolveEntity" , new Class [ ] { String . class , String . class } ) ; resolve = resolverImplClass . getMethod ( "resolve" , new Class [ ] { String . class , String . class } ) ; } catch ( NoSuchMethodException ex ) { throw new BuildException ( ex ) ; } log ( "Apache resolver library found, xml-commons resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } private void processExternalCatalogs ( ) { if ( ! externalCatalogsProcessed ) { try { setXMLCatalog . invoke ( resolverImpl , new Object [ ] { XMLCatalog . this } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } Path catPath = getCatalogPath ( ) ; if ( catPath != null ) { log ( "Using catalogpath '" + getCatalogPath ( ) + "'" , Project . MSG_DEBUG ) ; String [ ] catPathList = getCatalogPath ( ) . list ( ) ; for ( int i = 0 ; i < catPathList . length ; i ++ ) { File catFile = new File ( catPathList [ i ] ) ; log ( "Parsing " + catFile , Project . MSG_DEBUG ) ; try { parseCatalog . invoke ( resolverImpl , new Object [ ] { catFile . getPath ( ) } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } } externalCatalogsProcessed = true ; } } } 	0	['30', '3', '0', '15', '109', '395', '4', '13', '13', '0.869731801', '929', '0.555555556', '4', '0.517241379', '0.211206897', '1', '1', '29.66666667', '8', '1.9667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private Vector regexps = new Vector ( ) ; private String line = null ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int regexpsSize = regexps . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; boolean matches = re . matches ( line ) ; if ( ! matches ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private final Vector getRegexps ( ) { return regexps ; } public final Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } } } } } 	0	['8', '5', '0', '9', '29', '0', '1', '8', '5', '0.571428571', '187', '1', '0', '0.823529412', '0.375', '2', '5', '22', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; public class SubAnt extends Task { private Path buildpath ; private String target = null ; private String antfile = "build.xml" ; private File genericantfile = null ; private boolean inheritAll = false ; private boolean inheritRefs = false ; private boolean failOnError = true ; private String output = null ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Vector propertySets = new Vector ( ) ; public void execute ( ) { if ( buildpath == null ) { throw new BuildException ( "No buildpath specified" ) ; } final String [ ] filenames = buildpath . list ( ) ; final int count = filenames . length ; if ( count < 1 ) { log ( "No sub-builds to iterate on" , Project . MSG_WARN ) ; return ; } BuildException buildException = null ; for ( int i = 0 ; i < count ; ++ i ) { File file = null ; Throwable thrownException = null ; try { File directory = null ; file = new File ( filenames [ i ] ) ; if ( file . isDirectory ( ) ) { if ( genericantfile != null ) { directory = file ; file = genericantfile ; } else { file = new File ( file , antfile ) ; } } execute ( file , directory ) ; } catch ( RuntimeException ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( "File '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( "Target '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } if ( buildException != null ) { throw buildException ; } } private void execute ( File file , File directory ) throws BuildException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { String msg = "Invalid file: " + file ; if ( failOnError ) { throw new BuildException ( msg ) ; } log ( msg , Project . MSG_WARN ) ; return ; } Ant ant = createAntTask ( directory ) ; String antfilename = null ; try { antfilename = file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } ant . setAntfile ( antfilename ) ; try { ant . execute ( ) ; } catch ( BuildException e ) { if ( failOnError ) { throw e ; } log ( "Failure for target '" + target + "' of: " + antfilename + "\n" + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void setAntfile ( String antfile ) { this . antfile = antfile ; } public void setGenericAntfile ( File afile ) { this . genericantfile = afile ; } public void setFailonerror ( boolean failOnError ) { this . failOnError = failOnError ; } public void setTarget ( String target ) { this . target = target ; } public void setOutput ( String s ) { this . output = s ; } public void setInheritall ( boolean b ) { this . inheritAll = b ; } public void setInheritrefs ( boolean b ) { this . inheritRefs = b ; } public void addProperty ( Property p ) { properties . addElement ( p ) ; } public void addReference ( Ant . Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addDirset ( DirSet set ) { getBuildpath ( ) . addDirset ( set ) ; } public void addFileset ( FileSet set ) { getBuildpath ( ) . addFileset ( set ) ; } public void addFilelist ( FileList list ) { getBuildpath ( ) . addFilelist ( list ) ; } public void setBuildpath ( Path s ) { getBuildpath ( ) . append ( s ) ; } public Path createBuildpath ( ) { return getBuildpath ( ) . createPath ( ) ; } public Path . PathElement createBuildpathElement ( ) { return getBuildpath ( ) . createPathElement ( ) ; } private Path getBuildpath ( ) { if ( buildpath == null ) { buildpath = new Path ( getProject ( ) ) ; } return buildpath ; } public void setBuildpathRef ( Reference r ) { createBuildpath ( ) . setRefid ( r ) ; } private Ant createAntTask ( File directory ) { Ant ant = ( Ant ) getProject ( ) . createTask ( "ant" ) ; ant . setOwningTarget ( getOwningTarget ( ) ) ; ant . setTaskName ( getTaskName ( ) ) ; ant . init ( ) ; if ( target != null && target . length ( ) > 0 ) { ant . setTarget ( target ) ; } if ( output != null ) { ant . setOutput ( output ) ; } if ( directory != null ) { ant . setDir ( directory ) ; } ant . setInheritAll ( inheritAll ) ; for ( Enumeration i = properties . elements ( ) ; i . hasMoreElements ( ) ; ) { copyProperty ( ant . createProperty ( ) , ( Property ) i . nextElement ( ) ) ; } for ( Enumeration i = propertySets . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addPropertyset ( ( PropertySet ) i . nextElement ( ) ) ; } ant . setInheritRefs ( inheritRefs ) ; for ( Enumeration i = references . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addReference ( ( Ant . Reference ) i . nextElement ( ) ) ; } return ant ; } private static void copyProperty ( Property to , Property from ) { to . setName ( from . getName ( ) ) ; if ( from . getValue ( ) != null ) { to . setValue ( from . getValue ( ) ) ; } if ( from . getFile ( ) != null ) { to . setFile ( from . getFile ( ) ) ; } if ( from . getResource ( ) != null ) { to . setResource ( from . getResource ( ) ) ; } if ( from . getPrefix ( ) != null ) { to . setPrefix ( from . getPrefix ( ) ) ; } if ( from . getRefid ( ) != null ) { to . setRefid ( from . getRefid ( ) ) ; } if ( from . getEnvironment ( ) != null ) { to . setEnvironment ( from . getEnvironment ( ) ) ; } if ( from . getClasspath ( ) != null ) { to . setClasspath ( from . getClasspath ( ) ) ; } } } 	0	['23', '3', '0', '15', '88', '201', '0', '15', '19', '0.847107438', '541', '1', '1', '0.627118644', '0.144927536', '2', '2', '22.04347826', '13', '2.1304', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '16', '1', '0', '15', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable { private Vector elements ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; setChecked ( false ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fl ) ; setChecked ( false ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( dset ) ; setChecked ( false ) ; } public void add ( Path path ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( path ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( getProject ( ) ) ; elements . addElement ( p ) ; setChecked ( false ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( getProject ( ) != null ) { f = getProject ( ) . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path " + o ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or" + " path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( getProject ( ) ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof DirSet ) { DirSet dset = ( DirSet ) o ; DirectoryScanner ds = dset . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedDirectories ( ) ; File dir = dset . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileList ) { FileList fl = ( FileList ) o ; String [ ] s = fl . getFiles ( getProject ( ) ) ; File dir = fl . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { try { Path p = ( Path ) super . clone ( ) ; p . elements = ( Vector ) elements . clone ( ) ; return p ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } Enumeration e = elements . elements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } setChecked ( true ) ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } private static void addUnlessPresent ( Vector v , File dir , String [ ] s ) { for ( int j = 0 ; j < s . length ; j ++ ) { File d = new File ( dir , s [ j ] ) ; String absolutePath = d . getAbsolutePath ( ) ; addUnlessPresent ( v , translateFile ( absolutePath ) ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( "Kaffe" . equals ( System . getProperty ( "java.vm.name" ) ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = getProject ( ) . resolveFile ( dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } } 	0	['30', '3', '0', '51', '102', '301', '40', '13', '24', '0.603448276', '1238', '0.5', '1', '0.526315789', '0.12183908', '2', '6', '40.2', '15', '2.6333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private final Vector getComments ( ) { return comments ; } public final Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '172', '1', '0', '0.823529412', '0.375', '2', '5', '20.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task m_task ; public TaskLogger ( final Task task ) { this . m_task = task ; } public void info ( final String message ) { m_task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { m_task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { m_task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { m_task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { m_task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0	['13', '5', '0', '11', '34', '68', '5', '7', '12', '0.75', '199', '1', '0', '0.837837838', '0.292307692', '2', '8', '14.15384615', '5', '2.1538', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public static final String NAME_KEY = "name" ; public static final String CASE_KEY = "casesensitive" ; public static final String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '10', '23', '0', '5', '5', '8', '0.761904762', '198', '0.5', '0', '0.844444444', '0.35', '1', '4', '23', '6', '2.25', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType type = new FileType ( ) ; type . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( type ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0	['6', '5', '0', '9', '22', '0', '4', '5', '6', '0.6', '105', '0.5', '0', '0.88372093', '0.333333333', '2', '5', '16.16666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; FileInputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '4', '21', '3', '0', '4', '1', '1.5', '144', '1', '0', '0.960784314', '1', '2', '3', '46.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0	['5', '3', '0', '5', '15', '4', '0', '5', '5', '0.75', '90', '1', '0', '0.902439024', '0.533333333', '0', '0', '16.4', '1', '0.8', '0']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; String [ ] getDeselectedDirectories ( ) ; String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '0', '3', '1', '0', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant ; import java . io . File ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . apache . tools . ant . taskdefs . condition . Os ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) && ! token . startsWith ( "." ) && ! token . startsWith ( ".." ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '17', '0', '2', '1', '3', '0.25', '204', '1', '0', '0', '0.666666667', '0', '0', '65.66666667', '2', '1', '0']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Reference ; public class IsReference extends ProjectComponent implements Condition { private Reference ref ; private String type ; public void setRefid ( Reference r ) { ref = r ; } public void setType ( String type ) { this . type = type ; } public boolean eval ( ) throws BuildException { if ( ref == null ) { throw new BuildException ( "No reference specified for isreference " + "condition" ) ; } Object o = getProject ( ) . getReference ( ref . getRefId ( ) ) ; if ( o == null ) { return false ; } else if ( type == null ) { return true ; } else { Class typeClass = ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( type ) ; if ( typeClass == null ) { typeClass = ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( type ) ; } if ( typeClass == null ) { return false ; } return typeClass . isAssignableFrom ( o . getClass ( ) ) ; } } } 	0	['4', '2', '0', '6', '14', '2', '1', '5', '4', '0.666666667', '68', '1', '1', '0.75', '0.5', '0', '0', '15.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; FileInputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( bis != null ) { try { bis . close ( ) ; } catch ( IOException ioex ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '5', '25', '3', '0', '5', '1', '1.5', '191', '1', '0', '0.960784314', '1', '2', '3', '62.33333333', '13', '4.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitutions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '308', '1', '0', '0.840909091', '0.325', '1', '1', '37', '4', '1.25', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final void setSkip ( final long skip ) { this . skip = skip ; } private final long getSkip ( ) { return skip ; } public final Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0	['10', '5', '0', '6', '30', '0', '1', '5', '6', '0.688888889', '328', '1', '1', '0.777777778', '0.375', '2', '5', '30.8', '12', '2.3', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public final Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . net . URL ; public class ResourceLocation { private String name = null ; private String publicId = null ; private String location = null ; private URL base = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public void setBase ( URL base ) { this . base = base ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } public URL getBase ( ) { return base ; } } 	0	['7', '1', '1', '5', '8', '3', '5', '0', '7', '0.75', '47', '1', '0', '0', '0.476190476', '0', '0', '5.142857143', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; private static final FileUtils fu = FileUtils . newFileUtils ( ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! fu . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['10', '6', '0', '10', '33', '35', '0', '10', '6', '0.851851852', '165', '1', '1', '0.950617284', '0.351851852', '3', '9', '15.2', '2', '0.9', '0']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; public void setName ( String name ) { this . name = name ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { if ( ( ( Attribute ) attributes . get ( i ) ) . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the attribute " + attribute . getName ( ) + " has already been specified" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; } public static class Attribute { private String name ; private String defaultValue ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private boolean optional = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } TemplateElement other = ( TemplateElement ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } return optional == other . optional ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) ; } } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) + objectHashCode ( getURI ( ) ) + objectHashCode ( nestedSequential ) + objectHashCode ( attributes ) + objectHashCode ( elements ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	0	['17', '4', '0', '15', '62', '78', '4', '14', '12', '0.8125', '416', '0.8', '1', '0.719298246', '0.205882353', '0', '0', '23.17647059', '16', '2.8235', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '39', '4', '0', '7', '7', '0.714285714', '277', '1', '0', '0.917647059', '0.46875', '4', '4', '32.875', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; public final class LoadProperties extends Task { private File srcFile = null ; private final Vector filterChains = new Vector ( ) ; private String encoding = null ; public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "Source file not defined." ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist." ) ; } if ( ! srcFile . isFile ( ) ) { throw new BuildException ( "Source file is not a file." ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; ByteArrayInputStream tis = null ; try { final long len = srcFile . length ( ) ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } if ( encoding == null ) { tis = new ByteArrayInputStream ( text . getBytes ( ) ) ; } else { tis = new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } final Properties props = new Properties ( ) ; props . load ( tis ) ; Property propertyTask = ( Property ) getProject ( ) . createTask ( "property" ) ; propertyTask . setTaskName ( getTaskName ( ) ) ; propertyTask . addProperties ( props ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , getLocation ( ) ) ; } catch ( final BuildException be ) { throw be ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } try { if ( tis != null ) { tis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['5', '3', '0', '8', '41', '0', '0', '8', '5', '0.5', '230', '1', '0', '0.902439024', '0.4', '2', '2', '44.4', '1', '0.8', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public class HashvalueAlgorithm implements Algorithm { public boolean isValid ( ) { return true ; } public String getValue ( File file ) { try { if ( ! file . canRead ( ) ) { return null ; } java . io . FileInputStream fis = new java . io . FileInputStream ( file ) ; byte [ ] content = new byte [ fis . available ( ) ] ; fis . read ( content ) ; fis . close ( ) ; String s = new String ( content ) ; int hash = s . hashCode ( ) ; return Integer . toString ( hash ) ; } catch ( Exception e ) { return null ; } } public String toString ( ) { return "HashvalueAlgorithm" ; } } 	0	['4', '1', '0', '1', '13', '6', '0', '1', '4', '2', '45', '0', '0', '0', '0.625', '0', '0', '10.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import sun . misc . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0	['2', '3', '0', '4', '15', '1', '0', '4', '0', '2', '59', '0', '0', '0.952380952', '0.666666667', '1', '1', '28.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class MatchingTask extends Task implements SelectorContainer { protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { fileset . setDefaultexcludes ( useDefaultExcludes ) ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; return fileset . getDirectoryScanner ( getProject ( ) ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { fileset . addContainsRegexp ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { fileset . addDifferent ( selector ) ; } public void addType ( TypeSelector selector ) { fileset . addType ( selector ) ; } public void addModified ( ModifiedSelector selector ) { fileset . addModified ( selector ) ; } public void add ( FileSelector selector ) { fileset . add ( selector ) ; } protected final FileSet getImplicitFileSet ( ) { return fileset ; } } 	0	['42', '3', '11', '39', '96', '0', '11', '28', '40', '0', '328', '1', '1', '0.474358974', '0.073412698', '2', '2', '6.785714286', '6', '1.1667', '0']
package org . apache . tools . ant . types ; public class DTDLocation extends ResourceLocation { } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { } 	0	['1', '6', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . types . resolver ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogEntry ; import org . apache . xml . resolver . helpers . PublicId ; public class ApacheCatalog extends Catalog { private ApacheCatalogResolver resolver = null ; protected Catalog newCatalog ( ) { ApacheCatalog cat = ( ApacheCatalog ) super . newCatalog ( ) ; cat . setResolver ( resolver ) ; return cat ; } public void setResolver ( ApacheCatalogResolver resolver ) { this . resolver = resolver ; } public void addEntry ( CatalogEntry entry ) { int type = entry . getEntryType ( ) ; if ( type == PUBLIC ) { String publicid = PublicId . normalize ( entry . getEntryArg ( 0 ) ) ; String systemid = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addPublicEntry ( publicid , systemid , base ) ; } } else if ( type == URI ) { String uri = normalizeURI ( entry . getEntryArg ( 0 ) ) ; String altURI = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addURIEntry ( uri , altURI , base ) ; } } super . addEntry ( entry ) ; } } 	0	['4', '2', '0', '6', '14', '0', '1', '6', '3', '0', '96', '1', '1', '0.916666667', '0.5', '1', '3', '22.75', '5', '1.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . InputStream ; import java . io . StringReader ; public class StringInputStream extends InputStream { private StringReader in ; private String encoding ; private byte [ ] slack ; private int begin ; public StringInputStream ( String source ) { in = new StringReader ( source ) ; } public StringInputStream ( String source , String encoding ) { in = new StringReader ( source ) ; this . encoding = encoding ; } public synchronized int read ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } byte result ; if ( slack != null && begin < slack . length ) { result = slack [ begin ] ; if ( ++ begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) <= 0 ) { return - 1 ; } result = buf [ 0 ] ; } if ( result < 0 ) { return 256 + result ; } else { return result ; } } public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } while ( slack == null ) { char [ ] buf = new char [ len ] ; int n = in . read ( buf ) ; if ( n == - 1 ) { return - 1 ; } if ( n > 0 ) { String s = new String ( buf , 0 , n ) ; if ( encoding == null ) { slack = s . getBytes ( ) ; } else { slack = s . getBytes ( encoding ) ; } begin = 0 ; } } if ( len > slack . length - begin ) { len = slack . length - begin ; } System . arraycopy ( slack , begin , b , off , len ) ; if ( ( begin += len ) >= slack . length ) { slack = null ; } return len ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized int available ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( slack != null ) { return slack . length - begin ; } if ( in . ready ( ) ) { return 1 ; } else { return 0 ; } } public boolean markSupported ( ) { return false ; } public synchronized void reset ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } slack = null ; in . reset ( ) ; } public synchronized void close ( ) throws IOException { in . close ( ) ; slack = null ; in = null ; } } 	0	['9', '2', '0', '0', '23', '0', '0', '0', '9', '0.53125', '250', '1', '0', '0.5625', '0.388888889', '1', '2', '26.33333333', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; import java . util . TimeZone ; class ChangeLogWriter { private static final SimpleDateFormat c_outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat c_outputTime = new SimpleDateFormat ( "HH:mm" ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; c_outputDate . setTimeZone ( utc ) ; c_outputTime . setTimeZone ( utc ) ; } public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; output . println ( "<changelog>" ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( output , entry ) ; } output . println ( "</changelog>" ) ; output . flush ( ) ; output . close ( ) ; } private void printEntry ( final PrintWriter output , final CVSEntry entry ) { output . println ( "\t<entry>" ) ; output . println ( "\t\t<date>" + c_outputDate . format ( entry . getDate ( ) ) + "</date>" ) ; output . println ( "\t\t<time>" + c_outputTime . format ( entry . getDate ( ) ) + "</time>" ) ; output . println ( "\t\t<author><![CDATA[" + entry . getAuthor ( ) + "]]></author>" ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; output . println ( "\t\t<file>" ) ; output . println ( "\t\t\t<name>" + file . getName ( ) + "</name>" ) ; output . println ( "\t\t\t<revision>" + file . getRevision ( ) + "</revision>" ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { output . println ( "\t\t\t<prevrevision>" + previousRevision + "</prevrevision>" ) ; } output . println ( "\t\t</file>" ) ; } output . println ( "\t\t<msg><![CDATA[" + entry . getComment ( ) + "]]></msg>" ) ; output . println ( "\t</entry>" ) ; } } 	0	['4', '1', '0', '3', '25', '4', '1', '2', '1', '0.333333333', '183', '1', '0', '0', '0.583333333', '0', '0', '44.25', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private File myFile ; public void setFile ( final File file ) { myFile = file ; } public void execute ( ) throws BuildException { File savedFile = myFile ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( myFile ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . store ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + myFile ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing output stream " + ioe , Project . MSG_ERR ) ; } } myFile = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = myFile + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( myFile ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing input stream " + ioe , Project . MSG_ERR ) ; } } } } private void validate ( ) throws BuildException { if ( null == myFile ) { myFile = getProject ( ) . resolveFile ( DEFAULT_FILENAME ) ; } if ( ! myFile . exists ( ) ) { try { FileUtils . newFileUtils ( ) . createNewFile ( myFile ) ; } catch ( final IOException ioe ) { final String message = myFile + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! myFile . canRead ( ) ) { final String message = "Unable to read from " + myFile + "." ; throw new BuildException ( message ) ; } if ( ! myFile . canWrite ( ) ) { final String message = "Unable to write to " + myFile + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '3', '0', '5', '35', '0', '0', '5', '3', '0.866666667', '300', '1', '0', '0.880952381', '0.444444444', '1', '1', '48.5', '1', '0.8333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '1', '35', '11', '4', '33', '2', '5', '0.25', '54', '1', '0', '0', '0.533333333', '0', '0', '9.6', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setProject ( Project project ) { super . setProject ( project ) ; defaultSet . setProject ( project ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , getLocation ( ) ) ; } if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( getProject ( ) ) == null ) { try { super . execute ( ) ; } finally { if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { filesets . removeElement ( defaultSet ) ; } } } else if ( isValidOs ( ) ) { Execute execute = prepareExec ( ) ; Commandline cloned = ( Commandline ) cmdl . clone ( ) ; cloned . createArgument ( ) . setValue ( defaultSet . getDir ( getProject ( ) ) . getPath ( ) ) ; try { execute . setCommandline ( cloned . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	0	['18', '5', '0', '15', '58', '39', '0', '15', '16', '0.607843137', '316', '1', '1', '0.862903226', '0.268518519', '4', '7', '16.38888889', '4', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0	['5', '3', '3', '8', '12', '2', '6', '2', '5', '0.625', '49', '1', '0', '0.902439024', '0.466666667', '0', '0', '8.4', '1', '0.8', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; import org . apache . tools . ant . ProjectComponent ; public class LineTokenizer extends ProjectComponent implements Tokenizer { private String lineEnd = "" ; private int pushed = - 2 ; private boolean includeDelims = false ; public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } lineEnd = "" ; StringBuffer line = new StringBuffer ( ) ; int state = 0 ; while ( ch != - 1 ) { if ( state == 0 ) { if ( ch == '\r' ) { state = 1 ; } else if ( ch == '\n' ) { lineEnd = "\n" ; break ; } else { line . append ( ( char ) ch ) ; } } else { state = 0 ; if ( ch == '\n' ) { lineEnd = "\r\n" ; } else { pushed = ch ; lineEnd = "\r" ; } break ; } ch = in . read ( ) ; } if ( ch == - 1 && state == 1 ) { lineEnd = "\r" ; } if ( includeDelims ) { line . append ( lineEnd ) ; } return line . toString ( ) ; } public String getPostToken ( ) { if ( includeDelims ) { return "" ; } return lineEnd ; } } 	0	['4', '2', '0', '6', '10', '0', '4', '2', '4', '0.333333333', '125', '1', '0', '0.75', '0.5', '0', '0', '29.5', '2', '1', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task implements TypeAdapter { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void checkProxyClass ( Class proxyClass ) { checkTaskClass ( proxyClass , getProject ( ) ) ; } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { getProject ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return proxy ; } } 	0	['7', '3', '0', '6', '26', '15', '2', '5', '6', '0.833333333', '237', '0.5', '0', '0.860465116', '0.285714286', '1', '1', '32.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random rand = new Random ( ) ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; Path cp = attributes . getClasspath ( ) ; if ( cp == null ) { cp = new Path ( attributes . getProject ( ) ) ; } if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { classpath . addExtdirs ( attributes . getExtdirs ( ) ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.1" ) ; } else if ( "1.2" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.2" ) ; } else { cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['16', '1', '3', '15', '56', '86', '4', '12', '6', '0.8', '372', '1', '2', '0', '0.226666667', '0', '0', '22.0625', '14', '2', '0']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public final void setName ( final String name ) { this . name = name ; } public final void setType ( final String type ) { this . type = type ; } public final void setValue ( final String value ) { this . value = value ; } public final String getName ( ) { return name ; } public final String getType ( ) { return type ; } public final String getValue ( ) { return value ; } } 	0	['7', '1', '0', '24', '8', '3', '24', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is " + "not available.  A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '151', '0', '0', '0.92', '0.5', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; public class FileSet extends AbstractFileSet { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	0	['3', '4', '3', '32', '9', '3', '28', '4', '2', '2', '23', '0', '0', '0.988636364', '0.666666667', '3', '4', '6.666666667', '2', '0.6667', '0']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) ; } } 	0	['3', '2', '0', '3', '8', '0', '2', '1', '3', '0', '32', '1', '0', '0.75', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['31', '1', '0', '5', '68', '407', '2', '3', '13', '0.904761905', '624', '0.904761905', '2', '0', '0.316129032', '0', '0', '18.4516129', '11', '1.4516', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Hashtable ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean crSeen = false ; } private static final int MAX_SIZE = 1024 ; private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private Hashtable buffers = new Hashtable ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; bufferInfo . crSeen = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . crSeen = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( c == '\n' ) { bufferInfo . buffer . write ( cc ) ; processBuffer ( bufferInfo . buffer ) ; } else { if ( bufferInfo . crSeen ) { processBuffer ( bufferInfo . buffer ) ; } bufferInfo . buffer . write ( cc ) ; } bufferInfo . crSeen = ( c == '\r' ) ; if ( ! bufferInfo . crSeen && bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } protected void processFlush ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxFlush ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processFlush ( bufferInfo . buffer ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; BufferInfo bufferInfo = getBufferInfo ( ) ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { bufferInfo . buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['10', '2', '0', '4', '30', '27', '1', '3', '5', '0.761904762', '252', '1', '1', '0.357142857', '0.283333333', '1', '1', '23.5', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class DifferentSelector extends MappingSelector { private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private boolean ignoreFileTimes = true ; public void setIgnoreFileTimes ( boolean ignoreFileTimes ) { this . ignoreFileTimes = ignoreFileTimes ; } protected boolean selectionTest ( File srcfile , File destfile ) { if ( srcfile . exists ( ) != destfile . exists ( ) ) { return true ; } if ( srcfile . length ( ) != destfile . length ( ) ) { return true ; } if ( ! ignoreFileTimes ) { boolean sameDate ; sameDate = destfile . lastModified ( ) >= srcfile . lastModified ( ) - granularity && destfile . lastModified ( ) <= srcfile . lastModified ( ) + granularity ; if ( ! sameDate ) { return true ; } } try { return ! fileUtils . contentEquals ( srcfile , destfile ) ; } catch ( IOException e ) { throw new BuildException ( "while comparing " + srcfile + " and " + destfile , e ) ; } } } 	0	['3', '5', '0', '7', '14', '0', '4', '3', '2', '0.25', '92', '1', '1', '0.953488372', '0.555555556', '1', '1', '29', '8', '3', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '9', '7', '21', '8', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . UnknownElement ; public class Antlib extends Task implements TaskContainer { public static final String TAG = "antlib" ; public static Antlib createAntlib ( Project project , URL antlibUrl , String uri ) { try { antlibUrl . openConnection ( ) . connect ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to find " + antlibUrl , ex ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; helper . enterAntLib ( uri ) ; try { ProjectHelper2 parser = new ProjectHelper2 ( ) ; UnknownElement ue = parser . parseUnknownElement ( project , antlibUrl ) ; if ( ! ( ue . getTag ( ) . equals ( TAG ) ) ) { throw new BuildException ( "Unexpected tag " + ue . getTag ( ) + " expecting " + TAG , ue . getLocation ( ) ) ; } Antlib antlib = new Antlib ( ) ; antlib . setProject ( project ) ; antlib . setLocation ( ue . getLocation ( ) ) ; antlib . init ( ) ; ue . configure ( antlib ) ; return antlib ; } finally { helper . exitAntLib ( ) ; } } private ClassLoader classLoader ; private String uri = "" ; private List tasks = new ArrayList ( ) ; protected void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } protected void setURI ( String uri ) { this . uri = uri ; } private ClassLoader getClassLoader ( ) { if ( classLoader == null ) { classLoader = Antlib . class . getClassLoader ( ) ; } return classLoader ; } public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } public void execute ( ) { for ( Iterator i = tasks . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; setLocation ( ue . getLocation ( ) ) ; ue . maybeConfigure ( ) ; Object configuredObject = ue . getRealThing ( ) ; if ( configuredObject == null ) { continue ; } if ( ! ( configuredObject instanceof AntlibDefinition ) ) { throw new BuildException ( "Invalid task in antlib " + ue . getTag ( ) + " " + configuredObject . getClass ( ) + " does not " + "extend org.apache.tools.ant.taskdefs.AntlibDefinition" ) ; } AntlibDefinition def = ( AntlibDefinition ) configuredObject ; def . setURI ( uri ) ; def . setAntlibClassLoader ( getClassLoader ( ) ) ; def . init ( ) ; def . execute ( ) ; } } } 	0	['8', '3', '0', '11', '45', '16', '1', '10', '4', '0.771428571', '216', '0.6', '0', '0.840909091', '0.270833333', '1', '1', '25.375', '4', '1.875', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String m_userID ; private String m_displayName ; public void setDisplayname ( final String displayName ) { m_displayName = displayName ; } public void setUserid ( final String userID ) { m_userID = userID ; } String getUserID ( ) { return m_userID ; } String getDisplayname ( ) { return m_displayName ; } void validate ( ) throws BuildException { if ( null == m_userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == m_displayName ) { final String message = "Displayname attribute must be set for userID " + m_userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '3', '0.6', '56', '1', '0', '0', '0.666666667', '0', '0', '8', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '5', '15', '1', '0', '5', '1', '2', '67', '0', '0', '0.980392157', '1', '1', '2', '32.5', '4', '2', '0']
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0	['5', '1', '0', '7', '5', '10', '6', '1', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { super ( "ProcessDestroyer Shutdown Hook" ) ; } public void run ( ) { if ( shouldDestroy ) { ProcessDestroyer . this . run ( ) ; } } public void setShouldDestroy ( boolean shouldDestroy ) { this . shouldDestroy = shouldDestroy ; } } public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; addShutdownHookMethod = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; removeShutdownHookMethod = Runtime . class . getMethod ( "removeShutdownHook" , paramTypes ) ; } catch ( NoSuchMethodException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void addShutdownHook ( ) { if ( addShutdownHookMethod != null ) { destroyProcessThread = new ProcessDestroyerImpl ( ) ; Object [ ] args = { destroyProcessThread } ; try { addShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; added = true ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } private void removeShutdownHook ( ) { if ( removeShutdownHookMethod != null && destroyProcessThread != null ) { Object [ ] args = { destroyProcessThread } ; try { Boolean removed = ( Boolean ) removeShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; if ( ! removed . booleanValue ( ) ) { System . err . println ( "Could not remove shutdown hook" ) ; } destroyProcessThread . setShouldDestroy ( false ) ; destroyProcessThread . start ( ) ; try { destroyProcessThread . join ( 20000 ) ; } catch ( InterruptedException ie ) { } destroyProcessThread = null ; added = false ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } public boolean isAddedAsShutdownHook ( ) { return added ; } public boolean add ( Process process ) { synchronized ( processes ) { if ( processes . size ( ) == 0 ) { addShutdownHook ( ) ; } processes . addElement ( process ) ; return processes . contains ( process ) ; } } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( processes . size ( ) == 0 ) { processes . notifyAll ( ) ; removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } try { processes . wait ( ) ; } catch ( InterruptedException interrupt ) { } } } } 	0	['8', '1', '0', '2', '33', '4', '2', '1', '5', '0.673469388', '269', '0.714285714', '1', '0', '0.416666667', '0', '0', '31.75', '4', '1.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '14', '26', '0', '5', '9', '7', '0.458333333', '199', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.85714286', '5', '2.5714', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '6', '13', '0', '5', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . JavaEnvUtils ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( "keytool" ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '8', '34', '65', '0', '8', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '1', '2', '27', '2', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0	['7', '1', '0', '2', '7', '21', '2', '0', '7', '2', '7', '0', '0', '0', '0.642857143', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector replyToList = new Vector ( ) ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; private String charset = null ; private String user = null ; private String password = null ; private boolean SSL = false ; public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean SSL ) { this . SSL = SSL ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addReplyTo ( EmailAddress address ) { this . replyToList . add ( address ) ; } public void setReplyTo ( String address ) { this . replyToList . add ( new EmailAddress ( address ) ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( getProject ( ) . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } if ( autoFound == false && ( ( user != null ) || ( password != null ) ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SMTP auth only possible with MIME mail" ) ; } if ( autoFound == false && ( SSL ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SSL only possible with MIME mail" ) ; } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } if ( charset != null ) { if ( message . getCharset ( ) != null ) { throw new BuildException ( "The charset can only be " + "specified in one location" ) ; } else { message . setCharset ( charset ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "ReplyTo " + replyToList , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( SSL ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setReplyToList ( replyToList ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } catch ( Exception e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw new BuildException ( e ) ; } } finally { message = savedMessage ; files = savedFiles ; } } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['30', '3', '1', '14', '89', '301', '1', '13', '30', '0.935532234', '844', '0.826086957', '2', '0.560606061', '0.207407407', '3', '3', '26.36666667', '39', '2.5', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '2', '5', '15', '0', '4', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String m_name ; private String m_revision ; private String m_previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { m_name = name ; m_revision = revision ; if ( ! revision . equals ( previousRevision ) ) { m_previousRevision = previousRevision ; } } String getName ( ) { return m_name ; } String getRevision ( ) { return m_revision ; } String getPreviousRevision ( ) { return m_previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; Task task = event . getTask ( ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } private TimedElement getTaskElement ( Task task ) { TimedElement element = ( TimedElement ) tasks . get ( task ) ; if ( element != null ) { return element ; } for ( Enumeration e = tasks . keys ( ) ; e . hasMoreElements ( ) ; ) { Task key = ( Task ) e . nextElement ( ) ; if ( key instanceof UnknownElement ) { if ( ( ( UnknownElement ) key ) . getTask ( ) == task ) { return ( TimedElement ) tasks . get ( key ) ; } } } return null ; } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = getTaskElement ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	0	['16', '1', '0', '13', '74', '50', '0', '13', '12', '0.937037037', '635', '1', '1', '0', '0.288888889', '0', '0', '37.5625', '9', '2.6875', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import java . util . Vector ; public class Description extends DataType { public void addText ( String text ) { ProjectHelper ph = ProjectHelper . getProjectHelper ( ) ; if ( ! ( ph instanceof ProjectHelperImpl ) ) { return ; } String currentDescription = getProject ( ) . getDescription ( ) ; if ( currentDescription == null ) { getProject ( ) . setDescription ( text ) ; } else { getProject ( ) . setDescription ( currentDescription + text ) ; } } public static String getDescription ( Project project ) { StringBuffer description = new StringBuffer ( ) ; Vector targets = ( Vector ) project . getReference ( "ant.targets" ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { Target t = ( Target ) targets . elementAt ( i ) ; concatDescriptions ( project , t , description ) ; } return description . toString ( ) ; } private static void concatDescriptions ( Project project , Target t , StringBuffer description ) { if ( t == null ) { return ; } Vector tasks = findElementInTarget ( project , t , "description" ) ; if ( tasks == null ) { return ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { Task task = ( Task ) tasks . elementAt ( i ) ; if ( ! ( task instanceof UnknownElement ) ) { continue ; } UnknownElement ue = ( ( UnknownElement ) task ) ; StringBuffer descComp = ue . getWrapper ( ) . getText ( ) ; if ( descComp != null ) { description . append ( ( Object ) descComp ) ; } } } private static Vector findElementInTarget ( Project project , Target t , String name ) { Task [ ] tasks = t . getTasks ( ) ; Vector elems = new Vector ( ) ; for ( int i = 0 ; i < tasks . length ; i ++ ) { if ( name . equals ( tasks [ i ] . getTaskName ( ) ) ) { elems . addElement ( tasks [ i ] ) ; } } return elems ; } } 	0	['5', '3', '0', '9', '24', '10', '1', '9', '3', '2', '137', '0', '0', '0.882352941', '0.4', '0', '0', '26.4', '6', '2.8', '0']
package org . apache . tools . ant ; import java . io . Serializable ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . Locator ; public class Location implements Serializable { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( Locator loc ) { this ( loc . getSystemId ( ) , loc . getLineNumber ( ) , loc . getColumnNumber ( ) ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { if ( fileName != null && fileName . startsWith ( "file:" ) ) { this . fileName = FileUtils . newFileUtils ( ) . fromURI ( fileName ) ; } else { this . fileName = fileName ; } this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getFileName ( ) { return fileName ; } public int getLineNumber ( ) { return lineNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['8', '1', '0', '80', '19', '18', '79', '1', '6', '0.428571429', '99', '0.75', '1', '0', '0.392857143', '0', '0', '10.875', '3', '0.625', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . IOException ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean inheritAll = true ; private boolean inheritRefs = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = ( Ant ) getProject ( ) . createTask ( "ant" ) ; callee . setOwningTarget ( getOwningTarget ( ) ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( getLocation ( ) ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , getLocation ( ) ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void addPropertyset ( org . apache . tools . ant . types . PropertySet ps ) { if ( callee == null ) { init ( ) ; } callee . addPropertyset ( ps ) ; } public void setTarget ( String target ) { subTarget = target ; } public void handleOutput ( String output ) { if ( callee != null ) { callee . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( callee != null ) { return callee . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( callee != null ) { callee . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( callee != null ) { callee . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( callee != null ) { callee . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } } 	0	['14', '3', '0', '10', '44', '0', '0', '10', '14', '0.730769231', '199', '1', '1', '0.74', '0.255102041', '2', '4', '12.92857143', '2', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '6', '2', '0', '6', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '24', '1', '1', '8', '2', '2', '147', '0', '0', '0.958333333', '1', '0', '0', '72.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0	['3', '5', '0', '9', '11', '3', '5', '4', '3', '2', '76', '0', '0', '0.953488372', '0.666666667', '1', '1', '24.33333333', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0	['24', '1', '0', '23', '24', '276', '3', '20', '24', '2', '24', '0', '0', '0', '0.089285714', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Exit extends Task { private String message ; private String ifCondition , unlessCondition ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { String text = null ; if ( message != null && message . length ( ) > 0 ) { text = message ; } else { if ( getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } else { if ( text == null ) { text = "No message" ; } } } throw new BuildException ( text ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } } 	0	['8', '3', '0', '4', '18', '10', '0', '4', '6', '0.714285714', '172', '1', '0', '0.840909091', '0.75', '0', '0', '20.125', '4', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , getLocation ( ) ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , getLocation ( ) ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , getLocation ( ) ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { getProject ( ) . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '5', '24', '1', '0', '5', '6', '0.7', '137', '1', '0', '0.880952381', '0.416666667', '3', '3', '21.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . Tokenizer ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . regexp . Regexp ; public class TokenFilter extends BaseFilterReader implements ChainableReader { public interface Filter { String filter ( String string ) ; } private Vector filters = new Vector ( ) ; private Tokenizer tokenizer = null ; private String delimOutput = null ; private String line = null ; private int linePos = 0 ; public TokenFilter ( ) { super ( ) ; } public TokenFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } while ( line == null || line . length ( ) == 0 ) { line = tokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } for ( Enumeration e = filters . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; line = filter . filter ( line ) ; if ( line == null ) { break ; } } linePos = 0 ; if ( line != null ) { if ( tokenizer . getPostToken ( ) . length ( ) != 0 ) { if ( delimOutput != null ) { line = line + delimOutput ; } else { line = line + tokenizer . getPostToken ( ) ; } } } } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final Reader chain ( final Reader reader ) { TokenFilter newFilter = new TokenFilter ( reader ) ; newFilter . filters = filters ; newFilter . tokenizer = tokenizer ; newFilter . delimOutput = delimOutput ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } public void setDelimOutput ( String delimOutput ) { this . delimOutput = resolveBackSlash ( delimOutput ) ; } public void addLineTokenizer ( LineTokenizer tokenizer ) { add ( tokenizer ) ; } public void addStringTokenizer ( StringTokenizer tokenizer ) { add ( tokenizer ) ; } public void addFileTokenizer ( FileTokenizer tokenizer ) { add ( tokenizer ) ; } public void add ( Tokenizer tokenizer ) { if ( this . tokenizer != null ) { throw new BuildException ( "Only one tokenizer allowed" ) ; } this . tokenizer = tokenizer ; } public void addReplaceString ( ReplaceString filter ) { filters . addElement ( filter ) ; } public void addContainsString ( ContainsString filter ) { filters . addElement ( filter ) ; } public void addReplaceRegex ( ReplaceRegex filter ) { filters . addElement ( filter ) ; } public void addContainsRegex ( ContainsRegex filter ) { filters . addElement ( filter ) ; } public void addTrim ( Trim filter ) { filters . addElement ( filter ) ; } public void addIgnoreBlank ( IgnoreBlank filter ) { filters . addElement ( filter ) ; } public void addDeleteCharacters ( DeleteCharacters filter ) { filters . addElement ( filter ) ; } public void add ( Filter filter ) { filters . addElement ( filter ) ; } public static class FileTokenizer extends ProjectComponent implements Tokenizer { public String getToken ( Reader in ) throws IOException { return FileUtils . readFully ( in ) ; } public String getPostToken ( ) { return "" ; } } public static class StringTokenizer extends ProjectComponent implements Tokenizer { private String intraString = "" ; private int pushed = - 2 ; private char [ ] delims = null ; private boolean delimsAreTokens = false ; private boolean suppressDelims = false ; private boolean includeDelims = false ; public void setDelims ( String delims ) { this . delims = resolveBackSlash ( delims ) . toCharArray ( ) ; } public void setDelimsAreTokens ( boolean delimsAreTokens ) { this . delimsAreTokens = delimsAreTokens ; } public void setSuppressDelims ( boolean suppressDelims ) { this . suppressDelims = suppressDelims ; } public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } boolean inToken = true ; intraString = "" ; StringBuffer word = new StringBuffer ( ) ; StringBuffer padding = new StringBuffer ( ) ; while ( ch != - 1 ) { char c = ( char ) ch ; boolean isDelim = isDelim ( c ) ; if ( inToken ) { if ( isDelim ) { if ( delimsAreTokens ) { if ( word . length ( ) == 0 ) { word . append ( c ) ; } else { pushed = ch ; } break ; } padding . append ( c ) ; inToken = false ; } else { word . append ( c ) ; } } else { if ( isDelim ) { padding . append ( c ) ; } else { pushed = ch ; break ; } } ch = in . read ( ) ; } intraString = padding . toString ( ) ; if ( includeDelims ) { word . append ( intraString ) ; } return word . toString ( ) ; } public String getPostToken ( ) { if ( suppressDelims || includeDelims ) { return "" ; } return intraString ; } private boolean isDelim ( char ch ) { if ( delims == null ) { return Character . isWhitespace ( ch ) ; } for ( int i = 0 ; i < delims . length ; ++ i ) { if ( delims [ i ] == ch ) { return true ; } } return false ; } } public abstract static class ChainableReaderFilter extends ProjectComponent implements ChainableReader , Filter { private boolean byLine = true ; public void setByLine ( boolean byLine ) { this . byLine = byLine ; } public Reader chain ( Reader reader ) { TokenFilter tokenFilter = new TokenFilter ( reader ) ; if ( ! byLine ) { tokenFilter . add ( new FileTokenizer ( ) ) ; } tokenFilter . add ( this ) ; return tokenFilter ; } } public static class ReplaceString extends ChainableReaderFilter { private String from ; private String to ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String filter ( String line ) { if ( from == null ) { throw new BuildException ( "Missing from in stringreplace" ) ; } StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = line . indexOf ( from ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( line . substring ( start , found ) ) ; } if ( to != null ) { ret . append ( to ) ; } start = found + from . length ( ) ; found = line . indexOf ( line , start ) ; } if ( line . length ( ) > start ) { ret . append ( line . substring ( start , line . length ( ) ) ) ; } return ret . toString ( ) ; } } public static class ContainsString extends ProjectComponent implements Filter { private String contains ; public void setContains ( String contains ) { this . contains = contains ; } public String filter ( String string ) { if ( contains == null ) { throw new BuildException ( "Missing contains in containsstring" ) ; } if ( string . indexOf ( contains ) > - 1 ) { return string ; } return null ; } } public static class ReplaceRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing pattern in replaceregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { to = "" ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String line ) { initialize ( ) ; if ( ! regexp . matches ( line , options ) ) { return line ; } return regexp . substitute ( line , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class ContainsRegex extends ChainableReaderFilter { private String from ; private String to ; private Project project ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing from in containsregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( project ) ; if ( to == null ) { return ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String string ) { initialize ( ) ; if ( ! regexp . matches ( string , options ) ) { return null ; } if ( substitution == null ) { return string ; } return regexp . substitute ( string , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class Trim extends ChainableReaderFilter { public String filter ( String line ) { return line . trim ( ) ; } } public static class IgnoreBlank extends ChainableReaderFilter { public String filter ( String line ) { if ( line . trim ( ) . length ( ) == 0 ) { return null ; } return line ; } } public static class DeleteCharacters extends ProjectComponent implements Filter , ChainableReader { private String deleteChars = "" ; public void setChars ( String deleteChars ) { this . deleteChars = resolveBackSlash ( deleteChars ) ; } public String filter ( String string ) { StringBuffer output = new StringBuffer ( string . length ( ) ) ; for ( int i = 0 ; i < string . length ( ) ; ++ i ) { char ch = string . charAt ( i ) ; if ( ! ( isDeleteCharacter ( ch ) ) ) { output . append ( ch ) ; } } return output . toString ( ) ; } public Reader chain ( Reader reader ) { return new BaseFilterReader ( reader ) { public int read ( ) throws IOException { while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { return c ; } if ( ! ( isDeleteCharacter ( ( char ) c ) ) ) { return c ; } } } } ; } private boolean isDeleteCharacter ( char c ) { for ( int d = 0 ; d < deleteChars . length ( ) ; ++ d ) { if ( deleteChars . charAt ( d ) == c ) { return true ; } } return false ; } } public static String resolveBackSlash ( String input ) { StringBuffer b = new StringBuffer ( ) ; boolean backSlashSeen = false ; for ( int i = 0 ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; if ( ! backSlashSeen ) { if ( c == '\\' ) { backSlashSeen = true ; } else { b . append ( c ) ; } } else { switch ( c ) { case '\\' : b . append ( ( char ) '\\' ) ; break ; case 'n' : b . append ( ( char ) '\n' ) ; break ; case 'r' : b . append ( ( char ) '\r' ) ; break ; case 't' : b . append ( ( char ) '\t' ) ; break ; case 'f' : b . append ( ( char ) '\f' ) ; break ; case 's' : b . append ( " \t\n\r\f" ) ; break ; default : b . append ( c ) ; } backSlashSeen = false ; } } return b . toString ( ) ; } public static int convertRegexOptions ( String flags ) { if ( flags == null ) { return 0 ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } return options ; } } 	0	['19', '4', '0', '18', '40', '23', '6', '16', '19', '0.688888889', '386', '1', '1', '0.604651163', '0.119298246', '2', '4', '19.05263158', '11', '1.7368', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public final class StripJavaComments extends BaseFilterReader implements ChainableReader { private int readAheadCh = - 1 ; private boolean inString = false ; private boolean quoted = false ; public StripJavaComments ( ) { super ( ) ; } public StripJavaComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( readAheadCh != - 1 ) { ch = readAheadCh ; readAheadCh = - 1 ; } else { ch = in . read ( ) ; if ( ch == '"' && ! quoted ) { inString = ! inString ; quoted = false ; } else if ( ch == '\\' ) { quoted = ! quoted ; } else { quoted = false ; if ( ! inString ) { if ( ch == '/' ) { ch = in . read ( ) ; if ( ch == '/' ) { while ( ch != '\n' && ch != - 1 && ch != '\r' ) { ch = in . read ( ) ; } } else if ( ch == '*' ) { while ( ch != - 1 ) { ch = in . read ( ) ; if ( ch == '*' ) { ch = in . read ( ) ; while ( ch == '*' && ch != - 1 ) { ch = in . read ( ) ; } if ( ch == '/' ) { ch = read ( ) ; break ; } } } } else { readAheadCh = ch ; ch = '/' ; } } } } } return ch ; } public final Reader chain ( final Reader rdr ) { StripJavaComments newFilter = new StripJavaComments ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '3', '7', '0', '1', '2', '4', '0', '161', '1', '0', '0.928571429', '0.75', '2', '4', '38.5', '1', '0.5', '0']
package org . apache . tools . mail ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null && line . length ( ) >= 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . length ( ) > 3 && line . charAt ( 3 ) == '-' ; } private void append ( String line ) { if ( line . length ( ) > 4 ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } } 	0	['5', '1', '0', '1', '19', '0', '1', '0', '3', '0.5', '108', '1', '0', '0', '0.533333333', '0', '0', '20.2', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; public final class LoadFile extends Task { private File srcFile = null ; private boolean failOnError = true ; private String encoding = null ; private String property = null ; private final Vector filterChains = new Vector ( ) ; public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void setProperty ( final String property ) { this . property = property ; } public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setFailonerror ( final boolean fail ) { failOnError = fail ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "source file not defined" ) ; } if ( property == null ) { throw new BuildException ( "output property not defined" ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; log ( "loading " + srcFile + " into property " + property , Project . MSG_VERBOSE ) ; try { final long len = srcFile . length ( ) ; log ( "file size = " + len , Project . MSG_DEBUG ) ; final int size = ( int ) len ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } String text = "" ; if ( size != 0 ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( size ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; text = crh . readFully ( instream ) ; } if ( text != null ) { if ( text . length ( ) > 0 ) { getProject ( ) . setNewProperty ( property , text ) ; log ( "loaded " + text . length ( ) + " characters" , Project . MSG_VERBOSE ) ; log ( property + " := " + text , Project . MSG_DEBUG ) ; } } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; if ( failOnError ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } } catch ( final BuildException be ) { if ( failOnError ) { throw be ; } else { log ( be . getMessage ( ) , Project . MSG_ERR ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['7', '3', '0', '7', '38', '0', '0', '7', '7', '0.666666667', '262', '1', '0', '0.860465116', '0.342857143', '2', '2', '35.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . util ; import java . util . Hashtable ; import java . util . Enumeration ; public class LazyHashtable extends Hashtable { protected boolean initAllDone = false ; public LazyHashtable ( ) { super ( ) ; } protected void initAll ( ) { if ( initAllDone ) { return ; } initAllDone = true ; } public Enumeration elements ( ) { initAll ( ) ; return super . elements ( ) ; } public boolean isEmpty ( ) { initAll ( ) ; return super . isEmpty ( ) ; } public int size ( ) { initAll ( ) ; return super . size ( ) ; } public boolean contains ( Object value ) { initAll ( ) ; return super . contains ( value ) ; } public boolean containsKey ( Object value ) { initAll ( ) ; return super . containsKey ( value ) ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } public Enumeration keys ( ) { initAll ( ) ; return super . keys ( ) ; } } 	0	['9', '3', '0', '0', '16', '34', '0', '0', '8', '0', '60', '1', '0', '0.8', '0.666666667', '1', '1', '5.555555556', '2', '1', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public ExitException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['3', '5', '0', '2', '8', '0', '2', '0', '3', '0', '28', '1', '0', '0.928571429', '0.666666667', '0', '0', '8', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; public class Move extends Copy { public Move ( ) { super ( ) ; setOverwrite ( true ) ; } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; File f = new File ( fromFile ) ; boolean selfMove = false ; if ( f . exists ( ) ) { String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = ( String ) toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toFile ) ; if ( ( i + 1 ) == toFiles . length && ! selfMove ) { moveFile ( f , d , filtering , forceOverwrite ) ; } else { copyFile ( f , d , filtering , forceOverwrite ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . keys ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String fromDirName = ( String ) e . nextElement ( ) ; String [ ] toDirNames = ( String [ ] ) dirCopyMap . get ( fromDirName ) ; boolean selfMove = false ; for ( int i = 0 ; i < toDirNames . length ; i ++ ) { if ( fromDirName . equals ( toDirNames [ i ] ) ) { log ( "Skipping self-move of " + fromDirName , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toDirNames [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } File fromDir = new File ( fromDirName ) ; if ( ! selfMove && okToDelete ( fromDir ) ) { deleteDir ( fromDir ) ; } } if ( createCount > 0 ) { log ( "Moved " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } private void moveFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { boolean moved = false ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! moved ) { copyFile ( fromFile , toFile , filtering , overwrite ) ; if ( ! fromFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + fromFile . getAbsolutePath ( ) ) ; } } } private void copyFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( fromFile , toFile , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , getOutputEncoding ( ) , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = true ; if ( ( getFilterSets ( ) != null && getFilterSets ( ) . size ( ) > 0 ) || ( getFilterChains ( ) != null && getFilterChains ( ) . size ( ) > 0 ) ) { renamed = false ; } else { if ( ! filtering ) { String parentPath = destFile . getParent ( ) ; if ( parentPath != null ) { File parent = new File ( parentPath ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } } if ( destFile . exists ( ) && destFile . isFile ( ) ) { if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } } renamed = sourceFile . renameTo ( destFile ) ; } else { renamed = false ; } } return renamed ; } } 	0	['7', '4', '0', '9', '50', '21', '0', '9', '1', '2', '686', '0', '0', '0.930232558', '0.714285714', '4', '4', '97', '21', '5.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { String FILE_PROTOCOL_PREFIX = "file://" ; void setStylesheet ( File stylesheet ) throws Exception ; void addParam ( String name , String expression ) throws Exception ; void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; public class EmailAddress { private String name ; private String address ; public EmailAddress ( ) { } public EmailAddress ( String email ) { final int minLen = 9 ; int len = email . length ( ) ; if ( len > minLen ) { if ( ( email . charAt ( 0 ) == '<' || email . charAt ( 1 ) == '<' ) && ( email . charAt ( len - 1 ) == '>' || email . charAt ( len - 2 ) == '>' ) ) { this . address = trim ( email , true ) ; return ; } } int paramDepth = 0 ; int start = 0 ; int end = 0 ; int nStart = 0 ; int nEnd = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = email . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; nStart = i + 1 ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; nEnd = i ; } } else if ( paramDepth == 0 && c == '<' ) { if ( start == 0 ) { nEnd = i ; } start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; if ( end != len - 1 ) { nStart = i + 1 ; } } } if ( end == 0 ) { end = len ; } if ( nEnd == 0 ) { nEnd = len ; } this . address = trim ( email . substring ( start , end ) , true ) ; this . name = trim ( email . substring ( nStart , nEnd ) , false ) ; if ( this . name . length ( ) + this . address . length ( ) > len ) { this . name = null ; } } private String trim ( String t , boolean trimAngleBrackets ) { int start = 0 ; int end = t . length ( ) ; boolean trim = false ; do { trim = false ; if ( t . charAt ( end - 1 ) == ')' || ( t . charAt ( end - 1 ) == '>' && trimAngleBrackets ) || ( t . charAt ( end - 1 ) == '"' && t . charAt ( end - 2 ) != '\\' ) || t . charAt ( end - 1 ) <= ' ' ) { trim = true ; end -- ; } if ( t . charAt ( start ) == '(' || ( t . charAt ( start ) == '<' && trimAngleBrackets ) || t . charAt ( start ) == '"' || t . charAt ( start ) <= ' ' ) { trim = true ; start ++ ; } } while ( trim ) ; return t . substring ( start , end ) ; } public void setName ( String name ) { this . name = name ; } public void setAddress ( String address ) { this . address = address ; } public String toString ( ) { if ( name == null ) { return address ; } else { return name + " <" + address + ">" ; } } public String getAddress ( ) { return address ; } public String getName ( ) { return name ; } } 	0	['8', '1', '0', '4', '15', '6', '4', '0', '7', '0.571428571', '286', '1', '0', '0', '0.541666667', '0', '0', '34.5', '13', '2.375', '0']
package org . apache . tools . ant . util ; public interface TimeoutObserver { void timeoutOccured ( Watchdog w ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class SunRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.rmi.rmic.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use SUN rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting SUN rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '22', '3', '1', '7', '2', '1', '152', '0', '0', '0.866666667', '0.5', '0', '0', '48.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . zip . ZipException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; private Resource lastScannedResource ; private Hashtable myentries ; private String encoding ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String [ ] getIncludedFiles ( ) { if ( srcFile != null ) { Vector myvector = new Vector ( ) ; scanme ( ) ; for ( Enumeration e = myentries . elements ( ) ; e . hasMoreElements ( ) ; ) { Resource myresource = ( Resource ) e . nextElement ( ) ; if ( ! myresource . isDirectory ( ) && match ( myresource . getName ( ) ) ) { myvector . addElement ( myresource . getName ( ) ) ; } } String [ ] files = new String [ myvector . size ( ) ] ; myvector . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } else { return super . getIncludedFiles ( ) ; } } public String [ ] getIncludedDirectories ( ) { if ( srcFile != null ) { Vector myvector = new Vector ( ) ; scanme ( ) ; for ( Enumeration e = myentries . elements ( ) ; e . hasMoreElements ( ) ; ) { Resource myresource = ( Resource ) e . nextElement ( ) ; if ( myresource . isDirectory ( ) && match ( myresource . getName ( ) ) ) { myvector . addElement ( myresource . getName ( ) ) ; } } String [ ] files = new String [ myvector . size ( ) ] ; myvector . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } else { return super . getIncludedDirectories ( ) ; } } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } public Resource getResource ( String name ) { if ( srcFile == null ) { return super . getResource ( name ) ; } else if ( name . equals ( "" ) ) { return new Resource ( "" , true , Long . MAX_VALUE , true ) ; } scanme ( ) ; if ( myentries . containsKey ( name ) ) { return ( Resource ) myentries . get ( name ) ; } else if ( myentries . containsKey ( name + "/" ) ) { return ( Resource ) myentries . get ( name + "/" ) ; } else { return new Resource ( name ) ; } } private void scanme ( ) { Resource thisresource = new Resource ( srcFile . getAbsolutePath ( ) , srcFile . exists ( ) , srcFile . lastModified ( ) ) ; if ( lastScannedResource != null && lastScannedResource . getName ( ) . equals ( thisresource . getName ( ) ) && lastScannedResource . getLastModified ( ) == thisresource . getLastModified ( ) ) { return ; } ZipEntry entry = null ; ZipFile zf = null ; myentries = new Hashtable ( ) ; try { try { zf = new ZipFile ( srcFile , encoding ) ; } catch ( ZipException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { entry = ( ZipEntry ) e . nextElement ( ) ; myentries . put ( new String ( entry . getName ( ) ) , new Resource ( entry . getName ( ) , true , entry . getTime ( ) , entry . isDirectory ( ) ) ) ; } } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException ex ) { } } } lastScannedResource = thisresource ; } } 	0	['9', '2', '0', '7', '50', '14', '2', '5', '8', '0.5625', '348', '1', '1', '0.884057971', '0.481481481', '2', '4', '37.22222222', '8', '3.4444', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public class DepthSelector extends BaseExtendSelector { public int min = - 1 ; public int max = - 1 ; public static final String MIN_KEY = "min" ; public static final String MAX_KEY = "max" ; public DepthSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{depthselector min: " ) ; buf . append ( min ) ; buf . append ( " max: " ) ; buf . append ( max ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMin ( int min ) { this . min = min ; } public void setMax ( int max ) { this . max = max ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MIN_KEY . equalsIgnoreCase ( paramname ) ) { try { setMin ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid minimum value " + parameters [ i ] . getValue ( ) ) ; } } else if ( MAX_KEY . equalsIgnoreCase ( paramname ) ) { try { setMax ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid maximum value " + parameters [ i ] . getValue ( ) ) ; } } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( min < 0 && max < 0 ) { setError ( "You must set at least one of the min or the " + "max levels." ) ; } if ( max < min && max > - 1 ) { setError ( "The maximum depth is lower than the minimum." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int depth = - 1 ; String absBase = basedir . getAbsolutePath ( ) ; String absFile = file . getAbsolutePath ( ) ; StringTokenizer tokBase = new StringTokenizer ( absBase , File . separator ) ; StringTokenizer tokFile = new StringTokenizer ( absFile , File . separator ) ; while ( tokFile . hasMoreTokens ( ) ) { String filetoken = tokFile . nextToken ( ) ; if ( tokBase . hasMoreTokens ( ) ) { String basetoken = tokBase . nextToken ( ) ; if ( ! basetoken . equals ( filetoken ) ) { throw new BuildException ( "File " + filename + " does not appear within " + absBase + "directory" ) ; } } else { depth += 1 ; if ( max > - 1 && depth > max ) { return false ; } } } if ( tokBase . hasMoreTokens ( ) ) { throw new BuildException ( "File " + filename + " is outside of " + absBase + "directory tree" ) ; } if ( min > - 1 && depth < min ) { return false ; } return true ; } } 	0	['7', '5', '0', '9', '26', '0', '5', '4', '7', '0.666666667', '263', '0', '0', '0.863636364', '0.342857143', '2', '5', '36', '8', '3', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . util . FileUtils ; public class CvsTagDiff extends AbstractCvsTask { static final String FILE_STRING = "File " ; static final String TO_STRING = " to " ; static final String FILE_IS_NEW = " is new;" ; static final String REVISION = "revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private String mypackage ; private String mystartTag ; private String myendTag ; private String mystartDate ; private String myendDate ; private File mydestfile ; private FileUtils myfileUtils = FileUtils . newFileUtils ( ) ; public void setPackage ( String p ) { mypackage = p ; } public void setStartTag ( String s ) { mystartTag = s ; } public void setStartDate ( String s ) { mystartDate = s ; } public void setEndTag ( String s ) { myendTag = s ; } public void setEndDate ( String s ) { myendDate = s ; } public void setDestFile ( File f ) { mydestfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; addCommandArgument ( "rdiff" ) ; addCommandArgument ( "-s" ) ; if ( mystartTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( mystartTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( mystartDate ) ; } if ( myendTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( myendTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( myendDate ) ; } StringTokenizer myTokenizer = new StringTokenizer ( mypackage ) ; while ( myTokenizer . hasMoreTokens ( ) ) { addCommandArgument ( myTokenizer . nextToken ( ) ) ; } setCommand ( "" ) ; File tmpFile = null ; try { tmpFile = myfileUtils . createTempFile ( "cvstagdiff" , ".log" , null ) ; tmpFile . deleteOnExit ( ) ; setOutput ( tmpFile ) ; super . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; String toBeRemoved = FILE_STRING + mypackage + "/" ; int headerLength = toBeRemoved . length ( ) ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { if ( line . length ( ) > headerLength ) { if ( line . startsWith ( toBeRemoved ) ) { line = line . substring ( headerLength ) ; } else { line = line . substring ( FILE_STRING . length ( ) ) ; } if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + TO_STRING . length ( ) ) ; entry = new CvsTagEntry ( filename , revision , prevRevision ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , null , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( mydestfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; writer . print ( "<tagdiff " ) ; if ( mystartTag != null ) { writer . print ( "startTag=\"" + mystartTag + "\" " ) ; } else { writer . print ( "startDate=\"" + mystartDate + "\" " ) ; } if ( myendTag != null ) { writer . print ( "endTag=\"" + myendTag + "\" " ) ; } else { writer . print ( "endDate=\"" + myendDate + "\" " ) ; } writer . print ( "cvsroot=\"" + getCvsRoot ( ) + "\" " ) ; writer . print ( "package=\"" + mypackage + "\" " ) ; writer . println ( ">" ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( writer , entries [ i ] ) ; } writer . println ( "</tagdiff>" ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { log ( ioe . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagEntry ( PrintWriter writer , CvsTagEntry entry ) { writer . println ( "\t<entry>" ) ; writer . println ( "\t\t<file>" ) ; writer . println ( "\t\t\t<name>" + entry . getFile ( ) + "</name>" ) ; if ( entry . getRevision ( ) != null ) { writer . println ( "\t\t\t<revision>" + entry . getRevision ( ) + "</revision>" ) ; } if ( entry . getPreviousRevision ( ) != null ) { writer . println ( "\t\t\t<prevrevision>" + entry . getPreviousRevision ( ) + "</prevrevision>" ) ; } writer . println ( "\t\t</file>" ) ; writer . println ( "\t</entry>" ) ; } private void validate ( ) throws BuildException { if ( null == mypackage ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == mydestfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == mystartTag && null == mystartDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != mystartTag && null != mystartDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == myendTag && null == myendDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != myendTag && null != myendDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	0	['12', '4', '0', '5', '60', '16', '0', '5', '8', '0.902097902', '720', '0.538461538', '1', '0.876404494', '0.305555556', '1', '2', '57.91666667', '3', '1.0833', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . util . Date ; import java . util . Vector ; class CVSEntry { private Date m_date ; private String m_author ; private final String m_comment ; private final Vector m_files = new Vector ( ) ; public CVSEntry ( Date date , String author , String comment ) { m_date = date ; m_author = author ; m_comment = comment ; } public void addFile ( String file , String revision ) { m_files . addElement ( new RCSFile ( file , revision ) ) ; } public void addFile ( String file , String revision , String previousRevision ) { m_files . addElement ( new RCSFile ( file , revision , previousRevision ) ) ; } Date getDate ( ) { return m_date ; } void setAuthor ( final String author ) { m_author = author ; } String getAuthor ( ) { return m_author ; } String getComment ( ) { return m_comment ; } Vector getFiles ( ) { return m_files ; } public String toString ( ) { return getAuthor ( ) + "\n" + getDate ( ) + "\n" + getFiles ( ) + "\n" + getComment ( ) ; } } 	0	['9', '1', '0', '4', '18', '14', '3', '1', '4', '0.65625', '88', '1', '0', '0', '0.518518519', '0', '0', '8.333333333', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property = null ; private String value = "true" ; public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <condition>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<condition>" ) ; } if ( property == null ) { throw new BuildException ( "The property attribute is required." ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { log ( "Condition true; setting " + property + " to " + value , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { log ( "Condition false; not setting " + property , Project . MSG_DEBUG ) ; } } } 	0	['4', '3', '0', '5', '16', '0', '0', '5', '4', '0.333333333', '95', '1', '0', '0.914285714', '0.75', '0', '0', '22.25', '1', '0.75', '0']
package org . apache . tools . ant . types ; import java . security . UnresolvedPermission ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; public class Permissions { private List grantedPermissions = new LinkedList ( ) ; private List revokedPermissions = new LinkedList ( ) ; private java . security . Permissions granted = null ; private SecurityManager origSm = null ; private boolean active = false ; private boolean delegateToOldSM = false ; public Permissions ( ) { } public Permissions ( boolean delegateToOldSM ) { this . delegateToOldSM = delegateToOldSM ; } public void addConfiguredGrant ( Permissions . Permission perm ) { grantedPermissions . add ( perm ) ; } public void addConfiguredRevoke ( Permissions . Permission perm ) { revokedPermissions . add ( perm ) ; } public void setSecurityManager ( ) throws BuildException { origSm = System . getSecurityManager ( ) ; init ( ) ; System . setSecurityManager ( new MySM ( ) ) ; active = true ; } private void init ( ) throws BuildException { granted = new java . security . Permissions ( ) ; for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Revoked permission " + p + " does not contain a class." ) ; } } for ( Iterator i = grantedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Granted permission " + p + " does not contain a class." ) ; } else { java . security . Permission perm = new UnresolvedPermission ( p . getClassName ( ) , p . getName ( ) , p . getActions ( ) , null ) ; granted . add ( perm ) ; } } granted . add ( new java . net . SocketPermission ( "localhost:1024-" , "listen" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor.url" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.class.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.arch" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.encoding" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "path.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "line.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.name" , "read" ) ) ; } public void restoreSecurityManager ( ) { active = false ; System . setSecurityManager ( origSm ) ; } private class MySM extends SecurityManager { public void checkExit ( int status ) { java . security . Permission perm = new java . lang . RuntimePermission ( "exitVM" , null ) ; try { checkPermission ( perm ) ; } catch ( SecurityException e ) { throw new ExitException ( e . getMessage ( ) , status ) ; } } public void checkPermission ( java . security . Permission perm ) { if ( active ) { if ( delegateToOldSM && ! perm . getName ( ) . equals ( "exitVM" ) ) { boolean permOK = false ; if ( granted . implies ( perm ) ) { permOK = true ; } checkRevoked ( perm ) ; if ( ! permOK && origSm != null ) { origSm . checkPermission ( perm ) ; } } else { if ( ! granted . implies ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was not granted." ) ; } checkRevoked ( perm ) ; } } } private void checkRevoked ( java . security . Permission perm ) { for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { if ( ( ( Permissions . Permission ) i . next ( ) ) . matches ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was revoked." ) ; } } } } public static class Permission { private String className ; private String name ; private String actionString ; private Set actions ; public void setClass ( String aClass ) { className = aClass . trim ( ) ; } public String getClassName ( ) { return className ; } public void setName ( String aName ) { name = aName . trim ( ) ; } public String getName ( ) { return name ; } public void setActions ( String actions ) { actionString = actions ; if ( actions . length ( ) > 0 ) { this . actions = parseActions ( actions ) ; } } public String getActions ( ) { return actionString ; } boolean matches ( java . security . Permission perm ) { if ( ! className . equals ( perm . getClass ( ) . getName ( ) ) ) { return false ; } if ( name != null ) { if ( name . endsWith ( "*" ) ) { if ( ! perm . getName ( ) . startsWith ( name . substring ( 0 , name . length ( ) - 1 ) ) ) { return false ; } } else { if ( ! name . equals ( perm . getName ( ) ) ) { return false ; } } } if ( actions != null ) { Set as = parseActions ( perm . getActions ( ) ) ; int size = as . size ( ) ; as . removeAll ( actions ) ; if ( as . size ( ) == size ) { return false ; } } return true ; } private Set parseActions ( String actions ) { Set result = new HashSet ( ) ; StringTokenizer tk = new StringTokenizer ( actions , "," ) ; while ( tk . hasMoreTokens ( ) ) { String item = tk . nextToken ( ) . trim ( ) ; if ( ! item . equals ( "" ) ) { result . add ( item ) ; } } return result ; } public String toString ( ) { return ( "Permission: " + className + " (\"" + name + "\", \"" + actions + "\")" ) ; } } } 	0	['12', '1', '0', '6', '34', '4', '3', '4', '6', '0.651515152', '367', '1', '0', '0', '0.3125', '0', '0', '29.08333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Dirname extends Task { private File file ; private String property ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } else { String value = file . getParent ( ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['4', '3', '0', '5', '10', '2', '0', '5', '4', '0.666666667', '48', '1', '0', '0.925', '0.5', '0', '0', '10.5', '1', '0.75', '0']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	0	['8', '1', '0', '4', '39', '22', '1', '3', '6', '0.785714286', '377', '0.5', '0', '0', '0.166666667', '0', '0', '45.875', '3', '1.25', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	0	['28', '4', '5', '23', '45', '348', '6', '23', '28', '0.037037037', '204', '1', '0', '0.564516129', '0.079192547', '0', '0', '6.25', '4', '1.2143', '0']
package org . apache . tools . ant . util ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import java . util . Vector ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } return v1 . equals ( v2 ) ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } public static void putAll ( Dictionary m1 , Dictionary m2 ) { for ( Enumeration it = m2 . keys ( ) ; it . hasMoreElements ( ) ; ) { Object key = it . nextElement ( ) ; m1 . put ( key , m2 . get ( key ) ) ; } } public static final class EmptyEnumeration implements Enumeration { public EmptyEnumeration ( ) { } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) throws NoSuchElementException { throw new NoSuchElementException ( ) ; } } } 	0	['4', '1', '0', '3', '13', '6', '3', '0', '4', '2', '86', '0', '0', '0', '0.333333333', '1', '1', '20.5', '8', '3.5', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public interface RegexpMatcher { int MATCH_DEFAULT = 0x00000000 ; int MATCH_CASE_INSENSITIVE = 0x00000100 ; int MATCH_MULTILINE = 0x00001000 ; int MATCH_SINGLELINE = 0x00010000 ; void setPattern ( String pattern ) throws BuildException ; String getPattern ( ) throws BuildException ; boolean matches ( String argument ) throws BuildException ; Vector getGroups ( String argument ) throws BuildException ; boolean matches ( String input , int options ) throws BuildException ; Vector getGroups ( String input , int options ) throws BuildException ; } 	0	['6', '1', '0', '11', '6', '15', '10', '1', '6', '1.2', '10', '0', '0', '0', '0.722222222', '0', '0', '0', '1', '1', '0']
package org . apache . tools . bzip2 ; import java . io . InputStream ; import java . io . IOException ; public class CBZip2InputStream extends InputStream implements BZip2Constants { private static void cadvise ( ) { System . out . println ( "CRC Error" ) ; } private static void badBGLengths ( ) { cadvise ( ) ; } private static void bitStreamEOF ( ) { cadvise ( ) ; } private static void compressedStreamEOF ( ) { cadvise ( ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } private int last ; private int origPtr ; private int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private int [ ] tt ; private char [ ] ll8 ; private int [ ] unzftab = new int [ 256 ] ; private int [ ] [ ] limit = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] [ ] base = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] [ ] perm = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] minLens = new int [ N_GROUPS ] ; private InputStream bsStream ; private boolean streamEnd = false ; private int currentChar = - 1 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; private static final int RAND_PART_B_STATE = 3 ; private static final int RAND_PART_C_STATE = 4 ; private static final int NO_RAND_PART_A_STATE = 5 ; private static final int NO_RAND_PART_B_STATE = 6 ; private static final int NO_RAND_PART_C_STATE = 7 ; private int currentState = START_BLOCK_STATE ; private int storedBlockCRC , storedCombinedCRC ; private int computedBlockCRC , computedCombinedCRC ; int i2 , count , chPrev , ch2 ; int i , tPos ; int rNToGo = 0 ; int rTPos = 0 ; int j2 ; char z ; public CBZip2InputStream ( InputStream zStream ) { ll8 = null ; tt = null ; bsSetStream ( zStream ) ; initialize ( ) ; initBlock ( ) ; setupBlock ( ) ; } public int read ( ) { if ( streamEnd ) { return - 1 ; } else { int retChar = currentChar ; switch ( currentState ) { case START_BLOCK_STATE : break ; case RAND_PART_A_STATE : break ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : break ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : break ; } return retChar ; } } private void initialize ( ) { char magic3 , magic4 ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; if ( magic3 != 'h' || magic4 < '1' || magic4 > '9' ) { bsFinishedWithStream ( ) ; streamEnd = true ; return ; } setDecompressStructureSizes ( magic4 - '0' ) ; computedCombinedCRC = 0 ; } private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 ) { complete ( ) ; return ; } if ( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; } private void endBlock ( ) { computedBlockCRC = mCrc . getFinalCRC ( ) ; if ( storedBlockCRC != computedBlockCRC ) { crcError ( ) ; } computedCombinedCRC = ( computedCombinedCRC << 1 ) | ( computedCombinedCRC > > > 31 ) ; computedCombinedCRC ^= computedBlockCRC ; } private void complete ( ) { storedCombinedCRC = bsGetInt32 ( ) ; if ( storedCombinedCRC != computedCombinedCRC ) { crcError ( ) ; } bsFinishedWithStream ( ) ; streamEnd = true ; } private static void blockOverrun ( ) { cadvise ( ) ; } private static void badBlockHeader ( ) { cadvise ( ) ; } private static void crcError ( ) { cadvise ( ) ; } private void bsFinishedWithStream ( ) { try { if ( this . bsStream != null ) { if ( this . bsStream != System . in ) { this . bsStream . close ( ) ; this . bsStream = null ; } } } catch ( IOException ioe ) { } } private void bsSetStream ( InputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; } private int bsR ( int n ) { int v ; while ( bsLive < n ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } v = ( bsBuff > > ( bsLive - n ) ) & ( ( 1 << n ) - 1 ) ; bsLive -= n ; return v ; } private char bsGetUChar ( ) { return ( char ) bsR ( 8 ) ; } private int bsGetint ( ) { int u = 0 ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; return u ; } private int bsGetIntVS ( int numBits ) { return ( int ) bsR ( numBits ) ; } private int bsGetInt32 ( ) { return ( int ) bsGetint ( ) ; } private void hbCreateDecodeTables ( int [ ] limit , int [ ] base , int [ ] perm , char [ ] length , int minLen , int maxLen , int alphaSize ) { int pp , i , j , vec ; pp = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { for ( j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ] = j ; pp ++ ; } } } for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] = 0 ; } for ( i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( i = 1 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] += base [ i - 1 ] ; } for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { limit [ i ] = 0 ; } vec = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { vec += ( base [ i + 1 ] - base [ i ] ) ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } } private void recvDecodingTables ( ) { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int i , j , t , nGroups , nSelectors , alphaSize ; int minLen , maxLen ; boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { if ( bsR ( 1 ) == 1 ) { inUse16 [ i ] = true ; } else { inUse16 [ i ] = false ; } } for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( bsR ( 1 ) == 1 ) { inUse [ i * 16 + j ] = true ; } } } } makeMaps ( ) ; alphaSize = nInUse + 2 ; nGroups = bsR ( 3 ) ; nSelectors = bsR ( 15 ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { j = 0 ; while ( bsR ( 1 ) == 1 ) { j ++ ; } selectorMtf [ i ] = ( char ) j ; } { char [ ] pos = new char [ N_GROUPS ] ; char tmp , v ; for ( v = 0 ; v < nGroups ; v ++ ) { pos [ v ] = v ; } for ( i = 0 ; i < nSelectors ; i ++ ) { v = selectorMtf [ i ] ; tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( bsR ( 1 ) == 1 ) { if ( bsR ( 1 ) == 0 ) { curr ++ ; } else { curr -- ; } } len [ t ] [ i ] = ( char ) curr ; } } for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } hbCreateDecodeTables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; minLens [ t ] = minLen ; } } private void getAndMoveToFrontDecode ( ) { char [ ] yy = new char [ 256 ] ; int i , j , nextSym , limitLast ; int EOB , groupNo , groupPos ; limitLast = baseBlockSize * blockSize100k ; origPtr = bsGetIntVS ( 24 ) ; recvDecodingTables ( ) ; EOB = nInUse + 1 ; groupNo = - 1 ; groupPos = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { unzftab [ i ] = 0 ; } for ( i = 0 ; i <= 255 ; i ++ ) { yy [ i ] = ( char ) i ; } last = - 1 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } while ( true ) { if ( nextSym == EOB ) { break ; } if ( nextSym == RUNA || nextSym == RUNB ) { char ch ; int s = - 1 ; int N = 1 ; do { if ( nextSym == RUNA ) { s = s + ( 0 + 1 ) * N ; } else if ( nextSym == RUNB ) { s = s + ( 1 + 1 ) * N ; } N = N * 2 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } } while ( nextSym == RUNA || nextSym == RUNB ) ; s ++ ; ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch ] += s ; while ( s > 0 ) { last ++ ; ll8 [ last ] = ch ; s -- ; } if ( last >= limitLast ) { blockOverrun ( ) ; } continue ; } else { char tmp ; last ++ ; if ( last >= limitLast ) { blockOverrun ( ) ; } tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] ] ++ ; ll8 [ last ] = seqToUnseq [ tmp ] ; j = nextSym - 1 ; for ( ; j > 3 ; j -= 4 ) { yy [ j ] = yy [ j - 1 ] ; yy [ j - 1 ] = yy [ j - 2 ] ; yy [ j - 2 ] = yy [ j - 3 ] ; yy [ j - 3 ] = yy [ j - 4 ] ; } for ( ; j > 0 ; j -- ) { yy [ j ] = yy [ j - 1 ] ; } yy [ 0 ] = tmp ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } continue ; } } } private void setupBlock ( ) { int [ ] cftab = new int [ 257 ] ; char ch ; cftab [ 0 ] = 0 ; for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] = unzftab [ i - 1 ] ; } for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] += cftab [ i - 1 ] ; } for ( i = 0 ; i <= last ; i ++ ) { ch = ( char ) ll8 [ i ] ; tt [ cftab [ ch ] ] = i ; cftab [ ch ] ++ ; } cftab = null ; tPos = tt [ origPtr ] ; count = 0 ; i2 = 0 ; ch2 = 256 ; if ( blockRandomised ) { rNToGo = 0 ; rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; ch2 ^= ( int ) ( ( rNToGo == 1 ) ? 1 : 0 ) ; i2 ++ ; currentChar = ch2 ; currentState = RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupNoRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; i2 ++ ; currentChar = ch2 ; currentState = NO_RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupRandPartB ( ) { if ( ch2 != chPrev ) { currentState = RAND_PART_A_STATE ; count = 1 ; setupRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; z ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; j2 = 0 ; currentState = RAND_PART_C_STATE ; setupRandPartC ( ) ; } else { currentState = RAND_PART_A_STATE ; setupRandPartA ( ) ; } } } private void setupRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupRandPartA ( ) ; } } private void setupNoRandPartB ( ) { if ( ch2 != chPrev ) { currentState = NO_RAND_PART_A_STATE ; count = 1 ; setupNoRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; currentState = NO_RAND_PART_C_STATE ; j2 = 0 ; setupNoRandPartC ( ) ; } else { currentState = NO_RAND_PART_A_STATE ; setupNoRandPartA ( ) ; } } } private void setupNoRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = NO_RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupNoRandPartA ( ) ; } } private void setDecompressStructureSizes ( int newSize100k ) { if ( ! ( 0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9 ) ) { } blockSize100k = newSize100k ; if ( newSize100k == 0 ) { return ; } int n = baseBlockSize * newSize100k ; ll8 = new char [ n ] ; tt = new int [ n ] ; } } 	0	['32', '2', '0', '4', '40', '330', '2', '2', '2', '0.772759857', '2011', '0.777777778', '1', '0.225', '0.20625', '1', '1', '60.4375', '26', '4.0938', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLiaison2 extends XSLTLiaison { void configure ( XSLTProcess xsltTask ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	0	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . PrintWriter ; import org . apache . tools . ant . ProjectComponent ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; private String charset = null ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream ps ) throws IOException { PrintWriter out = charset != null ? new PrintWriter ( new OutputStreamWriter ( ps , charset ) ) : new PrintWriter ( ps ) ; if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . substring ( 0 ) ) ) ; } out . flush ( ) ; } public boolean isMimeTypeSpecified ( ) { return specified ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['11', '2', '0', '6', '26', '0', '4', '2', '11', '0.58', '181', '1', '0', '0.529411765', '0.409090909', '0', '0', '15', '1', '0.7273', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public class EscapeUnicode extends BaseParamFilterReader implements ChainableReader { private StringBuffer unicodeBuf ; public EscapeUnicode ( ) { super ( ) ; unicodeBuf = new StringBuffer ( ) ; } public EscapeUnicode ( final Reader in ) { super ( in ) ; unicodeBuf = new StringBuffer ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( unicodeBuf . length ( ) == 0 ) { ch = in . read ( ) ; if ( ch != - 1 ) { char achar = ( char ) ch ; if ( achar >= '' ) { unicodeBuf = new StringBuffer ( "u0000" ) ; String s = Integer . toHexString ( ch ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { unicodeBuf . setCharAt ( unicodeBuf . length ( ) - s . length ( ) + i , s . charAt ( i ) ) ; } ch = '\\' ; } } } else { ch = ( int ) unicodeBuf . charAt ( 0 ) ; unicodeBuf . deleteCharAt ( 0 ) ; } return ch ; } public final Reader chain ( final Reader rdr ) { EscapeUnicode newFilter = new EscapeUnicode ( rdr ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { } } 	0	['5', '5', '0', '4', '19', '4', '1', '3', '4', '0.25', '107', '1', '0', '0.903225806', '0.7', '2', '5', '20.2', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( getProject ( ) . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = getProject ( ) . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not " + "found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = getProject ( ) . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , getLocation ( ) ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , getLocation ( ) ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = getProject ( ) . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; public StreamPumper ( InputStream is , int messageLevel ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; } public void pumpStream ( ) throws IOException { if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '6', '44', '21', '1', '6', '7', '0.740740741', '367', '1', '0', '0.804347826', '0.45', '0', '0', '35.1', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Unpack extends Task { protected File source ; protected File dest ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( getProject ( ) . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( getProject ( ) . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { source = src ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No Src specified" , getLocation ( ) ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "Src doesn't exist" , getLocation ( ) ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , getLocation ( ) ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; } 	0	['10', '3', '2', '7', '26', '29', '2', '5', '6', '0.555555556', '162', '1', '0', '0.804347826', '0.5', '0', '0', '15', '4', '1.2', '0']
package org . apache . tools . ant . types ; public class DirSet extends AbstractFileSet { public DirSet ( ) { super ( ) ; } protected DirSet ( DirSet dirset ) { super ( dirset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	0	['3', '4', '0', '9', '9', '3', '5', '4', '2', '2', '23', '0', '0', '0.988636364', '0.666666667', '3', '4', '6.666666667', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( getProject ( ) , d , getLocation ( ) ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; setProperty ( "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } private void setProperty ( String name , String value ) { getProject ( ) . setNewProperty ( prefix + name , value ) ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } Tstamp . this . setProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Hashtable calendarFields = new Hashtable ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['6', '3', '0', '6', '26', '3', '1', '6', '4', '0.4', '134', '1', '0', '0.880952381', '0.5', '0', '0', '21', '2', '1', '0']
package org . apache . tools . ant . input ; public class InputRequest { private String prompt ; private String input ; public InputRequest ( String prompt ) { if ( prompt == null ) { throw new IllegalArgumentException ( "prompt must not be null" ) ; } this . prompt = prompt ; } public String getPrompt ( ) { return prompt ; } public void setInput ( String input ) { this . input = input ; } public boolean isInputValid ( ) { return true ; } public String getInput ( ) { return input ; } } 	0	['5', '1', '1', '5', '7', '6', '5', '0', '5', '0.75', '32', '1', '0', '0', '0.7', '0', '0', '5', '1', '0.8', '0']
package org . apache . tools . ant . util ; import java . util . Enumeration ; import java . util . Vector ; public class Watchdog implements Runnable { private Vector observers = new Vector ( 1 ) ; private long timeout = - 1 ; private boolean stopped = false ; public Watchdog ( long timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public void addTimeoutObserver ( TimeoutObserver to ) { observers . addElement ( to ) ; } public void removeTimeoutObserver ( TimeoutObserver to ) { observers . removeElement ( to ) ; } protected final void fireTimeoutOccured ( ) { Enumeration e = observers . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( TimeoutObserver ) e . nextElement ( ) ) . timeoutOccured ( this ) ; } } public synchronized void start ( ) { stopped = false ; Thread t = new Thread ( this , "WATCHDOG" ) ; t . setDaemon ( true ) ; t . start ( ) ; } public synchronized void stop ( ) { stopped = true ; notifyAll ( ) ; } public synchronized void run ( ) { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( ! stopped && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } if ( ! stopped ) { fireTimeoutOccured ( ) ; } } } 	0	['7', '1', '0', '3', '22', '0', '3', '1', '6', '0.555555556', '112', '1', '0', '0', '0.476190476', '0', '0', '14.57142857', '4', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class ExecTask extends Task { private String os ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private String resultProperty ; private boolean failIfExecFails = true ; private String executable ; private boolean resolveExecutable = false ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; private Redirector redirector = new Redirector ( this ) ; private boolean vmLauncher = true ; public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void setTimeout ( Integer value ) { if ( value == null ) { timeout = null ; } else { setTimeout ( new Long ( value . intValue ( ) ) ) ; } incompatibleWithSpawn = true ; } public void setExecutable ( String value ) { this . executable = value ; cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { redirector . setOutput ( out ) ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { redirector . setInput ( input ) ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { redirector . setInputString ( inputString ) ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn = true ; } public void setError ( File error ) { redirector . setError ( error ) ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn = true ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setResolveExecutable ( boolean resolveExecutable ) { this . resolveExecutable = resolveExecutable ; } public boolean getResolveExecutable ( ) { return resolveExecutable ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; incompatibleWithSpawn = true ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } protected String resolveExecutable ( String exec , boolean searchPath ) { if ( ! resolveExecutable ) { return exec ; } File executableFile = getProject ( ) . resolveFile ( exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( dir != null ) { executableFile = fileUtils . resolveFile ( dir , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } if ( searchPath ) { Vector env = Execute . getProcEnvironment ( ) ; Enumeration e = env . elements ( ) ; Path p = null ; while ( e . hasMoreElements ( ) ) { String line = ( String ) e . nextElement ( ) ; if ( line . startsWith ( "PATH=" ) || line . startsWith ( "Path=" ) ) { p = new Path ( getProject ( ) , line . substring ( 5 ) ) ; break ; } } if ( p != null ) { String [ ] dirs = p . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { executableFile = fileUtils . resolveFile ( new File ( dirs [ i ] ) , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } } } return exec ; } public void execute ( ) throws BuildException { File savedDir = dir ; cmdl . setExecutable ( resolveExecutable ( executable , false ) ) ; checkConfiguration ( ) ; if ( isValidOs ( ) ) { try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , getLocation ( ) ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not " + "exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a " + "directory" ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn does not also not allow timeout" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute which is " + "not compatible with spawn" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; exe . setSpawn ( spawn ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int returnCode = - 1 ; if ( ! spawn ) { returnCode = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { String msg = "Timeout: killed the sub-process" ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_WARN ) ; } } maybeSetResultPropertyValue ( returnCode ) ; if ( Execute . isFailure ( returnCode ) ) { if ( failOnError ) { throw new BuildException ( getTaskType ( ) + " returned: " + returnCode , getLocation ( ) ) ; } else { log ( "Result: " + returnCode , Project . MSG_ERR ) ; } } redirector . complete ( ) ; } else { exe . spawn ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , getLocation ( ) ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return redirector . createHandler ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { } } 	0	['36', '3', '1', '19', '106', '272', '4', '15', '26', '0.862857143', '712', '1', '3', '0.513888889', '0.175', '0', '0', '18.36111111', '12', '1.3889', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { void setJavac ( Javac attributes ) ; boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; public interface ResourceFactory { Resource getResource ( String name ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Random ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { String tempFileName = "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; tmpFile = new File ( tempFileName ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '30', '0', '0', '5', '0', '0', '189', '1', '2', '0', '0.6', '0', '0', '92', '10', '5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  " + "Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , getLocation ( ) ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , getLocation ( ) ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class FileList extends DataType { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof FileList ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a filelist" ; throw new BuildException ( msg ) ; } else { return ( FileList ) o ; } } } 	0	['8', '3', '0', '11', '33', '0', '6', '5', '6', '0.428571429', '181', '1', '0', '0.833333333', '0.3125', '1', '1', '21.375', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected URL url ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref ; protected String prefix ; private Project fallback ; protected boolean userProperty ; public Property ( ) { this ( false ) ; } protected Property ( boolean userProperty ) { this ( userProperty , null ) ; } protected Property ( boolean userProperty , Project fallback ) { this . userProperty = userProperty ; this . fallback = fallback ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setUrl ( URL url ) { this . url = url ; } public URL getUrl ( ) { return url ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public String getPrefix ( ) { return prefix ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setUserProperty ( boolean userProperty ) { log ( "DEPRECATED: Ignoring request to set user property in Property" + " task." , Project . MSG_WARN ) ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( getProject ( ) == null ) { throw new IllegalStateException ( "project has not been set" ) ; } if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or " + "refid with the name attribute" , getLocation ( ) ) ; } } else { if ( url == null && file == null && resource == null && env == null ) { throw new BuildException ( "You must specify url, file, resource or " + "environment when not using the " + "name attribute" , getLocation ( ) ) ; } } if ( url == null && file == null && resource == null && prefix != null ) { throw new BuildException ( "Prefix is only valid when loading from " + "a url, file or resource" , getLocation ( ) ) ; } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) { loadFile ( file ) ; } if ( url != null ) { loadUrl ( url ) ; } if ( resource != null ) { loadResource ( resource ) ; } if ( env != null ) { loadEnvironment ( env ) ; } if ( ( name != null ) && ( ref != null ) ) { try { addProperty ( name , ref . getReferencedObject ( getProject ( ) ) . toString ( ) ) ; } catch ( BuildException be ) { if ( fallback != null ) { addProperty ( name , ref . getReferencedObject ( fallback ) . toString ( ) ) ; } else { throw be ; } } } } protected void loadUrl ( URL url ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + url , Project . MSG_VERBOSE ) ; try { InputStream is = url . openStream ( ) ; try { props . load ( is ) ; } finally { if ( is != null ) { is . close ( ) ; } } addProperties ( props ) ; } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; InputStream is = null ; try { ClassLoader cL = null ; if ( classpath != null ) { cL = getProject ( ) . createClassLoader ( classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) { prefix += "." ; } log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; String v = getProject ( ) . replaceProperties ( value ) ; if ( prefix != null ) { name = prefix + name ; } addProperty ( name , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( getProject ( ) . getUserProperty ( n ) == null ) { getProject ( ) . setInheritedProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { getProject ( ) . setNewProperty ( n , v ) ; } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; Stack referencesSeen = new Stack ( ) ; resolve ( props , name , referencesSeen ) ; } } private void resolve ( Properties props , String name , Stack referencesSeen ) throws BuildException { if ( referencesSeen . contains ( name ) ) { throw new BuildException ( "Property " + name + " was circularly " + "defined." ) ; } String value = props . getProperty ( name ) ; Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; if ( propertyRefs . size ( ) != 0 ) { referencesSeen . push ( name ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { resolve ( props , propertyName , referencesSeen ) ; fragment = props . getProperty ( propertyName ) ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; props . put ( name , value ) ; referencesSeen . pop ( ) ; } } } 	0	['35', '3', '0', '14', '90', '519', '4', '10', '25', '0.909090909', '815', '1', '3', '0.536231884', '0.171428571', '0', '0', '21.97142857', '7', '1.4', '0']
package org . apache . tools . ant . types ; public class Resource implements Cloneable , Comparable { private String name = null ; private boolean exists = true ; private long lastmodified = 0 ; private boolean directory = false ; public Resource ( ) { } public Resource ( String name ) { this ( name , false , 0 , false ) ; } public Resource ( String name , boolean exists , long lastmodified ) { this ( name , exists , lastmodified , false ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory ) { this . name = name ; this . exists = exists ; this . lastmodified = lastmodified ; this . directory = directory ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public boolean isExists ( ) { return exists ; } public void setExists ( boolean exists ) { this . exists = exists ; } public long getLastModified ( ) { return ! exists || lastmodified < 0 ? 0 : lastmodified ; } public void setLastModified ( long lastmodified ) { this . lastmodified = lastmodified ; } public boolean isDirectory ( ) { return directory ; } public void setDirectory ( boolean directory ) { this . directory = directory ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new Error ( "CloneNotSupportedException for a " + "Clonable Resource caught?" ) ; } } public int compareTo ( Object other ) { if ( ! ( other instanceof Resource ) ) { throw new IllegalArgumentException ( "Can only be compared with " + "Resources" ) ; } Resource r = ( Resource ) other ; return getName ( ) . compareTo ( r . getName ( ) ) ; } } 	0	['14', '1', '0', '8', '19', '45', '8', '0', '14', '0.576923077', '138', '1', '0', '0', '0.371428571', '0', '0', '8.571428571', '3', '0.9286', '0']
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "sj" : exec ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '11', '1', '1', '5', '2', '2', '41', '0', '0', '0.958333333', '1', '0', '0', '19.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or " + "only a filtersFile parameter is " + "required" , getLocation ( ) ) ; } if ( isSingleFilter ) { getProject ( ) . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; getProject ( ) . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '18', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; public interface BuildLogger extends BuildListener { void setMessageOutputLevel ( int level ) ; void setOutputPrintStream ( PrintStream output ) ; void setEmacsMode ( boolean emacsMode ) ; void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '7', '23', '0', '0', '7', '7', '0.625', '145', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.14285714', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public interface ExecuteStreamHandler { void setProcessInputStream ( OutputStream os ) throws IOException ; void setProcessErrorStream ( InputStream is ) throws IOException ; void setProcessOutputStream ( InputStream is ) throws IOException ; void start ( ) throws IOException ; void stop ( ) ; } 	0	['5', '1', '0', '13', '5', '10', '13', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '13', '1', '0', '12', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public final void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private final String getLineBreaks ( ) { return lineBreaks ; } public final Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0	['7', '5', '0', '5', '17', '0', '1', '4', '5', '0.777777778', '107', '1', '0', '0.848484848', '0.476190476', '2', '5', '13.85714286', '5', '1.2857', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ExtendSelector extends BaseSelector { private String classname = null ; private FileSelector dynselector = null ; private Vector paramVec = new Vector ( ) ; private Path classpath = null ; public ExtendSelector ( ) { } public void setClassname ( String classname ) { this . classname = classname ; } public void selectorCreate ( ) { if ( classname != null && classname . length ( ) > 0 ) { try { Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } dynselector = ( FileSelector ) c . newInstance ( ) ; final Project project = getProject ( ) ; if ( project != null ) { project . setProjectReference ( dynselector ) ; } } catch ( ClassNotFoundException cnfexcept ) { setError ( "Selector " + classname + " not initialized, no such class" ) ; } catch ( InstantiationException iexcept ) { setError ( "Selector " + classname + " not initialized, could not create class" ) ; } catch ( IllegalAccessException iaexcept ) { setError ( "Selector " + classname + " not initialized, class not accessible" ) ; } } else { setError ( "There is no classname specified" ) ; } } public void addParam ( Parameter p ) { paramVec . addElement ( p ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathref ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public void verifySettings ( ) { if ( dynselector == null ) { selectorCreate ( ) ; } if ( classname == null || classname . length ( ) < 1 ) { setError ( "The classname attribute is required" ) ; } else if ( dynselector == null ) { setError ( "Internal Error: The custom selector was not created" ) ; } else if ( ! ( dynselector instanceof ExtendFileSelector ) && ( paramVec . size ( ) > 0 ) ) { setError ( "Cannot set parameters on custom selector that does not " + "implement ExtendFileSelector" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) throws BuildException { validate ( ) ; if ( paramVec . size ( ) > 0 && dynselector instanceof ExtendFileSelector ) { Parameter [ ] paramArray = new Parameter [ paramVec . size ( ) ] ; paramVec . copyInto ( paramArray ) ; ( ( ExtendFileSelector ) dynselector ) . setParameters ( paramArray ) ; } return dynselector . isSelected ( basedir , filename , file ) ; } } 	0	['10', '4', '0', '17', '36', '3', '5', '12', '10', '0.583333333', '253', '1', '2', '0.795454545', '0.266666667', '1', '3', '23.9', '7', '2.3', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public interface Algorithm { boolean isValid ( ) ; String getValue ( File file ) ; } 	0	['2', '1', '0', '3', '2', '1', '3', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '7', '9', '1', '3', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '271', '0', '0', '0', '0.45', '0', '0', '32.875', '7', '2.75', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . launch . AntMain ; public class Main implements AntMain { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 1 ) ; private Vector propertyFiles = new Vector ( 1 ) ; private boolean allowInput = true ; private boolean keepGoingMode = false ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = new Main ( ) ; m . startAnt ( args , additionalUserProperties , coreLoader ) ; } public void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { try { Diagnostics . validateVersion ( ) ; processArgs ( args ) ; } catch ( Throwable exc ) { handleLogfile ( ) ; printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; definedProps . put ( key , property ) ; } } int exitCode = 1 ; try { runBuild ( coreLoader ) ; exitCode = 0 ; } catch ( BuildException be ) { if ( err != System . err ) { printMessage ( be ) ; } } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; } finally { handleLogfile ( ) ; } System . exit ( exitCode ) ; } private static void handleLogfile ( ) { if ( isLogFileUsed ) { if ( out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } if ( err != null ) { try { err . close ( ) ; } catch ( final Exception e ) { } } } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } public Main ( ) { } protected Main ( String [ ] args ) throws BuildException { processArgs ( args ) ; } private void processArgs ( String [ ] args ) { String searchForThis = null ; PrintStream logTo = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) || arg . equals ( "-h" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) || arg . equals ( "-d" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-noinput" ) ) { allowInput = false ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; throw new BuildException ( msg ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] . replace ( '/' , File . separatorChar ) ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; throw new BuildException ( msg ) ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } else { throw new BuildException ( "Missing value for property " + name ) ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { throw new BuildException ( "Only one logger class may " + " be specified." ) ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -logger argument" ) ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { throw new BuildException ( "Only one input handler class may " + "be specified." ) ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -inputhandler" + " argument" ) ; } } else if ( arg . equals ( "-emacs" ) || arg . equals ( "-e" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) || arg . equals ( "-p" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) || arg . equals ( "-s" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-k" ) || arg . equals ( "-keep-going" ) ) { keepGoingMode = true ; } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; throw new BuildException ( "" ) ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = logTo ; err = logTo ; System . setOut ( out ) ; System . setErr ( err ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; InputStream in = System . in ; SecurityManager oldsm = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { oldsm = System . getSecurityManager ( ) ; } try { if ( allowInput ) { project . setDefaultInputStream ( System . in ) ; } System . setIn ( new DemuxInputStream ( project ) ) ; System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; project . setKeepGoingMode ( keepGoingMode ) ; ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { if ( project . getDefaultTarget ( ) != null ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( out ) ; System . setErr ( err ) ; System . setIn ( in ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; if ( project != null ) { project . setProjectReference ( listener ) ; } project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private void addInputHandler ( Project project ) throws BuildException { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { try { handler = ( InputHandler ) ( Class . forName ( inputHandlerClassname ) . newInstance ( ) ) ; if ( project != null ) { project . setProjectReference ( handler ) ; } } catch ( ClassCastException e ) { String msg = "The specified input handler class " + inputHandlerClassname + " does not implement the InputHandler interface" ; throw new BuildException ( msg ) ; } catch ( Exception e ) { String msg = "Unable to instantiate specified input handler " + "class " + inputHandlerClassname + " : " + e . getClass ( ) . getName ( ) ; throw new BuildException ( msg ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { Class loggerClass = Class . forName ( loggerClassname ) ; logger = ( BuildLogger ) ( loggerClass . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger " + "class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help, -h              print this message" + lSep ) ; msg . append ( "  -projecthelp, -p       print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug, -d             print debugging information" + lSep ) ; msg . append ( "  -emacs, -e             produce logging information without adornments" + lSep ) ; msg . append ( "  -lib <path>            specifies a path to search for jars and classes" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -noinput               do not allow interactive input" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -keep-going, -k        execute all targets that do not depend" + lSep ) ; msg . append ( "                         on failed target(s)" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           (s)earch for buildfile towards the root of" + lSep ) ; msg . append ( "    -s  <file>           the filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; if ( targetName . equals ( "" ) ) { continue ; } targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Other targets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) <= maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) ) ; } } 	0	['23', '1', '0', '14', '113', '173', '1', '14', '5', '0.751196172', '1964', '0.894736842', '0', '0', '0.144628099', '0', '0', '83.56521739', '50', '4.3913', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public interface Regexp extends RegexpMatcher { int REPLACE_FIRST = 0x00000001 ; int REPLACE_ALL = 0x00000010 ; String substitute ( String input , String argument , int options ) throws BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . facade ; import java . util . Enumeration ; import java . util . Vector ; public class FacadeTaskHelper { private Vector args = new Vector ( ) ; private String userChoice ; private String magicValue ; private String defaultValue ; public FacadeTaskHelper ( String defaultValue ) { this ( defaultValue , null ) ; } public FacadeTaskHelper ( String defaultValue , String magicValue ) { this . defaultValue = defaultValue ; this . magicValue = magicValue ; } public void setMagicValue ( String magicValue ) { this . magicValue = magicValue ; } public void setImplementation ( String userChoice ) { this . userChoice = userChoice ; } public String getImplementation ( ) { return userChoice != null ? userChoice : ( magicValue != null ? magicValue : defaultValue ) ; } public String getExplicitChoice ( ) { return userChoice ; } public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . addElement ( arg ) ; } public String [ ] getArgs ( ) { Vector tmp = new Vector ( args . size ( ) ) ; for ( Enumeration e = args . elements ( ) ; e . hasMoreElements ( ) ; ) { ImplementationSpecificArgument arg = ( ( ImplementationSpecificArgument ) e . nextElement ( ) ) ; String [ ] curr = arg . getParts ( getImplementation ( ) ) ; for ( int i = 0 ; i < curr . length ; i ++ ) { tmp . addElement ( curr [ i ] ) ; } } String [ ] res = new String [ tmp . size ( ) ] ; tmp . copyInto ( res ) ; return res ; } public boolean hasBeenSet ( ) { return userChoice != null || magicValue != null ; } } 	0	['9', '1', '0', '3', '19', '8', '2', '1', '9', '0.53125', '119', '1', '0', '0', '0.518518519', '0', '0', '11.77777778', '3', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Mkdir extends Task { private static final int MKDIR_RETRY_SLEEP_MILLIS = 10 ; private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , getLocation ( ) ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file " + "already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = mkdirs ( dir ) ; if ( ! result ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } private boolean mkdirs ( File f ) { if ( ! f . mkdirs ( ) ) { try { Thread . sleep ( MKDIR_RETRY_SLEEP_MILLIS ) ; return f . mkdirs ( ) ; } catch ( InterruptedException ex ) { return f . mkdirs ( ) ; } } return true ; } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '1', '99', '1', '0', '0.925', '0.75', '1', '1', '23.25', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . OutputStream ; import java . io . IOException ; public class TeeOutputStream extends OutputStream { private OutputStream left ; private OutputStream right ; public TeeOutputStream ( OutputStream left , OutputStream right ) { this . left = left ; this . right = right ; } public void close ( ) throws IOException { left . close ( ) ; right . close ( ) ; } public void flush ( ) throws IOException { left . flush ( ) ; right . flush ( ) ; } public void write ( byte [ ] b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } public void write ( byte [ ] b , int off , int len ) throws IOException { left . write ( b , off , len ) ; right . write ( b , off , len ) ; } public void write ( int b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } } 	0	['6', '2', '0', '1', '12', '0', '1', '0', '6', '0', '62', '1', '0', '0.5', '0.458333333', '1', '1', '9', '1', '0.8333', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '23', '3', '3', '23', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Http extends ProjectComponent implements Condition { private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = 400 ; public void setErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } else { return false ; } } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	0	['4', '2', '0', '4', '15', '0', '1', '3', '4', '0.333333333', '109', '1', '0', '0.75', '0.5', '0', '0', '25.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; public class Patch extends Task { private File originalFile ; private File directory ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setDestfile ( File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void setDir ( File directory ) { this . directory = directory ; } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , getLocation ( ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; if ( directory != null ) { if ( directory . exists ( ) && directory . isDirectory ( ) ) { exe . setWorkingDirectory ( directory ) ; } else if ( ! directory . isDirectory ( ) ) { throw new BuildException ( directory + " is not a directory." , getLocation ( ) ) ; } else { throw new BuildException ( "directory " + directory + " doesn\'t exist" , getLocation ( ) ) ; } } else { exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } } 	0	['11', '3', '0', '11', '38', '0', '0', '11', '11', '0.7', '250', '1', '1', '0.787234043', '0.454545455', '1', '1', '21.36363636', '2', '1.4545', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private static final RegexpFactory factory = new RegexpFactory ( ) ; private Regexp regexp ; public RegularExpression ( ) { this . regexp = factory . newRegexp ( ) ; } public void setPattern ( String pattern ) { this . regexp . setPattern ( pattern ) ; } public String getPattern ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } return this . regexp ; } public RegularExpression getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof RegularExpression ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a " + DATA_TYPE_NAME ; throw new BuildException ( msg ) ; } else { return ( RegularExpression ) o ; } } } 	0	['6', '3', '0', '11', '23', '1', '4', '7', '5', '0.8', '95', '0.666666667', '2', '0.882352941', '0.6', '0', '0', '14.33333333', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { ZipShort getHeaderId ( ) ; ZipShort getLocalFileDataLength ( ) ; ZipShort getCentralDirectoryLength ( ) ; byte [ ] getLocalFileDataData ( ) ; byte [ ] getCentralDirectoryData ( ) ; void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; public class EqualComparator implements Comparator { public int compare ( Object o1 , Object o2 ) { if ( o1 == null ) { if ( o2 == null ) { return 1 ; } else { return 0 ; } } else { return ( o1 . equals ( o2 ) ) ? 0 : 1 ; } } public String toString ( ) { return "EqualComparator" ; } } 	0	['3', '1', '0', '1', '5', '3', '1', '0', '3', '2', '24', '0', '0', '0', '0.666666667', '0', '0', '7', '4', '1.6667', '0']
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0	['3', '3', '2', '6', '6', '1', '5', '1', '3', '0.5', '25', '1', '0', '0.882352941', '0.833333333', '1', '1', '7', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NoneSelector extends BaseSelectorContainer { public NoneSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{noneselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( ! replace && dest . exists ( ) ) { throw new BuildException ( dest + " already exists." ) ; } try { FileUtils . newFileUtils ( ) . rename ( src , dest ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename " + src + " to " + dest , e , getLocation ( ) ) ; } } } 	0	['5', '3', '0', '5', '19', '0', '0', '5', '5', '0.666666667', '100', '1', '0', '0.902439024', '0.533333333', '1', '1', '18.4', '1', '0.8', '0']
package org . apache . tools . ant . input ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . KeepAliveInputStream ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; DataInputStream in = null ; try { in = new DataInputStream ( new KeepAliveInputStream ( getInputStream ( ) ) ) ; do { System . err . println ( prompt ) ; try { String input = in . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from" + " Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to close input." , e ) ; } } } } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( "(" ) ; Enumeration e = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( e . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( "," ) ; } sb . append ( e . nextElement ( ) ) ; first = false ; } sb . append ( ")" ) ; prompt = sb . toString ( ) ; } return prompt ; } protected InputStream getInputStream ( ) { return System . in ; } } 	0	['4', '1', '0', '7', '22', '6', '2', '5', '2', '2', '121', '0', '0', '0', '0.75', '0', '0', '29.25', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilesMatch implements Condition { private File file1 , file2 ; private FileUtils fu = FileUtils . newFileUtils ( ) ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = fu . contentEquals ( file1 , file2 ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0	['4', '1', '0', '4', '13', '0', '1', '3', '4', '0.666666667', '60', '1', '1', '0', '0.75', '0', '0', '13.25', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class UnPackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( '.' , File . separatorChar ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private static final ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ( new ZipShort ( getMode ( ) ) ) . getBytes ( ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ( new ZipLong ( linkArray . length ) ) . getBytes ( ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ( new ZipShort ( getUserId ( ) ) ) . getBytes ( ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ( new ZipShort ( getGroupId ( ) ) ) . getBytes ( ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ( new ZipLong ( checksum ) ) . getBytes ( ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ( new ZipLong ( data , offset ) ) . getValue ( ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ( new ZipShort ( tmp , 0 ) ) . getValue ( ) ; byte [ ] linkArray = new byte [ ( int ) ( new ZipLong ( tmp , 2 ) ) . getValue ( ) ] ; uid = ( new ZipShort ( tmp , 6 ) ) . getValue ( ) ; gid = ( new ZipShort ( tmp , 8 ) ) . getValue ( ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	0	['20', '1', '0', '4', '42', '130', '0', '4', '18', '0.736842105', '376', '1', '1', '0', '0.284210526', '0', '0', '17.45', '3', '1.15', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof Substitution ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a substitution" ; throw new BuildException ( msg ) ; } else { return ( Substitution ) o ; } } } 	0	['4', '3', '0', '6', '17', '0', '2', '4', '4', '0.833333333', '70', '0.5', '0', '0.909090909', '0.583333333', '0', '0', '16', '3', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class JAXPUtils { private static final FileUtils fu = FileUtils . newFileUtils ( ) ; private static SAXParserFactory parserFactory = null ; private static SAXParserFactory nsParserFactory = null ; private static DocumentBuilderFactory builderFactory = null ; public static synchronized SAXParserFactory getParserFactory ( ) throws BuildException { if ( parserFactory == null ) { parserFactory = newParserFactory ( ) ; } return parserFactory ; } public static synchronized SAXParserFactory getNSParserFactory ( ) throws BuildException { if ( nsParserFactory == null ) { nsParserFactory = newParserFactory ( ) ; nsParserFactory . setNamespaceAware ( true ) ; } return nsParserFactory ; } public static SAXParserFactory newParserFactory ( ) throws BuildException { try { return SAXParserFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "XML parser factory has not been " + "configured correctly: " + e . getMessage ( ) , e ) ; } } public static Parser getParser ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getParser ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getXMLReader ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getNamespaceXMLReader ( ) throws BuildException { try { return newSAXParser ( getNSParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static String getSystemId ( File file ) { return fu . toURI ( file . getAbsolutePath ( ) ) ; } public static DocumentBuilder getDocumentBuilder ( ) throws BuildException { try { return getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( e ) ; } } private static SAXParser newSAXParser ( SAXParserFactory factory ) throws BuildException { try { return factory . newSAXParser ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( "Cannot create parser for the given " + "configuration: " + e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static BuildException convertToBuildException ( SAXException e ) { Exception nested = e . getException ( ) ; if ( nested != null ) { return new BuildException ( nested ) ; } else { return new BuildException ( e ) ; } } private static synchronized DocumentBuilderFactory getDocumentBuilderFactory ( ) throws BuildException { if ( builderFactory == null ) { try { builderFactory = DocumentBuilderFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "Document builder factory has not " + "been configured correctly: " + e . getMessage ( ) , e ) ; } } return builderFactory ; } } 	0	['13', '1', '0', '5', '32', '70', '3', '2', '9', '0.833333333', '158', '1', '1', '0', '0.083333333', '0', '0', '10.84615385', '2', '0.9231', '0']
package org . apache . tools . tar ; import java . io . File ; import java . util . Date ; import java . util . Locale ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; public static final int MAX_NAMELEN = 31 ; public static final int DEFAULT_DIR_MODE = 040755 ; public static final int DEFAULT_FILE_MODE = 0100644 ; public static final int MILLIS_PER_SECOND = 1000 ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > MAX_NAMELEN ) { user = user . substring ( 0 , MAX_NAMELEN ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / MILLIS_PER_SECOND ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; if ( osname != null ) { if ( osname . startsWith ( "windows" ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } else if ( osname . indexOf ( "netware" ) > - 1 ) { int colon = name . indexOf ( ':' ) ; if ( colon != - 1 ) { name = name . substring ( colon + 1 ) ; } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = DEFAULT_DIR_MODE ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = DEFAULT_FILE_MODE ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / MILLIS_PER_SECOND ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean equals ( Object it ) { if ( it == null || getClass ( ) != it . getClass ( ) ) { return false ; } return equals ( ( TarEntry ) it ) ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public String getLinkName ( ) { return this . linkName . toString ( ) ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / MILLIS_PER_SECOND ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / MILLIS_PER_SECOND ; } public Date getModTime ( ) { return new Date ( this . modTime * MILLIS_PER_SECOND ) ; } public File getFile ( ) { return this . file ; } public int getMode ( ) { return this . mode ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['35', '1', '0', '6', '73', '353', '4', '2', '34', '0.809597523', '790', '0.789473684', '0', '0', '0.16', '1', '1', '21.02857143', '4', '1.2', '0']
package org . apache . tools . ant ; public class MagicNames { public static final String SCRIPT_REPOSITORY = "org.apache.ant.scriptrepo" ; public static final String SYSTEM_LOADER_REF = "ant.coreLoader" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '6', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Method ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class WLRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; AntClassLoader loader = null ; try { Class c = null ; if ( getRmic ( ) . getClasspath ( ) == null ) { c = Class . forName ( "weblogic.rmic" ) ; } else { loader = getRmic ( ) . getProject ( ) . createClassLoader ( getRmic ( ) . getClasspath ( ) ) ; c = Class . forName ( "weblogic.rmic" , true , loader ) ; } Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use WebLogic rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting WebLogic rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; } } } public String getStubClassSuffix ( ) { return "_WLStub" ; } public String getSkelClassSuffix ( ) { return "_WLSkel" ; } } 	0	['5', '2', '0', '11', '23', '10', '1', '10', '4', '1', '130', '0', '0', '0.764705882', '0.5', '0', '0', '24.8', '1', '0.8', '0']
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static void panic ( ) { System . out . println ( "panic" ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { int nNodes , nHeap , n1 , n2 , i , j , k ; boolean tooLong ; int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( i = 0 ; i < alphaSize ; i ++ ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } while ( true ) { nNodes = alphaSize ; nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; { int zz , tmp ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) ) { panic ( ) ; } while ( nHeap > 1 ) { n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; weight [ nNodes ] = ( ( weight [ n1 ] & 0xffffff00 ) + ( weight [ n2 ] & 0xffffff00 ) ) | ( 1 + ( ( ( weight [ n1 ] & 0x000000ff ) > ( weight [ n2 ] & 0x000000ff ) ) ? ( weight [ n1 ] & 0x000000ff ) : ( weight [ n2 ] & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; { int zz = 0 , tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) ) { panic ( ) ; } tooLong = false ; for ( i = 1 ; i <= alphaSize ; i ++ ) { j = 0 ; k = i ; while ( parent [ k ] >= 0 ) { k = parent [ k ] ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( ! tooLong ) { break ; } for ( i = 1 ; i < alphaSize ; i ++ ) { j = weight [ i ] > > 8 ; j = 1 + ( j / 2 ) ; weight [ i ] = j << 8 ; } } } int last ; int origPtr ; int blockSize100k ; boolean blockRandomised ; int bytesOut ; int bsBuff ; int bsLive ; CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private char [ ] block ; private int [ ] quadrant ; private int [ ] zptr ; private short [ ] szptr ; private int [ ] ftab ; private int nMTF ; private int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; private int workFactor ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int nBlocksRandomised ; private int currentChar = - 1 ; private int runLength = 0 ; public CBZip2OutputStream ( OutputStream inStream ) throws IOException { this ( inStream , 9 ) ; } public CBZip2OutputStream ( OutputStream inStream , int inBlockSize ) throws IOException { block = null ; quadrant = null ; zptr = null ; ftab = null ; bsSetStream ( inStream ) ; workFactor = 50 ; if ( inBlockSize > 9 ) { inBlockSize = 9 ; } if ( inBlockSize < 1 ) { inBlockSize = 1 ; } blockSize100k = inBlockSize ; allocateCompressStructures ( ) ; initialize ( ) ; initBlock ( ) ; } public void write ( int bv ) throws IOException { int b = ( 256 + bv ) % 256 ; if ( currentChar != - 1 ) { if ( currentChar == b ) { runLength ++ ; if ( runLength > 254 ) { writeRun ( ) ; currentChar = - 1 ; runLength = 0 ; } } else { writeRun ( ) ; runLength = 1 ; currentChar = b ; } } else { currentChar = b ; runLength ++ ; } } private void writeRun ( ) throws IOException { if ( last < allowableBlockSize ) { inUse [ currentChar ] = true ; for ( int i = 0 ; i < runLength ; i ++ ) { mCrc . updateCRC ( ( char ) currentChar ) ; } switch ( runLength ) { case 1 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 2 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 3 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; default : inUse [ runLength - 4 ] = true ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) ( runLength - 4 ) ; break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } boolean closed = false ; protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } public void close ( ) throws IOException { if ( closed ) { return ; } if ( runLength > 0 ) { writeRun ( ) ; } currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; closed = true ; super . close ( ) ; bsStream . close ( ) ; } public void flush ( ) throws IOException { super . flush ( ) ; bsStream . flush ( ) ; } private int blockCRC , combinedCRC ; private void initialize ( ) throws IOException { bytesOut = 0 ; nBlocksRandomised = 0 ; bsPutUChar ( 'h' ) ; bsPutUChar ( '0' + blockSize100k ) ; combinedCRC = 0 ; } private int allowableBlockSize ; private void initBlock ( ) { mCrc . initialiseCRC ( ) ; last = - 1 ; for ( int i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } allowableBlockSize = baseBlockSize * blockSize100k - 20 ; } private void endBlock ( ) throws IOException { blockCRC = mCrc . getFinalCRC ( ) ; combinedCRC = ( combinedCRC << 1 ) | ( combinedCRC > > > 31 ) ; combinedCRC ^= blockCRC ; doReversibleTransformation ( ) ; bsPutUChar ( 0x31 ) ; bsPutUChar ( 0x41 ) ; bsPutUChar ( 0x59 ) ; bsPutUChar ( 0x26 ) ; bsPutUChar ( 0x53 ) ; bsPutUChar ( 0x59 ) ; bsPutint ( blockCRC ) ; if ( blockRandomised ) { bsW ( 1 , 1 ) ; nBlocksRandomised ++ ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUChar ( 0x17 ) ; bsPutUChar ( 0x72 ) ; bsPutUChar ( 0x45 ) ; bsPutUChar ( 0x38 ) ; bsPutUChar ( 0x50 ) ; bsPutUChar ( 0x90 ) ; bsPutint ( combinedCRC ) ; bsFinishedWithStream ( ) ; } private void hbAssignCodes ( int [ ] code , char [ ] length , int minLen , int maxLen , int alphaSize ) { int n , vec , i ; vec = 0 ; for ( n = minLen ; n <= maxLen ; n ++ ) { for ( i = 0 ; i < alphaSize ; i ++ ) { if ( length [ i ] == n ) { code [ i ] = vec ; vec ++ ; } } ; vec <<= 1 ; } } private void bsSetStream ( OutputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; bytesOut = 0 ; } private void bsFinishedWithStream ( ) throws IOException { while ( bsLive > 0 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } } private void bsW ( int n , int v ) throws IOException { while ( bsLive >= 8 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } bsBuff |= ( v << ( 32 - bsLive - n ) ) ; bsLive += n ; } private void bsPutUChar ( int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutint ( int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void bsPutIntVS ( int numBits , int c ) throws IOException { bsW ( numBits , c ) ; } private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups , nBytes ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 == 1 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } ; totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } nBytes = bytesOut ; for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } nBytes = bytesOut ; bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } nBytes = bytesOut ; for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } nBytes = bytesOut ; selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } } private void moveToFrontCodeAndSend ( ) throws IOException { bsPutIntVS ( 24 , origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private OutputStream bsStream ; private void simpleSort ( int lo , int hi , int d ) { int i , j , h , bigN , hp ; int v ; bigN = hi - lo + 1 ; if ( bigN < 2 ) { return ; } hp = 0 ; while ( incs [ hp ] < bigN ) { hp ++ ; } hp -- ; for ( ; hp >= 0 ; hp -- ) { h = incs [ hp ] ; i = lo + h ; while ( true ) { if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( workDone > workLimit && firstAttempt ) { return ; } } } } private void vswap ( int p1 , int p2 , int n ) { int temp = 0 ; while ( n > 0 ) { temp = zptr [ p1 ] ; zptr [ p1 ] = zptr [ p2 ] ; zptr [ p2 ] = temp ; p1 ++ ; p2 ++ ; n -- ; } } private char med3 ( char a , char b , char c ) { char t ; if ( a > b ) { t = a ; a = b ; b = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } if ( a > b ) { b = a ; } return b ; } private static class StackElem { int ll ; int hh ; int dd ; } private void qSort3 ( int loSt , int hiSt , int dSt ) { int unLo , unHi , ltLo , gtHi , med , n , m ; int sp , lo , hi , d ; StackElem [ ] stack = new StackElem [ QSORT_STACK_SIZE ] ; for ( int count = 0 ; count < QSORT_STACK_SIZE ; count ++ ) { stack [ count ] = new StackElem ( ) ; } sp = 0 ; stack [ sp ] . ll = loSt ; stack [ sp ] . hh = hiSt ; stack [ sp ] . dd = dSt ; sp ++ ; while ( sp > 0 ) { if ( sp >= QSORT_STACK_SIZE ) { panic ( ) ; } sp -- ; lo = stack [ sp ] . ll ; hi = stack [ sp ] . hh ; d = stack [ sp ] . dd ; if ( hi - lo < SMALL_THRESH || d > DEPTH_THRESH ) { simpleSort ( lo , hi , d ) ; if ( workDone > workLimit && firstAttempt ) { return ; } continue ; } med = med3 ( block [ zptr [ lo ] + d + 1 ] , block [ zptr [ hi ] + d + 1 ] , block [ zptr [ ( lo + hi ) > > 1 ] + d + 1 ] ) ; unLo = ltLo = lo ; unHi = gtHi = hi ; while ( true ) { while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unLo ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ ltLo ] ; zptr [ ltLo ] = temp ; ltLo ++ ; unLo ++ ; continue ; } ; if ( n > 0 ) { break ; } unLo ++ ; } while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unHi ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unHi ] ; zptr [ unHi ] = zptr [ gtHi ] ; zptr [ gtHi ] = temp ; gtHi -- ; unHi -- ; continue ; } ; if ( n < 0 ) { break ; } unHi -- ; } if ( unLo > unHi ) { break ; } int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ unHi ] ; zptr [ unHi ] = temp ; unLo ++ ; unHi -- ; } if ( gtHi < ltLo ) { stack [ sp ] . ll = lo ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d + 1 ; sp ++ ; continue ; } n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( lo , unLo - n , n ) ; m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack [ sp ] . ll = lo ; stack [ sp ] . hh = n ; stack [ sp ] . dd = d ; sp ++ ; stack [ sp ] . ll = n + 1 ; stack [ sp ] . hh = m - 1 ; stack [ sp ] . dd = d + 1 ; sp ++ ; stack [ sp ] . ll = m ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d ; sp ++ ; } } private void mainSort ( ) { int i , j , ss , sb ; int [ ] runningOrder = new int [ 256 ] ; int [ ] copy = new int [ 256 ] ; boolean [ ] bigDone = new boolean [ 256 ] ; int c1 , c2 ; int numQSorted ; for ( i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ last + i + 2 ] = block [ ( i % ( last + 1 ) ) + 1 ] ; } for ( i = 0 ; i <= last + NUM_OVERSHOOT_BYTES ; i ++ ) { quadrant [ i ] = 0 ; } block [ 0 ] = ( char ) ( block [ last + 1 ] ) ; if ( last < 4000 ) { for ( i = 0 ; i <= last ; i ++ ) { zptr [ i ] = i ; } firstAttempt = false ; workDone = workLimit = 0 ; simpleSort ( 0 , last , 0 ) ; } else { numQSorted = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { bigDone [ i ] = false ; } for ( i = 0 ; i <= 65536 ; i ++ ) { ftab [ i ] = 0 ; } c1 = block [ 0 ] ; for ( i = 0 ; i <= last ; i ++ ) { c2 = block [ i + 1 ] ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( i = 1 ; i <= 65536 ; i ++ ) { ftab [ i ] += ftab [ i - 1 ] ; } c1 = block [ 1 ] ; for ( i = 0 ; i < last ; i ++ ) { c2 = block [ i + 2 ] ; j = ( c1 << 8 ) + c2 ; c1 = c2 ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = i ; } j = ( ( block [ last + 1 ] ) << 8 ) + ( block [ 1 ] ) ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = last ; for ( i = 0 ; i <= 255 ; i ++ ) { runningOrder [ i ] = i ; } { int vv ; int h = 1 ; do { h = 3 * h + 1 ; } while ( h <= 256 ) ; do { h = h / 3 ; for ( i = h ; i <= 255 ; i ++ ) { vv = runningOrder [ i ] ; j = i ; while ( ( ftab [ ( ( runningOrder [ j - h ] ) + 1 ) << 8 ] - ftab [ ( runningOrder [ j - h ] ) << 8 ] ) > ( ftab [ ( ( vv ) + 1 ) << 8 ] - ftab [ ( vv ) << 8 ] ) ) { runningOrder [ j ] = runningOrder [ j - h ] ; j = j - h ; if ( j <= ( h - 1 ) ) { break ; } } runningOrder [ j ] = vv ; } } while ( h != 1 ) ; } for ( i = 0 ; i <= 255 ; i ++ ) { ss = runningOrder [ i ] ; for ( j = 0 ; j <= 255 ; j ++ ) { sb = ( ss << 8 ) + j ; if ( ! ( ( ftab [ sb ] & SETMASK ) == SETMASK ) ) { int lo = ftab [ sb ] & CLEARMASK ; int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { qSort3 ( lo , hi , 2 ) ; numQSorted += ( hi - lo + 1 ) ; if ( workDone > workLimit && firstAttempt ) { return ; } } ftab [ sb ] |= SETMASK ; } } bigDone [ ss ] = true ; if ( i < 255 ) { int bbStart = ftab [ ss << 8 ] & CLEARMASK ; int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( j = 0 ; j < bbSize ; j ++ ) { int a2update = zptr [ bbStart + j ] ; int qVal = ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + last + 1 ] = qVal ; } } if ( ! ( ( ( bbSize - 1 ) > > shifts ) <= 65535 ) ) { panic ( ) ; } } for ( j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( j = ftab [ ss << 8 ] & CLEARMASK ; j < ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j ++ ) { c1 = block [ zptr [ j ] ] ; if ( ! bigDone [ c1 ] ) { zptr [ copy [ c1 ] ] = zptr [ j ] == 0 ? last : zptr [ j ] - 1 ; copy [ c1 ] ++ ; } } for ( j = 0 ; j <= 255 ; j ++ ) { ftab [ ( j << 8 ) + ss ] |= SETMASK ; } } } } private void randomiseBlock ( ) { int i ; int rNToGo = 0 ; int rTPos = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i <= last ; i ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; block [ i + 1 ] &= 0xFF ; inUse [ block [ i + 1 ] ] = true ; } } private void doReversibleTransformation ( ) { int i ; workLimit = workFactor * last ; workDone = 0 ; blockRandomised = false ; firstAttempt = true ; mainSort ( ) ; if ( workDone > workLimit && firstAttempt ) { randomiseBlock ( ) ; workLimit = workDone = 0 ; blockRandomised = true ; firstAttempt = false ; mainSort ( ) ; } origPtr = - 1 ; for ( i = 0 ; i <= last ; i ++ ) { if ( zptr [ i ] == 0 ) { origPtr = i ; break ; } } ; if ( origPtr == - 1 ) { panic ( ) ; } } private boolean fullGtU ( int i1 , int i2 ) { int k ; char c1 , c2 ; int s1 , s2 ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; k = last + 1 ; do { c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; if ( i1 > last ) { i1 -= last ; i1 -- ; } ; if ( i2 > last ) { i2 -= last ; i2 -- ; } ; k -= 4 ; workDone ++ ; } while ( k >= 0 ) ; return false ; } private int [ ] incs = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; private void allocateCompressStructures ( ) { int n = baseBlockSize * blockSize100k ; block = new char [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; quadrant = new int [ ( n + NUM_OVERSHOOT_BYTES ) ] ; zptr = new int [ n ] ; ftab = new int [ 65537 ] ; if ( block == null || quadrant == null || zptr == null || ftab == null ) { } szptr = new short [ 2 * n ] ; } private void generateMTFValues ( ) { char [ ] yy = new char [ 256 ] ; int i , j ; char tmp ; char tmp2 ; int zPend ; int wr ; int EOB ; makeMaps ( ) ; EOB = nInUse + 1 ; for ( i = 0 ; i <= EOB ; i ++ ) { mtfFreq [ i ] = 0 ; } wr = 0 ; zPend = 0 ; for ( i = 0 ; i < nInUse ; i ++ ) { yy [ i ] = ( char ) i ; } for ( i = 0 ; i <= last ; i ++ ) { char ll_i ; ll_i = unseqToSeq [ block [ zptr [ i ] ] ] ; j = 0 ; tmp = yy [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } ; yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } ; if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } ; zPend = 0 ; } szptr [ wr ] = ( short ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } } szptr [ wr ] = ( short ) EOB ; wr ++ ; mtfFreq [ EOB ] ++ ; nMTF = wr ; } } 	0	['33', '2', '0', '6', '44', '322', '2', '4', '5', '0.857469512', '4238', '0.780487805', '1', '0.138888889', '0.257575758', '1', '1', '126.1818182', '32', '5.6061', '0']
package org . apache . tools . ant . util ; import java . text . ChoiceFormat ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public final class DateUtils { public static final String ISO8601_DATETIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss" ; public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd" ; public static final String ISO8601_TIME_PATTERN = "HH:mm:ss" ; public static final DateFormat DATE_HEADER_FORMAT = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss " , Locale . US ) ; private static final MessageFormat MINUTE_SECONDS = new MessageFormat ( "{0}{1}" ) ; private static final double [ ] LIMITS = { 0 , 1 , 2 } ; private static final String [ ] MINUTES_PART = { "" , "1 minute " , "{0,number} minutes " } ; private static final String [ ] SECONDS_PART = { "0 seconds" , "1 second" , "{1,number} seconds" } ; private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat ( LIMITS , MINUTES_PART ) ; private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat ( LIMITS , SECONDS_PART ) ; static { MINUTE_SECONDS . setFormat ( 0 , MINUTES_FORMAT ) ; MINUTE_SECONDS . setFormat ( 1 , SECONDS_FORMAT ) ; } private DateUtils ( ) { } public static String format ( long date , String pattern ) { return format ( new Date ( date ) , pattern ) ; } public static String format ( Date date , String pattern ) { DateFormat df = createDateFormat ( pattern ) ; return df . format ( date ) ; } public static String formatElapsedTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; Object [ ] args = { new Long ( minutes ) , new Long ( seconds % 60 ) } ; return MINUTE_SECONDS . format ( args ) ; } private static DateFormat createDateFormat ( String pattern ) { SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; TimeZone gmt = TimeZone . getTimeZone ( "GMT" ) ; sdf . setTimeZone ( gmt ) ; sdf . setLenient ( true ) ; return sdf ; } public static int getPhaseOfMoon ( Calendar cal ) { int dayOfTheYear = cal . get ( Calendar . DAY_OF_YEAR ) ; int yearInMetonicCycle = ( ( cal . get ( Calendar . YEAR ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * yearInMetonicCycle + 18 ) % 30 ; if ( ( epact == 25 && yearInMetonicCycle > 11 ) || epact == 24 ) { epact ++ ; } return ( ( ( ( ( dayOfTheYear + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; } public static String getDateForHeader ( ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; int offset = tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , cal . get ( Calendar . MILLISECOND ) ) ; StringBuffer tzMarker = new StringBuffer ( offset < 0 ? "-" : "+" ) ; offset = Math . abs ( offset ) ; int hours = offset / ( 60 * 60 * 1000 ) ; int minutes = offset / ( 60 * 1000 ) - 60 * hours ; if ( hours < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( hours ) ; if ( minutes < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( minutes ) ; return DATE_HEADER_FORMAT . format ( cal . getTime ( ) ) + tzMarker . toString ( ) ; } public static Date parseIso8601DateTime ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATETIME_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601Date ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATE_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601DateTimeOrDate ( String datestr ) throws ParseException { try { return parseIso8601DateTime ( datestr ) ; } catch ( ParseException px ) { return parseIso8601Date ( datestr ) ; } } } 	0	['11', '1', '0', '3', '36', '51', '3', '0', '8', '1.01', '314', '0.6', '0', '0', '0.22', '0', '0', '26.63636364', '4', '1.3636', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private Vector contains = new Vector ( ) ; private String line = null ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int containsSize = contains . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; if ( line . indexOf ( containsStr ) == - 1 ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private final Vector getContains ( ) { return contains ; } public final Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '173', '1', '0', '0.823529412', '0.375', '2', '5', '20.25', '4', '1.125', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . filters . ClassConstants ; import org . apache . tools . ant . filters . EscapeUnicode ; import org . apache . tools . ant . filters . ExpandProperties ; import org . apache . tools . ant . filters . HeadFilter ; import org . apache . tools . ant . filters . LineContains ; import org . apache . tools . ant . filters . LineContainsRegExp ; import org . apache . tools . ant . filters . PrefixLines ; import org . apache . tools . ant . filters . ReplaceTokens ; import org . apache . tools . ant . filters . StripJavaComments ; import org . apache . tools . ant . filters . StripLineBreaks ; import org . apache . tools . ant . filters . StripLineComments ; import org . apache . tools . ant . filters . TabsToSpaces ; import org . apache . tools . ant . filters . TailFilter ; import org . apache . tools . ant . filters . TokenFilter ; public final class FilterChain extends DataType implements Cloneable { private Vector filterReaders = new Vector ( ) ; public final void addFilterReader ( final AntFilterReader filterReader ) { filterReaders . addElement ( filterReader ) ; } public final Vector getFilterReaders ( ) { return filterReaders ; } public final void addClassConstants ( final ClassConstants classConstants ) { filterReaders . addElement ( classConstants ) ; } public final void addExpandProperties ( final ExpandProperties expandProperties ) { filterReaders . addElement ( expandProperties ) ; } public final void addHeadFilter ( final HeadFilter headFilter ) { filterReaders . addElement ( headFilter ) ; } public final void addLineContains ( final LineContains lineContains ) { filterReaders . addElement ( lineContains ) ; } public final void addLineContainsRegExp ( final LineContainsRegExp lineContainsRegExp ) { filterReaders . addElement ( lineContainsRegExp ) ; } public final void addPrefixLines ( final PrefixLines prefixLines ) { filterReaders . addElement ( prefixLines ) ; } public final void addReplaceTokens ( final ReplaceTokens replaceTokens ) { filterReaders . addElement ( replaceTokens ) ; } public final void addStripJavaComments ( final StripJavaComments stripJavaComments ) { filterReaders . addElement ( stripJavaComments ) ; } public final void addStripLineBreaks ( final StripLineBreaks stripLineBreaks ) { filterReaders . addElement ( stripLineBreaks ) ; } public final void addStripLineComments ( final StripLineComments stripLineComments ) { filterReaders . addElement ( stripLineComments ) ; } public final void addTabsToSpaces ( final TabsToSpaces tabsToSpaces ) { filterReaders . addElement ( tabsToSpaces ) ; } public final void addTailFilter ( final TailFilter tailFilter ) { filterReaders . addElement ( tailFilter ) ; } public final void addEscapeUnicode ( final EscapeUnicode escapeUnicode ) { filterReaders . addElement ( escapeUnicode ) ; } public final void addTokenFilter ( final TokenFilter tokenFilter ) { filterReaders . addElement ( tokenFilter ) ; } public void addDeleteCharacters ( TokenFilter . DeleteCharacters filter ) { filterReaders . addElement ( filter ) ; } public void addContainsRegex ( TokenFilter . ContainsRegex filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceRegex ( TokenFilter . ReplaceRegex filter ) { filterReaders . addElement ( filter ) ; } public void addTrim ( TokenFilter . Trim filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceString ( TokenFilter . ReplaceString filter ) { filterReaders . addElement ( filter ) ; } public void addIgnoreBlank ( TokenFilter . IgnoreBlank filter ) { filterReaders . addElement ( filter ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! filterReaders . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof FilterChain ) { FilterChain fc = ( FilterChain ) o ; filterReaders = fc . getFilterReaders ( ) ; } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterChain" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } public void add ( ChainableReader filter ) { filterReaders . addElement ( filter ) ; } } 	0	['25', '3', '0', '32', '38', '0', '5', '27', '25', '0', '189', '1', '0', '0.555555556', '0.08', '1', '1', '6.52', '1', '0.96', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '6', '5', '6', '5', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class DateSelector extends BaseExtendSelector { private long millis = - 1 ; private String dateTime = null ; private boolean includeDirs = false ; private int granularity = 0 ; private int cmp = 2 ; public static final String MILLIS_KEY = "millis" ; public static final String DATETIME_KEY = "datetime" ; public static final String CHECKDIRS_KEY = "checkdirs" ; public static final String GRANULARITY_KEY = "granularity" ; public static final String WHEN_KEY = "when" ; public DateSelector ( ) { if ( Os . isFamily ( "dos" ) ) { granularity = 2000 ; } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dateselector date: " ) ; buf . append ( dateTime ) ; buf . append ( " compare: " ) ; if ( cmp == 0 ) { buf . append ( "before" ) ; } else if ( cmp == 1 ) { buf . append ( "after" ) ; } else { buf . append ( "equal" ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMillis ( long millis ) { this . millis = millis ; } public long getMillis ( ) { return millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value relative" + " to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { setError ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + " MM/DD/YYYY HH:MM AM_PM format." ) ; } } } public void setCheckdirs ( boolean includeDirs ) { this . includeDirs = includeDirs ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public void setWhen ( TimeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MILLIS_KEY . equalsIgnoreCase ( paramname ) ) { try { setMillis ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid millisecond setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( DATETIME_KEY . equalsIgnoreCase ( paramname ) ) { setDatetime ( parameters [ i ] . getValue ( ) ) ; } else if ( CHECKDIRS_KEY . equalsIgnoreCase ( paramname ) ) { setCheckdirs ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( GRANULARITY_KEY . equalsIgnoreCase ( paramname ) ) { try { setGranularity ( new Integer ( parameters [ i ] . getValue ( ) ) . intValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid granularity setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { TimeComparisons cmp = new TimeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( dateTime == null && millis < 0 ) { setError ( "You must provide a datetime or the number of " + "milliseconds." ) ; } else if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) && ( ! includeDirs ) ) { return true ; } if ( cmp == 0 ) { return ( ( file . lastModified ( ) - granularity ) < millis ) ; } else if ( cmp == 1 ) { return ( ( file . lastModified ( ) + granularity ) > millis ) ; } else { return ( Math . abs ( file . lastModified ( ) - millis ) <= granularity ) ; } } public static class TimeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "before" , "after" , "equal" } ; } } } 	0	['11', '5', '0', '12', '38', '1', '5', '7', '11', '0.84', '394', '0.5', '0', '0.791666667', '0.215909091', '1', '4', '33.90909091', '8', '2.7273', '0']
package org . apache . tools . ant . types ; public class FlexInteger { private Integer value ; public FlexInteger ( String value ) { this . value = Integer . decode ( value ) ; } public int intValue ( ) { return value . intValue ( ) ; } public String toString ( ) { return value . toString ( ) ; } } 	0	['3', '1', '0', '0', '7', '0', '0', '0', '3', '0', '19', '1', '0', '0', '0.666666667', '0', '0', '5', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '20', '21', '0', '2', '9', '0.6', '132', '1', '0', '0.804347826', '0.4', '1', '1', '11.7', '1', '0.9', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; class RedirectingStreamHandler extends PumpStreamHandler { RedirectingStreamHandler ( final ChangeLogParser parser ) { super ( new RedirectingOutputStream ( parser ) , new ByteArrayOutputStream ( ) ) ; } String getErrors ( ) { try { final ByteArrayOutputStream error = ( ByteArrayOutputStream ) getErr ( ) ; return error . toString ( "ASCII" ) ; } catch ( final Exception e ) { return null ; } } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( final IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '1', '2', '40', '0', '0', '0.857142857', '0.666666667', '0', '0', '12.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; try { Class c = Class . forName ( "at.dms.kjc.Main" ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use kjc compiler, as it is not " + "available. A common solution is to " + "set the environment variable CLASSPATH " + "to your kjc archive (kjc.jar)." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting kjc compiler: " , ex , location ) ; } } } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; if ( compileSourcepath != null ) { cp . append ( compileSourcepath ) ; } else { cp . append ( src ) ; } cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['4', '2', '0', '10', '26', '6', '1', '9', '2', '1', '195', '0', '0', '0.884615385', '0.5', '0', '0', '47.5', '10', '3', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_DIM = 2 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private final void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String err = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( err != null ) { errColor = PREFIX + err + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected final void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0	['3', '2', '0', '1', '18', '0', '0', '1', '1', '0.96875', '258', '1', '0', '0.888888889', '0.5', '1', '3', '79.66666667', '12', '5.6667', '0']
package org . apache . tools . ant . util ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; public final class StringUtils { public static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static Vector lineSplit ( String data ) { return split ( data , '\n' ) ; } public static Vector split ( String data , int ch ) { Vector elems = new Vector ( ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( ch , i ) ) != - 1 ) { String elem = data . substring ( i , pos ) ; elems . addElement ( elem ) ; i = pos + 1 ; } elems . addElement ( data . substring ( i ) ) ; return elems ; } public static String replace ( String data , String from , String to ) { StringBuffer buf = new StringBuffer ( data . length ( ) ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( from , i ) ) != - 1 ) { buf . append ( data . substring ( i , pos ) ) . append ( to ) ; i = pos + from . length ( ) ; } buf . append ( data . substring ( i ) ) ; return buf . toString ( ) ; } public static String getStackTrace ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; pw . close ( ) ; return sw . toString ( ) ; } } 	0	['6', '1', '0', '14', '24', '15', '14', '0', '5', '1', '116', '0', '0', '0', '0.3', '0', '0', '18.16666667', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class ContainsSelector extends BaseExtendSelector { private String contains = null ; private boolean casesensitive = true ; private boolean ignorewhitespace = false ; public static final String EXPRESSION_KEY = "expression" ; public static final String CONTAINS_KEY = "text" ; public static final String CASE_KEY = "casesensitive" ; public static final String WHITESPACE_KEY = "ignorewhitespace" ; public ContainsSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsselector text: " ) ; buf . append ( contains ) ; buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " ignorewhitespace: " ) ; if ( ignorewhitespace ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setText ( String contains ) { this . contains = contains ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setIgnorewhitespace ( boolean ignorewhitespace ) { this . ignorewhitespace = ignorewhitespace ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( CONTAINS_KEY . equalsIgnoreCase ( paramname ) ) { setText ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( WHITESPACE_KEY . equalsIgnoreCase ( paramname ) ) { setIgnorewhitespace ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( contains == null ) { setError ( "The text attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } String userstr = contains ; if ( ! casesensitive ) { userstr = contains . toLowerCase ( ) ; } if ( ignorewhitespace ) { userstr = SelectorUtils . removeWhitespace ( userstr ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! casesensitive ) { teststr = teststr . toLowerCase ( ) ; } if ( ignorewhitespace ) { teststr = SelectorUtils . removeWhitespace ( teststr ) ; } if ( teststr . indexOf ( userstr ) > - 1 ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read file " + filename ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close file " + filename ) ; } } } } } 	0	['8', '5', '0', '11', '30', '0', '5', '6', '8', '0.816326531', '299', '0.428571429', '0', '0.844444444', '0.35', '1', '4', '35.5', '11', '3.125', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class PrefixLines extends BaseParamFilterReader implements ChainableReader { private static final String PREFIX_KEY = "prefix" ; private String prefix = null ; private String queuedData = null ; public PrefixLines ( ) { super ( ) ; } public PrefixLines ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readLine ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { if ( prefix != null ) { queuedData = prefix + queuedData ; } return read ( ) ; } } return ch ; } public final void setPrefix ( final String prefix ) { this . prefix = prefix ; } private final String getPrefix ( ) { return prefix ; } public final Reader chain ( final Reader rdr ) { PrefixLines newFilter = new PrefixLines ( rdr ) ; newFilter . setPrefix ( getPrefix ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( PREFIX_KEY . equals ( params [ i ] . getName ( ) ) ) { prefix = params [ i ] . getValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '5', '22', '0', '1', '4', '5', '0.555555556', '150', '1', '0', '0.848484848', '0.476190476', '2', '5', '20', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '7', '13', '1', '1', '6', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . types . Parameter ; public final class HeadFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private long linesRead = 0 ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; public HeadFilter ( ) { super ( ) ; } public HeadFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } line = headFilter ( line ) ; linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final void setSkip ( final long skip ) { this . skip = skip ; } private final long getSkip ( ) { return skip ; } public final Reader chain ( final Reader rdr ) { HeadFilter newFilter = new HeadFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { lines = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String headFilter ( String line ) { linesRead ++ ; if ( skip > 0 ) { if ( ( linesRead - 1 ) < skip ) { return null ; } } if ( lines > 0 ) { if ( linesRead > ( lines + skip ) ) { return null ; } } return line ; } } 	0	['10', '5', '0', '6', '25', '0', '1', '5', '6', '0.703703704', '251', '1', '1', '0.777777778', '0.375', '2', '4', '23.2', '5', '1.6', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . util . StringUtils ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public NoBannerLogger ( ) { } public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( StringUtils . LINE_SEP + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '4', '16', '0', '0', '4', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsFalse extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for falsehood" ) ; } return ! value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '34', '1', '0', '0.818181818', '0.666666667', '0', '0', '10', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; public abstract class BaseParamFilterReader extends BaseFilterReader implements Parameterizable { private Parameter [ ] parameters ; public BaseParamFilterReader ( ) { super ( ) ; } public BaseParamFilterReader ( final Reader in ) { super ( in ) ; } public final void setParameters ( final Parameter [ ] parameters ) { this . parameters = parameters ; setInitialized ( false ) ; } protected final Parameter [ ] getParameters ( ) { return parameters ; } } 	0	['4', '4', '11', '14', '7', '4', '11', '3', '3', '0.666666667', '22', '1', '1', '0.928571429', '0.5', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class MajoritySelector extends BaseSelectorContainer { private boolean allowtie = true ; public MajoritySelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{majorityselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void setAllowtie ( boolean tiebreaker ) { allowtie = tiebreaker ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int yesvotes = 0 ; int novotes = 0 ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { yesvotes = yesvotes + 1 ; } else { novotes = novotes + 1 ; } } if ( yesvotes > novotes ) { return true ; } else if ( novotes > yesvotes ) { return false ; } return allowtie ; } } 	0	['4', '5', '0', '6', '15', '0', '5', '2', '4', '0.333333333', '83', '1', '0', '0.953846154', '0.4375', '1', '1', '19.5', '5', '2', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpFactory extends RegexpMatcherFactory { public RegexpFactory ( ) { } public Regexp newRegexp ( ) throws BuildException { return ( Regexp ) newRegexp ( null ) ; } public Regexp newRegexp ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createRegexpInstance ( systemDefault ) ; } try { testAvailability ( "java.util.regex.Matcher" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaOroRegexp" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.regexp.RE" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpRegexp" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected Regexp createRegexpInstance ( String classname ) throws BuildException { RegexpMatcher m = createInstance ( classname ) ; if ( m instanceof Regexp ) { return ( Regexp ) m ; } else { throw new BuildException ( classname + " doesn't implement the Regexp interface" ) ; } } } 	0	['4', '2', '0', '6', '13', '6', '1', '5', '3', '2', '83', '0', '0', '0.625', '0.5', '0', '0', '19.75', '1', '0.75', '0']
package org . apache . tools . zip ; public final class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	0	['7', '1', '0', '7', '8', '0', '7', '0', '7', '0', '89', '1', '0', '0', '0.428571429', '1', '1', '11.57142857', '4', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0	['1', '1', '0', '20', '1', '0', '19', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . LogOutputStream ; class RedirectingOutputStream extends LogOutputStream { private final ChangeLogParser parser ; public RedirectingOutputStream ( final ChangeLogParser parser ) { super ( null , 0 ) ; this . parser = parser ; } protected void processLine ( final String line ) { parser . stdout ( line ) ; } } 	0	['2', '4', '0', '4', '4', '0', '1', '3', '1', '0', '16', '1', '1', '0.9375', '0.666666667', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Pack extends Task { protected File zipFile ; protected File source ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setDestfile ( File zipFile ) { setZipfile ( zipFile ) ; } public void setSrc ( File src ) { source = src ; } private void validate ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , getLocation ( ) ) ; } if ( zipFile . isDirectory ( ) ) { throw new BuildException ( "zipfile attribute must not " + "represent a directory!" , getLocation ( ) ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Src attribute must not " + "represent a directory!" , getLocation ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( ! source . exists ( ) ) { log ( "Nothing to do: " + source . getAbsolutePath ( ) + " doesn't exist." ) ; } else if ( zipFile . lastModified ( ) < source . lastModified ( ) ) { log ( "Building: " + zipFile . getAbsolutePath ( ) ) ; pack ( ) ; } else { log ( "Nothing to do: " + zipFile . getAbsolutePath ( ) + " is up to date." ) ; } } private void zipFile ( InputStream in , OutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , OutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } protected abstract void pack ( ) ; } 	0	['9', '3', '2', '5', '24', '26', '2', '3', '5', '0.6875', '169', '1', '0', '0.822222222', '0.444444444', '1', '1', '17.55555556', '1', '0.8889', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public abstract class BaseExtendSelector extends BaseSelector implements ExtendFileSelector { protected Parameter [ ] parameters = null ; public BaseExtendSelector ( ) { } public void setParameters ( Parameter [ ] parameters ) { this . parameters = parameters ; } protected Parameter [ ] getParameters ( ) { return parameters ; } public abstract boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['4', '4', '8', '12', '5', '0', '8', '4', '3', '0.333333333', '18', '1', '1', '0.921052632', '0.4375', '0', '0', '3.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; private static final FileUtils fu = FileUtils . newFileUtils ( ) ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! fu . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['8', '6', '0', '10', '31', '18', '0', '10', '4', '0.80952381', '149', '1', '1', '0.9625', '0.357142857', '3', '9', '17.25', '2', '0.875', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskAdapter ; public class Taskdef extends Typedef { public Taskdef ( ) { setAdapterClass ( TaskAdapter . class ) ; setAdaptToClass ( Task . class ) ; } } 	0	['2', '7', '0', '2', '8', '1', '0', '2', '1', '1', '37', '0', '0', '0.987179487', '0.5', '0', '0', '16.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public final void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private final int getTablength ( ) { return tabLength ; } public final Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '5', '0.708333333', '126', '1', '0', '0.848484848', '0.476190476', '2', '5', '16.42857143', '5', '1.2857', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . email . EmailAddress ; import org . apache . tools . ant . taskdefs . email . Message ; import org . apache . tools . ant . taskdefs . email . Mailer ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . mail . MailMessage ; public class MailLogger extends DefaultLogger { private StringBuffer buffer = new StringBuffer ( ) ; public void buildFinished ( BuildEvent event ) { super . buildFinished ( event ) ; Project project = event . getProject ( ) ; Hashtable properties = project . getProperties ( ) ; Properties fileProperties = new Properties ( ) ; String filename = ( String ) properties . get ( "MailLogger.properties.file" ) ; if ( filename != null ) { InputStream is = null ; try { is = new FileInputStream ( filename ) ; fileProperties . load ( is ) ; } catch ( IOException ioe ) { } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } for ( Enumeration e = fileProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = fileProperties . getProperty ( key ) ; properties . put ( key , project . replaceProperties ( value ) ) ; } boolean success = ( event . getException ( ) == null ) ; String prefix = success ? "success" : "failure" ; try { boolean notify = Project . toBoolean ( getValue ( properties , prefix + ".notify" , "on" ) ) ; if ( ! notify ) { return ; } String mailhost = getValue ( properties , "mailhost" , "localhost" ) ; int port = Integer . parseInt ( getValue ( properties , "port" , String . valueOf ( MailMessage . DEFAULT_PORT ) ) ) ; String user = getValue ( properties , "user" , "" ) ; String password = getValue ( properties , "password" , "" ) ; boolean ssl = Project . toBoolean ( getValue ( properties , "ssl" , "off" ) ) ; String from = getValue ( properties , "from" , null ) ; String replytoList = getValue ( properties , "replyto" , "" ) ; String toList = getValue ( properties , prefix + ".to" , null ) ; String subject = getValue ( properties , prefix + ".subject" , ( success ) ? "Build Success" : "Build Failure" ) ; if ( user . equals ( "" ) && password . equals ( "" ) && ! ssl ) { sendMail ( mailhost , port , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } else { sendMimeMail ( event . getProject ( ) , mailhost , port , user , password , ssl , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } } catch ( Exception e ) { System . out . println ( "MailLogger failed to send e-mail!" ) ; e . printStackTrace ( System . err ) ; } } protected void log ( String message ) { buffer . append ( message ) . append ( StringUtils . LINE_SEP ) ; } private String getValue ( Hashtable properties , String name , String defaultValue ) throws Exception { String propertyName = "MailLogger." + name ; String value = ( String ) properties . get ( propertyName ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { throw new Exception ( "Missing required parameter: " + propertyName ) ; } return value ; } private void sendMail ( String mailhost , int port , String from , String replyToList , String toList , String subject , String message ) throws IOException { MailMessage mailMessage = new MailMessage ( mailhost , port ) ; mailMessage . setHeader ( "Date" , DateUtils . getDateForHeader ( ) ) ; mailMessage . from ( from ) ; if ( ! replyToList . equals ( "" ) ) { StringTokenizer t = new StringTokenizer ( replyToList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . replyto ( t . nextToken ( ) ) ; } } StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } mailMessage . setSubject ( subject ) ; PrintStream ps = mailMessage . getPrintStream ( ) ; ps . println ( message ) ; mailMessage . sendAndClose ( ) ; } private void sendMimeMail ( Project project , String host , int port , String user , String password , boolean ssl , String from , String replyToString , String toString , String subject , String message ) { Mailer mailer = null ; try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail: " + e . getMessage ( ) ) ; return ; } Vector replyToList = vectorizeEmailAddresses ( replyToString ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( ssl ) ; Message mymessage = new Message ( message ) ; mymessage . setProject ( project ) ; mailer . setMessage ( mymessage ) ; mailer . setFrom ( new EmailAddress ( from ) ) ; mailer . setReplyToList ( replyToList ) ; Vector toList = vectorizeEmailAddresses ( toString ) ; mailer . setToList ( toList ) ; mailer . setCcList ( new Vector ( ) ) ; mailer . setBccList ( new Vector ( ) ) ; mailer . setFiles ( new Vector ( ) ) ; mailer . setSubject ( subject ) ; mailer . send ( ) ; } private Vector vectorizeEmailAddresses ( String listString ) { Vector emailList = new Vector ( ) ; StringTokenizer tokens = new StringTokenizer ( listString , "," ) ; while ( tokens . hasMoreTokens ( ) ) { emailList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } return emailList ; } } 	0	['7', '2', '0', '10', '69', '15', '0', '10', '2', '0.5', '453', '1', '0', '0.727272727', '0.367346939', '2', '4', '63.57142857', '14', '2.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringReader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class Concat extends Task { private static final int BUFFER_SIZE = 8192 ; private File destinationFile = null ; private boolean append = false ; private String encoding = null ; private String outputEncoding = null ; private StringBuffer textBuffer ; private Vector sources = new Vector ( ) ; private Vector filterChains = null ; private boolean forceOverwrite = true ; private TextElement footer ; private TextElement header ; private boolean fixLastLine = false ; private String eolString = System . getProperty ( "line.separator" ) ; private Writer outputWriter = null ; private Vector sourceFiles = new Vector ( ) ; private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setForce ( boolean force ) { this . forceOverwrite = force ; } public Path createPath ( ) { Path path = new Path ( getProject ( ) ) ; sources . addElement ( path ) ; return path ; } public void addFileset ( FileSet set ) { sources . addElement ( set ) ; } public void addFilelist ( FileList list ) { sources . addElement ( list ) ; } public void addFilterChain ( FilterChain filterChain ) { if ( filterChains == null ) { filterChains = new Vector ( ) ; } filterChains . addElement ( filterChain ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void addHeader ( TextElement header ) { this . header = header ; } public void addFooter ( TextElement footer ) { this . footer = footer ; } public void setFixLastLine ( boolean fixLastLine ) { this . fixLastLine = fixLastLine ; } public void setEol ( FixCRLF . CrLf crlf ) { String s = crlf . getValue ( ) ; if ( s . equals ( "cr" ) || s . equals ( "mac" ) ) { eolString = "\r" ; } else if ( s . equals ( "lf" ) || s . equals ( "unix" ) ) { eolString = "\n" ; } else if ( s . equals ( "crlf" ) || s . equals ( "dos" ) ) { eolString = "\r\n" ; } } public void setWriter ( Writer outputWriter ) { this . outputWriter = outputWriter ; } public void execute ( ) { sanitizeText ( ) ; if ( destinationFile != null && outputWriter != null ) { throw new BuildException ( "Cannot specify both a destination file and an output writer" ) ; } if ( sources . size ( ) == 0 && textBuffer == null ) { throw new BuildException ( "At least one file must be provided, or some text." ) ; } if ( sources . size ( ) > 0 && textBuffer != null ) { throw new BuildException ( "Cannot include inline text when using filesets." ) ; } for ( Enumeration e = sources . elements ( ) ; e . hasMoreElements ( ) ; ) { Object o = e . nextElement ( ) ; if ( o instanceof Path ) { Path path = ( Path ) o ; checkAddFiles ( null , path . list ( ) ) ; } else if ( o instanceof FileSet ) { FileSet fileSet = ( FileSet ) o ; DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; checkAddFiles ( fileSet . getDir ( getProject ( ) ) , scanner . getIncludedFiles ( ) ) ; } else if ( o instanceof FileList ) { FileList fileList = ( FileList ) o ; checkAddFiles ( fileList . getDir ( getProject ( ) ) , fileList . getFiles ( getProject ( ) ) ) ; } } if ( destinationFile != null && ! forceOverwrite && ( sourceFiles . size ( ) > 0 ) && destinationFile . exists ( ) ) { boolean outofdate = false ; for ( int i = 0 ; i < sourceFiles . size ( ) ; ++ i ) { File file = ( File ) sourceFiles . elementAt ( i ) ; if ( file . lastModified ( ) > destinationFile . lastModified ( ) ) { outofdate = true ; break ; } } if ( ! outofdate ) { log ( destinationFile + " is up-to-date." , Project . MSG_VERBOSE ) ; return ; } } if ( textBuffer == null && sourceFiles . size ( ) == 0 && header == null && footer == null ) { log ( "No existing files and no nested text, doing nothing" , Project . MSG_INFO ) ; return ; } cat ( ) ; } public void reset ( ) { append = false ; forceOverwrite = true ; destinationFile = null ; encoding = null ; outputEncoding = null ; fixLastLine = false ; sources . removeAllElements ( ) ; sourceFiles . removeAllElements ( ) ; filterChains = null ; footer = null ; header = null ; } private void checkAddFiles ( File base , String [ ] filenames ) { for ( int i = 0 ; i < filenames . length ; ++ i ) { File file = new File ( base , filenames [ i ] ) ; if ( ! file . exists ( ) ) { log ( "File " + file + " does not exist." , Project . MSG_ERR ) ; continue ; } if ( destinationFile != null && fileUtils . fileNameEquals ( destinationFile , file ) ) { throw new BuildException ( "Input file \"" + file + "\" " + "is the same as the output file." ) ; } sourceFiles . addElement ( file ) ; } } private void cat ( ) { OutputStream os = null ; Reader reader = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; try { PrintWriter writer = null ; if ( outputWriter != null ) { writer = new PrintWriter ( outputWriter ) ; } else { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { File parent = fileUtils . getParentFile ( destinationFile ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; } if ( outputEncoding == null ) { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os ) ) ) ; } else { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os , outputEncoding ) ) ) ; } } if ( header != null ) { if ( header . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( header . getValue ( ) ) ) ; } else { writer . print ( header . getValue ( ) ) ; } } if ( textBuffer != null ) { reader = new StringReader ( getProject ( ) . replaceProperties ( textBuffer . substring ( 0 ) ) ) ; } else { reader = new MultiReader ( ) ; } concatenate ( buffer , writer , reader ) ; if ( footer != null ) { if ( footer . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( footer . getValue ( ) ) ) ; } else { writer . print ( footer . getValue ( ) ) ; } } writer . flush ( ) ; if ( os != null ) { os . flush ( ) ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException ignore ) { } } if ( os != null ) { try { os . close ( ) ; } catch ( IOException ignore ) { } } } } private void concatenate ( char [ ] buffer , Writer writer , Reader in ) throws IOException { if ( filterChains != null ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( BUFFER_SIZE ) ; helper . setPrimaryReader ( in ) ; helper . setFilterChains ( filterChains ) ; helper . setProject ( getProject ( ) ) ; in = new BufferedReader ( helper . getAssembledReader ( ) ) ; } while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } writer . write ( buffer , 0 , nRead ) ; } writer . flush ( ) ; } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . substring ( 0 ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } public static class TextElement extends ProjectComponent { private String value = "" ; private boolean trimLeading = false ; private boolean trim = false ; private boolean filtering = true ; private String encoding = null ; public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } private boolean getFiltering ( ) { return filtering ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setFile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "File " + file + " does not exist." ) ; } BufferedReader reader = null ; try { if ( this . encoding == null ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , this . encoding ) ) ; } value = fileUtils . readFully ( reader ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Throwable t ) { } } } } public void addText ( String value ) { this . value += getProject ( ) . replaceProperties ( value ) ; } public void setTrimLeading ( boolean strip ) { this . trimLeading = strip ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public String getValue ( ) { if ( value == null ) { value = "" ; } if ( value . trim ( ) . length ( ) == 0 ) { value = "" ; } if ( trimLeading ) { char [ ] current = value . toCharArray ( ) ; StringBuffer b = new StringBuffer ( current . length ) ; boolean startOfLine = true ; int pos = 0 ; while ( pos < current . length ) { char ch = current [ pos ++ ] ; if ( startOfLine ) { if ( ch == ' ' || ch == '\t' ) { continue ; } startOfLine = false ; } b . append ( ch ) ; if ( ch == '\n' || ch == '\r' ) { startOfLine = true ; } } value = b . toString ( ) ; } if ( trim ) { value = value . trim ( ) ; } return value ; } } private class MultiReader extends Reader { private int pos = 0 ; private Reader reader = null ; private int lastPos = 0 ; private char [ ] lastChars = new char [ eolString . length ( ) ] ; private boolean needAddSeparator = false ; private Reader getReader ( ) throws IOException { if ( reader == null ) { if ( encoding == null ) { reader = new BufferedReader ( new FileReader ( ( File ) sourceFiles . elementAt ( pos ) ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( ( File ) sourceFiles . elementAt ( pos ) ) , encoding ) ) ; } for ( int i = 0 ; i < lastChars . length ; ++ i ) { lastChars [ i ] = 0 ; } } return reader ; } public int read ( ) throws IOException { if ( needAddSeparator ) { int ret = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } return ret ; } while ( pos < sourceFiles . size ( ) ) { int ch = getReader ( ) . read ( ) ; if ( ch == - 1 ) { reader . close ( ) ; reader = null ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { addLastChar ( ( char ) ch ) ; return ch ; } pos ++ ; } return - 1 ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int amountRead = 0 ; while ( pos < sourceFiles . size ( ) || ( needAddSeparator ) ) { if ( needAddSeparator ) { cbuf [ off ] = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; pos ++ ; } len -- ; off ++ ; amountRead ++ ; if ( len == 0 ) { return amountRead ; } continue ; } int nRead = getReader ( ) . read ( cbuf , off , len ) ; if ( nRead == - 1 || nRead == 0 ) { reader . close ( ) ; reader = null ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } else { pos ++ ; } } else { if ( fixLastLine ) { for ( int i = nRead ; i > ( nRead - lastChars . length ) ; -- i ) { if ( i < 0 ) { break ; } addLastChar ( cbuf [ off + i - 1 ] ) ; } } len -= nRead ; off += nRead ; amountRead += nRead ; if ( len == 0 ) { return amountRead ; } } } if ( amountRead == 0 ) { return - 1 ; } else { return amountRead ; } } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } private void addLastChar ( char ch ) { for ( int i = lastChars . length - 2 ; i >= 0 ; -- i ) { lastChars [ i ] = lastChars [ i + 1 ] ; } lastChars [ lastChars . length - 1 ] = ch ; } private boolean isMissingEndOfLine ( ) { for ( int i = 0 ; i < lastChars . length ; ++ i ) { if ( lastChars [ i ] != eolString . charAt ( i ) ) { return true ; } } return false ; } } } 	0	['28', '3', '0', '18', '94', '220', '2', '18', '18', '0.877314815', '769', '1', '3', '0.587301587', '0.119047619', '1', '1', '25.89285714', '22', '2.7143', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '12', '15', '13', '9', '4', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import java . net . URL ; public class WhichResource extends Task { private Path classpath ; private String classname ; private String resource ; private String property ; public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } private void validate ( ) { int setcount = 0 ; if ( classname != null ) { setcount ++ ; } if ( resource != null ) { setcount ++ ; } if ( setcount == 0 ) { throw new BuildException ( "One of classname or resource must be specified" ) ; } if ( setcount > 1 ) { throw new BuildException ( "Only one of classname or resource can be specified" ) ; } if ( property == null ) { throw new BuildException ( "No property defined" ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( classpath != null ) { getProject ( ) . log ( "using user supplied classpath: " + classpath , Project . MSG_DEBUG ) ; classpath = classpath . concatSystemClasspath ( "ignore" ) ; } else { classpath = new Path ( getProject ( ) ) ; classpath = classpath . concatSystemClasspath ( "only" ) ; getProject ( ) . log ( "using system classpath: " + classpath , Project . MSG_DEBUG ) ; } AntClassLoader loader ; loader = new AntClassLoader ( getProject ( ) . getCoreLoader ( ) , getProject ( ) , classpath , false ) ; String location = null ; if ( classname != null ) { classname = classname . replace ( '.' , '/' ) ; resource = "/" + classname + ".class" ; } else { if ( ! resource . startsWith ( "/" ) ) { resource = "/" + resource ; } } log ( "Searching for " + resource , Project . MSG_VERBOSE ) ; URL url ; url = loader . getResource ( resource ) ; if ( url != null ) { location = url . toExternalForm ( ) ; getProject ( ) . setNewProperty ( property , location ) ; } } public void setResource ( String resource ) { this . resource = resource ; } public void setClass ( String classname ) { this . classname = classname ; } public void setProperty ( String property ) { this . property = property ; } } 	0	['8', '3', '0', '6', '28', '8', '0', '6', '7', '0.714285714', '221', '1', '1', '0.840909091', '0.5', '2', '2', '26.125', '6', '1.75', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . mail . MailMessage ; class PlainMailer extends Mailer { public void send ( ) { try { MailMessage mailMessage = new MailMessage ( host , port ) ; mailMessage . from ( from . toString ( ) ) ; Enumeration e ; e = replyToList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . replyto ( e . nextElement ( ) . toString ( ) ) ; } e = toList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . to ( e . nextElement ( ) . toString ( ) ) ; } e = ccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . cc ( e . nextElement ( ) . toString ( ) ) ; } e = bccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . bcc ( e . nextElement ( ) . toString ( ) ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } mailMessage . setHeader ( "Date" , getDate ( ) ) ; if ( message . getCharset ( ) != null ) { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) + "; charset=\"" + message . getCharset ( ) + "\"" ) ; } else { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) ) ; } PrintStream out = mailMessage . getPrintStream ( ) ; message . print ( out ) ; e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; attach ( file , out ) ; } mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail" , ioe ) ; } } protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } if ( includeFileNames ) { out . println ( ) ; String filename = file . getName ( ) ; int filenamelength = filename . length ( ) ; out . println ( filename ) ; for ( int star = 0 ; star < filenamelength ; star ++ ) { out . print ( '=' ) ; } out . println ( ) ; } int length ; final int maxBuf = 1024 ; byte [ ] buf = new byte [ maxBuf ] ; FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr , buf . length ) ; while ( ( length = in . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { finstr . close ( ) ; } } } 	0	['3', '2', '1', '7', '40', '3', '2', '5', '1', '2', '237', '0', '0', '0.9', '0.555555556', '1', '1', '78', '8', '3', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; import java . io . PrintWriter ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String message ) { super ( message ) ; } public BuildException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String message , Location location ) { super ( message ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public Throwable getCause ( ) { return getException ( ) ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['15', '4', '0', '243', '27', '0', '242', '1', '15', '0.392857143', '157', '1', '1', '0.619047619', '0.322222222', '1', '3', '9.333333333', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . StringUtils ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '3', '30', '0', '0', '3', '5', '0.6', '1270', '1', '0', '0.880952381', '0.555555556', '1', '1', '210', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; public class GZip extends Pack { protected void pack ( ) { GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '4', '13', '1', '0', '4', '1', '2', '56', '0', '0', '0.980392157', '1', '1', '2', '27', '4', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . Checksum ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase extends ProjectComponent { private Vector conditions = new Vector ( ) ; protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return conditions . elements ( ) ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addChecksum ( Checksum c ) { conditions . addElement ( c ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } public void addIsSet ( IsSet i ) { conditions . addElement ( i ) ; } public void addHttp ( Http h ) { conditions . addElement ( h ) ; } public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } public void addFilesMatch ( FilesMatch test ) { conditions . addElement ( test ) ; } public void addContains ( Contains test ) { conditions . addElement ( test ) ; } public void addIsTrue ( IsTrue test ) { conditions . addElement ( test ) ; } public void addIsFalse ( IsFalse test ) { conditions . addElement ( test ) ; } public void addIsReference ( IsReference i ) { conditions . addElement ( i ) ; } public void add ( Condition c ) { conditions . addElement ( c ) ; } } 	0	['20', '2', '5', '20', '25', '0', '5', '18', '18', '0', '122', '1', '0', '0.321428571', '0.102777778', '0', '0', '5.05', '1', '0.95', '0']
package org . apache . tools . ant . util ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . substring ( 0 ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '145', '1', '1', '0', '0.9', '0', '0', '27.4', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0	['6', '1', '0', '3', '11', '1', '1', '2', '6', '0.7', '74', '1', '0', '0', '0.555555556', '0', '0', '10.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class LogOutputStream extends OutputStream { private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } public void flush ( ) { processBuffer ( ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } public int getMessageLevel ( ) { return level ; } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['9', '2', '2', '10', '18', '8', '9', '1', '6', '0.821428571', '160', '1', '1', '0.384615385', '0.377777778', '1', '1', '16', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class WaitFor extends ConditionBase { private long maxWaitMillis = 1000L * 60L * 3L ; private long maxWaitMultiplier = 1L ; private long checkEveryMillis = 500L ; private long checkEveryMultiplier = 1L ; private String timeoutProperty ; public void setMaxWait ( long time ) { maxWaitMillis = time ; } public void setMaxWaitUnit ( Unit unit ) { maxWaitMultiplier = unit . getMultiplier ( ) ; } public void setCheckEvery ( long time ) { checkEveryMillis = time ; } public void setCheckEveryUnit ( Unit unit ) { checkEveryMultiplier = unit . getMultiplier ( ) ; } public void setTimeoutProperty ( String p ) { timeoutProperty = p ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <waitfor>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<waitfor>" ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; long savedMaxWaitMillis = maxWaitMillis ; long savedCheckEveryMillis = checkEveryMillis ; try { maxWaitMillis *= maxWaitMultiplier ; checkEveryMillis *= checkEveryMultiplier ; long start = System . currentTimeMillis ( ) ; long end = start + maxWaitMillis ; while ( System . currentTimeMillis ( ) < end ) { if ( c . eval ( ) ) { return ; } try { Thread . sleep ( checkEveryMillis ) ; } catch ( InterruptedException e ) { } } if ( timeoutProperty != null ) { getProject ( ) . setNewProperty ( timeoutProperty , "true" ) ; } } finally { maxWaitMillis = savedMaxWaitMillis ; checkEveryMillis = savedCheckEveryMillis ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK } ; private Hashtable timeTable = new Hashtable ( ) ; public Unit ( ) { timeTable . put ( MILLISECOND , new Long ( 1L ) ) ; timeTable . put ( SECOND , new Long ( 1000L ) ) ; timeTable . put ( MINUTE , new Long ( 1000L * 60L ) ) ; timeTable . put ( HOUR , new Long ( 1000L * 60L * 60L ) ) ; timeTable . put ( DAY , new Long ( 1000L * 60L * 60L * 24L ) ) ; timeTable . put ( WEEK , new Long ( 1000L * 60L * 60L * 24L * 7L ) ) ; } public long getMultiplier ( ) { String key = getValue ( ) . toLowerCase ( ) ; Long l = ( Long ) timeTable . get ( key ) ; return l . longValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['7', '3', '0', '6', '18', '1', '0', '6', '7', '0.7', '139', '1', '0', '0.842105263', '0.428571429', '0', '0', '18.14285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ClasspathUtils ; public abstract class DefBase extends AntlibDefinition { private ClassLoader createdLoader ; private ClasspathUtils . Delegate cpDelegate ; public void setReverseLoader ( boolean reverseLoader ) { this . cpDelegate . setReverseLoader ( reverseLoader ) ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public Path getClasspath ( ) { return cpDelegate . getClasspath ( ) ; } public boolean isReverseLoader ( ) { return cpDelegate . isReverseLoader ( ) ; } public String getLoaderId ( ) { return cpDelegate . getClassLoadId ( ) ; } public String getClasspathId ( ) { return cpDelegate . getClassLoadId ( ) ; } public void setClasspath ( Path classpath ) { this . cpDelegate . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return this . cpDelegate . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { this . cpDelegate . setClasspathref ( r ) ; } public void setLoaderRef ( Reference r ) { this . cpDelegate . setLoaderRef ( r ) ; } protected ClassLoader createLoader ( ) { if ( getAntlibClassLoader ( ) != null ) { return getAntlibClassLoader ( ) ; } if ( createdLoader == null ) { createdLoader = this . cpDelegate . getClassLoader ( ) ; ( ( AntClassLoader ) createdLoader ) . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } return createdLoader ; } public void init ( ) throws BuildException { this . cpDelegate = ClasspathUtils . getDelegate ( this ) ; super . init ( ) ; } } 	0	['12', '4', '1', '11', '27', '0', '2', '9', '11', '0.545454545', '90', '1', '1', '0.788461538', '0.333333333', '0', '0', '6.333333333', '3', '1.0833', '0']
package org . apache . tools . zip ; public final class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000L ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return result ; } public long getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	0	['7', '1', '0', '3', '8', '0', '3', '0', '7', '0', '147', '1', '0', '0', '0.342857143', '1', '1', '19.85714286', '4', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; public interface ChainableReader { Reader chain ( Reader rdr ) ; } 	0	['1', '1', '0', '19', '1', '0', '19', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; java . net . Socket s = null ; try { s = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } finally { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ioe ) { } } } return true ; } } 	0	['4', '2', '0', '4', '13', '0', '1', '3', '4', '0.333333333', '89', '1', '0', '0.75', '0.5', '0', '0', '20.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . email ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . DateUtils ; public abstract class Mailer { protected String host = null ; protected int port = - 1 ; protected String user = null ; protected String password = null ; protected boolean SSL = false ; protected Message message ; protected EmailAddress from ; protected Vector replyToList = null ; protected Vector toList = null ; protected Vector ccList = null ; protected Vector bccList = null ; protected Vector files = null ; protected String subject = null ; protected Task task ; protected boolean includeFileNames = false ; public void setHost ( String host ) { this . host = host ; } public void setPort ( int port ) { this . port = port ; } public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean SSL ) { this . SSL = SSL ; } public void setMessage ( Message m ) { this . message = m ; } public void setFrom ( EmailAddress from ) { this . from = from ; } public void setReplyToList ( Vector list ) { this . replyToList = list ; } public void setToList ( Vector list ) { this . toList = list ; } public void setCcList ( Vector list ) { this . ccList = list ; } public void setBccList ( Vector list ) { this . bccList = list ; } public void setFiles ( Vector files ) { this . files = files ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setTask ( Task task ) { this . task = task ; } public void setIncludeFileNames ( boolean b ) { this . includeFileNames = b ; } public abstract void send ( ) throws BuildException ; protected final String getDate ( ) { return DateUtils . getDateForHeader ( ) ; } } 	0	['18', '1', '1', '8', '20', '129', '3', '5', '17', '0.952941176', '134', '1', '3', '0', '0.229166667', '0', '0', '5.611111111', '1', '0.9444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class UpToDate extends Task implements Condition { private String _property ; private String _value ; private File _sourceFile ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setValue ( String value ) { _value = value ; } private String getValue ( ) { return ( _value != null ) ? _value : "true" ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void setSrcfile ( File file ) { _sourceFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 && _sourceFile == null ) { throw new BuildException ( "At least one srcfile or a nested " + "<srcfiles> element must be set." ) ; } if ( sourceFileSets . size ( ) > 0 && _sourceFile != null ) { throw new BuildException ( "Cannot specify both the srcfile " + "attribute and a nested <srcfiles> " + "element." ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested " + "mapper element must be set." ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) { log ( "The targetfile \"" + _targetFile . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } if ( _sourceFile != null && ! _sourceFile . exists ( ) ) { throw new BuildException ( _sourceFile . getAbsolutePath ( ) + " not found." ) ; } Enumeration e = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; upToDate = upToDate && scanDir ( fs . getDir ( getProject ( ) ) , ds . getIncludedFiles ( ) ) ; } if ( _sourceFile != null ) { if ( mapperElement == null ) { upToDate = upToDate && ( _targetFile . lastModified ( ) >= _sourceFile . lastModified ( ) ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; upToDate = upToDate && ( sfs . restrict ( new String [ ] { _sourceFile . getAbsolutePath ( ) } , null , null , mapperElement . getImplementation ( ) ) . length == 0 ) ; } } return upToDate ; } public void execute ( ) throws BuildException { if ( _property == null ) { throw new BuildException ( "property attribute is required." , getLocation ( ) ) ; } boolean upToDate = eval ( ) ; if ( upToDate ) { this . getProject ( ) . setNewProperty ( _property , getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up-to-date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files are up-to-date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; File dir = srcDir ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; dir = null ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } } 	0	['11', '3', '0', '14', '39', '19', '1', '13', '9', '0.75', '332', '1', '1', '0.787234043', '0.327272727', '1', '1', '28.63636364', '21', '3', '0']
package org . apache . tools . ant . util ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; public class KeepAliveInputStream extends FilterInputStream { public KeepAliveInputStream ( InputStream in ) { super ( in ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '1', '3', '1', '1', '0', '2', '2', '7', '0', '0', '0.947368421', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public abstract class MappingSelector extends BaseSelector { protected File targetdir = null ; protected Mapper mapperElement = null ; protected FileNameMapper map = null ; protected int granularity = 0 ; public MappingSelector ( ) { granularity = ( int ) FileUtils . newFileUtils ( ) . getFileTimestampGranularity ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir . getName ( ) + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; boolean selected = selectionTest ( file , destfile ) ; return selected ; } protected abstract boolean selectionTest ( File srcfile , File destfile ) ; public void setGranularity ( int granularity ) { this . granularity = granularity ; } } 	0	['7', '4', '2', '10', '23', '3', '2', '8', '6', '0.666666667', '139', '1', '2', '0.853658537', '0.428571429', '1', '3', '18.28571429', '4', '1.7143', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class CvsTagEntry { String m_filename ; String m_prevRevision ; String m_revision ; public CvsTagEntry ( String filename ) { this ( filename , null , null ) ; } public CvsTagEntry ( String filename , String revision ) { this ( filename , revision , null ) ; } public CvsTagEntry ( String filename , String revision , String prevRevision ) { m_filename = filename ; m_revision = revision ; m_prevRevision = prevRevision ; } public String getFile ( ) { return m_filename ; } public String getRevision ( ) { return m_revision ; } public String getPreviousRevision ( ) { return m_prevRevision ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( m_filename ) ; if ( ( m_revision == null ) ) { buffer . append ( " was removed" ) ; if ( m_prevRevision != null ) { buffer . append ( "; previous revision was " ) . append ( m_prevRevision ) ; } } else if ( m_revision != null && m_prevRevision == null ) { buffer . append ( " is new; current revision is " ) . append ( m_revision ) ; } else if ( m_revision != null && m_prevRevision != null ) { buffer . append ( " has changed from " ) . append ( m_prevRevision ) . append ( " to " ) . append ( m_revision ) ; } return buffer . toString ( ) ; } } 	0	['7', '1', '0', '1', '11', '7', '1', '0', '7', '0.333333333', '105', '0', '0', '0', '0.714285714', '0', '0', '13.57142857', '7', '1.4286', '0']
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static final StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0	['3', '1', '0', '5', '19', '1', '0', '5', '2', '0.5', '89', '1', '0', '0', '0.5', '0', '0', '28.33333333', '1', '0.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public abstract class BaseSelector extends DataType implements FileSelector { private String errmsg = null ; public BaseSelector ( ) { } public void setError ( String msg ) { if ( errmsg == null ) { errmsg = msg ; } } public String getError ( ) { return errmsg ; } public void verifySettings ( ) { } public void validate ( ) { if ( getError ( ) == null ) { verifySettings ( ) ; } if ( getError ( ) != null ) { throw new BuildException ( errmsg ) ; } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; } 	0	['6', '3', '5', '18', '8', '3', '15', '3', '6', '0.4', '39', '1', '0', '0.857142857', '0.5', '0', '0', '5.333333333', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class AndSelector extends BaseSelectorContainer { public AndSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{andselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; } } 	0	['3', '5', '0', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant ; import java . io . IOException ; import java . io . InputStream ; public class DemuxInputStream extends InputStream { private Project project ; public DemuxInputStream ( Project project ) { this . project = project ; } public int read ( ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; if ( project . demuxInput ( buffer , 0 , 1 ) == - 1 ) { return - 1 ; } return buffer [ 0 ] ; } public int read ( byte [ ] buffer , int offset , int length ) throws IOException { return project . demuxInput ( buffer , offset , length ) ; } } 	0	['3', '2', '0', '2', '5', '0', '1', '1', '3', '0', '34', '1', '1', '0.818181818', '0.5', '1', '2', '10', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; private int index = - 1 ; public abstract String [ ] getValues ( ) ; protected EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { int index = indexOfValue ( value ) ; if ( index == - 1 ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . index = index ; this . value = value ; } public final boolean containsValue ( String value ) { return ( indexOfValue ( value ) != - 1 ) ; } public final int indexOfValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return - 1 ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return i ; } } return - 1 ; } public final String getValue ( ) { return value ; } public final int getIndex ( ) { return index ; } public String toString ( ) { return getValue ( ) ; } } 	0	['8', '1', '33', '59', '14', '20', '58', '1', '7', '0.714285714', '87', '1', '0', '0', '0.6875', '0', '0', '9.625', '5', '1.5', '0']
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '2064', '0', '0', '0', '0', '0', '0', '2052', '0', '0', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public abstract class DataType extends ProjectComponent { protected String description ; protected Reference ref ; protected boolean checked = true ; public void setDescription ( final String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( final Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( final Stack stack , final Project project ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( project ) ; if ( o instanceof DataType ) { if ( stack . contains ( o ) ) { throw circularReference ( ) ; } else { stack . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stack , project ) ; stack . pop ( ) ; } } checked = true ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } else { return o ; } } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one " + "attribute when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements " + "when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular " + "reference." ) ; } protected boolean isChecked ( ) { return checked ; } protected void setChecked ( final boolean checked ) { this . checked = checked ; } protected Reference getRefid ( ) { return ref ; } protected void checkAttributesAllowed ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } protected void checkChildrenAllowed ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } } } 	0	['15', '2', '15', '24', '29', '59', '20', '4', '5', '0.714285714', '169', '1', '1', '0.391304348', '0.20952381', '0', '0', '10.06666667', '3', '1.2667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class PreSetDef extends AntlibDefinition implements TaskContainer { private UnknownElement nestedTask ; private String name ; public void setName ( String name ) { this . name = name ; } public void addTask ( Task nestedTask ) { if ( this . nestedTask != null ) { throw new BuildException ( "Only one nested element allowed" ) ; } if ( ! ( nestedTask instanceof UnknownElement ) ) { throw new BuildException ( "addTask called with a task that is not an unknown element" ) ; } this . nestedTask = ( UnknownElement ) nestedTask ; } public void execute ( ) { if ( nestedTask == null ) { throw new BuildException ( "Missing nested element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( nestedTask . getNamespace ( ) , nestedTask . getTag ( ) ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { throw new BuildException ( "Unable to find typedef " + componentName ) ; } PreSetDefinition newDef = new PreSetDefinition ( def , nestedTask ) ; newDef . setName ( name ) ; helper . addDataTypeDefinition ( newDef ) ; } public static class PreSetDefinition extends AntTypeDefinition { private AntTypeDefinition parent ; private UnknownElement element ; public PreSetDefinition ( AntTypeDefinition parent , UnknownElement el ) { if ( parent instanceof PreSetDefinition ) { PreSetDefinition p = ( PreSetDefinition ) parent ; el . applyPreSet ( p . element ) ; parent = p . parent ; } this . parent = parent ; this . element = el ; } public void setClass ( Class clazz ) { throw new BuildException ( "Not supported" ) ; } public void setClassName ( String className ) { throw new BuildException ( "Not supported" ) ; } public String getClassName ( ) { return parent . getClassName ( ) ; } public void setAdapterClass ( Class adapterClass ) { throw new BuildException ( "Not supported" ) ; } public void setAdaptToClass ( Class adaptToClass ) { throw new BuildException ( "Not supported" ) ; } public void setClassLoader ( ClassLoader classLoader ) { throw new BuildException ( "Not supported" ) ; } public ClassLoader getClassLoader ( ) { return parent . getClassLoader ( ) ; } public Class getExposedClass ( Project project ) { return parent . getExposedClass ( project ) ; } public Class getTypeClass ( Project project ) { return parent . getTypeClass ( project ) ; } public void checkClass ( Project project ) { parent . checkClass ( project ) ; } public Object createObject ( Project project ) { Object o = parent . create ( project ) ; if ( o == null ) { return null ; } return o ; } public UnknownElement getPreSets ( ) { return element ; } public Object create ( Project project ) { return this ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( other . getClass ( ) != getClass ( ) ) { return false ; } PreSetDefinition otherDef = ( PreSetDefinition ) other ; if ( ! parent . sameDefinition ( otherDef . parent , project ) ) { return false ; } if ( ! element . similar ( otherDef . element ) ) { return false ; } return true ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( ! other . getClass ( ) . getName ( ) . equals ( getClass ( ) . getName ( ) ) ) { return false ; } PreSetDefinition otherDef = ( PreSetDefinition ) other ; if ( ! parent . similarDefinition ( otherDef . parent , project ) ) { return false ; } if ( ! element . similar ( otherDef . element ) ) { return false ; } return true ; } } } 	0	['4', '4', '0', '11', '19', '2', '0', '11', '4', '0.666666667', '102', '1', '1', '0.931818182', '0.5', '0', '0', '24', '4', '2', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . TimeZone ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat c_inputDate = new SimpleDateFormat ( "yyyy/MM/dd HH:mm:ss" ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; c_inputDate . setTimeZone ( utc ) ; } private String m_file ; private String m_date ; private String m_author ; private String m_comment ; private String m_revision ; private String m_previousRevision ; private int m_status = GET_FILE ; private final Hashtable m_entries = new Hashtable ( ) ; CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ m_entries . size ( ) ] ; Enumeration e = m_entries . elements ( ) ; int i = 0 ; while ( e . hasMoreElements ( ) ) { array [ i ++ ] = ( CVSEntry ) e . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( m_status ) { case GET_FILE : reset ( ) ; processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . startsWith ( "======" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; saveEntry ( ) ; m_status = GET_FILE ; } else if ( line . startsWith ( "----------------------------" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; m_status = GET_PREVIOUS_REV ; } else { m_comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { m_file = line . substring ( 14 , line . length ( ) ) ; m_status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { m_revision = line . substring ( 9 ) ; m_status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { m_status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { m_date = line . substring ( 6 , 25 ) ; String lineData = line . substring ( line . indexOf ( ";" ) + 1 ) ; m_author = lineData . substring ( 10 , lineData . indexOf ( ";" ) ) ; m_status = GET_COMMENT ; m_comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision" ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } m_previousRevision = line . substring ( 9 ) ; saveEntry ( ) ; m_revision = m_previousRevision ; m_status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = m_date + m_author + m_comment ; CVSEntry entry ; if ( ! m_entries . containsKey ( entryKey ) ) { entry = new CVSEntry ( parseDate ( m_date ) , m_author , m_comment ) ; m_entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) m_entries . get ( entryKey ) ; } entry . addFile ( m_file , m_revision , m_previousRevision ) ; } private Date parseDate ( final String date ) { try { return c_inputDate . parse ( date ) ; } catch ( ParseException e ) { return null ; } } private void reset ( ) { m_file = null ; m_date = null ; m_author = null ; m_comment = null ; m_revision = null ; m_previousRevision = null ; } } 	0	['12', '1', '0', '4', '37', '0', '3', '1', '1', '0.766233766', '340', '1', '0', '0', '0.818181818', '0', '0', '26.16666667', '3', '1.6667', '0']
package org . apache . tools . ant . util . regexp ; public class RegexpUtil { public static final boolean hasFlag ( int options , int flag ) { return ( ( options & flag ) > 0 ) ; } public static final int removeFlag ( int options , int flag ) { return ( options & ( 0xFFFFFFFF - flag ) ) ; } } 	0	['3', '1', '0', '0', '4', '3', '0', '0', '3', '2', '20', '0', '0', '0', '0.5', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . tools . ant . types . resolver ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . ResourceLocation ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogManager ; import org . apache . xml . resolver . tools . CatalogResolver ; public class ApacheCatalogResolver extends CatalogResolver { private XMLCatalog xmlCatalog = null ; static { CatalogManager . getStaticManager ( ) . setIgnoreMissingProperties ( true ) ; System . getProperties ( ) . put ( "xml.catalog.className" , ApacheCatalog . class . getName ( ) ) ; CatalogManager . getStaticManager ( ) . setUseStaticCatalog ( false ) ; } public void setXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog = xmlCatalog ; } public void parseCatalog ( String file ) { Catalog _catalog = getCatalog ( ) ; if ( ! ( _catalog instanceof ApacheCatalog ) ) { throw new BuildException ( "Wrong catalog type found: " + _catalog . getClass ( ) . getName ( ) ) ; } ApacheCatalog catalog = ( ApacheCatalog ) _catalog ; catalog . setResolver ( this ) ; try { catalog . parseCatalog ( file ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( ex ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } public void addPublicEntry ( String publicid , String systemid , URL base ) { ResourceLocation dtd = new ResourceLocation ( ) ; dtd . setBase ( base ) ; dtd . setPublicId ( publicid ) ; dtd . setLocation ( systemid ) ; xmlCatalog . addDTD ( dtd ) ; } public void addURIEntry ( String uri , String altURI , URL base ) { ResourceLocation entity = new ResourceLocation ( ) ; entity . setBase ( base ) ; entity . setPublicId ( uri ) ; entity . setLocation ( altURI ) ; xmlCatalog . addEntity ( entity ) ; } } 	0	['7', '2', '0', '7', '32', '9', '1', '7', '5', '0.75', '128', '0.5', '1', '0.545454545', '0.5', '0', '0', '17', '2', '0.8571', '0']
package org . apache . tools . ant . filters ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public abstract class BaseFilterReader extends FilterReader { private static final int BUFFER_SIZE = 8192 ; private boolean initialized = false ; private Project project = null ; public BaseFilterReader ( ) { super ( new StringReader ( new String ( ) ) ) ; try { close ( ) ; } catch ( IOException ioe ) { } } public BaseFilterReader ( final Reader in ) { super ( in ) ; } public final int read ( final char [ ] cbuf , final int off , final int len ) throws IOException { for ( int i = 0 ; i < len ; i ++ ) { final int ch = read ( ) ; if ( ch == - 1 ) { if ( i == 0 ) { return - 1 ; } else { return i ; } } cbuf [ off + i ] = ( char ) ch ; } return len ; } public final long skip ( final long n ) throws IOException , IllegalArgumentException { if ( n < 0L ) { throw new IllegalArgumentException ( "skip value is negative" ) ; } for ( long i = 0 ; i < n ; i ++ ) { if ( read ( ) == - 1 ) { return i ; } } return n ; } protected final void setInitialized ( final boolean initialized ) { this . initialized = initialized ; } protected final boolean getInitialized ( ) { return initialized ; } public final void setProject ( final Project project ) { this . project = project ; } protected final Project getProject ( ) { return project ; } protected final String readLine ( ) throws IOException { int ch = in . read ( ) ; if ( ch == - 1 ) { return null ; } StringBuffer line = new StringBuffer ( ) ; while ( ch != - 1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n' ) { break ; } ch = in . read ( ) ; } return line . toString ( ) ; } protected final String readFully ( ) throws IOException { return FileUtils . readFully ( in , BUFFER_SIZE ) ; } } 	0	['10', '3', '6', '20', '21', '23', '18', '2', '5', '0.814814815', '151', '1', '1', '0.692307692', '0.228571429', '1', '2', '13.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private FacadeTaskHelper facade ; public Rmic ( ) { try { Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; facade = new FacadeTaskHelper ( "kaffe" ) ; } catch ( ClassNotFoundException cnfe ) { facade = new FacadeTaskHelper ( "sun" ) ; } } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , getLocation ( ) ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , getLocation ( ) ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { final String generatedFile = generatedFiles [ i ] ; if ( ! generatedFile . endsWith ( ".class" ) ) { continue ; } final int pos = generatedFile . length ( ) - ".class" . length ( ) ; String sourceFileName = generatedFile . substring ( 0 , pos ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { fileUtils . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { fileUtils . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	0	['48', '4', '0', '25', '109', '964', '7', '20', '44', '0.946301925', '819', '0.952380952', '4', '0.624', '0.154166667', '3', '3', '15.625', '7', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Task ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { System . err . println ( "As of Ant 1.2 released in October 2000, the " + "TaskOutputStream class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '10', '0', '0', '1', '1', '0', '67', '1', '1', '0.714285714', '0.666666667', '1', '1', '20.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private static final int MAXIMUM_COMRESSION_LEVEL = 9 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private static final String DEFAULT_COMMAND = "checkout" ; private String command = null ; private boolean quiet = false ; private boolean reallyquiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) { this . setPassfile ( defaultPassFile ) ; } } if ( passFile != null ) { if ( passFile . isFile ( ) && passFile . canRead ( ) ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_INFO ) ; } else if ( ! passFile . canRead ( ) ) { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not readable" , Project . MSG_WARN ) ; } else { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not a file" , Project . MSG_WARN ) ; } } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( dest == null ) { dest = getProject ( ) . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && Execute . isFailure ( retCode ) ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , getLocation ( ) ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } else { Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { } } if ( errorStream != null ) { try { errorStream . close ( ) ; } catch ( IOException e ) { } } } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . DEFAULT_COMMAND ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-r" ) ; addCommandArgument ( p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setReallyquiet ( boolean q ) { reallyquiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression <= MAXIMUM_COMRESSION_LEVEL ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet && ! reallyquiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( reallyquiet ) { c . createArgument ( true ) . setValue ( "-Q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	0	['41', '3', '2', '17', '105', '700', '2', '15', '32', '0.925', '988', '0.956521739', '2', '0.480519481', '0.195121951', '0', '0', '22.53658537', '10', '1.6341', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; public interface Tokenizer { String getToken ( Reader in ) throws IOException ; String getPostToken ( ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public class AntTypeDefinition { private String name ; private Class clazz ; private Class adapterClass ; private Class adaptToClass ; private String className ; private ClassLoader classLoader ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setClass ( Class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } if ( classLoader == null ) { this . classLoader = clazz . getClassLoader ( ) ; } if ( className == null ) { this . className = clazz . getName ( ) ; } } public void setClassName ( String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public Class getExposedClass ( Project project ) { if ( adaptToClass != null ) { Class z = getTypeClass ( project ) ; if ( z == null ) { return null ; } if ( adaptToClass . isAssignableFrom ( z ) ) { return z ; } } if ( adapterClass != null ) { return adapterClass ; } return getTypeClass ( project ) ; } public Class getTypeClass ( Project project ) { if ( clazz != null ) { return clazz ; } try { if ( classLoader == null ) { clazz = Class . forName ( className ) ; } else { clazz = classLoader . loadClass ( className ) ; } } catch ( NoClassDefFoundError ncdfe ) { project . log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for type " + name , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { project . log ( "Could not load class (" + className + ") for type " + name , Project . MSG_DEBUG ) ; } return clazz ; } public Object create ( Project project ) { return icreate ( project ) ; } private Object icreate ( Project project ) { Class c = getTypeClass ( project ) ; if ( c == null ) { return null ; } Object o = createAndSet ( project , c ) ; if ( o == null || adapterClass == null ) { return o ; } if ( adaptToClass != null ) { if ( adaptToClass . isAssignableFrom ( o . getClass ( ) ) ) { return o ; } } TypeAdapter adapterObject = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapterObject == null ) { return null ; } adapterObject . setProxy ( o ) ; return adapterObject ; } public void checkClass ( Project project ) { if ( clazz == null ) { clazz = getTypeClass ( project ) ; if ( clazz == null ) { throw new BuildException ( "Unable to create class for " + getName ( ) ) ; } } if ( adapterClass != null ) { boolean needToCheck = true ; if ( adaptToClass != null && adaptToClass . isAssignableFrom ( clazz ) ) { needToCheck = false ; } if ( needToCheck ) { TypeAdapter adapter = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapter == null ) { throw new BuildException ( "Unable to create adapter object" ) ; } adapter . checkProxyClass ( clazz ) ; } } } private Object createAndSet ( Project project , Class c ) { try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { project } ) ; } project . setProjectReference ( o ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "Type " + name + ": A class needed by class " + c + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe ) ; } catch ( Throwable t ) { throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( other . getClass ( ) != this . getClass ( ) ) { return false ; } if ( ! ( other . getTypeClass ( project ) . equals ( getTypeClass ( project ) ) ) ) { return false ; } if ( ! other . getExposedClass ( project ) . equals ( getExposedClass ( project ) ) ) { return false ; } if ( other . adapterClass != adapterClass ) { return false ; } if ( other . adaptToClass != adaptToClass ) { return false ; } return true ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( getClass ( ) != other . getClass ( ) ) { return false ; } if ( ! getClassName ( ) . equals ( other . getClassName ( ) ) ) { return false ; } if ( ! extractClassname ( adapterClass ) . equals ( extractClassname ( other . adapterClass ) ) ) { return false ; } if ( ! extractClassname ( adaptToClass ) . equals ( extractClassname ( other . adaptToClass ) ) ) { return false ; } ClassLoader oldLoader = other . getClassLoader ( ) ; ClassLoader newLoader = this . getClassLoader ( ) ; if ( oldLoader != null && newLoader != null && oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) { return true ; } else { return false ; } } private String extractClassname ( Class c ) { if ( c == null ) { return "<null>" ; } else { return c . getClass ( ) . getName ( ) ; } } } 	0	['20', '1', '2', '11', '45', '112', '7', '4', '16', '0.684210526', '543', '0.857142857', '0', '0', '0.316666667', '0', '0', '25.8', '11', '3', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; write ( root , wri , 0 , "  " ) ; wri . flush ( ) ; } public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( "]]>" ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( "&#x5d;&#x5d;&gt;" ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( "]]>" ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } 	0	['8', '1', '0', '1', '42', '24', '1', '0', '7', '0.714285714', '485', '1', '0', '0', '0.346938776', '0', '0', '59.375', '11', '4', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { return newRegexpMatcher ( null ) ; } public RegexpMatcher newRegexpMatcher ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { testAvailability ( "java.util.regex.Matcher" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.regexp.RE" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } protected void testAvailability ( String className ) throws BuildException { try { Class . forName ( className ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['5', '1', '1', '6', '12', '10', '3', '3', '3', '2', '86', '0', '0', '0', '0.533333333', '0', '0', '16.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { private String validargs = null ; private String message = "" ; private String addproperty = null ; private String defaultvalue = null ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; } public void setDefaultvalue ( String defaultvalue ) { this . defaultvalue = defaultvalue ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { if ( addproperty != null && getProject ( ) . getProperty ( addproperty ) != null ) { log ( "skipping " + getTaskName ( ) + " as property " + addproperty + " has already been set." ) ; return ; } InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } getProject ( ) . getInputHandler ( ) . handleInput ( request ) ; String value = request . getInput ( ) ; if ( ( value == null || value . trim ( ) . length ( ) == 0 ) && defaultvalue != null ) { value = defaultvalue ; } if ( addproperty != null && value != null ) { getProject ( ) . setNewProperty ( addproperty , value ) ; } } } 	0	['7', '3', '0', '8', '25', '0', '0', '8', '7', '0.625', '141', '1', '0', '0.860465116', '0.857142857', '1', '1', '18.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public class ContainsRegexpSelector extends BaseExtendSelector { private String userProvidedExpression = null ; private RegularExpression myRegExp = null ; private Regexp myExpression = null ; public static final String EXPRESSION_KEY = "expression" ; public ContainsRegexpSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsregexpselector expression: " ) ; buf . append ( userProvidedExpression ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setExpression ( String theexpression ) { this . userProvidedExpression = theexpression ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( EXPRESSION_KEY . equalsIgnoreCase ( paramname ) ) { setExpression ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( userProvidedExpression == null ) { setError ( "The expression attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { String teststr = null ; BufferedReader in = null ; validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } if ( myRegExp == null ) { myRegExp = new RegularExpression ( ) ; myRegExp . setPattern ( userProvidedExpression ) ; myExpression = myRegExp . getRegexp ( getProject ( ) ) ; } try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; teststr = in . readLine ( ) ; while ( teststr != null ) { if ( myExpression . matches ( teststr ) ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read file " + filename ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close file " + filename ) ; } } } } } 	0	['6', '5', '0', '14', '29', '0', '5', '9', '6', '0.7', '224', '0.75', '2', '0.88372093', '0.416666667', '1', '4', '35.66666667', '8', '2.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private static final String OS_NAME = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String OS_ARCH = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String OS_VERSION = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { if ( family . equals ( "windows" ) ) { isFamily = OS_NAME . indexOf ( "windows" ) > - 1 ; } else if ( family . equals ( "os/2" ) ) { isFamily = OS_NAME . indexOf ( "os/2" ) > - 1 ; } else if ( family . equals ( "netware" ) ) { isFamily = OS_NAME . indexOf ( "netware" ) > - 1 ; } else if ( family . equals ( "dos" ) ) { isFamily = PATH_SEP . equals ( ";" ) && ! isFamily ( "netware" ) ; } else if ( family . equals ( "mac" ) ) { isFamily = OS_NAME . indexOf ( "mac" ) > - 1 ; } else if ( family . equals ( "tandem" ) ) { isFamily = OS_NAME . indexOf ( "nonstop_kernel" ) > - 1 ; } else if ( family . equals ( "unix" ) ) { isFamily = PATH_SEP . equals ( ":" ) && ! isFamily ( "openvms" ) && ( ! isFamily ( "mac" ) || OS_NAME . endsWith ( "x" ) ) ; } else if ( family . equals ( "win9x" ) ) { isFamily = isFamily ( "windows" ) && ( OS_NAME . indexOf ( "95" ) >= 0 || OS_NAME . indexOf ( "98" ) >= 0 || OS_NAME . indexOf ( "me" ) >= 0 || OS_NAME . indexOf ( "ce" ) >= 0 ) ; } else if ( family . equals ( "z/os" ) ) { isFamily = OS_NAME . indexOf ( "z/os" ) > - 1 || OS_NAME . indexOf ( "os/390" ) > - 1 ; } else if ( family . equals ( "os/400" ) ) { isFamily = OS_NAME . indexOf ( "os/400" ) > - 1 ; } else if ( family . equals ( "openvms" ) ) { isFamily = OS_NAME . indexOf ( "openvms" ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( OS_NAME ) ; } if ( arch != null ) { isArch = arch . equals ( OS_ARCH ) ; } if ( version != null ) { isVersion = version . equals ( OS_VERSION ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	0	['13', '1', '0', '14', '23', '68', '12', '2', '12', '0.697916667', '357', '1', '0', '0', '0.708333333', '0', '0', '25.84615385', '44', '4.0769', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public final class AntFilterReader extends DataType implements Cloneable { private String className ; private final Vector parameters = new Vector ( ) ; private Path classpath ; public final void setClassName ( final String className ) { this . className = className ; } public final String getClassName ( ) { return className ; } public final void addParam ( final Parameter param ) { parameters . addElement ( param ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public final Parameter [ ] getParams ( ) { Parameter [ ] params = new Parameter [ parameters . size ( ) ] ; parameters . copyInto ( params ) ; return params ; } public void setRefid ( Reference r ) throws BuildException { if ( ! parameters . isEmpty ( ) || className != null || classpath != null ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof AntFilterReader ) { AntFilterReader afr = ( AntFilterReader ) o ; setClassName ( afr . getClassName ( ) ) ; setClasspath ( afr . getClasspath ( ) ) ; Parameter [ ] p = afr . getParams ( ) ; if ( p != null ) { for ( int i = 0 ; i < p . length ; i ++ ) { addParam ( p [ i ] ) ; } } } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterReader" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['10', '3', '0', '9', '31', '15', '2', '7', '10', '0.666666667', '166', '1', '1', '0.769230769', '0.3', '1', '1', '15.3', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class KaffeRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; try { Class c = Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Constructor cons = c . getConstructor ( new Class [ ] { String [ ] . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { cmd . getArguments ( ) } ) ; Method doRmic = c . getMethod ( "run" , null ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , null ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use Kaffe rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting Kaffe rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } } 	0	['3', '2', '0', '7', '19', '3', '1', '6', '2', '1', '93', '0', '0', '0.866666667', '0.5', '0', '0', '29.66666667', '1', '0.6667', '0']
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class SendEmail extends EmailTask { public void setMailport ( Integer value ) { setMailport ( value . intValue ( ) ) ; } } 	0	['2', '4', '0', '1', '5', '1', '0', '1', '2', '2', '10', '0', '0', '0.985507246', '0.75', '1', '1', '4', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class PathConvert extends Task { private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private boolean setonempty = true ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; public PathConvert ( ) { onWindows = Os . isFamily ( "dos" ) ; } public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set " + "in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public static class TargetOs extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "windows" , "unix" , "netware" , "os/2" , "tandem" } ; } } public Path createPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { TargetOs to = new TargetOs ( ) ; to . setValue ( target ) ; setTargetos ( to ) ; } public void setTargetos ( TargetOs target ) { targetOS = target . getValue ( ) ; targetWindows = ! targetOS . equals ( "unix" ) && ! targetOS . equals ( "tandem" ) ; } public void setSetonempty ( boolean setonempty ) { this . setonempty = setonempty ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) { throw noChildrenAllowed ( ) ; } refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { Path savedPath = path ; String savedPathSep = pathSep ; String savedDirSep = dirSep ; try { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else if ( obj instanceof DirSet ) { DirSet ds = ( DirSet ) obj ; path . addDirset ( ds ) ; } else if ( obj instanceof FileList ) { FileList fl = ( FileList ) obj ; path . addFilelist ( fl ) ; } else { throw new BuildException ( "'refid' does not refer to a " + "path, fileset, dirset, or " + "filelist." ) ; } } validateSetup ( ) ; String fromDirSep = onWindows ? "\\" : "/" ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; if ( i != 0 ) { rslt . append ( pathSep ) ; } StringTokenizer stDirectory = new StringTokenizer ( elem , fromDirSep , true ) ; String token = null ; while ( stDirectory . hasMoreTokens ( ) ) { token = stDirectory . nextToken ( ) ; if ( fromDirSep . equals ( token ) ) { rslt . append ( dirSep ) ; } else { rslt . append ( token ) ; } } } String value = rslt . toString ( ) ; if ( setonempty ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { if ( rslt . length ( ) > 0 ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } finally { path = savedPath ; dirSep = savedDirSep ; pathSep = savedPathSep ; } } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) { throw new BuildException ( "You must specify a path to convert" ) ; } if ( property == null ) { throw new BuildException ( "You must specify a property" ) ; } if ( targetOS == null && pathSep == null && dirSep == null ) { throw new BuildException ( "You must specify at least one of " + "targetOS, dirSep, or pathSep" ) ; } String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested <path> " + "elements when using the refid attribute." ) ; } } 	0	['16', '3', '0', '13', '48', '58', '1', '13', '12', '0.786666667', '485', '1', '2', '0.711538462', '0.25', '2', '2', '28.6875', '4', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class LazyFileOutputStream extends OutputStream { private FileOutputStream fos ; private File file ; private boolean append ; private boolean opened = false ; private boolean closed = false ; public LazyFileOutputStream ( String name ) { this ( name , false ) ; } public LazyFileOutputStream ( String name , boolean append ) { this ( new File ( name ) , append ) ; } public LazyFileOutputStream ( File f ) { this ( f , false ) ; } public LazyFileOutputStream ( File file , boolean append ) { this . file = file ; this . append = append ; } public void open ( ) throws IOException { ensureOpened ( ) ; } public synchronized void close ( ) throws IOException { if ( opened ) { fos . close ( ) ; } closed = true ; } public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } public synchronized void write ( byte [ ] b , int offset , int len ) throws IOException { ensureOpened ( ) ; fos . write ( b , offset , len ) ; } public synchronized void write ( int b ) throws IOException { ensureOpened ( ) ; fos . write ( b ) ; } private synchronized void ensureOpened ( ) throws IOException { if ( closed ) { throw new IOException ( file + " has already been closed." ) ; } if ( ! opened ) { fos = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; opened = true ; } } } 	0	['10', '2', '0', '1', '22', '29', '1', '0', '9', '0.311111111', '117', '1', '0', '0.454545455', '0.333333333', '1', '1', '10.2', '1', '0.6', '0']
package org . apache . tools . ant ; public interface DynamicConfigurator { void setDynamicAttribute ( String name , String value ) throws BuildException ; Object createDynamicElement ( String name ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . types . Resource ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { patDirs = null ; strDirs = null ; return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxEnd ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxEnd ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs [ i ] . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = patDirs [ patIdxStart + j + 1 ] ; String subStr = strDirs [ strIdxStart + i + j ] ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { return tokenizePath ( path , File . separator ) ; } public static Vector tokenizePath ( String path , String separator ) { Vector ret = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( path , separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } private static String [ ] tokenizePathAsArray ( String path ) { char sep = File . separatorChar ; int start = 0 ; int len = path . length ( ) ; int count = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { count ++ ; } start = pos + 1 ; } } if ( len != start ) { count ++ ; } String [ ] l = new String [ count ] ; count = 0 ; start = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { String tok = path . substring ( start , pos ) ; l [ count ++ ] = tok ; } start = pos + 1 ; } } if ( len != start ) { String tok = path . substring ( start ) ; l [ count ] = tok ; } return l ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } public static boolean isOutOfDate ( Resource src , Resource target , int granularity ) { if ( ! src . isExists ( ) ) { return false ; } if ( ! target . isExists ( ) ) { return true ; } if ( ( src . getLastModified ( ) - granularity ) > target . getLastModified ( ) ) { return true ; } return false ; } public static String removeWhitespace ( String input ) { StringBuffer result = new StringBuffer ( ) ; if ( input != null ) { StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { result . append ( st . nextToken ( ) ) ; } } return result . toString ( ) ; } public static boolean hasWildcards ( String input ) { return ( input . indexOf ( '*' ) != - 1 || input . indexOf ( '?' ) != - 1 ) ; } public static String rtrimWildcardTokens ( String input ) { Vector v = tokenizePath ( input , File . separator ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int counter = 0 ; counter < v . size ( ) ; counter ++ ) { if ( hasWildcards ( ( String ) v . elementAt ( counter ) ) ) { break ; } if ( counter > 0 ) { sb . append ( File . separator ) ; } sb . append ( ( String ) v . elementAt ( counter ) ) ; } return sb . toString ( ) ; } } 	0	['17', '1', '0', '6', '42', '134', '5', '1', '14', '0.9375', '936', '1', '1', '0', '0.208333333', '0', '0', '54', '47', '6.8824', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class SizeSelector extends BaseExtendSelector { private long size = - 1 ; private long multiplier = 1 ; private long sizelimit = - 1 ; private int cmp = 2 ; public static final String SIZE_KEY = "value" ; public static final String UNITS_KEY = "units" ; public static final String WHEN_KEY = "when" ; public SizeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{sizeselector value: " ) ; buf . append ( sizelimit ) ; buf . append ( "compare: " ) ; if ( cmp == 0 ) { buf . append ( "less" ) ; } else if ( cmp == 1 ) { buf . append ( "more" ) ; } else { buf . append ( "equal" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setValue ( long size ) { this . size = size ; if ( ( multiplier != 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setUnits ( ByteUnits units ) { int i = units . getIndex ( ) ; multiplier = 0 ; if ( ( i > - 1 ) && ( i < 4 ) ) { multiplier = 1000 ; } else if ( ( i > 3 ) && ( i < 9 ) ) { multiplier = 1024 ; } else if ( ( i > 8 ) && ( i < 13 ) ) { multiplier = 1000000 ; } else if ( ( i > 12 ) && ( i < 18 ) ) { multiplier = 1048576 ; } else if ( ( i > 17 ) && ( i < 22 ) ) { multiplier = 1000000000L ; } else if ( ( i > 21 ) && ( i < 27 ) ) { multiplier = 1073741824L ; } else if ( ( i > 26 ) && ( i < 31 ) ) { multiplier = 1000000000000L ; } else if ( ( i > 30 ) && ( i < 36 ) ) { multiplier = 1099511627776L ; } if ( ( multiplier > 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setWhen ( SizeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( SIZE_KEY . equalsIgnoreCase ( paramname ) ) { try { setValue ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid size setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( UNITS_KEY . equalsIgnoreCase ( paramname ) ) { ByteUnits units = new ByteUnits ( ) ; units . setValue ( parameters [ i ] . getValue ( ) ) ; setUnits ( units ) ; } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { SizeComparisons cmp = new SizeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( size < 0 ) { setError ( "The value attribute is required, and must be positive" ) ; } else if ( multiplier < 1 ) { setError ( "Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti" ) ; } else if ( sizelimit < 0 ) { setError ( "Internal error: Code is not setting sizelimit correctly" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } if ( cmp == 0 ) { return ( file . length ( ) < sizelimit ) ; } else if ( cmp == 1 ) { return ( file . length ( ) > sizelimit ) ; } else { return ( file . length ( ) == sizelimit ) ; } } public static class ByteUnits extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "K" , "k" , "kilo" , "KILO" , "Ki" , "KI" , "ki" , "kibi" , "KIBI" , "M" , "m" , "mega" , "MEGA" , "Mi" , "MI" , "mi" , "mebi" , "MEBI" , "G" , "g" , "giga" , "GIGA" , "Gi" , "GI" , "gi" , "gibi" , "GIBI" , "T" , "t" , "tera" , "TERA" , "Ti" , "TI" , "ti" , "tebi" , "TEBI" } ; } } public static class SizeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "less" , "more" , "equal" } ; } } } 	0	['8', '5', '0', '11', '28', '0', '5', '6', '8', '0.693877551', '366', '0.571428571', '0', '0.844444444', '0.25', '1', '4', '43.875', '19', '5.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; public class DefaultExcludes extends Task { private String add = "" ; private String remove = "" ; private boolean defaultrequested = false ; private boolean echo = false ; private int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( ! defaultrequested && add . equals ( "" ) && remove . equals ( "" ) && ! echo ) { throw new BuildException ( "<defaultexcludes> task must set " + "at least one attribute (echo=\"false\"" + " doesn't count since that is the default" ) ; } if ( defaultrequested ) { DirectoryScanner . resetDefaultExcludes ( ) ; } if ( ! add . equals ( "" ) ) { DirectoryScanner . addDefaultExclude ( add ) ; } if ( ! remove . equals ( "" ) ) { DirectoryScanner . removeDefaultExclude ( remove ) ; } if ( echo ) { StringBuffer message = new StringBuffer ( "Current Default Excludes:\n" ) ; String [ ] excludes = DirectoryScanner . getDefaultExcludes ( ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { message . append ( "  " + excludes [ i ] + "\n" ) ; } log ( message . toString ( ) , logLevel ) ; } } public void setDefault ( boolean def ) { defaultrequested = def ; } public void setAdd ( String add ) { this . add = add ; } public void setRemove ( String remove ) { this . remove = remove ; } public void setEcho ( boolean echo ) { this . echo = echo ; } } 	0	['6', '3', '0', '3', '18', '0', '0', '3', '6', '0.64', '128', '1', '0', '0.880952381', '0.555555556', '2', '2', '19.5', '1', '0.8333', '0']
package org . apache . tools . ant . util ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; public class LoaderUtils { public static void setContextClassLoader ( ClassLoader loader ) { Thread currentThread = Thread . currentThread ( ) ; currentThread . setContextClassLoader ( loader ) ; } public static ClassLoader getContextClassLoader ( ) { Thread currentThread = Thread . currentThread ( ) ; return currentThread . getContextClassLoader ( ) ; } public static boolean isContextLoaderAvailable ( ) { return true ; } private static File normalizeSource ( File source ) { if ( source != null ) { FileUtils fileUtils = FileUtils . newFileUtils ( ) ; try { source = fileUtils . normalize ( source . getAbsolutePath ( ) ) ; } catch ( BuildException e ) { } } return source ; } public static File getClassSource ( Class c ) { return normalizeSource ( Locator . getClassSource ( c ) ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = LoaderUtils . class . getClassLoader ( ) ; } return normalizeSource ( Locator . getResourceSource ( c , resource ) ) ; } } 	0	['8', '1', '0', '6', '21', '28', '3', '3', '6', '1', '70', '0', '0', '0', '0.175', '0', '0', '7.625', '3', '1.25', '0']
