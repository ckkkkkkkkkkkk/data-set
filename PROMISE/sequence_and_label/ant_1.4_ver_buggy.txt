package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . util . Hashtable ; import java . util . Vector ; import java . io . File ; import java . io . IOException ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private boolean parallel = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple srcfile elements." , location ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple targetfile elements." , location ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( taskName ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 ) { throw new BuildException ( "no filesets specified" , location ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , location ) ; } if ( mapperElement == null ) { throw new BuildException ( "no dest attribute specified" , location ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; File base = fs . getDir ( project ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; if ( ! "dir" . equals ( type ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( type ) ) { String [ ] s = getDirs ( base , ds ) ; ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; String [ ] command = getCommandline ( s , b ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	1	['15', '4', '2', '18', '55', '37', '2', '16', '9', '0.728571429', '730', '1', '4', '0.846153846', '0.193333333', '3', '7', '47', '12', '2.4667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Properties ; import java . util . zip . * ; import java . sql . * ; public class SQLExec extends Task { static public class DelimiterType extends EnumeratedAttribute { static public final String NORMAL = "normal" ; static public final String ROW = "row" ; public String [ ] getValues ( ) { return new String [ ] { NORMAL , ROW } ; } } private int goodSql = 0 , totalSql = 0 ; private Path classpath ; private AntClassLoader loader ; private Vector filesets = new Vector ( ) ; private Connection conn = null ; private boolean autocommit = false ; private Statement statement = null ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private String delimiter = ";" ; private String delimiterType = DelimiterType . NORMAL ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String rdbms = null ; private String version = null ; private String onError = "abort" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setUserid ( String userId ) { this . userId = userId ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setDelimiter ( String delimiter ) { this . delimiter = delimiter ; } public void setDelimiterType ( DelimiterType delimiterType ) { this . delimiterType = delimiterType . getValue ( ) ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setRdbms ( String vendor ) { this . rdbms = vendor . toLowerCase ( ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( ) ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { sqlCommand = sqlCommand . trim ( ) ; if ( srcFile == null && sqlCommand . length ( ) == 0 && filesets . isEmpty ( ) ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file or fileset, transactions or sql statement must be set!" , location ) ; } } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File srcDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { Transaction t = createTransaction ( ) ; t . setSrc ( new File ( srcDir , srcFiles [ j ] ) ) ; } } Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; } if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , location ) ; } if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , location ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , location ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , location ) ; } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = new AntClassLoader ( project , classpath ) ; dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , location ) ; } try { log ( "connecting to " + url , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , userId ) ; info . put ( "password" , password ) ; conn = driverInstance . connect ( url , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } if ( ! isValidRdbms ( conn ) ) return ; conn . setAutoCommit ( autocommit ) ; statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! autocommit ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; try { while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; line = ProjectHelper . replaceProperties ( project , line , project . getProperties ( ) ) ; if ( line . startsWith ( "//" ) ) continue ; if ( line . startsWith ( "--" ) ) continue ; if ( line . length ( ) > 2 && line . substring ( 0 , 3 ) . equalsIgnoreCase ( "REM" ) ) continue ; sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) sql += "\n" ; if ( delimiterType . equals ( DelimiterType . NORMAL ) && sql . endsWith ( delimiter ) || delimiterType . equals ( DelimiterType . ROW ) && line . equals ( delimiter ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - delimiter . length ( ) ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } catch ( SQLException e ) { throw e ; } } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) return true ; try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) return ; try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } else { if ( print ) { printResults ( out ) ; } } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) throw e ; log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; FileReader reader = new FileReader ( tSrcFile ) ; runStatements ( reader , out ) ; reader . close ( ) ; } } } } 	1	['26', '3', '0', '15', '108', '233', '1', '15', '22', '0.902608696', '1156', '1', '2', '0.596774194', '0.16025641', '3', '3', '42.57692308', '7', '1.2692', '1']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Date ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; public class DependSet extends MatchingTask { private Vector sourceFileSets = new Vector ( ) ; private Vector sourceFileLists = new Vector ( ) ; private Vector targetFileSets = new Vector ( ) ; private Vector targetFileLists = new Vector ( ) ; public DependSet ( ) { } public void addSrcfileset ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public void addSrcfilelist ( FileList fl ) { sourceFileLists . addElement ( fl ) ; } public void addTargetfileset ( FileSet fs ) { targetFileSets . addElement ( fs ) ; } public void addTargetfilelist ( FileList fl ) { targetFileLists . addElement ( fl ) ; } public void execute ( ) throws BuildException { if ( ( sourceFileSets . size ( ) == 0 ) && ( sourceFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <srcfileset> or <srcfilelist> element must be set" ) ; } if ( ( targetFileSets . size ( ) == 0 ) && ( targetFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <targetfileset> or <targetfilelist> element must be set" ) ; } long now = ( new Date ( ) ) . getTime ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector allTargets = new Vector ( ) ; Enumeration enumTargetSets = targetFileSets . elements ( ) ; while ( enumTargetSets . hasMoreElements ( ) ) { FileSet targetFS = ( FileSet ) enumTargetSets . nextElement ( ) ; DirectoryScanner targetDS = targetFS . getDirectoryScanner ( project ) ; String [ ] targetFiles = targetDS . getIncludedFiles ( ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFS . getDir ( project ) , targetFiles [ i ] ) ; allTargets . addElement ( dest ) ; if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } } } boolean upToDate = true ; Enumeration enumTargetLists = targetFileLists . elements ( ) ; while ( enumTargetLists . hasMoreElements ( ) ) { FileList targetFL = ( FileList ) enumTargetLists . nextElement ( ) ; String [ ] targetFiles = targetFL . getFiles ( project ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFL . getDir ( project ) , targetFiles [ i ] ) ; if ( ! dest . exists ( ) ) { log ( targetFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; continue ; } else { allTargets . addElement ( dest ) ; } if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } } } if ( upToDate ) { Enumeration enumSourceSets = sourceFileSets . elements ( ) ; while ( upToDate && enumSourceSets . hasMoreElements ( ) ) { FileSet sourceFS = ( FileSet ) enumSourceSets . nextElement ( ) ; DirectoryScanner sourceDS = sourceFS . getDirectoryScanner ( project ) ; String [ ] sourceFiles = sourceDS . getIncludedFiles ( ) ; int i = 0 ; do { File src = new File ( sourceFS . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } Enumeration enumTargets = allTargets . elements ( ) ; while ( upToDate && enumTargets . hasMoreElements ( ) ) { File dest = ( File ) enumTargets . nextElement ( ) ; if ( src . lastModified ( ) > dest . lastModified ( ) ) { log ( dest . getPath ( ) + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; upToDate = false ; } } } while ( upToDate && ( ++ i < sourceFiles . length ) ) ; } } if ( upToDate ) { Enumeration enumSourceLists = sourceFileLists . elements ( ) ; while ( upToDate && enumSourceLists . hasMoreElements ( ) ) { FileList sourceFL = ( FileList ) enumSourceLists . nextElement ( ) ; String [ ] sourceFiles = sourceFL . getFiles ( project ) ; int i = 0 ; do { File src = new File ( sourceFL . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( ! src . exists ( ) ) { log ( sourceFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; break ; } Enumeration enumTargets = allTargets . elements ( ) ; while ( upToDate && enumTargets . hasMoreElements ( ) ) { File dest = ( File ) enumTargets . nextElement ( ) ; if ( src . lastModified ( ) > dest . lastModified ( ) ) { log ( dest . getPath ( ) + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; upToDate = false ; } } } while ( upToDate && ( ++ i < sourceFiles . length ) ) ; } } if ( ! upToDate ) { log ( "Deleting all target files. " , Project . MSG_VERBOSE ) ; for ( Enumeration e = allTargets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileToRemove = ( File ) e . nextElement ( ) ; log ( "Deleting file " + fileToRemove . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; fileToRemove . delete ( ) ; } } } } 	1	['6', '4', '0', '8', '34', '0', '0', '8', '6', '0.6', '493', '1', '0', '0.939759036', '0.555555556', '1', '1', '80.5', '1', '0.8333', '2']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private String name ; private String path ; private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) return string ; final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "keytool -genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setCommand ( new Commandline ( sb . toString ( ) ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	1	['14', '3', '0', '7', '33', '65', '0', '7', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '2', '3', '27', '2', '1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . BufferedReader ; import java . io . StringReader ; import java . io . ByteArrayOutputStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; public class Execute { public final static int INVALID = Integer . MAX_VALUE ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; static { try { vmLauncher = new Java13CommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { shellLauncher = new WinNTCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( osname . indexOf ( "windows" ) >= 0 ) { CommandLauncher baseLauncher ; if ( System . getProperty ( "java.version" ) . startsWith ( "1.1" ) ) { baseLauncher = new Java11CommandLauncher ( ) ; } else { baseLauncher = new CommandLauncher ( ) ; } if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) return procEnvironment ; procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( out . toString ( ) ) ) ; String var = null ; String line , lineSep = System . getProperty ( "line.separator" ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } procEnvironment . addElement ( var ) ; } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "mac os" ) >= 0 ) { try { String version = System . getProperty ( "os.version" ) ; int majorVersion = Integer . parseInt ( version . substring ( 0 , version . indexOf ( '.' ) ) ) ; if ( majorVersion >= 10 ) { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } } catch ( NumberFormatException e ) { } String [ ] cmd = null ; return cmd ; } else if ( osname . indexOf ( "os/2" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else if ( osname . indexOf ( "indows" ) >= 0 ) { if ( osname . indexOf ( "nt" ) >= 0 || osname . indexOf ( "2000" ) >= 0 ) { String [ ] cmd = { "cmd" , "/c" , "set" } ; return cmd ; } else { String [ ] cmd = { "command.com" , "/c" , "set" } ; return cmd ; } } else { String [ ] cmd = { "/usr/bin/env" } ; return cmd ; } } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { this . streamHandler = streamHandler ; this . watchdog = watchdog ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { if ( env == null || newEnvironment ) return env ; return patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { if ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) workingDirectory = null ; else workingDirectory = wd ; } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public int execute ( ) throws IOException { CommandLauncher launcher = vmLauncher != null ? vmLauncher : shellLauncher ; if ( ! useVMLauncher ) { launcher = shellLauncher ; } final Process process = launcher . exec ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; if ( watchdog != null ) watchdog . start ( process ) ; waitFor ( process ) ; if ( watchdog != null ) watchdog . stop ( ) ; streamHandler . stop ( ) ; if ( watchdog != null ) watchdog . checkException ( ) ; return getExitValue ( ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } private String [ ] patchEnvironment ( ) { Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { int pos = env [ i ] . indexOf ( '=' ) ; String key = env [ i ] . substring ( 0 , pos + 1 ) ; int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( ( ( String ) osEnv . elementAt ( j ) ) . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; break ; } } osEnv . addElement ( env [ i ] ) ; } String [ ] result = new String [ osEnv . size ( ) ] ; osEnv . copyInto ( result ) ; return result ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . toString ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different directory under this JVM" ) ; } } private static class Java11CommandLauncher extends CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { String [ ] newcmd = new String [ cmd . length ] ; for ( int i = 0 ; i < cmd . length ; i ++ ) { newcmd [ i ] = Commandline . quoteArgument ( cmd [ i ] ) ; } if ( project != null ) { project . log ( "Execute:Java11CommandLauncher: " + Commandline . toString ( newcmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( newcmd , env ) ; } } private static class Java13CommandLauncher extends CommandLauncher { public Java13CommandLauncher ( ) throws NoSuchMethodException { _execWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . toString ( cmd ) , Project . MSG_DEBUG ) ; } Object [ ] arguments = { cmd , env , workingDir } ; return ( Process ) _execWithCWD . invoke ( Runtime . getRuntime ( ) , arguments ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } private Method _execWithCWD ; } private static class CommandLauncherProxy extends CommandLauncher { CommandLauncherProxy ( CommandLauncher launcher ) { _launcher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return _launcher . exec ( project , cmd , env ) ; } private CommandLauncher _launcher ; } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; _script = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: No project provided" ) ; } String antHome = project . getProperty ( "ant.home" ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: Property 'ant.home' not found" ) ; } String antRun = project . resolveFile ( antHome + File . separator + _script ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String _script ; } } 	1	['21', '1', '0', '27', '78', '158', '11', '17', '15', '0.735714286', '659', '0.928571429', '5', '0', '0.145', '0', '0', '29.71428571', '7', '1.6667', '1']
package org . apache . tools . ant ; import java . io . * ; public class DefaultLogger implements BuildLogger { private static int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected boolean emacsMode = false ; public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = output ; } public void setErrorPrintStream ( PrintStream err ) { this . err = err ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( lSep + "BUILD SUCCESSFUL" ) ; } else { err . println ( lSep + "BUILD FAILED" + lSep ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { error . printStackTrace ( err ) ; } else { if ( error instanceof BuildException ) { err . println ( error . toString ( ) ) ; } else { err . println ( error . getMessage ( ) ) ; } } } out . println ( lSep + "Total time: " + formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel ) { out . println ( lSep + event . getTarget ( ) . getName ( ) + ":" ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { PrintStream logTo = event . getPriority ( ) == Project . MSG_ERR ? err : out ; if ( event . getPriority ( ) <= msgOutputLevel ) { if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String msg = "[" + name + "] " ; for ( int i = 0 ; i < ( LEFT_COLUMN_SIZE - msg . length ( ) ) ; i ++ ) { logTo . print ( " " ) ; } logTo . print ( msg ) ; } } logTo . println ( event . getMessage ( ) ) ; } } protected static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	1	['14', '1', '1', '9', '34', '47', '4', '5', '12', '0.824175824', '279', '1', '0', '0', '0.307692308', '0', '0', '18.42857143', '6', '1.8571', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { public boolean eval ( ) throws BuildException ; } 	1	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class Description extends DataType { public void addText ( String text ) { String currentDescription = project . getDescription ( ) ; if ( currentDescription == null ) { project . setDescription ( text ) ; } else { project . setDescription ( currentDescription + text ) ; } } } 	1	['2', '3', '0', '3', '8', '1', '0', '3', '2', '2', '28', '0', '0', '0.967741935', '0.75', '0', '0', '13', '2', '1', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in equals" ) ; } return arg1 . equals ( arg2 ) ; } } 	1	['4', '1', '0', '3', '7', '2', '1', '2', '4', '0.666666667', '34', '1', '0', '0', '0.75', '0', '0', '7', '1', '0.75', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	1	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class Exit extends Task { private String message ; public void setMessage ( String value ) { this . message = value ; } public void execute ( ) throws BuildException { if ( message != null && message . length ( ) > 0 ) { throw new BuildException ( message ) ; } else { throw new BuildException ( "No message" ) ; } } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } } 	1	['4', '3', '0', '5', '12', '0', '0', '5', '4', '0.333333333', '48', '1', '0', '0.925', '0.75', '0', '0', '10.75', '1', '0.75', '2']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class SunRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.rmi.rmic.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use SUN rmic, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting SUN rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	1	['3', '2', '0', '8', '22', '3', '1', '7', '2', '1', '152', '0', '0', '0.866666667', '0.5', '0', '0', '48.66666667', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . io . * ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private final String BOOLEAN = "%boolean;" ; private final String TASKS = "%tasks;" ; private final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , location ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printHead ( out , project . getTaskDefinitions ( ) . keys ( ) , project . getDataTypeDefinitions ( ) . keys ( ) ) ; printTargetDecl ( out ) ; Enumeration dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) project . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = project . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; printElementDecl ( out , taskName , ( Class ) project . getTaskDefinitions ( ) . get ( taskName ) ) ; } printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , location ) ; } finally { if ( out != null ) { out . close ( ) ; } } } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( taskName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | property | taskdef | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #REQUIRED" ) ; out . println ( "          default CDATA #REQUIRED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration enum = ih . getNestedElements ( ) ; while ( enum . hasMoreElements ( ) ) { v . addElement ( ( String ) enum . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( v . size ( ) > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb . setLength ( 0 ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; enum = ih . getAttributes ( ) ; while ( enum . hasMoreElements ( ) ) { String attrName = ( String ) enum . nextElement ( ) ; if ( "id" . equals ( attrName ) ) continue ; sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( org . apache . tools . ant . types . Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } private void printTail ( PrintWriter out ) { } protected boolean isNmtoken ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } protected boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } 	1	['10', '3', '0', '7', '60', '41', '0', '7', '3', '0.9', '748', '0.6', '0', '0.804347826', '0.285714286', '0', '0', '72.8', '7', '2.1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import java . io . * ; import java . util . * ; public class Replace extends MatchingTask { private File src = null ; private NestedString token = null ; private NestedString value = new NestedString ( ) ; private File propertyFile = null ; private Properties properties = null ; private Vector replacefilters = new Vector ( ) ; private File dir = null ; private int fileCount ; private int replaceCount ; private boolean summary = false ; public class NestedString { private StringBuffer buf = new StringBuffer ( ) ; public void addText ( String val ) { buf . append ( val ) ; } public String getText ( ) { return buf . toString ( ) ; } } public class Replacefilter { private String token ; private String value ; private String property ; public void validate ( ) throws BuildException { if ( token == null ) { String message = "token is a mandatory attribute " + "of replacefilter." ; throw new BuildException ( message ) ; } if ( "" . equals ( token ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message ) ; } if ( ( value != null ) && ( property != null ) ) { String message = "Either value or property " + "can be specified, but a replacefilter " + "element cannot have both." ; throw new BuildException ( message ) ; } if ( ( property != null ) ) { if ( propertyFile == null ) { String message = "The replacefilter's property attribute " + "can only be used with the replacetask's " + "propertyFile attribute." ; throw new BuildException ( message ) ; } if ( properties == null || properties . getProperty ( property ) == null ) { String message = "property \"" + property + "\" was not found in " + propertyFile . getPath ( ) ; throw new BuildException ( message ) ; } } } public String getReplaceValue ( ) { if ( property != null ) { return ( String ) properties . getProperty ( property ) ; } else if ( value != null ) { return value ; } else if ( Replace . this . value != null ) { return Replace . this . value . getText ( ) ; } else { return new String ( "" ) ; } } public void setToken ( String token ) { this . token = token ; } public String getToken ( ) { return token ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setProperty ( String property ) { this . property = property ; } public String getProperty ( ) { return property ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( propertyFile != null ) { properties = getProperties ( propertyFile ) ; } validateReplacefilters ( ) ; fileCount = 0 ; replaceCount = 0 ; if ( src != null ) { processFile ( src ) ; } if ( dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] srcs = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < srcs . length ; i ++ ) { File file = new File ( dir , srcs [ i ] ) ; processFile ( file ) ; } } if ( summary ) { log ( "Replaced " + replaceCount + " occurrences in " + fileCount + " files." , Project . MSG_INFO ) ; } } public void validateAttributes ( ) throws BuildException { if ( src == null && dir == null ) { String message = "Either the file or the dir attribute " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( propertyFile != null && ! propertyFile . exists ( ) ) { String message = "Property file " + propertyFile . getPath ( ) + " does not exist." ; throw new BuildException ( message , location ) ; } if ( token == null && replacefilters . size ( ) == 0 ) { String message = "Either token or a nested replacefilter " + "must be specified" ; throw new BuildException ( message , location ) ; } if ( token != null && "" . equals ( token . getText ( ) ) ) { String message = "The token attribute must not be an empty string." ; throw new BuildException ( message , location ) ; } } public void validateReplacefilters ( ) throws BuildException { for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter element = ( Replacefilter ) replacefilters . elementAt ( i ) ; element . validate ( ) ; } } public Properties getProperties ( File propertyFile ) throws BuildException { Properties properties = new Properties ( ) ; try { properties . load ( new FileInputStream ( propertyFile ) ) ; } catch ( FileNotFoundException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") not found." ; throw new BuildException ( message ) ; } catch ( IOException e ) { String message = "Property file (" + propertyFile . getPath ( ) + ") cannot be loaded." ; throw new BuildException ( message ) ; } return properties ; } private void processFile ( File src ) throws BuildException { if ( ! src . exists ( ) ) { throw new BuildException ( "Replace: source file " + src . getPath ( ) + " doesn't exist" , location ) ; } File temp = new File ( src . getPath ( ) + ".temp" ) ; if ( temp . exists ( ) ) { throw new BuildException ( "Replace: temporary file " + temp . getPath ( ) + " already exists" , location ) ; } try { BufferedReader br = new BufferedReader ( new FileReader ( src ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( temp ) ) ; int fileLengthInBytes = ( int ) ( src . length ( ) ) ; StringBuffer tmpBuf = new StringBuffer ( fileLengthInBytes ) ; int readChar = 0 ; int totread = 0 ; while ( true ) { readChar = br . read ( ) ; if ( readChar < 0 ) { break ; } tmpBuf . append ( ( char ) readChar ) ; totread ++ ; } String buf = tmpBuf . toString ( ) ; String newString = new String ( buf ) ; if ( token != null ) { String linesep = System . getProperty ( "line.separator" ) ; String val = stringReplace ( value . getText ( ) , "\n" , linesep ) ; String tok = stringReplace ( token . getText ( ) , "\n" , linesep ) ; log ( "Replacing in " + src . getPath ( ) + ": " + token . getText ( ) + " --> " + value . getText ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , tok , val ) ; } if ( replacefilters . size ( ) > 0 ) { newString = processReplacefilters ( newString , src . getPath ( ) ) ; } boolean changes = ! newString . equals ( buf ) ; if ( changes ) { bw . write ( newString , 0 , newString . length ( ) ) ; bw . flush ( ) ; } bw . close ( ) ; br . close ( ) ; if ( changes ) { ++ fileCount ; src . delete ( ) ; temp . renameTo ( src ) ; } else { temp . delete ( ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new BuildException ( ioe , location ) ; } } private String processReplacefilters ( String buffer , String filename ) { String newString = new String ( buffer ) ; for ( int i = 0 ; i < replacefilters . size ( ) ; i ++ ) { Replacefilter filter = ( Replacefilter ) replacefilters . elementAt ( i ) ; log ( "Replacing in " + filename + ": " + filter . getToken ( ) + " --> " + filter . getReplaceValue ( ) , Project . MSG_VERBOSE ) ; newString = stringReplace ( newString , filter . getToken ( ) , filter . getReplaceValue ( ) ) ; } return newString ; } public void setFile ( File file ) { this . src = file ; } public void setSummary ( boolean summary ) { this . summary = summary ; } public void setDir ( File dir ) { this . dir = dir ; } public void setToken ( String token ) { createReplaceToken ( ) . addText ( token ) ; } public void setValue ( String value ) { createReplaceValue ( ) . addText ( value ) ; } public NestedString createReplaceToken ( ) { if ( token == null ) { token = new NestedString ( ) ; } return token ; } public NestedString createReplaceValue ( ) { return value ; } public void setPropertyFile ( File filename ) { propertyFile = filename ; } public Replacefilter createReplacefilter ( ) { Replacefilter filter = new Replacefilter ( ) ; replacefilters . addElement ( filter ) ; return filter ; } private String stringReplace ( String str , String str1 , String str2 ) { StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = str . indexOf ( str1 ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( str . substring ( start , found ) ) ; } if ( str2 != null ) { ret . append ( str2 ) ; } start = found + str1 . length ( ) ; found = str . indexOf ( str1 , start ) ; ++ replaceCount ; } if ( str . length ( ) > start ) { ret . append ( str . substring ( start , str . length ( ) ) ) ; } return ret . toString ( ) ; } } 	1	['20', '4', '0', '7', '71', '102', '2', '7', '14', '0.821052632', '677', '1', '2', '0.804123711', '0.3', '2', '2', '32.35', '5', '1.25', '1']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	1	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class KaffeRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; try { Class c = Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Constructor cons = c . getConstructor ( new Class [ ] { String [ ] . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { cmd . getArguments ( ) } ) ; Method doRmic = c . getMethod ( "run" , null ) ; String str [ ] = cmd . getArguments ( ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , null ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use Kaffe rmic, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting Kaffe rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } } 	1	['3', '2', '0', '7', '19', '3', '1', '6', '2', '1', '96', '0', '0', '0.866666667', '0.5', '0', '0', '30.66666667', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setDir ( new File ( src . getParent ( ) ) ) ; fs . createInclude ( ) . setName ( src . getName ( ) ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , location ) ; } if ( defaultSetDefined && defaultSet . getDir ( project ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( project ) == null ) { super . execute ( ) ; } else if ( isValidOs ( ) ) { createArg ( ) . setValue ( defaultSet . getDir ( project ) . getPath ( ) ) ; Execute execute = prepareExec ( ) ; try { execute . setCommandline ( cmdl . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( taskType + " doesn\'t support the executable attribute" , location ) ; } public void setCommand ( String e ) { throw new BuildException ( taskType + " doesn\'t support the command attribute" , location ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( taskType + " doesn\'t support the skipemptyfileset attribute" , location ) ; } protected boolean isValidOs ( ) { return System . getProperty ( "path.separator" ) . equals ( ":" ) && ( ! System . getProperty ( "os.name" ) . startsWith ( "Mac" ) || System . getProperty ( "os.name" ) . endsWith ( "X" ) ) && super . isValidOs ( ) ; } } 	1	['16', '5', '0', '13', '55', '26', '0', '13', '14', '0.577777778', '275', '1', '1', '0.87704918', '0.390625', '3', '6', '16', '5', '1.375', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; public class ExecTask extends Task { private static String lSep = System . getProperty ( "line.separator" ) ; private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Integer timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; private ByteArrayOutputStream baos = null ; private String outputprop ; private boolean vmLauncher = true ; public void setTimeout ( Integer value ) { timeout = value ; } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setOutputproperty ( String outputprop ) { this . outputprop = outputprop ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; if ( isValidOs ( ) ) { runExec ( prepareExec ( ) ) ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) dir = project . getBaseDir ( ) ; log ( cmdl . toString ( ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int err = - 1 ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( taskType + " returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } if ( baos != null ) { BufferedReader in = new BufferedReader ( new StringReader ( baos . toString ( ) ) ) ; String line = null ; StringBuffer val = new StringBuffer ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( val . length ( ) != 0 ) { val . append ( lSep ) ; } val . append ( line ) ; } project . setProperty ( outputprop , val . toString ( ) ) ; } } protected void runExec ( Execute exe ) throws BuildException { exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else if ( outputprop != null ) { baos = new ByteArrayOutputStream ( ) ; log ( "Output redirected to ByteArray" , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( baos ) ; } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) return null ; return new ExecuteWatchdog ( timeout . intValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) fos . close ( ) ; if ( baos != null ) baos . close ( ) ; } catch ( IOException io ) { } } } 	1	['23', '3', '1', '18', '69', '163', '4', '14', '14', '0.846153846', '514', '1', '2', '0.637931034', '0.198863636', '0', '0', '20.7826087', '3', '1.0435', '3']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; private boolean inheritAll = true ; Vector properties = new Vector ( ) ; Project p1 ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void init ( ) { p1 = new Project ( ) ; p1 . setJavaVersionProperty ( ) ; p1 . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; for ( int i = 0 ; i < properties . size ( ) ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) p1 . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { Vector listeners = project . getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { p1 . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { try { PrintStream out = new PrintStream ( new FileOutputStream ( output ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; p1 . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; Class taskClass = ( Class ) taskdefs . get ( taskName ) ; p1 . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; p1 . addDataTypeDefinition ( typeName , typeClass ) ; } Hashtable prop1 ; if ( inheritAll == true ) { prop1 = project . getProperties ( ) ; } else { prop1 = project . getUserProperties ( ) ; project . setSystemProperties ( ) ; } e = prop1 . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) prop1 . get ( arg ) ; if ( inheritAll == true ) p1 . setProperty ( arg , value ) ; else p1 . setUserProperty ( arg , value ) ; } } protected void handleOutput ( String line ) { if ( p1 != null ) { p1 . demuxOutput ( line , false ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( p1 != null ) { p1 . demuxOutput ( line , true ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) throws BuildException { try { if ( p1 == null ) { reinit ( ) ; } if ( dir == null ) dir = project . getBaseDir ( ) ; initializeProject ( ) ; p1 . setBaseDir ( dir ) ; p1 . setUserProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . execute ( ) ; } if ( antFile == null ) antFile = "build.xml" ; File file = new File ( antFile ) ; if ( ! file . isAbsolute ( ) ) { antFile = ( new File ( dir , antFile ) ) . getAbsolutePath ( ) ; file = ( new File ( antFile ) ) ; if ( ! file . isFile ( ) ) { throw new BuildException ( "Build file " + file + " not found." ) ; } } p1 . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( p1 , new File ( antFile ) ) ; if ( target == null ) { target = p1 . getDefaultTarget ( ) ; } if ( p1 . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && p1 . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && getOwningTarget ( ) != null && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent target" ) ; } p1 . executeTarget ( target ) ; } finally { p1 = null ; } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( p1 == null ) { reinit ( ) ; } Property p = ( Property ) p1 . createTask ( "property" ) ; p . setUserProperty ( true ) ; properties . addElement ( p ) ; return p ; } } 	1	['13', '3', '0', '10', '78', '8', '1', '9', '9', '0.75', '502', '0.714285714', '1', '0.755102041', '0.384615385', '2', '3', '37.07692308', '8', '2', '3']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	1	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import org . apache . tools . ant . Task ; import java . io . * ; import java . util . * ; public class Recorder extends Task { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = new Boolean ( append ) ; } public void setLoglevel ( VerbosityLevelChoices level ) { String lev = level . getValue ( ) ; if ( lev . equalsIgnoreCase ( "error" ) ) { loglevel = Project . MSG_ERR ; } else if ( lev . equalsIgnoreCase ( "warn" ) ) { loglevel = Project . MSG_WARN ; } else if ( lev . equalsIgnoreCase ( "info" ) ) { loglevel = Project . MSG_INFO ; } else if ( lev . equalsIgnoreCase ( "verbose" ) ) { loglevel = Project . MSG_VERBOSE ; } else if ( lev . equalsIgnoreCase ( "debug" ) ) { loglevel = Project . MSG_DEBUG ; } } public void execute ( ) throws BuildException { if ( filename == null ) throw new BuildException ( "No filename specified" ) ; getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setRecordState ( start ) ; } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] values = { "start" , "stop" } ; public String [ ] getValues ( ) { return values ; } } public static class VerbosityLevelChoices extends EnumeratedAttribute { private static final String [ ] values = { "error" , "warn" , "info" , "verbose" , "debug" } ; public String [ ] getValues ( ) { return values ; } } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { try { entry = new RecorderEntry ( name ) ; PrintStream out = null ; if ( append == null ) { out = new PrintStream ( new FileOutputStream ( name ) ) ; } else { out = new PrintStream ( new FileOutputStream ( name , append . booleanValue ( ) ) ) ; } entry . setErrorPrintStream ( out ) ; entry . setOutputPrintStream ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems creating a recorder entry" , ioe ) ; } proj . addBuildListener ( entry ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } } 	1	['8', '3', '0', '9', '32', '6', '0', '9', '6', '0.685714286', '201', '1', '0', '0.860465116', '0.30952381', '1', '1', '23.5', '6', '1.5', '1']
package org . apache . tools . ant . listener ; import org . apache . tools . ant . * ; import org . apache . log4j . Category ; import org . apache . log4j . helpers . NullEnumeration ; public class Log4jListener implements BuildListener { static final String LOG4J_CONFIG_PROPERTY = "log4j.configuration" ; private boolean initialized = false ; public Log4jListener ( ) { initialized = false ; Category cat = Category . getInstance ( "org.apache.tools.ant" ) ; Category rootCat = Category . getRoot ( ) ; if ( ! ( rootCat . getAllAppenders ( ) instanceof NullEnumeration ) ) { initialized = true ; } else { cat . error ( "No log4j.properties in build area" ) ; } } public void buildStarted ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Project . class . getName ( ) ) ; cat . info ( "Build started." ) ; } } public void buildFinished ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Project . class . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Build finished." ) ; } else { cat . error ( "Build finished with error." , event . getException ( ) ) ; } } } public void targetStarted ( BuildEvent event ) { if ( initialized ) { Category cat = Category . getInstance ( Target . class . getName ( ) ) ; cat . info ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" started." ) ; } } public void targetFinished ( BuildEvent event ) { if ( initialized ) { String targetName = event . getTarget ( ) . getName ( ) ; Category cat = Category . getInstance ( Target . class . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" finished." ) ; } else { cat . error ( "Target \"" + event . getTarget ( ) . getName ( ) + "\" finished with error." , event . getException ( ) ) ; } } } public void taskStarted ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Category cat = Category . getInstance ( task . getClass ( ) . getName ( ) ) ; cat . info ( "Task \"" + task . getTaskName ( ) + "\" started." ) ; } } public void taskFinished ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Category cat = Category . getInstance ( task . getClass ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { cat . info ( "Task \"" + task . getTaskName ( ) + "\" finished." ) ; } else { cat . error ( "Task \"" + task . getTaskName ( ) + "\" finished with error." , event . getException ( ) ) ; } } } public void messageLogged ( BuildEvent event ) { if ( initialized ) { Object categoryObject = event . getTask ( ) ; if ( categoryObject == null ) { categoryObject = event . getTarget ( ) ; if ( categoryObject == null ) { categoryObject = event . getProject ( ) ; } } Category cat = Category . getInstance ( categoryObject . getClass ( ) . getName ( ) ) ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : cat . error ( event . getMessage ( ) ) ; break ; case Project . MSG_WARN : cat . warn ( event . getMessage ( ) ) ; break ; case Project . MSG_INFO : cat . info ( event . getMessage ( ) ) ; break ; case Project . MSG_VERBOSE : cat . debug ( event . getMessage ( ) ) ; break ; case Project . MSG_DEBUG : cat . debug ( event . getMessage ( ) ) ; break ; default : cat . error ( event . getMessage ( ) ) ; break ; } } } } 	1	['9', '1', '0', '7', '34', '0', '0', '7', '8', '0.75', '298', '0.25', '0', '0', '0.592592593', '0', '0', '31.66666667', '5', '2.7778', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import java . io . * ; public class Cvs extends Task { private Commandline cmd = new Commandline ( ) ; private String cvsRoot ; private String pack ; private String command = "checkout" ; private boolean quiet = false ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private File output ; private File error ; private boolean failOnError = false ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( "cvs" ) ; if ( cvsRoot != null ) { toExecute . createArgument ( ) . setValue ( "-d" ) ; toExecute . createArgument ( ) . setValue ( cvsRoot ) ; } if ( noexec ) { toExecute . createArgument ( ) . setValue ( "-n" ) ; } if ( quiet ) { toExecute . createArgument ( ) . setValue ( "-q" ) ; } toExecute . createArgument ( ) . setLine ( command ) ; toExecute . addArguments ( cmd . getCommandline ( ) ) ; if ( pack != null ) { toExecute . createArgument ( ) . setLine ( pack ) ; } Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; } ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { if ( output != null ) { try { outputstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } if ( error != null ) { try { errorstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) dest = project . getBaseDir ( ) ; exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { int retCode = exe . execute ( ) ; if ( failOnError && retCode != 0 ) throw new BuildException ( "cvs exited with error code " + retCode ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } finally { if ( output != null ) { try { outputstream . close ( ) ; } catch ( IOException e ) { } } if ( error != null ) { try { errorstream . close ( ) ; } catch ( IOException e ) { } } } } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) root = null ; } this . cvsRoot = root ; } public void setPort ( int port ) { this . port = port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public void setPackage ( String p ) { this . pack = p ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-r" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-D" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } } 	1	['15', '3', '0', '15', '54', '59', '0', '15', '15', '0.880952381', '398', '1', '1', '0.725490196', '0.373333333', '0', '0', '24.73333333', '3', '1.3333', '1']
package org . apache . tools . ant . types ; import java . util . * ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; private String maxMemory = null ; private boolean executeJar = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { String props [ ] = super . getVariables ( ) ; if ( props == null ) return null ; for ( int i = 0 ; i < props . length ; i ++ ) { props [ i ] = "-D" + props [ i ] ; } return props ; } public int size ( ) { return variables . size ( ) ; } public void setSystem ( ) throws BuildException { try { Properties p = new Properties ( sys = System . getProperties ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } } public CommandlineJava ( ) { setVm ( getJavaExecutableName ( ) ) ; setVmversion ( Project . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { String [ ] result = new String [ size ( ) ] ; int pos = 0 ; String [ ] vmArgs = getActualVMCommand ( ) . getCommandline ( ) ; result [ pos ++ ] = vmArgs [ 0 ] ; if ( executeJar ) { result [ pos ++ ] = "-jar" ; } System . arraycopy ( vmArgs , 1 , result , pos , vmArgs . length - 1 ) ; pos += vmArgs . length - 1 ; if ( sysProperties . size ( ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { result [ pos ++ ] = "-classpath" ; result [ pos ++ ] = fullClasspath . toString ( ) ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } private Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { size += 2 ; } if ( executeJar ) { size ++ ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { CommandlineJava c = new CommandlineJava ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; c . maxMemory = maxMemory ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } c . vmVersion = vmVersion ; c . executeJar = executeJar ; return c ; } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } private String getJavaExecutableName ( ) { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean dosBased = os . indexOf ( "windows" ) >= 0 || os . indexOf ( "os/2" ) >= 0 ; String extension = dosBased ? ".exe" : "" ; java . io . File jExecutable = new java . io . File ( System . getProperty ( "java.home" ) + "/../bin/java" + extension ) ; if ( jExecutable . exists ( ) ) { return jExecutable . getAbsolutePath ( ) ; } else { return "java" ; } } } 	1	['26', '1', '0', '9', '62', '119', '1', '8', '24', '0.68', '437', '1', '4', '0', '0.317307692', '0', '0', '15.53846154', '6', '1.6923', '1']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class WLRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; try { Class c = Class . forName ( "weblogic.rmic" ) ; Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use WebLogic rmic, as it is not available" + " A common solution is to set the environment variable" + " CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting WebLogic rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } public String getStubClassSuffix ( ) { return "_WLStub" ; } public String getSkelClassSuffix ( ) { return "_WLSkel" ; } } 	1	['5', '2', '0', '7', '18', '10', '1', '6', '4', '1', '95', '0', '0', '0.764705882', '0.5', '0', '0', '17.8', '1', '0.8', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . * ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; private Vector filterSets = new Vector ( ) ; private FileUtils fileUtils ; public Copy ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { preserveLastModified = Project . toBoolean ( preserve ) ; } protected Vector getFilterSets ( ) { return filterSets ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to copy." ; log ( message ) ; throw new BuildException ( message ) ; } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , destDir , srcFiles , srcDirs ) ; } doFileOperations ( ) ; if ( destFile != null ) { destDir = null ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of destfile and destdir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of destfile or destdir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Cannot concatenate multple files into a single file." ) ; } if ( destFile != null ) { destDir = new File ( destFile . getParent ( ) ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , forceOverwrite , preserveLastModified ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Copied " + count + " empty director" + ( count == 1 ? "y" : "ies" ) + " to " + destDir . getAbsolutePath ( ) ) ; } } } } 	1	['20', '3', '1', '16', '74', '92', '1', '15', '14', '0.824561404', '720', '1', '2', '0.660714286', '0.225', '2', '2', '34.25', '13', '1.95', '2']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class RmicAdapterFactory { private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { if ( rmicType == null ) { try { Class . forName ( "sun.rmi.rmic.Main" ) ; rmicType = "sun" ; } catch ( ClassNotFoundException cnfe ) { try { Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Class . forName ( "kaffe.tools.compiler.Compiler" ) ; rmicType = "kaffe" ; } catch ( ClassNotFoundException cnfk ) { throw new BuildException ( "Couldn\'t guess rmic implementation" ) ; } } } if ( rmicType . equalsIgnoreCase ( "sun" ) ) { return new SunRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "kaffe" ) ) { return new KaffeRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "weblogic" ) ) { return new WLRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( RmicAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a rmic adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1	['3', '1', '0', '7', '15', '3', '1', '6', '1', '2', '112', '0', '0', '0', '0.444444444', '0', '0', '36.33333333', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase { private Vector conditions = new Vector ( ) ; private Project project ; public void setProject ( Project p ) { this . project = p ; } protected Project getProject ( ) { return project ; } protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return new ConditionEnumeration ( ) ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } private class ConditionEnumeration implements Enumeration { private int currentElement = 0 ; public boolean hasMoreElements ( ) { return countConditions ( ) > currentElement ; } public Object nextElement ( ) throws NoSuchElementException { Object o = null ; try { o = conditions . elementAt ( currentElement ++ ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } if ( o instanceof Task ) { ( ( Task ) o ) . setProject ( getProject ( ) ) ; } else if ( o instanceof ConditionBase ) { ( ( ConditionBase ) o ) . setProject ( getProject ( ) ) ; } return o ; } } } 	1	['13', '1', '4', '11', '18', '0', '5', '10', '9', '0.583333333', '78', '1', '1', '0', '0.161538462', '0', '0', '4.846153846', '1', '0.9231', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean initialized = false ; private boolean inheritAll = true ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void init ( ) { callee = ( Ant ) project . createTask ( "ant" ) ; callee . setOwningTarget ( target ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( location ) ; callee . init ( ) ; initialized = true ; } public void execute ( ) { if ( ! initialized ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , location ) ; } callee . setDir ( project . getBaseDir ( ) ) ; callee . setAntfile ( project . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . execute ( ) ; } public Property createParam ( ) { return callee . createProperty ( ) ; } public void setTarget ( String target ) { subTarget = target ; } protected void handleOutput ( String line ) { if ( callee != null ) { callee . handleOutput ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( callee != null ) { callee . handleErrorOutput ( line ) ; } else { super . handleErrorOutput ( line ) ; } } } 	1	['8', '3', '0', '8', '28', '0', '0', '8', '6', '0.678571429', '128', '1', '1', '0.840909091', '0.5', '2', '4', '14.5', '3', '1.375', '1']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { public void setRmic ( Rmic attributes ) ; public boolean execute ( ) throws BuildException ; public FileNameMapper getMapper ( ) ; public Path getClasspath ( ) ; } 	1	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . Enumeration ; import java . util . Date ; import java . util . Vector ; public class UpToDate extends MatchingTask implements Condition { private String _property ; private String _value ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setValue ( String value ) { _value = value ; } private String getValue ( ) { return ( _value != null ) ? _value : "true" ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 ) { throw new BuildException ( "At least one <srcfiles> element must be set" ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested mapper element must be set" ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) return false ; Enumeration enum = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; upToDate = upToDate && scanDir ( fs . getDir ( project ) , ds . getIncludedFiles ( ) ) ; } return upToDate ; } public void execute ( ) throws BuildException { boolean upToDate = eval ( ) ; if ( upToDate ) { this . project . setProperty ( _property , this . getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up to date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files have been up to date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String files [ ] ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; File dir = srcDir ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; dir = null ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } } 	1	['10', '4', '0', '14', '35', '11', '1', '13', '8', '0.711111111', '216', '1', '1', '0.896551724', '0.32', '1', '1', '20.1', '10', '2.1', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import java . io . File ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; private Path src ; private File destDir ; private Path compileClasspath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; protected boolean failOnError = true ; protected File [ ] compileList = new File [ 0 ] ; public Path createSrc ( ) { if ( src == null ) { src = new Path ( project ) ; } return src . createPath ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean fork ) { this . fork = fork ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , location ) ; } resetFileLists ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = ( File ) project . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , location ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } String compiler = project . getProperty ( "build.compiler" ) ; if ( fork ) { if ( compiler != null ) { if ( isJdkCompiler ( compiler ) ) { log ( "Since fork is true, ignoring build.compiler setting." , Project . MSG_WARN ) ; compiler = "extJavac" ; } else { log ( "Since build.compiler setting isn't classic or modern, ignoring fork setting." , Project . MSG_WARN ) ; } } else { compiler = "extJavac" ; } } if ( compiler == null ) { if ( Project . getJavaVersion ( ) != Project . JAVA_1_1 && Project . getJavaVersion ( ) != Project . JAVA_1_2 ) { compiler = "modern" ; } else { compiler = "classic" ; } } if ( compileList . length > 0 ) { CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compiler , this ) ; log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , location ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String files [ ] ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compiler ) { return "modern" . equals ( compiler ) || "classic" . equals ( compiler ) || "javac1.1" . equals ( compiler ) || "javac1.2" . equals ( compiler ) || "javac1.3" . equals ( compiler ) || "javac1.4" . equals ( compiler ) ; } } 	1	['50', '4', '1', '24', '82', '1091', '11', '14', '47', '0.959183673', '646', '1', '4', '0.614173228', '0.214285714', '3', '3', '11.5', '7', '1.3', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Move extends Copy { public Move ( ) { super ( ) ; forceOverwrite = true ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; continue ; } boolean moved = false ; File f = new File ( fromFile ) ; File d = new File ( toFile ) ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( f , d , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } if ( ! moved ) { try { log ( "Moving " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( f , d , executionFilters , forceOverwrite ) ; f = new File ( fromFile ) ; if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Moved " + count + " empty directories to " + destDir . getAbsolutePath ( ) ) ; } } if ( filesets . size ( ) > 0 ) { Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; File dir = fs . getDir ( project ) ; if ( okToDelete ( dir ) ) { deleteDir ( dir ) ; } } } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return false ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) return false ; } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = true ; if ( ! filtering ) { String parentPath = destFile . getParent ( ) ; if ( parentPath != null ) { File parent = new File ( parentPath ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } } if ( destFile . exists ( ) ) { if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + destFile ) ; } } renamed = sourceFile . renameTo ( destFile ) ; } else { renamed = false ; } return renamed ; } } 	1	['5', '4', '0', '10', '42', '10', '0', '10', '1', '2', '481', '0', '0', '0.952380952', '0.6', '4', '6', '95.2', '15', '5.2', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class CompilerAdapterFactory { private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { return new Javac12 ( ) ; } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) ) { try { Class . forName ( "com.sun.tools.javac.Main" ) ; } catch ( ClassNotFoundException cnfe ) { task . log ( "Modern compiler is not available - using " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } return new Javac13 ( ) ; } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	1	['3', '1', '0', '12', '20', '3', '1', '11', '1', '2', '165', '0', '0', '0', '0.444444444', '0', '0', '54', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property ; private String value = "true" ; public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one condition into <condition>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <condition>" ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { getProject ( ) . setProperty ( property , value ) ; } } } 	1	['4', '3', '0', '4', '12', '0', '0', '4', '4', '0.5', '54', '1', '0', '0.914285714', '0.75', '0', '0', '12', '1', '0.75', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class Expand extends MatchingTask { private File dest ; private File source ; private boolean overwrite = true ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; if ( source == null ) { throw new BuildException ( "Source attribute must be specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( source . isDirectory ( ) ) { DirectoryScanner ds = super . getDirectoryScanner ( source ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( source , files [ i ] ) ; expandFile ( touch , file , dest ) ; } } else { expandFile ( touch , source , dest ) ; } } private void expandFile ( Touch touch , File srcF , File dir ) { ZipInputStream zis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { File f = new File ( dir , project . translatePath ( ze . getName ( ) ) ) ; try { if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= ze . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; continue ; } log ( "expanding " + ze . getName ( ) + " to " + f , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( ze . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = zis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( ze . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } } 	1	['6', '4', '0', '9', '48', '5', '0', '9', '5', '0.666666667', '300', '1', '0', '0.939759036', '0.458333333', '4', '5', '48.5', '10', '2.3333', '1']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . * ; import java . util . * ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref = null ; protected boolean userProperty = false ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setUserProperty ( boolean userProperty ) { this . userProperty = userProperty ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or refid with the name attribute" , location ) ; } } else { if ( file == null && resource == null && env == null ) { throw new BuildException ( "You must specify file, resource or environment when not using the name attribute" , location ) ; } } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) loadFile ( file ) ; if ( resource != null ) loadResource ( resource ) ; if ( env != null ) loadEnvironment ( env ) ; if ( ( name != null ) && ( ref != null ) ) { Object obj = ref . getReferencedObject ( getProject ( ) ) ; if ( obj != null ) { addProperty ( name , obj . toString ( ) ) ; } } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; try { ClassLoader cL = null ; InputStream is = null ; if ( classpath != null ) { cL = new AntClassLoader ( project , classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) prefix += "." ; log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) props . getProperty ( name ) ; String v = ProjectHelper . replaceProperties ( project , value , project . getProperties ( ) ) ; addProperty ( name , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( project . getUserProperty ( n ) == null ) { project . setUserProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { if ( project . getProperty ( n ) == null ) { project . setProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; boolean resolved = false ; while ( ! resolved ) { Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; resolved = true ; if ( propertyRefs . size ( ) != 0 ) { StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( propertyName . equals ( name ) ) { throw new BuildException ( "Property " + name + " was circularly defined." ) ; } fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { fragment = props . getProperty ( propertyName ) ; resolved = false ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; props . put ( name , value ) ; } } } } } 	1	['26', '3', '0', '12', '74', '265', '2', '10', '20', '0.885', '643', '1', '2', '0.596774194', '0.230769231', '0', '0', '23.42307692', '4', '1.4615', '1']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private String family ; public void setFamily ( String f ) { family = f . toLowerCase ( ) ; } public boolean eval ( ) throws BuildException { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; String pathSep = System . getProperty ( "path.separator" ) ; if ( family != null ) { if ( family . equals ( "windows" ) ) { return osName . indexOf ( "windows" ) > - 1 ; } else if ( family . equals ( "dos" ) ) { return pathSep . equals ( ";" ) ; } else if ( family . equals ( "mac" ) ) { return osName . indexOf ( "mac" ) > - 1 ; } else if ( family . equals ( "unix" ) ) { return pathSep . equals ( ":" ) && ( ! osName . startsWith ( "mac" ) || osName . endsWith ( "x" ) ) ; } throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } return false ; } } 	1	['3', '1', '0', '3', '14', '1', '1', '2', '3', '0.5', '97', '1', '0', '0', '0.666666667', '0', '0', '31', '1', '0.6667', '1']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . mail . MailMessage ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class SendEmail extends Task { private String from ; private String mailhost = "localhost" ; private String message ; private String toList ; private String subject ; private Vector files = new Vector ( ) ; public SendEmail ( ) { } public void setToList ( String toList ) { this . toList = toList ; } public void setFrom ( String from ) { this . from = from ; } public void setMailhost ( String mailhost ) { this . mailhost = mailhost ; } public void setMessage ( String message ) { this . message = message ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( project . resolveFile ( t . nextToken ( ) ) ) ; } } public void execute ( ) { try { MailMessage mailMessage = new MailMessage ( mailhost ) ; if ( from != null ) { mailMessage . from ( from ) ; } else { throw new BuildException ( "Attribute \"from\" is required." ) ; } if ( toList != null ) { StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } } else { throw new BuildException ( "Attribute \"toList\" is required." ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } if ( ! files . isEmpty ( ) ) { PrintStream out = mailMessage . getPrintStream ( ) ; for ( Enumeration e = files . elements ( ) ; e . hasMoreElements ( ) ; ) { File file = ( File ) e . nextElement ( ) ; if ( file . exists ( ) && file . canRead ( ) ) { int bufsize = 1024 ; int length ; byte [ ] buf = new byte [ bufsize ] ; BufferedInputStream in = null ; try { in = new BufferedInputStream ( new FileInputStream ( file ) , bufsize ) ; while ( ( length = in . read ( buf , 0 , bufsize ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { if ( in != null ) { in . close ( ) ; } } } else { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not readable." ) ; } } } else if ( message != null ) { PrintStream out = mailMessage . getPrintStream ( ) ; out . print ( message ) ; } else { throw new BuildException ( "Attribute \"file\" or \"message\" is required." ) ; } log ( "Sending email" ) ; mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail: " + ioe . getMessage ( ) ) ; } } } 	1	['8', '3', '0', '5', '41', '10', '0', '5', '8', '0.80952381', '236', '1', '0', '0.840909091', '0.875', '1', '1', '27.75', '14', '2.625', '1']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Random ; public abstract class DefaultCompilerAdapter implements CompilerAdapter { protected Path src ; protected File destDir ; protected String encoding ; protected boolean debug = false ; protected boolean optimize = false ; protected boolean deprecation = false ; protected boolean depend = false ; protected boolean verbose = false ; protected String target ; protected Path bootclasspath ; protected Path extdirs ; protected Path compileClasspath ; protected Project project ; protected Location location ; protected boolean includeAntRuntime ; protected boolean includeJavaRuntime ; protected String memoryInitialSize ; protected String memoryMaximumSize ; protected File [ ] compileList ; protected static String lSep = System . getProperty ( "line.separator" ) ; protected Javac attributes ; public void setJavac ( Javac attributes ) { this . attributes = attributes ; src = attributes . getSrcdir ( ) ; destDir = attributes . getDestdir ( ) ; encoding = attributes . getEncoding ( ) ; debug = attributes . getDebug ( ) ; optimize = attributes . getOptimize ( ) ; deprecation = attributes . getDeprecation ( ) ; depend = attributes . getDepend ( ) ; verbose = attributes . getVerbose ( ) ; target = attributes . getTarget ( ) ; bootclasspath = attributes . getBootclasspath ( ) ; extdirs = attributes . getExtdirs ( ) ; compileList = attributes . getFileList ( ) ; compileClasspath = attributes . getClasspath ( ) ; project = attributes . getProject ( ) ; location = attributes . getLocation ( ) ; includeAntRuntime = attributes . getIncludeantruntime ( ) ; includeJavaRuntime = attributes . getIncludejavaruntime ( ) ; memoryInitialSize = attributes . getMemoryInitialSize ( ) ; memoryMaximumSize = attributes . getMemoryMaximumSize ( ) ; } public Javac getJavac ( ) { return attributes ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( project ) ; if ( destDir != null ) { classpath . setLocation ( destDir ) ; } if ( compileClasspath == null ) { if ( includeAntRuntime ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( includeAntRuntime ) { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( compileClasspath . concatSystemClasspath ( "ignore" ) ) ; } } if ( includeJavaRuntime ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; classpath . addFileset ( msZipFiles ) ; } else if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } return classpath ; } protected Commandline setupJavacCommandlineSwitches ( Commandline cmd ) { Path classpath = getCompileClasspath ( ) ; boolean usingJava1_1 = Project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ; String memoryParameterPrefix = usingJava1_1 ? "-J-" : "-J-X" ; if ( memoryInitialSize != null ) { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "ms" + memoryInitialSize ) ; } if ( memoryMaximumSize != null ) { cmd . createArgument ( ) . setValue ( memoryParameterPrefix + "mx" + memoryMaximumSize ) ; } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { addExtdirsToClasspath ( cp ) ; } cp . append ( classpath ) ; cp . append ( src ) ; cmd . createArgument ( ) . setPath ( cp ) ; } else { cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( src ) ; if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } if ( bootclasspath != null ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bootclasspath ) ; } if ( extdirs != null ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } } if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } else if ( Project . getJavaVersion ( ) != Project . JAVA_1_0 && Project . getJavaVersion ( ) != Project . JAVA_1_1 ) { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( depend ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } else if ( Project . getJavaVersion ( ) . startsWith ( "1.2" ) ) { cmd . createArgument ( ) . setValue ( "-Xdepend" ) ; } else { attributes . log ( "depend attribute is not supported by the modern compiler" , Project . MSG_WARN ) ; } } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } return cmd ; } protected Commandline setupJavacCommand ( ) { Commandline cmd = new Commandline ( ) ; setupJavacCommandlineSwitches ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { attributes . log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . length != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; for ( int i = 0 ; i < compileList . length ; i ++ ) { String arg = compileList [ i ] . getAbsolutePath ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg + lSep ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected int executeExternalCompile ( String [ ] args , int firstFileName ) { String [ ] commandArray = null ; File tmpFile = null ; try { if ( Commandline . toString ( args ) . length ( ) > 4096 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = firstFileName ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ firstFileName + 1 ] ; System . arraycopy ( args , 0 , commandArray , 0 , firstFileName ) ; commandArray [ firstFileName ] = "@" + tmpFile . getAbsolutePath ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = args ; } try { Execute exe = new Execute ( new LogStreamHandler ( attributes , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; return exe . getExitValue ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running " + args [ 0 ] + " compiler" , e , location ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } protected void addExtdirsToClasspath ( Path classpath ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( project , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( ! dirs [ i ] . endsWith ( File . separator ) ) { dirs [ i ] += File . separator ; } File dir = project . resolveFile ( dirs [ i ] ) ; FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; classpath . addFileset ( fs ) ; } } } 	1	['11', '1', '8', '22', '86', '15', '8', '14', '4', '0.728571429', '887', '1', '7', '0', '0.266666667', '0', '0', '77.72727273', '22', '4.6364', '1']
