package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '12', '6', '2', '1', '4', '2', '99', '0', '0', '0.953488372', '0.357142857', '1', '3', '23.75', '3', '1', '0']
package org . apache . log4j . net ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; import org . apache . log4j . net . SyslogTracerPrintWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; public static final String SYSLOG_HOST_OPTION = "SyslogHost" ; public static final String FACILITY_OPTION = "Facility" ; public static final String FACILITY_PRINTING_OPTION = "FacilityPrinting" ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogTracerPrintWriter stp ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( this . syslogFacility ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( syslogFacility ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } public void close ( ) { closed = true ; sqw = null ; stp = null ; } private void initSyslogFacilityStr ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : facilityStr = "kern:" ; break ; case LOG_USER : facilityStr = "user:" ; break ; case LOG_MAIL : facilityStr = "mail:" ; break ; case LOG_DAEMON : facilityStr = "daemon:" ; break ; case LOG_AUTH : facilityStr = "auth:" ; ; break ; case LOG_SYSLOG : facilityStr = "syslog:" ; break ; case LOG_LPR : facilityStr = "lpr:" ; break ; case LOG_NEWS : facilityStr = "news:" ; break ; case LOG_UUCP : facilityStr = "uucp:" ; break ; case LOG_CRON : facilityStr = "cron:" ; break ; case LOG_AUTHPRIV : facilityStr = "authpriv:" ; break ; case LOG_FTP : facilityStr = "ftp:" ; break ; case LOG_LOCAL0 : facilityStr = "local0:" ; break ; case LOG_LOCAL1 : facilityStr = "local1:" ; break ; case LOG_LOCAL2 : facilityStr = "local2:" ; break ; case LOG_LOCAL3 : facilityStr = "local3:" ; break ; case LOG_LOCAL4 : facilityStr = "local4:" ; break ; case LOG_LOCAL5 : facilityStr = "local5:" ; break ; case LOG_LOCAL6 : facilityStr = "local6:" ; break ; case LOG_LOCAL7 : facilityStr = "local7:" ; break ; default : System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . priority ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setPriority ( event . priority . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( stp ) ; else if ( event . throwableInformation != null ) { sqw . write ( event . throwableInformation ) ; } } public void activateOptions ( ) { } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SYSLOG_HOST_OPTION , FACILITY_OPTION , FACILITY_PRINTING_OPTION } ) ; } public boolean requiresLayout ( ) { return true ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; if ( "KERN" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_KERN ; else if ( "USER" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_USER ; else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_MAIL ; else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_DAEMON ; else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTH ; else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_SYSLOG ; else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LPR ; else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_NEWS ; else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_UUCP ; else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_CRON ; else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_AUTHPRIV ; else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_FTP ; else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL0 ; else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL1 ; else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL2 ; else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL3 ; else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL4 ; else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL5 ; else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL6 ; else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) this . syslogFacility = LOG_LOCAL7 ; else { System . err . println ( facilityName + " is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( this . syslogFacility ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( SYSLOG_HOST_OPTION ) ) this . setSyslogHost ( value ) ; else if ( option . equals ( FACILITY_PRINTING_OPTION ) ) facilityPrinting = OptionConverter . toBoolean ( value , facilityPrinting ) ; else if ( option . equals ( FACILITY_OPTION ) ) { this . setFacility ( value ) ; } } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . stp = new SyslogTracerPrintWriter ( sqw ) ; this . syslogHost = syslogHost ; } } 	1	['12', '2', '0', '10', '35', '24', '0', '10', '11', '0.994134897', '531', '0.064516129', '2', '0.666666667', '0.366666667', '2', '4', '40.66666667', '23', '5.0833', '2']
package org . apache . log4j . xml ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . XMLReaderFactory ; import org . xml . sax . SAXException ; import org . apache . xerces . parsers . SAXParser ; import org . apache . trax . Processor ; import org . apache . trax . TemplatesBuilder ; import org . apache . trax . Templates ; import org . apache . trax . Transformer ; import org . apache . trax . Result ; import org . apache . trax . ProcessorException ; import org . apache . trax . ProcessorFactoryException ; import org . apache . trax . TransformException ; import org . apache . serialize . SerializerFactory ; import org . apache . serialize . Serializer ; import org . apache . serialize . OutputFormat ; import org . xml . sax . helpers . AttributesImpl ; import java . io . FileOutputStream ; import java . io . IOException ; public class Transform { public static void main ( String [ ] args ) throws Exception { PropertyConfigurator . disableAll ( ) ; PropertyConfigurator . configure ( "x.lcf" ) ; Processor processor = Processor . newInstance ( "xslt" ) ; XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TemplatesBuilder templatesBuilder = processor . getTemplatesBuilder ( ) ; reader . setContentHandler ( templatesBuilder ) ; if ( templatesBuilder instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , templatesBuilder ) ; } reader . parse ( args [ 0 ] ) ; Templates templates = templatesBuilder . getTemplates ( ) ; Transformer transformer = templates . newTransformer ( ) ; FileOutputStream fos = new FileOutputStream ( args [ 2 ] ) ; Result result = new Result ( fos ) ; Serializer serializer = SerializerFactory . getSerializer ( "xml" ) ; serializer . setOutputStream ( fos ) ; transformer . setContentHandler ( serializer . asContentHandler ( ) ) ; org . xml . sax . ContentHandler chandler = transformer . getInputContentHandler ( ) ; DC dc = new DC ( chandler ) ; reader . setContentHandler ( dc ) ; if ( chandler instanceof LexicalHandler ) { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , chandler ) ; } else { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , null ) ; } reader . parse ( args [ 1 ] ) ; } } class DC implements ContentHandler { static Category cat = Category . getInstance ( "DC" ) ; ContentHandler chandler ; DC ( ContentHandler chandler ) { this . chandler = chandler ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "characters: [" + new String ( ch , start , length ) + "] called" ) ; chandler . characters ( ch , start , length ) ; } public void endDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "endDocument called." ) ; chandler . endDocument ( ) ; } public void endElement ( String namespaceURI , String localName , String qName ) throws org . xml . sax . SAXException { cat . debug ( "endElement(" + namespaceURI + ", " + localName + ", " + qName + ") called" ) ; chandler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { cat . debug ( "endPrefixMapping(" + prefix + ") called" ) ; chandler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { cat . debug ( "ignorableWhitespace called" ) ; chandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { cat . debug ( "processingInstruction called" ) ; chandler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { cat . debug ( "setDocumentLocator called" ) ; chandler . setDocumentLocator ( locator ) ; } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { cat . debug ( "skippedEntity(" + name + ")  called" ) ; chandler . skippedEntity ( name ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { cat . debug ( "startDocument called" ) ; chandler . startDocument ( ) ; } public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws org . xml . sax . SAXException { cat . debug ( "startElement(" + namespaceURI + ", " + localName + ", " + qName + ")called" ) ; if ( "log4j:event" . equals ( qName ) ) { cat . debug ( "-------------" ) ; if ( atts instanceof org . xml . sax . helpers . AttributesImpl ) { AttributesImpl ai = ( AttributesImpl ) atts ; int i = atts . getIndex ( "timestamp" ) ; ai . setValue ( i , "hello" ) ; } String ts = atts . getValue ( "timestamp" ) ; cat . debug ( "New timestamp is " + ts ) ; } chandler . startElement ( namespaceURI , localName , qName , atts ) ; } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { cat . debug ( "startPrefixMapping(" + prefix + ", " + uri + ") called" ) ; chandler . startPrefixMapping ( prefix , uri ) ; } } 	0	['2', '1', '0', '0', '3', '1', '0', '0', '2', '2', '6', '0', '0', '0', '0.5', '0', '0', '2', '1', '0.5', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	1	['6', '1', '0', '3', '9', '9', '1', '2', '6', '0.866666667', '44', '0', '0', '0', '0.458333333', '0', '0', '5.833333333', '2', '1.1667', '1']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	['8', '1', '0', '6', '22', '0', '3', '3', '8', '0.142857143', '176', '1', '0', '0', '0.40625', '0', '0', '20.875', '5', '3.125', '0']
package org . apache . log4j ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . util . Enumeration ; public class BasicConfigurator { public static final String DISABLE_OVERRIDE_KEY = "log4j.disableOverride" ; public static final String INHERITED = "inherited" ; static { String override = null ; String propertyName = DISABLE_OVERRIDE_KEY ; try { override = System . getProperty ( propertyName , override ) ; } catch ( SecurityException e ) { LogLog . debug ( "Could not read system property \"" + propertyName + "\"." , e ) ; } if ( override != null ) { if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding disable. Non-null system property " + DISABLE_OVERRIDE_KEY + "=[" + override + "]." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } protected BasicConfigurator ( ) { } protected void addRenderer ( String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not isntantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; Category . defaultHierarchy . rendererMap . put ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } static public void configure ( ) { Category root = Category . getRoot ( ) ; root . addAppender ( new FileAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) , System . out ) ) ; } static public void configure ( Appender appender ) { Category root = Category . getRoot ( ) ; root . addAppender ( appender ) ; } static public void disable ( Priority p ) { if ( Category . disable != Category . DISABLE_OVERRIDE ) { Category . disable = p . level ; } } static public void disableAll ( ) { disable ( Priority . FATAL ) ; } static public void disableDebug ( ) { disable ( Priority . DEBUG ) ; } static public void disableInfo ( ) { disable ( Priority . INFO ) ; } static public void enableAll ( ) { Category . disable = Category . DISABLE_OFF ; } public static void flagAsShippedCode ( ) { disableInfo ( ) ; } protected static void overrideAsNeeded ( String override ) { if ( override != null ) { LogLog . debug ( "Handling non-null disable override directive: \"" + override + "\"." ) ; if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding all disable methods." ) ; Category . disable = Category . DISABLE_OVERRIDE ; } } } public static void resetConfiguration ( ) { Category . defaultHierarchy . getRoot ( ) . setPriority ( Priority . DEBUG ) ; Category . defaultHierarchy . root . setResourceBundle ( null ) ; Category . disable = Category . DISABLE_OFF ; synchronized ( Category . defaultHierarchy . ht ) { Category . defaultHierarchy . shutdown ( ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . setPriority ( null ) ; c . setAdditivity ( true ) ; c . setResourceBundle ( null ) ; } } Category . defaultHierarchy . rendererMap . clear ( ) ; } } 	1	['14', '1', '2', '20', '42', '91', '9', '11', '9', '1.051282051', '247', '0', '0', '0', '0.134615385', '0', '0', '16.42857143', '3', '1.2857', '1']
package org . apache . log4j . helpers ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . text . FieldPosition ; abstract public class DateLayout extends Layout { public final static String NULL_DATE_FORMAT = "NULL" ; public final static String RELATIVE_TIME_DATE_FORMAT = "RELATIVE" ; protected FieldPosition pos = new FieldPosition ( 0 ) ; final static public String DATE_FORMAT_OPTION = "DateFormat" ; final static public String TIMEZONE_OPTION = "TimeZone" ; private String timeZoneID ; private String dateFormatOption ; protected DateFormat dateFormat ; protected Date date = new Date ( ) ; public void activateOptions ( ) { setDateFormat ( dateFormatOption ) ; if ( timeZoneID != null && dateFormat != null ) { dateFormat . setTimeZone ( TimeZone . getTimeZone ( timeZoneID ) ) ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { DATE_FORMAT_OPTION , TIMEZONE_OPTION } ; } public void dateFormat ( StringBuffer buf , LoggingEvent event ) { if ( dateFormat != null ) { date . setTime ( event . timeStamp ) ; dateFormat . format ( date , buf , this . pos ) ; buf . append ( ' ' ) ; } } public void setDateFormat ( DateFormat dateFormat , TimeZone timeZone ) { this . dateFormat = dateFormat ; this . dateFormat . setTimeZone ( timeZone ) ; } public void setDateFormat ( String dateFormatType ) { setDateFormat ( dateFormatType , TimeZone . getDefault ( ) ) ; } public void setDateFormat ( String dateFormatType , TimeZone timeZone ) { if ( dateFormatType == null ) { this . dateFormat = null ; return ; } if ( dateFormatType . equalsIgnoreCase ( NULL_DATE_FORMAT ) ) { this . dateFormat = null ; } else if ( dateFormatType . equalsIgnoreCase ( RELATIVE_TIME_DATE_FORMAT ) ) { this . dateFormat = new RelativeTimeDateFormat ( ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) { this . dateFormat = new AbsoluteTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) { this . dateFormat = new DateTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) { this . dateFormat = new ISO8601DateFormat ( timeZone ) ; } else { this . dateFormat = new SimpleDateFormat ( dateFormatType ) ; this . dateFormat . setTimeZone ( timeZone ) ; } } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( DATE_FORMAT_OPTION ) ) { dateFormatOption = value . toUpperCase ( ) ; } else if ( option . equalsIgnoreCase ( TIMEZONE_OPTION ) ) { timeZoneID = value ; } } } 	0	['8', '2', '1', '7', '24', '12', '1', '6', '8', '0.936507937', '179', '0.555555556', '0', '0.533333333', '0.333333333', '0', '0', '20.25', '7', '2.25', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . File ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . CountingQuietWriter ; import org . apache . log4j . spi . LoggingEvent ; public class RollingFileAppender extends FileAppender { static final public String MAX_FILE_SIZE_OPTION = "MaxFileSize" ; static final public String MAX_BACKUP_INDEX_OPTION = "MaxBackupIndex" ; protected long maxFileSize = 10 * 1024 * 1024 ; protected int maxBackupIndex = 1 ; public RollingFileAppender ( ) { super ( ) ; } public RollingFileAppender ( Layout layout , OutputStream os ) { super ( layout , os ) ; } public RollingFileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } public RollingFileAppender ( Layout layout , String filename , boolean append ) throws IOException { super ( layout , filename , append ) ; } public RollingFileAppender ( Layout layout , String filename ) throws IOException { super ( layout , filename ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { MAX_FILE_SIZE_OPTION , MAX_BACKUP_INDEX_OPTION } ) ; } public synchronized void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; if ( append ) { File f = new File ( fileName ) ; ( ( CountingQuietWriter ) qw ) . setCount ( f . length ( ) ) ; } } public synchronized void rollOver ( ) { File target ; File file ; if ( maxBackupIndex > 0 ) { file = new File ( fileName + '.' + maxBackupIndex ) ; if ( file . exists ( ) ) file . delete ( ) ; for ( int i = maxBackupIndex - 1 ; i >= 1 ; i -- ) { file = new File ( fileName + "." + i ) ; if ( file . exists ( ) ) { target = new File ( fileName + '.' + ( i + 1 ) ) ; file . renameTo ( target ) ; } } target = new File ( fileName + "." + 1 ) ; this . closeWriterIfOurs ( ) ; file = new File ( fileName ) ; file . renameTo ( target ) ; } try { this . setFile ( fileName , false ) ; } catch ( IOException e ) { System . err . println ( "setFile(" + fileName + ", false) call failed." ) ; e . printStackTrace ( ) ; } } public void setMaxBackupIndex ( int maxBackups ) { this . maxBackupIndex = maxBackups ; } public void setMaxFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( MAX_FILE_SIZE_OPTION ) ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } else if ( key . equalsIgnoreCase ( MAX_BACKUP_INDEX_OPTION ) ) { maxBackupIndex = OptionConverter . toInt ( value , maxBackupIndex ) ; } } protected void setQWForFiles ( Writer writer ) { this . qw = new CountingQuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { super . subAppend ( event ) ; if ( ( fileName != null ) && ( ( CountingQuietWriter ) qw ) . getCount ( ) >= maxFileSize ) this . rollOver ( ) ; } } 	1	['13', '3', '1', '10', '42', '0', '2', '8', '11', '0.729166667', '289', '0.5', '0', '0.804878049', '0.247863248', '1', '10', '20.92307692', '5', '1.2308', '1']
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	['10', '1', '5', '34', '13', '45', '32', '2', '9', '1', '28', '0', '0', '0', '0.407407407', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . helpers . LogLog ; public class NDC { static Hashtable ht = new Hashtable ( ) ; static int pushCounter = 0 ; static final int REAP_THRESHOLD = 5 ; private NDC ( ) { } public static void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null ) stack . setSize ( 0 ) ; } public static Stack cloneStack ( ) { Object o = ht . get ( Thread . currentThread ( ) ) ; if ( o == null ) return null ; else { Stack stack = ( Stack ) o ; return ( Stack ) stack . clone ( ) ; } } public static void inherit ( Stack stack ) { if ( stack != null ) ht . put ( Thread . currentThread ( ) , stack ) ; } static public String get ( ) { Stack s = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( s != null && ! s . isEmpty ( ) ) return ( ( DiagnosticContext ) s . peek ( ) ) . fullMessage ; else return null ; } public static int getDepth ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack == null ) return 0 ; else return stack . size ( ) ; } private static void lazyRemove ( ) { Vector v ; synchronized ( ht ) { if ( ++ pushCounter >= REAP_THRESHOLD ) { return ; } else { pushCounter = 0 ; } int misses = 0 ; v = new Vector ( ) ; Enumeration enum = ht . keys ( ) ; while ( enum . hasMoreElements ( ) && ( misses <= 4 ) ) { Thread t = ( Thread ) enum . nextElement ( ) ; if ( t . isAlive ( ) ) { misses ++ ; } else { misses = 0 ; v . addElement ( t ) ; } } } int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Thread t = ( Thread ) v . elementAt ( i ) ; LogLog . debug ( "Lazy NDC removal for thread [" + t . getName ( ) + "] (" + ht . size ( ) + ")." ) ; ht . remove ( t ) ; } } public static String pop ( ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack != null && ! stack . isEmpty ( ) ) return ( ( DiagnosticContext ) stack . pop ( ) ) . message ; else return "" ; } public static void push ( String message ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack == null ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack = new Stack ( ) ; ht . put ( key , stack ) ; stack . push ( dc ) ; } else if ( stack . isEmpty ( ) ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack . push ( dc ) ; } else { DiagnosticContext parent = ( DiagnosticContext ) stack . peek ( ) ; stack . push ( new DiagnosticContext ( message , parent ) ) ; } } static public void remove ( ) { ht . remove ( Thread . currentThread ( ) ) ; lazyRemove ( ) ; } static public void setMaxDepth ( int maxDepth ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null && maxDepth < stack . size ( ) ) stack . setSize ( maxDepth ) ; } private static class DiagnosticContext { String fullMessage ; String message ; DiagnosticContext ( String message , DiagnosticContext parent ) { this . message = message ; if ( parent != null ) { fullMessage = parent . fullMessage + ' ' + message ; } else { fullMessage = message ; } } } } 	1	['12', '1', '0', '12', '41', '0', '10', '2', '9', '0.666666667', '275', '0', '0', '0', '0.090909091', '0', '0', '21.66666667', '6', '2.25', '1']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '1', '14', '8', '0', '1', '2', '0.875', '45', '0', '1', '0', '0.333333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; final static int FATAL_INT = 50000 ; final static int ERROR_INT = 40000 ; final static int WARN_INT = 30000 ; final static int INFO_INT = 20000 ; final static int DEBUG_INT = 10000 ; final static public Priority FATAL = new Priority ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Priority ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Priority ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Priority ( INFO_INT , "INFO" , 5 ) ; final static public Priority DEBUG = new Priority ( DEBUG_INT , "DEBUG" , 6 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Priority . WARN , Priority . INFO , Priority . DEBUG } ; } public static Priority toPriority ( String sArg ) { return toPriority ( sArg , Priority . DEBUG ) ; } public static Priority toPriority ( int val ) { switch ( val ) { case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case FATAL_INT : return FATAL ; default : return DEBUG ; } } public static Priority toPriority ( String sArg , Priority defaultPriority ) { if ( sArg == null ) return defaultPriority ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "DEBUG" ) ) return Priority . DEBUG ; if ( s . equals ( "INFO" ) ) return Priority . INFO ; if ( s . equals ( "WARN" ) ) return Priority . WARN ; if ( s . equals ( "ERROR" ) ) return Priority . ERROR ; if ( s . equals ( "FATAL" ) ) return Priority . FATAL ; return defaultPriority ; } } 	1	['10', '1', '2', '40', '13', '15', '40', '0', '8', '0.811965812', '169', '0', '5', '0', '0.333333333', '0', '0', '14.6', '7', '2.1', '1']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( 0 , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	1	['6', '1', '0', '7', '21', '0', '5', '2', '5', '0.9', '274', '0.2', '0', '0', '0.466666667', '0', '0', '43', '5', '2.8333', '1']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . DateLayout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; public class TTCCLayout extends DateLayout { final static public String THREAD_PRINTING_OPTION = "ThreadPrinting" ; final static public String CATEGORY_PREFIXING_OPTION = "CategoryPrefixing" ; final static public String CONTEXT_PRINTING_OPTION = "ContextPrinting" ; private boolean threadPrinting = true ; private boolean categoryPrefixing = true ; private boolean contextPrinting = true ; protected final StringBuffer buf = new StringBuffer ( 256 ) ; public TTCCLayout ( ) { this . setDateFormat ( RELATIVE_TIME_DATE_FORMAT , null ) ; } public TTCCLayout ( String dateFormatType ) { this . setDateFormat ( dateFormatType ) ; } public String format ( LoggingEvent event ) { buf . setLength ( 0 ) ; dateFormat ( buf , event ) ; if ( this . threadPrinting ) { buf . append ( '[' ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "] " ) ; } buf . append ( event . priority . toString ( ) ) ; buf . append ( ' ' ) ; if ( this . categoryPrefixing ) { buf . append ( event . categoryName ) ; buf . append ( ' ' ) ; } if ( this . contextPrinting ) { event . getNDC ( ) ; if ( event . ndc != null ) { buf . append ( event . ndc ) ; buf . append ( ' ' ) ; } } buf . append ( "- " ) ; buf . append ( event . message ) ; buf . append ( LINE_SEP ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { THREAD_PRINTING_OPTION , CATEGORY_PREFIXING_OPTION , CONTEXT_PRINTING_OPTION } ) ; } public boolean ignoresThrowable ( ) { return true ; } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( THREAD_PRINTING_OPTION ) ) threadPrinting = OptionConverter . toBoolean ( value , threadPrinting ) ; else if ( key . equalsIgnoreCase ( CATEGORY_PREFIXING_OPTION ) ) categoryPrefixing = OptionConverter . toBoolean ( value , categoryPrefixing ) ; else if ( key . equalsIgnoreCase ( CONTEXT_PRINTING_OPTION ) ) contextPrinting = OptionConverter . toBoolean ( value , contextPrinting ) ; } public void setCategoryPrefixing ( boolean categoryPrefixing ) { this . categoryPrefixing = categoryPrefixing ; } public void setThreadPrinting ( boolean threadPrinting ) { this . threadPrinting = threadPrinting ; } } 	0	['8', '3', '0', '7', '25', '0', '2', '5', '8', '0.795918367', '217', '0.571428571', '0', '0.714285714', '0.40625', '1', '1', '25.25', '5', '1.625', '0']
package org . apache . log4j . helpers ; public class LogLog { public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean configDebugEnabled = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; static { try { String key = System . getProperty ( CONFIG_DEBUG_KEY ) ; if ( key != null ) configDebugEnabled = OptionConverter . toBoolean ( key , true ) ; } catch ( SecurityException e ) { System . err . println ( PREFIX + "Could not read system property \"" + CONFIG_DEBUG_KEY + "\"." ) ; } } static public void setInternalDebugging ( boolean enabled ) { configDebugEnabled = enabled ; } public static void debug ( String msg ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( configDebugEnabled ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	1	['7', '1', '0', '28', '16', '9', '28', '1', '6', '1', '91', '0.75', '0', '0', '0.333333333', '0', '0', '11.42857143', '3', '1.2857', '2']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . LogLog ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public String fqnOfCategoryClass ; public String categoryName ; transient public Priority priority ; public String ndc ; public boolean ndcLookupRequired = true ; public String message ; public String threadName ; transient public Throwable throwable ; public String throwableInformation ; public long timeStamp ; public LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; public LoggingEvent ( String fqnOfCategoryClass , Category category , Priority priority , String message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . categoryName = category . getName ( ) ; this . priority = priority ; this . message = message ; this . throwable = throwable ; timeStamp = System . currentTimeMillis ( ) ; } public static long getStartTime ( ) { return startTime ; } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public String getThrowableInformation ( ) { if ( throwable == null ) { return null ; } if ( throwableInformation == null ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; throwable . printStackTrace ( pw ) ; throwableInformation = sw . toString ( ) ; } return throwableInformation ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getNDC ( ) ; this . getThrowableInformation ( ) ; oos . defaultWriteObject ( ) ; oos . writeInt ( priority . toInt ( ) ) ; } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; priority = Priority . toPriority ( ois . readInt ( ) ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } public void setLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } } } 	1	['9', '1', '0', '53', '27', '20', '50', '4', '6', '0.894230769', '151', '0.076923077', '2', '0', '0.232142857', '0', '0', '14.33333333', '3', '1.3333', '2']
package org . apache . log4j . spi ; public interface OptionHandler { void activateOptions ( ) ; String [ ] getOptionStrings ( ) ; void setOption ( String option , String value ) ; } 	0	['3', '1', '0', '8', '3', '3', '8', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import java . net . URL ; import java . awt . Image ; import java . awt . Toolkit ; public class Loader extends java . lang . Object { public static Image getGIF_Image ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static Image getGIF_Image ( URL url ) { Image img = null ; try { System . out . println ( url ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public static URL getHTML_Page ( String path ) { URL url = null ; return ( url = ClassLoader . getSystemResource ( path ) ) ; } } 	1	['4', '1', '0', '0', '15', '6', '0', '0', '4', '2', '73', '0', '0', '0', '0.333333333', '0', '0', '17.25', '1', '0.75', '3']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class SocketNode implements Runnable { Socket socket ; Hierarchy hierarchy ; ObjectInputStream ois ; static Category cat = Category . getInstance ( SocketNode . class . getName ( ) ) ; public SocketNode ( Socket socket , Hierarchy hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( socket . getInputStream ( ) ) ; } catch ( Exception e ) { cat . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Category remoteCategory ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteCategory = hierarchy . getInstance ( event . categoryName ) ; if ( event . priority . isGreaterOrEqual ( remoteCategory . getChainedPriority ( ) ) ) { remoteCategory . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { cat . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { cat . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( Exception e ) { cat . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { cat . info ( "Could not close connection." , e ) ; } } } 	0	['4', '1', '0', '7', '25', '0', '3', '4', '2', '0.733333333', '106', '0', '2', '0', '0.416666667', '0', '0', '24.25', '2', '0.75', '0']
package org . apache . log4j . xml ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; public class XMLLayout extends Layout { private final int DEFAULT_SIZE = 256 ; private final int UPPER_LIMIT = 2048 ; private StringBuffer buf = new StringBuffer ( DEFAULT_SIZE ) ; private boolean locationInfo = false ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( buf . capacity ( ) > UPPER_LIMIT ) { buf = new StringBuffer ( DEFAULT_SIZE ) ; } else { buf . setLength ( 0 ) ; } buf . append ( "<log4j:event category=\"" ) ; buf . append ( event . categoryName ) ; buf . append ( "\" timestamp=\"" ) ; buf . append ( event . timeStamp ) ; buf . append ( "\" priority=\"" ) ; buf . append ( event . priority ) ; buf . append ( "\" thread=\"" ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "\">\r\n" ) ; buf . append ( "<log4j:message>" ) ; buf . append ( event . message ) ; buf . append ( "</log4j:message>\r\n" ) ; String ndc = event . getNDC ( ) ; if ( ndc != null ) { buf . append ( "<log4j:NDC>" ) ; buf . append ( ndc ) ; buf . append ( "</log4j:NDC>\r\n" ) ; } String t = event . getThrowableInformation ( ) ; if ( t != null ) { buf . append ( "<log4j:throwable>" ) ; buf . append ( t ) ; buf . append ( "</log4j:throwable>\r\n" ) ; } if ( locationInfo ) { event . setLocationInformation ( ) ; buf . append ( "<log4j:locationInfo class=\"" ) ; buf . append ( event . locationInfo . getClassName ( ) ) ; buf . append ( "\" method=\"" ) ; buf . append ( event . locationInfo . getMethodName ( ) ) ; buf . append ( "\" file=\"" ) ; buf . append ( event . locationInfo . getFileName ( ) ) ; buf . append ( "\" line=\"" ) ; buf . append ( event . locationInfo . getLineNumber ( ) ) ; buf . append ( "\"/>\r\n" ) ; } buf . append ( "</log4j:event>\r\n\r\n" ) ; return buf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } } 	1	['6', '2', '0', '5', '24', '9', '0', '5', '6', '0.92', '241', '0.8', '0', '0.615384615', '0.444444444', '1', '1', '38.33333333', '5', '1.8333', '1']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; static int delay ; static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile delay" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String delayStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } try { delay = Integer . parseInt ( delayStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret delay number [" + delayStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	1	['7', '1', '0', '5', '35', '15', '0', '5', '2', '0.75', '179', '0', '1', '0', '0.25', '0', '0', '24', '2', '1', '1']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	0	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . TracerPrintWriter ; public class FileAppender extends AppenderSkeleton { public static final String FILE_OPTION = "File" ; public static final String IMMEDIATE_FLUSH_OPTION = "ImmediateFlush" ; public static final String APPEND_OPTION = "Append" ; protected boolean fileAppend = true ; protected boolean immediateFlush = true ; protected QuietWriter qw ; protected TracerPrintWriter tp ; protected String fileName = null ; protected boolean qwIsOurs = false ; public FileAppender ( ) { } public FileAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public FileAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public FileAppender ( Layout layout , String filename , boolean append ) throws IOException { this . layout = layout ; this . setFile ( filename , append ) ; } public FileAppender ( Layout layout , String filename ) throws IOException { this ( layout , filename , true ) ; } public void activateOptions ( ) { if ( fileName != null ) { try { setFile ( fileName , fileAppend ) ; } catch ( java . io . IOException e ) { errorHandler . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e , ErrorCode . FILE_OPEN_FAILURE ) ; } } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . qw == null ) { errorHandler . error ( "No output target set for appender named \"" + name + "\"." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named \"" + name + "\"." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; reset ( ) ; } protected void closeWriterIfOurs ( ) { if ( this . qwIsOurs && this . qw != null ) { try { this . qw . close ( ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not close output stream " + qw , e ) ; } } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { FILE_OPTION , APPEND_OPTION , IMMEDIATE_FLUSH_OPTION } ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { this . errorHandler = eh ; if ( this . qwIsOurs && this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { reset ( ) ; this . setQWForFiles ( new FileWriter ( fileName , append ) ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fileName = fileName ; this . qwIsOurs = true ; } public void setFile ( String fileName ) throws IOException { this . setFile ( fileName , fileAppend ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( FILE_OPTION ) ) { value = value . trim ( ) ; if ( value . equalsIgnoreCase ( "System.out" ) ) setWriter ( new OutputStreamWriter ( System . out ) ) ; else if ( value . equalsIgnoreCase ( "System.err" ) ) setWriter ( new OutputStreamWriter ( System . err ) ) ; else { fileName = value ; } } else if ( key . equalsIgnoreCase ( APPEND_OPTION ) ) { fileAppend = OptionConverter . toBoolean ( value , fileAppend ) ; } else if ( key . equalsIgnoreCase ( IMMEDIATE_FLUSH_OPTION ) ) { immediateFlush = OptionConverter . toBoolean ( value , immediateFlush ) ; } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . qwIsOurs = false ; } protected void setQWForFiles ( Writer writer ) { this . qw = new QuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { if ( event . throwable != null ) { event . throwable . printStackTrace ( this . tp ) ; } else if ( event . throwableInformation != null ) { this . qw . write ( event . throwableInformation ) ; } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriterIfOurs ( ) ; this . fileName = null ; this . qw = null ; this . tp = null ; } } 	1	['20', '2', '2', '17', '46', '58', '9', '8', '15', '0.649122807', '413', '0.666666667', '2', '0.545454545', '0.2375', '1', '3', '19.2', '7', '1.65', '1']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . Writer ; public class HTMLLayout extends Layout { protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; boolean locationInfo = false ; public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } sbuf . append ( "\r\n\r\n<tr>" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . timeStamp - event . getStartTime ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getThreadName ( ) ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; if ( event . priority . isGreaterOrEqual ( Priority . WARN ) ) { sbuf . append ( "<font color=\"#FF0000\">" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</font>" ) ; } else { sbuf . append ( event . priority ) ; } sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . categoryName ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . getNDC ( ) ) ; sbuf . append ( "</td>\r\n" ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . locationInfo . getFileName ( ) ) ; sbuf . append ( ':' ) ; sbuf . append ( event . locationInfo . getLineNumber ( ) ) ; sbuf . append ( "</td>\r\n" ) ; } sbuf . append ( "<td>" ) ; sbuf . append ( event . message ) ; sbuf . append ( "</td>\r\n" ) ; sbuf . append ( "</tr>" ) ; if ( event . throwable != null ) { sbuf . append ( "\r\n<tr><td colspan=\"7\">" ) ; sbuf . append ( getThrowableAsHTML ( event . throwable ) ) ; sbuf . append ( "</td></tr>" ) ; } return sbuf . toString ( ) ; } public String getContentType ( ) { return "text/html" ; } public String getHeader ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "<html><body>\r\n" ) ; sbuf . append ( "<table border=\"1\" cellpadding=\"2\">\r\n<tr>\r\n" ) ; sbuf . append ( "<th>Time</th><th>Thread</th><th>Priority</th><th>Category</th>" ) ; sbuf . append ( "<th>NDC</th>" ) ; if ( locationInfo ) { sbuf . append ( "<th>File:Line</th>" ) ; } sbuf . append ( "<th>Message</th></tr>" ) ; return sbuf . toString ( ) ; } public String getFooter ( ) { return "</table></body></html>" ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION } ; } String getThrowableAsHTML ( Throwable throwable ) { if ( throwable == null ) return null ; StringWriter sw = new StringWriter ( ) ; HTMLPrintWriter hpw = new HTMLPrintWriter ( sw ) ; throwable . printStackTrace ( hpw ) ; return sw . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } static class HTMLPrintWriter extends PrintWriter { static String TRACE_PREFIX = "<br>&nbsp;&nbsp;&nbsp;&nbsp;" ; public HTMLPrintWriter ( Writer writer ) { super ( writer ) ; } public void println ( char [ ] c ) { write ( TRACE_PREFIX ) ; this . write ( c ) ; } public void println ( String s ) { write ( TRACE_PREFIX ) ; this . write ( s ) ; } } } 	1	['10', '2', '0', '6', '33', '33', '0', '6', '9', '0.933333333', '321', '0.6', '0', '0.470588235', '0.325', '1', '1', '30.6', '5', '1.7', '2']
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	['5', '1', '0', '1', '7', '8', '1', '0', '3', '0.75', '22', '1', '1', '0', '0.75', '0', '0', '3.2', '1', '0.6', '0']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import java . util . Enumeration ; import java . util . Vector ; import java . util . MissingResourceException ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import java . net . URL ; import java . net . MalformedURLException ; public class Category implements AppenderAttachable { static final int DISABLE_OFF = - 1 ; static final int DISABLE_OVERRIDE = - 21 ; private static String DEFAULT_FQN = "org.apache.log4j.Category" ; protected static String instanceFQN ; protected static int disable = Category . DISABLE_OFF ; static boolean emittedNoAppenderWarning = false ; static boolean emittedNoResourceBundleWarning = false ; static public final Hierarchy defaultHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; protected ResourceBundle resourceBundle ; protected Hierarchy myContext ; static public final String DEFAULT_CONFIGURATION_FILE = "log4j.properties" ; static final public String DEFAULT_CONFIGURATION_KEY = "log4j.configuration" ; public static final String DEFAULT_INIT_OVERRIDE_KEY = "log4j.defaultInitOverride" ; static { String override = null ; try { override = System . getProperty ( DEFAULT_INIT_OVERRIDE_KEY , override ) ; } catch ( SecurityException e ) { LogLog . debug ( "Could not read system property \"" + DEFAULT_INIT_OVERRIDE_KEY + "\"." , e ) ; } if ( override == null || "false" . equalsIgnoreCase ( override ) ) { String resource = System . getProperty ( DEFAULT_CONFIGURATION_KEY , DEFAULT_CONFIGURATION_FILE ) ; URL url = null ; try { url = new URL ( resource ) ; } catch ( MalformedURLException ex ) { url = Category . class . getResource ( resource ) ; if ( url == null ) { ClassLoader loader = Category . class . getClassLoader ( ) ; if ( loader != null ) { url = loader . getResource ( resource ) ; } } } if ( url != null ) { OptionConverter . selectAndConfigure ( url ) ; } else { LogLog . debug ( "Could not find resource: [" + resource + "]." ) ; } } } protected String name ; protected Priority priority ; protected Category parent ; AppenderAttachableImpl aai ; protected boolean additive = true ; protected Category ( String name ) { this . name = name ; this . instanceFQN = DEFAULT_FQN ; } synchronized public void addAppender ( Appender newAppender ) { if ( aai == null ) { aai = new AppenderAttachableImpl ( ) ; } aai . addAppender ( newAppender ) ; } public void assert ( boolean assertion , String msg ) { if ( ! assertion ) this . error ( msg ) ; } public void callAppenders ( LoggingEvent event ) { int writes = 0 ; for ( Category c = this ; c != null ; c = c . parent ) { synchronized ( c ) { if ( c . aai != null ) { writes += c . aai . appendLoopOnAppenders ( event ) ; } if ( ! c . additive ) { break ; } } } if ( ! Category . emittedNoAppenderWarning && writes == 0 ) { LogLog . error ( "No appenders could be found for category (" + this . getName ( ) + ")." ) ; LogLog . error ( "Please initialize the log4j system properly." ) ; emittedNoAppenderWarning = true ; } } synchronized void closeNestedAppenders ( ) { Enumeration enum = this . getAllAppenders ( ) ; if ( enum != null ) { while ( enum . hasMoreElements ( ) ) { Appender a = ( Appender ) enum . nextElement ( ) ; if ( a instanceof AppenderAttachable ) { a . close ( ) ; } } } } public void debug ( Object message ) { if ( disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( instanceFQN , Priority . DEBUG , message , null ) ; } } public void debug ( Object message , Throwable t ) { if ( disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . DEBUG , message , t ) ; } public void error ( Object message ) { if ( disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( instanceFQN , Priority . ERROR , message , null ) ; } public void error ( Object message , Throwable t ) { if ( disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( instanceFQN , Priority . ERROR , message , t ) ; } public static Category exists ( String name ) { return defaultHierarchy . exists ( name ) ; } public void fatal ( Object message ) { if ( disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . FATAL , message , null ) ; } public void fatal ( Object message , Throwable t ) { if ( disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . FATAL , message , t ) ; } protected void forcedLog ( String fqn , Priority priority , Object message , Throwable t ) { String s ; if ( message instanceof String ) { s = ( String ) message ; } else { s = myContext . rendererMap . findAndRender ( message ) ; } callAppenders ( new LoggingEvent ( fqn , this , priority , s , t ) ) ; } public boolean getAdditivity ( ) { return additive ; } public Enumeration getAllAppenders ( ) { if ( aai == null ) return NullEnumeration . getInstance ( ) ; else return aai . getAllAppenders ( ) ; } public Appender getAppender ( String name ) { if ( aai == null || name == null ) return null ; return aai . getAppender ( name ) ; } public Priority getChainedPriority ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . priority != null ) return c . priority ; } return null ; } public static Enumeration getCurrentCategories ( ) { Vector v = new Vector ( defaultHierarchy . ht . size ( ) ) ; Enumeration elems = defaultHierarchy . ht . elements ( ) ; while ( elems . hasMoreElements ( ) ) { Object o = elems . nextElement ( ) ; if ( o instanceof Category ) { v . addElement ( o ) ; } } return v . elements ( ) ; } public static Hierarchy getDefaultHierarchy ( ) { return defaultHierarchy ; } public static Category getInstance ( String name ) { return defaultHierarchy . getInstance ( name ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) ) ; } public static Category getInstance ( String name , CategoryFactory factory ) { return defaultHierarchy . getInstance ( name , factory ) ; } public final String getName ( ) { return name ; } final public Priority getPriority ( ) { return this . priority ; } final public static Category getRoot ( ) { return defaultHierarchy . getRoot ( ) ; } public ResourceBundle getResourceBundle ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . resourceBundle != null ) return c . resourceBundle ; } return null ; } protected String getResourceBundleString ( String key ) { ResourceBundle rb = getResourceBundle ( ) ; if ( rb == null ) { if ( ! emittedNoResourceBundleWarning ) { error ( "No resource bundle has been set for category " + name ) ; emittedNoResourceBundleWarning = true ; } return null ; } else { try { return rb . getString ( key ) ; } catch ( MissingResourceException mre ) { error ( "No resource is associated with key \"" + key + "\"." ) ; return null ; } } } public void info ( Object message ) { if ( disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . INFO , message , null ) ; } public void info ( Object message , Throwable t ) { if ( disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , Priority . INFO , message , t ) ; } public boolean isDebugEnabled ( ) { if ( disable >= Priority . DEBUG_INT ) return false ; return Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isEnabledFor ( Priority priority ) { if ( disable >= priority . level ) { return false ; } return priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isInfoEnabled ( ) { if ( disable >= Priority . INFO_INT ) return false ; return Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public void l7dlog ( Priority priority , String key , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String msg = getResourceBundleString ( key ) ; if ( msg == null ) { msg = key ; } callAppenders ( new LoggingEvent ( instanceFQN , this , priority , msg , t ) ) ; } } public void l7dlog ( Priority priority , String key , Object [ ] params , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String pattern = getResourceBundleString ( key ) ; String msg ; if ( pattern == null ) msg = key ; else msg = java . text . MessageFormat . format ( pattern , params ) ; callAppenders ( new LoggingEvent ( instanceFQN , this , priority , msg , t ) ) ; } } public void log ( Priority priority , Object message , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , priority , message , t ) ; } public void log ( Priority priority , Object message ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( instanceFQN , priority , message , null ) ; } public void log ( String callerFQN , Priority priority , Object message , Throwable t ) { if ( disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( callerFQN , priority , message , t ) ; } } synchronized public void removeAllAppenders ( ) { if ( aai != null ) { aai . removeAllAppenders ( ) ; aai = null ; } } synchronized public void removeAppender ( Appender appender ) { if ( appender == null || aai == null ) return ; aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { if ( name == null || aai == null ) return ; aai . removeAppender ( name ) ; } public void setAdditivity ( boolean additive ) { this . additive = additive ; } final void setHierarchy ( Hierarchy hierarchy ) { this . myContext = hierarchy ; } public void setPriority ( Priority priority ) { this . priority = priority ; } public void setResourceBundle ( ResourceBundle bundle ) { resourceBundle = bundle ; } public static void shutdown ( ) { defaultHierarchy . shutdown ( ) ; } public void warn ( Object message ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( instanceFQN , Priority . WARN , message , null ) ; } public void warn ( Object message , Throwable t ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( instanceFQN , Priority . WARN , message , t ) ; } } 	1	['49', '1', '3', '60', '96', '688', '53', '12', '42', '0.828947368', '800', '0.473684211', '5', '0', '0.150641026', '0', '0', '14.93877551', '6', '2.1429', '9']
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public static final String THRESHOLD_OPTION = "Threshold" ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public final Filter getFirstFilter ( ) { return headFilter ; } public final String getName ( ) { return this . name ; } public String [ ] getOptionStrings ( ) { return new String [ ] { THRESHOLD_OPTION } ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; } if ( ! isAsSevereAsThreshold ( event . priority ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . error ( "It is forbidden to set a null ErrorHandler. Ignoring directive." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( THRESHOLD_OPTION ) ) { threshold = Priority . toPriority ( value ) ; } } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	0	['19', '1', '9', '20', '31', '131', '11', '9', '18', '0.909722222', '181', '0.875', '5', '0', '0.210526316', '0', '0', '8.105263158', '4', '1.4211', '0']
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public void setLayout ( Layout layout ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	1	['9', '1', '0', '22', '9', '36', '18', '4', '9', '2', '9', '0', '0', '0', '0.259259259', '0', '0', '0', '1', '1', '1']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '0']
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; private static final int FATAL = Priority . FATAL . toInt ( ) ; private static final int ERROR = Priority . ERROR . toInt ( ) ; private static final int WARN = Priority . WARN . toInt ( ) ; private static final int INFO = Priority . INFO . toInt ( ) ; private static final int DEBUG = Priority . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public void close ( ) { } public void append ( LoggingEvent event ) { StringWriter sw_writer = new StringWriter ( ) ; PrintWriter pw_writer = new PrintWriter ( sw_writer ) ; pw_writer . print ( layout . format ( event ) ) ; if ( event . throwable != null ) event . throwable . printStackTrace ( pw_writer ) ; pw_writer . close ( ) ; int nt_category = event . priority . toInt ( ) ; if ( nt_category < FATAL || nt_category > DEBUG ) { nt_category = INFO ; } reportEvent ( _handle , sw_writer . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int priority ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	['14', '2', '0', '6', '26', '83', '1', '5', '10', '0.871794872', '157', '1', '0', '0.72', '0.384615385', '1', '1', '9.785714286', '4', '0.7143', '1']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	['4', '3', '2', '9', '12', '0', '8', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . TriggeringEventEvaluator ; import java . util . Properties ; import java . util . Date ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . MimeMessage ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import javax . mail . internet . MimeUtility ; public class SMTPAppender extends AppenderSkeleton { public static final String TO_OPTION = "To" ; public static final String FROM_OPTION = "From" ; public static final String SUBJECT_OPTION = "Subject" ; public static final String SMTP_HOST_OPTION = "SMTPHost" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final String EVALUATOR_CLASS_OPTION = "EvaluatorClass" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; String to ; String from ; String subject ; String smtpHost ; int bufferSize = 512 ; CyclicBuffer cb = new CyclicBuffer ( bufferSize ) ; Session session ; Message msg ; boolean locationInfo = false ; TriggeringEventEvaluator evaluator ; public SMTPAppender ( ) { this ( new DefaultEvaluator ( ) ) ; } public SMTPAppender ( TriggeringEventEvaluator evaluator ) { this . evaluator = evaluator ; } public void activateOptions ( ) { Properties props = System . getProperties ( ) ; if ( smtpHost != null ) props . put ( "mail.smtp.host" , smtpHost ) ; session = Session . getDefaultInstance ( props , null ) ; msg = new MimeMessage ( session ) ; try { if ( from != null ) msg . setFrom ( getAddress ( from ) ) ; else msg . setFrom ( ) ; msg . setRecipients ( Message . RecipientType . TO , parseAddress ( to ) ) ; if ( subject != null ) msg . setSubject ( subject ) ; } catch ( MessagingException e ) { LogLog . error ( "Could not activate SMTPAppender options." , e ) ; } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } event . getThreadName ( ) ; event . getNDC ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } cb . add ( event ) ; if ( evaluator . isTriggeringEvent ( event ) ) { sendBuffer ( ) ; } } protected boolean checkEntryConditions ( ) { if ( this . msg == null ) { errorHandler . error ( "Message object not configured." ) ; return false ; } if ( this . evaluator == null ) { errorHandler . error ( "No TriggeringEventEvaluator is set for appender [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } public void close ( ) { this . closed = true ; } InternetAddress getAddress ( String addressStr ) { try { return new InternetAddress ( addressStr ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TO_OPTION , FROM_OPTION , SUBJECT_OPTION , SMTP_HOST_OPTION , BUFFER_SIZE_OPTION , LOCATION_INFO_OPTION } ) ; } InternetAddress [ ] parseAddress ( String addressStr ) { try { return InternetAddress . parse ( addressStr , true ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public boolean requiresLayout ( ) { return true ; } protected void sendBuffer ( ) { try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String t = layout . getHeader ( ) ; if ( t != null ) sbuf . append ( t ) ; int len = cb . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( layout . format ( cb . get ( ) ) ) ; } t = layout . getFooter ( ) ; if ( t != null ) sbuf . append ( t ) ; part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; msg . setContent ( mp ) ; msg . setSentDate ( new Date ( ) ) ; Transport . send ( msg ) ; } catch ( Exception e ) { LogLog . error ( "Error occured while sending e-mail notification." , e ) ; } } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( TO_OPTION ) ) to = value ; else if ( option . equals ( FROM_OPTION ) ) from = value ; else if ( option . equals ( SMTP_HOST_OPTION ) ) smtpHost = value ; else if ( option . equals ( SUBJECT_OPTION ) ) subject = value ; else if ( option . equals ( EVALUATOR_CLASS_OPTION ) ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { bufferSize = OptionConverter . toInt ( value , bufferSize ) ; cb . resize ( bufferSize ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class DefaultEvaluator implements TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) { return event . priority . isGreaterOrEqual ( Priority . ERROR ) ; } } 	1	['13', '2', '0', '9', '62', '52', '0', '9', '8', '0.939814815', '449', '0', '2', '0.620689655', '0.346153846', '2', '3', '32.15384615', '10', '2.3846', '3']
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	['4', '1', '0', '1', '11', '2', '1', '0', '2', '0.777777778', '61', '0', '0', '0', '0.5', '1', '1', '13.5', '6', '2', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . DefaultCategoryFactory ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import java . util . NoSuchElementException ; import java . util . Enumeration ; import java . util . Properties ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . StringTokenizer ; import java . util . Hashtable ; public class PropertyConfigurator extends BasicConfigurator implements Configurator { protected Hashtable registry = new Hashtable ( 11 ) ; protected CategoryFactory categoryFactory = new DefaultCategoryFactory ( ) ; static final String CATEGORY_PREFIX = "log4j.category." ; static final String ADDITIVITY_PREFIX = "log4j.additivity." ; static final String ROOT_CATEGORY_PREFIX = "log4j.rootCategory" ; static final String APPENDER_PREFIX = "log4j.appender." ; static final String RENDERER_PREFIX = "log4j.renderer." ; static final String CATEGORY_FACTORY_KEY = "log4j.categoryFactory" ; static final private String INTERNAL_ROOT_NAME = "root" ; public void doConfigure ( String configFileName , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; try { FileInputStream istream = new FileInputStream ( configFileName ) ; props . load ( istream ) ; istream . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not read configuration file [" + configFileName + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configFileName + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } static public void configure ( String configFilename ) { new PropertyConfigurator ( ) . doConfigure ( configFilename , Category . defaultHierarchy ) ; } public static void configure ( java . net . URL configURL ) { new PropertyConfigurator ( ) . doConfigure ( configURL , Category . defaultHierarchy ) ; } static public void configure ( Properties properties ) { new PropertyConfigurator ( ) . doConfigure ( properties , Category . defaultHierarchy ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { PropertyWatchdog pdog = new PropertyWatchdog ( configFilename ) ; pdog . setDelay ( delay ) ; pdog . start ( ) ; } public void doConfigure ( Properties properties , Hierarchy hierarchy ) { String value = properties . getProperty ( LogLog . CONFIG_DEBUG_KEY ) ; if ( value != null ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( value , true ) ) ; } String override = properties . getProperty ( BasicConfigurator . DISABLE_OVERRIDE_KEY ) ; BasicConfigurator . overrideAsNeeded ( override ) ; configureRootCategory ( properties , hierarchy ) ; configureCategoryFactory ( properties ) ; parseCatsAndRenderers ( properties , hierarchy ) ; LogLog . debug ( "Finished configuring." ) ; registry . clear ( ) ; } public void doConfigure ( java . net . URL configURL , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; LogLog . debug ( "Reading configuration from URL " + configURL ) ; try { props . load ( configURL . openStream ( ) ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not read configuration file from URL [" + configURL + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configURL + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } void configureCategoryFactory ( Properties props ) { String factoryClassName = OptionConverter . findAndSubst ( CATEGORY_FACTORY_KEY , props ) ; if ( factoryClassName != null ) { LogLog . debug ( "Setting category factory to [" + factoryClassName + "]." ) ; categoryFactory = ( CategoryFactory ) OptionConverter . instantiateByClassName ( factoryClassName , CategoryFactory . class , categoryFactory ) ; } } void configureOptionHandler ( OptionHandler oh , String prefix , Properties props ) { String [ ] options = oh . getOptionStrings ( ) ; if ( options == null ) return ; String value ; for ( int i = 0 ; i < options . length ; i ++ ) { value = OptionConverter . findAndSubst ( prefix + options [ i ] , props ) ; LogLog . debug ( "Option " + options [ i ] + "=[" + ( value == null ? "null" : value ) + "]." ) ; if ( value != null ) { oh . setOption ( options [ i ] , value ) ; } } oh . activateOptions ( ) ; } void configureRootCategory ( Properties props , Hierarchy hierarchy ) { String value = OptionConverter . findAndSubst ( ROOT_CATEGORY_PREFIX , props ) ; if ( value == null ) LogLog . debug ( "Could not find root category information. Is this OK?" ) ; else { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseCategory ( props , root , ROOT_CATEGORY_PREFIX , INTERNAL_ROOT_NAME , value ) ; } } } protected void parseCatsAndRenderers ( Properties props , Hierarchy hierarchy ) { Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( key . startsWith ( CATEGORY_PREFIX ) ) { String categoryName = key . substring ( CATEGORY_PREFIX . length ( ) ) ; String value = OptionConverter . findAndSubst ( key , props ) ; Category cat = hierarchy . getInstance ( categoryName , categoryFactory ) ; synchronized ( cat ) { parseCategory ( props , cat , key , categoryName , value ) ; parseAdditivityForCategory ( props , cat , categoryName ) ; } } else if ( key . startsWith ( RENDERER_PREFIX ) ) { String renderedClass = key . substring ( RENDERER_PREFIX . length ( ) ) ; String renderingClass = OptionConverter . findAndSubst ( key , props ) ; addRenderer ( renderedClass , renderingClass ) ; } } } void parseAdditivityForCategory ( Properties props , Category cat , String categoryName ) { String value = OptionConverter . findAndSubst ( ADDITIVITY_PREFIX + categoryName , props ) ; LogLog . debug ( "Handling " + ADDITIVITY_PREFIX + categoryName + "=[" + value + "]" ) ; if ( ( value != null ) && ( ! value . equals ( "" ) ) ) { boolean additivity = OptionConverter . toBoolean ( value , true ) ; LogLog . debug ( "Setting additivity for \"" + categoryName + "\" to " + additivity ) ; cat . setAdditivity ( additivity ) ; } } void parseCategory ( Properties props , Category cat , String optionKey , String catName , String value ) { LogLog . debug ( "Parsing for [" + catName + "] with value=[" + value + "]." ) ; StringTokenizer st = new StringTokenizer ( value , "," ) ; if ( ! ( value . startsWith ( "," ) || value . equals ( "" ) ) ) { if ( ! st . hasMoreTokens ( ) ) return ; String priorityStr = st . nextToken ( ) ; LogLog . debug ( "Priority token is [" + priorityStr + "]." ) ; if ( priorityStr . equalsIgnoreCase ( BasicConfigurator . INHERITED ) && ! catName . equals ( INTERNAL_ROOT_NAME ) ) cat . setPriority ( null ) ; else cat . setPriority ( Priority . toPriority ( priorityStr ) ) ; LogLog . debug ( "Category " + catName + " set to " + cat . getPriority ( ) ) ; } cat . removeAllAppenders ( ) ; Appender appender ; String appenderName ; while ( st . hasMoreTokens ( ) ) { appenderName = st . nextToken ( ) . trim ( ) ; if ( appenderName == null || appenderName . equals ( "," ) ) continue ; LogLog . debug ( "Parsing appender named \"" + appenderName + "\"." ) ; appender = parseAppender ( props , appenderName ) ; if ( appender != null ) { cat . addAppender ( appender ) ; } } } Appender parseAppender ( Properties props , String appenderName ) { Appender appender = registryGet ( appenderName ) ; if ( ( appender != null ) ) { LogLog . debug ( "Appender \"" + appenderName + "\" was already parsed." ) ; return appender ; } String prefix = APPENDER_PREFIX + appenderName ; String layoutPrefix = prefix + ".layout" ; appender = ( Appender ) OptionConverter . instantiateByKey ( props , prefix , org . apache . log4j . Appender . class , null ) ; if ( appender == null ) { LogLog . error ( "Could not instantiate appender named \"" + appenderName + "\"." ) ; return null ; } appender . setName ( appenderName ) ; if ( appender instanceof OptionHandler ) { configureOptionHandler ( ( OptionHandler ) appender , prefix + "." , props ) ; LogLog . debug ( "Parsed \"" + appenderName + "\" options." ) ; if ( appender . requiresLayout ( ) ) { Layout layout = ( Layout ) OptionConverter . instantiateByKey ( props , layoutPrefix , Layout . class , null ) ; if ( layout != null ) { appender . setLayout ( layout ) ; LogLog . debug ( "Parsing layout options for \"" + appenderName + "\"." ) ; configureOptionHandler ( layout , layoutPrefix + "." , props ) ; LogLog . debug ( "End of parsing for \"" + appenderName + "\"." ) ; } } } registryPut ( appender ) ; return appender ; } void registryPut ( Appender appender ) { registry . put ( appender . getName ( ) , appender ) ; } Appender registryGet ( String name ) { return ( Appender ) registry . get ( name ) ; } } class PropertyWatchdog extends FileWatchdog { PropertyWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new PropertyConfigurator ( ) . doConfigure ( filename , Category . defaultHierarchy ) ; } } 	1	['19', '2', '0', '28', '79', '153', '16', '14', '9', '0.939814815', '754', '0.25', '1', '0.4', '0.257309942', '1', '1', '38.05263158', '10', '2.4211', '2']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '3', '19', '6', '0', '3', '2', '0.666666667', '68', '0', '0', '0', '0.333333333', '0', '0', '15.75', '2', '1.25', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . examples . XPriority ; public class XCategory extends Category implements OptionHandler { private static XFactory factory = new XFactory ( ) ; static String instanceFQCN = XCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public XCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public void fatal ( String message ) { if ( disable <= XPriority . FATAL_INT ) return ; if ( XPriority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . FATAL , message , null ) ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= XPriority . TRACE_INT ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , XPriority . TRACE , message , null ) ) ; } private static class XFactory implements CategoryFactory { XFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new XCategory ( name ) ; } } } 	1	['10', '2', '0', '7', '27', '29', '1', '7', '8', '0.911111111', '145', '0.2', '1', '0.854545455', '0.777777778', '1', '4', '13', '3', '1.4', '1']
package org . apache . log4j . helpers ; import java . io . PrintWriter ; public class TracerPrintWriter extends PrintWriter { protected QuietWriter qWriter ; public TracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; this . qWriter = qWriter ; } final public void setQuietWriter ( QuietWriter qWriter ) { this . qWriter = qWriter ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } public void println ( char [ ] s ) { this . println ( new String ( s ) ) ; } public void println ( String s ) { this . qWriter . write ( s ) ; this . qWriter . write ( org . apache . log4j . Layout . LINE_SEP ) ; } } 	0	['5', '3', '1', '5', '9', '0', '3', '2', '5', '0', '43', '1', '1', '0.93442623', '0.4', '1', '1', '7.4', '1', '0.8', '0']
package org . apache . log4j . xml ; import java . util . * ; import java . net . URL ; import org . w3c . dom . * ; import java . lang . reflect . Method ; import org . apache . log4j . Category ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . Appender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import org . xml . sax . InputSource ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . net . URL ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . FactoryConfigurationError ; public class DOMConfigurator extends BasicConfigurator implements Configurator { static final String CONFIGURATION_TAG = "configuration" ; static final String RENDERER_TAG = "renderer" ; static final String APPENDER_TAG = "appender" ; static final String APPENDER_REF_TAG = "appender-ref" ; static final String PARAM_TAG = "param" ; static final String LAYOUT_TAG = "layout" ; static final String CATEGORY = "category" ; static final String NAME_ATTR = "name" ; static final String CLASS_ATTR = "class" ; static final String VALUE_ATTR = "value" ; static final String ROOT_TAG = "root" ; static final String PRIORITY_TAG = "priority" ; static final String FILTER_TAG = "filter" ; static final String ERROR_HANDLER_TAG = "errorHandler" ; static final String REF_ATTR = "ref" ; static final String ADDITIVITY_ATTR = "additivity" ; static final String SCFO_ATTR = "disableOverride" ; static final String CONFIG_DEBUG_ATTR = "configDebug" ; static final String RENDERING_CLASS_ATTR = "renderingClass" ; static final String RENDERED_CLASS_ATTR = "renderedClass" ; static final String EMPTY_STR = "" ; static final Class [ ] ONE_STRING_PARAM = new Class [ ] { String . class } ; final static String dbfKey = "javax.xml.parsers.DocumentBuilderFactory" ; Hashtable appenderBag ; public DOMConfigurator ( ) { appenderBag = new Hashtable ( ) ; } protected Appender findAppenderByReference ( Element appenderRef ) { String appenderName = appenderRef . getAttribute ( REF_ATTR ) ; Appender appender = ( Appender ) appenderBag . get ( appenderName ) ; if ( appender != null ) { return appender ; } else { Document doc = appenderRef . getOwnerDocument ( ) ; Element element = null ; NodeList list = doc . getElementsByTagName ( "appender" ) ; for ( int t = 0 ; t < list . getLength ( ) ; t ++ ) { Node node = list . item ( t ) ; NamedNodeMap map = node . getAttributes ( ) ; Node attrNode = map . getNamedItem ( "name" ) ; if ( appenderName . equals ( attrNode . getNodeValue ( ) ) ) { element = ( Element ) node ; break ; } } if ( element == null ) { LogLog . error ( "No appender named [" + appenderName + "] could be found." ) ; return null ; } else { appender = parseAppender ( element ) ; appenderBag . put ( appenderName , appender ) ; return appender ; } } } protected Appender parseAppender ( Element appenderElement ) { String className = appenderElement . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Class name: [" + className + ']' ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Appender appender = ( Appender ) instance ; appender . setName ( appenderElement . getAttribute ( NAME_ATTR ) ) ; NodeList children = appenderElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; if ( currentElement . getTagName ( ) . equals ( PARAM_TAG ) ) { if ( appender instanceof OptionHandler ) { parseParameters ( currentElement , ( OptionHandler ) appender ) ; } } else if ( currentElement . getTagName ( ) . equals ( LAYOUT_TAG ) ) { appender . setLayout ( parseLayout ( currentElement ) ) ; } else if ( currentElement . getTagName ( ) . equals ( FILTER_TAG ) ) { parseFilters ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( ERROR_HANDLER_TAG ) ) { parseErrorHandler ( currentElement , appender ) ; } else if ( currentElement . getTagName ( ) . equals ( APPENDER_REF_TAG ) ) { String refName = currentElement . getAttribute ( REF_ATTR ) ; if ( appender instanceof AppenderAttachable ) { AppenderAttachable aa = ( AppenderAttachable ) appender ; LogLog . debug ( "Attaching appender named [" + refName + "] to appender named [" + appender . getName ( ) + "]." ) ; aa . addAppender ( findAppenderByReference ( currentElement ) ) ; } else { LogLog . error ( "Requesting attachment of appender named [" + refName + "] to appender named [" + appender . getName ( ) + "] which does not implement org.apache.log4j.spi.AppenderAttachable." ) ; } } } } if ( appender instanceof OptionHandler ) { ( ( OptionHandler ) appender ) . activateOptions ( ) ; } return appender ; } catch ( Exception oops ) { LogLog . error ( "Could not create an Appender. Reported error follows." , oops ) ; return null ; } } protected void parseErrorHandler ( Element element , Appender appender ) { ErrorHandler eh = ( ErrorHandler ) OptionConverter . instantiateByClassName ( element . getAttribute ( CLASS_ATTR ) , org . apache . log4j . spi . ErrorHandler . class , null ) ; if ( eh != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , eh ) ; } } } appender . setErrorHandler ( eh ) ; } } protected void parseParameters ( Element elem , OptionHandler oh ) { String name = elem . getAttribute ( NAME_ATTR ) ; String value = elem . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Handling parameter \"" + name + "=" + value + '\"' ) ; if ( oh instanceof OptionHandler && value != null ) { oh . setOption ( name , OptionConverter . convertSpecialChars ( value ) ) ; } } protected void parseFilters ( Element element , Appender appender ) { String clazz = element . getAttribute ( CLASS_ATTR ) ; Filter filter = ( Filter ) OptionConverter . instantiateByClassName ( clazz , org . apache . log4j . spi . Filter . class , null ) ; if ( filter != null ) { NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , filter ) ; } } } appender . addFilter ( filter ) ; } } protected void parseCategory ( Element categoryElement , Hierarchy hierarchy ) { String catName = categoryElement . getAttribute ( NAME_ATTR ) ; Category cat ; String className = categoryElement . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { LogLog . debug ( "Retreiving an instance of org.apache.log4j.Category." ) ; cat = hierarchy . getInstance ( catName ) ; } else { LogLog . debug ( "Desired category sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method getInstanceMethod = clazz . getMethod ( "getInstance" , ONE_STRING_PARAM ) ; cat = ( Category ) getInstanceMethod . invoke ( null , new Object [ ] { catName } ) ; } catch ( Exception oops ) { LogLog . error ( "Could not retrieve category [" + catName + "]. Reported error follows." , oops ) ; return ; } } synchronized ( cat ) { cat . setAdditivity ( OptionConverter . toBoolean ( categoryElement . getAttribute ( ADDITIVITY_ATTR ) , true ) ) ; parseChildrenOfCategoryElement ( categoryElement , cat , false ) ; } } protected void parseRoot ( Element rootElement , Hierarchy hierarchy ) { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseChildrenOfCategoryElement ( rootElement , root , true ) ; } } protected void parseChildrenOfCategoryElement ( Element catElement , Category cat , boolean isRoot ) { cat . removeAllAppenders ( ) ; NodeList children = catElement . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( APPENDER_REF_TAG ) ) { Element appenderRef = ( Element ) currentNode ; Appender appender = findAppenderByReference ( appenderRef ) ; String refName = appenderRef . getAttribute ( REF_ATTR ) ; if ( appender != null ) LogLog . debug ( "Adding appender named [" + refName + "] to category [" + cat . getName ( ) + "]." ) ; else LogLog . debug ( "Appender named [" + refName + "] not found." ) ; cat . addAppender ( appender ) ; } else if ( tagName . equals ( PRIORITY_TAG ) ) { parsePriority ( currentElement , cat , isRoot ) ; } else if ( tagName . equals ( PARAM_TAG ) ) { if ( cat instanceof OptionHandler ) { OptionHandler oh = ( OptionHandler ) cat ; parseParameters ( currentElement , oh ) ; oh . activateOptions ( ) ; } } } } } protected Layout parseLayout ( Element layout_element ) { String className = layout_element . getAttribute ( CLASS_ATTR ) ; LogLog . debug ( "Parsing layout of class: \"" + className + "\"" ) ; try { Object instance = Class . forName ( className ) . newInstance ( ) ; Layout layout = ( Layout ) instance ; NodeList params = layout_element . getChildNodes ( ) ; final int length = params . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = ( Node ) params . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( PARAM_TAG ) ) { parseParameters ( currentElement , layout ) ; } } } layout . activateOptions ( ) ; return layout ; } catch ( Exception oops ) { LogLog . error ( "Could not create the Layout. Reported error follows." , oops ) ; return null ; } } protected void parserRenderer ( Element element ) { String renderingClass = element . getAttribute ( RENDERING_CLASS_ATTR ) ; String renderedClass = element . getAttribute ( RENDERED_CLASS_ATTR ) ; addRenderer ( renderedClass , renderingClass ) ; } protected void parsePriority ( Element element , Category cat , boolean isRoot ) { String catName = cat . getName ( ) ; if ( isRoot ) { catName = "root" ; } String priStr = element . getAttribute ( VALUE_ATTR ) ; LogLog . debug ( "Priority value for " + catName + " is  [" + priStr + "]." ) ; if ( BasicConfigurator . INHERITED . equals ( priStr ) ) { if ( isRoot ) { LogLog . error ( "Root priority cannot be inherited. Ignoring directive." ) ; } else { cat . setPriority ( null ) ; } } else { String className = element . getAttribute ( CLASS_ATTR ) ; if ( EMPTY_STR . equals ( className ) ) { cat . setPriority ( Priority . toPriority ( priStr ) ) ; } else { LogLog . debug ( "Desired Priority sub-class: [" + className + ']' ) ; try { Class clazz = Class . forName ( className ) ; Method toPriorityMethod = clazz . getMethod ( "toPriority" , ONE_STRING_PARAM ) ; Priority pri = ( Priority ) toPriorityMethod . invoke ( null , new Object [ ] { priStr } ) ; cat . setPriority ( pri ) ; } catch ( Exception oops ) { LogLog . error ( "Could not create priority [" + priStr + "]. Reported error follows." , oops ) ; return ; } } } LogLog . debug ( catName + " priority set to " + cat . getPriority ( ) ) ; } static public void configure ( Element element ) { DOMConfigurator configurator = new DOMConfigurator ( ) ; configurator . parse ( element , Category . getDefaultHierarchy ( ) ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { XMLWatchdog xdog = new XMLWatchdog ( configFilename ) ; xdog . setDelay ( delay ) ; xdog . start ( ) ; } public void doConfigure ( String filename , Hierarchy hierarchy ) { try { doConfigure ( new FileInputStream ( filename ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + filename + "]." , e ) ; } } public void doConfigure ( URL url , Hierarchy hierarchy ) { try { doConfigure ( url . openStream ( ) , hierarchy ) ; } catch ( IOException e ) { LogLog . error ( "Could not open [" + url + "]." , e ) ; } } public void doConfigure ( InputStream input , Hierarchy hierarchy ) throws FactoryConfigurationError { DocumentBuilderFactory dbf = null ; try { LogLog . debug ( "System property is :" + System . getProperty ( dbfKey ) ) ; dbf = DocumentBuilderFactory . newInstance ( ) ; LogLog . debug ( "Standard DocumentBuilderFactory search succeded." ) ; LogLog . debug ( "DocumentBuilderFactory is: " + dbf . getClass ( ) . getName ( ) ) ; } catch ( FactoryConfigurationError fce ) { Exception e = fce . getException ( ) ; LogLog . debug ( "Could not instantiate a DocumentBuilderFactory." , e ) ; throw fce ; } try { dbf . setValidating ( true ) ; DocumentBuilder docBuilder = dbf . newDocumentBuilder ( ) ; InputSource inputSource = new InputSource ( input ) ; URL dtdURL = DOMConfigurator . class . getResource ( "log4j.dtd" ) ; if ( dtdURL == null ) { LogLog . error ( "Could not find log4j.dtd." ) ; } else { LogLog . debug ( "URL to log4j.dtd is [" + dtdURL . toString ( ) + "]." ) ; inputSource . setSystemId ( dtdURL . toString ( ) ) ; } Document doc = docBuilder . parse ( inputSource ) ; parse ( doc . getDocumentElement ( ) , hierarchy ) ; } catch ( Exception e ) { LogLog . error ( "Could not parse input stream [" + input + "]." , e ) ; } } static public void configure ( String filename ) throws FactoryConfigurationError { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } protected void parse ( Element element , Hierarchy hierarchy ) { if ( ! element . getTagName ( ) . equals ( CONFIGURATION_TAG ) ) { LogLog . error ( "DOM element is not a <configuration> element" ) ; return ; } String confDebug = element . getAttribute ( CONFIG_DEBUG_ATTR ) ; LogLog . debug ( "configDebug attribute= \"" + confDebug + "\"." ) ; if ( ! confDebug . equals ( "" ) && ! confDebug . equals ( "null" ) ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( confDebug , true ) ) ; } else LogLog . debug ( "Ignoring " + CONFIG_DEBUG_ATTR + " attribute." ) ; String override = element . getAttribute ( SCFO_ATTR ) ; LogLog . debug ( "Disable override=\"" + override + "\"." ) ; if ( ! override . equals ( "" ) && ! override . equals ( "null" ) ) { overrideAsNeeded ( override ) ; } else LogLog . debug ( "Ignoring " + SCFO_ATTR + " attribute." ) ; NodeList children = element . getChildNodes ( ) ; final int length = children . getLength ( ) ; for ( int loop = 0 ; loop < length ; loop ++ ) { Node currentNode = children . item ( loop ) ; if ( currentNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element currentElement = ( Element ) currentNode ; String tagName = currentElement . getTagName ( ) ; if ( tagName . equals ( CATEGORY ) ) { parseCategory ( currentElement , hierarchy ) ; } else if ( tagName . equals ( ROOT_TAG ) ) { parseRoot ( currentElement , hierarchy ) ; } else if ( tagName . equals ( RENDERER_TAG ) ) { parserRenderer ( currentElement ) ; } } } } } class XMLWatchdog extends FileWatchdog { XMLWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new DOMConfigurator ( ) . doConfigure ( filename , Category . getDefaultHierarchy ( ) ) ; } } 	1	['22', '2', '0', '19', '95', '223', '6', '15', '8', '1.013605442', '1176', '0', '0', '0.375', '0.216450216', '1', '1', '51.18181818', '11', '3.2273', '3']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	['8', '1', '0', '3', '14', '0', '2', '1', '8', '0.571428571', '146', '0', '1', '0', '0.416666667', '0', '0', '16.625', '3', '1.75', '0']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	1	['5', '1', '3', '8', '6', '10', '6', '2', '5', '1.25', '13', '0', '1', '0', '0.466666667', '0', '0', '0.8', '1', '0.8', '1']
package org . apache . log4j . gui ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . spi . LoggingEvent ; import javax . swing . JList ; import javax . swing . AbstractListModel ; import javax . swing . JFrame ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JTable ; import javax . swing . JTextArea ; import javax . swing . table . AbstractTableModel ; import javax . swing . table . TableCellRenderer ; import javax . swing . JScrollPane ; import javax . swing . ListCellRenderer ; import java . awt . Component ; import java . awt . FlowLayout ; import javax . swing . BoxLayout ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionListener ; import java . awt . event . ActionEvent ; import java . awt . Container ; import javax . swing . ImageIcon ; import java . awt . Image ; import java . awt . Toolkit ; import java . net . URL ; import java . awt . Rectangle ; public class JTableAppender extends JTable { static Category cat = Category . getInstance ( JTableAppender . class . getName ( ) ) ; PatternLayout layout ; public JTableAppender ( ) { layout = new PatternLayout ( "%r %p %c [%t] -  %m" ) ; this . setDefaultRenderer ( Object . class , new Renderer ( ) ) ; } public void add ( LoggingEvent event ) { ( ( JTableAppenderModel ) getModel ( ) ) . add ( event ) ; } public Dimension getPreferredSize ( ) { System . out . println ( "getPreferredSize() called" ) ; return super . getPreferredSize ( ) ; } static public void main ( String [ ] args ) { JFrame frame = new JFrame ( "JListView test" ) ; Container container = frame . getContentPane ( ) ; JTableAppender appender = new JTableAppender ( ) ; JTableAppenderModel model = new JTableAppenderModel ( Integer . parseInt ( args [ 0 ] ) ) ; appender . setModel ( model ) ; JScrollPane sp = new JScrollPane ( appender ) ; sp . setPreferredSize ( new Dimension ( 250 , 80 ) ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . X_AXIS ) ) ; container . add ( sp ) ; JButton button = new JButton ( "ADD" ) ; container . add ( button ) ; button . addActionListener ( new JTableAddAction ( appender ) ) ; frame . setVisible ( true ) ; frame . setSize ( new Dimension ( 700 , 700 ) ) ; long before = System . currentTimeMillis ( ) ; int RUN = 10000 ; int i = 0 ; while ( i ++ < RUN ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " + i , null ) ; event . getThreadName ( ) ; if ( i % 10 == 0 ) { event . throwable = new Exception ( "hello " + i ) ; } appender . add ( event ) ; } long after = System . currentTimeMillis ( ) ; System . out . println ( "Time taken :" + ( ( after - before ) * 1000 / RUN ) ) ; } class Renderer extends JTextArea implements TableCellRenderer { Object o = new Object ( ) ; int i = 0 ; public Renderer ( ) { System . out . println ( "Render() called ----------------------" ) ; } public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { System . out . println ( o + " ============== " + i ++ ) ; if ( value instanceof LoggingEvent ) { LoggingEvent event = ( LoggingEvent ) value ; String str = layout . format ( event ) ; String t = event . getThrowableInformation ( ) ; if ( t != null ) { System . out . println ( "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" ) ; setText ( str + Layout . LINE_SEP + t ) ; } else { setText ( str ) ; } } else { setText ( value . toString ( ) ) ; } return this ; } } } class JTableAppenderModel extends AbstractTableModel { CyclicBuffer cb ; JTableAppenderModel ( int size ) { cb = new CyclicBuffer ( size ) ; } public void add ( LoggingEvent event ) { cb . add ( event ) ; int j = cb . length ( ) ; fireTableDataChanged ( ) ; } public int getColumnCount ( ) { return 1 ; } public int getRowCount ( ) { return cb . length ( ) ; } public Object getValueAt ( int row , int col ) { return cb . get ( row ) ; } } class JTableAddAction implements ActionListener { int j ; JTableAppender appender ; Category cat = Category . getInstance ( "x" ) ; public JTableAddAction ( JTableAppender appender ) { this . appender = appender ; j = 0 ; } public void actionPerformed ( ActionEvent e ) { System . out . println ( "Action occured" ) ; LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . DEBUG , "Message " + j , null ) ; if ( j % 5 == 0 ) { event . throwable = new Exception ( "hello " + j ) ; } j ++ ; appender . add ( event ) ; } } 	0	['6', '5', '0', '7', '44', '13', '2', '7', '4', '0.85', '208', '0', '2', '0.995139733', '0.3', '2', '2', '33', '3', '1', '0']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . io . OutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class SocketAppender extends AppenderSkeleton { InetAddress address ; int port = 4560 ; String hostName ; ObjectOutputStream oos ; int reconnectionDelay = 30000 ; boolean locationInfo = false ; private Connector connector ; int counter = 0 ; private static final int RESET_FREQUENCY = 1 ; public static final String REMOTE_HOST_OPTION = "RemoteHost" ; public static final String PORT_OPTION = "Port" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String RECONNECTION_DELAY_OPTION = "ReconnectionDelay" ; public SocketAppender ( ) { } public SocketAppender ( InetAddress address , int port ) { this . address = address ; this . port = port ; this . hostName = address . getHostName ( ) ; connect ( address , port ) ; } public SocketAppender ( String host , int port ) { this . port = port ; this . hostName = host ; this . address = getAddressByName ( host ) ; connect ( address , port ) ; } public void activateOptions ( ) { connect ( address , port ) ; } public void close ( ) { this . closed = true ; cleanUp ( ) ; } public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close oos." , e ) ; } oos = null ; } if ( connector != null ) { connector . interrupt ( ) ; connector = null ; } } void connect ( InetAddress address , int port ) { if ( this . address == null ) return ; try { cleanUp ( ) ; oos = new ObjectOutputStream ( new Socket ( address , port ) . getOutputStream ( ) ) ; } catch ( IOException e ) { LogLog . error ( "Could not connect to remote log4j server at [" + address . getHostName ( ) + "]. We will try again later." , e ) ; fireConnector ( ) ; } } public void append ( LoggingEvent event ) { if ( address == null ) { errorHandler . error ( "No remote host is set for SocketAppedender named \"" + this . name + "\"." ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . setLocationInformation ( ) ; } oos . writeObject ( event ) ; oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . debug ( "Detected problem with connection: " + e ) ; fireConnector ( ) ; } } } void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( "Starting a new connector thread." ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } } InetAddress getAddressByName ( String host ) { try { return InetAddress . getByName ( host ) ; } catch ( Exception e ) { LogLog . error ( "Could not find address of [" + host + "]." , e ) ; return null ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { REMOTE_HOST_OPTION , PORT_OPTION , LOCATION_INFO_OPTION , RECONNECTION_DELAY_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( REMOTE_HOST_OPTION ) ) address = getAddressByName ( value ) ; else if ( option . equals ( PORT_OPTION ) ) port = OptionConverter . toInt ( value , port ) ; else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; else if ( option . equals ( RECONNECTION_DELAY_OPTION ) ) reconnectionDelay = OptionConverter . toInt ( value , reconnectionDelay ) ; } class Connector extends Thread { public void run ( ) { Socket socket ; while ( ! isInterrupted ( ) ) { try { sleep ( reconnectionDelay ) ; LogLog . debug ( "Attempting connection to " + address . getHostName ( ) ) ; socket = new Socket ( address , port ) ; synchronized ( this ) { oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; connector = null ; break ; } } catch ( InterruptedException e ) { LogLog . debug ( "Connector interrupted. Leaving loop." ) ; return ; } catch ( java . net . ConnectException e ) { LogLog . debug ( "Remote host " + address . getHostName ( ) + " refused connection." ) ; } catch ( IOException e ) { LogLog . debug ( "Could not connect to " + address . getHostName ( ) + ". Exception is " + e ) ; } } } } } 	1	['14', '2', '0', '8', '43', '41', '3', '6', '10', '0.846153846', '359', '0.153846154', '1', '0.620689655', '0.244897959', '2', '3', '23.71428571', '6', '1.6429', '1']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; this . priority = priority ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	['3', '2', '0', '4', '6', '3', '2', '3', '3', '2', '25', '0', '0', '0.959183673', '0.833333333', '1', '6', '7.333333333', '2', '1', '0']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . io . IOException ; import java . io . File ; import java . util . Hashtable ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . RootCategory ; public class SocketServer { static String GENERIC = "generic" ; static String CONFIG_FILE_EXT = ".lcf" ; static Category cat = Category . getInstance ( SocketServer . class ) ; static SocketServer server ; static int port ; Hashtable hierarchyMap ; Hierarchy genericHierarchy ; File dir ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; InetAddress inetAddress = socket . getInetAddress ( ) ; cat . info ( "Connected to client at " + inetAddress ) ; Hierarchy h = ( Hierarchy ) server . hierarchyMap . get ( inetAddress ) ; if ( h == null ) { h = server . configureHierarchy ( inetAddress ) ; } cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , h ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketServer . class . getName ( ) + " port configFile directory" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String dirStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; File dir = new File ( dirStr ) ; if ( ! dir . isDirectory ( ) ) { usage ( "[" + dirStr + "] is not a directory." ) ; } server = new SocketServer ( dir ) ; } public SocketServer ( File directory ) { this . dir = directory ; hierarchyMap = new Hashtable ( 11 ) ; } Hierarchy configureHierarchy ( InetAddress inetAddress ) { cat . info ( "Locating configuration file for " + inetAddress ) ; String s = inetAddress . toString ( ) ; int i = s . indexOf ( "/" ) ; if ( i == - 1 ) { cat . warn ( "Could not parse the inetAddress [" + inetAddress + "]. Using default hierarchy." ) ; return genericHierarchy ( ) ; } else { String key = s . substring ( 0 , i ) ; File configFile = new File ( dir , key + CONFIG_FILE_EXT ) ; if ( configFile . exists ( ) ) { Hierarchy h = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; hierarchyMap . put ( inetAddress , h ) ; try { new PropertyConfigurator ( ) . doConfigure ( configFile . toURL ( ) , h ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + configFile + " to a URL." , e ) ; } return h ; } else { cat . warn ( "Could not find config file [" + configFile + "]." ) ; return genericHierarchy ( ) ; } } } Hierarchy genericHierarchy ( ) { if ( genericHierarchy == null ) { File f = new File ( dir , GENERIC + CONFIG_FILE_EXT ) ; if ( f . exists ( ) ) { genericHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; try { new PropertyConfigurator ( ) . doConfigure ( f . toURL ( ) , genericHierarchy ) ; } catch ( MalformedURLException e ) { cat . error ( "Could not convert" + f + " to a URL. Reverting to default hierarchy" , e ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } else { cat . warn ( "Could not find config file [" + f + "]. Will use the default hierarchy." ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } return genericHierarchy ; } } 	1	['8', '1', '0', '6', '49', '6', '0', '6', '2', '0.666666667', '389', '0', '3', '0', '0.257142857', '0', '0', '46.5', '3', '1.75', '1']
package org . apache . log4j . net ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; class SyslogTracerPrintWriter extends TracerPrintWriter { static String TAB = "    " ; SyslogTracerPrintWriter ( QuietWriter qWriter ) { super ( qWriter ) ; } public void println ( Object o ) { this . qWriter . write ( o . toString ( ) ) ; } public void println ( String s ) { this . qWriter . write ( TAB + s . substring ( 1 ) ) ; } } 	0	['4', '4', '0', '3', '11', '4', '1', '2', '2', '0.666666667', '32', '0', '0', '0.968253968', '0.5', '2', '2', '6.75', '1', '0.5', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char " + c + " at position " + i ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . message ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( System . currentTimeMillis ( ) ) ; return df . format ( date ) ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { event . setLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return event . locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return event . locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return event . locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return event . locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { event . setLocationInformation ( ) ; return event . locationInfo . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	1	['8', '1', '0', '15', '41', '8', '4', '14', '2', '0.956043956', '691', '0.461538462', '3', '0', '0.375', '0', '0', '82.125', '21', '6.25', '1']
package org . apache . log4j . gui ; import java . awt . Color ; import java . awt . Image ; import java . awt . Toolkit ; import java . io . * ; import java . net . URL ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Hashtable ; import javax . swing . Icon ; import javax . swing . ImageIcon ; import javax . swing . JTextPane ; import javax . swing . text . BadLocationException ; import javax . swing . text . MutableAttributeSet ; import javax . swing . text . SimpleAttributeSet ; import javax . swing . text . StyleConstants ; import javax . swing . text . StyledDocument ; import javax . swing . text . TabSet ; import javax . swing . text . TabStop ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . Loader ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . TracerPrintWriter ; import org . apache . log4j . helpers . OptionConverter ; public class TextPaneAppender extends AppenderSkeleton { JTextPane textpane ; StyledDocument doc ; TracerPrintWriter tp ; StringWriter sw ; QuietWriter qw ; Hashtable attributes ; Hashtable icons ; private String label ; private boolean fancy ; final String LABEL_OPTION = "Label" ; final String COLOR_OPTION_FATAL = "Color.Emerg" ; final String COLOR_OPTION_ERROR = "Color.Error" ; final String COLOR_OPTION_WARN = "Color.Warn" ; final String COLOR_OPTION_INFO = "Color.Info" ; final String COLOR_OPTION_DEBUG = "Color.Debug" ; final String COLOR_OPTION_BACKGROUND = "Color.Background" ; final String FANCY_OPTION = "Fancy" ; final String FONT_NAME_OPTION = "Font.Name" ; final String FONT_SIZE_OPTION = "Font.Size" ; public static Image loadIcon ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public TextPaneAppender ( Layout layout , String name ) { this ( ) ; this . layout = layout ; this . name = name ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; } public TextPaneAppender ( ) { super ( ) ; setTextPane ( new JTextPane ( ) ) ; createAttributes ( ) ; createIcons ( ) ; this . label = "" ; this . sw = new StringWriter ( ) ; this . qw = new QuietWriter ( sw , errorHandler ) ; this . tp = new TracerPrintWriter ( qw ) ; this . fancy = true ; } public void close ( ) { } private void createAttributes ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; attributes = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { MutableAttributeSet att = new SimpleAttributeSet ( ) ; attributes . put ( prio [ i ] , att ) ; StyleConstants . setFontSize ( att , 14 ) ; } StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . ERROR ) , Color . red ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . WARN ) , Color . orange ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . INFO ) , Color . gray ) ; StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( Priority . DEBUG ) , Color . black ) ; } private void createIcons ( ) { Priority prio [ ] = Priority . getAllPossiblePriorities ( ) ; icons = new Hashtable ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { if ( prio [ i ] . equals ( Priority . FATAL ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . ERROR ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/RedFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . WARN ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/BlueFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . INFO ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; if ( prio [ i ] . equals ( Priority . DEBUG ) ) icons . put ( prio [ i ] , new ImageIcon ( loadIcon ( "icons/GreenFlag.gif" ) ) ) ; } } public void append ( LoggingEvent event ) { String text = this . layout . format ( event ) ; String trace = "" ; if ( event . throwable != null ) { event . throwable . printStackTrace ( tp ) ; for ( int i = 0 ; i < sw . getBuffer ( ) . length ( ) ; i ++ ) { if ( sw . getBuffer ( ) . charAt ( i ) == '\t' ) sw . getBuffer ( ) . replace ( i , i + 1 , "        " ) ; } trace = sw . toString ( ) ; sw . getBuffer ( ) . delete ( 0 , sw . getBuffer ( ) . length ( ) ) ; } try { if ( fancy ) { textpane . setEditable ( true ) ; textpane . insertIcon ( ( ImageIcon ) icons . get ( event . priority ) ) ; textpane . setEditable ( false ) ; } doc . insertString ( doc . getLength ( ) , text + trace , ( MutableAttributeSet ) attributes . get ( event . priority ) ) ; } catch ( BadLocationException badex ) { System . err . println ( badex ) ; } textpane . setCaretPosition ( doc . getLength ( ) ) ; } public JTextPane getTextPane ( ) { return textpane ; } public String getLabel ( ) { return label ; } public String [ ] getOptionStrings ( ) { return new String [ ] { LABEL_OPTION , COLOR_OPTION_FATAL , COLOR_OPTION_ERROR , COLOR_OPTION_WARN , COLOR_OPTION_INFO , COLOR_OPTION_DEBUG , COLOR_OPTION_BACKGROUND , FANCY_OPTION , FONT_NAME_OPTION , FONT_SIZE_OPTION } ; } private Color parseColor ( String v ) { StringTokenizer st = new StringTokenizer ( v , "," ) ; int val [ ] = { 255 , 255 , 255 , 255 } ; int i = 0 ; while ( st . hasMoreTokens ( ) ) { val [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; i ++ ; } return new Color ( val [ 0 ] , val [ 1 ] , val [ 2 ] , val [ 3 ] ) ; } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setTextPane ( JTextPane textpane ) { this . textpane = textpane ; textpane . setEditable ( false ) ; textpane . setBackground ( Color . lightGray ) ; this . doc = textpane . getStyledDocument ( ) ; } private void setColor ( Priority p , String v ) { StyleConstants . setForeground ( ( MutableAttributeSet ) attributes . get ( p ) , parseColor ( v ) ) ; } private void setFontSize ( int size ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontSize ( ( MutableAttributeSet ) e . nextElement ( ) , size ) ; } return ; } private void setFontName ( String name ) { Enumeration e = attributes . elements ( ) ; while ( e . hasMoreElements ( ) ) { StyleConstants . setFontFamily ( ( MutableAttributeSet ) e . nextElement ( ) , name ) ; } return ; } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( LABEL_OPTION ) ) this . label = value ; if ( option . equalsIgnoreCase ( COLOR_OPTION_FATAL ) ) setColor ( Priority . FATAL , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_ERROR ) ) setColor ( Priority . ERROR , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_WARN ) ) setColor ( Priority . WARN , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_INFO ) ) setColor ( Priority . INFO , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_DEBUG ) ) setColor ( Priority . DEBUG , value ) ; if ( option . equalsIgnoreCase ( COLOR_OPTION_BACKGROUND ) ) textpane . setBackground ( parseColor ( value ) ) ; if ( option . equalsIgnoreCase ( FANCY_OPTION ) ) fancy = OptionConverter . toBoolean ( value , fancy ) ; if ( option . equalsIgnoreCase ( FONT_SIZE_OPTION ) ) setFontSize ( Integer . parseInt ( value ) ) ; if ( option . equalsIgnoreCase ( FONT_NAME_OPTION ) ) setFontName ( value ) ; return ; } public boolean requiresLayout ( ) { return true ; } } 	0	['19', '2', '0', '10', '69', '129', '2', '8', '13', '0.885964912', '675', '0.105263158', '2', '0.514285714', '0.233082707', '1', '3', '33.52631579', '11', '2.1579', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; import java . util . Enumeration ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Logging confFile runLength delay burstLen\n" + "        confFile is a configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . getRoot ( ) . removeAllAppenders ( ) ; System . gc ( ) ; System . gc ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	1	['7', '1', '0', '3', '27', '5', '0', '3', '2', '0.566666667', '196', '0', '1', '0', '0.333333333', '0', '0', '26.28571429', '4', '1.7143', '1']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '0']
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Category ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; static StringBuffer sbuf = new StringBuffer ( ) ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = props . getProperty ( key ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" object." ) ; return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { sbuf . setLength ( 0 ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) return val ; else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = System . getProperty ( key ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) sbuf . append ( replacement ) ; i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url ) { String clazz = url . getRef ( ) ; Configurator configurator = null ; if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { String filename = url . getFile ( ) ; if ( filename != null && filename . endsWith ( ".xml" ) ) { configurator = new DOMConfigurator ( ) ; } else { configurator = new PropertyConfigurator ( ) ; } } configurator . doConfigure ( url , Category . defaultHierarchy ) ; } } 	1	['13', '1', '0', '22', '54', '76', '20', '6', '10', '0.861111111', '537', '0', '0', '0', '0.183333333', '0', '0', '39.84615385', '11', '3', '3']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; } } 	1	['7', '1', '0', '4', '13', '0', '3', '1', '7', '0.366666667', '236', '0', '1', '0', '0.523809524', '0', '0', '32', '6', '2.5714', '1']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final String LOCATION_INFO_OPTION = "LocationInfo" ; static final int BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , aai ) ; dispatcher . start ( ) ; } synchronized public void addAppender ( Appender newAppender ) { aai . addAppender ( newAppender ) ; } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; if ( locationInfo ) { event . setLocationInformation ( ) ; } synchronized ( bf ) { if ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "AsyncAppender cannot be interrupted." , e ) ; } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { closed = true ; dispatcher . interrupt ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { return aai . getAllAppenders ( ) ; } public Appender getAppender ( String name ) { return aai . getAppender ( name ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { LOCATION_INFO_OPTION } ) ; } public boolean requiresLayout ( ) { return false ; } synchronized public void removeAllAppenders ( ) { aai . removeAllAppenders ( ) ; } synchronized public void removeAppender ( Appender appender ) { aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { aai . removeAppender ( name ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; Dispatcher ( BoundedFIFO bf , AppenderAttachableImpl aai ) { this . bf = bf ; this . aai = aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ( ) ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } if ( aai != null ) aai . appendLoopOnAppenders ( event ) ; } } } 	1	['12', '2', '0', '9', '39', '14', '0', '9', '12', '0.863636364', '174', '0', '3', '0.620689655', '0.375', '2', '3', '13', '4', '1.3333', '5']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '0']
package org . apache . log4j . varia ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class PriorityMatchFilter extends Filter { public static final String PRIORITY_TO_MATCH_OPTION = "PriorityToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; Priority priorityToMatch ; public int decide ( LoggingEvent event ) { if ( this . priorityToMatch == null ) { return Filter . NEUTRAL ; } boolean matchOccured = false ; if ( this . priorityToMatch == event . priority ) { matchOccured = true ; } if ( this . acceptOnMatch ^ matchOccured ) { return Filter . DENY ; } else { return Filter . ACCEPT ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { PRIORITY_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( PRIORITY_TO_MATCH_OPTION ) ) { priorityToMatch = Priority . toPriority ( value , null ) ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } } 	1	['4', '2', '0', '4', '8', '0', '0', '4', '4', '0.916666667', '69', '0', '1', '0.571428571', '0.5', '0', '0', '15.25', '4', '2', '1']
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	['8', '2', '0', '0', '10', '28', '0', '0', '8', '2', '21', '0', '0', '0.65', '0.46875', '1', '2', '1.625', '1', '0.875', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . PatternParser ; import org . apache . log4j . helpers . PatternConverter ; import org . apache . log4j . helpers . OptionConverter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . util . Vector ; import java . text . FieldPosition ; public class PatternLayout extends Layout { final static public String CONVERSION_PATTERN_OPTION = "ConversionPattern" ; public final static String DEFAULT_CONVERSION_PATTERN = "%m\n" ; public final static String TTCC_CONVERSION_PATTERN = "%r [%t] %p %c %x - %m%n" ; protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; private PatternConverter head ; private String timezone ; public PatternLayout ( ) { this ( DEFAULT_CONVERSION_PATTERN ) ; } public PatternLayout ( String pattern ) { head = createPatternParser ( ( pattern == null ) ? DEFAULT_CONVERSION_PATTERN : pattern ) . parse ( ) ; } public void activateOptions ( ) { } protected PatternParser createPatternParser ( String pattern ) { return new PatternParser ( pattern ) ; } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } PatternConverter c = head ; while ( c != null ) { c . format ( sbuf , event ) ; c = c . next ; } return sbuf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { CONVERSION_PATTERN_OPTION } ; } public boolean ignoresThrowable ( ) { return true ; } public void setConversionPattern ( String conversionPattern ) { setOption ( CONVERSION_PATTERN_OPTION , conversionPattern ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; if ( option . equalsIgnoreCase ( CONVERSION_PATTERN_OPTION ) ) { head = createPatternParser ( value ) . parse ( ) ; } } } 	1	['9', '2', '0', '13', '18', '30', '9', '4', '8', '0.9375', '114', '0.625', '1', '0.533333333', '0.518518519', '0', '0', '10.77777778', '3', '1.2222', '1']
package org . apache . log4j . xml . test ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . xml . test . TPriority ; public class TCategory extends Category implements OptionHandler { private static TFactory factory = new TFactory ( ) ; static String instanceFQCN = TCategory . class . getName ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix ; public TCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { log ( instanceFQCN , Priority . DEBUG , message + suffix , null ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void setOption ( String option , String value ) { System . out . println ( option + "=" + value ) ; if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; System . out . println ( "Setting suffix to" + suffix ) ; } } public void trace ( String message ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , null ) ) ; } public void trace ( String message , Exception e ) { if ( disable <= TPriority . TRACE_INT ) return ; if ( TPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( instanceFQCN , this , TPriority . TRACE , message , e ) ) ; } private static class TFactory implements CategoryFactory { TFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new TCategory ( name ) ; } } } 	0	['10', '2', '0', '7', '27', '29', '1', '7', '8', '0.911111111', '145', '0.2', '1', '0.854545455', '0.555555556', '1', '3', '13', '3', '1.4', '0']
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { if ( file . exists ( ) ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ( ) ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	1	['5', '2', '2', '5', '17', '2', '4', '1', '2', '0.625', '95', '0.333333333', '0', '0.938461538', '0.466666667', '1', '1', '16.8', '3', '1.4', '2']
package org . apache . log4j . xml . examples ; import org . apache . log4j . Priority ; public class XPriority extends Priority { static final int TRACE_INT = 800 ; static final int FATAL_INT = 1 ; static final int SYSLOG_FATAL_INT = 0 ; static final int SYSLOG_TRACE_INT = 7 ; public static final XPriority TRACE = new XPriority ( TRACE_INT , "TRACE" , 7 ) ; public static final XPriority FATAL = new XPriority ( FATAL_INT , "FATAL" , FATAL_INT ) ; protected XPriority ( int level , String strLevel , int syslogEquiv ) { super ( level , strLevel , syslogEquiv ) ; } public static Priority toPriority ( String sArg ) { if ( sArg == null ) return XPriority . TRACE ; String stringVal = sArg . toUpperCase ( ) ; if ( stringVal . equals ( "TRACE" ) ) return XPriority . TRACE ; if ( stringVal . equals ( "FATAL" ) ) return XPriority . FATAL ; return Priority . toPriority ( sArg ) ; } public static Priority toPriority ( int i ) throws IllegalArgumentException { switch ( i ) { case TRACE_INT : return XPriority . TRACE ; case FATAL_INT : return XPriority . FATAL ; } return Priority . toPriority ( i ) ; } } 	0	['4', '2', '0', '2', '9', '0', '1', '1', '2', '1', '62', '0', '2', '0.8', '0.555555556', '1', '1', '13', '4', '1.75', '0']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; public class Hierarchy { static private CategoryFactory defaultFactory = new DefaultCategoryFactory ( ) ; Hashtable ht ; Category root ; RendererMap rendererMap ; public Hierarchy ( Category root ) { ht = new Hashtable ( ) ; this . root = root ; this . root . myContext = this ; rendererMap = new RendererMap ( ) ; } public void addRenderer ( Class classToRender , ObjectRenderer or ) { rendererMap . put ( classToRender , or ) ; } public void clear ( ) { ht . clear ( ) ; } public Category exists ( String name ) { Object o = ht . get ( new CategoryKey ( name ) ) ; if ( o instanceof Category ) { return ( Category ) o ; } else { return null ; } } public Category getInstance ( String name ) { return getInstance ( name , defaultFactory ) ; } public Category getInstance ( String name , CategoryFactory factory ) { CategoryKey key = new CategoryKey ( name ) ; Category category ; synchronized ( ht ) { Object o = ht . get ( key ) ; if ( o == null ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateParents ( category ) ; return category ; } else if ( o instanceof Category ) { return ( Category ) o ; } else if ( o instanceof ProvisionNode ) { category = factory . makeNewCategoryInstance ( name ) ; ht . put ( key , category ) ; updateChildren ( ( ProvisionNode ) o , category ) ; updateParents ( category ) ; return category ; } else { return null ; } } } public RendererMap getRendererMap ( ) { return rendererMap ; } public Category getRoot ( ) { return root ; } final private void updateParents ( Category cat ) { String name = cat . name ; int length = name . length ( ) ; boolean parentFound = false ; for ( int i = name . lastIndexOf ( '.' , length - 1 ) ; i >= 0 ; i = name . lastIndexOf ( '.' , i - 1 ) ) { String substr = name . substring ( 0 , i ) ; CategoryKey key = new CategoryKey ( substr ) ; Object o = ht . get ( key ) ; if ( o == null ) { ProvisionNode pn = new ProvisionNode ( cat ) ; ht . put ( key , pn ) ; } else if ( o instanceof Category ) { parentFound = true ; cat . parent = ( Category ) o ; break ; } else if ( o instanceof ProvisionNode ) { ( ( ProvisionNode ) o ) . addElement ( cat ) ; } else { Exception e = new IllegalStateException ( "unexpected object type " + o . getClass ( ) + " in ht." ) ; e . printStackTrace ( ) ; } } if ( ! parentFound ) cat . parent = root ; } final private void updateChildren ( ProvisionNode pn , Category cat ) { final int last = pn . size ( ) ; childLoop : for ( int i = 0 ; i < last ; i ++ ) { Category c = ( Category ) pn . elementAt ( i ) ; if ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { continue childLoop ; } while ( c . parent != null && c . parent . name . startsWith ( cat . name ) ) { c = c . parent ; } cat . parent = c . parent ; c . parent = cat ; } } public void shutdown ( ) { Category root = getRoot ( ) ; root . closeNestedAppenders ( ) ; synchronized ( ht ) { Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . closeNestedAppenders ( ) ; } root . removeAllAppenders ( ) ; cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . removeAllAppenders ( ) ; } } } } 	1	['12', '1', '0', '21', '43', '24', '15', '7', '9', '0.704545455', '346', '0.25', '3', '0', '0.272727273', '0', '0', '27.5', '6', '2.1667', '2']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new FileAppender ( layout , System . out ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . util . Enumeration ; public class Shallow { static Category cat = Category . getInstance ( Shallow . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Shallow . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; NDC . push ( "NDC" ) ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; root . debug ( "Message " + i ) ; cat . info ( "Message " + ++ i ) ; root . info ( "Message " + i ) ; cat . warn ( "Message " + ++ i ) ; root . warn ( "Message " + i ) ; cat . error ( "Message " + ++ i ) ; root . error ( "Message " + i ) ; cat . log ( Priority . FATAL , "Message " + ++ i ) ; root . log ( Priority . FATAL , "Message " + i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; root . debug ( "Message " + i , e ) ; cat . info ( "Message " + ++ i , e ) ; root . info ( "Message " + i , e ) ; cat . warn ( "Message " + ++ i , e ) ; root . warn ( "Message " + i , e ) ; cat . error ( "Message " + ++ i , e ) ; root . error ( "Message " + i , e ) ; cat . log ( Priority . FATAL , "Message " + ++ i , e ) ; root . log ( Priority . FATAL , "Message " + i , e ) ; Category . shutdown ( ) ; System . gc ( ) ; } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	['8', '1', '0', '4', '38', '24', '0', '4', '2', '0.714285714', '322', '0', '1', '0', '0.214285714', '0', '0', '39', '2', '1', '1']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import java . io . IOException ; import java . io . InputStreamReader ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	0	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . xml . examples . XPriority ; public class XCategory extends Category implements OptionHandler { final private static String FQCN = XCategory . class . getName ( ) ; private static XFactory factory = new XFactory ( ) ; public static final String SUFFIX_OPTION = "Suffix" ; String suffix = "" ; protected XCategory ( String name ) { super ( name ) ; } public void activateOptions ( ) { } public void debug ( String message ) { super . debug ( message + " " + suffix ) ; } public static Category getInstance ( String name ) { return Category . getInstance ( name , factory ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) , factory ) ; } public String [ ] getOptionStrings ( ) { return ( new String [ ] { SUFFIX_OPTION } ) ; } public void lethal ( String message , Throwable t ) { if ( hierarchy . isDisabled ( XPriority . LETHAL_INT ) ) return ; if ( XPriority . LETHAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . LETHAL , message , t ) ; } public void lethal ( String message ) { if ( hierarchy . isDisabled ( XPriority . LETHAL_INT ) ) return ; if ( XPriority . LETHAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . LETHAL , message , null ) ; } public void setOption ( String option , String value ) { if ( option == null ) { return ; } if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { this . suffix = value ; LogLog . debug ( "Setting suffix to" + suffix ) ; } } public String getOption ( String option ) { if ( option . equalsIgnoreCase ( SUFFIX_OPTION ) ) { return this . suffix ; } return null ; } public void trace ( String message , Throwable t ) { if ( hierarchy . isDisabled ( XPriority . TRACE_INT ) ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , XPriority . TRACE , message , t ) ; } public void trace ( String message ) { if ( hierarchy . isDisabled ( XPriority . TRACE_INT ) ) return ; if ( XPriority . TRACE . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) callAppenders ( new LoggingEvent ( FQCN , this , XPriority . TRACE , message , null ) ) ; } public static class XFactory implements CategoryFactory { public XFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new XCategory ( name ) ; } } } 	1	['14', '2', '0', '9', '33', '53', '1', '9', '11', '0.876923077', '188', '0.4', '1', '0.796610169', '0.442307692', '1', '3', '12.07142857', '3', '1.6429', '1']
package org . apache . log4j . varia ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class StringMatchFilter extends Filter { public static final String STRING_TO_MATCH_OPTION = "StringToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; String stringToMatch ; public int decide ( LoggingEvent event ) { if ( event . message == null || stringToMatch == null ) return Filter . NEUTRAL ; if ( event . message instanceof String ) { String msg = ( String ) event . message ; if ( msg . indexOf ( stringToMatch ) == - 1 ) { return Filter . NEUTRAL ; } else { if ( acceptOnMatch ) { return Filter . ACCEPT ; } else { return Filter . DENY ; } } } else { return Filter . NEUTRAL ; } } public String [ ] getOptionStrings ( ) { return new String [ ] { STRING_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( STRING_TO_MATCH_OPTION ) ) { stringToMatch = value ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } } 	0	['4', '2', '0', '3', '8', '0', '0', '3', '4', '0.916666667', '76', '0', '0', '0.571428571', '0.5', '0', '0', '17', '6', '2.5', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . RelativeTimeDateFormat ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . helpers . DateTimeDateFormat ; import org . apache . log4j . helpers . ISO8601DateFormat ; import org . apache . log4j . spi . LoggingEvent ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . text . FieldPosition ; abstract public class DateLayout extends Layout { public final static String NULL_DATE_FORMAT = "NULL" ; public final static String RELATIVE_TIME_DATE_FORMAT = "RELATIVE" ; protected FieldPosition pos = new FieldPosition ( 0 ) ; final static public String DATE_FORMAT_OPTION = "DateFormat" ; final static public String TIMEZONE_OPTION = "TimeZone" ; private String timeZoneID ; private String dateFormatOption ; protected DateFormat dateFormat ; protected Date date = new Date ( ) ; public String [ ] getOptionStrings ( ) { return new String [ ] { DATE_FORMAT_OPTION , TIMEZONE_OPTION } ; } public void setOption ( String option , String value ) { if ( option . equalsIgnoreCase ( DATE_FORMAT_OPTION ) ) { dateFormatOption = value . toUpperCase ( ) ; } else if ( option . equalsIgnoreCase ( TIMEZONE_OPTION ) ) { timeZoneID = value ; } } public void setDateFormat ( String dateFormat ) { if ( dateFormat != null ) { dateFormatOption = dateFormat . toUpperCase ( ) ; } setDateFormat ( dateFormatOption , TimeZone . getDefault ( ) ) ; } public String getDateFormat ( ) { return dateFormatOption ; } public void setTimeZone ( String timeZone ) { this . timeZoneID = timeZone ; } public String getTimeZone ( ) { return timeZoneID ; } public void activateOptions ( ) { setDateFormat ( dateFormatOption ) ; if ( timeZoneID != null && dateFormat != null ) { dateFormat . setTimeZone ( TimeZone . getTimeZone ( timeZoneID ) ) ; } } public void dateFormat ( StringBuffer buf , LoggingEvent event ) { if ( dateFormat != null ) { date . setTime ( event . timeStamp ) ; dateFormat . format ( date , buf , this . pos ) ; buf . append ( ' ' ) ; } } public void setDateFormat ( DateFormat dateFormat , TimeZone timeZone ) { this . dateFormat = dateFormat ; this . dateFormat . setTimeZone ( timeZone ) ; } public void setDateFormat ( String dateFormatType , TimeZone timeZone ) { if ( dateFormatType == null ) { this . dateFormat = null ; return ; } if ( dateFormatType . equalsIgnoreCase ( NULL_DATE_FORMAT ) ) { this . dateFormat = null ; } else if ( dateFormatType . equalsIgnoreCase ( RELATIVE_TIME_DATE_FORMAT ) ) { this . dateFormat = new RelativeTimeDateFormat ( ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) { this . dateFormat = new AbsoluteTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) { this . dateFormat = new DateTimeDateFormat ( timeZone ) ; } else if ( dateFormatType . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) { this . dateFormat = new ISO8601DateFormat ( timeZone ) ; } else { this . dateFormat = new SimpleDateFormat ( dateFormatType ) ; this . dateFormat . setTimeZone ( timeZone ) ; } } } 	1	['11', '2', '0', '6', '27', '19', '0', '6', '11', '0.911111111', '199', '0.555555556', '0', '0.444444444', '0.303030303', '0', '0', '16.27272727', '7', '2', '1']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '0']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import java . util . Random ; class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { LENGTH = args . length ; if ( LENGTH == 0 ) { System . err . println ( "Usage: java " + StressCategory . class . getName ( ) + " name1 ... nameN\n." ) ; System . exit ( 1 ) ; } if ( LENGTH >= 7 ) { System . err . println ( "This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines" ) ; } names = new String [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { names [ i ] = args [ i ] ; } cat = new Category [ LENGTH ] ; ct = new CT [ LENGTH ] ; permute ( 0 ) ; } static void permute ( int n ) { if ( n == LENGTH ) createLoop ( 0 ) ; else for ( int i = n ; i < LENGTH ; i ++ ) { swap ( names , n , i ) ; permute ( n + 1 ) ; swap ( names , n , i ) ; } } static void swap ( String [ ] names , int i , int j ) { String t = names [ i ] ; names [ i ] = names [ j ] ; names [ j ] = t ; } public static void permutationDump ( ) { System . out . print ( "Current permutation is - " ) ; for ( int i = 0 ; i < LENGTH ; i ++ ) { System . out . print ( names [ i ] + " " ) ; } System . out . println ( ) ; } static void createLoop ( int n ) { if ( n == LENGTH ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ct [ i ] == null ) cat [ i ] = null ; else { cat [ i ] = Category . getInstance ( ct [ i ] . catstr ) ; cat [ i ] . setPriority ( ct [ i ] . priority ) ; } } test ( ) ; Category . defaultHierarchy . clear ( ) ; } else { ct [ n ] = null ; createLoop ( n + 1 ) ; ct [ n ] = new CT ( names [ n ] , null ) ; createLoop ( n + 1 ) ; int r = random . nextInt ( ) ; if ( r < 0 ) r = - r ; ct [ n ] = new CT ( names [ n ] , priority [ r % 5 ] ) ; createLoop ( n + 1 ) ; } } static void test ( ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ! checkCorrectness ( i ) ) { System . out . println ( "Failed stress test." ) ; permutationDump ( ) ; ctDump ( ) ; catDump ( ) ; System . exit ( 1 ) ; } } } static void ctDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null ) System . out . println ( "ct [" + j + "] = (" + ct [ j ] . catstr + "," + ct [ j ] . priority + ")" ) ; else System . out . println ( "ct [" + j + "] = undefined" ) ; } } static void catDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( cat [ j ] != null ) System . out . println ( "cat[" + j + "] = (" + cat [ j ] . name + "," + cat [ j ] . getPriority ( ) + ")" ) ; else System . out . println ( "cat[" + j + "] = undefined" ) ; } } static boolean checkCorrectness ( int i ) { CT localCT = ct [ i ] ; if ( localCT == null ) return true ; Priority expected = getExpectedPrioriy ( localCT ) ; Priority purported = cat [ i ] . getChainedPriority ( ) ; if ( expected != purported ) { System . out . println ( "Expected priority for " + localCT . catstr + " is " + expected ) ; System . out . println ( "Purported priority for " + cat [ i ] . name + " is " + purported ) ; return false ; } return true ; } static Priority getExpectedPrioriy ( CT ctParam ) { Priority priority = ctParam . priority ; if ( priority != null ) return priority ; String catstr = ctParam . catstr ; for ( int i = catstr . lastIndexOf ( '.' , catstr . length ( ) - 1 ) ; i >= 0 ; i = catstr . lastIndexOf ( '.' , i - 1 ) ) { String substr = catstr . substring ( 0 , i ) ; for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null && substr . equals ( ct [ j ] . catstr ) ) { Priority p = ct [ j ] . priority ; if ( p != null ) return p ; } } } return defaultPriority ; } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { this . catstr = catstr ; this . priority = priority ; } } } 	1	['13', '1', '0', '4', '40', '8', '0', '4', '2', '0.697916667', '516', '0', '4', '0', '0.15', '0', '0', '38.07692308', '7', '2.7692', '2']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['6', '1', '5', '9', '10', '7', '7', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Hierarchy ; import java . net . URL ; public interface Configurator { void doConfigure ( URL url , Hierarchy hierarchy ) ; } 	1	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . log4j . xml . examples ; import org . apache . log4j . helpers . LogLog ; public class ReportParserError implements org . xml . sax . ErrorHandler { void report ( String msg , org . xml . sax . SAXParseException e ) { LogLog . error ( msg + e . getMessage ( ) + "\n\tat line=" + e . getLineNumber ( ) + " col=" + e . getColumnNumber ( ) + " of " + "SystemId=\"" + e . getSystemId ( ) + "\" PublicID = \"" + e . getPublicId ( ) + '\"' ) ; } public void warning ( org . xml . sax . SAXParseException e ) { report ( "WARNING: " , e ) ; } public void error ( org . xml . sax . SAXParseException e ) { report ( "ERROR: " , e ) ; } public void fatalError ( org . xml . sax . SAXParseException e ) { report ( "FATAL: " , e ) ; } } 	0	['5', '1', '0', '1', '17', '10', '0', '1', '4', '2', '58', '0', '0', '0', '0.666666667', '0', '0', '10.6', '1', '0.8', '0']
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; public static final String SOURCE_OPTION = "Source" ; private String source = null ; private String server = null ; private static final int FATAL = Priority . FATAL . toInt ( ) ; private static final int ERROR = Priority . ERROR . toInt ( ) ; private static final int WARN = Priority . WARN . toInt ( ) ; private static final int INFO = Priority . INFO . toInt ( ) ; private static final int DEBUG = Priority . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SOURCE_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( SOURCE_OPTION ) ) { source = value . trim ( ) ; } } public void close ( ) { } public void activateOptions ( ) { if ( source != null ) { try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { LogLog . error ( "Could not register event source." , e ) ; _handle = 0 ; } } } public void append ( LoggingEvent event ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( s [ 0 ] ) ; } } } int nt_category = event . priority . toInt ( ) ; reportEvent ( _handle , sbuf . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public void setSource ( String source ) { this . source = source . trim ( ) ; } public String getSource ( ) { return source ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int priority ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	['19', '2', '0', '8', '36', '141', '1', '7', '15', '0.864197531', '229', '0.888888889', '0', '0.6', '0.355555556', '1', '1', '10.57894737', '4', '0.9474', '1']
package org . apache . log4j . varia ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; public class DenyAllFilter extends Filter { public int decide ( LoggingEvent event ) { return Filter . DENY ; } public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } } 	0	['4', '2', '0', '2', '5', '6', '0', '2', '4', '2', '12', '0', '0', '0.571428571', '0.5', '0', '0', '2', '1', '0.75', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } ConsoleAppender appender = new ConsoleAppender ( new SimpleLayout ( ) ) ; if ( "false" . equals ( args [ 0 ] ) ) ; else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; Category . getDefaultHierarchy ( ) . disableInfo ( ) ; } else Usage ( ) ; SHORT_CAT . setPriority ( Priority . INFO ) ; Category . getRoot ( ) . setPriority ( Priority . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	1	['8', '1', '0', '6', '31', '22', '0', '6', '2', '0.942857143', '324', '0', '7', '0', '0.285714286', '0', '0', '38.25', '5', '2', '1']
package org . apache . log4j . test ; import org . apache . log4j . * ; import org . apache . log4j . gui . TextPaneAppender ; import javax . swing . JFrame ; import javax . swing . JTextPane ; import java . awt . Dimension ; public class TP { static Category cat = Category . getInstance ( TP . class . getName ( ) ) ; public static void main ( String argv [ ] ) { JFrame frame = new JFrame ( "asdasd" ) ; Category root = Category . getRoot ( ) ; PatternLayout layout = new PatternLayout ( "%p [%t] $c{2} %m\n" ) ; TextPaneAppender ap = new TextPaneAppender ( layout , "c" ) ; JTextPane textPane = ap . getTextPane ( ) ; textPane . setPreferredSize ( new Dimension ( 200 , 200 ) ) ; frame . getContentPane ( ) . add ( textPane ) ; frame . pack ( ) ; ap . getTextPane ( ) . setVisible ( true ) ; frame . setVisible ( true ) ; root . addAppender ( ap ) ; cat . debug ( "Message 1." ) ; cat . debug ( "Message 2." ) ; } } 	0	['4', '1', '0', '5', '24', '4', '0', '5', '2', '0.833333333', '83', '0', '1', '0', '0.333333333', '0', '0', '19.25', '1', '0.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . util . Enumeration ; public class Shallow { static Category cat = Category . getInstance ( Shallow . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Shallow . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( ".xml" ) ) DOMConfigurator . configure ( configFile ) ; else PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; NDC . push ( "NDC" ) ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; root . debug ( "Message " + i ) ; cat . info ( "Message " + ++ i ) ; root . info ( "Message " + i ) ; cat . warn ( "Message " + ++ i ) ; root . warn ( "Message " + i ) ; cat . error ( "Message " + ++ i ) ; root . error ( "Message " + i ) ; cat . log ( Priority . FATAL , "Message " + ++ i ) ; root . log ( Priority . FATAL , "Message " + i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; root . debug ( "Message " + i , e ) ; cat . info ( "Message " + ++ i , e ) ; root . info ( "Message " + i , e ) ; cat . warn ( "Message " + ++ i , e ) ; root . warn ( "Message " + i , e ) ; cat . error ( "Message " + ++ i , e ) ; root . error ( "Message " + i , e ) ; cat . log ( Priority . FATAL , "Message " + ++ i , e ) ; root . log ( Priority . FATAL , "Message " + i , e ) ; Category . shutdown ( ) ; } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	['8', '1', '0', '5', '39', '24', '0', '5', '2', '0.714285714', '328', '0', '1', '0', '0.214285714', '0', '0', '39.75', '2', '1.125', '1']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; import java . io . InputStreamReader ; public class SocketMin { static Category cat = Category . getInstance ( SyslogMin . class . getName ( ) ) ; static SocketAppender s ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; if ( argv [ 2 ] . equals ( "true" ) ) loop ( ) ; else test ( ) ; s . close ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketMin . class + " host port true|false" ) ; System . exit ( 1 ) ; } static void init ( String host , String portStr ) { Category root = Category . getRoot ( ) ; BasicConfigurator . configure ( ) ; try { int port = Integer . parseInt ( portStr ) ; cat . info ( "Creating socket appender (" + host + "," + port + ")." ) ; s = new SocketAppender ( host , port ) ; s . setName ( "S" ) ; root . addAppender ( s ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } catch ( Exception e ) { System . err . println ( "Could not start!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } static void loop ( ) { Category root = Category . getRoot ( ) ; InputStreamReader in = new InputStreamReader ( System . in ) ; System . out . println ( "Type 'q' to quit" ) ; int i ; int k = 0 ; while ( true ) { cat . debug ( "Message " + k ++ ) ; cat . info ( "Message " + k ++ ) ; cat . warn ( "Message " + k ++ ) ; cat . error ( "Message " + k ++ , new Exception ( "Just testing" ) ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } if ( i == - 1 ) break ; if ( i == 'q' ) break ; if ( i == 'r' ) { System . out . println ( "Removing appender S" ) ; root . removeAppender ( "S" ) ; } } } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['8', '1', '0', '7', '42', '14', '0', '7', '2', '0.75', '308', '0', '2', '0', '0.238095238', '0', '0', '37', '4', '1.5', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . DefaultCategoryFactory ; import org . apache . log4j . config . PropertySetter ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . FileWatchdog ; import java . util . NoSuchElementException ; import java . util . Enumeration ; import java . util . Properties ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . StringTokenizer ; import java . util . Hashtable ; public class PropertyConfigurator extends BasicConfigurator implements Configurator { protected Hashtable registry = new Hashtable ( 11 ) ; protected CategoryFactory categoryFactory = new DefaultCategoryFactory ( ) ; static final String CATEGORY_PREFIX = "log4j.category." ; static final String ADDITIVITY_PREFIX = "log4j.additivity." ; static final String ROOT_CATEGORY_PREFIX = "log4j.rootCategory" ; static final String APPENDER_PREFIX = "log4j.appender." ; static final String RENDERER_PREFIX = "log4j.renderer." ; static final String CATEGORY_FACTORY_KEY = "log4j.categoryFactory" ; static final private String INTERNAL_ROOT_NAME = "root" ; public void doConfigure ( String configFileName , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; try { FileInputStream istream = new FileInputStream ( configFileName ) ; props . load ( istream ) ; istream . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not read configuration file [" + configFileName + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configFileName + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } static public void configure ( String configFilename ) { new PropertyConfigurator ( ) . doConfigure ( configFilename , Category . defaultHierarchy ) ; } public static void configure ( java . net . URL configURL ) { new PropertyConfigurator ( ) . doConfigure ( configURL , Category . defaultHierarchy ) ; } static public void configure ( Properties properties ) { new PropertyConfigurator ( ) . doConfigure ( properties , Category . defaultHierarchy ) ; } static public void configureAndWatch ( String configFilename ) { configureAndWatch ( configFilename , FileWatchdog . DEFAULT_DELAY ) ; } static public void configureAndWatch ( String configFilename , long delay ) { PropertyWatchdog pdog = new PropertyWatchdog ( configFilename ) ; pdog . setDelay ( delay ) ; pdog . start ( ) ; } public void doConfigure ( Properties properties , Hierarchy hierarchy ) { String value = properties . getProperty ( LogLog . DEBUG_KEY ) ; if ( value == null ) { value = properties . getProperty ( LogLog . CONFIG_DEBUG_KEY ) ; if ( value != null ) LogLog . warn ( "[log4j.configDebug] is deprecated. Use [log4j.debug] instead." ) ; } if ( value != null ) { LogLog . setInternalDebugging ( OptionConverter . toBoolean ( value , true ) ) ; } String override = properties . getProperty ( BasicConfigurator . DISABLE_OVERRIDE_KEY ) ; hierarchy . overrideAsNeeded ( override ) ; if ( override == null ) { String disableStr = properties . getProperty ( BasicConfigurator . DISABLE_KEY ) ; if ( disableStr != null ) hierarchy . disable ( disableStr ) ; } configureRootCategory ( properties , hierarchy ) ; configureCategoryFactory ( properties ) ; parseCatsAndRenderers ( properties , hierarchy ) ; LogLog . debug ( "Finished configuring." ) ; registry . clear ( ) ; } public void doConfigure ( java . net . URL configURL , Hierarchy hierarchy ) { Properties props = new Properties ( ) ; LogLog . debug ( "Reading configuration from URL " + configURL ) ; try { props . load ( configURL . openStream ( ) ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not read configuration file from URL [" + configURL + "]." , e ) ; LogLog . error ( "Ignoring configuration file [" + configURL + "]." ) ; return ; } doConfigure ( props , hierarchy ) ; } void configureCategoryFactory ( Properties props ) { String factoryClassName = OptionConverter . findAndSubst ( CATEGORY_FACTORY_KEY , props ) ; if ( factoryClassName != null ) { LogLog . debug ( "Setting category factory to [" + factoryClassName + "]." ) ; categoryFactory = ( CategoryFactory ) OptionConverter . instantiateByClassName ( factoryClassName , CategoryFactory . class , categoryFactory ) ; } } void configureRootCategory ( Properties props , Hierarchy hierarchy ) { String value = OptionConverter . findAndSubst ( ROOT_CATEGORY_PREFIX , props ) ; if ( value == null ) LogLog . debug ( "Could not find root category information. Is this OK?" ) ; else { Category root = hierarchy . getRoot ( ) ; synchronized ( root ) { parseCategory ( props , root , ROOT_CATEGORY_PREFIX , INTERNAL_ROOT_NAME , value ) ; } } } protected void parseCatsAndRenderers ( Properties props , Hierarchy hierarchy ) { Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; if ( key . startsWith ( CATEGORY_PREFIX ) ) { String categoryName = key . substring ( CATEGORY_PREFIX . length ( ) ) ; String value = OptionConverter . findAndSubst ( key , props ) ; Category cat = hierarchy . getInstance ( categoryName , categoryFactory ) ; synchronized ( cat ) { parseCategory ( props , cat , key , categoryName , value ) ; parseAdditivityForCategory ( props , cat , categoryName ) ; } } else if ( key . startsWith ( RENDERER_PREFIX ) ) { String renderedClass = key . substring ( RENDERER_PREFIX . length ( ) ) ; String renderingClass = OptionConverter . findAndSubst ( key , props ) ; addRenderer ( hierarchy , renderedClass , renderingClass ) ; } } } void parseAdditivityForCategory ( Properties props , Category cat , String categoryName ) { String value = OptionConverter . findAndSubst ( ADDITIVITY_PREFIX + categoryName , props ) ; LogLog . debug ( "Handling " + ADDITIVITY_PREFIX + categoryName + "=[" + value + "]" ) ; if ( ( value != null ) && ( ! value . equals ( "" ) ) ) { boolean additivity = OptionConverter . toBoolean ( value , true ) ; LogLog . debug ( "Setting additivity for \"" + categoryName + "\" to " + additivity ) ; cat . setAdditivity ( additivity ) ; } } void parseCategory ( Properties props , Category cat , String optionKey , String catName , String value ) { LogLog . debug ( "Parsing for [" + catName + "] with value=[" + value + "]." ) ; StringTokenizer st = new StringTokenizer ( value , "," ) ; if ( ! ( value . startsWith ( "," ) || value . equals ( "" ) ) ) { if ( ! st . hasMoreTokens ( ) ) return ; String priorityStr = st . nextToken ( ) ; LogLog . debug ( "Priority token is [" + priorityStr + "]." ) ; if ( priorityStr . equalsIgnoreCase ( BasicConfigurator . INHERITED ) && ! catName . equals ( INTERNAL_ROOT_NAME ) ) cat . setPriority ( null ) ; else cat . setPriority ( Priority . toPriority ( priorityStr ) ) ; LogLog . debug ( "Category " + catName + " set to " + cat . getPriority ( ) ) ; } cat . removeAllAppenders ( ) ; Appender appender ; String appenderName ; while ( st . hasMoreTokens ( ) ) { appenderName = st . nextToken ( ) . trim ( ) ; if ( appenderName == null || appenderName . equals ( "," ) ) continue ; LogLog . debug ( "Parsing appender named \"" + appenderName + "\"." ) ; appender = parseAppender ( props , appenderName ) ; if ( appender != null ) { cat . addAppender ( appender ) ; } } } Appender parseAppender ( Properties props , String appenderName ) { Appender appender = registryGet ( appenderName ) ; if ( ( appender != null ) ) { LogLog . debug ( "Appender \"" + appenderName + "\" was already parsed." ) ; return appender ; } String prefix = APPENDER_PREFIX + appenderName ; String layoutPrefix = prefix + ".layout" ; appender = ( Appender ) OptionConverter . instantiateByKey ( props , prefix , org . apache . log4j . Appender . class , null ) ; if ( appender == null ) { LogLog . error ( "Could not instantiate appender named \"" + appenderName + "\"." ) ; return null ; } appender . setName ( appenderName ) ; if ( appender instanceof OptionHandler ) { if ( appender . requiresLayout ( ) ) { Layout layout = ( Layout ) OptionConverter . instantiateByKey ( props , layoutPrefix , Layout . class , null ) ; if ( layout != null ) { appender . setLayout ( layout ) ; LogLog . debug ( "Parsing layout options for \"" + appenderName + "\"." ) ; PropertySetter . setProperties ( layout , props , layoutPrefix + "." ) ; LogLog . debug ( "End of parsing for \"" + appenderName + "\"." ) ; } } PropertySetter . setProperties ( appender , props , prefix + "." ) ; LogLog . debug ( "Parsed \"" + appenderName + "\" options." ) ; } registryPut ( appender ) ; return appender ; } void registryPut ( Appender appender ) { registry . put ( appender . getName ( ) , appender ) ; } Appender registryGet ( String name ) { return ( Appender ) registry . get ( name ) ; } } class PropertyWatchdog extends FileWatchdog { PropertyWatchdog ( String filename ) { super ( filename ) ; } public void doOnChange ( ) { new PropertyConfigurator ( ) . doConfigure ( filename , Category . defaultHierarchy ) ; } } 	1	['18', '2', '0', '28', '78', '135', '14', '15', '9', '0.93627451', '714', '0.25', '1', '0.413793103', '0.277777778', '1', '1', '38', '10', '2.5', '6']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; public final static int FATAL_INT = 50000 ; public final static int ERROR_INT = 40000 ; public final static int WARN_INT = 30000 ; public final static int INFO_INT = 20000 ; public final static int DEBUG_INT = 10000 ; final static public Priority FATAL = new Priority ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Priority ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Priority ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Priority ( INFO_INT , "INFO" , 6 ) ; final static public Priority DEBUG = new Priority ( DEBUG_INT , "DEBUG" , 7 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Priority . WARN , Priority . INFO , Priority . DEBUG } ; } public static Priority toPriority ( String sArg ) { return toPriority ( sArg , Priority . DEBUG ) ; } public static Priority toPriority ( int val ) { return toPriority ( val , Priority . DEBUG ) ; } public static Priority toPriority ( int val , Priority defaultPriority ) { switch ( val ) { case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case FATAL_INT : return FATAL ; default : return defaultPriority ; } } public static Priority toPriority ( String sArg , Priority defaultPriority ) { if ( sArg == null ) return defaultPriority ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "DEBUG" ) ) return Priority . DEBUG ; if ( s . equals ( "INFO" ) ) return Priority . INFO ; if ( s . equals ( "WARN" ) ) return Priority . WARN ; if ( s . equals ( "ERROR" ) ) return Priority . ERROR ; if ( s . equals ( "FATAL" ) ) return Priority . FATAL ; return defaultPriority ; } } 	1	['11', '1', '0', '31', '14', '15', '31', '0', '9', '0.792307692', '174', '0', '5', '0', '0.35', '0', '0', '13.63636364', '7', '2', '5']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import java . util . Random ; class StressCategory { static Priority [ ] priority = new Priority [ ] { Priority . DEBUG , Priority . INFO , Priority . WARN , Priority . ERROR , Priority . FATAL } ; static Priority defaultPriority = Category . getRoot ( ) . getPriority ( ) ; static int LENGTH ; static String [ ] names ; static Category [ ] cat ; static CT [ ] ct ; static Random random = new Random ( 10 ) ; public static void main ( String [ ] args ) { LENGTH = args . length ; if ( LENGTH == 0 ) { System . err . println ( "Usage: java " + StressCategory . class . getName ( ) + " name1 ... nameN\n." ) ; System . exit ( 1 ) ; } if ( LENGTH >= 7 ) { System . err . println ( "This stress test suffers from combinatorial explosion.\n" + "Invoking with seven arguments takes about 90 minutes even on fast machines" ) ; } names = new String [ LENGTH ] ; for ( int i = 0 ; i < LENGTH ; i ++ ) { names [ i ] = args [ i ] ; } cat = new Category [ LENGTH ] ; ct = new CT [ LENGTH ] ; permute ( 0 ) ; } static void permute ( int n ) { if ( n == LENGTH ) createLoop ( 0 ) ; else for ( int i = n ; i < LENGTH ; i ++ ) { swap ( names , n , i ) ; permute ( n + 1 ) ; swap ( names , n , i ) ; } } static void swap ( String [ ] names , int i , int j ) { String t = names [ i ] ; names [ i ] = names [ j ] ; names [ j ] = t ; } public static void permutationDump ( ) { System . out . print ( "Current permutation is - " ) ; for ( int i = 0 ; i < LENGTH ; i ++ ) { System . out . print ( names [ i ] + " " ) ; } System . out . println ( ) ; } static void createLoop ( int n ) { if ( n == LENGTH ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ct [ i ] == null ) cat [ i ] = null ; else { cat [ i ] = Category . getInstance ( ct [ i ] . catstr ) ; cat [ i ] . setPriority ( ct [ i ] . priority ) ; } } test ( ) ; Category . defaultHierarchy . clear ( ) ; } else { ct [ n ] = null ; createLoop ( n + 1 ) ; ct [ n ] = new CT ( names [ n ] , null ) ; createLoop ( n + 1 ) ; int r = random . nextInt ( ) ; if ( r < 0 ) r = - r ; ct [ n ] = new CT ( names [ n ] , priority [ r % 5 ] ) ; createLoop ( n + 1 ) ; } } static void test ( ) { for ( int i = 0 ; i < LENGTH ; i ++ ) { if ( ! checkCorrectness ( i ) ) { System . out . println ( "Failed stress test." ) ; permutationDump ( ) ; ctDump ( ) ; catDump ( ) ; System . exit ( 1 ) ; } } } static void ctDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null ) System . out . println ( "ct [" + j + "] = (" + ct [ j ] . catstr + "," + ct [ j ] . priority + ")" ) ; else System . out . println ( "ct [" + j + "] = undefined" ) ; } } static void catDump ( ) { for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( cat [ j ] != null ) System . out . println ( "cat[" + j + "] = (" + cat [ j ] . name + "," + cat [ j ] . getPriority ( ) + ")" ) ; else System . out . println ( "cat[" + j + "] = undefined" ) ; } } static boolean checkCorrectness ( int i ) { CT localCT = ct [ i ] ; if ( localCT == null ) return true ; Priority expected = getExpectedPrioriy ( localCT ) ; Priority purported = cat [ i ] . getChainedPriority ( ) ; if ( expected != purported ) { System . out . println ( "Expected priority for " + localCT . catstr + " is " + expected ) ; System . out . println ( "Purported priority for " + cat [ i ] . name + " is " + purported ) ; return false ; } return true ; } static Priority getExpectedPrioriy ( CT ctParam ) { Priority priority = ctParam . priority ; if ( priority != null ) return priority ; String catstr = ctParam . catstr ; for ( int i = catstr . lastIndexOf ( '.' , catstr . length ( ) - 1 ) ; i >= 0 ; i = catstr . lastIndexOf ( '.' , i - 1 ) ) { String substr = catstr . substring ( 0 , i ) ; for ( int j = 0 ; j < LENGTH ; j ++ ) { if ( ct [ j ] != null && substr . equals ( ct [ j ] . catstr ) ) { Priority p = ct [ j ] . priority ; if ( p != null ) return p ; } } } return defaultPriority ; } static class CT { public String catstr ; public Priority priority ; CT ( String catstr , Priority priority ) { this . catstr = catstr ; this . priority = priority ; } } } 	0	['13', '1', '0', '4', '40', '8', '0', '4', '2', '0.697916667', '516', '0', '4', '0', '0.15', '0', '0', '38.07692308', '7', '2.7692', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . LogLog ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . lang . reflect . Method ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; import java . util . Hashtable ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public final String fqnOfCategoryClass ; transient public Category category ; public final String categoryName ; transient public Priority priority ; private String ndc ; private boolean ndcLookupRequired = true ; transient private Object message ; private String renderedMessage ; private String threadName ; private ThrowableInformation throwableInfo ; public final long timeStamp ; private LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; static final Integer [ ] PARAM_ARRAY = new Integer [ 1 ] ; static final String TO_PRIORITY = "toPriority" ; static final Class [ ] TO_PRIORITY_PARAMS = new Class [ ] { int . class } ; static final Hashtable methodCache = new Hashtable ( 3 ) ; public LoggingEvent ( String fqnOfCategoryClass , Category category , Priority priority , Object message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . category = category ; this . categoryName = category . getName ( ) ; this . priority = priority ; this . message = message ; if ( throwable != null ) { this . throwableInfo = new ThrowableInformation ( throwable ) ; } timeStamp = System . currentTimeMillis ( ) ; } public LocationInfo getLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } return locationInfo ; } public Object getMessage ( ) { if ( message != null ) { return message ; } else { return getRenderedMessage ( ) ; } } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public String getRenderedMessage ( ) { if ( renderedMessage == null && message != null ) { if ( message instanceof String ) renderedMessage = ( String ) message ; else { renderedMessage = category . getHierarchy ( ) . getRendererMap ( ) . findAndRender ( message ) ; } } return renderedMessage ; } public static long getStartTime ( ) { return startTime ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public ThrowableInformation getThrowableInformation ( ) { return throwableInfo ; } public String [ ] getThrowableStrRep ( ) { if ( throwableInfo == null ) return null ; else return throwableInfo . getThrowableStrRep ( ) ; } private void readPriority ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { int p = ois . readInt ( ) ; try { String className = ( String ) ois . readObject ( ) ; if ( className == null ) { priority = Priority . toPriority ( p ) ; } else { Method m = ( Method ) methodCache . get ( className ) ; if ( m == null ) { Class clazz = Class . forName ( className ) ; m = clazz . getDeclaredMethod ( TO_PRIORITY , TO_PRIORITY_PARAMS ) ; methodCache . put ( className , m ) ; } PARAM_ARRAY [ 0 ] = new Integer ( p ) ; priority = ( Priority ) m . invoke ( null , PARAM_ARRAY ) ; } } catch ( Exception e ) { LogLog . warn ( "Priority deserialization failed, reverting to default." , e ) ; priority = Priority . toPriority ( p ) ; } } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; readPriority ( ois ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getRenderedMessage ( ) ; this . getNDC ( ) ; this . getThrowableStrRep ( ) ; oos . defaultWriteObject ( ) ; writePriority ( oos ) ; } private void writePriority ( ObjectOutputStream oos ) throws java . io . IOException { oos . writeInt ( priority . toInt ( ) ) ; Class clazz = priority . getClass ( ) ; if ( clazz == Priority . class ) { oos . writeObject ( null ) ; } else { oos . writeObject ( clazz . getName ( ) ) ; } } } 	1	['15', '1', '0', '42', '48', '77', '35', '8', '9', '0.898496241', '304', '0.421052632', '4', '0', '0.196428571', '0', '0', '18', '4', '1.4', '4']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . priority . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . message ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ 0 ] ; } public boolean ignoresThrowable ( ) { return true ; } public void setOption ( String option , String value ) { } } 	0	['6', '2', '0', '6', '12', '13', '3', '3', '6', '0.8', '54', '0', '0', '0.615384615', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . log4j . helpers ; import java . net . URL ; public class Loader { static String TSTR = "Caught Exception while in Loader.getResource. This may be innocuous." ; static public URL getResource ( String resource , Class clazz ) { URL url = null ; LogLog . debug ( "Trying to find [" + resource + "] using Class.getResource()." ) ; try { url = clazz . getResource ( resource ) ; if ( url != null ) return url ; } catch ( Throwable t ) { LogLog . warn ( TSTR , t ) ; } String fullyQualified = resolveName ( resource , clazz ) ; LogLog . debug ( "Trying to find [" + fullyQualified + "] using ClassLoader.getSystemResource()." ) ; url = ClassLoader . getSystemResource ( fullyQualified ) ; if ( url != null ) return url ; ClassLoader loader = clazz . getClassLoader ( ) ; if ( loader != null ) { try { LogLog . debug ( "Trying to find [" + resource + "] using " + loader + " class loader." ) ; url = loader . getResource ( resource ) ; if ( url != null ) return url ; } catch ( Throwable t ) { LogLog . warn ( TSTR , t ) ; } } LogLog . debug ( "Trying to find [" + resource + "] using ClassLoader.getSystemResource()." ) ; url = ClassLoader . getSystemResource ( resource ) ; return url ; } static String resolveName ( String resource , Class clazz ) { String fqcn = clazz . getName ( ) ; int index = fqcn . lastIndexOf ( '.' ) ; if ( index != - 1 ) { fqcn = fqcn . substring ( 0 , index ) . replace ( '.' , '/' ) ; resource = fqcn + "/" + resource ; } return resource ; } } 	1	['4', '1', '0', '2', '19', '4', '1', '1', '2', '0.666666667', '139', '0', '0', '0', '0.555555556', '0', '0', '33.5', '3', '1.25', '1']
package org . apache . log4j . helpers ; public class FormattingInfo { int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; void reset ( ) { min = - 1 ; max = 0x7FFFFFFF ; leftAlign = false ; } void dump ( ) { LogLog . debug ( "min=" + min + ", max=" + max + ", leftAlign=" + leftAlign ) ; } } 	0	['3', '1', '0', '9', '10', '0', '8', '1', '1', '0', '49', '0', '0', '0', '1', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . log4j . test ; import java . util . Properties ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; public class SysoutConfigurator implements Configurator { public void doConfigure ( java . net . URL url , Hierarchy hierarchy ) { Category . getRoot ( ) . addAppender ( new ConsoleAppender ( new SimpleLayout ( ) , ConsoleAppender . SYSTEM_OUT ) ) ; } } 	1	['2', '1', '0', '7', '7', '1', '0', '7', '2', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '6.5', '1', '0.5', '1']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; int millis = calendar . get ( Calendar . MILLISECOND ) ; if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	0	['4', '3', '2', '4', '12', '6', '4', '0', '4', '1.333333333', '111', '0', '0', '0.951219512', '0.357142857', '1', '3', '26', '6', '1.75', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final int DEFAULT_BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( DEFAULT_BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; boolean interruptedWarningMessage = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , this ) ; dispatcher . start ( ) ; } public void addAppender ( Appender newAppender ) { synchronized ( aai ) { aai . addAppender ( newAppender ) ; } } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; if ( locationInfo ) { event . getLocationInformation ( ) ; } synchronized ( bf ) { while ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { if ( ! interruptedWarningMessage ) { interruptedWarningMessage = true ; LogLog . warn ( "AsyncAppender interrupted." , e ) ; } else { LogLog . warn ( "AsyncAppender interrupted again." ) ; } } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { synchronized ( this ) { if ( closed ) return ; closed = true ; } dispatcher . close ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { synchronized ( aai ) { return aai . getAllAppenders ( ) ; } } public Appender getAppender ( String name ) { synchronized ( aai ) { return aai . getAppender ( name ) ; } } public boolean getLocationInfo ( ) { return locationInfo ; } public boolean requiresLayout ( ) { return false ; } public void removeAllAppenders ( ) { synchronized ( aai ) { aai . removeAllAppenders ( ) ; } } public void removeAppender ( Appender appender ) { synchronized ( aai ) { aai . removeAppender ( appender ) ; } } public void removeAppender ( String name ) { synchronized ( aai ) { aai . removeAppender ( name ) ; } } public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public void setBufferSize ( int size ) { bf . resize ( size ) ; } public int getBufferSize ( ) { return bf . getMaxSize ( ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { LOCATION_INFO_OPTION , BUFFER_SIZE_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { int newSize = OptionConverter . toInt ( value , DEFAULT_BUFFER_SIZE ) ; bf . resize ( newSize ) ; } } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; boolean interrupted = false ; AsyncAppender container ; Dispatcher ( BoundedFIFO bf , AsyncAppender container ) { this . bf = bf ; this . container = container ; this . aai = container . aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; this . setName ( "Dispatcher-" + getName ( ) ) ; } void close ( ) { synchronized ( bf ) { interrupted = true ; if ( bf . length ( ) == 0 ) { bf . notify ( ) ; } } } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "The dispathcer should not be interrupted." ) ; break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } synchronized ( container . aai ) { if ( aai != null && event != null ) { aai . appendLoopOnAppenders ( event ) ; } } } } } 	1	['16', '2', '0', '10', '48', '34', '1', '10', '16', '0.883333333', '320', '0', '3', '0.545454545', '0.25', '2', '3', '18.5', '5', '1.4375', '5']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; public class DelayedLoop { static Category cat = Category . getInstance ( DelayedLoop . class ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + DelayedLoop . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( "xml" ) ) { DOMConfigurator . configureAndWatch ( configFile , 3000 ) ; } else { PropertyConfigurator . configureAndWatch ( configFile , 3000 ) ; } } static void test ( ) { int i = 0 ; while ( true ) { cat . debug ( "MSG " + i ++ ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } 	0	['7', '1', '0', '3', '25', '17', '0', '3', '2', '0.833333333', '105', '0', '1', '0', '0.277777778', '0', '0', '13.57142857', '2', '1.1429', '0']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class SimpleSocketServer { static Category cat = Category . getInstance ( SimpleSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; cat . info ( "Connected to client at " + socket . getInetAddress ( ) ) ; cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SimpleSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	1	['6', '1', '0', '4', '30', '9', '0', '4', '2', '0.666666667', '144', '0', '1', '0', '0.333333333', '0', '0', '22.5', '2', '1', '1']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . InputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class SocketNode implements Runnable { Socket socket ; Hierarchy hierarchy ; ObjectInputStream ois ; static Category cat = Category . getInstance ( SocketNode . class . getName ( ) ) ; public SocketNode ( Socket socket , Hierarchy hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( socket . getInputStream ( ) ) ; } catch ( Exception e ) { cat . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Category remoteCategory ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteCategory = hierarchy . getInstance ( event . categoryName ) ; event . category = remoteCategory ; if ( event . priority . isGreaterOrEqual ( remoteCategory . getChainedPriority ( ) ) ) { remoteCategory . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { cat . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { cat . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( Exception e ) { cat . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { cat . info ( "Could not close connection." , e ) ; } } } 	1	['4', '1', '0', '7', '25', '0', '3', '4', '2', '0.733333333', '109', '0', '2', '0', '0.416666667', '0', '0', '25', '2', '0.75', '3']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class SimpleSocketServer { static Category cat = Category . getInstance ( SimpleSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; cat . info ( "Connected to client at " + socket . getInetAddress ( ) ) ; cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SimpleSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	0	['6', '1', '0', '4', '30', '9', '0', '4', '2', '0.666666667', '144', '0', '1', '0', '0.333333333', '0', '0', '22.5', '2', '1', '0']
package org . apache . log4j . net ; import java . net . Socket ; import java . net . ServerSocket ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . io . IOException ; import java . io . File ; import java . util . Hashtable ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . RootCategory ; public class SocketServer { static String GENERIC = "generic" ; static String CONFIG_FILE_EXT = ".lcf" ; static Category cat = Category . getInstance ( SocketServer . class ) ; static SocketServer server ; static int port ; Hashtable hierarchyMap ; Hierarchy genericHierarchy ; File dir ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] ) ; else usage ( "Wrong number of arguments." ) ; try { cat . info ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { cat . info ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; InetAddress inetAddress = socket . getInetAddress ( ) ; cat . info ( "Connected to client at " + inetAddress ) ; Hierarchy h = ( Hierarchy ) server . hierarchyMap . get ( inetAddress ) ; if ( h == null ) { h = server . configureHierarchy ( inetAddress ) ; } cat . info ( "Starting new socket node." ) ; new Thread ( new SocketNode ( socket , h ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketServer . class . getName ( ) + " port configFile directory" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile , String dirStr ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; File dir = new File ( dirStr ) ; if ( ! dir . isDirectory ( ) ) { usage ( "[" + dirStr + "] is not a directory." ) ; } server = new SocketServer ( dir ) ; } public SocketServer ( File directory ) { this . dir = directory ; hierarchyMap = new Hashtable ( 11 ) ; } Hierarchy configureHierarchy ( InetAddress inetAddress ) { cat . info ( "Locating configuration file for " + inetAddress ) ; String s = inetAddress . toString ( ) ; int i = s . indexOf ( "/" ) ; if ( i == - 1 ) { cat . warn ( "Could not parse the inetAddress [" + inetAddress + "]. Using default hierarchy." ) ; return genericHierarchy ( ) ; } else { String key = s . substring ( 0 , i ) ; File configFile = new File ( dir , key + CONFIG_FILE_EXT ) ; if ( configFile . exists ( ) ) { Hierarchy h = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; hierarchyMap . put ( inetAddress , h ) ; new PropertyConfigurator ( ) . doConfigure ( configFile . getAbsolutePath ( ) , h ) ; return h ; } else { cat . warn ( "Could not find config file [" + configFile + "]." ) ; return genericHierarchy ( ) ; } } } Hierarchy genericHierarchy ( ) { if ( genericHierarchy == null ) { File f = new File ( dir , GENERIC + CONFIG_FILE_EXT ) ; if ( f . exists ( ) ) { genericHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; new PropertyConfigurator ( ) . doConfigure ( f . getAbsolutePath ( ) , genericHierarchy ) ; } else { cat . warn ( "Could not find config file [" + f + "]. Will use the default hierarchy." ) ; genericHierarchy = Category . getDefaultHierarchy ( ) ; } } return genericHierarchy ; } } 	1	['8', '1', '0', '6', '48', '6', '0', '6', '2', '0.666666667', '356', '0', '3', '0', '0.257142857', '0', '0', '42.375', '3', '1.75', '1']
package org . apache . log4j . helpers ; import java . io . File ; import java . io . Writer ; import java . io . FileWriter ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	0	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '0']
package org . apache . log4j . config ; import java . beans . Introspector ; import java . beans . PropertyDescriptor ; import java . beans . BeanInfo ; import java . beans . IntrospectionException ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import org . apache . log4j . * ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . OptionHandler ; public class PropertySetter { protected Object obj ; protected PropertyDescriptor [ ] props ; public PropertySetter ( Object obj ) { this . obj = obj ; } protected void introspect ( ) { try { BeanInfo bi = Introspector . getBeanInfo ( obj . getClass ( ) ) ; props = bi . getPropertyDescriptors ( ) ; } catch ( IntrospectionException ex ) { LogLog . error ( "Failed to introspect " + obj + ": " + ex . getMessage ( ) ) ; props = new PropertyDescriptor [ 0 ] ; } } public static void setProperties ( Object obj , Properties properties , String prefix ) { new PropertySetter ( obj ) . setProperties ( properties , prefix ) ; } public void setProperties ( Properties properties , String prefix ) { int len = prefix . length ( ) ; for ( Enumeration e = properties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; if ( key . startsWith ( prefix ) ) { if ( key . indexOf ( '.' , len + 1 ) > 0 ) { continue ; } String value = OptionConverter . findAndSubst ( key , properties ) ; key = key . substring ( len ) ; if ( "layout" . equals ( key ) && obj instanceof Appender ) { continue ; } setProperty ( key , value ) ; } } activate ( ) ; } public void setProperty ( String name , String value ) { if ( value == null ) return ; name = Introspector . decapitalize ( name ) ; PropertyDescriptor prop = getPropertyDescriptor ( name ) ; if ( prop == null ) { LogLog . warn ( "No such property [" + name + "] in " + obj . getClass ( ) . getName ( ) + "." ) ; } else { try { setProperty ( prop , name , value ) ; } catch ( PropertySetterException ex ) { LogLog . warn ( "Failed to set property " + name + " to value \"" + value + "\". " + ex . getMessage ( ) ) ; } } } public void setProperty ( PropertyDescriptor prop , String name , String value ) throws PropertySetterException { Method setter = prop . getWriteMethod ( ) ; if ( setter == null ) { throw new PropertySetterException ( "No setter for property" ) ; } Class [ ] paramTypes = setter . getParameterTypes ( ) ; if ( paramTypes . length != 1 ) { throw new PropertySetterException ( "#params for setter != 1" ) ; } Object arg ; try { arg = convertArg ( value , paramTypes [ 0 ] ) ; } catch ( Throwable t ) { throw new PropertySetterException ( "Conversion to type [" + paramTypes [ 0 ] + "] failed. Reason: " + t ) ; } if ( arg == null ) { throw new PropertySetterException ( "Conversion to type [" + paramTypes [ 0 ] + "] failed." ) ; } LogLog . debug ( "Setting property [" + name + "] to [" + arg + "]." ) ; try { setter . invoke ( obj , new Object [ ] { arg } ) ; } catch ( Exception ex ) { throw new PropertySetterException ( ex ) ; } } protected Object convertArg ( String val , Class type ) { if ( val == null ) return null ; String v = val . trim ( ) ; if ( String . class . isAssignableFrom ( type ) ) { return val ; } else if ( Integer . TYPE . isAssignableFrom ( type ) ) { return new Integer ( v ) ; } else if ( Long . TYPE . isAssignableFrom ( type ) ) { return new Long ( v ) ; } else if ( Boolean . TYPE . isAssignableFrom ( type ) ) { if ( "true" . equalsIgnoreCase ( v ) ) { return Boolean . TRUE ; } else if ( "false" . equalsIgnoreCase ( v ) ) { return Boolean . FALSE ; } } else if ( Priority . class . isAssignableFrom ( type ) ) { return OptionConverter . toPriority ( v , null ) ; } return null ; } protected PropertyDescriptor getPropertyDescriptor ( String name ) { if ( props == null ) introspect ( ) ; for ( int i = 0 ; i < props . length ; i ++ ) { if ( name . equals ( props [ i ] . getName ( ) ) ) { return props [ i ] ; } } return null ; } public void activate ( ) { if ( obj instanceof OptionHandler ) { ( ( OptionHandler ) obj ) . activateOptions ( ) ; } } } 	1	['10', '1', '0', '7', '49', '13', '1', '6', '6', '0.694444444', '386', '0.5', '0', '0', '0.35', '0', '0', '37.2', '11', '2.9', '2']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	0	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '0']
package org . apache . log4j . net ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; public static final String SYSLOG_HOST_OPTION = "SyslogHost" ; public static final String FACILITY_OPTION = "Facility" ; public static final String FACILITY_PRINTING_OPTION = "FacilityPrinting" ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; static final String TAB = "    " ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { SYSLOG_HOST_OPTION , FACILITY_OPTION , FACILITY_PRINTING_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( SYSLOG_HOST_OPTION ) ) this . setSyslogHost ( value ) ; else if ( option . equals ( FACILITY_PRINTING_OPTION ) ) facilityPrinting = OptionConverter . toBoolean ( value , facilityPrinting ) ; else if ( option . equals ( FACILITY_OPTION ) ) { this . setFacility ( value ) ; } } synchronized public void close ( ) { closed = true ; sqw = null ; } private void initSyslogFacilityStr ( ) { facilityStr = getFacilityString ( this . syslogFacility ) ; if ( facilityStr == null ) { System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } else { facilityStr += ":" ; } } public static String getFacilityString ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : return "kern" ; case LOG_USER : return "user" ; case LOG_MAIL : return "mail" ; case LOG_DAEMON : return "daemon" ; case LOG_AUTH : return "auth" ; case LOG_SYSLOG : return "syslog" ; case LOG_LPR : return "lpr" ; case LOG_NEWS : return "news" ; case LOG_UUCP : return "uucp" ; case LOG_CRON : return "cron" ; case LOG_AUTHPRIV : return "authpriv" ; case LOG_FTP : return "ftp" ; case LOG_LOCAL0 : return "local0" ; case LOG_LOCAL1 : return "local1" ; case LOG_LOCAL2 : return "local2" ; case LOG_LOCAL3 : return "local3" ; case LOG_LOCAL4 : return "local4" ; case LOG_LOCAL5 : return "local5" ; case LOG_LOCAL6 : return "local6" ; case LOG_LOCAL7 : return "local7" ; default : return null ; } } public static int getFacility ( String facilityName ) { if ( facilityName != null ) { facilityName = facilityName . trim ( ) ; } if ( "KERN" . equalsIgnoreCase ( facilityName ) ) { return LOG_KERN ; } else if ( "USER" . equalsIgnoreCase ( facilityName ) ) { return LOG_USER ; } else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) { return LOG_MAIL ; } else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) { return LOG_DAEMON ; } else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTH ; } else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) { return LOG_SYSLOG ; } else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) { return LOG_LPR ; } else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) { return LOG_NEWS ; } else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) { return LOG_UUCP ; } else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) { return LOG_CRON ; } else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTHPRIV ; } else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) { return LOG_FTP ; } else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL0 ; } else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL1 ; } else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL2 ; } else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL3 ; } else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL4 ; } else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL5 ; } else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL6 ; } else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL7 ; } else { return - 1 ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . priority ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setPriority ( event . priority . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; if ( len > 0 ) { sqw . write ( s [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { sqw . write ( TAB + s [ i ] . substring ( 1 ) ) ; } } } } public void activateOptions ( ) { } public boolean requiresLayout ( ) { return true ; } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . syslogHost = syslogHost ; } public String getSyslogHost ( ) { return syslogHost ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; syslogFacility = getFacility ( facilityName ) ; if ( syslogFacility == - 1 ) { System . err . println ( "[" + facilityName + "] is an unknown syslog facility. Defaulting to [USER]." ) ; syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public String getFacility ( ) { return getFacilityString ( syslogFacility ) ; } public void setFacilityPrinting ( boolean on ) { facilityPrinting = on ; } public boolean getFacilityPrinting ( ) { return facilityPrinting ; } } 	1	['18', '2', '0', '8', '42', '81', '0', '8', '17', '1', '517', '0.064516129', '1', '0.545454545', '0.259259259', '2', '4', '26', '22', '3.9444', '1']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import java . util . Properties ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSAppender extends AppenderSkeleton { TopicConnection topicConnection ; TopicSession topicSession ; TopicPublisher topicPublisher ; static String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION = "TopicConnectionFactoryBindingName" ; static String TOPIC_BINDING_NAME_OPTION = "TopicBindingName" ; String topicBindingName ; String tcfBindingName ; public JMSAppender ( ) { } protected Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } public void activateOptions ( ) { TopicConnectionFactory topicConnectionFactory ; try { Context ctx = new InitialContext ( ) ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) lookup ( ctx , topicBindingName ) ; topicPublisher = topicSession . createPublisher ( topic ) ; ctx . close ( ) ; } catch ( Exception e ) { errorHandler . error ( "Error while activating options for appender named [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } protected boolean checkEntryConditions ( ) { String fail = null ; if ( this . topicConnection == null ) { fail = "No TopicConnection" ; } else if ( this . topicSession == null ) { fail = "No TopicSession" ; } else if ( this . topicPublisher == null ) { fail = "No TopicPublisher" ; } if ( fail != null ) { errorHandler . error ( fail + " for JMSAppender named [" + name + "]." ) ; return false ; } else { return true ; } } public synchronized void close ( ) { if ( this . closed ) return ; LogLog . debug ( "Closing appender [" + name + "]." ) ; this . closed = true ; try { if ( topicSession != null ) topicSession . close ( ) ; if ( topicConnection != null ) topicConnection . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Error while closing JMSAppender [" + name + "]." , e ) ; } topicPublisher = null ; topicSession = null ; topicConnection = null ; } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } try { ObjectMessage msg = topicSession . createObjectMessage ( ) ; msg . setObject ( event ) ; topicPublisher . publish ( msg ) ; } catch ( Exception e ) { errorHandler . error ( "Could not publish message in JMSAppender [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TOPIC_BINDING_NAME_OPTION , TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equals ( TOPIC_BINDING_NAME_OPTION ) ) topicBindingName = value ; else if ( key . equals ( TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION ) ) { tcfBindingName = value ; } } public boolean requiresLayout ( ) { return false ; } } 	0	['10', '2', '0', '5', '35', '25', '0', '5', '7', '0.761904762', '272', '0', '0', '0.692307692', '0.361111111', '2', '3', '25.5', '5', '1.8', '0']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . helpers . LogLog ; public class NDC { static Hashtable ht = new Hashtable ( ) ; static int pushCounter = 0 ; static final int REAP_THRESHOLD = 5 ; private NDC ( ) { } public static void clear ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null ) stack . setSize ( 0 ) ; } public static Stack cloneStack ( ) { Object o = ht . get ( Thread . currentThread ( ) ) ; if ( o == null ) return null ; else { Stack stack = ( Stack ) o ; return ( Stack ) stack . clone ( ) ; } } public static void inherit ( Stack stack ) { if ( stack != null ) ht . put ( Thread . currentThread ( ) , stack ) ; } static public String get ( ) { Stack s = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( s != null && ! s . isEmpty ( ) ) return ( ( DiagnosticContext ) s . peek ( ) ) . fullMessage ; else return null ; } public static int getDepth ( ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack == null ) return 0 ; else return stack . size ( ) ; } private static void lazyRemove ( ) { Vector v ; synchronized ( ht ) { if ( ++ pushCounter >= REAP_THRESHOLD ) { return ; } else { pushCounter = 0 ; } int misses = 0 ; v = new Vector ( ) ; Enumeration enum = ht . keys ( ) ; while ( enum . hasMoreElements ( ) && ( misses <= 4 ) ) { Thread t = ( Thread ) enum . nextElement ( ) ; if ( t . isAlive ( ) ) { misses ++ ; } else { misses = 0 ; v . addElement ( t ) ; } } } int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Thread t = ( Thread ) v . elementAt ( i ) ; LogLog . debug ( "Lazy NDC removal for thread [" + t . getName ( ) + "] (" + ht . size ( ) + ")." ) ; ht . remove ( t ) ; } } public static String pop ( ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack != null && ! stack . isEmpty ( ) ) return ( ( DiagnosticContext ) stack . pop ( ) ) . message ; else return "" ; } public static void push ( String message ) { Thread key = Thread . currentThread ( ) ; Stack stack = ( Stack ) ht . get ( key ) ; if ( stack == null ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack = new Stack ( ) ; ht . put ( key , stack ) ; stack . push ( dc ) ; } else if ( stack . isEmpty ( ) ) { DiagnosticContext dc = new DiagnosticContext ( message , null ) ; stack . push ( dc ) ; } else { DiagnosticContext parent = ( DiagnosticContext ) stack . peek ( ) ; stack . push ( new DiagnosticContext ( message , parent ) ) ; } } static public void remove ( ) { ht . remove ( Thread . currentThread ( ) ) ; lazyRemove ( ) ; } static public void setMaxDepth ( int maxDepth ) { Stack stack = ( Stack ) ht . get ( Thread . currentThread ( ) ) ; if ( stack != null && maxDepth < stack . size ( ) ) stack . setSize ( maxDepth ) ; } private static class DiagnosticContext { String fullMessage ; String message ; DiagnosticContext ( String message , DiagnosticContext parent ) { this . message = message ; if ( parent != null ) { fullMessage = parent . fullMessage + ' ' + message ; } else { fullMessage = message ; } } } } 	1	['12', '1', '0', '12', '41', '0', '10', '2', '9', '0.666666667', '275', '0', '0', '0', '0.090909091', '0', '0', '21.66666667', '6', '2.25', '2']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . NDC ; import org . apache . log4j . helpers . PatternParser ; import org . apache . log4j . helpers . PatternConverter ; import org . apache . log4j . helpers . OptionConverter ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . TimeZone ; import java . util . Vector ; import java . text . FieldPosition ; public class PatternLayout extends Layout { final static public String CONVERSION_PATTERN_OPTION = "ConversionPattern" ; public final static String DEFAULT_CONVERSION_PATTERN = "%m%n" ; public final static String TTCC_CONVERSION_PATTERN = "%r [%t] %p %c %x - %m%n" ; protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; private String pattern ; private PatternConverter head ; private String timezone ; public PatternLayout ( ) { this ( DEFAULT_CONVERSION_PATTERN ) ; } public PatternLayout ( String pattern ) { this . pattern = pattern ; head = createPatternParser ( ( pattern == null ) ? DEFAULT_CONVERSION_PATTERN : pattern ) . parse ( ) ; } public String [ ] getOptionStrings ( ) { return new String [ ] { CONVERSION_PATTERN_OPTION } ; } public void setOption ( String option , String value ) { if ( value == null ) return ; if ( option . equalsIgnoreCase ( CONVERSION_PATTERN_OPTION ) ) { pattern = value ; head = createPatternParser ( value ) . parse ( ) ; } } public void setConversionPattern ( String conversionPattern ) { pattern = conversionPattern ; head = createPatternParser ( conversionPattern ) . parse ( ) ; } public String getConversionPattern ( ) { return pattern ; } public void activateOptions ( ) { } public boolean ignoresThrowable ( ) { return true ; } protected PatternParser createPatternParser ( String pattern ) { return new PatternParser ( pattern ) ; } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } PatternConverter c = head ; while ( c != null ) { c . format ( sbuf , event ) ; c = c . next ; } return sbuf . toString ( ) ; } } 	1	['10', '2', '0', '7', '19', '27', '3', '4', '9', '0.901234568', '130', '0.666666667', '1', '0.5', '0.5', '0', '0', '11.1', '3', '1.2', '1']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; public interface CategoryFactory { public Category makeNewCategoryInstance ( String name ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; public class Hierarchy { static final int DISABLE_OFF = - 1 ; static final int DISABLE_OVERRIDE = - 2 ; static private CategoryFactory defaultFactory = new DefaultCategoryFactory ( ) ; Hashtable ht ; Category root ; RendererMap rendererMap ; int disable ; boolean emittedNoAppenderWarning = false ; boolean emittedNoResourceBundleWarning = false ; public Hierarchy ( Category root ) { ht = new Hashtable ( ) ; this . root = root ; disable = DISABLE_OFF ; this . root . setHierarchy ( this ) ; rendererMap = new RendererMap ( ) ; } public void addRenderer ( Class classToRender , ObjectRenderer or ) { rendererMap . put ( classToRender , or ) ; } public void clear ( ) { ht . clear ( ) ; } public Category exists ( String name ) { Object o = ht . get ( new CategoryKey ( name ) ) ; if ( o instanceof Category ) { return ( Category ) o ; } else { return null ; } } public void disable ( String priorityStr ) { if ( disable != DISABLE_OVERRIDE ) { Priority p = Priority . toPriority ( priorityStr , null ) ; if ( p != null ) { disable = p . level ; } else { LogLog . warn ( "Could not convert [" + priorityStr + "] to Priority." ) ; } } } public void disable ( Priority p ) { if ( ( disable != DISABLE_OVERRIDE ) && ( p != null ) ) { disable = p . level ; } } public void disableAll ( ) { disable ( Priority . FATAL ) ; } public void disableDebug ( ) { disable ( Priority . DEBUG ) ; } public void disableInfo ( ) { disable ( Priority . INFO ) ; } public void enableAll ( ) { disable = DISABLE_OFF ; } public void overrideAsNeeded ( String override ) { if ( override != null ) { LogLog . debug ( "Handling non-null disable override directive: \"" + override + "\"." ) ; if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding all disable methods." ) ; disable = DISABLE_OVERRIDE ; } } } public Category getInstance ( String name ) { return getInstance ( name , defaultFactory ) ; } public Category getInstance ( String name , CategoryFactory factory ) { CategoryKey key = new CategoryKey ( name ) ; Category category ; synchronized ( ht ) { Object o = ht . get ( key ) ; if ( o == null ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateParents ( category ) ; return category ; } else if ( o instanceof Category ) { return ( Category ) o ; } else if ( o instanceof ProvisionNode ) { category = factory . makeNewCategoryInstance ( name ) ; category . setHierarchy ( this ) ; ht . put ( key , category ) ; updateChildren ( ( ProvisionNode ) o , category ) ; updateParents ( category ) ; return category ; } else { return null ; } } } public Enumeration getCurrentCategories ( ) { Vector v = new Vector ( ht . size ( ) ) ; Enumeration elems = ht . elements ( ) ; while ( elems . hasMoreElements ( ) ) { Object o = elems . nextElement ( ) ; if ( o instanceof Category ) { v . addElement ( o ) ; } } return v . elements ( ) ; } public boolean isDisabled ( int level ) { return disable >= level ; } public RendererMap getRendererMap ( ) { return rendererMap ; } public Category getRoot ( ) { return root ; } public void resetConfiguration ( ) { getRoot ( ) . setPriority ( Priority . DEBUG ) ; root . setResourceBundle ( null ) ; disable = Hierarchy . DISABLE_OFF ; synchronized ( ht ) { shutdown ( ) ; Enumeration cats = getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . setPriority ( null ) ; c . setAdditivity ( true ) ; c . setResourceBundle ( null ) ; } } rendererMap . clear ( ) ; } public void setDisableOverride ( String override ) { if ( OptionConverter . toBoolean ( override , true ) ) { LogLog . debug ( "Overriding disable." ) ; disable = DISABLE_OVERRIDE ; } } public void shutdown ( ) { Category root = getRoot ( ) ; root . closeNestedAppenders ( ) ; synchronized ( ht ) { Enumeration cats = this . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . closeNestedAppenders ( ) ; } root . removeAllAppenders ( ) ; cats = this . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { Category c = ( Category ) cats . nextElement ( ) ; c . removeAllAppenders ( ) ; } } } final private void updateParents ( Category cat ) { String name = cat . name ; int length = name . length ( ) ; boolean parentFound = false ; for ( int i = name . lastIndexOf ( '.' , length - 1 ) ; i >= 0 ; i = name . lastIndexOf ( '.' , i - 1 ) ) { String substr = name . substring ( 0 , i ) ; CategoryKey key = new CategoryKey ( substr ) ; Object o = ht . get ( key ) ; if ( o == null ) { ProvisionNode pn = new ProvisionNode ( cat ) ; ht . put ( key , pn ) ; } else if ( o instanceof Category ) { parentFound = true ; cat . parent = ( Category ) o ; break ; } else if ( o instanceof ProvisionNode ) { ( ( ProvisionNode ) o ) . addElement ( cat ) ; } else { Exception e = new IllegalStateException ( "unexpected object type " + o . getClass ( ) + " in ht." ) ; e . printStackTrace ( ) ; } } if ( ! parentFound ) cat . parent = root ; } final private void updateChildren ( ProvisionNode pn , Category cat ) { final int last = pn . size ( ) ; for ( int i = 0 ; i < last ; i ++ ) { Category c = ( Category ) pn . elementAt ( i ) ; if ( ! c . parent . name . startsWith ( cat . name ) ) { cat . parent = c . parent ; c . parent = cat ; } } } } 	1	['23', '1', '0', '23', '65', '125', '15', '10', '20', '0.873737374', '530', '0.111111111', '3', '0', '0.186868687', '0', '0', '21.65217391', '6', '1.913', '3']
package org . apache . log4j . spi ; import org . apache . log4j . Hierarchy ; import java . net . URL ; public interface Configurator { void doConfigure ( URL url , Hierarchy hierarchy ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . TriggeringEventEvaluator ; import java . util . Properties ; import java . util . Date ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . Message ; import javax . mail . MessagingException ; import javax . mail . internet . MimeMessage ; import javax . mail . Multipart ; import javax . mail . internet . MimeMultipart ; import javax . mail . internet . MimeBodyPart ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . AddressException ; import javax . mail . internet . MimeUtility ; public class SMTPAppender extends AppenderSkeleton { String to ; String from ; String subject ; String smtpHost ; int bufferSize = 512 ; CyclicBuffer cb = new CyclicBuffer ( bufferSize ) ; Session session ; Message msg ; boolean locationInfo = false ; public static final String TO_OPTION = "To" ; public static final String FROM_OPTION = "From" ; public static final String SUBJECT_OPTION = "Subject" ; public static final String SMTP_HOST_OPTION = "SMTPHost" ; public static final String BUFFER_SIZE_OPTION = "BufferSize" ; public static final String EVALUATOR_CLASS_OPTION = "EvaluatorClass" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; protected TriggeringEventEvaluator evaluator ; public SMTPAppender ( ) { this ( new DefaultEvaluator ( ) ) ; } public SMTPAppender ( TriggeringEventEvaluator evaluator ) { this . evaluator = evaluator ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TO_OPTION , FROM_OPTION , SUBJECT_OPTION , SMTP_HOST_OPTION , BUFFER_SIZE_OPTION , EVALUATOR_CLASS_OPTION , LOCATION_INFO_OPTION } ) ; } public void activateOptions ( ) { Properties props = System . getProperties ( ) ; if ( smtpHost != null ) props . put ( "mail.smtp.host" , smtpHost ) ; session = Session . getDefaultInstance ( props , null ) ; msg = new MimeMessage ( session ) ; try { if ( from != null ) msg . setFrom ( getAddress ( from ) ) ; else msg . setFrom ( ) ; msg . setRecipients ( Message . RecipientType . TO , parseAddress ( to ) ) ; if ( subject != null ) msg . setSubject ( subject ) ; } catch ( MessagingException e ) { LogLog . error ( "Could not activate SMTPAppender options." , e ) ; } } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } event . getThreadName ( ) ; event . getNDC ( ) ; if ( locationInfo ) { event . getLocationInformation ( ) ; } cb . add ( event ) ; if ( evaluator . isTriggeringEvent ( event ) ) { sendBuffer ( ) ; } } protected boolean checkEntryConditions ( ) { if ( this . msg == null ) { errorHandler . error ( "Message object not configured." ) ; return false ; } if ( this . evaluator == null ) { errorHandler . error ( "No TriggeringEventEvaluator is set for appender [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } synchronized public void close ( ) { this . closed = true ; } InternetAddress getAddress ( String addressStr ) { try { return new InternetAddress ( addressStr ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } InternetAddress [ ] parseAddress ( String addressStr ) { try { return InternetAddress . parse ( addressStr , true ) ; } catch ( AddressException e ) { errorHandler . error ( "Could not parse address [" + addressStr + "]." , e , ErrorCode . ADDRESS_PARSE_FAILURE ) ; return null ; } } public String getTo ( ) { return to ; } public boolean requiresLayout ( ) { return true ; } protected void sendBuffer ( ) { try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String t = layout . getHeader ( ) ; if ( t != null ) sbuf . append ( t ) ; int len = cb . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { LoggingEvent event = cb . get ( ) ; sbuf . append ( layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { sbuf . append ( s [ j ] ) ; } } } } t = layout . getFooter ( ) ; if ( t != null ) sbuf . append ( t ) ; part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; msg . setContent ( mp ) ; msg . setSentDate ( new Date ( ) ) ; Transport . send ( msg ) ; } catch ( Exception e ) { LogLog . error ( "Error occured while sending e-mail notification." , e ) ; } } public String getEvaluatorClass ( ) { return evaluator == null ? null : evaluator . getClass ( ) . getName ( ) ; } public String getFrom ( ) { return from ; } public String getSubject ( ) { return subject ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( TO_OPTION ) ) to = value ; else if ( option . equals ( FROM_OPTION ) ) from = value ; else if ( option . equals ( SMTP_HOST_OPTION ) ) smtpHost = value ; else if ( option . equals ( SUBJECT_OPTION ) ) subject = value ; else if ( option . equals ( EVALUATOR_CLASS_OPTION ) ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } else if ( option . equals ( BUFFER_SIZE_OPTION ) ) { bufferSize = OptionConverter . toInt ( value , bufferSize ) ; cb . resize ( bufferSize ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } public void setFrom ( String from ) { this . from = from ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setBufferSize ( int bufferSize ) { this . bufferSize = bufferSize ; cb . resize ( bufferSize ) ; } public void setSMTPHost ( String smtpHost ) { this . smtpHost = smtpHost ; } public String getSMTPHost ( ) { return smtpHost ; } public void setTo ( String to ) { this . to = to ; } public int getBufferSize ( ) { return bufferSize ; } public void setEvaluatorClass ( String value ) { evaluator = ( TriggeringEventEvaluator ) OptionConverter . instantiateByClassName ( value , TriggeringEventEvaluator . class , evaluator ) ; } public void setLocationInfo ( boolean locationInfo ) { this . locationInfo = locationInfo ; } public boolean getLocationInfo ( ) { return locationInfo ; } } class DefaultEvaluator implements TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) { return event . priority . isGreaterOrEqual ( Priority . ERROR ) ; } } 	1	['27', '2', '0', '10', '80', '239', '0', '10', '22', '0.938034188', '565', '0.055555556', '2', '0.418604651', '0.240740741', '2', '3', '19.25925926', '10', '1.8519', '3']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	0	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . log4j . config ; import java . beans . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; import org . apache . log4j . Appender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; public class PropertyGetter { protected static final Object [ ] NULL_ARG = new Object [ ] { } ; protected Object obj ; protected PropertyDescriptor [ ] props ; public interface PropertyCallback { void foundProperty ( Object obj , String prefix , String name , Object value ) ; } public PropertyGetter ( Object obj ) throws IntrospectionException { BeanInfo bi = Introspector . getBeanInfo ( obj . getClass ( ) ) ; props = bi . getPropertyDescriptors ( ) ; this . obj = obj ; } public static void getProperties ( Object obj , PropertyCallback callback , String prefix ) { try { new PropertyGetter ( obj ) . getProperties ( callback , prefix ) ; } catch ( IntrospectionException ex ) { LogLog . error ( "Failed to introspect object " + obj , ex ) ; } } public void getProperties ( PropertyCallback callback , String prefix ) { for ( int i = 0 ; i < props . length ; i ++ ) { Method getter = props [ i ] . getReadMethod ( ) ; if ( getter == null ) continue ; if ( ! isHandledType ( getter . getReturnType ( ) ) ) { continue ; } String name = props [ i ] . getName ( ) ; try { Object result = getter . invoke ( obj , NULL_ARG ) ; if ( result != null ) { callback . foundProperty ( obj , prefix , name , result ) ; } } catch ( Exception ex ) { LogLog . warn ( "Failed to get value of property " + name ) ; } } } protected boolean isHandledType ( Class type ) { return String . class . isAssignableFrom ( type ) || Integer . TYPE . isAssignableFrom ( type ) || Long . TYPE . isAssignableFrom ( type ) || Boolean . TYPE . isAssignableFrom ( type ) || Priority . class . isAssignableFrom ( type ) ; } } 	1	['6', '1', '0', '3', '25', '11', '1', '2', '3', '0.68', '154', '0.6', '0', '0', '0.44', '0', '0', '23.83333333', '8', '2.3333', '1']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { root . setPriority ( Priority . DEBUG ) ; BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toHexString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '4', '37', '8', '0', '4', '7', '0.822916667', '314', '0', '1', '0.897058824', '0.21875', '0', '0', '32.55555556', '7', '2', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . or . MessageRenderer ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSSink { static public void main ( String [ ] args ) { if ( args . length != 3 ) { usage ( "Wrong number of arguments." ) ; } String tcfBindingName = args [ 0 ] ; String topicBindingName = args [ 1 ] ; PropertyConfigurator . configure ( args [ 2 ] ) ; Category . getDefaultHierarchy ( ) . addRenderer ( Message . class , new MessageRenderer ( ) ) ; try { Context ctx = new InitialContext ( ) ; TopicConnectionFactory topicConnectionFactory ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; TopicConnection topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; TopicSession topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; TopicSubscriber topicSubscriber = topicSession . createDurableSubscriber ( topic , "x" ) ; LoggingEvent event ; Category remoteCategory ; while ( true ) { ObjectMessage msg = ( ObjectMessage ) topicSubscriber . receive ( ) ; event = ( LoggingEvent ) msg . getObject ( ) ; remoteCategory = Category . getInstance ( event . categoryName ) ; remoteCategory . callAppenders ( event ) ; } } catch ( Exception e ) { LogLog . error ( "Could not read JMS message." , e ) ; } } protected static Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + JMSSink . class . getName ( ) + " TopicConnectionFactoryBindingName TopicBindingName configFile" ) ; System . exit ( 1 ) ; } } 	1	['5', '1', '0', '7', '31', '10', '0', '7', '2', '0.875', '145', '0', '0', '0', '0.3', '0', '0', '27.6', '3', '1.4', '3']
package org . apache . log4j . varia ; import java . io . File ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Layout ; public class ResilientFileAppender extends FileAppender { File file ; public ResilientFileAppender ( ) { } public ResilientFileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } protected boolean checkEntryConditions ( ) { if ( ! super . checkEntryConditions ( ) ) { return false ; } if ( ( file != null ) && ! file . exists ( ) ) { file = new File ( fileName ) ; try { setFile ( fileName ) ; } catch ( java . io . IOException e ) { LogLog . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e ) ; } } return true ; } public void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; file = new File ( fileName ) ; } protected void reset ( ) { super . reset ( ) ; file = null ; } } 	0	['5', '3', '0', '3', '18', '4', '0', '3', '3', '0.5', '76', '0', '0', '0.916666667', '0.36', '1', '7', '14', '4', '1.2', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; import java . util . Enumeration ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Logging . class . getName ( ) + " confFile runLength [delay] [burstLen]\n" + "        confFile is an XML configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . shutdown ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( ( System . currentTimeMillis ( ) - before ) * 1000.0 ) / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	1	['8', '1', '0', '3', '30', '12', '0', '3', '2', '0.666666667', '228', '0', '1', '0', '0.321428571', '0', '0', '26.75', '4', '1.75', '1']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import java . util . Enumeration ; public interface AppenderAttachable { public void addAppender ( Appender newAppender ) ; public Enumeration getAllAppenders ( ) ; public Appender getAppender ( String name ) ; void removeAllAppenders ( ) ; void removeAppender ( Appender appender ) ; void removeAppender ( String name ) ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; static StringBuffer sbuf = new StringBuffer ( ) ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static String getSystemProperty ( String key , String def ) { try { return System . getProperty ( key , def ) ; } catch ( Throwable e ) { LogLog . debug ( "Was not allowed to read system property \"" + key + "\"." ) ; return def ; } } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = findAndSubst ( key , props ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static Priority toPriority ( String value , Priority defaultValue ) { if ( value == null ) return defaultValue ; int hashIndex = value . indexOf ( '#' ) ; if ( hashIndex == - 1 ) { return Priority . toPriority ( value , defaultValue ) ; } Priority result = defaultValue ; String clazz = value . substring ( hashIndex + 1 ) ; String priorityName = value . substring ( 0 , hashIndex ) ; LogLog . debug ( "toPriority" + ":class=[" + clazz + "]" + ":pri=[" + priorityName + "]" ) ; try { Class customPriority = Class . forName ( clazz ) ; Class [ ] paramTypes = new Class [ ] { String . class , org . apache . log4j . Priority . class } ; java . lang . reflect . Method toPriorityMethod = customPriority . getMethod ( "toPriority" , paramTypes ) ; Object [ ] params = new Object [ ] { priorityName , defaultValue } ; Object o = toPriorityMethod . invoke ( null , params ) ; result = ( Priority ) o ; } catch ( ClassNotFoundException e ) { LogLog . warn ( "custom priority class [" + clazz + "] not found." ) ; } catch ( NoSuchMethodException e ) { LogLog . warn ( "custom priority class [" + clazz + "]" + " does not have a constructor which takes one string parameter" , e ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { LogLog . warn ( "custom priority class [" + clazz + "]" + " could not be instantiated" , e ) ; } catch ( ClassCastException e ) { LogLog . warn ( "class [" + clazz + "] is not a subclass of org.apache.log4j.Priority" , e ) ; } catch ( IllegalAccessException e ) { LogLog . warn ( "class [" + clazz + "] cannot be instantiated due to access restrictions" , e ) ; } catch ( Exception e ) { LogLog . warn ( "class [" + clazz + "], priority [" + priorityName + "] conversion failed." , e ) ; } return result ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) { LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" variable." ) ; return defaultValue ; } return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { sbuf . setLength ( 0 ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) return val ; else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = getSystemProperty ( key , null ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) sbuf . append ( replacement ) ; i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url , Hierarchy hierarchy ) { String clazz = url . getRef ( ) ; Configurator configurator = null ; if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { String filename = url . getFile ( ) ; if ( filename != null && filename . endsWith ( ".xml" ) ) { try { configurator = new DOMConfigurator ( ) ; } catch ( NoClassDefFoundError e ) { LogLog . warn ( "Could not find DOMConfigurator!" , e ) ; return ; } } else { configurator = new PropertyConfigurator ( ) ; } } configurator . doConfigure ( url , hierarchy ) ; } } 	1	['15', '1', '0', '20', '63', '103', '17', '6', '12', '0.910714286', '757', '0', '0', '0', '0.154761905', '0', '0', '48.93333333', '11', '3', '3']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; public interface ErrorHandler extends OptionHandler { void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; } 	0	['2', '1', '0', '15', '2', '1', '14', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . spi ; import java . io . Writer ; import java . io . PrintWriter ; import java . util . Vector ; public class ThrowableInformation implements java . io . Serializable { private transient Throwable throwable ; private String [ ] rep ; static private VectorWriter vw = new VectorWriter ( ) ; public ThrowableInformation ( Throwable throwable ) { this . throwable = throwable ; } public Throwable getThrowable ( ) { return throwable ; } public String [ ] getThrowableStrRep ( ) { if ( rep != null ) { return ( String [ ] ) rep . clone ( ) ; } else { throwable . printStackTrace ( vw ) ; rep = vw . toStringArray ( ) ; vw . clear ( ) ; return rep ; } } } class VectorWriter extends PrintWriter { private Vector v ; VectorWriter ( ) { super ( new NullWriter ( ) ) ; v = new Vector ( ) ; } public void println ( Object o ) { v . addElement ( o . toString ( ) ) ; } public void println ( char [ ] s ) { v . addElement ( new String ( s ) ) ; } public void println ( String s ) { v . addElement ( s ) ; } public String [ ] toStringArray ( ) { int len = v . size ( ) ; String [ ] sa = new String [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { sa [ i ] = ( String ) v . elementAt ( i ) ; } return sa ; } public void clear ( ) { v . setSize ( 0 ) ; } } class NullWriter extends Writer { public void close ( ) { } public void flush ( ) { } public void write ( char [ ] cbuf , int off , int len ) { } } 	1	['4', '1', '0', '2', '10', '0', '1', '1', '3', '0.666666667', '43', '1', '1', '0', '0.666666667', '0', '0', '9', '2', '0.75', '2']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . or . MessageRenderer ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSSink { static public void main ( String [ ] args ) { if ( args . length != 3 ) { usage ( "Wrong number of arguments." ) ; } String tcfBindingName = args [ 0 ] ; String topicBindingName = args [ 1 ] ; PropertyConfigurator . configure ( args [ 2 ] ) ; Category . getDefaultHierarchy ( ) . addRenderer ( Message . class , new MessageRenderer ( ) ) ; try { Context ctx = new InitialContext ( ) ; TopicConnectionFactory topicConnectionFactory ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; TopicConnection topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; TopicSession topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; TopicSubscriber topicSubscriber = topicSession . createDurableSubscriber ( topic , "x" ) ; LoggingEvent event ; Category remoteCategory ; while ( true ) { ObjectMessage msg = ( ObjectMessage ) topicSubscriber . receive ( ) ; event = ( LoggingEvent ) msg . getObject ( ) ; remoteCategory = Category . getInstance ( event . categoryName ) ; remoteCategory . callAppenders ( event ) ; } } catch ( Exception e ) { LogLog . error ( "Could not read JMS message." , e ) ; } } protected static Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + JMSSink . class . getName ( ) + " TopicConnectionFactoryBindingName TopicBindingName configFile" ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '7', '31', '10', '0', '7', '2', '0.875', '145', '0', '0', '0', '0.3', '0', '0', '27.6', '3', '1.4', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; public class FileAppender extends WriterAppender { public static final String FILE_OPTION = "File" ; public static final String APPEND_OPTION = "Append" ; protected boolean fileAppend = true ; protected String fileName = null ; protected boolean qwIsOurs = false ; public FileAppender ( ) { } public FileAppender ( Layout layout , OutputStream os ) { super ( layout , os ) ; } public FileAppender ( Layout layout , Writer writer ) { super ( layout , writer ) ; } public FileAppender ( Layout layout , String filename , boolean append ) throws IOException { this . layout = layout ; this . setFile ( filename , append ) ; } public FileAppender ( Layout layout , String filename ) throws IOException { this ( layout , filename , true ) ; } public void setFile ( String file ) { String val = file . trim ( ) ; if ( val . equalsIgnoreCase ( "System.out" ) ) { setWriter ( new OutputStreamWriter ( System . out ) ) ; } else if ( val . equalsIgnoreCase ( "System.err" ) ) { setWriter ( new OutputStreamWriter ( System . err ) ) ; } else { fileName = val ; } } public boolean getAppend ( ) { return fileAppend ; } public String getFile ( ) { return fileName ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { FILE_OPTION , APPEND_OPTION } ) ; } public void setAppend ( boolean flag ) { fileAppend = flag ; } public void activateOptions ( ) { if ( fileName != null ) { try { setFile ( fileName , fileAppend ) ; } catch ( java . io . IOException e ) { errorHandler . error ( "setFile(" + fileName + "," + fileAppend + ") call failed." , e , ErrorCode . FILE_OPEN_FAILURE ) ; } } else { LogLog . warn ( "File option not set for appender [" + name + "]." ) ; LogLog . warn ( "Are you using FileAppender instead of ConsoleAppender?" ) ; } } protected void closeFile ( ) { if ( this . qw != null && this . qwIsOurs ) { try { this . qw . close ( ) ; } catch ( java . io . IOException e ) { LogLog . error ( "Could not close " + qw , e ) ; } } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { reset ( ) ; this . setQWForFiles ( new FileWriter ( fileName , append ) ) ; this . fileName = fileName ; this . fileAppend = append ; this . qwIsOurs = true ; writeHeader ( ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( FILE_OPTION ) ) { String val = value . trim ( ) ; if ( val . equalsIgnoreCase ( "System.out" ) ) { setWriter ( new OutputStreamWriter ( System . out ) ) ; } else if ( val . equalsIgnoreCase ( "System.err" ) ) { setWriter ( new OutputStreamWriter ( System . err ) ) ; } else { fileName = val ; } } else if ( key . equalsIgnoreCase ( APPEND_OPTION ) ) { fileAppend = OptionConverter . toBoolean ( value , fileAppend ) ; } } protected void setQWForFiles ( Writer writer ) { this . qw = new QuietWriter ( writer , errorHandler ) ; } protected void reset ( ) { closeFile ( ) ; this . fileName = null ; if ( qwIsOurs ) { super . reset ( ) ; } else { this . qw = null ; } } } 	1	['16', '3', '1', '8', '40', '0', '1', '7', '13', '0.666666667', '306', '0.6', '0', '0.755555556', '0.322916667', '1', '13', '17.8125', '6', '1.375', '3']
package org . apache . log4j . varia ; import java . io . * ; import java . net . Socket ; import java . net . ServerSocket ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . RollingFileAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . LogLog ; public class ExternallyRolledFileAppender extends RollingFileAppender { static final public String PORT_OPTION = "Port" ; static final public String ROLL_OVER = "RollOver" ; static final public String OK = "OK" ; int port = 0 ; HUP hup ; public ExternallyRolledFileAppender ( ) { } public void activateOptions ( ) { super . activateOptions ( ) ; if ( port != 0 ) { if ( hup != null ) { hup . interrupt ( ) ; } hup = new HUP ( this , port ) ; hup . setDaemon ( true ) ; hup . start ( ) ; } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { PORT_OPTION } ) ; } public void setOption ( String option , String value ) { super . setOption ( option , value ) ; if ( option . equalsIgnoreCase ( PORT_OPTION ) ) { port = OptionConverter . toInt ( value , port ) ; LogLog . debug ( "Port option set to " + port ) ; } } } class HUP extends Thread { int port ; ExternallyRolledFileAppender er ; HUP ( ExternallyRolledFileAppender er , int port ) { this . er = er ; this . port = port ; } public void run ( ) { while ( ! isInterrupted ( ) ) { try { ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; new Thread ( new HUPNode ( socket , er ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } class HUPNode implements Runnable { Socket socket ; DataInputStream dis ; DataOutputStream dos ; ExternallyRolledFileAppender er ; public HUPNode ( Socket socket , ExternallyRolledFileAppender er ) { this . socket = socket ; this . er = er ; try { dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void run ( ) { try { String line = dis . readUTF ( ) ; LogLog . debug ( "Got external roll over signal." ) ; if ( ExternallyRolledFileAppender . ROLL_OVER . equals ( line ) ) { synchronized ( er ) { er . rollOver ( ) ; } dos . writeUTF ( ExternallyRolledFileAppender . OK ) ; } else { dos . writeUTF ( "Expecting [RollOver] string." ) ; } dos . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Unexptected exception. Exiting HUPNode." , e ) ; } } } 	0	['4', '4', '0', '6', '20', '0', '2', '5', '4', '1.066666667', '77', '0', '1', '0.931818182', '0.625', '2', '4', '17', '3', '1.5', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; public class WriterAppender extends AppenderSkeleton { public static final String IMMEDIATE_FLUSH_OPTION = "ImmediateFlush" ; protected boolean immediateFlush = true ; protected QuietWriter qw ; public WriterAppender ( ) { } public WriterAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public WriterAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public void setImmediateFlush ( boolean value ) { immediateFlush = value ; } public boolean getImmediateFlush ( ) { return immediateFlush ; } public void activateOptions ( ) { } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . closed ) { LogLog . warn ( "Not allowed to write to a closed appender." ) ; return false ; } if ( this . qw == null ) { errorHandler . error ( "No output stream or file set for appender named [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for appender named [" + name + "]." ) ; return false ; } return true ; } public synchronized void close ( ) { if ( this . closed ) return ; this . closed = true ; writeFooter ( ) ; reset ( ) ; } protected void closeWriter ( ) { if ( qw != null ) { try { qw . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close " + qw , e ) ; } } } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { IMMEDIATE_FLUSH_OPTION } ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; if ( this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( IMMEDIATE_FLUSH_OPTION ) ) { immediateFlush = OptionConverter . toBoolean ( value , immediateFlush ) ; } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; writeHeader ( ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { this . qw . write ( s [ i ] ) ; this . qw . write ( Layout . LINE_SEP ) ; } } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriter ( ) ; this . qw = null ; } protected void writeFooter ( ) { if ( layout != null ) { String f = layout . getFooter ( ) ; if ( f != null && this . qw != null ) this . qw . write ( f ) ; } } protected void writeHeader ( ) { if ( layout != null ) { String h = layout . getHeader ( ) ; if ( h != null && this . qw != null ) this . qw . write ( h ) ; } } } 	1	['19', '2', '1', '9', '43', '85', '2', '7', '13', '0.703703704', '285', '0.666666667', '1', '0.529411765', '0.190789474', '1', '3', '13.84210526', '5', '1.8947', '4']
package org . apache . log4j . gui . examples ; import java . awt . BorderLayout ; import java . awt . event . * ; import javax . swing . * ; import org . apache . log4j . * ; import org . apache . log4j . gui . * ; public class TextPaneAppenderExample implements ActionListener { JFrame mainframe ; ButtonGroup priorities ; TextPaneAppender tpa ; Category gui ; Priority prio [ ] ; JTabbedPane logview ; public TextPaneAppenderExample ( ) { mainframe = new JFrame ( "Testing the TextPaneAppender..." ) ; mainframe . setSize ( 300 , 300 ) ; logview = new JTabbedPane ( ) ; createLogger ( ) ; createMenuBar ( ) ; mainframe . setVisible ( true ) ; mainframe . getContentPane ( ) . add ( logview ) ; } public void createLogger ( ) { tpa = new TextPaneAppender ( new PatternLayout ( "%-5p %d [%t]:  %m%n" ) , "Debug" ) ; logview . addTab ( "Events ..." , new JScrollPane ( tpa . getTextPane ( ) ) ) ; gui = Category . getInstance ( this . getClass ( ) . getName ( ) ) ; gui . addAppender ( tpa ) ; } public void createMenuBar ( ) { JMenu file = new JMenu ( "File" ) ; JMenuItem exit = new JMenuItem ( "Exit" ) ; exit . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae ) { System . exit ( 0 ) ; } } ) ; file . add ( exit ) ; JMenuBar mb = new JMenuBar ( ) ; mb . add ( file ) ; JMenu logevent = new JMenu ( "LoggingEvents" ) ; JMenu selectprio = new JMenu ( "Priority" ) ; prio = Priority . getAllPossiblePriorities ( ) ; JRadioButtonMenuItem priority [ ] = new JRadioButtonMenuItem [ prio . length ] ; priorities = new ButtonGroup ( ) ; for ( int i = 0 ; i < prio . length ; i ++ ) { if ( i == 0 ) priority [ i ] = new JRadioButtonMenuItem ( prio [ i ] . toString ( ) , true ) ; else priority [ i ] = new JRadioButtonMenuItem ( prio [ i ] . toString ( ) ) ; priority [ i ] . setActionCommand ( prio [ i ] . toString ( ) ) ; selectprio . add ( priority [ i ] ) ; priorities . add ( priority [ i ] ) ; } logevent . add ( selectprio ) ; JMenuItem lognow = new JMenuItem ( "LogIt!" ) ; lognow . addActionListener ( this ) ; logevent . add ( lognow ) ; mb . add ( logevent ) ; mainframe . setJMenuBar ( mb ) ; } public void actionPerformed ( ActionEvent ae ) { String logtext = JOptionPane . showInputDialog ( "Text to log" ) ; if ( logtext == null ) logtext = "NO Input" ; int i = 0 ; String name = priorities . getSelection ( ) . getActionCommand ( ) ; while ( ! prio [ i ] . toString ( ) . equals ( name ) ) i = i + 1 ; gui . log ( prio [ i ] , logtext ) ; } static public void main ( String args [ ] ) { TextPaneAppenderExample tpex = new TextPaneAppenderExample ( ) ; } } 	0	['5', '1', '0', '7', '41', '2', '1', '7', '5', '0.375', '250', '0', '3', '0', '0.4', '0', '0', '47.8', '3', '1.6', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . helpers . OptionConverter ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . io . Writer ; public class HTMLLayout extends Layout { protected final int BUF_SIZE = 256 ; protected final int MAX_CAPACITY = 1024 ; static String TRACE_PREFIX = "<br>&nbsp;&nbsp;&nbsp;&nbsp;" ; private StringBuffer sbuf = new StringBuffer ( BUF_SIZE ) ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String TITLE_OPTION = "Title" ; boolean locationInfo = false ; String title = "Log4J Log Messages" ; public String [ ] getOptionStrings ( ) { return new String [ ] { LOCATION_INFO_OPTION , TITLE_OPTION } ; } public void setOption ( String key , String value ) { if ( value == null ) return ; if ( key . equalsIgnoreCase ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } else if ( key . equalsIgnoreCase ( TITLE_OPTION ) ) { title = value ; } } public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public boolean getLocationInfo ( ) { return locationInfo ; } public void setTitle ( String title ) { this . title = title ; } public String getTitle ( ) { return title ; } public String getContentType ( ) { return "text/html" ; } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( sbuf . capacity ( ) > MAX_CAPACITY ) { sbuf = new StringBuffer ( BUF_SIZE ) ; } else { sbuf . setLength ( 0 ) ; } sbuf . append ( Layout . LINE_SEP + "<tr>" + Layout . LINE_SEP ) ; sbuf . append ( "<td>" ) ; sbuf . append ( event . timeStamp - event . getStartTime ( ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"" + event . getThreadName ( ) + " thread\">" ) ; sbuf . append ( escapeHTMLTags ( event . getThreadName ( ) ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"Priority\">" ) ; if ( event . priority . equals ( Priority . DEBUG ) ) { sbuf . append ( "<font color=\"#339933\">" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</font>" ) ; } else if ( event . priority . isGreaterOrEqual ( Priority . WARN ) ) { sbuf . append ( "<font color=\"#993300\"><strong>" ) ; sbuf . append ( event . priority ) ; sbuf . append ( "</strong></font>" ) ; } else { sbuf . append ( event . priority ) ; } sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "<td title=\"" + event . categoryName + " category\">" ) ; sbuf . append ( escapeHTMLTags ( event . categoryName ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; if ( locationInfo ) { LocationInfo locInfo = event . getLocationInformation ( ) ; sbuf . append ( "<td>" ) ; sbuf . append ( escapeHTMLTags ( locInfo . getFileName ( ) ) ) ; sbuf . append ( ':' ) ; sbuf . append ( locInfo . getLineNumber ( ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; } sbuf . append ( "<td title=\"Message\">" ) ; sbuf . append ( escapeHTMLTags ( event . getRenderedMessage ( ) ) ) ; sbuf . append ( "</td>" + Layout . LINE_SEP ) ; sbuf . append ( "</tr>" + Layout . LINE_SEP ) ; if ( event . getNDC ( ) != null ) { sbuf . append ( "<tr><td bgcolor=\"#EEEEEE\" style=\"font-size : xx-small;\" colspan=\"6\" title=\"Nested Diagnostic Context\">" ) ; sbuf . append ( "NDC: " + escapeHTMLTags ( event . getNDC ( ) ) ) ; sbuf . append ( "</td></tr>" + Layout . LINE_SEP ) ; } String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { sbuf . append ( "<tr><td bgcolor=\"#993300\" style=\"color:White; font-size : xx-small;\" colspan=\"6\">" ) ; appendThrowableAsHTML ( s , sbuf ) ; sbuf . append ( "</td></tr>" + Layout . LINE_SEP ) ; } return sbuf . toString ( ) ; } void appendThrowableAsHTML ( String [ ] s , StringBuffer sbuf ) { if ( s != null ) { int len = s . length ; if ( len == 0 ) return ; sbuf . append ( escapeHTMLTags ( s [ 0 ] ) ) ; sbuf . append ( Layout . LINE_SEP ) ; for ( int i = 1 ; i < len ; i ++ ) { sbuf . append ( TRACE_PREFIX ) ; sbuf . append ( escapeHTMLTags ( s [ i ] ) ) ; sbuf . append ( Layout . LINE_SEP ) ; } } } public String getHeader ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">" + Layout . LINE_SEP ) ; sbuf . append ( "<html>" + Layout . LINE_SEP ) ; sbuf . append ( "<head>" + Layout . LINE_SEP ) ; sbuf . append ( "<title>" + title + "</title>" + Layout . LINE_SEP ) ; sbuf . append ( "<style type=\"text/css\">" + Layout . LINE_SEP ) ; sbuf . append ( "<!--" + Layout . LINE_SEP ) ; sbuf . append ( "body, table {font-family: arial,sans-serif; font-size: x-small;}" + Layout . LINE_SEP ) ; sbuf . append ( "th {background: #336699; color: #FFFFFF; text-align: left;}" + Layout . LINE_SEP ) ; sbuf . append ( "-->" + Layout . LINE_SEP ) ; sbuf . append ( "</style>" + Layout . LINE_SEP ) ; sbuf . append ( "</head>" + Layout . LINE_SEP ) ; sbuf . append ( "<body bgcolor=\"#FFFFFF\" topmargin=\"6\" leftmargin=\"6\">" + Layout . LINE_SEP ) ; sbuf . append ( "<hr size=\"1\" noshade>" + Layout . LINE_SEP ) ; sbuf . append ( "Log session start time " + new java . util . Date ( ) + "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" bordercolor=\"#224466\" width=\"100%\">" + Layout . LINE_SEP ) ; sbuf . append ( "<tr>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Time</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Thread</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Priority</th>" + Layout . LINE_SEP ) ; sbuf . append ( "<th>Category</th>" + Layout . LINE_SEP ) ; if ( locationInfo ) { sbuf . append ( "<th>File:Line</th>" + Layout . LINE_SEP ) ; } sbuf . append ( "<th>Message</th>" + Layout . LINE_SEP ) ; sbuf . append ( "</tr>" + Layout . LINE_SEP ) ; return sbuf . toString ( ) ; } public String getFooter ( ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( "</table>" + Layout . LINE_SEP ) ; sbuf . append ( "<br>" + Layout . LINE_SEP ) ; sbuf . append ( "</body></html>" ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } private String escapeHTMLTags ( String input ) { if ( input == null || input . length ( ) == 0 ) { return input ; } StringBuffer buf = new StringBuffer ( input . length ( ) + 6 ) ; char ch = ' ' ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { ch = input . charAt ( i ) ; if ( ch == '<' ) { buf . append ( "&lt;" ) ; } else if ( ch == '>' ) { buf . append ( "&gt;" ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } } 	1	['16', '2', '0', '5', '41', '74', '0', '5', '13', '0.916666667', '853', '0.375', '0', '0.363636364', '0.244444444', '1', '1', '51.8125', '7', '2', '2']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . Appender ; import org . apache . log4j . FileAppender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . TTCCLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import java . io . IOException ; public class Min { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test1 ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Min " + "simple|ttcc" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String layoutType ) { Appender appender = null ; Layout layout = null ; if ( layoutType . equals ( "simple" ) ) layout = new SimpleLayout ( ) ; else if ( layoutType . equals ( "ttcc" ) ) { layout = new TTCCLayout ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ; } else Usage ( "Wrong layoutType [" + layoutType + "]." ) ; appender = new FileAppender ( layout , System . out ) ; BasicConfigurator . configure ( appender ) ; } static void test1 ( ) { int i = 0 ; Category ERR = Category . getInstance ( "ERR" ) ; ERR . setPriority ( Priority . ERROR ) ; Category INF = Category . getInstance ( "INF" ) ; INF . setPriority ( Priority . INFO ) ; Category INF_ERR = Category . getInstance ( "INF.ERR" ) ; INF_ERR . setPriority ( Priority . ERROR ) ; Category DEB = Category . getInstance ( "DEB" ) ; DEB . setPriority ( Priority . DEBUG ) ; Category INF_UNDEF = Category . getInstance ( "INF.UNDEF" ) ; Category INF_ERR_UNDEF = Category . getInstance ( "INF.ERR.UNDEF" ) ; Category UNDEF = Category . getInstance ( "UNDEF" ) ; ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; ERR . error ( "Message " + i ) ; i ++ ; INF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF . error ( "Message " + i ) ; i ++ ; INF . warn ( "Message " + i ) ; i ++ ; INF . info ( "Message " + i ) ; i ++ ; INF_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_UNDEF . error ( "Message " + i ) ; i ++ ; INF_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR . error ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR_UNDEF . error ( "Message " + i ) ; i ++ ; DEB . log ( Priority . FATAL , "Message " + i ) ; i ++ ; DEB . error ( "Message " + i ) ; i ++ ; DEB . warn ( "Message " + i ) ; i ++ ; DEB . info ( "Message " + i ) ; i ++ ; DEB . debug ( "Message " + i ) ; i ++ ; UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; UNDEF . error ( "Message " + i ) ; i ++ ; UNDEF . warn ( "Message " + i ) ; i ++ ; UNDEF . info ( "Message " + i ) ; i ++ ; UNDEF . debug ( "Message " + i , new Exception ( "Just testing." ) ) ; i ++ ; ERR . warn ( "Message " + i ) ; i ++ ; ERR . info ( "Message " + i ) ; i ++ ; ERR . debug ( "Message " + i ) ; i ++ ; INF . debug ( "Message " + i ) ; i ++ ; INF_UNDEF . debug ( "Message " + i ) ; i ++ ; INF_ERR . warn ( "Message " + i ) ; i ++ ; INF_ERR . info ( "Message " + i ) ; i ++ ; INF_ERR . debug ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . debug ( "Message " + i ) ; i ++ ; INF . info ( "Messages should bear numbers 0 through 23." ) ; } } 	0	['5', '1', '0', '8', '26', '10', '0', '8', '2', '2', '508', '0', '0', '0', '0.266666667', '0', '0', '100.6', '3', '1.4', '0']
package org . apache . log4j ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . RootCategory ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . CategoryFactory ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . Loader ; import org . apache . log4j . or . RendererMap ; import org . apache . log4j . or . ObjectRenderer ; import java . util . Enumeration ; import java . util . Vector ; import java . util . MissingResourceException ; import java . text . MessageFormat ; import java . util . ResourceBundle ; import java . net . URL ; import java . net . MalformedURLException ; public class Category implements AppenderAttachable { static public final Hierarchy defaultHierarchy = new Hierarchy ( new RootCategory ( Priority . DEBUG ) ) ; static public final String DEFAULT_CONFIGURATION_FILE = "log4j.properties" ; static final public String DEFAULT_CONFIGURATION_KEY = "log4j.configuration" ; public static final String DEFAULT_INIT_OVERRIDE_KEY = "log4j.defaultInitOverride" ; static { String override = OptionConverter . getSystemProperty ( DEFAULT_INIT_OVERRIDE_KEY , null ) ; if ( override == null || "false" . equalsIgnoreCase ( override ) ) { String resource = OptionConverter . getSystemProperty ( DEFAULT_CONFIGURATION_KEY , DEFAULT_CONFIGURATION_FILE ) ; URL url = null ; try { url = new URL ( resource ) ; } catch ( MalformedURLException ex ) { url = Loader . getResource ( resource , Object . class ) ; } if ( url != null ) { LogLog . debug ( "Using URL [" + url + "] for automatic log4j configuration." ) ; OptionConverter . selectAndConfigure ( url , defaultHierarchy ) ; } else { LogLog . debug ( "Could not find resource: [" + resource + "]." ) ; } } } protected String name ; volatile protected Priority priority ; volatile protected Category parent ; private static final String FQCN = Category . class . getName ( ) ; protected ResourceBundle resourceBundle ; protected Hierarchy hierarchy ; AppenderAttachableImpl aai ; protected boolean additive = true ; protected Category ( String name ) { this . name = name ; } synchronized public void addAppender ( Appender newAppender ) { if ( aai == null ) { aai = new AppenderAttachableImpl ( ) ; } aai . addAppender ( newAppender ) ; } public void assert ( boolean assertion , String msg ) { if ( ! assertion ) this . error ( msg ) ; } public void callAppenders ( LoggingEvent event ) { int writes = 0 ; for ( Category c = this ; c != null ; c = c . parent ) { synchronized ( c ) { if ( c . aai != null ) { writes += c . aai . appendLoopOnAppenders ( event ) ; } if ( ! c . additive ) { break ; } } } if ( ! hierarchy . emittedNoAppenderWarning && writes == 0 ) { LogLog . error ( "No appenders could be found for category (" + this . getName ( ) + ")." ) ; LogLog . error ( "Please initialize the log4j system properly." ) ; hierarchy . emittedNoAppenderWarning = true ; } } synchronized void closeNestedAppenders ( ) { Enumeration enum = this . getAllAppenders ( ) ; if ( enum != null ) { while ( enum . hasMoreElements ( ) ) { Appender a = ( Appender ) enum . nextElement ( ) ; if ( a instanceof AppenderAttachable ) { a . close ( ) ; } } } } public void debug ( Object message ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return ; if ( Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( FQCN , Priority . DEBUG , message , null ) ; } } public void debug ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return ; if ( this . isEnabledFor ( Priority . DEBUG ) ) forcedLog ( FQCN , Priority . DEBUG , message , t ) ; } public void error ( Object message ) { if ( hierarchy . disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( FQCN , Priority . ERROR , message , null ) ; } public void error ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . ERROR_INT ) return ; if ( this . isEnabledFor ( Priority . ERROR ) ) forcedLog ( FQCN , Priority . ERROR , message , t ) ; } public static Category exists ( String name ) { return defaultHierarchy . exists ( name ) ; } public void fatal ( Object message ) { if ( hierarchy . disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . FATAL , message , null ) ; } public void fatal ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . FATAL_INT ) return ; if ( Priority . FATAL . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . FATAL , message , t ) ; } protected void forcedLog ( String fqcn , Priority priority , Object message , Throwable t ) { callAppenders ( new LoggingEvent ( fqcn , this , priority , message , t ) ) ; } public boolean getAdditivity ( ) { return additive ; } synchronized public Enumeration getAllAppenders ( ) { if ( aai == null ) return NullEnumeration . getInstance ( ) ; else return aai . getAllAppenders ( ) ; } synchronized public Appender getAppender ( String name ) { if ( aai == null || name == null ) return null ; return aai . getAppender ( name ) ; } public Priority getChainedPriority ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . priority != null ) return c . priority ; } return null ; } public static Enumeration getCurrentCategories ( ) { return defaultHierarchy . getCurrentCategories ( ) ; } public static Hierarchy getDefaultHierarchy ( ) { return defaultHierarchy ; } public Hierarchy getHierarchy ( ) { return hierarchy ; } public static Category getInstance ( String name ) { return defaultHierarchy . getInstance ( name ) ; } public static Category getInstance ( Class clazz ) { return getInstance ( clazz . getName ( ) ) ; } public static Category getInstance ( String name , CategoryFactory factory ) { return defaultHierarchy . getInstance ( name , factory ) ; } public final String getName ( ) { return name ; } final public Priority getPriority ( ) { return this . priority ; } final public static Category getRoot ( ) { return defaultHierarchy . getRoot ( ) ; } public ResourceBundle getResourceBundle ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . resourceBundle != null ) return c . resourceBundle ; } return null ; } protected String getResourceBundleString ( String key ) { ResourceBundle rb = getResourceBundle ( ) ; if ( rb == null ) { if ( ! hierarchy . emittedNoResourceBundleWarning ) { error ( "No resource bundle has been set for category " + name ) ; hierarchy . emittedNoResourceBundleWarning = true ; } return null ; } else { try { return rb . getString ( key ) ; } catch ( MissingResourceException mre ) { error ( "No resource is associated with key \"" + key + "\"." ) ; return null ; } } } public void info ( Object message ) { if ( hierarchy . disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . INFO , message , null ) ; } public void info ( Object message , Throwable t ) { if ( hierarchy . disable >= Priority . INFO_INT ) return ; if ( Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , Priority . INFO , message , t ) ; } public boolean isDebugEnabled ( ) { if ( hierarchy . disable >= Priority . DEBUG_INT ) return false ; return Priority . DEBUG . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isEnabledFor ( Priority priority ) { if ( hierarchy . disable >= priority . level ) { return false ; } return priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public boolean isInfoEnabled ( ) { if ( hierarchy . disable >= Priority . INFO_INT ) return false ; return Priority . INFO . isGreaterOrEqual ( this . getChainedPriority ( ) ) ; } public void l7dlog ( Priority priority , String key , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String msg = getResourceBundleString ( key ) ; if ( msg == null ) { msg = key ; } forcedLog ( FQCN , priority , msg , t ) ; } } public void l7dlog ( Priority priority , String key , Object [ ] params , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { String pattern = getResourceBundleString ( key ) ; String msg ; if ( pattern == null ) msg = key ; else msg = java . text . MessageFormat . format ( pattern , params ) ; forcedLog ( FQCN , priority , msg , t ) ; } } public void log ( Priority priority , Object message , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , priority , message , t ) ; } public void log ( Priority priority , Object message ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) forcedLog ( FQCN , priority , message , null ) ; } public void log ( String callerFQCN , Priority priority , Object message , Throwable t ) { if ( hierarchy . disable >= priority . level ) { return ; } if ( priority . isGreaterOrEqual ( this . getChainedPriority ( ) ) ) { forcedLog ( callerFQCN , priority , message , t ) ; } } synchronized public void removeAllAppenders ( ) { if ( aai != null ) { aai . removeAllAppenders ( ) ; aai = null ; } } synchronized public void removeAppender ( Appender appender ) { if ( appender == null || aai == null ) return ; aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { if ( name == null || aai == null ) return ; aai . removeAppender ( name ) ; } public void setAdditivity ( boolean additive ) { this . additive = additive ; } final void setHierarchy ( Hierarchy hierarchy ) { this . hierarchy = hierarchy ; } public void setPriority ( Priority priority ) { this . priority = priority ; } public void setResourceBundle ( ResourceBundle bundle ) { resourceBundle = bundle ; } public static void shutdown ( ) { defaultHierarchy . shutdown ( ) ; } public void warn ( Object message ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( FQCN , Priority . WARN , message , null ) ; } public void warn ( Object message , Throwable t ) { if ( this . isEnabledFor ( Priority . WARN ) ) forcedLog ( FQCN , Priority . WARN , message , t ) ; } } 	1	['50', '1', '2', '46', '90', '637', '38', '12', '43', '0.814868805', '778', '0.5', '5', '0', '0.149136578', '0', '0', '14.28', '6', '2.08', '9']
package org . apache . log4j . test ; public class SpacePad { static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; static public void main ( String [ ] args ) { StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < 35 ; i ++ ) { sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , i ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , 67 ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } static public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['4', '1', '0', '0', '10', '4', '0', '0', '3', '0.333333333', '114', '0', '0', '0', '0.333333333', '0', '0', '27.25', '4', '1.5', '0']
package org . apache . log4j . net ; import java . net . InetAddress ; import java . net . Socket ; import java . io . OutputStream ; import java . io . IOException ; import java . io . ObjectOutputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStreamWriter ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class SocketAppender extends AppenderSkeleton { public static final String REMOTE_HOST_OPTION = "RemoteHost" ; public static final String PORT_OPTION = "Port" ; public static final String LOCATION_INFO_OPTION = "LocationInfo" ; public static final String RECONNECTION_DELAY_OPTION = "ReconnectionDelay" ; static final int DEFAULT_PORT = 4560 ; static final int DEFAULT_RECONNECTION_DELAY = 30000 ; String remoteHost ; InetAddress address ; int port = DEFAULT_PORT ; ObjectOutputStream oos ; int reconnectionDelay = DEFAULT_RECONNECTION_DELAY ; boolean locationInfo = false ; private Connector connector ; int counter = 0 ; private static final int RESET_FREQUENCY = 1 ; public SocketAppender ( ) { } public SocketAppender ( InetAddress address , int port ) { this . address = address ; this . remoteHost = address . getHostName ( ) ; this . port = port ; connect ( address , port ) ; } public SocketAppender ( String host , int port ) { this . port = port ; this . address = getAddressByName ( host ) ; this . remoteHost = host ; connect ( address , port ) ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { REMOTE_HOST_OPTION , PORT_OPTION , LOCATION_INFO_OPTION , RECONNECTION_DELAY_OPTION } ) ; } public void setOption ( String option , String value ) { if ( value == null ) return ; super . setOption ( option , value ) ; if ( option . equals ( REMOTE_HOST_OPTION ) ) { address = getAddressByName ( value ) ; remoteHost = value ; } else if ( option . equals ( PORT_OPTION ) ) { port = OptionConverter . toInt ( value , port ) ; } else if ( option . equals ( LOCATION_INFO_OPTION ) ) { locationInfo = OptionConverter . toBoolean ( value , locationInfo ) ; } else if ( option . equals ( RECONNECTION_DELAY_OPTION ) ) { reconnectionDelay = OptionConverter . toInt ( value , reconnectionDelay ) ; } } public void activateOptions ( ) { connect ( address , port ) ; } synchronized public void close ( ) { if ( closed ) return ; this . closed = true ; cleanUp ( ) ; } public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close oos." , e ) ; } oos = null ; } if ( connector != null ) { connector . interrupted = true ; connector = null ; } } void connect ( InetAddress address , int port ) { if ( this . address == null ) return ; try { cleanUp ( ) ; oos = new ObjectOutputStream ( new Socket ( address , port ) . getOutputStream ( ) ) ; } catch ( IOException e ) { LogLog . error ( "Could not connect to remote log4j server at [" + address . getHostName ( ) + "]. We will try again later." , e ) ; fireConnector ( ) ; } } public void append ( LoggingEvent event ) { if ( event == null ) return ; if ( address == null ) { errorHandler . error ( "No remote host is set for SocketAppender named \"" + this . name + "\"." ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . getLocationInformation ( ) ; } oos . writeObject ( event ) ; oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . warn ( "Detected problem with connection: " + e ) ; if ( reconnectionDelay > 0 ) { fireConnector ( ) ; } } } } void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( "Starting a new connector thread." ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } } static InetAddress getAddressByName ( String host ) { try { return InetAddress . getByName ( host ) ; } catch ( Exception e ) { LogLog . error ( "Could not find address of [" + host + "]." , e ) ; return null ; } } public boolean requiresLayout ( ) { return false ; } public void setRemoteHost ( String host ) { address = getAddressByName ( host ) ; remoteHost = host ; } public String getRemoteHost ( ) { return remoteHost ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return port ; } public void setLocationInfo ( boolean locationInfo ) { this . locationInfo = locationInfo ; } public boolean getLocationInfo ( ) { return locationInfo ; } public void setReconnectionDelay ( int delay ) { this . reconnectionDelay = delay ; } public int getReconnectionDelay ( ) { return reconnectionDelay ; } class Connector extends Thread { boolean interrupted = false ; public void run ( ) { Socket socket ; while ( ! interrupted ) { try { sleep ( reconnectionDelay ) ; LogLog . debug ( "Attempting connection to " + address . getHostName ( ) ) ; socket = new Socket ( address , port ) ; synchronized ( this ) { oos = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; connector = null ; break ; } } catch ( InterruptedException e ) { LogLog . debug ( "Connector interrupted. Leaving loop." ) ; return ; } catch ( java . net . ConnectException e ) { LogLog . debug ( "Remote host " + address . getHostName ( ) + " refused connection." ) ; } catch ( IOException e ) { LogLog . debug ( "Could not connect to " + address . getHostName ( ) + ". Exception is " + e ) ; } } } } } 	1	['22', '2', '0', '9', '51', '95', '3', '7', '18', '0.888888889', '414', '0.133333333', '1', '0.486486486', '0.198863636', '2', '3', '17.13636364', '6', '1.5455', '1']
package org . apache . log4j . gui ; import org . apache . log4j . helpers . CyclicBuffer ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Priority ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PatternLayout ; import org . apache . log4j . spi . LoggingEvent ; import javax . swing . JList ; import javax . swing . AbstractListModel ; import javax . swing . JFrame ; import javax . swing . JButton ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JTextArea ; import javax . swing . JScrollPane ; import javax . swing . ListCellRenderer ; import java . awt . Component ; import java . awt . FlowLayout ; import java . awt . GridLayout ; import javax . swing . BoxLayout ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . ActionListener ; import java . awt . event . ActionEvent ; import java . awt . Container ; import javax . swing . ImageIcon ; import java . awt . Image ; import java . awt . Toolkit ; import java . net . URL ; import java . awt . Rectangle ; public class JListView extends JList { static Category cat = Category . getInstance ( JListView . class . getName ( ) ) ; PatternLayout layout ; static LoggingEvent proto = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " , new Throwable ( ) ) ; public JListView ( JListViewModel model ) { super ( model ) ; layout = new PatternLayout ( "%r %p %c [%t] -  %m" ) ; this . setCellRenderer ( new MyCellRenderer ( ) ) ; } public void add ( LoggingEvent event ) { ( ( JListViewModel ) getModel ( ) ) . add ( event ) ; } static public void main ( String [ ] args ) { JFrame frame = new JFrame ( "JListView test" ) ; Container container = frame . getContentPane ( ) ; JListView view = new JListView ( new JListViewModel ( Integer . parseInt ( args [ 0 ] ) ) ) ; JScrollPane sp = new JScrollPane ( view ) ; sp . setPreferredSize ( new Dimension ( 250 , 80 ) ) ; container . setLayout ( new BoxLayout ( container , BoxLayout . X_AXIS ) ) ; container . add ( sp ) ; JButton b1 = new JButton ( "Add 1" ) ; JButton b10 = new JButton ( "Add 10" ) ; JButton b100 = new JButton ( "Add 100" ) ; JButton b1000 = new JButton ( "Add 1000" ) ; JButton b10000 = new JButton ( "Add 10000" ) ; JPanel panel = new JPanel ( new GridLayout ( 0 , 1 ) ) ; container . add ( panel ) ; panel . add ( b1 ) ; panel . add ( b10 ) ; panel . add ( b100 ) ; panel . add ( b1000 ) ; panel . add ( b10000 ) ; AddAction a1 = new AddAction ( view , 1 ) ; AddAction a10 = new AddAction ( view , 10 ) ; AddAction a100 = new AddAction ( view , 100 ) ; AddAction a1000 = new AddAction ( view , 1000 ) ; AddAction a10000 = new AddAction ( view , 10000 ) ; b1 . addActionListener ( a1 ) ; b10 . addActionListener ( a10 ) ; b100 . addActionListener ( a100 ) ; b1000 . addActionListener ( a1000 ) ; b10000 . addActionListener ( a10000 ) ; frame . setVisible ( true ) ; frame . setSize ( new Dimension ( 700 , 700 ) ) ; long before = System . currentTimeMillis ( ) ; int RUN = 1000 ; int i = 0 ; while ( i ++ < RUN ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . ERROR , "Message " + i , null ) ; event . getThreadName ( ) ; if ( i % 10 == 0 ) { event . throwable = new Exception ( "hello " + i ) ; } view . add ( event ) ; } long after = System . currentTimeMillis ( ) ; System . out . println ( "Time taken :" + ( ( after - before ) * 1000 / RUN ) ) ; } class MyCellRenderer extends JTextArea implements ListCellRenderer { Object o = new Object ( ) ; int i = 0 ; final ImageIcon longIcon = new ImageIcon ( "RedFlag.gif" ) ; public MyCellRenderer ( ) { System . out . println ( "----------------------" ) ; } public int getTabSize ( ) { return 2 ; } public Image loadIcon ( String path ) { Image img = null ; try { URL url = ClassLoader . getSystemResource ( path ) ; img = ( Image ) ( Toolkit . getDefaultToolkit ( ) ) . getImage ( url ) ; } catch ( Exception e ) { System . out . println ( "Exception occured: " + e . getMessage ( ) + " - " + e ) ; } return ( img ) ; } public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { if ( value instanceof LoggingEvent ) { LoggingEvent event = ( LoggingEvent ) value ; String str = layout . format ( event ) ; String t = event . getThrowableInformation ( ) ; if ( t != null ) { setText ( str + Layout . LINE_SEP + t ) ; } else { setText ( str ) ; } } else { setText ( value . toString ( ) ) ; } return this ; } } } class JListViewModel extends AbstractListModel { CyclicBuffer cb ; JListViewModel ( int size ) { cb = new CyclicBuffer ( size ) ; } public void add ( LoggingEvent event ) { cb . add ( event ) ; int j = cb . length ( ) ; fireContentsChanged ( this , 0 , j ) ; } public Object getElementAt ( int index ) { return cb . get ( index ) ; } public int getSize ( ) { return cb . length ( ) ; } } class AddAction implements ActionListener { Thread t ; static int counter = 0 ; public AddAction ( JListView view , int burst ) { this . t = new AddThread ( view , burst ) ; t . start ( ) ; } public void actionPerformed ( ActionEvent e ) { System . out . println ( "Action occured" ) ; synchronized ( t ) { t . notify ( ) ; } } class AddThread extends Thread { int burst ; JListView view ; Category cat = Category . getInstance ( "x" ) ; AddThread ( JListView view , int burst ) { super ( ) ; this . burst = burst ; this . view = view ; setName ( "AddThread" + burst ) ; } public void run ( ) { while ( true ) { synchronized ( this ) { try { this . wait ( ) ; } catch ( Exception e ) { } } for ( int i = 0 ; i < burst ; i ++ ) { LoggingEvent event = new LoggingEvent ( "x" , cat , Priority . DEBUG , "Message " + counter , null ) ; event . getThreadName ( ) ; if ( counter % 50 == 0 ) { event . throwable = new Exception ( "hello " + counter ) ; } counter ++ ; view . add ( event ) ; } } } } } 	0	['5', '5', '0', '8', '44', '8', '3', '7', '3', '0.875', '289', '0', '3', '0.995695839', '0.3', '0', '0', '56', '3', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . FileAppender ; public interface OptionHandler { void activateOptions ( ) ; String [ ] getOptionStrings ( ) ; void setOption ( String option , String value ) ; } 	1	['3', '1', '0', '7', '3', '3', '7', '0', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '1']
package org . apache . log4j . or ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	0	['9', '1', '0', '5', '19', '10', '3', '2', '7', '0.375', '120', '0', '1', '0', '0.4375', '0', '0', '12.11111111', '4', '1.6667', '0']
package org . apache . log4j ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . util . Enumeration ; public class BasicConfigurator { public static final String DISABLE_OVERRIDE_KEY = "log4j.disableOverride" ; public static final String DISABLE_KEY = "log4j.disable" ; public static final String INHERITED = "inherited" ; static { String override = OptionConverter . getSystemProperty ( DISABLE_OVERRIDE_KEY , null ) ; if ( override != null ) { Category . defaultHierarchy . setDisableOverride ( override ) ; } else { String disableStr = OptionConverter . getSystemProperty ( DISABLE_KEY , null ) ; if ( disableStr != null ) { Category . defaultHierarchy . disable ( disableStr ) ; } } } protected BasicConfigurator ( ) { } protected void addRenderer ( Hierarchy hierarchy , String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not instantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; hierarchy . rendererMap . put ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } public static void disable ( String priorityStr ) { Category . getDefaultHierarchy ( ) . disable ( priorityStr ) ; } public static void disable ( Priority p ) { } public static void disableAll ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . FATAL ) ; } public static void disableDebug ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . DEBUG ) ; } public static void disableInfo ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . INFO ) ; } public static void enableAll ( ) { Category . getDefaultHierarchy ( ) . disable ( Priority . INFO ) ; } static public void configure ( ) { Category root = Category . getRoot ( ) ; root . addAppender ( new ConsoleAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) ) ) ; } static public void configure ( Appender appender ) { Category root = Category . getRoot ( ) ; root . addAppender ( appender ) ; } public static void resetConfiguration ( ) { Category . defaultHierarchy . resetConfiguration ( ) ; } public static void resetConfiguration ( Hierarchy hierarchy ) { hierarchy . resetConfiguration ( ) ; } } 	1	['14', '1', '1', '17', '36', '91', '6', '11', '10', '1.057692308', '161', '0', '0', '0', '0.138461538', '0', '0', '10.21428571', '3', '1', '2']
package org . apache . log4j . test ; import java . util . Properties ; import org . apache . log4j . Category ; import org . apache . log4j . Hierarchy ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class SysoutConfigurator implements Configurator { public void doConfigure ( java . net . URL url , Hierarchy hierarchy ) { Category . getRoot ( ) . addAppender ( new FileAppender ( new SimpleLayout ( ) , System . out ) ) ; } } 	0	['2', '1', '0', '7', '7', '1', '0', '7', '2', '2', '15', '0', '0', '0', '0.666666667', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import java . util . Properties ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSAppender extends AppenderSkeleton { public static final String TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION = "TopicConnectionFactoryBindingName" ; public static final String TOPIC_BINDING_NAME_OPTION = "TopicBindingName" ; TopicConnection topicConnection ; TopicSession topicSession ; TopicPublisher topicPublisher ; String topicBindingName ; String tcfBindingName ; public JMSAppender ( ) { } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { TOPIC_BINDING_NAME_OPTION , TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION } ) ; } public void setOption ( String key , String value ) { if ( value == null ) return ; super . setOption ( key , value ) ; if ( key . equals ( TOPIC_BINDING_NAME_OPTION ) ) topicBindingName = value ; else if ( key . equals ( TOPIC_CONNECTION_FACTORY_BINDING_NAME_OPTION ) ) { tcfBindingName = value ; } } public void setTopicConnectionFactoryBindingName ( String tcfBindingName ) { this . tcfBindingName = tcfBindingName ; } public String getTopicConnectionFactoryBindingName ( ) { return tcfBindingName ; } public void setTopicBindingName ( String topicBindingName ) { this . topicBindingName = topicBindingName ; } public String getTopicBindingName ( ) { return topicBindingName ; } public void activateOptions ( ) { TopicConnectionFactory topicConnectionFactory ; try { Context ctx = new InitialContext ( ) ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) lookup ( ctx , topicBindingName ) ; topicPublisher = topicSession . createPublisher ( topic ) ; ctx . close ( ) ; } catch ( Exception e ) { errorHandler . error ( "Error while activating options for appender named [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } protected Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } protected boolean checkEntryConditions ( ) { String fail = null ; if ( this . topicConnection == null ) { fail = "No TopicConnection" ; } else if ( this . topicSession == null ) { fail = "No TopicSession" ; } else if ( this . topicPublisher == null ) { fail = "No TopicPublisher" ; } if ( fail != null ) { errorHandler . error ( fail + " for JMSAppender named [" + name + "]." ) ; return false ; } else { return true ; } } public synchronized void close ( ) { if ( this . closed ) return ; LogLog . debug ( "Closing appender [" + name + "]." ) ; this . closed = true ; try { if ( topicSession != null ) topicSession . close ( ) ; if ( topicConnection != null ) topicConnection . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Error while closing JMSAppender [" + name + "]." , e ) ; } topicPublisher = null ; topicSession = null ; topicConnection = null ; } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } try { ObjectMessage msg = topicSession . createObjectMessage ( ) ; msg . setObject ( event ) ; topicPublisher . publish ( msg ) ; } catch ( Exception e ) { errorHandler . error ( "Could not publish message in JMSAppender [" + name + "]." , e , ErrorCode . GENERIC_FAILURE ) ; } } public boolean requiresLayout ( ) { return false ; } } 	1	['13', '2', '0', '5', '38', '44', '0', '5', '11', '0.845238095', '284', '0', '0', '0.6', '0.365384615', '2', '3', '20.30769231', '5', '1.6923', '2']
package org . apache . log4j ; import org . apache . log4j . spi . CategoryFactory ; class DefaultCategoryFactory implements CategoryFactory { DefaultCategoryFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new Category ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '1', '2', '10', '0', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . log4j ; import java . beans . * ; import java . io . IOException ; import java . io . Writer ; import java . io . FileWriter ; import java . io . File ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . CountingQuietWriter ; import org . apache . log4j . spi . LoggingEvent ; public class RollingFileAppender extends FileAppender { static final public String MAX_FILE_SIZE_OPTION = "MaxFileSize" ; static final public String MAX_BACKUP_INDEX_OPTION = "MaxBackupIndex" ; protected long maxFileSize = 10 * 1024 * 1024 ; protected int maxBackupIndex = 1 ; public RollingFileAppender ( ) { super ( ) ; } public RollingFileAppender ( Layout layout , String filename , boolean append ) throws IOException { super ( layout , filename , append ) ; } public RollingFileAppender ( Layout layout , String filename ) throws IOException { super ( layout , filename ) ; } public int getMaxBackupIndex ( ) { return maxBackupIndex ; } public long getMaximumFileSize ( ) { return maxFileSize ; } public String [ ] getOptionStrings ( ) { return OptionConverter . concatanateArrays ( super . getOptionStrings ( ) , new String [ ] { MAX_FILE_SIZE_OPTION , MAX_BACKUP_INDEX_OPTION } ) ; } public void rollOver ( ) { File target ; File file ; LogLog . debug ( "rolling over count=" + ( ( CountingQuietWriter ) qw ) . getCount ( ) ) ; LogLog . debug ( "maxBackupIndex=" + maxBackupIndex ) ; if ( maxBackupIndex > 0 ) { file = new File ( fileName + '.' + maxBackupIndex ) ; if ( file . exists ( ) ) file . delete ( ) ; for ( int i = maxBackupIndex - 1 ; i >= 1 ; i -- ) { file = new File ( fileName + "." + i ) ; if ( file . exists ( ) ) { target = new File ( fileName + '.' + ( i + 1 ) ) ; LogLog . debug ( "Renaming file " + file + " to " + target ) ; file . renameTo ( target ) ; } } target = new File ( fileName + "." + 1 ) ; this . closeFile ( ) ; file = new File ( fileName ) ; LogLog . debug ( "Renaming file " + file + " to " + target ) ; file . renameTo ( target ) ; } try { this . setFile ( fileName , false ) ; } catch ( IOException e ) { LogLog . error ( "setFile(" + fileName + ", false) call failed." , e ) ; } } public synchronized void setFile ( String fileName , boolean append ) throws IOException { super . setFile ( fileName , append ) ; if ( append ) { File f = new File ( fileName ) ; ( ( CountingQuietWriter ) qw ) . setCount ( f . length ( ) ) ; } } public void setOption ( String key , String value ) { super . setOption ( key , value ) ; if ( key . equalsIgnoreCase ( MAX_FILE_SIZE_OPTION ) ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } else if ( key . equalsIgnoreCase ( MAX_BACKUP_INDEX_OPTION ) ) { maxBackupIndex = OptionConverter . toInt ( value , maxBackupIndex ) ; } } public void setMaxBackupIndex ( int maxBackups ) { this . maxBackupIndex = maxBackups ; } public void setMaxFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setMaximumFileSize ( long maxFileSize ) { this . maxFileSize = maxFileSize ; } public void setMaxFileSize ( String value ) { maxFileSize = OptionConverter . toFileSize ( value , maxFileSize + 1 ) ; } protected void setQWForFiles ( Writer writer ) { this . qw = new CountingQuietWriter ( writer , errorHandler ) ; } protected void subAppend ( LoggingEvent event ) { super . subAppend ( event ) ; if ( ( fileName != null ) && ( ( CountingQuietWriter ) qw ) . getCount ( ) >= maxFileSize ) this . rollOver ( ) ; } } 	1	['15', '3', '0', '10', '44', '3', '0', '10', '13', '0.767857143', '334', '0.5', '0', '0.733333333', '0.241666667', '1', '10', '21', '5', '1.3333', '1']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int priority ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | priority ) + ">" + string ) ; } } 	0	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '0']
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { public static final String THRESHOLD_OPTION = "Threshold" ; protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public Filter getFilter ( ) { return headFilter ; } public final Filter getFirstFilter ( ) { return headFilter ; } public Layout getLayout ( ) { return layout ; } public final String getName ( ) { return this . name ; } public String [ ] getOptionStrings ( ) { return new String [ ] { THRESHOLD_OPTION } ; } public Priority getThreshold ( ) { return threshold ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; } if ( ! isAsSevereAsThreshold ( event . priority ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( THRESHOLD_OPTION ) ) { threshold = Priority . toPriority ( value ) ; } } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	1	['22', '1', '8', '20', '35', '175', '11', '9', '21', '0.904761905', '193', '0.875', '5', '0', '0.201298701', '0', '0', '7.409090909', '4', '1.3636', '4']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '0']
package org . apache . log4j . chainsaw ; import java . util . StringTokenizer ; import org . apache . log4j . Priority ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; class XMLFileHandler extends DefaultHandler { private static final String TAG_EVENT = "log4j:event" ; private static final String TAG_MESSAGE = "log4j:message" ; private static final String TAG_NDC = "log4j:NDC" ; private static final String TAG_THROWABLE = "log4j:throwable" ; private static final String TAG_LOCATION_INFO = "log4j:locationInfo" ; private final MyTableModel mModel ; private int mNumEvents ; private String mCurrentElement ; private long mTimeStamp ; private Priority mPriority ; private String mCategoryName ; private String mNDC ; private String mThreadName ; private String mMessage ; private String [ ] mThrowableStrRep ; private String mLocationDetails ; XMLFileHandler ( MyTableModel aModel ) { mModel = aModel ; } public void startDocument ( ) throws SAXException { mNumEvents = 0 ; } public void characters ( char [ ] aChars , int aStart , int aLength ) { if ( mCurrentElement == TAG_NDC ) { mNDC = new String ( aChars , aStart , aLength ) ; } else if ( mCurrentElement == TAG_MESSAGE ) { mMessage = new String ( aChars , aStart , aLength ) ; } else if ( mCurrentElement == TAG_THROWABLE ) { final StringTokenizer st = new StringTokenizer ( new String ( aChars , aStart , aLength ) , "\t" ) ; mThrowableStrRep = new String [ st . countTokens ( ) ] ; if ( mThrowableStrRep . length > 0 ) { mThrowableStrRep [ 0 ] = st . nextToken ( ) ; for ( int i = 1 ; i < mThrowableStrRep . length ; i ++ ) { mThrowableStrRep [ i ] = "\t" + st . nextToken ( ) ; } } } } public void endElement ( String aNamespaceURI , String aLocalName , String aQName ) { if ( TAG_EVENT . equals ( aQName ) ) { addEvent ( ) ; resetData ( ) ; } else if ( mCurrentElement != TAG_EVENT ) { mCurrentElement = TAG_EVENT ; } } public void startElement ( String aNamespaceURI , String aLocalName , String aQName , Attributes aAtts ) { if ( TAG_EVENT . equals ( aQName ) ) { mThreadName = aAtts . getValue ( "thread" ) ; mTimeStamp = Long . parseLong ( aAtts . getValue ( "timestamp" ) ) ; mCategoryName = aAtts . getValue ( "category" ) ; mPriority = Priority . toPriority ( aAtts . getValue ( "level" ) ) ; } else if ( TAG_LOCATION_INFO . equals ( aQName ) ) { mLocationDetails = aAtts . getValue ( "class" ) + "." + aAtts . getValue ( "method" ) + "(" + aAtts . getValue ( "file" ) + ":" + aAtts . getValue ( "line" ) + ")" ; } else if ( TAG_NDC . equals ( aQName ) ) { mCurrentElement = TAG_NDC ; } else if ( TAG_MESSAGE . equals ( aQName ) ) { mCurrentElement = TAG_MESSAGE ; } else if ( TAG_THROWABLE . equals ( aQName ) ) { mCurrentElement = TAG_THROWABLE ; } } int getNumEvents ( ) { return mNumEvents ; } private void addEvent ( ) { mModel . addEvent ( new EventDetails ( mTimeStamp , mPriority , mCategoryName , mNDC , mThreadName , mMessage , mThrowableStrRep , mLocationDetails ) ) ; mNumEvents ++ ; } private void resetData ( ) { mTimeStamp = 0 ; mPriority = null ; mCategoryName = null ; mNDC = null ; mThreadName = null ; mMessage = null ; mThrowableStrRep = null ; mLocationDetails = null ; } } 	1	['8', '2', '0', '4', '22', '4', '1', '3', '4', '0.767857143', '273', '1', '2', '0.708333333', '0.291666667', '1', '2', '31.125', '6', '2.375', '3']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import org . apache . log4j . net . SocketAppender ; public class Loop { public static void main ( String [ ] args ) { Category root = Category . getRoot ( ) ; Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; if ( args . length != 2 ) usage ( "Wrong number of arguments." ) ; String host = args [ 0 ] ; int port = 0 ; try { port = Integer . valueOf ( args [ 1 ] ) . intValue ( ) ; } catch ( NumberFormatException e ) { usage ( "Argument [" + args [ 1 ] + "] is not in proper int form." ) ; } SocketAppender sa = new SocketAppender ( host , port ) ; Layout layout = new PatternLayout ( "%5p [%t] %x %c - %m\n" ) ; FileAppender so = new FileAppender ( layout , System . out ) ; root . addAppender ( sa ) ; root . addAppender ( so ) ; int i = 0 ; while ( true ) { NDC . push ( "" + ( i ++ ) ) ; cat . debug ( "Debug message." ) ; root . info ( "Info message." ) ; NDC . pop ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + " host port" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '7', '27', '4', '0', '7', '2', '0.666666667', '134', '0', '0', '0', '0.333333333', '0', '0', '32.25', '3', '1.5', '0']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggerRepository ; import java . net . URL ; public interface Configurator { public static final String INHERITED = "inherited" ; void doConfigure ( URL url , LoggerRepository repository ) ; } 	1	['1', '1', '0', '7', '1', '0', '6', '1', '1', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; public class ThreadGroupRenderer implements ObjectRenderer { public ThreadGroupRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof ThreadGroup ) { StringBuffer sbuf = new StringBuffer ( ) ; ThreadGroup tg = ( ThreadGroup ) o ; sbuf . append ( "java.lang.ThreadGroup[name=" ) ; sbuf . append ( tg . getName ( ) ) ; sbuf . append ( ", maxpri=" ) ; sbuf . append ( tg . getMaxPriority ( ) ) ; sbuf . append ( "]" ) ; Thread [ ] t = new Thread [ tg . activeCount ( ) ] ; tg . enumerate ( t ) ; for ( int i = 0 ; i < t . length ; i ++ ) { sbuf . append ( Layout . LINE_SEP ) ; sbuf . append ( "   Thread=[" ) ; sbuf . append ( t [ i ] . getName ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . getPriority ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . isDaemon ( ) ) ; sbuf . append ( "]" ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '2', '16', '1', '0', '2', '2', '2', '100', '0', '0', '0', '0.75', '0', '0', '49', '3', '1.5', '0']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	1	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '1']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class SyslogMin { static Category CAT = Category . getInstance ( SyslogMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SyslogMin . class + " configFile" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String configFile ) { int port = 0 ; PropertyConfigurator . configure ( configFile ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; CAT . debug ( "Message " + i ++ ) ; CAT . info ( "Message " + i ++ ) ; CAT . warn ( "Message " + i ++ ) ; CAT . error ( "Message " + i ++ ) ; CAT . log ( Priority . FATAL , "Message " + i ++ ) ; CAT . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '4', '29', '17', '0', '4', '2', '0.666666667', '154', '0', '1', '0', '0.333333333', '0', '0', '20.71428571', '2', '1', '0']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	1	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '2']
package org . apache . log4j . varia . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class Loop { static Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + "configFile loopLength" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String loopStr ) { PropertyConfigurator . configure ( configFile ) ; try { loopLength = Integer . parseInt ( loopStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret loopLength [" + loopStr + "]." ) ; } } static void test ( ) { for ( int i = 0 ; i < loopLength ; i ++ ) { Thread . yield ( ) ; cat . debug ( "MSG " + i ) ; } } } 	0	['7', '1', '0', '2', '24', '15', '0', '2', '2', '0.611111111', '117', '0', '1', '0', '0.277777778', '0', '0', '15.28571429', '2', '1.1429', '0']
package org . apache . log4j . varia ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import org . apache . log4j . Logger ; import org . apache . log4j . helpers . LogLog ; import java . util . Vector ; public class FallbackErrorHandler implements ErrorHandler { Appender backup ; Appender primary ; Vector loggers ; public FallbackErrorHandler ( ) { } public void setLogger ( Logger logger ) { LogLog . debug ( "FB: Adding logger [" + logger . getName ( ) + "]." ) ; if ( loggers == null ) { loggers = new Vector ( ) ; } loggers . addElement ( logger ) ; } public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { error ( message , e , errorCode , null ) ; } public void error ( String message , Exception e , int errorCode , LoggingEvent event ) { for ( int i = 0 ; i < loggers . size ( ) ; i ++ ) { Logger l = ( Logger ) loggers . elementAt ( i ) ; LogLog . debug ( "FB: Searching for [" + primary . getName ( ) + "] in logger" + l . getName ( ) ) ; LogLog . debug ( "FB: Replacing [" + primary . getName ( ) + "] by [" + backup . getName ( ) + " in logger" + l ) ; l . removeAppender ( primary ) ; LogLog . debug ( "FB: Adding appender [" + backup . getName ( ) + "] to logger " + l . getName ( ) ) ; l . addAppender ( backup ) ; } } public void error ( String message ) { } public void setAppender ( Appender primary ) { LogLog . debug ( "FB: Setting primary appender to [" + primary . getName ( ) + "]." ) ; this . primary = primary ; } public void setBackupAppender ( Appender backup ) { LogLog . debug ( "FB: Setting backup appender to [" + backup . getName ( ) + "]." ) ; this . backup = backup ; } } 	1	['8', '1', '0', '6', '22', '22', '0', '6', '8', '0.714285714', '157', '0', '2', '0', '0.339285714', '0', '0', '18.25', '2', '1.125', '3']
package org . apache . log4j . varia ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import java . io . IOException ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . net . Socket ; public class Roller { static Category cat = Category . getInstance ( Roller . class . getName ( ) ) ; static String host ; static int port ; Roller ( ) { } public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; roll ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Roller . class . getName ( ) + "host_name port_number" ) ; System . exit ( 1 ) ; } static void init ( String hostArg , String portArg ) { host = hostArg ; try { port = Integer . parseInt ( portArg ) ; } catch ( java . lang . NumberFormatException e ) { usage ( "Second argument " + portArg + " is not a valid integer." ) ; } } static void roll ( ) { try { Socket socket = new Socket ( host , port ) ; DataOutputStream dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; DataInputStream dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos . writeUTF ( ExternallyRolledFileAppender . ROLL_OVER ) ; String rc = dis . readUTF ( ) ; if ( ExternallyRolledFileAppender . OK . equals ( rc ) ) { cat . info ( "Roll over signal acknowledged by remote appender." ) ; } else { cat . warn ( "Unexpected return code " + rc + " from remote entity." ) ; System . exit ( 2 ) ; } } catch ( IOException e ) { cat . error ( "Could not send roll signal on host " + host + " port " + port + " ." , e ) ; System . exit ( 2 ) ; } System . exit ( 0 ) ; } } 	0	['7', '1', '0', '2', '32', '15', '0', '2', '1', '0.625', '168', '0', '1', '0', '0.277777778', '0', '0', '22.42857143', '2', '1.1429', '0']
package org . apache . log4j . chainsaw ; import org . apache . log4j . Priority ; import org . apache . log4j . spi . LoggingEvent ; class EventDetails { private final long mTimeStamp ; private final Priority mPriority ; private final String mCategoryName ; private final String mNDC ; private final String mThreadName ; private final String mMessage ; private final String [ ] mThrowableStrRep ; private final String mLocationDetails ; EventDetails ( long aTimeStamp , Priority aPriority , String aCategoryName , String aNDC , String aThreadName , String aMessage , String [ ] aThrowableStrRep , String aLocationDetails ) { mTimeStamp = aTimeStamp ; mPriority = aPriority ; mCategoryName = aCategoryName ; mNDC = aNDC ; mThreadName = aThreadName ; mMessage = aMessage ; mThrowableStrRep = aThrowableStrRep ; mLocationDetails = aLocationDetails ; } EventDetails ( LoggingEvent aEvent ) { this ( aEvent . timeStamp , aEvent . level , aEvent . categoryName , aEvent . getNDC ( ) , aEvent . getThreadName ( ) , aEvent . getRenderedMessage ( ) , aEvent . getThrowableStrRep ( ) , ( aEvent . getLocationInformation ( ) == null ) ? null : aEvent . getLocationInformation ( ) . fullInfo ) ; } long getTimeStamp ( ) { return mTimeStamp ; } Priority getPriority ( ) { return mPriority ; } String getCategoryName ( ) { return mCategoryName ; } String getNDC ( ) { return mNDC ; } String getThreadName ( ) { return mThreadName ; } String getMessage ( ) { return mMessage ; } String getLocationDetails ( ) { return mLocationDetails ; } String [ ] getThrowableStrRep ( ) { return mThrowableStrRep ; } } 	1	['10', '1', '0', '9', '16', '29', '6', '3', '0', '0.777777778', '94', '1', '1', '0', '0.25', '0', '0', '7.6', '1', '0.8', '2']
package org . apache . log4j . xml . test ; import org . apache . log4j . Priority ; public class TPriority extends Priority { static final int TRACE_INT = 8000 ; static final int SYSLOG_TRACE_INT = 7 ; private static String TRACE_STR = "TRACE" ; public static final TPriority TRACE = new TPriority ( TRACE_INT , "TRACE" , 7 ) ; protected TPriority ( int level , String strLevel , int syslogEquiv ) { super ( level , strLevel , syslogEquiv ) ; } public static Priority toPriority ( String sArg ) { if ( sArg == null ) return TPriority . TRACE ; String stringVal = sArg . toUpperCase ( ) ; if ( stringVal . equalsIgnoreCase ( TRACE_STR ) ) return TPriority . TRACE ; return Priority . toPriority ( sArg ) ; } public static Priority toPriority ( int i ) throws IllegalArgumentException { switch ( i ) { case TRACE_INT : return TPriority . TRACE ; } return Priority . toPriority ( i ) ; } } 	0	['4', '2', '0', '2', '9', '0', '1', '1', '2', '0.916666667', '47', '0.25', '1', '0.8', '0.555555556', '0', '0', '9.75', '3', '1.25', '0']
package org . apache . log4j . nt ; import org . apache . log4j . * ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Level ; import org . apache . log4j . helpers . LogLog ; import java . io . * ; public class NTEventLogAppender extends AppenderSkeleton { private int _handle = 0 ; private String source = null ; private String server = null ; private static final int FATAL = Level . FATAL . toInt ( ) ; private static final int ERROR = Level . ERROR . toInt ( ) ; private static final int WARN = Level . WARN . toInt ( ) ; private static final int INFO = Level . INFO . toInt ( ) ; private static final int DEBUG = Level . DEBUG . toInt ( ) ; public NTEventLogAppender ( ) { this ( null , null , null ) ; } public NTEventLogAppender ( String source ) { this ( null , source , null ) ; } public NTEventLogAppender ( String server , String source ) { this ( server , source , null ) ; } public NTEventLogAppender ( Layout layout ) { this ( null , null , layout ) ; } public NTEventLogAppender ( String source , Layout layout ) { this ( null , source , layout ) ; } public NTEventLogAppender ( String server , String source , Layout layout ) { if ( source == null ) { source = "Log4j" ; } if ( layout == null ) { this . layout = new TTCCLayout ( ) ; } else { this . layout = layout ; } try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; _handle = 0 ; } } public void close ( ) { } public void activateOptions ( ) { if ( source != null ) { try { _handle = registerEventSource ( server , source ) ; } catch ( Exception e ) { LogLog . error ( "Could not register event source." , e ) ; _handle = 0 ; } } } public void append ( LoggingEvent event ) { StringBuffer sbuf = new StringBuffer ( ) ; sbuf . append ( layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { sbuf . append ( s [ i ] ) ; } } } int nt_category = event . level . toInt ( ) ; reportEvent ( _handle , sbuf . toString ( ) , nt_category ) ; } public void finalize ( ) { deregisterEventSource ( _handle ) ; _handle = 0 ; } public void setSource ( String source ) { this . source = source . trim ( ) ; } public String getSource ( ) { return source ; } public boolean requiresLayout ( ) { return true ; } native private int registerEventSource ( String server , String source ) ; native private void reportEvent ( int handle , String message , int level ) ; native private void deregisterEventSource ( int handle ) ; static { System . loadLibrary ( "NTEventLogAppender" ) ; } } 	1	['17', '2', '0', '8', '30', '114', '1', '7', '13', '0.828125', '200', '1', '0', '0.642857143', '0.3625', '1', '1', '10.29411765', '4', '0.8235', '4']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . log4j . or . jms ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . or . ObjectRenderer ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	1	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '2']
package org . apache . log4j . helpers ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class RelativeTimeDateFormat extends DateFormat { protected final long startTime ; public RelativeTimeDateFormat ( ) { this . startTime = System . currentTimeMillis ( ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { return sbuf . append ( ( date . getTime ( ) - startTime ) ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['3', '3', '0', '1', '7', '1', '1', '0', '3', '0.5', '20', '1', '0', '0.951219512', '0.444444444', '1', '3', '5.333333333', '1', '0.6667', '0']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	1	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '2']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; import org . apache . log4j . Layout ; import org . apache . log4j . Priority ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } FileAppender appender = new FileAppender ( new SimpleLayout ( ) , System . err ) ; if ( "false" . equals ( args [ 0 ] ) ) ; else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; BasicConfigurator . disableInfo ( ) ; } else Usage ( ) ; SHORT_CAT . setPriority ( Priority . INFO ) ; Category . getRoot ( ) . setPriority ( Priority . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	0	['8', '1', '0', '6', '30', '22', '0', '6', '2', '0.942857143', '324', '0', '7', '0', '0.285714286', '0', '0', '38.25', '5', '2', '0']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	1	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '2']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	0	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '0']
package org . apache . log4j . lf5 . util ; import org . apache . log4j . lf5 . LogLevel ; import org . apache . log4j . lf5 . LogRecord ; import org . apache . log4j . lf5 . viewer . LogBrokerMonitor ; import java . awt . * ; import java . util . Arrays ; import java . util . List ; public class LogMonitorAdapter { public static final int LOG4J_LOG_LEVELS = 0 ; public static final int JDK14_LOG_LEVELS = 1 ; private LogBrokerMonitor _logMonitor ; private LogLevel _defaultLevel = null ; private LogMonitorAdapter ( List userDefinedLevels ) { super ( ) ; _defaultLevel = ( LogLevel ) userDefinedLevels . get ( 0 ) ; _logMonitor = new LogBrokerMonitor ( userDefinedLevels ) ; _logMonitor . setFrameSize ( getDefaultMonitorWidth ( ) , getDefaultMonitorHeight ( ) ) ; _logMonitor . setFontSize ( 12 ) ; _logMonitor . show ( ) ; } public static LogMonitorAdapter newInstance ( int loglevels ) { LogMonitorAdapter adapter ; if ( loglevels == JDK14_LOG_LEVELS ) { adapter = newInstance ( LogLevel . getJdk14Levels ( ) ) ; adapter . setDefaultLevel ( LogLevel . FINEST ) ; adapter . setSevereLevel ( LogLevel . SEVERE ) ; } else { adapter = newInstance ( LogLevel . getLog4JLevels ( ) ) ; adapter . setDefaultLevel ( LogLevel . DEBUG ) ; adapter . setSevereLevel ( LogLevel . FATAL ) ; } return adapter ; } public static LogMonitorAdapter newInstance ( LogLevel [ ] userDefined ) { if ( userDefined == null ) { return null ; } return newInstance ( Arrays . asList ( userDefined ) ) ; } public static LogMonitorAdapter newInstance ( List userDefinedLevels ) { return new LogMonitorAdapter ( userDefinedLevels ) ; } public void addMessage ( LogRecord record ) { _logMonitor . addMessage ( record ) ; } public void setMaxNumberOfRecords ( int maxNumberOfRecords ) { _logMonitor . setMaxNumberOfLogRecords ( maxNumberOfRecords ) ; } public void setDefaultLevel ( LogLevel level ) { _defaultLevel = level ; } public LogLevel getDefaultLevel ( ) { return _defaultLevel ; } public void setSevereLevel ( LogLevel level ) { AdapterLogRecord . setSevereLevel ( level ) ; } public LogLevel getSevereLevel ( ) { return AdapterLogRecord . getSevereLevel ( ) ; } public void log ( String category , LogLevel level , String message , Throwable t , String NDC ) { AdapterLogRecord record = new AdapterLogRecord ( ) ; record . setCategory ( category ) ; record . setMessage ( message ) ; record . setNDC ( NDC ) ; record . setThrown ( t ) ; if ( level == null ) { record . setLevel ( getDefaultLevel ( ) ) ; } else { record . setLevel ( level ) ; } addMessage ( record ) ; } public void log ( String category , String message ) { log ( category , null , message ) ; } public void log ( String category , LogLevel level , String message , String NDC ) { log ( category , level , message , null , NDC ) ; } public void log ( String category , LogLevel level , String message , Throwable t ) { log ( category , level , message , t , null ) ; } public void log ( String category , LogLevel level , String message ) { log ( category , level , message , null , null ) ; } protected static int getScreenWidth ( ) { try { return Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . width ; } catch ( Throwable t ) { return 800 ; } } protected static int getScreenHeight ( ) { try { return Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) . height ; } catch ( Throwable t ) { return 600 ; } } protected static int getDefaultMonitorWidth ( ) { return ( 3 * getScreenWidth ( ) ) / 4 ; } protected static int getDefaultMonitorHeight ( ) { return ( 3 * getScreenHeight ( ) ) / 4 ; } } 	1	['19', '1', '0', '4', '40', '159', '0', '4', '14', '0.819444444', '198', '0.5', '2', '0', '0.203947368', '0', '0', '9.210526316', '2', '1.1053', '2']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	0	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	1	['6', '1', '6', '10', '10', '7', '8', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '2']
package org . apache . log4j ; import java . util . Vector ; class ProvisionNode extends Vector { ProvisionNode ( Category cat ) { super ( ) ; this . addElement ( cat ) ; } } 	0	['1', '4', '0', '2', '3', '0', '1', '1', '0', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . log4j . xml . examples ; import org . apache . log4j . helpers . LogLog ; public class ReportParserError implements org . xml . sax . ErrorHandler { void report ( String msg , org . xml . sax . SAXParseException e ) { LogLog . error ( msg + e . getMessage ( ) + "\n\tat line=" + e . getLineNumber ( ) + " col=" + e . getColumnNumber ( ) + " of " + "SystemId=\"" + e . getSystemId ( ) + "\" PublicID = \"" + e . getPublicId ( ) + '\"' ) ; } public void warning ( org . xml . sax . SAXParseException e ) { report ( "WARNING: " , e ) ; } public void error ( org . xml . sax . SAXParseException e ) { report ( "ERROR: " , e ) ; } public void fatalError ( org . xml . sax . SAXParseException e ) { report ( "FATAL: " , e ) ; } } 	1	['5', '1', '0', '1', '17', '10', '0', '1', '4', '2', '58', '0', '0', '0', '0.666666667', '0', '0', '10.6', '1', '0.8', '2']
package org . apache . log4j . xml . examples ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . net . * ; public class XMLSample { static Category cat = Category . getInstance ( XMLSample . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; sample ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + XMLSample . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { DOMConfigurator . configure ( configFile ) ; } static void sample ( ) { int i = - 1 ; Category root = Category . getRoot ( ) ; cat . debug ( "Message " + ++ i ) ; cat . warn ( "Message " + ++ i ) ; cat . error ( "Message " + ++ i ) ; Exception e = new Exception ( "Just testing" ) ; cat . debug ( "Message " + ++ i , e ) ; } } 	0	['7', '1', '0', '2', '26', '17', '0', '2', '2', '0.666666667', '131', '0', '1', '0', '0.277777778', '0', '0', '17.42857143', '2', '1', '0']
package org . apache . log4j . varia ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . spi . Configurator ; import java . net . URL ; import org . apache . log4j . spi . LoggerRepository ; public class ReloadingPropertyConfigurator implements Configurator { PropertyConfigurator delegate = new PropertyConfigurator ( ) ; public ReloadingPropertyConfigurator ( ) { } public void doConfigure ( URL url , LoggerRepository repository ) { } } 	1	['2', '1', '0', '3', '4', '1', '0', '3', '2', '1', '12', '0', '1', '0', '0.666666667', '0', '0', '4.5', '1', '0.5', '2']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; import java . io . InputStreamReader ; public class SocketMin { static Category cat = Category . getInstance ( SyslogMin . class . getName ( ) ) ; static SocketAppender s ; public static void main ( String argv [ ] ) { if ( argv . length == 3 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; if ( argv [ 2 ] . equals ( "true" ) ) loop ( ) ; else test ( ) ; s . close ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SocketMin . class + " host port true|false" ) ; System . exit ( 1 ) ; } static void init ( String host , String portStr ) { Category root = Category . getRoot ( ) ; BasicConfigurator . configure ( ) ; try { int port = Integer . parseInt ( portStr ) ; cat . info ( "Creating socket appender (" + host + "," + port + ")." ) ; s = new SocketAppender ( host , port ) ; s . setName ( "S" ) ; root . addAppender ( s ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } catch ( Exception e ) { System . err . println ( "Could not start!" ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } static void loop ( ) { Category root = Category . getRoot ( ) ; InputStreamReader in = new InputStreamReader ( System . in ) ; System . out . println ( "Type 'q' to quit" ) ; int i ; int k = 0 ; while ( true ) { cat . debug ( "Message " + k ++ ) ; cat . info ( "Message " + k ++ ) ; cat . warn ( "Message " + k ++ ) ; cat . error ( "Message " + k ++ , new Exception ( "Just testing" ) ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } if ( i == - 1 ) break ; if ( i == 'q' ) break ; if ( i == 'r' ) { System . out . println ( "Removing appender S" ) ; root . removeAppender ( "S" ) ; } } } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['8', '1', '0', '7', '42', '14', '0', '7', '2', '0.75', '308', '0', '2', '0', '0.238095238', '0', '0', '37', '4', '1.5', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . File ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . GregorianCalendar ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Locale ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . spi . LoggingEvent ; public class DailyRollingFileAppender extends FileAppender { static final int TOP_OF_TROUBLE = - 1 ; static final int TOP_OF_MINUTE = 0 ; static final int TOP_OF_HOUR = 1 ; static final int HALF_DAY = 2 ; static final int TOP_OF_DAY = 3 ; static final int TOP_OF_WEEK = 4 ; static final int TOP_OF_MONTH = 5 ; private String datePattern = "'.'yyyy-MM-dd" ; private String scheduledFilename ; private long nextCheck = System . currentTimeMillis ( ) - 1 ; Date now = new Date ( ) ; SimpleDateFormat sdf ; RollingCalendar rc = new RollingCalendar ( ) ; int checkPeriod = TOP_OF_TROUBLE ; static final TimeZone gmtTimeZone = TimeZone . getTimeZone ( "GMT" ) ; public DailyRollingFileAppender ( ) { } public DailyRollingFileAppender ( Layout layout , String filename , String datePattern ) throws IOException { super ( layout , filename , true ) ; this . datePattern = datePattern ; activateOptions ( ) ; } public void setDatePattern ( String pattern ) { datePattern = pattern ; } public String getDatePattern ( ) { return datePattern ; } public void activateOptions ( ) { super . activateOptions ( ) ; if ( datePattern != null && fileName != null ) { now . setTime ( System . currentTimeMillis ( ) ) ; sdf = new SimpleDateFormat ( datePattern ) ; int type = computeCheckPeriod ( ) ; printPeriodicity ( type ) ; rc . setType ( type ) ; File file = new File ( fileName ) ; scheduledFilename = fileName + sdf . format ( new Date ( file . lastModified ( ) ) ) ; } else { LogLog . error ( "Either Filename or DatePattern options are not set for [" + name + "]." ) ; } } void printPeriodicity ( int type ) { switch ( type ) { case TOP_OF_MINUTE : LogLog . debug ( "Appender [" + name + "] to be rolled every minute." ) ; break ; case TOP_OF_HOUR : LogLog . debug ( "Appender [" + name + "] to be rolled on top of every hour." ) ; break ; case HALF_DAY : LogLog . debug ( "Appender [" + name + "] to be rolled at midday and midnight." ) ; break ; case TOP_OF_DAY : LogLog . debug ( "Appender [" + name + "] to be rolled at midnight." ) ; break ; case TOP_OF_WEEK : LogLog . debug ( "Appender [" + name + "] to be rolled at start of week." ) ; break ; case TOP_OF_MONTH : LogLog . debug ( "Appender [" + name + "] to be rolled at start of every month." ) ; break ; default : LogLog . warn ( "Unknown periodicity for appender [" + name + "]." ) ; } } int computeCheckPeriod ( ) { RollingCalendar rollingCalendar = new RollingCalendar ( gmtTimeZone , Locale . ENGLISH ) ; Date epoch = new Date ( 0 ) ; if ( datePattern != null ) { for ( int i = TOP_OF_MINUTE ; i <= TOP_OF_MONTH ; i ++ ) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat ( datePattern ) ; simpleDateFormat . setTimeZone ( gmtTimeZone ) ; String r0 = simpleDateFormat . format ( epoch ) ; rollingCalendar . setType ( i ) ; Date next = new Date ( rollingCalendar . getNextCheckMillis ( epoch ) ) ; String r1 = simpleDateFormat . format ( next ) ; if ( r0 != null && r1 != null && ! r0 . equals ( r1 ) ) { return i ; } } } return TOP_OF_TROUBLE ; } void rollOver ( ) throws IOException { if ( datePattern == null ) { errorHandler . error ( "Missing DatePattern option in rollOver()." ) ; return ; } String datedFilename = fileName + sdf . format ( now ) ; if ( scheduledFilename . equals ( datedFilename ) ) { return ; } this . closeFile ( ) ; File target = new File ( scheduledFilename ) ; if ( target . exists ( ) ) { target . delete ( ) ; } File file = new File ( fileName ) ; file . renameTo ( target ) ; LogLog . debug ( fileName + " -> " + scheduledFilename ) ; try { this . setFile ( fileName , false , this . bufferedIO , this . bufferSize ) ; } catch ( IOException e ) { errorHandler . error ( "setFile(" + fileName + ", false) call failed." ) ; } scheduledFilename = datedFilename ; } protected void subAppend ( LoggingEvent event ) { long n = System . currentTimeMillis ( ) ; if ( n >= nextCheck ) { now . setTime ( n ) ; nextCheck = rc . getNextCheckMillis ( now ) ; try { rollOver ( ) ; } catch ( IOException ioe ) { LogLog . error ( "rollOver() failed." , ioe ) ; } } super . subAppend ( event ) ; } } class RollingCalendar extends GregorianCalendar { int type = DailyRollingFileAppender . TOP_OF_TROUBLE ; RollingCalendar ( ) { super ( ) ; } RollingCalendar ( TimeZone tz , Locale locale ) { super ( tz , locale ) ; } void setType ( int type ) { this . type = type ; } public long getNextCheckMillis ( Date now ) { return getNextCheckDate ( now ) . getTime ( ) ; } public Date getNextCheckDate ( Date now ) { this . setTime ( now ) ; switch ( type ) { case DailyRollingFileAppender . TOP_OF_MINUTE : this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; this . add ( Calendar . MINUTE , 1 ) ; break ; case DailyRollingFileAppender . TOP_OF_HOUR : this . set ( Calendar . MINUTE , 0 ) ; this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; this . add ( Calendar . HOUR_OF_DAY , 1 ) ; break ; case DailyRollingFileAppender . HALF_DAY : this . set ( Calendar . MINUTE , 0 ) ; this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; int hour = get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 12 ) { this . set ( Calendar . HOUR_OF_DAY , 12 ) ; } else { this . set ( Calendar . HOUR_OF_DAY , 0 ) ; this . add ( Calendar . DAY_OF_MONTH , 1 ) ; } break ; case DailyRollingFileAppender . TOP_OF_DAY : this . set ( Calendar . HOUR_OF_DAY , 0 ) ; this . set ( Calendar . MINUTE , 0 ) ; this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; this . add ( Calendar . DATE , 1 ) ; break ; case DailyRollingFileAppender . TOP_OF_WEEK : this . set ( Calendar . DAY_OF_WEEK , getFirstDayOfWeek ( ) ) ; this . set ( Calendar . HOUR_OF_DAY , 0 ) ; this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; this . add ( Calendar . WEEK_OF_YEAR , 1 ) ; break ; case DailyRollingFileAppender . TOP_OF_MONTH : this . set ( Calendar . DATE , 1 ) ; this . set ( Calendar . HOUR_OF_DAY , 0 ) ; this . set ( Calendar . SECOND , 0 ) ; this . set ( Calendar . MILLISECOND , 0 ) ; this . add ( Calendar . MONTH , 1 ) ; break ; default : throw new IllegalStateException ( "Unknown periodicity type." ) ; } return getTime ( ) ; } } 	1	['10', '3', '0', '8', '42', '0', '0', '8', '5', '0.866666667', '435', '0.2', '1', '0.825', '0.311111111', '1', '1', '41', '6', '1.6', '4']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . FileAppender ; public class DefaultInit { static Category cat = Category . getInstance ( DefaultInit . class . getName ( ) ) ; public static void main ( String [ ] argv ) { cat . debug ( "Hello world" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.DefaultInit " ) ; System . exit ( 1 ) ; } } 	0	['5', '1', '0', '1', '14', '8', '0', '1', '2', '0.875', '45', '0', '1', '0', '0.333333333', '0', '0', '7.6', '1', '0.6', '0']
package org . apache . log4j . net ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . LogManager ; import org . apache . log4j . spi . RendererSupport ; import org . apache . log4j . spi . LoggerRepository ; import org . apache . log4j . or . jms . MessageRenderer ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import javax . jms . * ; import javax . naming . InitialContext ; import javax . naming . Context ; import javax . naming . NameNotFoundException ; import javax . naming . NamingException ; public class JMSSink { static public void main ( String [ ] args ) { if ( args . length != 3 ) { usage ( "Wrong number of arguments." ) ; } String tcfBindingName = args [ 0 ] ; String topicBindingName = args [ 1 ] ; PropertyConfigurator . configure ( args [ 2 ] ) ; LoggerRepository rep = LogManager . getLoggerRepository ( ) ; if ( rep instanceof RendererSupport ) { ( ( RendererSupport ) rep ) . setRenderer ( Message . class , new MessageRenderer ( ) ) ; } try { Context ctx = new InitialContext ( ) ; TopicConnectionFactory topicConnectionFactory ; topicConnectionFactory = ( TopicConnectionFactory ) lookup ( ctx , tcfBindingName ) ; TopicConnection topicConnection = topicConnectionFactory . createTopicConnection ( ) ; topicConnection . start ( ) ; TopicSession topicSession = topicConnection . createTopicSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Topic topic = ( Topic ) ctx . lookup ( topicBindingName ) ; TopicSubscriber topicSubscriber = topicSession . createDurableSubscriber ( topic , "x" ) ; LoggingEvent event ; Category remoteCategory ; while ( true ) { ObjectMessage msg = ( ObjectMessage ) topicSubscriber . receive ( ) ; event = ( LoggingEvent ) msg . getObject ( ) ; remoteCategory = Category . getInstance ( event . categoryName ) ; remoteCategory . callAppenders ( event ) ; } } catch ( Exception e ) { LogLog . error ( "Could not read JMS message." , e ) ; } } protected static Object lookup ( Context ctx , String name ) throws NamingException { try { return ctx . lookup ( name ) ; } catch ( NameNotFoundException e ) { LogLog . error ( "Could not find name [" + name + "]." ) ; throw e ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + JMSSink . class . getName ( ) + " TopicConnectionFactoryBindingName TopicBindingName configFile" ) ; System . exit ( 1 ) ; } } 	1	['5', '1', '0', '9', '31', '10', '0', '9', '2', '0.875', '151', '0', '0', '0', '0.3', '0', '0', '28.8', '4', '1.6', '3']
package org . apache . log4j . spi ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Filter implements OptionHandler { public Filter next ; public static final int DENY = - 1 ; public static final int NEUTRAL = 0 ; public static final int ACCEPT = 1 ; public void activateOptions ( ) { } abstract public int decide ( LoggingEvent event ) ; } 	0	['5', '1', '0', '4', '6', '10', '2', '2', '5', '1.25', '13', '0', '1', '0', '0.466666667', '0', '0', '0.8', '1', '0.8', '0']
package org . apache . log4j . lf5 . viewer ; import javax . swing . * ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . KeyAdapter ; import java . awt . event . KeyEvent ; public class LogFactor5InputDialog extends LogFactor5Dialog { public static final int SIZE = 30 ; private JTextField _textField ; public LogFactor5InputDialog ( JFrame jframe , String title , String label ) { this ( jframe , title , label , SIZE ) ; } public LogFactor5InputDialog ( JFrame jframe , String title , String label , int size ) { super ( jframe , title , true ) ; JPanel bottom = new JPanel ( ) ; bottom . setLayout ( new FlowLayout ( ) ) ; JPanel main = new JPanel ( ) ; main . setLayout ( new FlowLayout ( ) ) ; main . add ( new JLabel ( label ) ) ; _textField = new JTextField ( size ) ; main . add ( _textField ) ; addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { hide ( ) ; } } } ) ; JButton ok = new JButton ( "Ok" ) ; ok . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } ) ; JButton cancel = new JButton ( "Cancel" ) ; cancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; _textField . setText ( "" ) ; } } ) ; bottom . add ( ok ) ; bottom . add ( cancel ) ; getContentPane ( ) . add ( main , BorderLayout . CENTER ) ; getContentPane ( ) . add ( bottom , BorderLayout . SOUTH ) ; pack ( ) ; centerWindow ( this ) ; show ( ) ; } public String getText ( ) { String s = _textField . getText ( ) ; if ( s != null && s . trim ( ) . length ( ) == 0 ) { return null ; } return s ; } } 	1	['4', '7', '0', '5', '25', '0', '4', '4', '3', '0.666666667', '125', '0.5', '0', '0.996865204', '0.45', '0', '0', '29.75', '3', '1', '2']
package org . apache . log4j . helpers ; public class FormattingInfo { int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; void reset ( ) { min = - 1 ; max = 0x7FFFFFFF ; leftAlign = false ; } void dump ( ) { LogLog . debug ( "min=" + min + ", max=" + max + ", leftAlign=" + leftAlign ) ; } } 	0	['3', '1', '0', '9', '10', '0', '8', '1', '1', '0', '49', '0', '0', '0', '1', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; buf [ first ] = null ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } int min ( int a , int b ) { return a < b ? a : b ; } synchronized public void resize ( int newSize ) { if ( newSize == maxSize ) return ; LoggingEvent [ ] tmp = new LoggingEvent [ newSize ] ; int len1 = maxSize - first ; len1 = min ( len1 , newSize ) ; len1 = min ( len1 , numElements ) ; System . arraycopy ( buf , first , tmp , 0 , len1 ) ; int len2 = 0 ; if ( ( len1 < numElements ) && ( len1 < newSize ) ) { len2 = numElements - len1 ; len2 = min ( len2 , newSize - len1 ) ; System . arraycopy ( buf , 0 , tmp , len1 , len2 ) ; } this . buf = tmp ; this . maxSize = newSize ; this . first = 0 ; this . numElements = len1 + len2 ; this . next = this . numElements ; if ( this . next == this . maxSize ) this . next = 0 ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	1	['10', '1', '0', '3', '17', '0', '2', '1', '9', '0.555555556', '249', '0', '1', '0', '0.466666667', '0', '0', '23.4', '5', '2.1', '2']
package org . apache . log4j . or ; class DefaultRenderer implements ObjectRenderer { DefaultRenderer ( ) { } public String doRender ( Object o ) { return o . toString ( ) ; } } 	0	['2', '1', '0', '2', '4', '1', '1', '1', '1', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . log4j . spi ; import org . apache . log4j . * ; import org . apache . log4j . helpers . LogLog ; import java . lang . reflect . Method ; import java . io . ObjectOutputStream ; import java . io . ObjectInputStream ; import java . util . Hashtable ; public class LoggingEvent implements java . io . Serializable { private static long startTime = System . currentTimeMillis ( ) ; transient public final String fqnOfCategoryClass ; transient public Category logger ; public final String categoryName ; transient public Priority level ; private String ndc ; private Hashtable mdcCopy ; private boolean ndcLookupRequired = true ; private boolean mdcLookupRequired = true ; transient private Object message ; private String renderedMessage ; private String threadName ; private ThrowableInformation throwableInfo ; public final long timeStamp ; private LocationInfo locationInfo ; static final long serialVersionUID = - 868428216207166145L ; static final Integer [ ] PARAM_ARRAY = new Integer [ 1 ] ; static final String TO_LEVEL = "toLevel" ; static final Class [ ] TO_LEVEL_PARAMS = new Class [ ] { int . class } ; static final Hashtable methodCache = new Hashtable ( 3 ) ; public LoggingEvent ( String fqnOfCategoryClass , Category logger , Priority priority , Object message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . logger = logger ; this . categoryName = logger . getName ( ) ; this . level = priority ; this . message = message ; if ( throwable != null ) { this . throwableInfo = new ThrowableInformation ( throwable ) ; } timeStamp = System . currentTimeMillis ( ) ; } public LoggingEvent ( String fqnOfCategoryClass , Category logger , long timeStamp , Priority priority , Object message , Throwable throwable ) { this . fqnOfCategoryClass = fqnOfCategoryClass ; this . logger = logger ; this . categoryName = logger . getName ( ) ; this . level = priority ; this . message = message ; if ( throwable != null ) { this . throwableInfo = new ThrowableInformation ( throwable ) ; } this . timeStamp = timeStamp ; } public LocationInfo getLocationInformation ( ) { if ( locationInfo == null ) { locationInfo = new LocationInfo ( new Throwable ( ) , fqnOfCategoryClass ) ; } return locationInfo ; } public Object getMessage ( ) { if ( message != null ) { return message ; } else { return getRenderedMessage ( ) ; } } public String getNDC ( ) { if ( ndcLookupRequired ) { ndcLookupRequired = false ; ndc = NDC . get ( ) ; } return ndc ; } public Object getMDC ( String key ) { Object r ; if ( mdcCopy != null ) { r = mdcCopy . get ( key ) ; if ( r != null ) { return r ; } } return MDC . get ( key ) ; } public void getMDCCopy ( ) { if ( mdcLookupRequired ) { ndcLookupRequired = false ; Hashtable t = ( Hashtable ) MDC . getContext ( ) ; if ( t != null ) { mdcCopy = ( Hashtable ) t . clone ( ) ; } } } public String getRenderedMessage ( ) { if ( renderedMessage == null && message != null ) { if ( message instanceof String ) renderedMessage = ( String ) message ; else { LoggerRepository repository = logger . getHierarchy ( ) ; if ( repository instanceof RendererSupport ) { RendererSupport rs = ( RendererSupport ) repository ; renderedMessage = rs . getRendererMap ( ) . findAndRender ( message ) ; } else { renderedMessage = message . toString ( ) ; } } } return renderedMessage ; } public static long getStartTime ( ) { return startTime ; } public String getThreadName ( ) { if ( threadName == null ) threadName = ( Thread . currentThread ( ) ) . getName ( ) ; return threadName ; } public ThrowableInformation getThrowableInformation ( ) { return throwableInfo ; } public String [ ] getThrowableStrRep ( ) { if ( throwableInfo == null ) return null ; else return throwableInfo . getThrowableStrRep ( ) ; } private void readLevel ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { int p = ois . readInt ( ) ; try { String className = ( String ) ois . readObject ( ) ; if ( className == null ) { level = Level . toLevel ( p ) ; } else { Method m = ( Method ) methodCache . get ( className ) ; if ( m == null ) { Class clazz = Class . forName ( className ) ; m = clazz . getDeclaredMethod ( TO_LEVEL , TO_LEVEL_PARAMS ) ; methodCache . put ( className , m ) ; } PARAM_ARRAY [ 0 ] = new Integer ( p ) ; level = ( Level ) m . invoke ( null , PARAM_ARRAY ) ; } } catch ( Exception e ) { LogLog . warn ( "Level deserialization failed, reverting to default." , e ) ; level = Level . toLevel ( p ) ; } } private void readObject ( ObjectInputStream ois ) throws java . io . IOException , ClassNotFoundException { ois . defaultReadObject ( ) ; readLevel ( ois ) ; if ( locationInfo == null ) locationInfo = new LocationInfo ( null , null ) ; } private void writeObject ( ObjectOutputStream oos ) throws java . io . IOException { this . getThreadName ( ) ; this . getRenderedMessage ( ) ; this . getNDC ( ) ; this . getMDCCopy ( ) ; this . getThrowableStrRep ( ) ; oos . defaultWriteObject ( ) ; writeLevel ( oos ) ; } private void writeLevel ( ObjectOutputStream oos ) throws java . io . IOException { oos . writeInt ( level . toInt ( ) ) ; Class clazz = level . getClass ( ) ; if ( clazz == Level . class ) { oos . writeObject ( null ) ; } else { oos . writeObject ( clazz . getName ( ) ) ; } } } 	1	['18', '1', '0', '62', '55', '99', '52', '11', '12', '0.885154062', '395', '0.476190476', '4', '0', '0.209150327', '0', '0', '19.77777778', '5', '1.5556', '5']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { root . setPriority ( Priority . DEBUG ) ; BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toHexString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '4', '37', '8', '0', '4', '7', '0.822916667', '314', '0', '1', '0.897058824', '0.21875', '0', '0', '32.55555556', '7', '2', '0']
package org . apache . log4j . lf5 . viewer ; import org . apache . log4j . lf5 . LogLevel ; import org . apache . log4j . lf5 . LogRecord ; import javax . swing . * ; import javax . swing . table . DefaultTableCellRenderer ; import java . awt . * ; public class LogTableRowRenderer extends DefaultTableCellRenderer { protected boolean _highlightFatal = true ; protected Color _color = new Color ( 230 , 230 , 230 ) ; public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int col ) { if ( ( row % 2 ) == 0 ) { setBackground ( _color ) ; } else { setBackground ( Color . white ) ; } FilteredLogTableModel model = ( FilteredLogTableModel ) table . getModel ( ) ; LogRecord record = model . getFilteredRecord ( row ) ; setForeground ( getLogLevelColor ( record . getLevel ( ) ) ) ; return ( super . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , col ) ) ; } protected Color getLogLevelColor ( LogLevel level ) { return ( Color ) LogLevel . getLogLevelColorMap ( ) . get ( level ) ; } } 	1	['3', '6', '0', '4', '13', '1', '1', '3', '2', '0.75', '59', '1', '0', '0.996992481', '0.444444444', '1', '1', '18', '2', '1', '3']
package org . apache . log4j ; class CategoryKey { String name ; int hashCache ; CategoryKey ( String name ) { this . name = name . intern ( ) ; hashCache = name . hashCode ( ) ; } final public int hashCode ( ) { return hashCache ; } final public boolean equals ( Object rArg ) { if ( this == rArg ) return true ; if ( rArg != null && CategoryKey . class == rArg . getClass ( ) ) return name == ( ( CategoryKey ) rArg ) . name ; else return false ; } } 	0	['4', '1', '0', '1', '11', '2', '1', '0', '2', '0.777777778', '61', '0', '0', '0', '0.5', '1', '1', '13.5', '6', '2', '0']
package org . apache . log4j . spi ; import org . apache . log4j . * ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Logger { public RootCategory ( Level level ) { super ( "root" ) ; setLevel ( level ) ; } final public Level getChainedLevel ( ) { return level ; } final public void setLevel ( Level level ) { if ( level == null ) { LogLog . error ( "You have tried to set a null level to root." , new Throwable ( ) ) ; } else { this . level = level ; } } final public void setPriority ( Level level ) { setLevel ( level ) ; } } 	1	['4', '3', '0', '6', '7', '6', '2', '4', '4', '2', '30', '0', '0', '0.945454545', '0.875', '1', '1', '6.5', '2', '1', '2']
package org . apache . log4j . performance ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . AppenderSkeleton ; public class NullAppender extends AppenderSkeleton { public static String s ; public String t ; public NullAppender ( ) { } public NullAppender ( Layout layout ) { this . layout = layout ; } public void close ( ) { } public void doAppend ( LoggingEvent event ) { if ( layout != null ) { t = layout . format ( event ) ; s = t ; } } public void append ( LoggingEvent event ) { } public boolean requiresLayout ( ) { return true ; } } 	0	['6', '2', '0', '3', '8', '15', '0', '3', '6', '1', '34', '0', '0', '0.818181818', '0.5', '1', '1', '4.333333333', '2', '0.8333', '0']
package org . apache . log4j . lf5 . viewer ; import javax . swing . * ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; public class LogFactor5ErrorDialog extends LogFactor5Dialog { public LogFactor5ErrorDialog ( JFrame jframe , String message ) { super ( jframe , "Error" , true ) ; JButton ok = new JButton ( "Ok" ) ; ok . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } ) ; JPanel bottom = new JPanel ( ) ; bottom . setLayout ( new FlowLayout ( ) ) ; bottom . add ( ok ) ; JPanel main = new JPanel ( ) ; main . setLayout ( new GridBagLayout ( ) ) ; wrapStringOnPanel ( message , main ) ; getContentPane ( ) . add ( main , BorderLayout . CENTER ) ; getContentPane ( ) . add ( bottom , BorderLayout . SOUTH ) ; show ( ) ; } } 	1	['1', '7', '0', '4', '14', '0', '3', '2', '1', '2', '56', '0', '0', '1', '1', '0', '0', '55', '0', '0', '2']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	0	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '0']
package org . apache . log4j . lf5 . viewer . categoryexplorer ; import javax . swing . * ; import javax . swing . tree . DefaultTreeCellEditor ; import javax . swing . tree . TreePath ; import java . awt . * ; import java . awt . event . MouseEvent ; import java . util . EventObject ; public class CategoryImmediateEditor extends DefaultTreeCellEditor { private CategoryNodeRenderer renderer ; protected Icon editingIcon = null ; public CategoryImmediateEditor ( JTree tree , CategoryNodeRenderer renderer , CategoryNodeEditor editor ) { super ( tree , renderer , editor ) ; this . renderer = renderer ; renderer . setIcon ( null ) ; renderer . setLeafIcon ( null ) ; renderer . setOpenIcon ( null ) ; renderer . setClosedIcon ( null ) ; super . editingIcon = null ; } public boolean shouldSelectCell ( EventObject e ) { boolean rv = false ; if ( e instanceof MouseEvent ) { MouseEvent me = ( MouseEvent ) e ; TreePath path = tree . getPathForLocation ( me . getX ( ) , me . getY ( ) ) ; CategoryNode node = ( CategoryNode ) path . getLastPathComponent ( ) ; rv = node . isLeaf ( ) ; } return rv ; } public boolean inCheckBoxHitRegion ( MouseEvent e ) { TreePath path = tree . getPathForLocation ( e . getX ( ) , e . getY ( ) ) ; if ( path == null ) { return false ; } CategoryNode node = ( CategoryNode ) path . getLastPathComponent ( ) ; boolean rv = false ; if ( true ) { Rectangle bounds = tree . getRowBounds ( lastRow ) ; Dimension checkBoxOffset = renderer . getCheckBoxOffset ( ) ; bounds . translate ( offset + checkBoxOffset . width , checkBoxOffset . height ) ; rv = bounds . contains ( e . getPoint ( ) ) ; } return true ; } protected boolean canEditImmediately ( EventObject e ) { boolean rv = false ; if ( e instanceof MouseEvent ) { MouseEvent me = ( MouseEvent ) e ; rv = inCheckBoxHitRegion ( me ) ; } return rv ; } protected void determineOffset ( JTree tree , Object value , boolean isSelected , boolean expanded , boolean leaf , int row ) { offset = 0 ; } } 	1	['5', '2', '0', '4', '20', '8', '1', '3', '3', '0.75', '121', '1', '1', '0.870967742', '0.333333333', '1', '3', '22.8', '2', '1.4', '2']
package org . apache . log4j ; import java . util . Vector ; class ProvisionNode extends Vector { ProvisionNode ( Category cat ) { super ( ) ; this . addElement ( cat ) ; } } 	0	['1', '4', '0', '2', '3', '0', '1', '1', '0', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; public class Transform { static public String escapeTags ( String input ) { if ( input == null || input . length ( ) == 0 ) { return input ; } StringBuffer buf = new StringBuffer ( input . length ( ) + 6 ) ; char ch = ' ' ; int len = input . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { ch = input . charAt ( i ) ; if ( ch == '<' ) { buf . append ( "&lt;" ) ; } else if ( ch == '>' ) { buf . append ( "&gt;" ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } } 	1	['2', '1', '0', '2', '9', '1', '2', '0', '2', '2', '59', '0', '0', '0', '0.5', '0', '0', '28.5', '6', '3', '3']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . NDC ; public class ConfigurationFileParsing { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { NDC . push ( "testing" ) ; PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; root . debug ( "Message 1" ) ; root . debug ( "Message 2" ) ; NDC . pop ( ) ; Category . shutdown ( ) ; } else { Usage ( "Wrong number of arguments." ) ; } } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ConfigurationFileParsing . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '3', '20', '6', '0', '3', '2', '0.666666667', '69', '0', '0', '0', '0.333333333', '0', '0', '16', '2', '1.25', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; if ( loopLen == newSize ) { last = 0 ; } else { last = loopLen ; } } } 	1	['7', '1', '0', '2', '13', '0', '1', '1', '7', '0.333333333', '246', '0', '1', '0', '0.523809524', '0', '0', '33.42857143', '7', '2.7143', '2']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; public interface ErrorHandler extends OptionHandler { void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; } 	0	['2', '1', '0', '14', '2', '1', '13', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . log4j ; import java . io . IOException ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . QuietWriter ; import org . apache . log4j . helpers . LogLog ; public class WriterAppender extends AppenderSkeleton { protected boolean immediateFlush = true ; protected String encoding ; protected QuietWriter qw ; public WriterAppender ( ) { } public WriterAppender ( Layout layout , OutputStream os ) { this ( layout , new OutputStreamWriter ( os ) ) ; } public WriterAppender ( Layout layout , Writer writer ) { this . layout = layout ; this . setWriter ( writer ) ; } public void setImmediateFlush ( boolean value ) { immediateFlush = value ; } public boolean getImmediateFlush ( ) { return immediateFlush ; } public void activateOptions ( ) { } public void append ( LoggingEvent event ) { if ( ! checkEntryConditions ( ) ) { return ; } subAppend ( event ) ; } protected boolean checkEntryConditions ( ) { if ( this . closed ) { LogLog . warn ( "Not allowed to write to a closed appender." ) ; return false ; } if ( this . qw == null ) { errorHandler . error ( "No output stream or file set for the appender named [" + name + "]." ) ; return false ; } if ( this . layout == null ) { errorHandler . error ( "No layout set for the appender named [" + name + "]." ) ; return false ; } return true ; } public synchronized void close ( ) { if ( this . closed ) return ; this . closed = true ; writeFooter ( ) ; reset ( ) ; } protected void closeWriter ( ) { if ( qw != null ) { try { qw . close ( ) ; } catch ( IOException e ) { LogLog . error ( "Could not close " + qw , e ) ; } } } protected OutputStreamWriter createWriter ( OutputStream os ) { OutputStreamWriter retval = null ; String enc = getEncoding ( ) ; if ( enc != null ) { try { retval = new OutputStreamWriter ( os , enc ) ; } catch ( IOException e ) { LogLog . warn ( "Error initializing output writer." ) ; LogLog . warn ( "Unsupported encoding?" ) ; } } if ( retval == null ) { retval = new OutputStreamWriter ( os ) ; } return retval ; } public String getEncoding ( ) { return encoding ; } public void setEncoding ( String value ) { encoding = value ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; if ( this . qw != null ) { this . qw . setErrorHandler ( eh ) ; } } } public synchronized void setWriter ( Writer writer ) { reset ( ) ; this . qw = new QuietWriter ( writer , errorHandler ) ; writeHeader ( ) ; } protected void subAppend ( LoggingEvent event ) { this . qw . write ( this . layout . format ( event ) ) ; if ( layout . ignoresThrowable ( ) ) { String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; for ( int i = 0 ; i < len ; i ++ ) { this . qw . write ( s [ i ] ) ; this . qw . write ( Layout . LINE_SEP ) ; } } } if ( this . immediateFlush ) { this . qw . flush ( ) ; } } public boolean requiresLayout ( ) { return true ; } protected void reset ( ) { closeWriter ( ) ; this . qw = null ; } protected void writeFooter ( ) { if ( layout != null ) { String f = layout . getFooter ( ) ; if ( f != null && this . qw != null ) { this . qw . write ( f ) ; this . qw . flush ( ) ; } } } protected void writeHeader ( ) { if ( layout != null ) { String h = layout . getHeader ( ) ; if ( h != null && this . qw != null ) this . qw . write ( h ) ; } } } 	1	['20', '2', '2', '10', '40', '112', '4', '6', '13', '0.684210526', '296', '1', '1', '0.514285714', '0.19375', '1', '3', '13.65', '5', '1.85', '3']
package org . apache . log4j . spi ; import java . io . StringWriter ; import java . io . PrintWriter ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . Layout ; public class LocationInfo implements java . io . Serializable { transient String lineNumber ; transient String fileName ; transient String className ; transient String methodName ; public String fullInfo ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public final static String NA = "?" ; static final long serialVersionUID = - 1325822038990805636L ; static boolean inVisualAge = false ; static { try { Class dummy = Class . forName ( "com.ibm.uvm.tools.DebugSupport" ) ; inVisualAge = true ; LogLog . debug ( "Detected IBM VisualAge environment." ) ; } catch ( Throwable e ) { } } public LocationInfo ( Throwable t , String fqnOfCallingClass ) { if ( t == null ) return ; String s ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } int ibegin , iend ; ibegin = s . lastIndexOf ( fqnOfCallingClass ) ; if ( ibegin == - 1 ) return ; ibegin = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( ibegin == - 1 ) return ; ibegin += Layout . LINE_SEP_LEN ; iend = s . indexOf ( Layout . LINE_SEP , ibegin ) ; if ( iend == - 1 ) return ; if ( ! inVisualAge ) { ibegin = s . lastIndexOf ( "at " , iend ) ; if ( ibegin == - 1 ) return ; ibegin += 3 ; } this . fullInfo = s . substring ( ibegin , iend ) ; } public String getClassName ( ) { if ( fullInfo == null ) return NA ; if ( className == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; if ( iend == - 1 ) className = NA ; else { iend = fullInfo . lastIndexOf ( '.' , iend ) ; int ibegin = 0 ; if ( inVisualAge ) { ibegin = fullInfo . lastIndexOf ( ' ' , iend ) + 1 ; } if ( iend == - 1 ) className = NA ; else className = this . fullInfo . substring ( ibegin , iend ) ; } } return className ; } public String getFileName ( ) { if ( fullInfo == null ) return NA ; if ( fileName == null ) { int iend = fullInfo . lastIndexOf ( ':' ) ; if ( iend == - 1 ) fileName = NA ; else { int ibegin = fullInfo . lastIndexOf ( '(' , iend - 1 ) ; fileName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } } return fileName ; } public String getLineNumber ( ) { if ( fullInfo == null ) return NA ; if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( ')' ) ; int ibegin = fullInfo . lastIndexOf ( ':' , iend - 1 ) ; if ( ibegin == - 1 ) lineNumber = NA ; else lineNumber = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return lineNumber ; } public String getMethodName ( ) { if ( fullInfo == null ) return NA ; if ( methodName == null ) { int iend = fullInfo . lastIndexOf ( '(' ) ; int ibegin = fullInfo . lastIndexOf ( '.' , iend ) ; if ( ibegin == - 1 ) methodName = NA ; else methodName = this . fullInfo . substring ( ibegin + 1 , iend ) ; } return methodName ; } } 	0	['6', '1', '0', '9', '21', '0', '7', '2', '5', '0.88', '286', '0.2', '0', '0', '0.466666667', '0', '0', '45', '6', '3', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int level ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setLevel ( int level ) { this . level = level ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | level ) + ">" + string ) ; } } 	1	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '2']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class BoundedFIFO { LoggingEvent [ ] buf ; int numElements = 0 ; int first = 0 ; int next = 0 ; int maxSize ; public BoundedFIFO ( int maxSize ) { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; buf = new LoggingEvent [ maxSize ] ; } public LoggingEvent get ( ) { if ( numElements == 0 ) return null ; LoggingEvent r = buf [ first ] ; if ( ++ first == maxSize ) { first = 0 ; } numElements -- ; return r ; } public void put ( LoggingEvent o ) { if ( numElements != maxSize ) { buf [ next ] = o ; if ( ++ next == maxSize ) { next = 0 ; } numElements ++ ; } } public int getMaxSize ( ) { return maxSize ; } public boolean isFull ( ) { return numElements == maxSize ; } public int length ( ) { return numElements ; } int min ( int a , int b ) { return a < b ? a : b ; } synchronized public void resize ( int newSize ) { if ( newSize == maxSize ) return ; LoggingEvent [ ] tmp = new LoggingEvent [ newSize ] ; int len1 = maxSize - first ; len1 = min ( len1 , newSize ) ; len1 = min ( len1 , numElements ) ; System . arraycopy ( buf , first , tmp , 0 , len1 ) ; int len2 = 0 ; if ( ( len1 < numElements ) && ( len1 < newSize ) ) { len2 = numElements - len1 ; len2 = min ( len2 , newSize - len1 ) ; System . arraycopy ( buf , 0 , tmp , len1 , len2 ) ; } this . buf = tmp ; this . maxSize = newSize ; this . first = 0 ; this . numElements = len1 + len2 ; this . next = this . numElements ; if ( this . next == this . maxSize ) this . next = 0 ; } public boolean wasEmpty ( ) { return numElements == 1 ; } public boolean wasFull ( ) { return ( numElements + 1 == maxSize ) ; } } 	0	['10', '1', '0', '3', '17', '0', '2', '1', '9', '0.555555556', '243', '0', '1', '0', '0.466666667', '0', '0', '22.8', '5', '2.1', '0']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	1	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '3']
package org . apache . log4j . config ; import java . io . * ; import java . util . * ; import org . apache . log4j . * ; public class PropertyPrinter implements PropertyGetter . PropertyCallback { protected int numAppenders = 0 ; protected Hashtable appenderNames = new Hashtable ( ) ; protected Hashtable layoutNames = new Hashtable ( ) ; protected PrintWriter out ; protected boolean doCapitalize ; public PropertyPrinter ( PrintWriter out ) { this ( out , false ) ; } public PropertyPrinter ( PrintWriter out , boolean doCapitalize ) { this . out = out ; this . doCapitalize = doCapitalize ; print ( out ) ; out . flush ( ) ; } protected String genAppName ( ) { return "A" + numAppenders ++ ; } protected boolean isGenAppName ( String name ) { if ( name . length ( ) < 2 || name . charAt ( 0 ) != 'A' ) return false ; for ( int i = 0 ; i < name . length ( ) ; i ++ ) { if ( name . charAt ( i ) < '0' || name . charAt ( i ) > '9' ) return false ; } return true ; } public void print ( PrintWriter out ) { printOptions ( out , Category . getRoot ( ) ) ; Enumeration cats = Category . getCurrentCategories ( ) ; while ( cats . hasMoreElements ( ) ) { printOptions ( out , ( Category ) cats . nextElement ( ) ) ; } } protected void printOptions ( PrintWriter out , Category cat ) { Enumeration appenders = cat . getAllAppenders ( ) ; Priority prio = cat . getPriority ( ) ; String appenderString = ( prio == null ? "" : prio . toString ( ) ) ; while ( appenders . hasMoreElements ( ) ) { Appender app = ( Appender ) appenders . nextElement ( ) ; String name ; if ( ( name = ( String ) appenderNames . get ( app ) ) == null ) { if ( ( name = app . getName ( ) ) == null || isGenAppName ( name ) ) { name = genAppName ( ) ; } appenderNames . put ( app , name ) ; printOptions ( out , app , "log4j.appender." + name ) ; if ( app . getLayout ( ) != null ) { printOptions ( out , app . getLayout ( ) , "log4j.appender." + name + ".layout" ) ; } } appenderString += ", " + name ; } String catKey = ( cat == Category . getRoot ( ) ) ? "log4j.rootCategory" : "log4j.category." + cat . getName ( ) ; if ( appenderString != "" ) { out . println ( catKey + "=" + appenderString ) ; } } protected void printOptions ( PrintWriter out , Object obj , String fullname ) { out . println ( fullname + "=" + obj . getClass ( ) . getName ( ) ) ; PropertyGetter . getProperties ( obj , this , fullname + "." ) ; } public void foundProperty ( Object obj , String prefix , String name , Object value ) { if ( obj instanceof Appender && "name" . equals ( name ) ) { return ; } if ( doCapitalize ) { name = capitalize ( name ) ; } out . println ( prefix + name + "=" + value . toString ( ) ) ; } public static String capitalize ( String name ) { if ( Character . isLowerCase ( name . charAt ( 0 ) ) ) { if ( name . length ( ) == 1 || Character . isLowerCase ( name . charAt ( 1 ) ) ) { StringBuffer newname = new StringBuffer ( name ) ; newname . setCharAt ( 0 , Character . toUpperCase ( name . charAt ( 0 ) ) ) ; return newname . toString ( ) ; } } return name ; } public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) ) ; } } 	0	['10', '1', '0', '7', '42', '39', '1', '6', '6', '0.644444444', '328', '1', '0', '0', '0.314285714', '0', '0', '31.3', '9', '2.8', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	1	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '7']
package org . apache . log4j . test ; public class SpacePad { static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; static public void main ( String [ ] args ) { StringBuffer sbuf = new StringBuffer ( ) ; for ( int i = 0 ; i < 35 ; i ++ ) { sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , i ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } sbuf . setLength ( 0 ) ; sbuf . append ( "\"" ) ; spacePad ( sbuf , 67 ) ; sbuf . append ( "\"" ) ; System . out . println ( sbuf . toString ( ) ) ; } static public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['4', '1', '0', '0', '10', '4', '0', '0', '3', '0.333333333', '114', '0', '0', '0', '0.333333333', '0', '0', '27.25', '4', '1.5', '0']
package org . apache . log4j . chainsaw ; import java . io . EOFException ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketException ; import org . apache . log4j . Logger ; import org . apache . log4j . spi . LoggingEvent ; class LoggingReceiver extends Thread { private static final Logger logger = Logger . getLogger ( LoggingReceiver . class ) ; private class Slurper implements Runnable { private final Socket mClient ; Slurper ( Socket aClient ) { mClient = aClient ; } public void run ( ) { logger . debug ( "Starting to get data" ) ; try { final ObjectInputStream ois = new ObjectInputStream ( mClient . getInputStream ( ) ) ; while ( true ) { final LoggingEvent event = ( LoggingEvent ) ois . readObject ( ) ; mModel . addEvent ( new EventDetails ( event ) ) ; } } catch ( EOFException e ) { logger . info ( "Reached EOF, closing connection" ) ; } catch ( SocketException e ) { logger . info ( "Caught SocketException, closing connection" ) ; } catch ( IOException e ) { logger . warn ( "Got IOException, closing connection" , e ) ; } catch ( ClassNotFoundException e ) { logger . warn ( "Got ClassNotFoundException, closing connection" , e ) ; } try { mClient . close ( ) ; } catch ( IOException e ) { logger . warn ( "Error closing connection" , e ) ; } } } private final MyTableModel mModel ; private final ServerSocket mSvrSock ; LoggingReceiver ( MyTableModel aModel , int aPort ) throws IOException { setDaemon ( true ) ; mModel = aModel ; mSvrSock = new ServerSocket ( aPort ) ; } public void run ( ) { logger . info ( "Thread started" ) ; try { while ( true ) { logger . debug ( "Waiting for a connection" ) ; final Socket client = mSvrSock . accept ( ) ; logger . debug ( "Got a connection from " + client . getInetAddress ( ) . getHostName ( ) ) ; final Thread t = new Thread ( new Slurper ( client ) ) ; t . setDaemon ( true ) ; t . start ( ) ; } } catch ( IOException e ) { logger . error ( "Error in accepting connections, stopping." , e ) ; } } } 	1	['6', '2', '0', '5', '25', '5', '2', '4', '1', '0.8', '94', '0.75', '2', '0.938461538', '0.24', '1', '1', '14', '1', '0.6667', '3']
package org . apache . log4j . or ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	0	['9', '1', '0', '5', '19', '10', '3', '2', '7', '0.375', '120', '0', '1', '0', '0.4375', '0', '0', '12.11111111', '4', '1.6667', '0']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	1	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '2']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public class CyclicBuffer { LoggingEvent [ ] ea ; int first ; int last ; int numElems ; int maxSize ; public CyclicBuffer ( int maxSize ) throws IllegalArgumentException { if ( maxSize < 1 ) { throw new IllegalArgumentException ( "The maxSize argument (" + maxSize + ") is not a positive integer." ) ; } this . maxSize = maxSize ; ea = new LoggingEvent [ maxSize ] ; first = 0 ; last = 0 ; numElems = 0 ; } public void add ( LoggingEvent event ) { ea [ last ] = event ; if ( ++ last == maxSize ) last = 0 ; if ( numElems < maxSize ) numElems ++ ; else if ( ++ first == maxSize ) first = 0 ; } public LoggingEvent get ( int i ) { if ( i < 0 || i >= numElems ) return null ; return ea [ ( first + i ) % maxSize ] ; } public int getMaxSize ( ) { return maxSize ; } public LoggingEvent get ( ) { LoggingEvent r = null ; if ( numElems > 0 ) { numElems -- ; r = ea [ first ] ; ea [ first ] = null ; if ( ++ first == maxSize ) first = 0 ; } return r ; } public int length ( ) { return numElems ; } public void resize ( int newSize ) { if ( newSize < 0 ) { throw new IllegalArgumentException ( "Negative array size [" + newSize + "] not allowed." ) ; } if ( newSize == numElems ) return ; LoggingEvent [ ] temp = new LoggingEvent [ newSize ] ; int loopLen = newSize < numElems ? newSize : numElems ; for ( int i = 0 ; i < loopLen ; i ++ ) { temp [ i ] = ea [ first ] ; ea [ first ] = null ; if ( ++ first == numElems ) first = 0 ; } ea = temp ; first = 0 ; numElems = loopLen ; maxSize = newSize ; if ( loopLen == newSize ) { last = 0 ; } else { last = loopLen ; } } } 	0	['7', '1', '0', '2', '13', '0', '1', '1', '7', '0.333333333', '246', '0', '1', '0', '0.523809524', '0', '0', '33.42857143', '7', '2.7143', '0']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new ConsoleAppender ( layout , ConsoleAppender . SYSTEM_OUT ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	1	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '1']
package org . apache . log4j ; import org . apache . log4j . spi . CategoryFactory ; class DefaultCategoryFactory implements CategoryFactory { DefaultCategoryFactory ( ) { } public Category makeNewCategoryInstance ( String name ) { return new Category ( name ) ; } } 	0	['2', '1', '0', '4', '4', '1', '2', '2', '1', '2', '10', '0', '0', '0', '0.75', '0', '0', '4', '1', '0.5', '0']
package org . apache . log4j . lf5 ; import org . apache . log4j . lf5 . viewer . LogBrokerMonitor ; public class AppenderFinalizer { protected LogBrokerMonitor _defaultMonitor = null ; public AppenderFinalizer ( LogBrokerMonitor defaultMonitor ) { _defaultMonitor = defaultMonitor ; } protected void finalize ( ) throws Throwable { System . out . println ( "Disposing of the default LogBrokerMonitor instance" ) ; _defaultMonitor . dispose ( ) ; } } 	1	['2', '1', '0', '2', '5', '0', '1', '1', '1', '0', '19', '1', '1', '0', '0.75', '0', '0', '8', '1', '0.5', '2']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . FileAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "xml/stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	0	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public boolean isAttached ( Appender appender ) { if ( appenderList == null || appender == null ) return false ; int size = appenderList . size ( ) ; Appender a ; for ( int i = 0 ; i < size ; i ++ ) { a = ( Appender ) appenderList . elementAt ( i ) ; if ( a == appender ) return true ; } return false ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	1	['9', '1', '0', '6', '23', '0', '3', '3', '9', '0.125', '208', '1', '0', '0', '0.416666667', '0', '0', '22', '5', '3.3333', '2']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '0']
package org . apache . log4j . lf5 . util ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . net . URL ; public class Resource { protected String _name ; public Resource ( ) { super ( ) ; } public Resource ( String name ) { _name = name ; } public void setName ( String name ) { _name = name ; } public String getName ( ) { return ( _name ) ; } public InputStream getInputStream ( ) { InputStream in = ResourceUtils . getResourceAsStream ( this , this ) ; return ( in ) ; } public InputStreamReader getInputStreamReader ( ) { InputStream in = ResourceUtils . getResourceAsStream ( this , this ) ; if ( in == null ) { return null ; } InputStreamReader reader = new InputStreamReader ( in ) ; return reader ; } public URL getURL ( ) { return ( ResourceUtils . getResourceAsURL ( this , this ) ) ; } } 	1	['7', '1', '0', '3', '11', '15', '3', '1', '7', '0.666666667', '49', '1', '0', '0', '0.642857143', '0', '0', '5.857142857', '2', '0.8571', '2']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import org . apache . log4j . net . SocketAppender ; public class Loop { public static void main ( String [ ] args ) { Category root = Category . getRoot ( ) ; Category cat = Category . getInstance ( Loop . class . getName ( ) ) ; if ( args . length != 2 ) usage ( "Wrong number of arguments." ) ; String host = args [ 0 ] ; int port = 0 ; try { port = Integer . valueOf ( args [ 1 ] ) . intValue ( ) ; } catch ( NumberFormatException e ) { usage ( "Argument [" + args [ 1 ] + "] is not in proper int form." ) ; } SocketAppender sa = new SocketAppender ( host , port ) ; Layout layout = new PatternLayout ( "%5p [%t] %x %c - %m\n" ) ; Appender so = new ConsoleAppender ( layout , "System.out" ) ; root . addAppender ( sa ) ; root . addAppender ( so ) ; int i = 0 ; while ( true ) { NDC . push ( "" + ( i ++ ) ) ; cat . debug ( "Debug message." ) ; root . info ( "Info message." ) ; NDC . pop ( ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Loop . class . getName ( ) + " host port" ) ; System . exit ( 1 ) ; } } 	0	['4', '1', '0', '7', '27', '4', '0', '7', '2', '0.666666667', '134', '0', '0', '0', '0.333333333', '0', '0', '32.25', '3', '1.5', '0']
package org . apache . log4j . lf5 ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; public abstract class LogRecord implements java . io . Serializable { protected static long _seqCount = 0 ; protected LogLevel _level ; protected String _message ; protected long _sequenceNumber ; protected long _millis ; protected String _category ; protected String _thread ; protected String _thrownStackTrace ; protected Throwable _thrown ; protected String _ndc ; protected String _location ; public LogRecord ( ) { super ( ) ; _millis = System . currentTimeMillis ( ) ; _category = "Debug" ; _message = "" ; _level = LogLevel . INFO ; _sequenceNumber = getNextId ( ) ; _thread = Thread . currentThread ( ) . toString ( ) ; _ndc = "" ; _location = "" ; } public LogLevel getLevel ( ) { return ( _level ) ; } public void setLevel ( LogLevel level ) { _level = level ; } public abstract boolean isSevereLevel ( ) ; public boolean hasThrown ( ) { Throwable thrown = getThrown ( ) ; if ( thrown == null ) { return false ; } String thrownString = thrown . toString ( ) ; return thrownString != null && thrownString . trim ( ) . length ( ) != 0 ; } public boolean isFatal ( ) { return isSevereLevel ( ) || hasThrown ( ) ; } public String getCategory ( ) { return ( _category ) ; } public void setCategory ( String category ) { _category = category ; } public String getMessage ( ) { return ( _message ) ; } public void setMessage ( String message ) { _message = message ; } public long getSequenceNumber ( ) { return ( _sequenceNumber ) ; } public void setSequenceNumber ( long number ) { _sequenceNumber = number ; } public long getMillis ( ) { return _millis ; } public void setMillis ( long millis ) { _millis = millis ; } public String getThreadDescription ( ) { return ( _thread ) ; } public void setThreadDescription ( String threadDescription ) { _thread = threadDescription ; } public String getThrownStackTrace ( ) { return ( _thrownStackTrace ) ; } public void setThrownStackTrace ( String trace ) { _thrownStackTrace = trace ; } public Throwable getThrown ( ) { return ( _thrown ) ; } public void setThrown ( Throwable thrown ) { if ( thrown == null ) { return ; } _thrown = thrown ; StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; thrown . printStackTrace ( out ) ; out . flush ( ) ; _thrownStackTrace = sw . toString ( ) ; try { out . close ( ) ; sw . close ( ) ; } catch ( IOException e ) { } out = null ; sw = null ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "LogRecord: [" + _level + ", " + _message + "]" ) ; return ( buf . toString ( ) ) ; } public String getNDC ( ) { return _ndc ; } public void setNDC ( String ndc ) { _ndc = ndc ; } public String getLocation ( ) { return _location ; } public void setLocation ( String location ) { _location = location ; } public static synchronized void resetSequenceNumber ( ) { _seqCount = 0 ; } protected static synchronized long getNextId ( ) { _seqCount ++ ; return _seqCount ; } } 	1	['28', '1', '2', '17', '46', '306', '16', '1', '26', '0.912457912', '236', '1', '1', '0', '0.259259259', '0', '0', '7.035714286', '4', '1.1429', '2']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; public class ThreadGroupRenderer implements ObjectRenderer { public ThreadGroupRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof ThreadGroup ) { StringBuffer sbuf = new StringBuffer ( ) ; ThreadGroup tg = ( ThreadGroup ) o ; sbuf . append ( "java.lang.ThreadGroup[name=" ) ; sbuf . append ( tg . getName ( ) ) ; sbuf . append ( ", maxpri=" ) ; sbuf . append ( tg . getMaxPriority ( ) ) ; sbuf . append ( "]" ) ; Thread [ ] t = new Thread [ tg . activeCount ( ) ] ; tg . enumerate ( t ) ; for ( int i = 0 ; i < t . length ; i ++ ) { sbuf . append ( Layout . LINE_SEP ) ; sbuf . append ( "   Thread=[" ) ; sbuf . append ( t [ i ] . getName ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . getPriority ( ) ) ; sbuf . append ( "," ) ; sbuf . append ( t [ i ] . isDaemon ( ) ) ; sbuf . append ( "]" ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '2', '16', '1', '0', '2', '2', '2', '100', '0', '0', '0', '0.75', '0', '0', '49', '3', '1.5', '0']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } private static long previousTime ; private static char [ ] previousTimeWithoutMillis = new char [ 9 ] ; public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { long now = date . getTime ( ) ; int millis = ( int ) ( now % 1000 ) ; if ( ( now - millis ) != previousTime ) { calendar . setTime ( date ) ; int start = sbuf . length ( ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; sbuf . getChars ( start , sbuf . length ( ) , previousTimeWithoutMillis , 0 ) ; previousTime = now - millis ; } else { sbuf . append ( previousTimeWithoutMillis ) ; } if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	1	['5', '3', '2', '4', '17', '8', '4', '0', '4', '1.1', '148', '0.4', '0', '0.951219512', '0.357142857', '1', '3', '27.6', '7', '1.6', '3']
package org . apache . log4j . net . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . net . SocketAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class SyslogMin { static Category CAT = Category . getInstance ( SyslogMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SyslogMin . class + " configFile" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String configFile ) { int port = 0 ; PropertyConfigurator . configure ( configFile ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; CAT . debug ( "Message " + i ++ ) ; CAT . info ( "Message " + i ++ ) ; CAT . warn ( "Message " + i ++ ) ; CAT . error ( "Message " + i ++ ) ; CAT . log ( Priority . FATAL , "Message " + i ++ ) ; CAT . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '4', '29', '17', '0', '4', '2', '0.666666667', '154', '0', '1', '0', '0.333333333', '0', '0', '20.71428571', '2', '1', '0']
package org . apache . log4j . helpers ; import java . util . Hashtable ; final public class ThreadLocalMap extends InheritableThreadLocal { public final Object childValue ( Object parentValue ) { Hashtable ht = ( Hashtable ) parentValue ; if ( ht != null ) { return ht . clone ( ) ; } else { return null ; } } } 	1	['2', '3', '0', '1', '4', '1', '1', '0', '2', '2', '15', '0', '0', '0.933333333', '0.75', '0', '0', '6.5', '2', '1', '2']
package org . apache . log4j . spi ; public interface ErrorCode { public final int GENERIC_FAILURE = 0 ; public final int WRITE_FAILURE = 1 ; public final int FLUSH_FAILURE = 2 ; public final int CLOSE_FAILURE = 3 ; public final int FILE_OPEN_FAILURE = 4 ; public final int MISSING_LAYOUT = 5 ; public final int ADDRESS_PARSE_FAILURE = 6 ; } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . log4j . lf5 . viewer . configure ; import java . io . * ; import java . net . URL ; import java . util . Iterator ; import java . util . LinkedList ; public class MRUFileManager { private static final String CONFIG_FILE_NAME = "mru_file_manager" ; private static final int DEFAULT_MAX_SIZE = 3 ; public static final String UNIX_SEPARATOR = "/" ; public static final String DOS_SEPARATOR = "\\" ; private int _maxSize = 0 ; private LinkedList _mruFileList ; public MRUFileManager ( ) { load ( ) ; setMaxSize ( DEFAULT_MAX_SIZE ) ; } public MRUFileManager ( int maxSize ) { load ( ) ; setMaxSize ( maxSize ) ; } public void save ( ) { File file = new File ( getFilename ( ) ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos . writeObject ( _mruFileList ) ; oos . flush ( ) ; oos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public int size ( ) { return _mruFileList . size ( ) ; } public Object getFile ( int index ) { if ( index < size ( ) ) { return _mruFileList . get ( index ) ; } return null ; } public InputStream getInputStream ( int index ) throws IOException , FileNotFoundException { if ( index < size ( ) ) { Object o = getFile ( index ) ; if ( o instanceof File ) { return getInputStream ( ( File ) o ) ; } else { return getInputStream ( ( URL ) o ) ; } } return null ; } public void set ( File file ) { setMRU ( file ) ; } public void set ( URL url ) { setMRU ( url ) ; } public String [ ] getMRUFileList ( ) { if ( size ( ) == 0 ) { return null ; } String [ ] ss = new String [ size ( ) ] ; for ( int i = 0 ; i < size ( ) ; i ++ ) { Object o = getFile ( i ) ; if ( o instanceof File ) { ss [ i ] = ( ( File ) o ) . getAbsolutePath ( ) ; } else { ss [ i ] = o . toString ( ) ; } } return ss ; } public void moveToTop ( int index ) { _mruFileList . add ( 0 , _mruFileList . remove ( index ) ) ; } public static void createConfigurationDirectory ( ) { String home = System . getProperty ( "user.home" ) ; String sep = ( home . startsWith ( UNIX_SEPARATOR ) ) ? UNIX_SEPARATOR : DOS_SEPARATOR ; File f = new File ( home + sep + "lf5" ) ; if ( ! f . exists ( ) ) { try { f . mkdir ( ) ; } catch ( SecurityException e ) { e . printStackTrace ( ) ; } } } protected InputStream getInputStream ( File file ) throws IOException , FileNotFoundException { BufferedInputStream reader = new BufferedInputStream ( new FileInputStream ( file ) ) ; return reader ; } protected InputStream getInputStream ( URL url ) throws IOException { return url . openStream ( ) ; } protected void setMRU ( Object o ) { int index = _mruFileList . indexOf ( o ) ; if ( index == - 1 ) { _mruFileList . add ( 0 , o ) ; setMaxSize ( _maxSize ) ; } else { moveToTop ( index ) ; } } protected void load ( ) { createConfigurationDirectory ( ) ; File file = new File ( getFilename ( ) ) ; if ( file . exists ( ) ) { try { ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( file ) ) ; _mruFileList = ( LinkedList ) ois . readObject ( ) ; ois . close ( ) ; Iterator it = _mruFileList . iterator ( ) ; while ( it . hasNext ( ) ) { Object o = it . next ( ) ; if ( ! ( o instanceof File ) && ! ( o instanceof URL ) ) { it . remove ( ) ; } } } catch ( Exception e ) { _mruFileList = new LinkedList ( ) ; } } else { _mruFileList = new LinkedList ( ) ; } } protected String getFilename ( ) { String home = System . getProperty ( "user.home" ) ; String sep = ( home . startsWith ( UNIX_SEPARATOR ) ) ? UNIX_SEPARATOR : DOS_SEPARATOR ; return home + sep + "lf5" + sep + CONFIG_FILE_NAME ; } protected void setMaxSize ( int maxSize ) { if ( maxSize < _mruFileList . size ( ) ) { for ( int i = 0 ; i < _mruFileList . size ( ) - maxSize ; i ++ ) { _mruFileList . removeFirst ( ) ; } } _maxSize = maxSize ; } } 	1	['17', '1', '0', '1', '51', '84', '1', '0', '11', '0.864583333', '344', '0.666666667', '0', '0', '0.305882353', '0', '0', '18.88235294', '4', '1.5294', '2']
package org . apache . log4j . helpers ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class RelativeTimeDateFormat extends DateFormat { protected final long startTime ; public RelativeTimeDateFormat ( ) { this . startTime = System . currentTimeMillis ( ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { return sbuf . append ( ( date . getTime ( ) - startTime ) ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['3', '3', '0', '1', '7', '1', '1', '0', '3', '0.5', '20', '1', '0', '0.951219512', '0.444444444', '1', '3', '5.333333333', '1', '0.6667', '0']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	1	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . log4j ; import java . beans . * ; import org . apache . log4j . helpers . LogLog ; import java . lang . reflect . Method ; public class RollingFileAppenderBeanInfo extends SimpleBeanInfo { private PropertyDescriptor [ ] props ; public RollingFileAppenderBeanInfo ( ) { Class clazz = RollingFileAppender . class ; try { BeanInfo bi = Introspector . getBeanInfo ( clazz , Introspector . IGNORE_ALL_BEANINFO ) ; props = bi . getPropertyDescriptors ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { if ( props [ i ] . getName ( ) . equals ( "maxFileSize" ) ) { Method m = clazz . getMethod ( "setMaxFileSize" , new Class [ ] { String . class } ) ; props [ i ] = new PropertyDescriptor ( "maxFileSize" , null , m ) ; } } } Introspector . flushFromCaches ( RollingFileAppender . class ) ; } catch ( IntrospectionException e ) { LogLog . error ( "Could not inspect RollingFileAppender." , e ) ; } catch ( NoSuchMethodException e ) { LogLog . error ( "Could not find setter method for RollingFileAppender." , e ) ; } } public PropertyDescriptor [ ] getPropertyDescriptors ( ) { return props ; } } 	0	['3', '2', '0', '1', '15', '1', '0', '1', '2', '0.833333333', '105', '0.333333333', '0', '0.818181818', '0.5', '0', '0', '33', '1', '0.6667', '0']
package org . apache . log4j . net ; import java . net . Socket ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . BufferedInputStream ; import org . apache . log4j . * ; import org . apache . log4j . spi . * ; public class SocketNode implements Runnable { Socket socket ; LoggerRepository hierarchy ; ObjectInputStream ois ; static Logger logger = Logger . getLogger ( SocketNode . class ) ; public SocketNode ( Socket socket , LoggerRepository hierarchy ) { this . socket = socket ; this . hierarchy = hierarchy ; try { ois = new ObjectInputStream ( new BufferedInputStream ( socket . getInputStream ( ) ) ) ; } catch ( Exception e ) { logger . error ( "Could not open ObjectInputStream to " + socket , e ) ; } } public void run ( ) { LoggingEvent event ; Logger remoteLogger ; try { while ( true ) { event = ( LoggingEvent ) ois . readObject ( ) ; remoteLogger = hierarchy . getLogger ( event . categoryName ) ; event . logger = remoteLogger ; if ( event . level . isGreaterOrEqual ( remoteLogger . getEffectiveLevel ( ) ) ) { remoteLogger . callAppenders ( event ) ; } } } catch ( java . io . EOFException e ) { logger . info ( "Caught java.io.EOFException closing conneciton." ) ; } catch ( java . net . SocketException e ) { logger . info ( "Caught java.net.SocketException closing conneciton." ) ; } catch ( IOException e ) { logger . info ( "Caught java.io.IOException: " + e ) ; logger . info ( "Closing connection." ) ; } catch ( Exception e ) { logger . error ( "Unexpected exception. Closing conneciton." , e ) ; } try { ois . close ( ) ; } catch ( Exception e ) { logger . info ( "Could not close connection." , e ) ; } } } 	1	['4', '1', '0', '9', '25', '0', '3', '6', '2', '0.733333333', '126', '0', '2', '0', '0.416666667', '0', '0', '29.25', '2', '0.75', '2']
package org . apache . log4j . helpers ; import java . util . Date ; import java . util . Calendar ; import java . util . TimeZone ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; public class AbsoluteTimeDateFormat extends DateFormat { public final static String ABS_TIME_DATE_FORMAT = "ABSOLUTE" ; public final static String DATE_AND_TIME_DATE_FORMAT = "DATE" ; public final static String ISO8601_DATE_FORMAT = "ISO8601" ; public AbsoluteTimeDateFormat ( ) { setCalendar ( Calendar . getInstance ( ) ) ; } public AbsoluteTimeDateFormat ( TimeZone timeZone ) { setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; if ( hour < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( hour ) ; sbuf . append ( ':' ) ; int mins = calendar . get ( Calendar . MINUTE ) ; if ( mins < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( mins ) ; sbuf . append ( ':' ) ; int secs = calendar . get ( Calendar . SECOND ) ; if ( secs < 10 ) { sbuf . append ( '0' ) ; } sbuf . append ( secs ) ; sbuf . append ( ',' ) ; int millis = calendar . get ( Calendar . MILLISECOND ) ; if ( millis < 100 ) sbuf . append ( '0' ) ; if ( millis < 10 ) sbuf . append ( '0' ) ; sbuf . append ( millis ) ; return sbuf ; } public Date parse ( String s , ParsePosition pos ) { return null ; } } 	0	['4', '3', '2', '4', '12', '6', '4', '0', '4', '1.333333333', '111', '0', '0', '0.951219512', '0.357142857', '1', '3', '26', '6', '1.75', '0']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	1	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '2']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . xml . DOMConfigurator ; public class DelayedLoop { static Category cat = Category . getInstance ( DelayedLoop . class ) ; static int loopLength ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + DelayedLoop . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { if ( configFile . endsWith ( "xml" ) ) { DOMConfigurator . configureAndWatch ( configFile , 3000 ) ; } else { PropertyConfigurator . configureAndWatch ( configFile , 3000 ) ; } } static void test ( ) { int i = 0 ; while ( true ) { cat . debug ( "MSG " + i ++ ) ; try { Thread . currentThread ( ) . sleep ( 1000 ) ; } catch ( Exception e ) { } } } } 	0	['7', '1', '0', '3', '25', '17', '0', '3', '2', '0.833333333', '105', '0', '1', '0', '0.277777778', '0', '0', '13.57142857', '2', '1.1429', '0']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . log4j . or ; public interface ObjectRenderer { public String doRender ( Object o ) ; } 	0	['1', '1', '0', '7', '1', '0', '7', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	1	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '1']
package org . apache . log4j . performance ; import java . util . Vector ; public class ListVsVector { static int RUN_LENGTH = 1000000 ; static Vector v = new Vector ( ) ; static Chain head ; static String tmp ; static public void main ( String [ ] args ) { v . addElement ( "aaa" ) ; v . addElement ( "bbb" ) ; v . addElement ( "ccc" ) ; v . addElement ( "ddd" ) ; v . addElement ( "eee" ) ; Chain c = new Chain ( "aaa" ) ; head = c ; c . next = new Chain ( "bbb" ) ; c = c . next ; c . next = new Chain ( "ccc" ) ; c = c . next ; c . next = new Chain ( "ddd" ) ; c = c . next ; c . next = new Chain ( "eee" ) ; double t ; t = loopChain ( ) ; System . out . println ( "Looping thourgh the chain took " + t ) ; t = loopVector ( ) ; System . out . println ( "Looping thourgh the vector took " + t ) ; } static double loopChain ( ) { long before = System . currentTimeMillis ( ) ; Chain c ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { c = head ; while ( c != null ) { tmp = c . s ; c = c . next ; } } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double loopVector ( ) { long before = System . currentTimeMillis ( ) ; int size = v . size ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) tmp = ( String ) v . elementAt ( j ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static class Chain { public String s ; public Chain next ; Chain ( String s ) { this . s = s ; } void setNext ( Chain c ) { next = c ; } } } 	0	['5', '1', '0', '1', '17', '0', '0', '1', '2', '0.5', '163', '0', '1', '0', '0.25', '0', '0', '30.8', '3', '1.4', '0']
package org . apache . log4j . lf5 . viewer ; import org . apache . log4j . lf5 . util . DateFormatManager ; import javax . swing . * ; import javax . swing . event . ListSelectionEvent ; import javax . swing . event . ListSelectionListener ; import javax . swing . table . TableColumn ; import javax . swing . table . TableColumnModel ; import java . awt . * ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; public class LogTable extends JTable { protected int _rowHeight = 30 ; protected JTextArea _detailTextArea ; protected int _numCols = 9 ; protected TableColumn [ ] _tableColumns = new TableColumn [ _numCols ] ; protected int [ ] _colWidths = { 40 , 40 , 40 , 70 , 70 , 360 , 440 , 200 , 60 } ; protected LogTableColumn [ ] _colNames = LogTableColumn . getLogTableColumnArray ( ) ; protected int _colDate = 0 ; protected int _colThread = 1 ; protected int _colMessageNum = 2 ; protected int _colLevel = 3 ; protected int _colNDC = 4 ; protected int _colCategory = 5 ; protected int _colMessage = 6 ; protected int _colLocation = 7 ; protected int _colThrown = 8 ; protected DateFormatManager _dateFormatManager = null ; public LogTable ( JTextArea detailTextArea ) { super ( ) ; init ( ) ; _detailTextArea = detailTextArea ; setModel ( new FilteredLogTableModel ( ) ) ; Enumeration columns = getColumnModel ( ) . getColumns ( ) ; int i = 0 ; while ( columns . hasMoreElements ( ) ) { TableColumn col = ( TableColumn ) columns . nextElement ( ) ; col . setCellRenderer ( new LogTableRowRenderer ( ) ) ; col . setPreferredWidth ( _colWidths [ i ] ) ; _tableColumns [ i ] = col ; i ++ ; } ListSelectionModel rowSM = getSelectionModel ( ) ; rowSM . addListSelectionListener ( new LogTableListSelectionListener ( this ) ) ; } public DateFormatManager getDateFormatManager ( ) { return _dateFormatManager ; } public void setDateFormatManager ( DateFormatManager dfm ) { _dateFormatManager = dfm ; } public synchronized void clearLogRecords ( ) { getFilteredLogTableModel ( ) . clear ( ) ; } public FilteredLogTableModel getFilteredLogTableModel ( ) { return ( FilteredLogTableModel ) getModel ( ) ; } public void setDetailedView ( ) { TableColumnModel model = getColumnModel ( ) ; for ( int f = 0 ; f < _numCols ; f ++ ) { model . removeColumn ( _tableColumns [ f ] ) ; } for ( int i = 0 ; i < _numCols ; i ++ ) { model . addColumn ( _tableColumns [ i ] ) ; } sizeColumnsToFit ( - 1 ) ; } public void setView ( List columns ) { TableColumnModel model = getColumnModel ( ) ; for ( int f = 0 ; f < _numCols ; f ++ ) { model . removeColumn ( _tableColumns [ f ] ) ; } Iterator selectedColumns = columns . iterator ( ) ; Vector columnNameAndNumber = getColumnNameAndNumber ( ) ; while ( selectedColumns . hasNext ( ) ) { model . addColumn ( _tableColumns [ columnNameAndNumber . indexOf ( selectedColumns . next ( ) ) ] ) ; } sizeColumnsToFit ( - 1 ) ; } public void setFont ( Font font ) { super . setFont ( font ) ; Graphics g = this . getGraphics ( ) ; if ( g != null ) { FontMetrics fm = g . getFontMetrics ( font ) ; int height = fm . getHeight ( ) ; _rowHeight = height + height / 3 ; setRowHeight ( _rowHeight ) ; } } protected void init ( ) { setRowHeight ( _rowHeight ) ; setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; } protected Vector getColumnNameAndNumber ( ) { Vector columnNameAndNumber = new Vector ( ) ; for ( int i = 0 ; i < _colNames . length ; i ++ ) { columnNameAndNumber . add ( i , _colNames [ i ] ) ; } return columnNameAndNumber ; } class LogTableListSelectionListener implements ListSelectionListener { protected JTable _table ; public LogTableListSelectionListener ( JTable table ) { _table = table ; } public void valueChanged ( ListSelectionEvent e ) { if ( e . getValueIsAdjusting ( ) ) { return ; } ListSelectionModel lsm = ( ListSelectionModel ) e . getSource ( ) ; if ( lsm . isSelectionEmpty ( ) ) { } else { StringBuffer buf = new StringBuffer ( ) ; int selectedRow = lsm . getMinSelectionIndex ( ) ; for ( int i = 0 ; i < _numCols - 1 ; i ++ ) { String value = "" ; Object obj = _table . getModel ( ) . getValueAt ( selectedRow , i ) ; if ( obj != null ) { value = obj . toString ( ) ; } buf . append ( _colNames [ i ] + ":" ) ; buf . append ( "\t" ) ; if ( i == _colThread || i == _colMessage || i == _colLevel ) { buf . append ( "\t" ) ; } if ( i == _colDate || i == _colNDC ) { buf . append ( "\t\t" ) ; } buf . append ( value ) ; buf . append ( "\n" ) ; } buf . append ( _colNames [ _numCols - 1 ] + ":\n" ) ; Object obj = _table . getModel ( ) . getValueAt ( selectedRow , _numCols - 1 ) ; if ( obj != null ) { buf . append ( obj . toString ( ) ) ; } _detailTextArea . setText ( buf . toString ( ) ) ; } } } } 	1	['10', '5', '0', '20', '41', '25', '16', '5', '8', '0.930555556', '311', '1', '2', '0.989130435', '0.28', '3', '3', '28.5', '3', '1.5', '3']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	0	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '0']
package org . apache . log4j ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OnlyOnceErrorHandler ; import org . apache . log4j . helpers . LogLog ; public abstract class AppenderSkeleton implements Appender , OptionHandler { protected Layout layout ; protected String name ; protected Priority threshold ; protected ErrorHandler errorHandler = new OnlyOnceErrorHandler ( ) ; protected Filter headFilter ; protected Filter tailFilter ; protected boolean closed = false ; public void activateOptions ( ) { } public void addFilter ( Filter newFilter ) { if ( headFilter == null ) { headFilter = tailFilter = newFilter ; } else { tailFilter . next = newFilter ; tailFilter = newFilter ; } } abstract protected void append ( LoggingEvent event ) ; public void clearFilters ( ) { headFilter = tailFilter = null ; } public void finalize ( ) { if ( this . closed ) return ; LogLog . debug ( "Finalizing appender named [" + name + "]." ) ; close ( ) ; } public ErrorHandler getErrorHandler ( ) { return this . errorHandler ; } public Filter getFilter ( ) { return headFilter ; } public final Filter getFirstFilter ( ) { return headFilter ; } public Layout getLayout ( ) { return layout ; } public final String getName ( ) { return this . name ; } public Priority getThreshold ( ) { return threshold ; } public boolean isAsSevereAsThreshold ( Priority priority ) { return ( ( threshold == null ) || priority . isGreaterOrEqual ( threshold ) ) ; } public synchronized void doAppend ( LoggingEvent event ) { if ( closed ) { LogLog . error ( "Attempted to append to closed appender named [" + name + "]." ) ; return ; } if ( ! isAsSevereAsThreshold ( event . level ) ) { return ; } Filter f = this . headFilter ; FILTER_LOOP : while ( f != null ) { switch ( f . decide ( event ) ) { case Filter . DENY : return ; case Filter . ACCEPT : break FILTER_LOOP ; case Filter . NEUTRAL : f = f . next ; } } this . append ( event ) ; } public synchronized void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { LogLog . warn ( "You have tried to set a null error-handler." ) ; } else { this . errorHandler = eh ; } } public void setLayout ( Layout layout ) { this . layout = layout ; } public void setName ( String name ) { this . name = name ; } public void setThreshold ( Priority threshold ) { this . threshold = threshold ; } } 	1	['20', '1', '12', '27', '31', '140', '18', '9', '19', '0.879699248', '175', '1', '5', '0', '0.2', '0', '0', '7.4', '4', '1.35', '4']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import org . apache . log4j . Appender ; import java . util . Enumeration ; import java . util . Vector ; public class MultipleAppenders { public static void main ( String argv [ ] ) { PropertyConfigurator . configure ( argv [ 0 ] ) ; Category root = Category . getRoot ( ) ; Enumeration e1 = root . getAllAppenders ( ) ; Vector v = new Vector ( 1 ) ; while ( e1 . hasMoreElements ( ) ) { Appender a = ( Appender ) e1 . nextElement ( ) ; v . addElement ( a ) ; String appenderName = a . getName ( ) ; if ( a != root . getAppender ( appenderName ) ) { System . out . println ( appenderName + " lookup failed. Exiting." ) ; System . exit ( 1 ) ; } root . addAppender ( a ) ; } root . addAppender ( null ) ; Enumeration e2 = root . getAllAppenders ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v . elementAt ( i ) != e2 . nextElement ( ) ) { } } if ( e2 . hasMoreElements ( ) ) { System . out . println ( "Failure, e2 has remaining elements. Exiting." ) ; System . exit ( 1 ) ; } System . out . println ( "OK" ) ; } } 	0	['2', '1', '0', '3', '20', '1', '0', '3', '2', '2', '85', '0', '0', '0', '0.5', '0', '0', '41.5', '6', '3', '0']
package org . apache . log4j ; public class Level extends Priority { final static public Level OFF = new Level ( OFF_INT , "OFF" , 0 ) ; final static public Level FATAL = new Level ( FATAL_INT , "FATAL" , 0 ) ; final static public Level ERROR = new Level ( ERROR_INT , "ERROR" , 3 ) ; final static public Level WARN = new Level ( WARN_INT , "WARN" , 4 ) ; final static public Level INFO = new Level ( INFO_INT , "INFO" , 6 ) ; final static public Level DEBUG = new Level ( DEBUG_INT , "DEBUG" , 7 ) ; final static public Level ALL = new Level ( ALL_INT , "ALL" , 7 ) ; protected Level ( int level , String levelStr , int syslogEquivalent ) { super ( level , levelStr , syslogEquivalent ) ; } public static Level toLevel ( String sArg ) { return ( Level ) toLevel ( sArg , Level . DEBUG ) ; } public static Level toLevel ( int val ) { return ( Level ) toLevel ( val , Level . DEBUG ) ; } public static Level toLevel ( int val , Level defaultLevel ) { switch ( val ) { case ALL_INT : return ALL ; case DEBUG_INT : return Level . DEBUG ; case INFO_INT : return Level . INFO ; case WARN_INT : return Level . WARN ; case ERROR_INT : return Level . ERROR ; case FATAL_INT : return Level . FATAL ; case OFF_INT : return OFF ; default : return defaultLevel ; } } public static Level toLevel ( String sArg , Level defaultLevel ) { if ( sArg == null ) return defaultLevel ; String s = sArg . toUpperCase ( ) ; if ( s . equals ( "ALL" ) ) return Level . ALL ; if ( s . equals ( "DEBUG" ) ) return Level . DEBUG ; if ( s . equals ( "INFO" ) ) return Level . INFO ; if ( s . equals ( "WARN" ) ) return Level . WARN ; if ( s . equals ( "ERROR" ) ) return Level . ERROR ; if ( s . equals ( "FATAL" ) ) return Level . FATAL ; if ( s . equals ( "OFF" ) ) return Level . OFF ; return defaultLevel ; } } 	1	['6', '2', '0', '24', '9', '0', '24', '1', '4', '0.2', '146', '0', '7', '0.666666667', '0.45', '0', '0', '22.16666667', '9', '3.3333', '5']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; public interface CategoryFactory { public Category makeNewCategoryInstance ( String name ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	1	['4', '3', '2', '6', '12', '0', '5', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '2']
package org . apache . log4j . helpers ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import org . apache . log4j . Layout ; import org . apache . log4j . NDC ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . or . ObjectRenderer ; import org . apache . log4j . or . RendererMap ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Date ; public class PatternParser { private static final char ESCAPE_CHAR = '%' ; private static final int LITERAL_STATE = 0 ; private static final int CONVERTER_STATE = 1 ; private static final int MINUS_STATE = 2 ; private static final int DOT_STATE = 3 ; private static final int MIN_STATE = 4 ; private static final int MAX_STATE = 5 ; static final int FULL_LOCATION_CONVERTER = 1000 ; static final int METHOD_LOCATION_CONVERTER = 1001 ; static final int CLASS_LOCATION_CONVERTER = 1002 ; static final int LINE_LOCATION_CONVERTER = 1003 ; static final int FILE_LOCATION_CONVERTER = 1004 ; static final int RELATIVE_TIME_CONVERTER = 2000 ; static final int THREAD_CONVERTER = 2001 ; static final int PRIORITY_CONVERTER = 2002 ; static final int NDC_CONVERTER = 2003 ; static final int MESSAGE_CONVERTER = 2004 ; int state ; protected StringBuffer currentLiteral = new StringBuffer ( 32 ) ; protected int patternLength ; protected int i ; PatternConverter head ; PatternConverter tail ; protected FormattingInfo formattingInfo = new FormattingInfo ( ) ; protected String pattern ; public PatternParser ( String pattern ) { this . pattern = pattern ; patternLength = pattern . length ( ) ; state = LITERAL_STATE ; } private void addToList ( PatternConverter pc ) { if ( head == null ) { head = tail = pc ; } else { tail . next = pc ; tail = pc ; } } private String extractOption ( ) { if ( ( i < patternLength ) && ( pattern . charAt ( i ) == '{' ) ) { int end = pattern . indexOf ( '}' , i ) ; if ( end > i ) { String r = pattern . substring ( i + 1 , end ) ; i = end + 1 ; return r ; } } return null ; } private int extractPrecisionOption ( ) { String opt = extractOption ( ) ; int r = 0 ; if ( opt != null ) { try { r = Integer . parseInt ( opt ) ; if ( r <= 0 ) { LogLog . error ( "Precision option (" + opt + ") isn't a positive integer." ) ; r = 0 ; } } catch ( NumberFormatException e ) { LogLog . error ( "Category option \"" + opt + "\" not a decimal integer." , e ) ; } } return r ; } public PatternConverter parse ( ) { char c ; i = 0 ; while ( i < patternLength ) { c = pattern . charAt ( i ++ ) ; switch ( state ) { case LITERAL_STATE : if ( i == patternLength ) { currentLiteral . append ( c ) ; continue ; } if ( c == ESCAPE_CHAR ) { switch ( pattern . charAt ( i ) ) { case ESCAPE_CHAR : currentLiteral . append ( c ) ; i ++ ; break ; case 'n' : currentLiteral . append ( Layout . LINE_SEP ) ; i ++ ; break ; default : if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } currentLiteral . setLength ( 0 ) ; currentLiteral . append ( c ) ; state = CONVERTER_STATE ; formattingInfo . reset ( ) ; } } else { currentLiteral . append ( c ) ; } break ; case CONVERTER_STATE : currentLiteral . append ( c ) ; switch ( c ) { case '-' : formattingInfo . leftAlign = true ; break ; case '.' : state = DOT_STATE ; break ; default : if ( c >= '0' && c <= '9' ) { formattingInfo . min = c - '0' ; state = MIN_STATE ; } else finalizeConverter ( c ) ; } break ; case MIN_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . min = formattingInfo . min * 10 + ( c - '0' ) ; else if ( c == '.' ) state = DOT_STATE ; else { finalizeConverter ( c ) ; } break ; case DOT_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) { formattingInfo . max = c - '0' ; state = MAX_STATE ; } else { LogLog . error ( "Error occured in position " + i + ".\n Was expecting digit, instead got char \"" + c + "\"." ) ; state = LITERAL_STATE ; } break ; case MAX_STATE : currentLiteral . append ( c ) ; if ( c >= '0' && c <= '9' ) formattingInfo . max = formattingInfo . max * 10 + ( c - '0' ) ; else { finalizeConverter ( c ) ; state = LITERAL_STATE ; } break ; } } if ( currentLiteral . length ( ) != 0 ) { addToList ( new LiteralPatternConverter ( currentLiteral . toString ( ) ) ) ; } return head ; } protected void finalizeConverter ( char c ) { PatternConverter pc = null ; switch ( c ) { case 'c' : pc = new CategoryPatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'C' : pc = new ClassNamePatternConverter ( formattingInfo , extractPrecisionOption ( ) ) ; currentLiteral . setLength ( 0 ) ; break ; case 'd' : String dateFormatStr = AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ; DateFormat df ; String dOpt = extractOption ( ) ; if ( dOpt != null ) dateFormatStr = dOpt ; if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ISO8601_DATE_FORMAT ) ) df = new ISO8601DateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . ABS_TIME_DATE_FORMAT ) ) df = new AbsoluteTimeDateFormat ( ) ; else if ( dateFormatStr . equalsIgnoreCase ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ) df = new DateTimeDateFormat ( ) ; else { try { df = new SimpleDateFormat ( dateFormatStr ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Could not instantiate SimpleDateFormat with " + dateFormatStr , e ) ; df = ( DateFormat ) OptionConverter . instantiateByClassName ( "org.apache.log4j.helpers.ISO8601DateFormat" , DateFormat . class , null ) ; } } pc = new DatePatternConverter ( formattingInfo , df ) ; currentLiteral . setLength ( 0 ) ; break ; case 'F' : pc = new LocationPatternConverter ( formattingInfo , FILE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'l' : pc = new LocationPatternConverter ( formattingInfo , FULL_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'L' : pc = new LocationPatternConverter ( formattingInfo , LINE_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'm' : pc = new BasicPatternConverter ( formattingInfo , MESSAGE_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'M' : pc = new LocationPatternConverter ( formattingInfo , METHOD_LOCATION_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'p' : pc = new BasicPatternConverter ( formattingInfo , PRIORITY_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'r' : pc = new BasicPatternConverter ( formattingInfo , RELATIVE_TIME_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 't' : pc = new BasicPatternConverter ( formattingInfo , THREAD_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; case 'x' : pc = new BasicPatternConverter ( formattingInfo , NDC_CONVERTER ) ; currentLiteral . setLength ( 0 ) ; break ; default : LogLog . error ( "Unexpected char [" + c + "] at position " + i + " in conversion patterrn." ) ; pc = new LiteralPatternConverter ( currentLiteral . toString ( ) ) ; currentLiteral . setLength ( 0 ) ; } addConverter ( pc ) ; } protected void addConverter ( PatternConverter pc ) { currentLiteral . setLength ( 0 ) ; addToList ( pc ) ; state = LITERAL_STATE ; formattingInfo . reset ( ) ; } private static class BasicPatternConverter extends PatternConverter { int type ; BasicPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { switch ( type ) { case RELATIVE_TIME_CONVERTER : return ( Long . toString ( event . timeStamp - LoggingEvent . getStartTime ( ) ) ) ; case THREAD_CONVERTER : return event . getThreadName ( ) ; case PRIORITY_CONVERTER : return event . priority . toString ( ) ; case NDC_CONVERTER : return event . getNDC ( ) ; case MESSAGE_CONVERTER : { return event . getRenderedMessage ( ) ; } default : return null ; } } } private static class LiteralPatternConverter extends PatternConverter { private String literal ; LiteralPatternConverter ( String value ) { literal = value ; } public final void format ( StringBuffer sbuf , LoggingEvent event ) { sbuf . append ( literal ) ; } public String convert ( LoggingEvent event ) { return literal ; } } private static class DatePatternConverter extends PatternConverter { private DateFormat df ; private Date date ; DatePatternConverter ( FormattingInfo formattingInfo , DateFormat df ) { super ( formattingInfo ) ; date = new Date ( ) ; this . df = df ; } public String convert ( LoggingEvent event ) { date . setTime ( event . timeStamp ) ; String converted = null ; try { converted = df . format ( date ) ; } catch ( Exception ex ) { LogLog . error ( "Error occured while converting date." , ex ) ; } return converted ; } } private class LocationPatternConverter extends PatternConverter { int type ; LocationPatternConverter ( FormattingInfo formattingInfo , int type ) { super ( formattingInfo ) ; this . type = type ; } public String convert ( LoggingEvent event ) { LocationInfo locationInfo = event . getLocationInformation ( ) ; switch ( type ) { case FULL_LOCATION_CONVERTER : return locationInfo . fullInfo ; case METHOD_LOCATION_CONVERTER : return locationInfo . getMethodName ( ) ; case LINE_LOCATION_CONVERTER : return locationInfo . getLineNumber ( ) ; case FILE_LOCATION_CONVERTER : return locationInfo . getFileName ( ) ; default : return null ; } } } private static abstract class NamedPatternConverter extends PatternConverter { int precision ; NamedPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo ) ; this . precision = precision ; } abstract String getFullyQualifiedName ( LoggingEvent event ) ; public String convert ( LoggingEvent event ) { String n = getFullyQualifiedName ( event ) ; if ( precision <= 0 ) return n ; else { int len = n . length ( ) ; int end = len - 1 ; for ( int i = precision ; i > 0 ; i -- ) { end = n . lastIndexOf ( '.' , end - 1 ) ; if ( end == - 1 ) return n ; } return n . substring ( end + 1 , len ) ; } } } private class ClassNamePatternConverter extends NamedPatternConverter { ClassNamePatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . getLocationInformation ( ) . getClassName ( ) ; } } private class CategoryPatternConverter extends NamedPatternConverter { CategoryPatternConverter ( FormattingInfo formattingInfo , int precision ) { super ( formattingInfo , precision ) ; } String getFullyQualifiedName ( LoggingEvent event ) { return event . categoryName ; } } } 	0	['8', '1', '0', '15', '41', '8', '4', '14', '2', '0.956043956', '693', '0.461538462', '3', '0', '0.375', '0', '0', '82.375', '21', '6.25', '0']
package org . apache . log4j . spi ; public class DefaultRepositorySelector implements RepositorySelector { final LoggerRepository repository ; public DefaultRepositorySelector ( LoggerRepository repository ) { this . repository = repository ; } public LoggerRepository getLoggerRepository ( ) { return repository ; } } 	1	['2', '1', '0', '3', '3', '0', '1', '2', '2', '0', '12', '0', '1', '0', '0.75', '0', '0', '4.5', '1', '0.5', '2']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormat ; import java . text . DateFormatSymbols ; public class ISO8601DateFormat extends AbsoluteTimeDateFormat { public ISO8601DateFormat ( ) { } public ISO8601DateFormat ( TimeZone timeZone ) { super ( timeZone ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; String month ; switch ( calendar . get ( Calendar . MONTH ) ) { case Calendar . JANUARY : month = "-01-" ; break ; case Calendar . FEBRUARY : month = "-02-" ; break ; case Calendar . MARCH : month = "-03-" ; break ; case Calendar . APRIL : month = "-04-" ; break ; case Calendar . MAY : month = "-05-" ; break ; case Calendar . JUNE : month = "-06-" ; break ; case Calendar . JULY : month = "-07-" ; break ; case Calendar . AUGUST : month = "-08-" ; break ; case Calendar . SEPTEMBER : month = "-09-" ; break ; case Calendar . OCTOBER : month = "-10-" ; break ; case Calendar . NOVEMBER : month = "-11-" ; break ; case Calendar . DECEMBER : month = "-12-" ; break ; default : month = "-NA-" ; break ; } sbuf . append ( month ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	0	['4', '4', '0', '3', '12', '6', '2', '1', '4', '2', '99', '0', '0', '0.953488372', '0.357142857', '1', '3', '23.75', '3', '1', '0']
package org . apache . log4j . lf5 . util ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public class DateFormatManager { private TimeZone _timeZone = null ; private Locale _locale = null ; private String _pattern = null ; private DateFormat _dateFormat = null ; public DateFormatManager ( ) { super ( ) ; configure ( ) ; } public DateFormatManager ( TimeZone timeZone ) { super ( ) ; _timeZone = timeZone ; configure ( ) ; } public DateFormatManager ( Locale locale ) { super ( ) ; _locale = locale ; configure ( ) ; } public DateFormatManager ( String pattern ) { super ( ) ; _pattern = pattern ; configure ( ) ; } public DateFormatManager ( TimeZone timeZone , Locale locale ) { super ( ) ; _timeZone = timeZone ; _locale = locale ; configure ( ) ; } public DateFormatManager ( TimeZone timeZone , String pattern ) { super ( ) ; _timeZone = timeZone ; _pattern = pattern ; configure ( ) ; } public DateFormatManager ( Locale locale , String pattern ) { super ( ) ; _locale = locale ; _pattern = pattern ; configure ( ) ; } public DateFormatManager ( TimeZone timeZone , Locale locale , String pattern ) { super ( ) ; _timeZone = timeZone ; _locale = locale ; _pattern = pattern ; configure ( ) ; } public synchronized TimeZone getTimeZone ( ) { if ( _timeZone == null ) { return TimeZone . getDefault ( ) ; } else { return _timeZone ; } } public synchronized void setTimeZone ( TimeZone timeZone ) { timeZone = timeZone ; configure ( ) ; } public synchronized Locale getLocale ( ) { if ( _locale == null ) { return Locale . getDefault ( ) ; } else { return _locale ; } } public synchronized void setLocale ( Locale locale ) { _locale = locale ; configure ( ) ; } public synchronized String getPattern ( ) { return _pattern ; } public synchronized void setPattern ( String pattern ) { _pattern = pattern ; configure ( ) ; } public synchronized String getOutputFormat ( ) { return _pattern ; } public synchronized void setOutputFormat ( String pattern ) { _pattern = pattern ; configure ( ) ; } public synchronized DateFormat getDateFormatInstance ( ) { return _dateFormat ; } public synchronized void setDateFormatInstance ( DateFormat dateFormat ) { _dateFormat = dateFormat ; } public String format ( Date date ) { return getDateFormatInstance ( ) . format ( date ) ; } public String format ( Date date , String pattern ) { DateFormat formatter = null ; formatter = getDateFormatInstance ( ) ; if ( formatter instanceof SimpleDateFormat ) { formatter = ( SimpleDateFormat ) ( formatter . clone ( ) ) ; ( ( SimpleDateFormat ) formatter ) . applyPattern ( pattern ) ; } return formatter . format ( date ) ; } public Date parse ( String date ) throws ParseException { return getDateFormatInstance ( ) . parse ( date ) ; } public Date parse ( String date , String pattern ) throws ParseException { DateFormat formatter = null ; formatter = getDateFormatInstance ( ) ; if ( formatter instanceof SimpleDateFormat ) { formatter = ( SimpleDateFormat ) ( formatter . clone ( ) ) ; ( ( SimpleDateFormat ) formatter ) . applyPattern ( pattern ) ; } return formatter . parse ( date ) ; } private synchronized void configure ( ) { _dateFormat = SimpleDateFormat . getDateTimeInstance ( DateFormat . FULL , DateFormat . FULL , getLocale ( ) ) ; _dateFormat . setTimeZone ( getTimeZone ( ) ) ; if ( _pattern != null ) { ( ( SimpleDateFormat ) _dateFormat ) . applyPattern ( _pattern ) ; } } } 	1	['23', '1', '0', '2', '32', '9', '2', '0', '22', '0.420454545', '325', '1', '0', '0', '0.326086957', '0', '0', '12.95652174', '2', '0.8261', '3']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Appender ; import java . util . Vector ; import java . util . Enumeration ; public class AppenderAttachableImpl implements AppenderAttachable { protected Vector appenderList ; public void addAppender ( Appender newAppender ) { if ( newAppender == null ) return ; if ( appenderList == null ) { appenderList = new Vector ( 1 ) ; } if ( ! appenderList . contains ( newAppender ) ) appenderList . addElement ( newAppender ) ; } public int appendLoopOnAppenders ( LoggingEvent event ) { int size = 0 ; Appender appender ; if ( appenderList != null ) { size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; appender . doAppend ( event ) ; } } return size ; } public Enumeration getAllAppenders ( ) { if ( appenderList == null ) return null ; else return appenderList . elements ( ) ; } public Appender getAppender ( String name ) { if ( appenderList == null || name == null ) return null ; int size = appenderList . size ( ) ; Appender appender ; for ( int i = 0 ; i < size ; i ++ ) { appender = ( Appender ) appenderList . elementAt ( i ) ; if ( name . equals ( appender . getName ( ) ) ) return appender ; } return null ; } public void removeAllAppenders ( ) { if ( appenderList != null ) { int len = appenderList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Appender a = ( Appender ) appenderList . elementAt ( i ) ; a . close ( ) ; } appenderList . removeAllElements ( ) ; appenderList = null ; } } public void removeAppender ( Appender appender ) { if ( appender == null || appenderList == null ) return ; appenderList . removeElement ( appender ) ; } public void removeAppender ( String name ) { if ( name == null || appenderList == null ) return ; int size = appenderList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( name . equals ( ( ( Appender ) appenderList . elementAt ( i ) ) . getName ( ) ) ) { appenderList . removeElementAt ( i ) ; break ; } } } } 	0	['8', '1', '0', '6', '22', '0', '3', '3', '8', '0.142857143', '176', '1', '0', '0', '0.40625', '0', '0', '20.875', '5', '3.125', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; public class ROFile { static Category cat = Category . getInstance ( ROFile . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ROFile . class . getName ( ) + "configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; cat . debug ( "Message " + ++ i ) ; } } 	1	['7', '1', '0', '2', '21', '17', '0', '2', '2', '0.666666667', '90', '0', '1', '0', '0.277777778', '0', '0', '11.57142857', '2', '1', '1']
package org . apache . log4j ; import org . apache . log4j . spi . OptionHandler ; import org . apache . log4j . spi . LoggingEvent ; public abstract class Layout implements OptionHandler { public final static String LINE_SEP = System . getProperty ( "line.separator" ) ; public final static int LINE_SEP_LEN = LINE_SEP . length ( ) ; abstract public String format ( LoggingEvent event ) ; public String getContentType ( ) { return "text/plain" ; } public String getHeader ( ) { return null ; } public String getFooter ( ) { return null ; } abstract public boolean ignoresThrowable ( ) ; } 	0	['10', '1', '4', '26', '13', '45', '24', '2', '9', '1', '28', '0', '0', '0', '0.407407407', '0', '0', '1.6', '1', '0.8', '0']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	1	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '2']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j . varia ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . OptionConverter ; public class StringMatchFilter extends Filter { public static final String STRING_TO_MATCH_OPTION = "StringToMatch" ; public static final String ACCEPT_ON_MATCH_OPTION = "AcceptOnMatch" ; boolean acceptOnMatch = true ; String stringToMatch ; public String [ ] getOptionStrings ( ) { return new String [ ] { STRING_TO_MATCH_OPTION , ACCEPT_ON_MATCH_OPTION } ; } public void setOption ( String key , String value ) { if ( key . equalsIgnoreCase ( STRING_TO_MATCH_OPTION ) ) { stringToMatch = value ; } else if ( key . equalsIgnoreCase ( ACCEPT_ON_MATCH_OPTION ) ) { acceptOnMatch = OptionConverter . toBoolean ( value , acceptOnMatch ) ; } } public void setStringToMatch ( String s ) { stringToMatch = s ; } public String getStringToMatch ( ) { return stringToMatch ; } public void setAcceptOnMatch ( boolean acceptOnMatch ) { this . acceptOnMatch = acceptOnMatch ; } public boolean getAcceptOnMatch ( ) { return acceptOnMatch ; } public int decide ( LoggingEvent event ) { String msg = event . getRenderedMessage ( ) ; if ( msg == null || stringToMatch == null ) return Filter . NEUTRAL ; if ( msg . indexOf ( stringToMatch ) == - 1 ) { return Filter . NEUTRAL ; } else { if ( acceptOnMatch ) { return Filter . ACCEPT ; } else { return Filter . DENY ; } } } } 	1	['8', '2', '0', '3', '13', '0', '0', '3', '8', '0.821428571', '87', '0', '0', '0.363636364', '0.375', '0', '0', '9.375', '5', '1.625', '3']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public String [ ] getOptionStrings ( ) { return new String [ 0 ] ; } public void setOption ( String option , String value ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . priority . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . getRenderedMessage ( ) ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return true ; } } 	0	['6', '2', '0', '6', '13', '13', '3', '3', '6', '0.8', '54', '0', '0', '0.615384615', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggerFactory ; public class Logger extends Category { private static final String FQCN = Level . class . getName ( ) ; protected Logger ( String name ) { super ( name ) ; } static public Logger getLogger ( String name ) { return LogManager . getLogger ( name ) ; } static public Logger getLogger ( Class clazz ) { return LogManager . getLogger ( clazz . getName ( ) ) ; } public static Logger getRootLogger ( ) { return LogManager . getRootLogger ( ) ; } public static Logger getLogger ( String name , LoggerFactory factory ) { return LogManager . getLogger ( name , factory ) ; } } 	1	['7', '2', '2', '25', '15', '21', '25', '3', '4', '1', '47', '0.5', '0', '0.903846154', '0.291666667', '1', '1', '5.428571429', '1', '0.7143', '5']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . lf5 . viewer . configure ; import org . apache . log4j . lf5 . LogLevel ; import org . apache . log4j . lf5 . LogLevelFormatException ; import org . apache . log4j . lf5 . viewer . LogBrokerMonitor ; import org . apache . log4j . lf5 . viewer . LogTable ; import org . apache . log4j . lf5 . viewer . categoryexplorer . CategoryExplorerModel ; import org . apache . log4j . lf5 . viewer . categoryexplorer . CategoryExplorerTree ; import org . apache . log4j . lf5 . viewer . categoryexplorer . CategoryNode ; import org . apache . log4j . lf5 . viewer . categoryexplorer . CategoryPath ; import org . apache . log4j . lf5 . viewer . LogTableColumn ; import org . apache . log4j . lf5 . viewer . LogTableColumnFormatException ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import javax . swing . * ; import javax . swing . tree . TreePath ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import java . awt . * ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . * ; import java . util . List ; public class ConfigurationManager extends Object { private static final String CONFIG_FILE_NAME = "lf5_configuration.xml" ; private static final String NAME = "name" ; private static final String PATH = "path" ; private static final String SELECTED = "selected" ; private static final String EXPANDED = "expanded" ; private static final String CATEGORY = "category" ; private static final String FIRST_CATEGORY_NAME = "Categories" ; private static final String LEVEL = "level" ; private static final String COLORLEVEL = "colorlevel" ; private static final String COLOR = "color" ; private static final String RED = "red" ; private static final String GREEN = "green" ; private static final String BLUE = "blue" ; private static final String COLUMN = "column" ; private static final String NDCTEXTFILTER = "searchtext" ; private LogBrokerMonitor _monitor = null ; private LogTable _table = null ; public ConfigurationManager ( LogBrokerMonitor monitor , LogTable table ) { super ( ) ; _monitor = monitor ; _table = table ; load ( ) ; } public void save ( ) { CategoryExplorerModel model = _monitor . getCategoryExplorerTree ( ) . getExplorerModel ( ) ; CategoryNode root = model . getRootCategoryNode ( ) ; StringBuffer xml = new StringBuffer ( 2048 ) ; openXMLDocument ( xml ) ; openConfigurationXML ( xml ) ; processLogRecordFilter ( _monitor . getNDCTextFilter ( ) , xml ) ; processLogLevels ( _monitor . getLogLevelMenuItems ( ) , xml ) ; processLogLevelColors ( _monitor . getLogLevelMenuItems ( ) , LogLevel . getLogLevelColorMap ( ) , xml ) ; processLogTableColumns ( LogTableColumn . getLogTableColumns ( ) , xml ) ; processConfigurationNode ( root , xml ) ; closeConfigurationXML ( xml ) ; store ( xml . toString ( ) ) ; } public void reset ( ) { deleteConfigurationFile ( ) ; collapseTree ( ) ; selectAllNodes ( ) ; } public static String treePathToString ( TreePath path ) { StringBuffer sb = new StringBuffer ( ) ; CategoryNode n = null ; Object [ ] objects = path . getPath ( ) ; for ( int i = 1 ; i < objects . length ; i ++ ) { n = ( CategoryNode ) objects [ i ] ; if ( i > 1 ) { sb . append ( "." ) ; } sb . append ( n . getTitle ( ) ) ; } return sb . toString ( ) ; } protected void load ( ) { File file = new File ( getFilename ( ) ) ; if ( file . exists ( ) ) { try { DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docBuilderFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( file ) ; processRecordFilter ( doc ) ; processCategories ( doc ) ; processLogLevels ( doc ) ; processLogLevelColors ( doc ) ; processLogTableColumns ( doc ) ; } catch ( Exception e ) { System . err . println ( "Unable process configuration file at " + getFilename ( ) + ". Error Message=" + e . getMessage ( ) ) ; } } } protected void processRecordFilter ( Document doc ) { NodeList nodeList = doc . getElementsByTagName ( NDCTEXTFILTER ) ; Node n = nodeList . item ( 0 ) ; if ( n == null ) { return ; } NamedNodeMap map = n . getAttributes ( ) ; String text = getValue ( map , NAME ) ; if ( text == null || text . equals ( "" ) ) { return ; } _monitor . setNDCLogRecordFilter ( text ) ; } protected void processCategories ( Document doc ) { CategoryExplorerTree tree = _monitor . getCategoryExplorerTree ( ) ; CategoryExplorerModel model = tree . getExplorerModel ( ) ; NodeList nodeList = doc . getElementsByTagName ( CATEGORY ) ; NamedNodeMap map = nodeList . item ( 0 ) . getAttributes ( ) ; int j = ( getValue ( map , NAME ) . equalsIgnoreCase ( FIRST_CATEGORY_NAME ) ) ? 1 : 0 ; for ( int i = nodeList . getLength ( ) - 1 ; i >= j ; i -- ) { Node n = nodeList . item ( i ) ; map = n . getAttributes ( ) ; CategoryNode chnode = model . addCategory ( new CategoryPath ( getValue ( map , PATH ) ) ) ; chnode . setSelected ( ( getValue ( map , SELECTED ) . equalsIgnoreCase ( "true" ) ) ? true : false ) ; if ( getValue ( map , EXPANDED ) . equalsIgnoreCase ( "true" ) ) ; tree . expandPath ( model . getTreePathToRoot ( chnode ) ) ; } } protected void processLogLevels ( Document doc ) { NodeList nodeList = doc . getElementsByTagName ( LEVEL ) ; Map menuItems = _monitor . getLogLevelMenuItems ( ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node n = nodeList . item ( i ) ; NamedNodeMap map = n . getAttributes ( ) ; String name = getValue ( map , NAME ) ; try { JCheckBoxMenuItem item = ( JCheckBoxMenuItem ) menuItems . get ( LogLevel . valueOf ( name ) ) ; item . setSelected ( getValue ( map , SELECTED ) . equalsIgnoreCase ( "true" ) ) ; } catch ( LogLevelFormatException e ) { } } } protected void processLogLevelColors ( Document doc ) { NodeList nodeList = doc . getElementsByTagName ( COLORLEVEL ) ; Map logLevelColors = LogLevel . getLogLevelColorMap ( ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node n = nodeList . item ( i ) ; if ( n == null ) { return ; } NamedNodeMap map = n . getAttributes ( ) ; String name = getValue ( map , NAME ) ; try { LogLevel level = LogLevel . valueOf ( name ) ; int red = Integer . parseInt ( getValue ( map , RED ) ) ; int green = Integer . parseInt ( getValue ( map , GREEN ) ) ; int blue = Integer . parseInt ( getValue ( map , BLUE ) ) ; Color c = new Color ( red , green , blue ) ; if ( level != null ) { level . setLogLevelColorMap ( level , c ) ; } } catch ( LogLevelFormatException e ) { } } } protected void processLogTableColumns ( Document doc ) { NodeList nodeList = doc . getElementsByTagName ( COLUMN ) ; Map menuItems = _monitor . getLogTableColumnMenuItems ( ) ; List selectedColumns = new ArrayList ( ) ; for ( int i = 0 ; i < nodeList . getLength ( ) ; i ++ ) { Node n = nodeList . item ( i ) ; if ( n == null ) { return ; } NamedNodeMap map = n . getAttributes ( ) ; String name = getValue ( map , NAME ) ; try { LogTableColumn column = LogTableColumn . valueOf ( name ) ; JCheckBoxMenuItem item = ( JCheckBoxMenuItem ) menuItems . get ( column ) ; item . setSelected ( getValue ( map , SELECTED ) . equalsIgnoreCase ( "true" ) ) ; if ( item . isSelected ( ) ) { selectedColumns . add ( column ) ; } } catch ( LogTableColumnFormatException e ) { } if ( selectedColumns . isEmpty ( ) ) { _table . setDetailedView ( ) ; } else { _table . setView ( selectedColumns ) ; } } } protected String getValue ( NamedNodeMap map , String attr ) { Node n = map . getNamedItem ( attr ) ; return n . getNodeValue ( ) ; } protected void collapseTree ( ) { CategoryExplorerTree tree = _monitor . getCategoryExplorerTree ( ) ; for ( int i = tree . getRowCount ( ) - 1 ; i > 0 ; i -- ) { tree . collapseRow ( i ) ; } } protected void selectAllNodes ( ) { CategoryExplorerModel model = _monitor . getCategoryExplorerTree ( ) . getExplorerModel ( ) ; CategoryNode root = model . getRootCategoryNode ( ) ; Enumeration all = root . breadthFirstEnumeration ( ) ; CategoryNode n = null ; while ( all . hasMoreElements ( ) ) { n = ( CategoryNode ) all . nextElement ( ) ; n . setSelected ( true ) ; } } protected void store ( String s ) { try { PrintWriter writer = new PrintWriter ( new FileWriter ( getFilename ( ) ) ) ; writer . print ( s ) ; writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } protected void deleteConfigurationFile ( ) { try { File f = new File ( getFilename ( ) ) ; if ( f . exists ( ) ) { f . delete ( ) ; } } catch ( SecurityException e ) { System . err . println ( "Cannot delete " + getFilename ( ) + " because a security violation occured." ) ; } } protected String getFilename ( ) { String home = System . getProperty ( "user.home" ) ; String sep = ( home . startsWith ( MRUFileManager . UNIX_SEPARATOR ) ) ? MRUFileManager . UNIX_SEPARATOR : MRUFileManager . DOS_SEPARATOR ; return home + sep + "lf5" + sep + CONFIG_FILE_NAME ; } private void processConfigurationNode ( CategoryNode node , StringBuffer xml ) { CategoryExplorerModel model = _monitor . getCategoryExplorerTree ( ) . getExplorerModel ( ) ; Enumeration all = node . breadthFirstEnumeration ( ) ; CategoryNode n = null ; while ( all . hasMoreElements ( ) ) { n = ( CategoryNode ) all . nextElement ( ) ; exportXMLElement ( n , model . getTreePathToRoot ( n ) , xml ) ; } } private void processLogLevels ( Map logLevelMenuItems , StringBuffer xml ) { xml . append ( "\t<loglevels>\r\n" ) ; Iterator it = logLevelMenuItems . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { LogLevel level = ( LogLevel ) it . next ( ) ; JCheckBoxMenuItem item = ( JCheckBoxMenuItem ) logLevelMenuItems . get ( level ) ; exportLogLevelXMLElement ( level . getLabel ( ) , item . isSelected ( ) , xml ) ; } xml . append ( "\t</loglevels>\r\n" ) ; } private void processLogLevelColors ( Map logLevelMenuItems , Map logLevelColors , StringBuffer xml ) { xml . append ( "\t<loglevelcolors>\r\n" ) ; Iterator it = logLevelMenuItems . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { LogLevel level = ( LogLevel ) it . next ( ) ; Color color = ( Color ) logLevelColors . get ( level ) ; exportLogLevelColorXMLElement ( level . getLabel ( ) , color , xml ) ; } xml . append ( "\t</loglevelcolors>\r\n" ) ; } private void processLogTableColumns ( List logTableColumnMenuItems , StringBuffer xml ) { xml . append ( "\t<logtablecolumns>\r\n" ) ; Iterator it = logTableColumnMenuItems . iterator ( ) ; while ( it . hasNext ( ) ) { LogTableColumn column = ( LogTableColumn ) it . next ( ) ; JCheckBoxMenuItem item = _monitor . getTableColumnMenuItem ( column ) ; exportLogTableColumnXMLElement ( column . getLabel ( ) , item . isSelected ( ) , xml ) ; } xml . append ( "\t</logtablecolumns>\r\n" ) ; } private void processLogRecordFilter ( String text , StringBuffer xml ) { xml . append ( "\t<" ) . append ( NDCTEXTFILTER ) . append ( " " ) ; xml . append ( NAME ) . append ( "=\"" ) . append ( text ) . append ( "\"" ) ; xml . append ( "/>\r\n" ) ; } private void openXMLDocument ( StringBuffer xml ) { xml . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n" ) ; } private void openConfigurationXML ( StringBuffer xml ) { xml . append ( "<configuration>\r\n" ) ; } private void closeConfigurationXML ( StringBuffer xml ) { xml . append ( "</configuration>\r\n" ) ; } private void exportXMLElement ( CategoryNode node , TreePath path , StringBuffer xml ) { CategoryExplorerTree tree = _monitor . getCategoryExplorerTree ( ) ; xml . append ( "\t<" ) . append ( CATEGORY ) . append ( " " ) ; xml . append ( NAME ) . append ( "=\"" ) . append ( node . getTitle ( ) ) . append ( "\" " ) ; xml . append ( PATH ) . append ( "=\"" ) . append ( treePathToString ( path ) ) . append ( "\" " ) ; xml . append ( EXPANDED ) . append ( "=\"" ) . append ( tree . isExpanded ( path ) ) . append ( "\" " ) ; xml . append ( SELECTED ) . append ( "=\"" ) . append ( node . isSelected ( ) ) . append ( "\"/>\r\n" ) ; } private void exportLogLevelXMLElement ( String label , boolean selected , StringBuffer xml ) { xml . append ( "\t\t<" ) . append ( LEVEL ) . append ( " " ) . append ( NAME ) ; xml . append ( "=\"" ) . append ( label ) . append ( "\" " ) ; xml . append ( SELECTED ) . append ( "=\"" ) . append ( selected ) ; xml . append ( "\"/>\r\n" ) ; } private void exportLogLevelColorXMLElement ( String label , Color color , StringBuffer xml ) { xml . append ( "\t\t<" ) . append ( COLORLEVEL ) . append ( " " ) . append ( NAME ) ; xml . append ( "=\"" ) . append ( label ) . append ( "\" " ) ; xml . append ( RED ) . append ( "=\"" ) . append ( color . getRed ( ) ) . append ( "\" " ) ; xml . append ( GREEN ) . append ( "=\"" ) . append ( color . getGreen ( ) ) . append ( "\" " ) ; xml . append ( BLUE ) . append ( "=\"" ) . append ( color . getBlue ( ) ) ; xml . append ( "\"/>\r\n" ) ; } private void exportLogTableColumnXMLElement ( String label , boolean selected , StringBuffer xml ) { xml . append ( "\t\t<" ) . append ( COLUMN ) . append ( " " ) . append ( NAME ) ; xml . append ( "=\"" ) . append ( label ) . append ( "\" " ) ; xml . append ( SELECTED ) . append ( "=\"" ) . append ( selected ) ; xml . append ( "\"/>\r\n" ) ; } } 	1	['28', '1', '0', '10', '105', '268', '1', '10', '4', '1.002178649', '962', '1', '2', '0', '0.173076923', '0', '0', '32.75', '5', '1.7857', '3']
package org . apache . log4j . nt . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . Appender ; import org . apache . log4j . nt . NTEventLogAppender ; import org . apache . log4j . Priority ; import org . apache . log4j . NDC ; import java . io . IOException ; public class NTMin { static Category cat = Category . getInstance ( NTMin . class . getName ( ) ) ; public static void main ( String argv [ ] ) { init ( ) ; test ( "someHost" ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + NTMin . class + "" ) ; System . exit ( 1 ) ; } static void init ( ) { BasicConfigurator . configure ( new NTEventLogAppender ( ) ) ; } static void test ( String host ) { NDC . push ( host ) ; int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; } } 	0	['7', '1', '0', '6', '30', '17', '0', '6', '2', '0.75', '144', '0', '1', '0', '0.277777778', '0', '0', '19.28571429', '2', '0.8571', '0']
package org . apache . log4j . test ; import java . io . * ; import org . apache . log4j . config . PropertyPrinter ; public class PrintProperties { public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) , true ) ; } } 	1	['2', '1', '0', '1', '5', '1', '0', '1', '2', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '1']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class QuietWriter extends FilterWriter { protected ErrorHandler errorHandler ; public QuietWriter ( Writer writer , ErrorHandler errorHandler ) { super ( writer ) ; setErrorHandler ( errorHandler ) ; } public void write ( String string ) { try { out . write ( string ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to write [" + string + "]." , e , ErrorCode . WRITE_FAILURE ) ; } } public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { errorHandler . error ( "Failed to flush writer," , e , ErrorCode . FLUSH_FAILURE ) ; } } public void setErrorHandler ( ErrorHandler eh ) { if ( eh == null ) { throw new IllegalArgumentException ( "Attempted to set null ErrorHandler." ) ; } else { this . errorHandler = eh ; } } } 	0	['4', '3', '2', '6', '12', '0', '5', '1', '4', '0', '57', '1', '1', '0.857142857', '0.5', '2', '2', '13', '2', '1', '0']
package org . apache . log4j ; public class Priority { int level ; String levelStr ; int syslogEquivalent ; public final static int OFF_INT = Integer . MAX_VALUE ; public final static int FATAL_INT = 50000 ; public final static int ERROR_INT = 40000 ; public final static int WARN_INT = 30000 ; public final static int INFO_INT = 20000 ; public final static int DEBUG_INT = 10000 ; public final static int ALL_INT = Integer . MIN_VALUE ; final static public Priority FATAL = new Level ( FATAL_INT , "FATAL" , 0 ) ; final static public Priority ERROR = new Level ( ERROR_INT , "ERROR" , 3 ) ; final static public Priority WARN = new Level ( WARN_INT , "WARN" , 4 ) ; final static public Priority INFO = new Level ( INFO_INT , "INFO" , 6 ) ; final static public Priority DEBUG = new Level ( DEBUG_INT , "DEBUG" , 7 ) ; protected Priority ( int level , String levelStr , int syslogEquivalent ) { this . level = level ; this . levelStr = levelStr ; this . syslogEquivalent = syslogEquivalent ; } public boolean equals ( Object o ) { if ( o instanceof Priority ) { Priority r = ( Priority ) o ; return ( this . level == r . level ) ; } else { return false ; } } public final int getSyslogEquivalent ( ) { return syslogEquivalent ; } public boolean isGreaterOrEqual ( Priority r ) { return level >= r . level ; } public static Priority [ ] getAllPossiblePriorities ( ) { return new Priority [ ] { Priority . FATAL , Priority . ERROR , Level . WARN , Priority . INFO , Priority . DEBUG } ; } final public String toString ( ) { return levelStr ; } public final int toInt ( ) { return level ; } public static Priority toPriority ( String sArg ) { return Level . toLevel ( sArg ) ; } public static Priority toPriority ( int val ) { return toPriority ( val , Priority . DEBUG ) ; } public static Priority toPriority ( int val , Priority defaultPriority ) { return Level . toLevel ( val , ( Level ) defaultPriority ) ; } public static Priority toPriority ( String sArg , Priority defaultPriority ) { return Level . toLevel ( sArg , ( Level ) defaultPriority ) ; } } 	1	['12', '1', '1', '35', '17', '44', '35', '1', '10', '0.981818182', '150', '0', '5', '0', '0.290909091', '0', '0', '10.25', '3', '1.0833', '3']
package org . apache . log4j . helpers ; import java . io . File ; import org . apache . log4j . helpers . LogLog ; public abstract class FileWatchdog extends Thread { static final public long DEFAULT_DELAY = 60000 ; protected String filename ; protected long delay = DEFAULT_DELAY ; File file ; long lastModif = 0 ; boolean warnedAlready = false ; boolean interrupted = false ; protected FileWatchdog ( String filename ) { this . filename = filename ; file = new File ( filename ) ; setDaemon ( true ) ; checkAndConfigure ( ) ; } public void setDelay ( long delay ) { this . delay = delay ; } abstract protected void doOnChange ( ) ; protected void checkAndConfigure ( ) { boolean fileExists ; try { fileExists = file . exists ( ) ; } catch ( SecurityException e ) { LogLog . warn ( "Was not allowed to read check file existance, file:[" + filename + "]." ) ; interrupted = true ; return ; } if ( fileExists ) { long l = file . lastModified ( ) ; if ( l > lastModif ) { lastModif = l ; doOnChange ( ) ; warnedAlready = false ; } } else { if ( ! warnedAlready ) { LogLog . debug ( "[" + filename + "] does not exist." ) ; warnedAlready = true ; } } } public void run ( ) { while ( ! interrupted ) { try { Thread . currentThread ( ) . sleep ( delay ) ; } catch ( InterruptedException e ) { } checkAndConfigure ( ) ; } } } 	0	['5', '2', '0', '2', '17', '0', '1', '1', '2', '0.607142857', '120', '0.285714286', '0', '0.938461538', '0.466666667', '1', '1', '21.6', '3', '1.4', '0']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import org . apache . log4j . Logger ; public interface ErrorHandler extends OptionHandler { void setLogger ( Logger logger ) ; void error ( String message , Exception e , int errorCode ) ; void error ( String message ) ; void error ( String message , Exception e , int errorCode , LoggingEvent event ) ; void setAppender ( Appender appender ) ; void setBackupAppender ( Appender appender ) ; } 	1	['6', '1', '0', '20', '6', '15', '17', '4', '6', '2', '6', '0', '0', '0', '0.404761905', '0', '0', '0', '1', '1', '2']
package org . apache . log4j . net . test ; import org . apache . log4j . * ; import java . io . IOException ; import java . io . InputStreamReader ; public class SMTPMin { static Category cat = Category . getInstance ( SMTPMin . class ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; test ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + SMTPMin . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = 0 ; cat . debug ( "Message " + i ++ ) ; cat . debug ( "Message " + i ++ , new Exception ( "Just testing." ) ) ; cat . info ( "Message " + i ++ ) ; cat . warn ( "Message " + i ++ ) ; cat . error ( "Message " + i ++ ) ; cat . log ( Priority . FATAL , "Message " + i ++ ) ; Category . shutdown ( ) ; Thread . currentThread ( ) . getThreadGroup ( ) . list ( ) ; } } 	0	['7', '1', '0', '4', '32', '17', '0', '4', '2', '0.666666667', '155', '0', '1', '0', '0.277777778', '0', '0', '20.85714286', '2', '1', '0']
package org . apache . log4j . varia ; import java . io . * ; import java . net . Socket ; import java . net . ServerSocket ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . RollingFileAppender ; import org . apache . log4j . helpers . LogLog ; public class ExternallyRolledFileAppender extends RollingFileAppender { static final public String ROLL_OVER = "RollOver" ; static final public String OK = "OK" ; int port = 0 ; HUP hup ; public ExternallyRolledFileAppender ( ) { } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return port ; } public void activateOptions ( ) { super . activateOptions ( ) ; if ( port != 0 ) { if ( hup != null ) { hup . interrupt ( ) ; } hup = new HUP ( this , port ) ; hup . setDaemon ( true ) ; hup . start ( ) ; } } } class HUP extends Thread { int port ; ExternallyRolledFileAppender er ; HUP ( ExternallyRolledFileAppender er , int port ) { this . er = er ; this . port = port ; } public void run ( ) { while ( ! isInterrupted ( ) ) { try { ServerSocket serverSocket = new ServerSocket ( port ) ; while ( true ) { Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; new Thread ( new HUPNode ( socket , er ) ) . start ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } class HUPNode implements Runnable { Socket socket ; DataInputStream dis ; DataOutputStream dos ; ExternallyRolledFileAppender er ; public HUPNode ( Socket socket , ExternallyRolledFileAppender er ) { this . socket = socket ; this . er = er ; try { dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void run ( ) { try { String line = dis . readUTF ( ) ; LogLog . debug ( "Got external roll over signal." ) ; if ( ExternallyRolledFileAppender . ROLL_OVER . equals ( line ) ) { synchronized ( er ) { er . rollOver ( ) ; } dos . writeUTF ( ExternallyRolledFileAppender . OK ) ; } else { dos . writeUTF ( "Expecting [RollOver] string." ) ; } dos . close ( ) ; } catch ( Exception e ) { LogLog . error ( "Unexpected exception. Exiting HUPNode." , e ) ; } } } 	1	['4', '4', '0', '4', '10', '0', '2', '3', '4', '0.916666667', '48', '0', '1', '0.931818182', '0.625', '0', '0', '10', '3', '1.25', '3']
package org . apache . log4j . performance ; public class NewVsSetLen { static String s ; static int BIGBUF_LEN = 1048576 ; static int SBUF_LEN = 256 ; static int RUN_LENGTH = BIGBUF_LEN / 4 ; static char [ ] sbuf = new char [ SBUF_LEN ] ; static char [ ] bigbuf = new char [ BIGBUF_LEN ] ; { for ( int i = 0 ; i < SBUF_LEN ; i ++ ) { sbuf [ i ] = ( char ) ( i ) ; } for ( int i = 0 ; i < BIGBUF_LEN ; i ++ ) { bigbuf [ i ] = ( char ) ( i ) ; } } static public void main ( String [ ] args ) { int t ; for ( int len = SBUF_LEN ; len <= BIGBUF_LEN ; len *= 4 , RUN_LENGTH /= 4 ) { System . out . println ( "<td>" + len + "\n" ) ; for ( int second = 0 ; second < 16 ; ) { System . out . println ( "SECOND loop=" + second + ", RUN_LENGTH=" + RUN_LENGTH + ", len=" + len ) ; t = ( int ) newBuffer ( len , second ) ; ; System . out . print ( "<td>" + t ) ; t = ( int ) setLen ( len , second ) ; System . out . println ( " <td>" + t + " \n" ) ; if ( second == 0 ) { second = 1 ; } else { second *= 2 ; } } } } static double newBuffer ( int size , int second ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; } for ( int x = 0 ; x < second ; x ++ ) { StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double setLen ( int size , int second ) { long before = System . currentTimeMillis ( ) ; StringBuffer buf = new StringBuffer ( SBUF_LEN ) ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { buf . append ( sbuf , 0 , sbuf . length ) ; buf . append ( bigbuf , 0 , size ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } for ( int x = 0 ; x < second ; x ++ ) { buf . append ( sbuf , 0 , SBUF_LEN ) ; s = buf . toString ( ) ; buf . setLength ( 0 ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '16', '0', '0', '0', '2', '0.208333333', '268', '0', '0', '0', '0.333333333', '0', '0', '51.4', '4', '2', '0']
package org . apache . log4j . chainsaw ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import javax . swing . BorderFactory ; import javax . swing . JButton ; import javax . swing . JComboBox ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JTextField ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; class ControlPanel extends JPanel { private static final Category LOG = Category . getInstance ( ControlPanel . class ) ; ControlPanel ( final MyTableModel aModel ) { setBorder ( BorderFactory . createTitledBorder ( "Controls: " ) ) ; final GridBagLayout gridbag = new GridBagLayout ( ) ; final GridBagConstraints c = new GridBagConstraints ( ) ; setLayout ( gridbag ) ; c . ipadx = 5 ; c . ipady = 5 ; c . gridx = 0 ; c . anchor = GridBagConstraints . EAST ; c . gridy = 0 ; JLabel label = new JLabel ( "Filter Level:" ) ; gridbag . setConstraints ( label , c ) ; add ( label ) ; c . gridy ++ ; label = new JLabel ( "Filter Thread:" ) ; gridbag . setConstraints ( label , c ) ; add ( label ) ; c . gridy ++ ; label = new JLabel ( "Filter Category:" ) ; gridbag . setConstraints ( label , c ) ; add ( label ) ; c . gridy ++ ; label = new JLabel ( "Filter NDC:" ) ; gridbag . setConstraints ( label , c ) ; add ( label ) ; c . gridy ++ ; label = new JLabel ( "Filter Message:" ) ; gridbag . setConstraints ( label , c ) ; add ( label ) ; c . weightx = 1 ; c . gridx = 1 ; c . anchor = GridBagConstraints . WEST ; c . gridy = 0 ; final Priority [ ] allPriorities = Priority . getAllPossiblePriorities ( ) ; final JComboBox priorities = new JComboBox ( allPriorities ) ; final Priority lowest = allPriorities [ allPriorities . length - 1 ] ; priorities . setSelectedItem ( lowest ) ; aModel . setPriorityFilter ( lowest ) ; gridbag . setConstraints ( priorities , c ) ; add ( priorities ) ; priorities . setEditable ( false ) ; priorities . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent aEvent ) { aModel . setPriorityFilter ( ( Priority ) priorities . getSelectedItem ( ) ) ; } } ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridy ++ ; final JTextField threadField = new JTextField ( "" ) ; threadField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent aEvent ) { aModel . setThreadFilter ( threadField . getText ( ) ) ; } public void removeUpdate ( DocumentEvent aEvente ) { aModel . setThreadFilter ( threadField . getText ( ) ) ; } public void changedUpdate ( DocumentEvent aEvent ) { aModel . setThreadFilter ( threadField . getText ( ) ) ; } } ) ; gridbag . setConstraints ( threadField , c ) ; add ( threadField ) ; c . gridy ++ ; final JTextField catField = new JTextField ( "" ) ; catField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent aEvent ) { aModel . setCategoryFilter ( catField . getText ( ) ) ; } public void removeUpdate ( DocumentEvent aEvent ) { aModel . setCategoryFilter ( catField . getText ( ) ) ; } public void changedUpdate ( DocumentEvent aEvent ) { aModel . setCategoryFilter ( catField . getText ( ) ) ; } } ) ; gridbag . setConstraints ( catField , c ) ; add ( catField ) ; c . gridy ++ ; final JTextField ndcField = new JTextField ( "" ) ; ndcField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent aEvent ) { aModel . setNDCFilter ( ndcField . getText ( ) ) ; } public void removeUpdate ( DocumentEvent aEvent ) { aModel . setNDCFilter ( ndcField . getText ( ) ) ; } public void changedUpdate ( DocumentEvent aEvent ) { aModel . setNDCFilter ( ndcField . getText ( ) ) ; } } ) ; gridbag . setConstraints ( ndcField , c ) ; add ( ndcField ) ; c . gridy ++ ; final JTextField msgField = new JTextField ( "" ) ; msgField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent aEvent ) { aModel . setMessageFilter ( msgField . getText ( ) ) ; } public void removeUpdate ( DocumentEvent aEvent ) { aModel . setMessageFilter ( msgField . getText ( ) ) ; } public void changedUpdate ( DocumentEvent aEvent ) { aModel . setMessageFilter ( msgField . getText ( ) ) ; } } ) ; gridbag . setConstraints ( msgField , c ) ; add ( msgField ) ; c . weightx = 0 ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . EAST ; c . gridx = 2 ; c . gridy = 0 ; final JButton exitButton = new JButton ( "Exit" ) ; exitButton . setMnemonic ( 'x' ) ; exitButton . addActionListener ( ExitAction . INSTANCE ) ; gridbag . setConstraints ( exitButton , c ) ; add ( exitButton ) ; c . gridy ++ ; final JButton clearButton = new JButton ( "Clear" ) ; clearButton . setMnemonic ( 'c' ) ; clearButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent aEvent ) { aModel . clear ( ) ; } } ) ; gridbag . setConstraints ( clearButton , c ) ; add ( clearButton ) ; c . gridy ++ ; final JButton toggleButton = new JButton ( "Pause" ) ; toggleButton . setMnemonic ( 'p' ) ; toggleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent aEvent ) { aModel . toggle ( ) ; toggleButton . setText ( aModel . isPaused ( ) ? "Resume" : "Pause" ) ; } } ) ; gridbag . setConstraints ( toggleButton , c ) ; add ( toggleButton ) ; } } 	1	['3', '5', '0', '12', '35', '3', '8', '11', '0', '1', '407', '0.5', '1', '0.998394864', '0.5', '0', '0', '134', '1', '0.3333', '3']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . LoggingEvent ; public abstract class PatternConverter { public PatternConverter next ; int min = - 1 ; int max = 0x7FFFFFFF ; boolean leftAlign = false ; protected PatternConverter ( ) { } protected PatternConverter ( FormattingInfo fi ) { min = fi . min ; max = fi . max ; leftAlign = fi . leftAlign ; } abstract protected String convert ( LoggingEvent event ) ; public void format ( StringBuffer sbuf , LoggingEvent e ) { String s = convert ( e ) ; if ( s == null ) { if ( 0 < min ) spacePad ( sbuf , min ) ; return ; } int len = s . length ( ) ; if ( len > max ) sbuf . append ( s . substring ( len - max ) ) ; else if ( len < min ) { if ( leftAlign ) { sbuf . append ( s ) ; spacePad ( sbuf , min - len ) ; } else { spacePad ( sbuf , min - len ) ; sbuf . append ( s ) ; } } else sbuf . append ( s ) ; } static String [ ] SPACES = { " " , "  " , "    " , "        " , "                " , "                                " } ; public void spacePad ( StringBuffer sbuf , int length ) { while ( length >= 32 ) { sbuf . append ( SPACES [ 5 ] ) ; length -= 32 ; } for ( int i = 4 ; i >= 0 ; i -- ) { if ( ( length & ( 1 << i ) ) != 0 ) { sbuf . append ( SPACES [ i ] ) ; } } } } 	0	['6', '1', '5', '9', '10', '7', '7', '2', '2', '0.72', '174', '0', '1', '0', '0.44', '0', '0', '27.16666667', '6', '1.8333', '0']
package org . apache . log4j . lf5 . util ; import org . apache . log4j . lf5 . Log4JLogRecord ; import org . apache . log4j . lf5 . LogLevel ; import org . apache . log4j . lf5 . LogLevelFormatException ; import org . apache . log4j . lf5 . LogRecord ; import org . apache . log4j . lf5 . viewer . LogBrokerMonitor ; import org . apache . log4j . lf5 . viewer . LogFactor5ErrorDialog ; import org . apache . log4j . lf5 . viewer . LogFactor5LoadingDialog ; import javax . swing . * ; import java . io . * ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; public class LogFileParser implements Runnable { public static final String RECORD_DELIMITER = "[slf5s.start]" ; public static final String ATTRIBUTE_DELIMITER = "[slf5s." ; public static final String DATE_DELIMITER = ATTRIBUTE_DELIMITER + "DATE]" ; public static final String THREAD_DELIMITER = ATTRIBUTE_DELIMITER + "THREAD]" ; public static final String CATEGORY_DELIMITER = ATTRIBUTE_DELIMITER + "CATEGORY]" ; public static final String LOCATION_DELIMITER = ATTRIBUTE_DELIMITER + "LOCATION]" ; public static final String MESSAGE_DELIMITER = ATTRIBUTE_DELIMITER + "MESSAGE]" ; public static final String PRIORITY_DELIMITER = ATTRIBUTE_DELIMITER + "PRIORITY]" ; public static final String NDC_DELIMITER = ATTRIBUTE_DELIMITER + "NDC]" ; private static SimpleDateFormat _sdf = new SimpleDateFormat ( "dd MMM yyyy HH:mm:ss,S" ) ; private LogBrokerMonitor _monitor ; LogFactor5LoadingDialog _loadDialog ; private InputStream _in = null ; public LogFileParser ( File file ) throws IOException , FileNotFoundException { this ( new FileInputStream ( file ) ) ; } public LogFileParser ( InputStream stream ) throws IOException { _in = stream ; } public void parse ( LogBrokerMonitor monitor ) throws RuntimeException { _monitor = monitor ; Thread t = new Thread ( this ) ; t . start ( ) ; } public void run ( ) { int index = 0 ; int counter = 0 ; LogRecord temp ; boolean isLogFile = false ; _loadDialog = new LogFactor5LoadingDialog ( _monitor . getBaseFrame ( ) , "Loading file..." ) ; try { String logRecords = loadLogFile ( _in ) ; while ( ( counter = logRecords . indexOf ( RECORD_DELIMITER , index ) ) != - 1 ) { temp = createLogRecord ( logRecords . substring ( index , counter ) ) ; isLogFile = true ; if ( temp != null ) { _monitor . addMessage ( temp ) ; } index = counter + RECORD_DELIMITER . length ( ) ; } if ( index < logRecords . length ( ) && isLogFile ) { temp = createLogRecord ( logRecords . substring ( index ) ) ; if ( temp != null ) { _monitor . addMessage ( temp ) ; } } if ( isLogFile == false ) { throw new RuntimeException ( "Invalid log file format" ) ; } SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { destroyDialog ( ) ; } } ) ; } catch ( RuntimeException e ) { destroyDialog ( ) ; displayError ( "Error - Invalid log file format.\nPlease see documentation" + " on how to load log files." ) ; } catch ( IOException e ) { destroyDialog ( ) ; displayError ( "Error - Unable to load log file!" ) ; } _in = null ; } protected void displayError ( String message ) { LogFactor5ErrorDialog error = new LogFactor5ErrorDialog ( _monitor . getBaseFrame ( ) , message ) ; } private void destroyDialog ( ) { _loadDialog . hide ( ) ; _loadDialog . dispose ( ) ; } private String loadLogFile ( InputStream stream ) throws IOException { BufferedInputStream br = new BufferedInputStream ( stream ) ; int count = 0 ; int size = br . available ( ) ; StringBuffer sb = null ; if ( size > 0 ) { sb = new StringBuffer ( size ) ; } else { sb = new StringBuffer ( 1024 ) ; } while ( ( count = br . read ( ) ) != - 1 ) { sb . append ( ( char ) count ) ; } br . close ( ) ; br = null ; return sb . toString ( ) ; } private String parseAttribute ( String name , String record ) { int index = record . indexOf ( name ) ; if ( index == - 1 ) { return null ; } return getAttribute ( index , record ) ; } private long parseDate ( String record ) { try { String s = parseAttribute ( DATE_DELIMITER , record ) ; if ( s == null ) { return 0 ; } Date d = _sdf . parse ( s ) ; return d . getTime ( ) ; } catch ( ParseException e ) { return 0 ; } } private LogLevel parsePriority ( String record ) { String temp = parseAttribute ( PRIORITY_DELIMITER , record ) ; if ( temp != null ) { try { return LogLevel . valueOf ( temp ) ; } catch ( LogLevelFormatException e ) { return LogLevel . DEBUG ; } } return LogLevel . DEBUG ; } private String parseThread ( String record ) { return parseAttribute ( THREAD_DELIMITER , record ) ; } private String parseCategory ( String record ) { return parseAttribute ( CATEGORY_DELIMITER , record ) ; } private String parseLocation ( String record ) { return parseAttribute ( LOCATION_DELIMITER , record ) ; } private String parseMessage ( String record ) { return parseAttribute ( MESSAGE_DELIMITER , record ) ; } private String parseNDC ( String record ) { return parseAttribute ( NDC_DELIMITER , record ) ; } private String parseThrowable ( String record ) { return getAttribute ( record . length ( ) , record ) ; } private LogRecord createLogRecord ( String record ) { if ( record == null || record . trim ( ) . length ( ) == 0 ) { return null ; } LogRecord lr = new Log4JLogRecord ( ) ; lr . setMillis ( parseDate ( record ) ) ; lr . setLevel ( parsePriority ( record ) ) ; lr . setCategory ( parseCategory ( record ) ) ; lr . setLocation ( parseLocation ( record ) ) ; lr . setThreadDescription ( parseThread ( record ) ) ; lr . setNDC ( parseNDC ( record ) ) ; lr . setMessage ( parseMessage ( record ) ) ; lr . setThrownStackTrace ( parseThrowable ( record ) ) ; return lr ; } private String getAttribute ( int index , String record ) { int start = record . lastIndexOf ( ATTRIBUTE_DELIMITER , index - 1 ) ; if ( start == - 1 ) { return record . substring ( 0 , index ) ; } start = record . indexOf ( "]" , start ) ; return record . substring ( start + 1 , index ) . trim ( ) ; } } 	1	['20', '1', '0', '8', '60', '178', '2', '8', '4', '1.004048583', '387', '0.230769231', '2', '0', '0.270676692', '0', '0', '17.7', '7', '1.45', '2']
package org . apache . log4j . test ; import java . io . * ; import org . apache . log4j . config . PropertyPrinter ; public class PrintProperties { public static void main ( String [ ] args ) { new PropertyPrinter ( new PrintWriter ( System . out ) , true ) ; } } 	0	['2', '1', '0', '1', '5', '1', '0', '1', '2', '2', '15', '0', '0', '0', '0.5', '0', '0', '6.5', '1', '0.5', '0']
package org . apache . log4j . lf5 . viewer . categoryexplorer ; import org . apache . log4j . lf5 . LogRecord ; import org . apache . log4j . lf5 . LogRecordFilter ; import java . util . Enumeration ; public class CategoryExplorerLogRecordFilter implements LogRecordFilter { protected CategoryExplorerModel _model ; public CategoryExplorerLogRecordFilter ( CategoryExplorerModel model ) { _model = model ; } public boolean passes ( LogRecord record ) { CategoryPath path = new CategoryPath ( record . getCategory ( ) ) ; return _model . isCategoryPathActive ( path ) ; } public void reset ( ) { resetAllNodes ( ) ; } protected void resetAllNodes ( ) { Enumeration nodes = _model . getRootCategoryNode ( ) . depthFirstEnumeration ( ) ; CategoryNode current ; while ( nodes . hasMoreElements ( ) ) { current = ( CategoryNode ) nodes . nextElement ( ) ; current . resetNumberOfContainedRecords ( ) ; _model . nodeChanged ( current ) ; } } } 	1	['4', '1', '0', '5', '14', '0', '0', '5', '3', '0', '45', '1', '1', '0', '0.5', '0', '0', '10', '2', '1', '2']
package org . apache . log4j . spi ; import org . apache . log4j . Appender ; import java . util . Enumeration ; public interface AppenderAttachable { public void addAppender ( Appender newAppender ) ; public Enumeration getAllAppenders ( ) ; public Appender getAppender ( String name ) ; void removeAllAppenders ( ) ; void removeAppender ( Appender appender ) ; void removeAppender ( String name ) ; } 	0	['6', '1', '0', '4', '6', '15', '3', '1', '6', '2', '6', '0', '0', '0', '0.555555556', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import java . util . Properties ; import java . net . URL ; import org . apache . log4j . Level ; import org . apache . log4j . spi . Configurator ; import org . apache . log4j . spi . LoggerRepository ; import org . apache . log4j . PropertyConfigurator ; public class OptionConverter { static String DELIM_START = "${" ; static char DELIM_STOP = '}' ; static int DELIM_START_LEN = 2 ; static int DELIM_STOP_LEN = 1 ; private OptionConverter ( ) { } public static String [ ] concatanateArrays ( String [ ] l , String [ ] r ) { int len = l . length + r . length ; String [ ] a = new String [ len ] ; System . arraycopy ( l , 0 , a , 0 , l . length ) ; System . arraycopy ( r , 0 , a , l . length , r . length ) ; return a ; } public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuffer sbuf = new StringBuffer ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == '\\' ) { c = s . charAt ( i ++ ) ; if ( c == 'n' ) c = '\n' ; else if ( c == 'r' ) c = '\r' ; else if ( c == 't' ) c = '\t' ; else if ( c == 'f' ) c = '\f' ; else if ( c == '\b' ) c = '\b' ; else if ( c == '\"' ) c = '\"' ; else if ( c == '\'' ) c = '\'' ; else if ( c == '\\' ) c = '\\' ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; } public static String getSystemProperty ( String key , String def ) { try { return System . getProperty ( key , def ) ; } catch ( Throwable e ) { LogLog . debug ( "Was not allowed to read system property \"" + key + "\"." ) ; return def ; } } public static Object instantiateByKey ( Properties props , String key , Class superClass , Object defaultValue ) { String className = findAndSubst ( key , props ) ; if ( className == null ) { LogLog . error ( "Could not find value for key " + key ) ; return defaultValue ; } return OptionConverter . instantiateByClassName ( className . trim ( ) , superClass , defaultValue ) ; } public static boolean toBoolean ( String value , boolean dEfault ) { if ( value == null ) return dEfault ; String trimmedVal = value . trim ( ) ; if ( "true" . equalsIgnoreCase ( trimmedVal ) ) return true ; if ( "false" . equalsIgnoreCase ( trimmedVal ) ) return false ; return dEfault ; } public static int toInt ( String value , int dEfault ) { if ( value != null ) { String s = value . trim ( ) ; try { return Integer . valueOf ( s ) . intValue ( ) ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; e . printStackTrace ( ) ; } } return dEfault ; } public static Level toLevel ( String value , Level defaultValue ) { if ( value == null ) return defaultValue ; int hashIndex = value . indexOf ( '#' ) ; if ( hashIndex == - 1 ) { if ( "NULL" . equalsIgnoreCase ( value ) ) { return null ; } else { return ( Level ) Level . toLevel ( value , defaultValue ) ; } } Level result = defaultValue ; String clazz = value . substring ( hashIndex + 1 ) ; String levelName = value . substring ( 0 , hashIndex ) ; if ( "NULL" . equalsIgnoreCase ( levelName ) ) { return null ; } LogLog . debug ( "toLevel" + ":class=[" + clazz + "]" + ":pri=[" + levelName + "]" ) ; try { Class customLevel = Class . forName ( clazz ) ; Class [ ] paramTypes = new Class [ ] { String . class , org . apache . log4j . Level . class } ; java . lang . reflect . Method toLevelMethod = customLevel . getMethod ( "toLevel" , paramTypes ) ; Object [ ] params = new Object [ ] { levelName , defaultValue } ; Object o = toLevelMethod . invoke ( null , params ) ; result = ( Level ) o ; } catch ( ClassNotFoundException e ) { LogLog . warn ( "custom level class [" + clazz + "] not found." ) ; } catch ( NoSuchMethodException e ) { LogLog . warn ( "custom level class [" + clazz + "]" + " does not have a constructor which takes one string parameter" , e ) ; } catch ( java . lang . reflect . InvocationTargetException e ) { LogLog . warn ( "custom level class [" + clazz + "]" + " could not be instantiated" , e ) ; } catch ( ClassCastException e ) { LogLog . warn ( "class [" + clazz + "] is not a subclass of org.apache.log4j.Level" , e ) ; } catch ( IllegalAccessException e ) { LogLog . warn ( "class [" + clazz + "] cannot be instantiated due to access restrictions" , e ) ; } catch ( Exception e ) { LogLog . warn ( "class [" + clazz + "], level [" + levelName + "] conversion failed." , e ) ; } return result ; } public static long toFileSize ( String value , long dEfault ) { if ( value == null ) return dEfault ; String s = value . trim ( ) . toUpperCase ( ) ; long multiplier = 1 ; int index ; if ( ( index = s . indexOf ( "KB" ) ) != - 1 ) { multiplier = 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "MB" ) ) != - 1 ) { multiplier = 1024 * 1024 ; s = s . substring ( 0 , index ) ; } else if ( ( index = s . indexOf ( "GB" ) ) != - 1 ) { multiplier = 1024 * 1024 * 1024 ; s = s . substring ( 0 , index ) ; } if ( s != null ) { try { return Long . valueOf ( s ) . longValue ( ) * multiplier ; } catch ( NumberFormatException e ) { LogLog . error ( "[" + s + "] is not in proper int form." ) ; LogLog . error ( "[" + value + "] not in expected format." , e ) ; } } return dEfault ; } public static String findAndSubst ( String key , Properties props ) { String value = props . getProperty ( key ) ; if ( value == null ) return null ; try { return substVars ( value , props ) ; } catch ( IllegalArgumentException e ) { LogLog . error ( "Bad option value [" + value + "]." , e ) ; return value ; } } public static Object instantiateByClassName ( String className , Class superClass , Object defaultValue ) { if ( className != null ) { try { Class classObj = Class . forName ( className ) ; if ( ! superClass . isAssignableFrom ( classObj ) ) { LogLog . error ( "A \"" + className + "\" object is not assignable to a \"" + superClass . getName ( ) + "\" variable." ) ; return defaultValue ; } return classObj . newInstance ( ) ; } catch ( Exception e ) { LogLog . error ( "Could not instantiate class [" + className + "]." , e ) ; } } return defaultValue ; } public static String substVars ( String val , Properties props ) throws IllegalArgumentException { StringBuffer sbuf = new StringBuffer ( ) ; int i = 0 ; int j , k ; while ( true ) { j = val . indexOf ( DELIM_START , i ) ; if ( j == - 1 ) { if ( i == 0 ) { return val ; } else { sbuf . append ( val . substring ( i , val . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { sbuf . append ( val . substring ( i , j ) ) ; k = val . indexOf ( DELIM_STOP , j ) ; if ( k == - 1 ) { throw new IllegalArgumentException ( '"' + val + "\" has no closing brace. Opening brace at position " + j + '.' ) ; } else { j += DELIM_START_LEN ; String key = val . substring ( j , k ) ; String replacement = getSystemProperty ( key , null ) ; if ( replacement == null && props != null ) { replacement = props . getProperty ( key ) ; } if ( replacement != null ) { String recursiveReplacement = substVars ( replacement , props ) ; sbuf . append ( recursiveReplacement ) ; } i = k + DELIM_STOP_LEN ; } } } } static public void selectAndConfigure ( URL url , String clazz , LoggerRepository hierarchy ) { Configurator configurator = null ; String filename = url . getFile ( ) ; if ( clazz == null && filename != null && filename . endsWith ( ".xml" ) ) { clazz = "org.apache.log4j.xml.DOMConfigurator" ; } if ( clazz != null ) { LogLog . debug ( "Preferred configurator class: " + clazz ) ; configurator = ( Configurator ) instantiateByClassName ( clazz , Configurator . class , null ) ; if ( configurator == null ) { LogLog . error ( "Could not instantiate configurator [" + clazz + "]." ) ; return ; } } else { configurator = new PropertyConfigurator ( ) ; } configurator . doConfigure ( url , hierarchy ) ; } } 	1	['15', '1', '0', '19', '60', '103', '16', '5', '12', '0.918367347', '760', '0', '0', '0', '0.160714286', '0', '0', '49.2', '11', '3.2', '4']
package org . apache . log4j . helpers ; public class LogLog { public static final String DEBUG_KEY = "log4j.debug" ; public static final String CONFIG_DEBUG_KEY = "log4j.configDebug" ; protected static boolean debugEnabled = false ; private static boolean quietMode = false ; private static final String PREFIX = "log4j: " ; private static final String ERR_PREFIX = "log4j:ERROR " ; private static final String WARN_PREFIX = "log4j:WARN " ; static { String key = OptionConverter . getSystemProperty ( DEBUG_KEY , null ) ; if ( key == null ) { key = OptionConverter . getSystemProperty ( CONFIG_DEBUG_KEY , null ) ; } if ( key != null ) { debugEnabled = OptionConverter . toBoolean ( key , true ) ; } } static public void setInternalDebugging ( boolean enabled ) { debugEnabled = enabled ; } public static void debug ( String msg ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; } } public static void debug ( String msg , Throwable t ) { if ( debugEnabled && ! quietMode ) { System . out . println ( PREFIX + msg ) ; if ( t != null ) t . printStackTrace ( System . out ) ; } } public static void error ( String msg ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; } public static void error ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( ERR_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } public static void setQuietMode ( boolean quietMode ) { LogLog . quietMode = quietMode ; } public static void warn ( String msg ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; } public static void warn ( String msg , Throwable t ) { if ( quietMode ) return ; System . err . println ( WARN_PREFIX + msg ) ; if ( t != null ) { t . printStackTrace ( ) ; } } } 	0	['10', '1', '0', '34', '19', '0', '34', '1', '9', '0.920634921', '146', '0.714285714', '0', '0', '0.333333333', '0', '0', '12.9', '4', '1.9', '0']
package org . apache . log4j . spi ; import java . io . Writer ; import java . io . PrintWriter ; import java . util . Vector ; public class ThrowableInformation implements java . io . Serializable { static final long serialVersionUID = - 4748765566864322735L ; private transient Throwable throwable ; private String [ ] rep ; public ThrowableInformation ( Throwable throwable ) { this . throwable = throwable ; } public Throwable getThrowable ( ) { return throwable ; } public String [ ] getThrowableStrRep ( ) { if ( rep != null ) { return ( String [ ] ) rep . clone ( ) ; } else { VectorWriter vw = new VectorWriter ( ) ; throwable . printStackTrace ( vw ) ; rep = vw . toStringArray ( ) ; vw . clear ( ) ; return rep ; } } } class VectorWriter extends PrintWriter { private Vector v ; VectorWriter ( ) { super ( new NullWriter ( ) ) ; v = new Vector ( ) ; } public void print ( Object o ) { v . addElement ( o . toString ( ) ) ; } public void print ( char [ ] s ) { v . addElement ( new String ( s ) ) ; } public void print ( String s ) { v . addElement ( s ) ; } public void println ( Object o ) { v . addElement ( o . toString ( ) ) ; } public void println ( char [ ] s ) { v . addElement ( new String ( s ) ) ; } public void println ( String s ) { v . addElement ( s ) ; } public String [ ] toStringArray ( ) { int len = v . size ( ) ; String [ ] sa = new String [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { sa [ i ] = ( String ) v . elementAt ( i ) ; } return sa ; } public void clear ( ) { v . setSize ( 0 ) ; } } class NullWriter extends Writer { public void close ( ) { } public void flush ( ) { } public void write ( char [ ] cbuf , int off , int len ) { } } 	1	['3', '1', '0', '6', '9', '0', '5', '1', '3', '0.833333333', '41', '0.666666667', '0', '0', '0.666666667', '0', '0', '11.66666667', '2', '1', '5']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . Layout ; import org . apache . log4j . Appender ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . net . SyslogAppender ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . TTCCLayout ; import org . apache . log4j . Priority ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . helpers . AbsoluteTimeDateFormat ; import java . io . IOException ; public class Min { public static void main ( String argv [ ] ) { if ( argv . length == 1 ) { ProgramInit ( argv [ 0 ] ) ; } else { Usage ( "Wrong number of arguments." ) ; } test1 ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java org.apache.log4j.test.Min " + "simple|ttcc" ) ; System . exit ( 1 ) ; } static void ProgramInit ( String layoutType ) { Appender appender = null ; Layout layout = null ; if ( layoutType . equals ( "simple" ) ) layout = new SimpleLayout ( ) ; else if ( layoutType . equals ( "ttcc" ) ) { layout = new TTCCLayout ( AbsoluteTimeDateFormat . DATE_AND_TIME_DATE_FORMAT ) ; } else Usage ( "Wrong layoutType [" + layoutType + "]." ) ; appender = new ConsoleAppender ( layout , "System.out" ) ; BasicConfigurator . configure ( appender ) ; } static void test1 ( ) { int i = 0 ; Category ERR = Category . getInstance ( "ERR" ) ; ERR . setPriority ( Priority . ERROR ) ; Category INF = Category . getInstance ( "INF" ) ; INF . setPriority ( Priority . INFO ) ; Category INF_ERR = Category . getInstance ( "INF.ERR" ) ; INF_ERR . setPriority ( Priority . ERROR ) ; Category DEB = Category . getInstance ( "DEB" ) ; DEB . setPriority ( Priority . DEBUG ) ; Category INF_UNDEF = Category . getInstance ( "INF.UNDEF" ) ; Category INF_ERR_UNDEF = Category . getInstance ( "INF.ERR.UNDEF" ) ; Category UNDEF = Category . getInstance ( "UNDEF" ) ; ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; ERR . error ( "Message " + i ) ; i ++ ; INF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF . error ( "Message " + i ) ; i ++ ; INF . warn ( "Message " + i ) ; i ++ ; INF . info ( "Message " + i ) ; i ++ ; INF_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_UNDEF . error ( "Message " + i ) ; i ++ ; INF_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR . error ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; INF_ERR_UNDEF . error ( "Message " + i ) ; i ++ ; DEB . log ( Priority . FATAL , "Message " + i ) ; i ++ ; DEB . error ( "Message " + i ) ; i ++ ; DEB . warn ( "Message " + i ) ; i ++ ; DEB . info ( "Message " + i ) ; i ++ ; DEB . debug ( "Message " + i ) ; i ++ ; UNDEF . log ( Priority . FATAL , "Message " + i ) ; i ++ ; UNDEF . error ( "Message " + i ) ; i ++ ; UNDEF . warn ( "Message " + i ) ; i ++ ; UNDEF . info ( "Message " + i ) ; i ++ ; UNDEF . debug ( "Message " + i , new Exception ( "Just testing." ) ) ; i ++ ; ERR . warn ( "Message " + i ) ; i ++ ; ERR . info ( "Message " + i ) ; i ++ ; ERR . debug ( "Message " + i ) ; i ++ ; INF . debug ( "Message " + i ) ; i ++ ; INF_UNDEF . debug ( "Message " + i ) ; i ++ ; INF_ERR . warn ( "Message " + i ) ; i ++ ; INF_ERR . info ( "Message " + i ) ; i ++ ; INF_ERR . debug ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . warn ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . info ( "Message " + i ) ; i ++ ; INF_ERR_UNDEF . debug ( "Message " + i ) ; i ++ ; INF . info ( "Messages should bear numbers 0 through 23." ) ; } } 	0	['5', '1', '0', '8', '26', '10', '0', '8', '2', '2', '508', '0', '0', '0', '0.266666667', '0', '0', '100.6', '3', '1.4', '0']
package org . apache . log4j . xml ; import org . apache . log4j . Layout ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LocationInfo ; import org . apache . log4j . helpers . OptionConverter ; import org . apache . log4j . helpers . DateLayout ; import org . apache . log4j . helpers . Transform ; public class XMLLayout extends Layout { private final int DEFAULT_SIZE = 256 ; private final int UPPER_LIMIT = 2048 ; private StringBuffer buf = new StringBuffer ( DEFAULT_SIZE ) ; private boolean locationInfo = false ; public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public boolean getLocationInfo ( ) { return locationInfo ; } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { if ( buf . capacity ( ) > UPPER_LIMIT ) { buf = new StringBuffer ( DEFAULT_SIZE ) ; } else { buf . setLength ( 0 ) ; } buf . append ( "<log4j:event category=\"" ) ; buf . append ( event . categoryName ) ; buf . append ( "\" timestamp=\"" ) ; buf . append ( event . timeStamp ) ; buf . append ( "\" level=\"" ) ; buf . append ( event . level ) ; buf . append ( "\" thread=\"" ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "\">\r\n" ) ; buf . append ( "<log4j:message><![CDATA[" ) ; buf . append ( event . getRenderedMessage ( ) ) ; buf . append ( "]]></log4j:message>\r\n" ) ; String ndc = event . getNDC ( ) ; if ( ndc != null ) { buf . append ( "<log4j:NDC><![CDATA[" ) ; buf . append ( ndc ) ; buf . append ( "]]></log4j:NDC>\r\n" ) ; } String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { buf . append ( "<log4j:throwable><![CDATA[" ) ; for ( int i = 0 ; i < s . length ; i ++ ) { buf . append ( s [ i ] ) ; buf . append ( "\r\n" ) ; } buf . append ( "]]></log4j:throwable>\r\n" ) ; } if ( locationInfo ) { LocationInfo locationInfo = event . getLocationInformation ( ) ; buf . append ( "<log4j:locationInfo class=\"" ) ; buf . append ( locationInfo . getClassName ( ) ) ; buf . append ( "\" method=\"" ) ; buf . append ( Transform . escapeTags ( locationInfo . getMethodName ( ) ) ) ; buf . append ( "\" file=\"" ) ; buf . append ( locationInfo . getFileName ( ) ) ; buf . append ( "\" line=\"" ) ; buf . append ( locationInfo . getLineNumber ( ) ) ; buf . append ( "\"/>\r\n" ) ; } buf . append ( "</log4j:event>\r\n\r\n" ) ; return buf . toString ( ) ; } public boolean ignoresThrowable ( ) { return false ; } } 	1	['6', '2', '0', '5', '24', '3', '0', '5', '6', '0.8', '239', '1', '0', '0.615384615', '0.444444444', '0', '0', '38.16666667', '6', '1.6667', '6']
package org . apache . log4j . spi ; import org . apache . log4j . Category ; import org . apache . log4j . Priority ; import org . apache . log4j . helpers . LogLog ; final public class RootCategory extends Category { public RootCategory ( Priority priority ) { super ( "root" ) ; setPriority ( priority ) ; } final public Priority getChainedPriority ( ) { return priority ; } final public void setPriority ( Priority priority ) { if ( priority == null ) { LogLog . error ( "You have tried to set a null priority to root." , new Throwable ( ) ) ; } else { this . priority = priority ; } } } 	0	['3', '2', '0', '4', '6', '3', '2', '3', '3', '2', '25', '0', '0', '0.959183673', '0.833333333', '1', '5', '7.333333333', '2', '1', '0']
package org . apache . log4j . or ; import org . apache . log4j . spi . RendererSupport ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . helpers . OptionConverter ; import java . util . Hashtable ; public class RendererMap { Hashtable map ; static ObjectRenderer defaultRenderer = new DefaultRenderer ( ) ; public RendererMap ( ) { map = new Hashtable ( ) ; } static public void addRenderer ( RendererSupport repository , String renderedClassName , String renderingClassName ) { LogLog . debug ( "Rendering class: [" + renderingClassName + "], Rendered class: [" + renderedClassName + "]." ) ; ObjectRenderer renderer = ( ObjectRenderer ) OptionConverter . instantiateByClassName ( renderingClassName , ObjectRenderer . class , null ) ; if ( renderer == null ) { LogLog . error ( "Could not instantiate renderer [" + renderingClassName + "]." ) ; return ; } else { try { Class renderedClass = Class . forName ( renderedClassName ) ; repository . setRenderer ( renderedClass , renderer ) ; } catch ( ClassNotFoundException e ) { LogLog . error ( "Could not find class [" + renderedClassName + "]." , e ) ; } } } public String findAndRender ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) . doRender ( o ) ; } public ObjectRenderer get ( Object o ) { if ( o == null ) return null ; else return get ( o . getClass ( ) ) ; } public ObjectRenderer get ( Class clazz ) { ObjectRenderer r = null ; for ( Class c = clazz ; c != null ; c = c . getSuperclass ( ) ) { r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } r = searchInterfaces ( c ) ; if ( r != null ) return r ; } return defaultRenderer ; } ObjectRenderer searchInterfaces ( Class c ) { ObjectRenderer r = ( ObjectRenderer ) map . get ( c ) ; if ( r != null ) { return r ; } else { Class [ ] ia = c . getInterfaces ( ) ; for ( int i = 0 ; i < ia . length ; i ++ ) { r = searchInterfaces ( ia [ i ] ) ; if ( r != null ) return r ; } } return null ; } public ObjectRenderer getDefaultRenderer ( ) { return defaultRenderer ; } public void clear ( ) { map . clear ( ) ; } public void put ( Class clazz , ObjectRenderer or ) { map . put ( clazz , or ) ; } } 	1	['11', '1', '0', '9', '32', '29', '5', '5', '8', '0.666666667', '197', '0', '1', '0', '0.283333333', '0', '0', '16.63636364', '4', '1.7273', '2']
package org . apache . log4j . test ; import java . net . Socket ; import java . net . ServerSocket ; import java . io . IOException ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . helpers . LogLog ; import org . apache . log4j . net . SocketNode ; import org . apache . log4j . net . SocketServer ; public class ShortSocketServer { static Category cat = Category . getInstance ( ShortSocketServer . class . getName ( ) ) ; static int port ; public static void main ( String argv [ ] ) { if ( argv . length == 2 ) { init ( argv [ 0 ] , argv [ 1 ] ) ; } else { usage ( "Wrong number of arguments." ) ; } try { LogLog . debug ( "Listening on port " + port ) ; ServerSocket serverSocket = new ServerSocket ( port ) ; LogLog . debug ( "Waiting to accept a new client." ) ; Socket socket = serverSocket . accept ( ) ; LogLog . debug ( "Connected to client at " + socket . getInetAddress ( ) ) ; LogLog . debug ( "Starting new socket node." ) ; SocketNode sn = new SocketNode ( socket , Category . getDefaultHierarchy ( ) ) ; Thread t = new Thread ( sn ) ; t . start ( ) ; t . join ( ) ; } catch ( Exception e ) { cat . error ( "Error while in main." , e ) ; } } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + ShortSocketServer . class . getName ( ) + " port configFile" ) ; System . exit ( 1 ) ; } static void init ( String portStr , String configFile ) { try { port = Integer . parseInt ( portStr ) ; } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; usage ( "Could not interpret port number [" + portStr + "]." ) ; } PropertyConfigurator . configure ( configFile ) ; } } 	0	['6', '1', '0', '5', '32', '9', '0', '5', '2', '0.666666667', '148', '0', '1', '0', '0.333333333', '0', '0', '23.16666667', '2', '1', '0']
package org . apache . log4j . chainsaw ; import java . awt . BorderLayout ; import java . awt . Dimension ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . io . IOException ; import java . util . Properties ; import javax . swing . BorderFactory ; import javax . swing . JFrame ; import javax . swing . JMenu ; import javax . swing . JMenuBar ; import javax . swing . JMenuItem ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JSplitPane ; import javax . swing . JTable ; import javax . swing . ListSelectionModel ; import org . apache . log4j . Category ; import org . apache . log4j . PropertyConfigurator ; public class Main extends JFrame { private static final int DEFAULT_PORT = 4445 ; public static final String PORT_PROP_NAME = "chainsaw.port" ; private static final Category LOG = Category . getInstance ( Main . class ) ; private Main ( ) { super ( "CHAINSAW - Log4J Log Viewer" ) ; final MyTableModel model = new MyTableModel ( ) ; final JMenuBar menuBar = new JMenuBar ( ) ; setJMenuBar ( menuBar ) ; final JMenu menu = new JMenu ( "File" ) ; menuBar . add ( menu ) ; try { final LoadXMLAction lxa = new LoadXMLAction ( this , model ) ; final JMenuItem loadMenuItem = new JMenuItem ( "Load file..." ) ; menu . add ( loadMenuItem ) ; loadMenuItem . addActionListener ( lxa ) ; } catch ( NoClassDefFoundError e ) { LOG . info ( "Missing classes for XML parser" , e ) ; JOptionPane . showMessageDialog ( this , "XML parser not in classpath - unable to load XML events." , "CHAINSAW" , JOptionPane . ERROR_MESSAGE ) ; } catch ( Exception e ) { LOG . info ( "Unable to create the action to load XML files" , e ) ; JOptionPane . showMessageDialog ( this , "Unable to create a XML parser - unable to load XML events." , "CHAINSAW" , JOptionPane . ERROR_MESSAGE ) ; } final JMenuItem exitMenuItem = new JMenuItem ( "Exit" ) ; menu . add ( exitMenuItem ) ; exitMenuItem . addActionListener ( ExitAction . INSTANCE ) ; final ControlPanel cp = new ControlPanel ( model ) ; getContentPane ( ) . add ( cp , BorderLayout . NORTH ) ; final JTable table = new JTable ( model ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; final JScrollPane scrollPane = new JScrollPane ( table ) ; scrollPane . setBorder ( BorderFactory . createTitledBorder ( "Events: " ) ) ; scrollPane . setPreferredSize ( new Dimension ( 900 , 300 ) ) ; final JPanel details = new DetailPanel ( table , model ) ; details . setPreferredSize ( new Dimension ( 900 , 300 ) ) ; final JSplitPane jsp = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , scrollPane , details ) ; getContentPane ( ) . add ( jsp , BorderLayout . CENTER ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent aEvent ) { ExitAction . INSTANCE . actionPerformed ( null ) ; } } ) ; pack ( ) ; setVisible ( true ) ; setupReceiver ( model ) ; } private void setupReceiver ( MyTableModel aModel ) { int port = DEFAULT_PORT ; final String strRep = System . getProperty ( PORT_PROP_NAME ) ; if ( strRep != null ) { try { port = Integer . parseInt ( strRep ) ; } catch ( NumberFormatException nfe ) { LOG . fatal ( "Unable to parse " + PORT_PROP_NAME + " property with value " + strRep + "." ) ; JOptionPane . showMessageDialog ( this , "Unable to parse port number from '" + strRep + "', quitting." , "CHAINSAW" , JOptionPane . ERROR_MESSAGE ) ; System . exit ( 1 ) ; } } try { final LoggingReceiver lr = new LoggingReceiver ( aModel , port ) ; lr . start ( ) ; } catch ( IOException e ) { LOG . fatal ( "Unable to connect to socket server, quiting" , e ) ; JOptionPane . showMessageDialog ( this , "Unable to create socket on port " + port + ", quitting." , "CHAINSAW" , JOptionPane . ERROR_MESSAGE ) ; System . exit ( 1 ) ; } } private static void initLog4J ( ) { final Properties props = new Properties ( ) ; props . setProperty ( "log4j.rootCategory" , "DEBUG, A1" ) ; props . setProperty ( "log4j.appender.A1" , "org.apache.log4j.ConsoleAppender" ) ; props . setProperty ( "log4j.appender.A1.layout" , "org.apache.log4j.TTCCLayout" ) ; PropertyConfigurator . configure ( props ) ; } public static void main ( String [ ] aArgs ) { initLog4J ( ) ; new Main ( ) ; } } 	1	['6', '6', '0', '9', '52', '9', '1', '9', '1', '0.95', '279', '0.5', '1', '0.993660856', '0.25', '0', '0', '44.83333333', '2', '0.8333', '2']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; public class SyslogQuietWriter extends QuietWriter { int syslogFacility ; int priority ; public SyslogQuietWriter ( Writer writer , int syslogFacility , ErrorHandler eh ) { super ( writer , eh ) ; this . syslogFacility = syslogFacility ; } public void setPriority ( int priority ) { this . priority = priority ; } public void setSyslogFacility ( int syslogFacility ) { this . syslogFacility = syslogFacility ; } public void write ( String string ) { super . write ( "<" + ( syslogFacility | priority ) + ">" + string ) ; } } 	0	['4', '4', '0', '3', '10', '0', '1', '2', '4', '0.5', '41', '0', '0', '0.875', '0.5', '2', '2', '8.75', '1', '0.75', '0']
package org . apache . log4j . jmx ; import javax . management . ObjectName ; import javax . management . MBeanServer ; import javax . management . MBeanServerFactory ; import com . sun . jdmk . comm . HtmlAdaptorServer ; import org . apache . log4j . Category ; public class Agent { static Category log = Category . getInstance ( Agent . class ) ; public Agent ( ) { } public void start ( ) { MBeanServer server = MBeanServerFactory . createMBeanServer ( ) ; HtmlAdaptorServer html = new HtmlAdaptorServer ( ) ; try { log . info ( "Registering HtmlAdaptorServer instance." ) ; server . registerMBean ( html , new ObjectName ( "Adaptor:name=html,port=8082" ) ) ; log . info ( "Registering HierarchyDynamicMBean instance." ) ; HierarchyDynamicMBean hdm = new HierarchyDynamicMBean ( ) ; server . registerMBean ( hdm , new ObjectName ( "log4j:hiearchy=default" ) ) ; } catch ( Exception e ) { log . error ( "Problem while regitering MBeans instances." , e ) ; return ; } html . start ( ) ; } } 	1	['4', '1', '0', '3', '15', '4', '1', '2', '2', '0.833333333', '68', '0', '1', '0', '0.5', '0', '0', '15.5', '1', '0.5', '2']
package org . apache . log4j . performance ; public class SystemTime { static int RUN_LENGTH = 1000000 ; static public void main ( String [ ] args ) { double t = systemCurrentTimeLoop ( ) ; System . out . println ( "Average System.currentTimeMillis() call took " + t ) ; t = currentThreadNameloop ( ) ; System . out . println ( "Average Thread.currentThread().getName() call took " + t ) ; } static double systemCurrentTimeLoop ( ) { long before = System . currentTimeMillis ( ) ; long l ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { l = System . currentTimeMillis ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } static double currentThreadNameloop ( ) { long before = System . currentTimeMillis ( ) ; String t ; for ( int i = 0 ; i < RUN_LENGTH ; i ++ ) { t = Thread . currentThread ( ) . getName ( ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / RUN_LENGTH ; } } 	0	['5', '1', '0', '0', '14', '4', '0', '0', '2', '0.25', '80', '0', '0', '0', '0.25', '0', '0', '14.8', '2', '1', '0']
package org . apache . log4j . spi ; import org . apache . log4j . * ; import java . util . Enumeration ; public interface LoggerRepository { public void addHierarchyEventListener ( HierarchyEventListener listener ) ; boolean isDisabled ( int level ) ; public void setThreshold ( Level level ) ; public void setThreshold ( String val ) ; public void emitNoAppenderWarning ( Category cat ) ; public Level getThreshold ( ) ; public Logger getLogger ( String name ) ; public Logger getLogger ( String name , LoggerFactory factory ) ; public Logger getRootLogger ( ) ; public abstract Logger exists ( String name ) ; public abstract void shutdown ( ) ; public Enumeration getCurrentLoggers ( ) ; public Enumeration getCurrentCategories ( ) ; public abstract void fireAddAppenderEvent ( Category logger , Appender appender ) ; public abstract void resetConfiguration ( ) ; } 	1	['15', '1', '0', '27', '15', '105', '22', '6', '15', '2', '15', '0', '0', '0', '0.216666667', '0', '0', '0', '1', '1', '3']
package org . apache . log4j . or ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . LogLog ; import javax . jms . Message ; import javax . jms . JMSException ; import javax . jms . DeliveryMode ; import java . util . Enumeration ; public class MessageRenderer implements ObjectRenderer { public MessageRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Message ) { StringBuffer sbuf = new StringBuffer ( ) ; Message m = ( Message ) o ; try { sbuf . append ( "DeliveryMode=" ) ; switch ( m . getJMSDeliveryMode ( ) ) { case DeliveryMode . NON_PERSISTENT : sbuf . append ( "NON_PERSISTENT" ) ; break ; case DeliveryMode . PERSISTENT : sbuf . append ( "PERSISTENT" ) ; break ; default : sbuf . append ( "UNKNOWN" ) ; } sbuf . append ( ", CorrelationID=" ) ; sbuf . append ( m . getJMSCorrelationID ( ) ) ; sbuf . append ( ", Destination=" ) ; sbuf . append ( m . getJMSDestination ( ) ) ; sbuf . append ( ", Expiration=" ) ; sbuf . append ( m . getJMSExpiration ( ) ) ; sbuf . append ( ", MessageID=" ) ; sbuf . append ( m . getJMSMessageID ( ) ) ; sbuf . append ( ", Priority=" ) ; sbuf . append ( m . getJMSPriority ( ) ) ; sbuf . append ( ", Redelivered=" ) ; sbuf . append ( m . getJMSRedelivered ( ) ) ; sbuf . append ( ", ReplyTo=" ) ; sbuf . append ( m . getJMSReplyTo ( ) ) ; sbuf . append ( ", Timestamp=" ) ; sbuf . append ( m . getJMSTimestamp ( ) ) ; sbuf . append ( ", Type=" ) ; sbuf . append ( m . getJMSType ( ) ) ; } catch ( JMSException e ) { LogLog . error ( "Could not parse Message." , e ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	0	['2', '1', '0', '3', '22', '1', '1', '2', '2', '2', '128', '0', '0', '0', '0.75', '0', '0', '63', '5', '2.5', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . xml . DOMConfigurator ; import java . util . Random ; public class StressAsyncAppender extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int BRANCHING_FACTOR = 4 ; static int maxThreads ; static long msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { if ( args . length != 1 ) { usage ( ) ; } DOMConfigurator . configure ( "xml/stressAsyncAppender.xml" ) ; try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java " + StressAsyncAppender . class . getName ( ) + " MAX_THREADS" ) ; System . exit ( 1 ) ; } public StressAsyncAppender ( ) { } public void run ( ) { int loopLength = StressAsyncAppender . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop, loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; synchronized ( lock ) { root . debug ( "Message number " + msgCounter ++ ) ; } } synchronized ( lock ) { StressAsyncAppender . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressAsyncAppender . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstrained ( n ) ; root . debug ( "Creating " + n + " child StressAsyncAppender threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressAsyncAppender, threadCounter = " + ( ++ threadCounter ) ) ; new StressAsyncAppender ( ) . start ( ) ; } } } static public int maxThreadsConstrained ( int a ) { int maxAllowed = StressAsyncAppender . maxThreads - StressAsyncAppender . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public void delay ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( Exception e ) { } } } 	1	['10', '2', '0', '2', '37', '23', '0', '2', '7', '0.833333333', '301', '0', '1', '0.884057971', '0.2', '0', '0', '28.1', '4', '1.7', '1']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . net . DatagramSocket ; import java . net . InetAddress ; import java . net . DatagramPacket ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . io . IOException ; public class SyslogWriter extends Writer { final int SYSLOG_PORT = 514 ; static String syslogHost ; private InetAddress address ; private DatagramSocket ds ; public SyslogWriter ( String syslogHost ) { this . syslogHost = syslogHost ; try { this . address = InetAddress . getByName ( syslogHost ) ; } catch ( UnknownHostException e ) { LogLog . error ( "Could not find " + syslogHost + ". All logging will FAIL." , e ) ; } try { this . ds = new DatagramSocket ( ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; LogLog . error ( "Could not instantiate DatagramSocket to " + syslogHost + ". All logging will FAIL." , e ) ; } } public void write ( char [ ] buf , int off , int len ) throws IOException { this . write ( new String ( buf , off , len ) ) ; } public void write ( String string ) throws IOException { DatagramPacket packet = new DatagramPacket ( string . getBytes ( ) , string . length ( ) , address , SYSLOG_PORT ) ; if ( this . ds != null ) ds . send ( packet ) ; } public void flush ( ) { } public void close ( ) { } } 	0	['5', '2', '0', '2', '18', '8', '1', '1', '5', '0.75', '88', '0.5', '0', '0.764705882', '0.45', '1', '2', '15.8', '1', '0.8', '0']
package org . apache . log4j . lf5 . viewer . categoryexplorer ; import javax . swing . * ; import javax . swing . event . CellEditorListener ; import javax . swing . event . ChangeEvent ; import javax . swing . event . EventListenerList ; import javax . swing . table . TableCellEditor ; import javax . swing . tree . TreeCellEditor ; import java . awt . * ; import java . awt . event . MouseEvent ; import java . util . EventObject ; public class CategoryAbstractCellEditor implements TableCellEditor , TreeCellEditor { protected EventListenerList _listenerList = new EventListenerList ( ) ; protected Object _value ; protected ChangeEvent _changeEvent = null ; protected int _clickCountToStart = 1 ; public Object getCellEditorValue ( ) { return _value ; } public void setCellEditorValue ( Object value ) { _value = value ; } public void setClickCountToStart ( int count ) { _clickCountToStart = count ; } public int getClickCountToStart ( ) { return _clickCountToStart ; } public boolean isCellEditable ( EventObject anEvent ) { if ( anEvent instanceof MouseEvent ) { if ( ( ( MouseEvent ) anEvent ) . getClickCount ( ) < _clickCountToStart ) { return false ; } } return true ; } public boolean shouldSelectCell ( EventObject anEvent ) { if ( this . isCellEditable ( anEvent ) ) { if ( anEvent == null || ( ( MouseEvent ) anEvent ) . getClickCount ( ) >= _clickCountToStart ) { return true ; } } return false ; } public boolean stopCellEditing ( ) { fireEditingStopped ( ) ; return true ; } public void cancelCellEditing ( ) { fireEditingCanceled ( ) ; } public void addCellEditorListener ( CellEditorListener l ) { _listenerList . add ( CellEditorListener . class , l ) ; } public void removeCellEditorListener ( CellEditorListener l ) { _listenerList . remove ( CellEditorListener . class , l ) ; } public Component getTreeCellEditorComponent ( JTree tree , Object value , boolean isSelected , boolean expanded , boolean leaf , int row ) { return null ; } public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { return null ; } protected void fireEditingStopped ( ) { Object [ ] listeners = _listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == CellEditorListener . class ) { if ( _changeEvent == null ) { _changeEvent = new ChangeEvent ( this ) ; } ( ( CellEditorListener ) listeners [ i + 1 ] ) . editingStopped ( _changeEvent ) ; } } } protected void fireEditingCanceled ( ) { Object [ ] listeners = _listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == CellEditorListener . class ) { if ( _changeEvent == null ) { _changeEvent = new ChangeEvent ( this ) ; } ( ( CellEditorListener ) listeners [ i + 1 ] ) . editingCanceled ( _changeEvent ) ; } } } } 	1	['16', '1', '1', '3', '28', '78', '3', '0', '13', '0.733333333', '213', '0.8', '0', '0', '0.208333333', '0', '0', '12', '5', '1.875', '2']
package org . apache . log4j . performance ; import java . io . Writer ; import java . io . IOException ; public class NOPWriter extends Writer { public void write ( char [ ] cbuf ) throws IOException { } public void write ( char [ ] cbuf , int off , int len ) throws IOException { } public void write ( int b ) throws IOException { } public void write ( String s ) throws IOException { } public void write ( String s , int off , int len ) throws IOException { } public void flush ( ) throws IOException { } public void close ( ) throws IOException { System . err . println ( "Close called." ) ; } } 	0	['8', '2', '0', '0', '10', '28', '0', '0', '8', '2', '21', '0', '0', '0.65', '0.46875', '1', '2', '1.625', '1', '0.875', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . helpers . BoundedFIFO ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import org . apache . log4j . helpers . LogLog ; import java . util . Enumeration ; public class AsyncAppender extends AppenderSkeleton implements AppenderAttachable { public static final int DEFAULT_BUFFER_SIZE = 128 ; BoundedFIFO bf = new BoundedFIFO ( DEFAULT_BUFFER_SIZE ) ; AppenderAttachableImpl aai ; Dispatcher dispatcher ; boolean locationInfo = false ; boolean interruptedWarningMessage = false ; public AsyncAppender ( ) { aai = new AppenderAttachableImpl ( ) ; dispatcher = new Dispatcher ( bf , this ) ; dispatcher . start ( ) ; } public void addAppender ( Appender newAppender ) { synchronized ( aai ) { aai . addAppender ( newAppender ) ; } } public void append ( LoggingEvent event ) { event . getNDC ( ) ; event . getThreadName ( ) ; event . getMDCCopy ( ) ; if ( locationInfo ) { event . getLocationInformation ( ) ; } synchronized ( bf ) { while ( bf . isFull ( ) ) { try { bf . wait ( ) ; } catch ( InterruptedException e ) { if ( ! interruptedWarningMessage ) { interruptedWarningMessage = true ; LogLog . warn ( "AsyncAppender interrupted." , e ) ; } else { LogLog . warn ( "AsyncAppender interrupted again." ) ; } } } bf . put ( event ) ; if ( bf . wasEmpty ( ) ) { bf . notify ( ) ; } } } public void close ( ) { synchronized ( this ) { if ( closed ) { return ; } closed = true ; } dispatcher . close ( ) ; try { dispatcher . join ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "Got an InterruptedException while waiting for the " + "dispatcher to finish." , e ) ; } dispatcher = null ; bf = null ; } public Enumeration getAllAppenders ( ) { synchronized ( aai ) { return aai . getAllAppenders ( ) ; } } public Appender getAppender ( String name ) { synchronized ( aai ) { return aai . getAppender ( name ) ; } } public boolean getLocationInfo ( ) { return locationInfo ; } public boolean isAttached ( Appender appender ) { return aai . isAttached ( appender ) ; } public boolean requiresLayout ( ) { return false ; } public void removeAllAppenders ( ) { synchronized ( aai ) { aai . removeAllAppenders ( ) ; } } public void removeAppender ( Appender appender ) { synchronized ( aai ) { aai . removeAppender ( appender ) ; } } public void removeAppender ( String name ) { synchronized ( aai ) { aai . removeAppender ( name ) ; } } public void setLocationInfo ( boolean flag ) { locationInfo = flag ; } public void setBufferSize ( int size ) { bf . resize ( size ) ; } public int getBufferSize ( ) { return bf . getMaxSize ( ) ; } } class Dispatcher extends Thread { BoundedFIFO bf ; AppenderAttachableImpl aai ; boolean interrupted = false ; AsyncAppender container ; Dispatcher ( BoundedFIFO bf , AsyncAppender container ) { this . bf = bf ; this . container = container ; this . aai = container . aai ; this . setPriority ( Thread . MIN_PRIORITY ) ; this . setName ( "Dispatcher-" + getName ( ) ) ; } void close ( ) { synchronized ( bf ) { interrupted = true ; if ( bf . length ( ) == 0 ) { bf . notify ( ) ; } } } public void run ( ) { LoggingEvent event ; while ( true ) { synchronized ( bf ) { if ( bf . length ( ) == 0 ) { if ( interrupted ) { return ; } try { bf . wait ( ) ; } catch ( InterruptedException e ) { LogLog . error ( "The dispathcer should not be interrupted." ) ; break ; } } event = bf . get ( ) ; if ( bf . wasFull ( ) ) { bf . notify ( ) ; } } synchronized ( container . aai ) { if ( aai != null && event != null ) { aai . appendLoopOnAppenders ( event ) ; } } } } } 	1	['15', '2', '0', '9', '43', '19', '1', '9', '15', '0.821428571', '279', '0', '3', '0.5625', '0.255555556', '1', '2', '17.2', '5', '1.2667', '5']
package org . apache . log4j ; import org . apache . log4j . spi . Filter ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; public interface Appender { void addFilter ( Filter newFilter ) ; public Filter getFilter ( ) ; public void clearFilters ( ) ; public void close ( ) ; public void doAppend ( LoggingEvent event ) ; public String getName ( ) ; public void setErrorHandler ( ErrorHandler errorHandler ) ; public ErrorHandler getErrorHandler ( ) ; public void setLayout ( Layout layout ) ; public Layout getLayout ( ) ; public void setName ( String name ) ; public boolean requiresLayout ( ) ; } 	0	['12', '1', '0', '21', '12', '66', '17', '4', '12', '2', '12', '0', '0', '0', '0.236111111', '0', '0', '0', '1', '1', '0']
package org . apache . log4j . helpers ; import java . util . Calendar ; import java . util . TimeZone ; import java . util . Date ; import java . text . FieldPosition ; import java . text . ParsePosition ; import java . text . DateFormatSymbols ; public class DateTimeDateFormat extends AbsoluteTimeDateFormat { String [ ] shortMonths ; public DateTimeDateFormat ( ) { super ( ) ; shortMonths = new DateFormatSymbols ( ) . getShortMonths ( ) ; } public DateTimeDateFormat ( TimeZone timeZone ) { this ( ) ; setCalendar ( Calendar . getInstance ( timeZone ) ) ; } public StringBuffer format ( Date date , StringBuffer sbuf , FieldPosition fieldPosition ) { calendar . setTime ( date ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; if ( day < 10 ) sbuf . append ( '0' ) ; sbuf . append ( day ) ; sbuf . append ( ' ' ) ; sbuf . append ( shortMonths [ calendar . get ( Calendar . MONTH ) ] ) ; sbuf . append ( ' ' ) ; int year = calendar . get ( Calendar . YEAR ) ; sbuf . append ( year ) ; sbuf . append ( ' ' ) ; return super . format ( date , sbuf , fieldPosition ) ; } public Date parse ( java . lang . String s , ParsePosition pos ) { return null ; } } 	1	['4', '4', '0', '3', '15', '4', '2', '1', '4', '0.333333333', '80', '0', '0', '0.953488372', '0.357142857', '1', '3', '18.75', '2', '0.75', '4']
package org . apache . log4j . test ; import org . apache . log4j . * ; public class CategoryWrapper { Category c ; static String FQCN = CategoryWrapper . class . getName ( ) ; CategoryWrapper ( String name ) { c = Category . getInstance ( name ) ; } public static void main ( String argv [ ] ) { Layout layout = new PatternLayout ( "%p [%t] %C %F - %m\n" ) ; Appender out = new ConsoleAppender ( layout , ConsoleAppender . SYSTEM_OUT ) ; CategoryWrapper w1 = new CategoryWrapper ( "c1" ) ; w1 . addAppender ( out ) ; w1 . print ( "hello" ) ; } public void addAppender ( Appender appender ) { c . addAppender ( appender ) ; } public void print ( String msg ) { c . log ( FQCN + ".print" , Priority . DEBUG , msg , null ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + CategoryWrapper . class . getName ( ) + " fileName" ) ; System . exit ( 1 ) ; } } 	0	['7', '1', '0', '6', '22', '11', '0', '6', '3', '0.666666667', '107', '0', '1', '0', '0.375', '0', '0', '13.85714286', '2', '0.8571', '0']
package org . apache . log4j ; import org . apache . log4j . spi . AppenderAttachable ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . spi . LoggerRepository ; import org . apache . log4j . helpers . NullEnumeration ; import org . apache . log4j . helpers . AppenderAttachableImpl ; import java . util . Enumeration ; import java . util . MissingResourceException ; import java . util . ResourceBundle ; public class Category implements AppenderAttachable { static int nooptimize ; protected String name ; volatile protected Level level ; volatile protected Category parent ; private static final String FQCN = Category . class . getName ( ) ; protected ResourceBundle resourceBundle ; protected LoggerRepository repository ; AppenderAttachableImpl aai ; protected boolean additive = true ; protected Category ( String name ) { this . name = name ; } synchronized public void addAppender ( Appender newAppender ) { if ( aai == null ) { aai = new AppenderAttachableImpl ( ) ; } aai . addAppender ( newAppender ) ; repository . fireAddAppenderEvent ( this , newAppender ) ; } public void assertLog ( boolean assertion , String msg ) { if ( ! assertion ) this . error ( msg ) ; } public void callAppenders ( LoggingEvent event ) { int writes = 0 ; for ( Category c = this ; c != null ; c = c . parent ) { synchronized ( c ) { if ( c . aai != null ) { writes += c . aai . appendLoopOnAppenders ( event ) ; } if ( ! c . additive ) { break ; } } } if ( writes == 0 ) { repository . emitNoAppenderWarning ( this ) ; } } synchronized void closeNestedAppenders ( ) { Enumeration enum = this . getAllAppenders ( ) ; if ( enum != null ) { while ( enum . hasMoreElements ( ) ) { Appender a = ( Appender ) enum . nextElement ( ) ; if ( a instanceof AppenderAttachable ) { a . close ( ) ; } } } } public void debug ( Object message ) { if ( repository . isDisabled ( Level . DEBUG_INT ) ) return ; if ( Level . DEBUG . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) { forcedLog ( FQCN , Level . DEBUG , message , null ) ; } } public void debug ( Object message , Throwable t ) { if ( repository . isDisabled ( Level . DEBUG_INT ) ) return ; if ( Level . DEBUG . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . DEBUG , message , t ) ; } public void error ( Object message ) { if ( repository . isDisabled ( Level . ERROR_INT ) ) return ; if ( Level . ERROR . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . ERROR , message , null ) ; } public void error ( Object message , Throwable t ) { if ( repository . isDisabled ( Level . ERROR_INT ) ) return ; if ( Level . ERROR . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . ERROR , message , t ) ; } public static Logger exists ( String name ) { return LogManager . exists ( name ) ; } public void fatal ( Object message ) { if ( repository . isDisabled ( Level . FATAL_INT ) ) return ; if ( Level . FATAL . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . FATAL , message , null ) ; } public void fatal ( Object message , Throwable t ) { if ( repository . isDisabled ( Level . FATAL_INT ) ) return ; if ( Level . FATAL . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . FATAL , message , t ) ; } protected void forcedLog ( String fqcn , Priority level , Object message , Throwable t ) { callAppenders ( new LoggingEvent ( fqcn , this , level , message , t ) ) ; } public boolean getAdditivity ( ) { return additive ; } synchronized public Enumeration getAllAppenders ( ) { if ( aai == null ) return NullEnumeration . getInstance ( ) ; else return aai . getAllAppenders ( ) ; } synchronized public Appender getAppender ( String name ) { if ( aai == null || name == null ) return null ; return aai . getAppender ( name ) ; } public Level getEffectiveLevel ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . level != null ) return c . level ; } return null ; } public Priority getChainedPriority ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . level != null ) return c . level ; } return null ; } public static Enumeration getCurrentCategories ( ) { return LogManager . getCurrentLoggers ( ) ; } public static LoggerRepository getDefaultHierarchy ( ) { return LogManager . getLoggerRepository ( ) ; } public LoggerRepository getHierarchy ( ) { return repository ; } public LoggerRepository getLoggerRepository ( ) { return repository ; } public static Category getInstance ( String name ) { nooptimize ++ ; return LogManager . getLogger ( name ) ; } public static Category getInstance ( Class clazz ) { nooptimize ++ ; return LogManager . getLogger ( clazz ) ; } public final String getName ( ) { return name ; } final public Category getParent ( ) { return this . parent ; } final public Level getLevel ( ) { return this . level ; } final public Level getPriority ( ) { return this . level ; } final public static Category getRoot ( ) { return LogManager . getRootLogger ( ) ; } public ResourceBundle getResourceBundle ( ) { for ( Category c = this ; c != null ; c = c . parent ) { if ( c . resourceBundle != null ) return c . resourceBundle ; } return null ; } protected String getResourceBundleString ( String key ) { ResourceBundle rb = getResourceBundle ( ) ; if ( rb == null ) { return null ; } else { try { return rb . getString ( key ) ; } catch ( MissingResourceException mre ) { error ( "No resource is associated with key \"" + key + "\"." ) ; return null ; } } } public void info ( Object message ) { if ( repository . isDisabled ( Level . INFO_INT ) ) return ; if ( Level . INFO . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . INFO , message , null ) ; } public void info ( Object message , Throwable t ) { if ( repository . isDisabled ( Level . INFO_INT ) ) return ; if ( Level . INFO . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . INFO , message , t ) ; } public boolean isAttached ( Appender appender ) { if ( appender == null || aai == null ) return false ; else { return aai . isAttached ( appender ) ; } } public boolean isDebugEnabled ( ) { if ( repository . isDisabled ( Level . DEBUG_INT ) ) return false ; return Level . DEBUG . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ; } public boolean isEnabledFor ( Priority level ) { if ( repository . isDisabled ( level . level ) ) return false ; return level . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ; } public boolean isInfoEnabled ( ) { if ( repository . isDisabled ( Level . INFO_INT ) ) return false ; return Level . INFO . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ; } public void l7dlog ( Priority priority , String key , Throwable t ) { if ( repository . isDisabled ( priority . level ) ) { return ; } if ( priority . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) { String msg = getResourceBundleString ( key ) ; if ( msg == null ) { msg = key ; } forcedLog ( FQCN , priority , msg , t ) ; } } public void l7dlog ( Priority priority , String key , Object [ ] params , Throwable t ) { if ( repository . isDisabled ( priority . level ) ) { return ; } if ( priority . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) { String pattern = getResourceBundleString ( key ) ; String msg ; if ( pattern == null ) msg = key ; else msg = java . text . MessageFormat . format ( pattern , params ) ; forcedLog ( FQCN , priority , msg , t ) ; } } public void log ( Priority priority , Object message , Throwable t ) { if ( repository . isDisabled ( priority . level ) ) { return ; } if ( priority . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , priority , message , t ) ; } public void log ( Priority priority , Object message ) { if ( repository . isDisabled ( priority . level ) ) { return ; } if ( priority . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , priority , message , null ) ; } public void log ( String callerFQCN , Priority level , Object message , Throwable t ) { if ( repository . isDisabled ( level . level ) ) { return ; } if ( level . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) { forcedLog ( callerFQCN , level , message , t ) ; } } synchronized public void removeAllAppenders ( ) { if ( aai != null ) { aai . removeAllAppenders ( ) ; aai = null ; } } synchronized public void removeAppender ( Appender appender ) { if ( appender == null || aai == null ) return ; aai . removeAppender ( appender ) ; } synchronized public void removeAppender ( String name ) { if ( name == null || aai == null ) return ; aai . removeAppender ( name ) ; } public void setAdditivity ( boolean additive ) { this . additive = additive ; } final void setHierarchy ( LoggerRepository repository ) { this . repository = repository ; } public void setLevel ( Level level ) { this . level = level ; } public void setPriority ( Priority priority ) { this . level = ( Level ) priority ; } public void setResourceBundle ( ResourceBundle bundle ) { resourceBundle = bundle ; } public static void shutdown ( ) { LogManager . shutdown ( ) ; } public void warn ( Object message ) { if ( repository . isDisabled ( Level . WARN_INT ) ) return ; if ( Level . WARN . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . WARN , message , null ) ; } public void warn ( Object message , Throwable t ) { if ( repository . isDisabled ( Level . WARN_INT ) ) return ; if ( Level . WARN . isGreaterOrEqual ( this . getEffectiveLevel ( ) ) ) forcedLog ( FQCN , Level . WARN , message , t ) ; } } 	1	['55', '1', '1', '65', '90', '831', '58', '10', '48', '0.766666667', '733', '0.7', '4', '0', '0.143874644', '0', '0', '12.14545455', '5', '2.0545', '5']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public String [ ] getOptionStrings ( ) { return null ; } public void setOption ( String key , String value ) { } public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } } 	0	['6', '1', '0', '3', '9', '9', '1', '2', '6', '0.866666667', '44', '0', '0', '0', '0.458333333', '0', '0', '5.833333333', '2', '1.1667', '0']
package org . apache . log4j . lf5 . viewer . categoryexplorer ; import javax . swing . tree . DefaultMutableTreeNode ; import javax . swing . tree . TreeNode ; import java . util . Enumeration ; public class CategoryNode extends DefaultMutableTreeNode { protected boolean _selected = true ; protected int _numberOfContainedRecords = 0 ; protected int _numberOfRecordsFromChildren = 0 ; protected boolean _hasFatalChildren = false ; protected boolean _hasFatalRecords = false ; public CategoryNode ( String title ) { setUserObject ( title ) ; } public String getTitle ( ) { return ( String ) getUserObject ( ) ; } public void setSelected ( boolean s ) { if ( s != _selected ) { _selected = s ; } } public boolean isSelected ( ) { return _selected ; } public void setAllDescendantsSelected ( ) { Enumeration children = children ( ) ; while ( children . hasMoreElements ( ) ) { CategoryNode node = ( CategoryNode ) children . nextElement ( ) ; node . setSelected ( true ) ; node . setAllDescendantsSelected ( ) ; } } public void setAllDescendantsDeSelected ( ) { Enumeration children = children ( ) ; while ( children . hasMoreElements ( ) ) { CategoryNode node = ( CategoryNode ) children . nextElement ( ) ; node . setSelected ( false ) ; node . setAllDescendantsDeSelected ( ) ; } } public String toString ( ) { return ( getTitle ( ) ) ; } public boolean equals ( Object obj ) { if ( obj instanceof CategoryNode ) { CategoryNode node = ( CategoryNode ) obj ; String tit1 = getTitle ( ) . toLowerCase ( ) ; String tit2 = node . getTitle ( ) . toLowerCase ( ) ; if ( tit1 . equals ( tit2 ) ) { return ( true ) ; } } return ( false ) ; } public int hashCode ( ) { return ( getTitle ( ) . hashCode ( ) ) ; } public void addRecord ( ) { _numberOfContainedRecords ++ ; addRecordToParent ( ) ; } public int getNumberOfContainedRecords ( ) { return _numberOfContainedRecords ; } public void resetNumberOfContainedRecords ( ) { _numberOfContainedRecords = 0 ; _numberOfRecordsFromChildren = 0 ; _hasFatalRecords = false ; _hasFatalChildren = false ; } public boolean hasFatalRecords ( ) { return _hasFatalRecords ; } public boolean hasFatalChildren ( ) { return _hasFatalChildren ; } public void setHasFatalRecords ( boolean flag ) { _hasFatalRecords = flag ; } public void setHasFatalChildren ( boolean flag ) { _hasFatalChildren = flag ; } protected int getTotalNumberOfRecords ( ) { return getNumberOfRecordsFromChildren ( ) + getNumberOfContainedRecords ( ) ; } protected void addRecordFromChild ( ) { _numberOfRecordsFromChildren ++ ; addRecordToParent ( ) ; } protected int getNumberOfRecordsFromChildren ( ) { return _numberOfRecordsFromChildren ; } protected void addRecordToParent ( ) { TreeNode parent = getParent ( ) ; if ( parent == null ) { return ; } ( ( CategoryNode ) parent ) . addRecordFromChild ( ) ; } } 	1	['20', '2', '0', '15', '30', '142', '15', '0', '16', '0.8', '191', '1', '0', '0.736111111', '0.3125', '2', '3', '8.3', '3', '1.25', '3']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	0	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '0']
package org . apache . log4j . varia ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import java . io . IOException ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . net . Socket ; public class Roller { static Category cat = Category . getInstance ( Roller . class . getName ( ) ) ; static String host ; static int port ; Roller ( ) { } public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] ) ; else usage ( "Wrong number of arguments." ) ; roll ( ) ; } static void usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Roller . class . getName ( ) + "host_name port_number" ) ; System . exit ( 1 ) ; } static void init ( String hostArg , String portArg ) { host = hostArg ; try { port = Integer . parseInt ( portArg ) ; } catch ( java . lang . NumberFormatException e ) { usage ( "Second argument " + portArg + " is not a valid integer." ) ; } } static void roll ( ) { try { Socket socket = new Socket ( host , port ) ; DataOutputStream dos = new DataOutputStream ( socket . getOutputStream ( ) ) ; DataInputStream dis = new DataInputStream ( socket . getInputStream ( ) ) ; dos . writeUTF ( ExternallyRolledFileAppender . ROLL_OVER ) ; String rc = dis . readUTF ( ) ; if ( ExternallyRolledFileAppender . OK . equals ( rc ) ) { cat . info ( "Roll over signal acknowledged by remote appender." ) ; } else { cat . warn ( "Unexpected return code " + rc + " from remote entity." ) ; System . exit ( 2 ) ; } } catch ( IOException e ) { cat . error ( "Could not send roll signal on host " + host + " port " + port + " ." , e ) ; System . exit ( 2 ) ; } System . exit ( 0 ) ; } } 	1	['7', '1', '0', '2', '32', '15', '0', '2', '1', '0.625', '168', '0', '1', '0', '0.277777778', '0', '0', '22.42857143', '2', '1.1429', '2']
package org . apache . log4j . helpers ; import java . io . File ; import java . io . Writer ; import java . io . FileWriter ; import java . io . FilterWriter ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	0	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '0']
package org . apache . log4j . lf5 . util ; import org . apache . log4j . lf5 . LogLevel ; import org . apache . log4j . lf5 . LogRecord ; import java . io . PrintWriter ; import java . io . StringWriter ; public class AdapterLogRecord extends LogRecord { private static LogLevel severeLevel = null ; private static StringWriter sw = new StringWriter ( ) ; private static PrintWriter pw = new PrintWriter ( sw ) ; public AdapterLogRecord ( ) { super ( ) ; } public void setCategory ( String category ) { super . setCategory ( category ) ; super . setLocation ( getLocationInfo ( category ) ) ; } public boolean isSevereLevel ( ) { if ( severeLevel == null ) return false ; return severeLevel . equals ( getLevel ( ) ) ; } public static void setSevereLevel ( LogLevel level ) { severeLevel = level ; } public static LogLevel getSevereLevel ( ) { return severeLevel ; } protected String getLocationInfo ( String category ) { String stackTrace = stackTraceToString ( new Throwable ( ) ) ; String line = parseLine ( stackTrace , category ) ; return line ; } protected String stackTraceToString ( Throwable t ) { String s = null ; synchronized ( sw ) { t . printStackTrace ( pw ) ; s = sw . toString ( ) ; sw . getBuffer ( ) . setLength ( 0 ) ; } return s ; } protected String parseLine ( String trace , String category ) { int index = trace . indexOf ( category ) ; if ( index == - 1 ) return null ; trace = trace . substring ( index ) ; trace = trace . substring ( 0 , trace . indexOf ( ")" ) + 1 ) ; return trace ; } } 	1	['9', '2', '0', '3', '24', '22', '1', '2', '5', '0.708333333', '113', '1', '1', '0.787878788', '0.34375', '2', '3', '11.22222222', '2', '1', '2']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . net ; import org . apache . log4j . AppenderSkeleton ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Layout ; import org . apache . log4j . helpers . SyslogWriter ; import org . apache . log4j . helpers . SyslogQuietWriter ; public class SyslogAppender extends AppenderSkeleton { final static public int LOG_KERN = 0 ; final static public int LOG_USER = 1 << 3 ; final static public int LOG_MAIL = 2 << 3 ; final static public int LOG_DAEMON = 3 << 3 ; final static public int LOG_AUTH = 4 << 3 ; final static public int LOG_SYSLOG = 5 << 3 ; final static public int LOG_LPR = 6 << 3 ; final static public int LOG_NEWS = 7 << 3 ; final static public int LOG_UUCP = 8 << 3 ; final static public int LOG_CRON = 9 << 3 ; final static public int LOG_AUTHPRIV = 10 << 3 ; final static public int LOG_FTP = 11 << 3 ; final static public int LOG_LOCAL0 = 16 << 3 ; final static public int LOG_LOCAL1 = 17 << 3 ; final static public int LOG_LOCAL2 = 18 << 3 ; final static public int LOG_LOCAL3 = 19 << 3 ; final static public int LOG_LOCAL4 = 20 << 3 ; final static public int LOG_LOCAL5 = 21 << 3 ; final static public int LOG_LOCAL6 = 22 << 3 ; final static public int LOG_LOCAL7 = 23 << 3 ; protected static final int SYSLOG_HOST_OI = 0 ; protected static final int FACILITY_OI = 1 ; static final String TAB = "    " ; int syslogFacility = LOG_USER ; String facilityStr ; boolean facilityPrinting = false ; SyslogQuietWriter sqw ; String syslogHost ; public SyslogAppender ( ) { this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , int syslogFacility ) { this . layout = layout ; this . syslogFacility = syslogFacility ; this . initSyslogFacilityStr ( ) ; } public SyslogAppender ( Layout layout , String syslogHost , int syslogFacility ) { this ( layout , syslogFacility ) ; setSyslogHost ( syslogHost ) ; } synchronized public void close ( ) { closed = true ; sqw = null ; } private void initSyslogFacilityStr ( ) { facilityStr = getFacilityString ( this . syslogFacility ) ; if ( facilityStr == null ) { System . err . println ( "\"" + syslogFacility + "\" is an unknown syslog facility. Defaulting to \"USER\"." ) ; this . syslogFacility = LOG_USER ; facilityStr = "user:" ; } else { facilityStr += ":" ; } } public static String getFacilityString ( int syslogFacility ) { switch ( syslogFacility ) { case LOG_KERN : return "kern" ; case LOG_USER : return "user" ; case LOG_MAIL : return "mail" ; case LOG_DAEMON : return "daemon" ; case LOG_AUTH : return "auth" ; case LOG_SYSLOG : return "syslog" ; case LOG_LPR : return "lpr" ; case LOG_NEWS : return "news" ; case LOG_UUCP : return "uucp" ; case LOG_CRON : return "cron" ; case LOG_AUTHPRIV : return "authpriv" ; case LOG_FTP : return "ftp" ; case LOG_LOCAL0 : return "local0" ; case LOG_LOCAL1 : return "local1" ; case LOG_LOCAL2 : return "local2" ; case LOG_LOCAL3 : return "local3" ; case LOG_LOCAL4 : return "local4" ; case LOG_LOCAL5 : return "local5" ; case LOG_LOCAL6 : return "local6" ; case LOG_LOCAL7 : return "local7" ; default : return null ; } } public static int getFacility ( String facilityName ) { if ( facilityName != null ) { facilityName = facilityName . trim ( ) ; } if ( "KERN" . equalsIgnoreCase ( facilityName ) ) { return LOG_KERN ; } else if ( "USER" . equalsIgnoreCase ( facilityName ) ) { return LOG_USER ; } else if ( "MAIL" . equalsIgnoreCase ( facilityName ) ) { return LOG_MAIL ; } else if ( "DAEMON" . equalsIgnoreCase ( facilityName ) ) { return LOG_DAEMON ; } else if ( "AUTH" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTH ; } else if ( "SYSLOG" . equalsIgnoreCase ( facilityName ) ) { return LOG_SYSLOG ; } else if ( "LPR" . equalsIgnoreCase ( facilityName ) ) { return LOG_LPR ; } else if ( "NEWS" . equalsIgnoreCase ( facilityName ) ) { return LOG_NEWS ; } else if ( "UUCP" . equalsIgnoreCase ( facilityName ) ) { return LOG_UUCP ; } else if ( "CRON" . equalsIgnoreCase ( facilityName ) ) { return LOG_CRON ; } else if ( "AUTHPRIV" . equalsIgnoreCase ( facilityName ) ) { return LOG_AUTHPRIV ; } else if ( "FTP" . equalsIgnoreCase ( facilityName ) ) { return LOG_FTP ; } else if ( "LOCAL0" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL0 ; } else if ( "LOCAL1" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL1 ; } else if ( "LOCAL2" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL2 ; } else if ( "LOCAL3" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL3 ; } else if ( "LOCAL4" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL4 ; } else if ( "LOCAL5" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL5 ; } else if ( "LOCAL6" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL6 ; } else if ( "LOCAL7" . equalsIgnoreCase ( facilityName ) ) { return LOG_LOCAL7 ; } else { return - 1 ; } } public void append ( LoggingEvent event ) { if ( ! isAsSevereAsThreshold ( event . level ) ) return ; if ( sqw == null ) { errorHandler . error ( "No syslog host is set for SyslogAppedender named \"" + this . name + "\"." ) ; return ; } String buffer = ( facilityPrinting ? facilityStr : "" ) + layout . format ( event ) ; sqw . setLevel ( event . level . getSyslogEquivalent ( ) ) ; sqw . write ( buffer ) ; String [ ] s = event . getThrowableStrRep ( ) ; if ( s != null ) { int len = s . length ; if ( len > 0 ) { sqw . write ( s [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { sqw . write ( TAB + s [ i ] . substring ( 1 ) ) ; } } } } public void activateOptions ( ) { } public boolean requiresLayout ( ) { return true ; } public void setSyslogHost ( String syslogHost ) { this . sqw = new SyslogQuietWriter ( new SyslogWriter ( syslogHost ) , syslogFacility , errorHandler ) ; this . syslogHost = syslogHost ; } public String getSyslogHost ( ) { return syslogHost ; } public void setFacility ( String facilityName ) { if ( facilityName == null ) return ; syslogFacility = getFacility ( facilityName ) ; if ( syslogFacility == - 1 ) { System . err . println ( "[" + facilityName + "] is an unknown syslog facility. Defaulting to [USER]." ) ; syslogFacility = LOG_USER ; } this . initSyslogFacilityStr ( ) ; if ( sqw != null ) { sqw . setSyslogFacility ( this . syslogFacility ) ; } } public String getFacility ( ) { return getFacilityString ( syslogFacility ) ; } public void setFacilityPrinting ( boolean on ) { facilityPrinting = on ; } public boolean getFacilityPrinting ( ) { return facilityPrinting ; } } 	1	['16', '2', '0', '7', '35', '58', '0', '7', '15', '1.002380952', '460', '0.071428571', '1', '0.580645161', '0.260416667', '1', '3', '26', '22', '4.0625', '10']
package org . apache . log4j . spi ; public interface TriggeringEventEvaluator { public boolean isTriggeringEvent ( LoggingEvent event ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . log4j ; import org . apache . log4j . spi . LoggingEvent ; public class SimpleLayout extends Layout { StringBuffer sbuf = new StringBuffer ( 128 ) ; public SimpleLayout ( ) { } public void activateOptions ( ) { } public String format ( LoggingEvent event ) { sbuf . setLength ( 0 ) ; sbuf . append ( event . level . toString ( ) ) ; sbuf . append ( " - " ) ; sbuf . append ( event . getRenderedMessage ( ) ) ; sbuf . append ( LINE_SEP ) ; return sbuf . toString ( ) ; } public boolean ignoresThrowable ( ) { return true ; } } 	1	['4', '2', '0', '5', '11', '4', '2', '3', '4', '0.666666667', '48', '0', '0', '0.727272727', '0.625', '0', '0', '10.75', '1', '0.75', '2']
package org . apache . log4j . config ; public class PropertySetterException extends Exception { protected Throwable rootCause ; public PropertySetterException ( String msg ) { super ( msg ) ; } public PropertySetterException ( Throwable rootCause ) { super ( ) ; this . rootCause = rootCause ; } public String getMessage ( ) { String msg = super . getMessage ( ) ; if ( msg == null && rootCause != null ) { msg = rootCause . getMessage ( ) ; } return msg ; } } 	0	['3', '3', '0', '1', '6', '1', '1', '0', '3', '0.5', '28', '1', '0', '0.944444444', '0.555555556', '1', '1', '8', '3', '1', '0']
package org . apache . log4j . or . sax ; import org . apache . log4j . or . ObjectRenderer ; import org . xml . sax . Attributes ; public class AttributesRenderer implements ObjectRenderer { public AttributesRenderer ( ) { } public String doRender ( Object o ) { if ( o instanceof Attributes ) { StringBuffer sbuf = new StringBuffer ( ) ; Attributes a = ( Attributes ) o ; int len = a . getLength ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { if ( first ) { first = false ; } else { sbuf . append ( ", " ) ; } sbuf . append ( a . getQName ( i ) ) ; sbuf . append ( '=' ) ; sbuf . append ( a . getValue ( i ) ) ; } return sbuf . toString ( ) ; } else { return o . toString ( ) ; } } } 	1	['2', '1', '0', '1', '11', '1', '0', '1', '2', '2', '58', '0', '0', '0', '0.75', '0', '0', '28', '4', '2', '2']
package org . apache . log4j . helpers ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public class NullEnumeration implements Enumeration { private static final NullEnumeration instance = new NullEnumeration ( ) ; private NullEnumeration ( ) { } public static NullEnumeration getInstance ( ) { return instance ; } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) { throw new NoSuchElementException ( ) ; } } 	0	['5', '1', '0', '1', '7', '8', '1', '0', '3', '0.75', '22', '1', '1', '0', '0.75', '0', '0', '3.2', '1', '0.6', '0']
package org . apache . log4j . lf5 ; public interface LogRecordFilter { public boolean passes ( LogRecord record ) ; } 	1	['1', '1', '0', '8', '1', '0', '7', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
package org . apache . log4j . test ; class Base64 { final static int MAX_LINE = 76 ; static byte [ ] asciiEncoding = { 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 43 , 47 } ; static char [ ] charEnc = new char [ 64 ] ; static { for ( int i = 0 ; i < 26 ; i ++ ) { charEnc [ i ] = ( char ) ( 'A' + i ) ; charEnc [ i + 26 ] = ( char ) ( 'a' + i ) ; } for ( int i = 0 ; i < 10 ; i ++ ) { charEnc [ i + 52 ] = ( char ) ( '0' + i ) ; } charEnc [ 62 ] = '+' ; charEnc [ 63 ] = '/' ; } static String toString ( byte [ ] inbuf ) { return toString ( inbuf , 0 , inbuf . length ) ; } static String toString ( byte [ ] inbuf , int offset , int length ) { StringBuffer output = new StringBuffer ( ( length ) * 4 / 3 + 1 ) ; int in ; char [ ] out = new char [ 4 ] ; int i = offset ; boolean ended = false ; int last = offset + length ; int j ; int bitsRead ; while ( ! ended ) { in = 0 ; bitsRead = 0 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( i == last ) { ended = true ; break ; } in = ( in << 8 ) | ( inbuf [ i ++ ] & 0xFF ) ; bitsRead += 8 ; } while ( bitsRead >= 6 ) { bitsRead -= 6 ; output . append ( charEnc [ ( in > > > bitsRead ) & 0x3F ] ) ; } if ( bitsRead == 4 ) { output . append ( charEnc [ ( in & 0x0F ) << 2 ] ) ; output . append ( "=" ) ; } else if ( bitsRead == 2 ) { output . append ( charEnc [ ( in & 0x03 ) << 4 ] ) ; output . append ( "==" ) ; } } return output . toString ( ) ; } public static void main ( String [ ] args ) { byte [ ] inbuf = new byte [ MAX_LINE ] ; while ( true ) { try { int read = System . in . read ( inbuf , 0 , MAX_LINE ) ; if ( read == - 1 ) break ; System . out . println ( "Read " + read + " chars." ) ; System . out . println ( Base64 . toString ( inbuf , 0 , read ) ) ; } catch ( Exception e ) { System . out . println ( "Exception " + e ) ; } } } } 	0	['5', '1', '0', '0', '15', '8', '0', '0', '1', '0.833333333', '479', '0', '0', '0', '0.3125', '0', '0', '94.2', '7', '2', '0']
package org . apache . log4j . helpers ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . LoggingEvent ; import org . apache . log4j . Logger ; import org . apache . log4j . Appender ; public class OnlyOnceErrorHandler implements ErrorHandler { final String WARN_PREFIX = "log4j warning: " ; final String ERROR_PREFIX = "log4j error: " ; boolean firstTime = true ; public void setLogger ( Logger logger ) { } public void activateOptions ( ) { } public void error ( String message , Exception e , int errorCode ) { error ( message , e , errorCode , null ) ; } public void error ( String message , Exception e , int errorCode , LoggingEvent event ) { if ( firstTime ) { LogLog . error ( message , e ) ; firstTime = false ; } } public void error ( String message ) { if ( firstTime ) { LogLog . error ( message ) ; firstTime = false ; } } public void setAppender ( Appender appender ) { } public void setBackupAppender ( Appender appender ) { } } 	1	['8', '1', '0', '6', '11', '22', '1', '5', '8', '0.857142857', '53', '0', '0', '0', '0.339285714', '0', '0', '5.25', '2', '1.125', '2']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . SimpleLayout ; import org . apache . log4j . ConsoleAppender ; import org . apache . log4j . Level ; public class NotLogging { static int runLength ; final static int INITIAL_HASH_SIZE = 101 ; static String SHORT_MSG = "Hello World" ; static Category SHORT_CAT = Category . getInstance ( "A0123456789" ) ; static Category MEDIUM_CAT = Category . getInstance ( "A0123456789.B0123456789" ) ; static Category LONG_CAT = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static Category INEXISTENT_SHORT_CAT = Category . getInstance ( "I0123456789" ) ; static Category INEXISTENT_MEDIUM_CAT = Category . getInstance ( "I0123456789.B0123456789" ) ; static Category INEXISTENT_LONG_CAT = Category . getInstance ( "I0123456789.B0123456789.C0123456789" ) ; static Category [ ] CAT_ARRAY = new Category [ ] { SHORT_CAT , MEDIUM_CAT , LONG_CAT , INEXISTENT_SHORT_CAT , INEXISTENT_MEDIUM_CAT , INEXISTENT_LONG_CAT } ; static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.NotLogging true|false runLength\n" + "true indicates shipped code, false indicates code in development" + "  where runLength is an int representing the run length of loops\n" + "We suggest that runLength be at least 100'000." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length != 2 ) { Usage ( ) ; } ProgramInit ( argv ) ; double delta ; System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = SimpleMessage ( CAT_ARRAY [ i ] , SHORT_MSG , runLength ) ; System . out . println ( "Simple argument,          " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = FullyOptimizedComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Fully optimized complex,  " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < CAT_ARRAY . length ; i ++ ) { delta = ComplexMessage ( CAT_ARRAY [ i ] , runLength ) ; System . out . println ( "Complex message argument, " + delta + " micros. Cat: " + CAT_ARRAY [ i ] . getName ( ) ) ; } } static void ProgramInit ( String [ ] args ) { try { runLength = Integer . parseInt ( args [ 1 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } ConsoleAppender appender = new ConsoleAppender ( new SimpleLayout ( ) ) ; if ( "false" . equals ( args [ 0 ] ) ) { } else if ( "true" . equals ( args [ 0 ] ) ) { System . out . println ( "Flagging as shipped code." ) ; Category . getDefaultHierarchy ( ) . setThreshold ( ( Level ) Level . WARN ) ; } else Usage ( ) ; SHORT_CAT . setLevel ( ( Level ) Level . INFO ) ; Category . getRoot ( ) . setLevel ( ( Level ) Level . INFO ) ; } static double SimpleMessage ( Category category , String msg , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( msg ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double FullyOptimizedComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { if ( category . isDebugEnabled ( ) ) category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } static double ComplexMessage ( Category category , long runLength ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . debug ( "Message" + i + " bottles of beer standing on the wall." ) ; } return ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ; } } 	0	['8', '1', '0', '6', '31', '22', '0', '6', '2', '0.942857143', '325', '0', '7', '0', '0.285714286', '0', '0', '38.375', '5', '2', '0']
package org . apache . log4j ; import org . apache . log4j . helpers . DateLayout ; import org . apache . log4j . spi . LoggingEvent ; public class TTCCLayout extends DateLayout { private boolean threadPrinting = true ; private boolean categoryPrefixing = true ; private boolean contextPrinting = true ; protected final StringBuffer buf = new StringBuffer ( 256 ) ; public TTCCLayout ( ) { this . setDateFormat ( RELATIVE_TIME_DATE_FORMAT , null ) ; } public TTCCLayout ( String dateFormatType ) { this . setDateFormat ( dateFormatType ) ; } public void setThreadPrinting ( boolean threadPrinting ) { this . threadPrinting = threadPrinting ; } public boolean getThreadPrinting ( ) { return threadPrinting ; } public void setCategoryPrefixing ( boolean categoryPrefixing ) { this . categoryPrefixing = categoryPrefixing ; } public boolean getCategoryPrefixing ( ) { return categoryPrefixing ; } public void setContextPrinting ( boolean contextPrinting ) { this . contextPrinting = contextPrinting ; } public boolean getContextPrinting ( ) { return contextPrinting ; } public String format ( LoggingEvent event ) { buf . setLength ( 0 ) ; dateFormat ( buf , event ) ; if ( this . threadPrinting ) { buf . append ( '[' ) ; buf . append ( event . getThreadName ( ) ) ; buf . append ( "] " ) ; } buf . append ( event . level . toString ( ) ) ; buf . append ( ' ' ) ; if ( this . categoryPrefixing ) { buf . append ( event . categoryName ) ; buf . append ( ' ' ) ; } if ( this . contextPrinting ) { String ndc = event . getNDC ( ) ; if ( ndc != null ) { buf . append ( ndc ) ; buf . append ( ' ' ) ; } } buf . append ( "- " ) ; buf . append ( event . getRenderedMessage ( ) ) ; buf . append ( LINE_SEP ) ; return buf . toString ( ) ; } public boolean ignoresThrowable ( ) { return true ; } } 	1	['10', '3', '0', '5', '23', '0', '1', '4', '10', '0.611111111', '172', '1', '0', '0.652173913', '0.375', '1', '1', '15.8', '5', '1.2', '2']
package org . apache . log4j . performance ; import java . util . Date ; public class ConcatVsArray { static void Usage ( ) { System . err . println ( "Usage: java org.apache.log4j.performance.ConcatVsArray " + "string1 string2 runLength\n" + "       where runLength is an integer." ) ; System . exit ( 1 ) ; } public static void main ( String args [ ] ) { if ( args . length != 3 ) { Usage ( ) ; } String s1 = args [ 0 ] ; String s2 = args [ 1 ] ; int runLength = 0 ; try { runLength = Integer . parseInt ( args [ 2 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; Usage ( ) ; } double micros ; String [ ] sa ; long before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { sa = new String [ ] { s1 , s2 } ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The anonymous array loop took around " + micros + " microseconds." ) ; String s ; before = new Date ( ) . getTime ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { s = s1 + s2 ; } micros = ( new Date ( ) . getTime ( ) - before ) * 1000.0 / runLength ; System . out . println ( "The append loop took around " + micros + " microseconds." ) ; } } 	0	['3', '1', '0', '0', '14', '3', '0', '0', '2', '2', '133', '0', '0', '0', '0.333333333', '0', '0', '43.33333333', '4', '1.6667', '0']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; public class Hello { static Category cat = Category . getInstance ( Hello . class ) ; public static void main ( String argv [ ] ) { BasicConfigurator . configure ( ) ; cat . debug ( "Hello world." ) ; cat . info ( "What a beatiful day." ) ; } } 	1	['4', '1', '0', '2', '12', '4', '0', '2', '2', '0.833333333', '38', '0', '1', '0', '0.333333333', '0', '0', '8', '1', '0.5', '1']
package org . apache . log4j . lf5 . util ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; public class ProductProperties { protected Properties _productProperties ; private static ProductProperties _reference = null ; private static Object _synchronizingObject = new Object ( ) ; private ProductProperties ( ) { this ( new Resource ( "org/apache/log4j/lf5/lf5.properties" ) ) ; } private ProductProperties ( Resource resource ) { super ( ) ; _productProperties = new Properties ( ) ; try { InputStream source = getSource ( resource ) ; byte [ ] contents = StreamUtils . getBytes ( source ) ; _productProperties = getProperties ( contents ) ; source . close ( ) ; validateProductProperties ( ) ; } catch ( Exception e ) { String error = e . getMessage ( ) ; throw new ExceptionInInitializerError ( error ) ; } } public static ProductProperties getInstance ( ) { if ( _reference == null ) { synchronized ( _synchronizingObject ) { if ( _reference == null ) { _reference = new ProductProperties ( ) ; } } } return _reference ; } public static String getPropertyNameOfProductName ( ) { return "product.name" ; } public static String getPropertyNameOfProductVersionNumber ( ) { return "product.version.number" ; } public static String getPropertyNameOfProductReleaseDate ( ) { return "product.release.date" ; } public String getProductName ( ) { return _productProperties . getProperty ( getPropertyNameOfProductName ( ) ) ; } public void setProductName ( String productName ) { _productProperties . setProperty ( getPropertyNameOfProductName ( ) , productName ) ; } public String getProductVersionNumber ( ) { return _productProperties . getProperty ( getPropertyNameOfProductVersionNumber ( ) ) ; } public void setProductVersionNumber ( String productVersionNumber ) { _productProperties . setProperty ( getPropertyNameOfProductVersionNumber ( ) , productVersionNumber ) ; } public String getProductReleaseDate ( ) { return _productProperties . getProperty ( getPropertyNameOfProductReleaseDate ( ) ) ; } public void setProductReleaseDate ( String productReleaseDate ) { _productProperties . setProperty ( getPropertyNameOfProductReleaseDate ( ) , productReleaseDate ) ; } public String get ( String name ) { return _productProperties . getProperty ( name ) ; } public Object set ( String name , String value ) { return _productProperties . setProperty ( name , value ) ; } public String getLogFactor5 ( ) { return getString ( "lf5" ) ; } public String getString ( String propertyName ) { return String . valueOf ( get ( propertyName ) ) ; } protected void validateProductProperties ( ) throws Exception { String value = null ; value = getProductVersionNumber ( ) ; if ( ( value == null ) || value . equals ( "" ) ) { throw new Exception ( "Product version number is null." ) ; } value = getProductReleaseDate ( ) ; if ( ( value == null ) || value . equals ( "" ) ) { throw new Exception ( "Product release date is null." ) ; } } private InputStream getSource ( Resource resource ) { return new BufferedInputStream ( ResourceUtils . getResourceAsStream ( this , resource ) ) ; } private Properties getProperties ( byte [ ] contents ) throws IOException { ByteArrayInputStream source = new ByteArrayInputStream ( contents ) ; Properties result = new Properties ( ) ; result . load ( source ) ; source . close ( ) ; return result ; } } 	0	['20', '1', '0', '5', '37', '116', '2', '3', '14', '0.754385965', '209', '1', '1', '0', '0.315789474', '0', '0', '9.3', '3', '0.95', '0']
package org . apache . log4j ; public class BasicConfigurator { protected BasicConfigurator ( ) { } static public void configure ( ) { Logger root = Logger . getRootLogger ( ) ; root . addAppender ( new ConsoleAppender ( new PatternLayout ( PatternLayout . TTCC_CONVERSION_PATTERN ) ) ) ; } static public void configure ( Appender appender ) { Logger root = Logger . getRootLogger ( ) ; root . addAppender ( appender ) ; } public static void resetConfiguration ( ) { LogManager . resetConfiguration ( ) ; } } 	1	['4', '1', '0', '13', '10', '6', '6', '7', '3', '2', '27', '0', '0', '0', '0.25', '0', '0', '5.75', '1', '0.75', '2']
package org . apache . log4j . lf5 . viewer ; import org . apache . log4j . lf5 . util . ProductProperties ; import org . apache . log4j . lf5 . util . Resource ; import javax . swing . * ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . net . URL ; public class LogFactor5AboutDialog extends JDialog { public LogFactor5AboutDialog ( Frame owner ) { super ( owner , "About LogFactor5" , true ) ; ProductProperties props = ProductProperties . getInstance ( ) ; setTitle ( "About LogFactor5" ) ; JPanel imagePanel = new JPanel ( ) ; Resource aboutResource = new Resource ( "org/apache/log4j/lf5/viewer/images/" + "lf5_about.gif" ) ; URL aboutIconURL = aboutResource . getURL ( ) ; ImageIcon aboutIcon = null ; if ( aboutIconURL != null ) { aboutIcon = new ImageIcon ( aboutIconURL ) ; } JLabel imageLabel = new JLabel ( ) ; if ( aboutIcon != null ) { imageLabel . setIcon ( aboutIcon ) ; } imagePanel . add ( imageLabel ) ; JPanel textPanel = new JPanel ( ) ; textPanel . setLayout ( new GridLayout ( 3 , 1 ) ) ; int numberOfRows = 13 ; numberOfRows = 11 ; JPanel mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new GridLayout ( numberOfRows , 1 ) ) ; JLabel aboutLF5 = new JLabel ( "LogFactor5 v" + props . getProductVersionNumber ( ) , JLabel . CENTER ) ; aboutLF5 . setHorizontalAlignment ( SwingConstants . CENTER ) ; JLabel donate = new JLabel ( "Contributed by ThoughtWorks Inc." ) ; donate . setHorizontalAlignment ( SwingConstants . CENTER ) ; mainPanel . add ( aboutLF5 ) ; mainPanel . add ( Box . createVerticalStrut ( 10 ) ) ; mainPanel . add ( donate ) ; mainPanel . add ( Box . createVerticalStrut ( 10 ) ) ; JButton ok = new JButton ( "OK" ) ; JPanel southPanel = new JPanel ( ) ; southPanel . setLayout ( new FlowLayout ( ) ) ; southPanel . add ( ok ) ; ok . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } ) ; getContentPane ( ) . add ( imagePanel , BorderLayout . NORTH ) ; getContentPane ( ) . add ( mainPanel , BorderLayout . CENTER ) ; getContentPane ( ) . add ( southPanel , BorderLayout . SOUTH ) ; setSize ( 414 , 400 ) ; center ( ) ; } protected void center ( ) { Dimension screen = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; Dimension comp = getSize ( ) ; setLocation ( ( ( screen . width - comp . width ) / 2 ) , ( ( screen . height - comp . height ) / 2 ) ) ; } } 	0	['2', '6', '0', '4', '33', '1', '2', '3', '1', '2', '184', '0', '0', '0.998417722', '0.75', '0', '0', '91', '1', '0.5', '0']
package org . apache . log4j . helpers ; import java . io . Writer ; import java . io . IOException ; import org . apache . log4j . spi . ErrorHandler ; import org . apache . log4j . spi . ErrorCode ; public class CountingQuietWriter extends QuietWriter { protected long count ; public CountingQuietWriter ( Writer writer , ErrorHandler eh ) { super ( writer , eh ) ; } public void write ( String string ) { try { out . write ( string ) ; count += string . length ( ) ; } catch ( IOException e ) { errorHandler . error ( "Write failure." , e , ErrorCode . WRITE_FAILURE ) ; } } public long getCount ( ) { return count ; } public void setCount ( long count ) { this . count = count ; } } 	1	['4', '4', '0', '3', '8', '0', '1', '2', '4', '0.333333333', '38', '1', '0', '0.875', '0.4', '2', '2', '8.25', '1', '0.75', '2']
package org . apache . log4j . test ; import org . apache . log4j . Category ; import org . apache . log4j . BasicConfigurator ; import org . apache . log4j . NDC ; import java . util . Random ; import java . util . Stack ; public class StressNDC extends Thread { static Category root = Category . getRoot ( ) ; static Random random = new Random ( 101 ) ; static final int LOOP_LENGTH = 24 ; static final int PUSH_MISS = LOOP_LENGTH / 2 ; static final int POP_MISS = PUSH_MISS * 2 ; static final int BRANCHING_FACTOR = 4 + 1 ; static int maxThreads ; static int msgCounter = 0 ; static int threadCounter = 0 ; static double LOG_2 = Math . log ( 2 ) ; static Object lock = new Object ( ) ; public static void main ( String args [ ] ) { BasicConfigurator . configure ( ) ; if ( args . length != 1 ) { usage ( ) ; } try { maxThreads = Integer . parseInt ( args [ 0 ] ) ; } catch ( java . lang . NumberFormatException e ) { System . err . println ( e ) ; usage ( ) ; } root . debug ( "push(IP=127.0.0.1)" ) ; NDC . push ( "IP=127.0.0.1" ) ; while ( true ) { synchronized ( lock ) { createChildren ( randomInt ( BRANCHING_FACTOR ) + 1 ) ; try { root . debug ( "About to wait for notification." ) ; lock . wait ( ) ; root . debug ( "Got a notification." ) ; } catch ( InterruptedException e ) { root . warn ( "Unpextected InterruptedException received." , e ) ; } } } } static void usage ( ) { System . err . println ( "Usage: java org.apache.log4j.test.StressNDC " + "MAX_THREADS" ) ; System . exit ( 1 ) ; } Stack parentDC ; public StressNDC ( Stack parentDC ) { this . setName ( randomID ( ) ) ; this . parentDC = parentDC ; } public void run ( ) { NDC . inherit ( parentDC ) ; int loopLength = StressNDC . randomInt ( LOOP_LENGTH ) ; root . debug ( "In run loop.debug( loopLength = " + loopLength ) ; int createIndex = loopLength / 2 ; for ( int i = 0 ; i <= loopLength ; i ++ ) { if ( i == createIndex ) createChildren ( randomInt ( BRANCHING_FACTOR ) ) ; if ( randomInt ( PUSH_MISS ) == 0 ) { String id = randomID ( ) ; root . debug ( "push(" + id + ")" ) ; NDC . push ( id ) ; } root . debug ( "Message number " + StressNDC . msgCounter ++ ) ; if ( randomInt ( POP_MISS ) == 0 ) { root . debug ( "pop()" ) ; NDC . pop ( ) ; } } synchronized ( lock ) { StressNDC . threadCounter -- ; root . debug ( "Exiting run loop. " + threadCounter ) ; if ( StressNDC . threadCounter <= 0 ) { root . debug ( "Notifying [main] thread." ) ; lock . notify ( ) ; } } if ( ( loopLength % 2 ) == 0 ) { root . debug ( "Removing NDC for this thread." ) ; NDC . remove ( ) ; } } public static void createChildren ( int n ) { if ( n <= 0 ) return ; synchronized ( lock ) { n = maxThreadsConstained ( n ) ; root . debug ( "Creating " + n + " child StressNDC threads." ) ; for ( int i = 0 ; i < n ; i ++ ) { root . debug ( "New StressNDC, threadCounter = " + ( ++ threadCounter ) ) ; new StressNDC ( NDC . cloneStack ( ) ) . start ( ) ; } } } static public int maxThreadsConstained ( int a ) { int maxAllowed = StressNDC . maxThreads - StressNDC . threadCounter ; return a <= maxAllowed ? a : maxAllowed ; } public static int randomInt ( int n ) { int r = random . nextInt ( ) % n ; return r >= 0 ? r : - r ; } public static String randomID ( ) { return Integer . toString ( random . nextInt ( ) & 0xFFFFFF ) ; } } 	0	['9', '2', '0', '3', '36', '8', '0', '3', '7', '0.822916667', '311', '0', '1', '0.897058824', '0.21875', '0', '0', '32.22222222', '7', '2', '0']
package org . apache . log4j . lf5 . util ; import java . io . InputStream ; import java . net . URL ; public class ResourceUtils { public static InputStream getResourceAsStream ( Object object , Resource resource ) { ClassLoader loader = object . getClass ( ) . getClassLoader ( ) ; InputStream in = null ; if ( loader != null ) { in = loader . getResourceAsStream ( resource . getName ( ) ) ; } else { in = ClassLoader . getSystemResourceAsStream ( resource . getName ( ) ) ; } return in ; } public static URL getResourceAsURL ( Object object , Resource resource ) { ClassLoader loader = object . getClass ( ) . getClassLoader ( ) ; URL url = null ; if ( loader != null ) { url = loader . getResource ( resource . getName ( ) ) ; } else { url = ClassLoader . getSystemResource ( resource . getName ( ) ) ; } return ( url ) ; } } 	1	['3', '1', '0', '2', '11', '3', '2', '1', '3', '2', '46', '0', '0', '0', '0.555555556', '0', '0', '14.33333333', '2', '1.3333', '2']
package org . apache . log4j . performance ; import org . apache . log4j . Category ; import org . apache . log4j . xml . DOMConfigurator ; import org . apache . log4j . NDC ; import org . apache . log4j . performance . NOPWriter ; public class Logging { static int runLength ; static int delay = - 1 ; static int burstLen = 100 ; static int DELAY_MULT = 1000 / burstLen ; static Category cat = Category . getInstance ( "A0123456789.B0123456789.C0123456789" ) ; static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Logging . class . getName ( ) + " confFile runLength [delay] [burstLen]\n" + "        confFile is an XML configuration file and\n" + "        runLength (integer) is the length of test loop.\n" + "        delay is the time in millisecs to wait every bustLen log requests." ) ; System . exit ( 1 ) ; } public static void main ( String argv [ ] ) { if ( argv . length == 2 ) init ( argv [ 0 ] , argv [ 1 ] , null , null ) ; else if ( argv . length == 4 ) init ( argv [ 0 ] , argv [ 1 ] , argv [ 2 ] , argv [ 3 ] ) ; else Usage ( "Wrong number of arguments." ) ; NDC . push ( "some context" ) ; double delta ; String msg = "ABCDEGHIJKLMNOPQRSTUVWXYZabcdeghijklmnopqrstuvwxyz1234567890" ; if ( delay <= 0 ) delta = NoDelayLoop ( cat , msg ) ; else delta = DelayedLoop ( cat , msg ) ; System . out . print ( ( int ) delta ) ; Category . shutdown ( ) ; } static void init ( String configFile , String runLengthStr , String delayStr , String burstLenStr ) { try { runLength = Integer . parseInt ( runLengthStr ) ; if ( delayStr != null ) { delay = Integer . parseInt ( delayStr ) ; } if ( delayStr != null ) { burstLen = Integer . parseInt ( burstLenStr ) ; DELAY_MULT = 1000 / burstLen ; } } catch ( java . lang . NumberFormatException e ) { e . printStackTrace ( ) ; } DOMConfigurator . configure ( configFile ) ; } static double NoDelayLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; } return ( ( System . currentTimeMillis ( ) - before ) * 1000.0 ) / runLength ; } static double DelayedLoop ( Category category , String msg ) { long before = System . currentTimeMillis ( ) ; int j = 0 ; Thread currentThread = Thread . currentThread ( ) ; for ( int i = 0 ; i < runLength ; i ++ ) { category . info ( msg ) ; if ( j ++ == burstLen ) { j = 0 ; try { currentThread . sleep ( delay ) ; } catch ( Exception e ) { } } } double actualTime = ( ( System . currentTimeMillis ( ) - before ) * 1000.0 / runLength ) ; System . out . println ( "actual time: " + actualTime ) ; return ( actualTime - delay * DELAY_MULT ) ; } } 	0	['8', '1', '0', '3', '30', '12', '0', '3', '2', '0.666666667', '228', '0', '1', '0', '0.321428571', '0', '0', '26.75', '4', '1.75', '0']
package org . apache . log4j . test ; import org . apache . log4j . PropertyConfigurator ; import org . apache . log4j . Category ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Finalize { static Category CAT = Category . getInstance ( Finalize . class . getName ( ) ) ; public static void main ( String argv [ ] ) { if ( argv . length == 1 ) init ( argv [ 0 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + Finalize . class . getName ( ) + " configFile" ) ; System . exit ( 1 ) ; } static void init ( String configFile ) { PropertyConfigurator . configure ( configFile ) ; } static void test ( ) { int i = - 1 ; InputStreamReader in = new InputStreamReader ( System . in ) ; Category root = Category . getRoot ( ) ; System . out . println ( "Type 'q' to quit" ) ; int j = 0 ; while ( true ) { System . gc ( ) ; try { i = in . read ( ) ; } catch ( Exception e ) { return ; } System . gc ( ) ; System . out . println ( "Read [" + i + "]." ) ; if ( i == - 1 ) break ; else if ( i == 'q' ) break ; else root . debug ( "Hello " + ( ++ j ) ) ; } root . removeAllAppenders ( ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; delay ( 3000 ) ; System . gc ( ) ; } static void foo ( Category cat ) { Enumeration enum = cat . getAllAppenders ( ) ; while ( enum != null && enum . hasMoreElements ( ) ) { ( ( org . apache . log4j . Appender ) enum . nextElement ( ) ) . close ( ) ; } } static void delay ( int amount ) { try { Thread . currentThread ( ) . sleep ( amount ) ; } catch ( Exception e ) { } } } 	1	['9', '1', '0', '3', '34', '34', '0', '3', '2', '0.875', '167', '0', '1', '0', '0.175', '0', '0', '17.33333333', '3', '1.4444', '1']
package org . apache . log4j . test ; import org . apache . log4j . * ; import java . util . * ; import java . text . * ; public class L7D { static ResourceBundle [ ] bundles ; public static void main ( String args [ ] ) { if ( args . length == 3 ) init ( args [ 0 ] , args [ 1 ] , args [ 2 ] ) ; else Usage ( "Wrong number of arguments." ) ; test ( ) ; } static void Usage ( String msg ) { System . err . println ( msg ) ; System . err . println ( "Usage: java " + L7D . class . getName ( ) + "configFile ISO639LanguageCode ISO2166CountryCode" ) ; System . exit ( 1 ) ; } static void init ( String configFile , String lanCode , String countryCode ) { PropertyConfigurator . configure ( configFile ) ; bundles = new ResourceBundle [ 3 ] ; try { bundles [ 0 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "en" , "US" ) ) ; bundles [ 1 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "FR" ) ) ; bundles [ 2 ] = ResourceBundle . getBundle ( "L7D" , new Locale ( "fr" , "CH" ) ) ; } catch ( MissingResourceException e ) { e . printStackTrace ( ) ; } } static void test ( ) { Category root = Category . getRoot ( ) ; for ( int i = 0 ; i < bundles . length ; i ++ ) { root . setResourceBundle ( bundles [ i ] ) ; root . l7dlog ( Priority . DEBUG , "bogus1" , null ) ; root . l7dlog ( Priority . INFO , "test" , null ) ; root . l7dlog ( Priority . WARN , "hello_world" , null ) ; root . l7dlog ( Priority . DEBUG , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "bogusMsg" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . ERROR , "msg1" , new Object [ ] { new Integer ( i + 1 ) , "log4j" } , null ) ; root . l7dlog ( Priority . INFO , "bogus2" , null ) ; } } } 	0	['6', '1', '0', '3', '25', '13', '0', '3', '2', '0.7', '202', '0', '0', '0', '0.277777778', '0', '0', '32.33333333', '2', '1.3333', '0']
package org . apache . log4j . spi ; public interface RepositorySelector { public LoggerRepository getLoggerRepository ( ) ; } 	1	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '2']
