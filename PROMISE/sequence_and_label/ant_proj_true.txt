package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . Vector ; import java . io . File ; import java . io . IOException ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private boolean parallel = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple srcfile elements." , location ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } protected void checkConfiguration ( ) { super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 ) { throw new BuildException ( "no filesets specified" , location ) ; } } protected void runExec ( Execute exe ) throws BuildException { try { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { Vector v = new Vector ( ) ; FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; File base = fs . getDir ( project ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; if ( ! "dir" . equals ( type ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { v . addElement ( s [ j ] ) ; } } if ( ! "file" . equals ( type ) ) { String [ ] s = getDirs ( base , ds ) ; ; for ( int j = 0 ; j < s . length ; j ++ ) { v . addElement ( s [ j ] ) ; } } String [ ] s = new String [ v . size ( ) ] ; v . copyInto ( s ) ; int err = - 1 ; if ( parallel ) { String [ ] command = getCommandline ( s , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } else { for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } } } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File baseDir ) { String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length ] ; int index = orig . length ; if ( srcFilePos != null ) { index = srcFilePos . getPosition ( ) ; } System . arraycopy ( orig , 0 , result , 0 , index ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ index + i ] = ( new File ( baseDir , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } System . arraycopy ( orig , index , result , index + srcFiles . length , orig . length - index ) ; return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , baseDir ) ; } protected String [ ] getFiles ( File basedir , DirectoryScanner ds ) { return ds . getIncludedFiles ( ) ; } protected String [ ] getDirs ( File basedir , DirectoryScanner ds ) { return ds . getIncludedDirectories ( ) ; } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['11', '4', '2', '14', '42', '29', '2', '12', '5', '0.725', '395', '1', '1', '0.885057471', '0.232323232', '3', '4', '34.54545455', '3', '1.2727', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '9', '0', '0', '1', '1', '0', '58', '1', '1', '0.714285714', '0.666666667', '1', '1', '17.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; public class Cvs extends Task { private Commandline cmd = new Commandline ( ) ; private String cvsRoot ; private String pack ; private String command = "checkout" ; private boolean quiet = false ; private boolean noexec = false ; private File dest ; private File output ; private File error ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( "cvs" ) ; if ( cvsRoot != null ) { toExecute . createArgument ( ) . setValue ( "-d" ) ; toExecute . createArgument ( ) . setValue ( cvsRoot ) ; } if ( noexec ) { toExecute . createArgument ( ) . setValue ( "-n" ) ; } if ( quiet ) { toExecute . createArgument ( ) . setValue ( "-q" ) ; } toExecute . createArgument ( ) . setLine ( command ) ; toExecute . addArguments ( cmd . getCommandline ( ) ) ; if ( pack != null ) { toExecute . createArgument ( ) . setLine ( pack ) ; } ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { if ( output != null ) { try { outputstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } if ( error != null ) { try { errorstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) dest = project . getBaseDir ( ) ; exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } finally { if ( output != null ) { try { outputstream . close ( ) ; } catch ( IOException e ) { } } if ( error != null ) { try { errorstream . close ( ) ; } catch ( IOException e ) { } } } } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) root = null ; } this . cvsRoot = root ; } public void setDest ( File dest ) { this . dest = dest ; } public void setPackage ( String p ) { this . pack = p ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-r" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-D" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } } 	0	['12', '3', '0', '12', '37', '32', '0', '12', '12', '0.858585859', '310', '1', '1', '0.770833333', '0.458333333', '0', '0', '24.08333333', '3', '1.4167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , location ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , location ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , location ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { project . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '4', '21', '1', '0', '4', '6', '0.7', '136', '1', '0', '0.880952381', '0.416666667', '2', '2', '21', '1', '0.8333', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '0', '3', '15', '0', '2', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Move extends Copy { public Move ( ) { super ( ) ; forceOverwrite = true ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; try { log ( "Moving " + fromFile + " to " + toFile , verbosity ) ; project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; File f = new File ( fromFile ) ; if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Moved " + count + " empty directories to " + destDir . getAbsolutePath ( ) ) ; } } if ( filesets . size ( ) > 0 ) { Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; File dir = fs . getDir ( project ) ; if ( okToDelete ( dir ) ) { deleteDir ( dir ) ; } } } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return false ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) return false ; } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } } 	0	['4', '4', '0', '6', '32', '6', '0', '6', '1', '2', '325', '0', '0', '0.963855422', '0.75', '3', '5', '80.25', '11', '5.25', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public void skip ( int numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; for ( int num = numToSkip ; num > 0 ; ) { int numRead = this . read ( skipBuf , 0 , ( num > skipBuf . length ? skipBuf . length : num ) ) ; if ( numRead == - 1 ) { break ; } num -= numRead ; } } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . entrySize = 0 ; this . entryOffset = 0 ; this . currEntry = null ; throw new IOException ( "bad header in block " + this . buffer . getCurrentBlockNum ( ) + " record " + this . buffer . getCurrentRecordNum ( ) + ", " + "header magic is not 'ustar', but '" + headerBuf [ 257 ] + headerBuf [ 258 ] + headerBuf [ 259 ] + headerBuf [ 260 ] + headerBuf [ 261 ] + "', or (dec) " + ( ( int ) headerBuf [ 257 ] ) + ", " + ( ( int ) headerBuf [ 258 ] ) + ", " + ( ( int ) headerBuf [ 259 ] ) + ", " + ( ( int ) headerBuf [ 260 ] ) + ", " + ( ( int ) headerBuf [ 261 ] ) ) ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	0	['16', '3', '0', '3', '40', '84', '1', '2', '16', '0.658333333', '604', '1', '2', '0.580645161', '0.291666667', '2', '7', '36.25', '1', '0.8125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . PatternSet ; import java . util . * ; public class CompileTask extends Javac { protected Vector taskList = new Vector ( ) ; public Taskdef createTaskdef ( ) { Taskdef task = new Taskdef ( ) ; taskList . addElement ( task ) ; return task ; } public void init ( ) { log ( "!! CompileTask is deprecated. !!" ) ; log ( "Use <taskdef> elements nested into <target>s instead" ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; String source = task . getClassname ( ) . replace ( '.' , '/' ) + ".java" ; PatternSet . NameEntry include = super . createInclude ( ) ; include . setName ( "**/" + source ) ; } super . init ( ) ; super . execute ( ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; task . init ( ) ; } } public void execute ( ) { } } 	0	['4', '5', '0', '5', '21', '0', '0', '5', '4', '0.333333333', '87', '1', '0', '0.98089172', '1', '1', '1', '20.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['9', '3', '0', '9', '29', '0', '0', '9', '9', '0.583333333', '168', '1', '1', '0.822222222', '0.444444444', '0', '0', '17.33333333', '2', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; private static final int BUFFER_SIZE = 512 ; public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) dir = project . getBaseDir ( ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( project . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) throw new BuildException ( "Property 'ant.home' not found" , location ) ; String antRun = project . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , this ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , this ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , location ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = project . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } ; protected void logFlush ( ) { if ( fos != null ) fos . close ( ) ; } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; private Exec parent ; public StreamPumper ( InputStream is , int messageLevel , Exec parent ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; this . parent = parent ; } public void pumpStream ( ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '5', '41', '21', '1', '5', '7', '0.793650794', '360', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; public abstract String [ ] getValues ( ) ; public EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { if ( ! containsValue ( value ) ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . value = value ; } public final boolean containsValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return false ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return true ; } } return false ; } public final String getValue ( ) { return value ; } } 	0	['5', '1', '5', '12', '11', '8', '11', '1', '5', '0.75', '59', '1', '0', '0', '0.7', '0', '0', '10.6', '5', '1.6', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . apache . tools . ant . util . DOMElementWriter ; public class XmlLogger implements BuildListener { private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private Document doc ; private Element buildElement ; private Element targetElement ; private Element taskElement ; private long buildStartTime ; private long targetStartTime ; private long taskStartTime ; private Stack targetTimeStack = new Stack ( ) ; private Stack targetStack = new Stack ( ) ; private Stack taskTimeStack = new Stack ( ) ; private Stack taskStack = new Stack ( ) ; public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildStartTime = System . currentTimeMillis ( ) ; doc = builder . newDocument ( ) ; buildElement = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildStartTime ; buildElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; } try { String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } Writer out = new FileWriter ( outFilename ) ; out . write ( "<?xml:stylesheet type=\"text/xsl\" href=\"log.xsl\"?>\n\n" ) ; ( new DOMElementWriter ( ) ) . write ( buildElement , out , 0 , "\t" ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to close log file" , exc ) ; } buildElement = null ; } public void targetStarted ( BuildEvent event ) { if ( targetElement != null ) { targetTimeStack . push ( new Long ( targetStartTime ) ) ; targetStack . push ( targetElement ) ; } targetStartTime = System . currentTimeMillis ( ) ; targetElement = doc . createElement ( TARGET_TAG ) ; targetElement . setAttribute ( NAME_ATTR , event . getTarget ( ) . getName ( ) ) ; } public void targetFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - targetStartTime ; targetElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( taskElement == null ) { buildElement . appendChild ( targetElement ) ; } else { taskElement . appendChild ( targetElement ) ; } targetElement = null ; if ( ! targetStack . isEmpty ( ) ) { targetStartTime = ( ( Long ) targetTimeStack . pop ( ) ) . longValue ( ) ; targetElement = ( Element ) targetStack . pop ( ) ; } } public void taskStarted ( BuildEvent event ) { if ( taskElement != null ) { taskTimeStack . push ( new Long ( taskStartTime ) ) ; taskStack . push ( taskElement ) ; } taskStartTime = System . currentTimeMillis ( ) ; taskElement = doc . createElement ( TASK_TAG ) ; String name = event . getTask ( ) . getClass ( ) . getName ( ) ; int pos = name . lastIndexOf ( "." ) ; if ( pos != - 1 ) { name = name . substring ( pos + 1 ) ; } taskElement . setAttribute ( NAME_ATTR , name ) ; taskElement . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; } public void taskFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - taskStartTime ; taskElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; targetElement . appendChild ( taskElement ) ; taskElement = null ; if ( ! taskStack . isEmpty ( ) ) { taskStartTime = ( ( Long ) taskTimeStack . pop ( ) ) . longValue ( ) ; taskElement = ( Element ) taskStack . pop ( ) ; } } public void messageLogged ( BuildEvent event ) { Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createTextNode ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; if ( taskElement != null ) { taskElement . appendChild ( messageElement ) ; } else if ( targetElement != null ) { targetElement . appendChild ( messageElement ) ; } else { buildElement . appendChild ( messageElement ) ; } } } 	0	['10', '1', '0', '9', '49', '1', '0', '9', '8', '0.920634921', '382', '1', '0', '0', '0.833333333', '0', '0', '35.1', '4', '1.9', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . regexp . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaRegexpMatcher implements RegexpMatcher { protected RE reg = null ; private String pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = pattern ; reg = new RE ( pattern ) ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern ; } public boolean matches ( String argument ) { return reg . match ( argument ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < reg . getParenCount ( ) ; i ++ ) { v . addElement ( reg . getParen ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '4', '13', '0', '0', '4', '5', '0.5', '65', '1', '0', '0', '0.8', '0', '0', '11.6', '3', '1.2', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . * ; public interface BuildLogger extends BuildListener { public void setMessageOutputLevel ( int level ) ; public void setOutputPrintStream ( PrintStream output ) ; public void setEmacsMode ( boolean emacsMode ) ; public void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '3', '4', '6', '2', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public abstract class DataType { protected String description = null ; protected Reference ref = null ; protected boolean checked = true ; public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( p ) ; if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } checked = true ; } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one attribute" + " when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular reference." ) ; } } 	0	['9', '1', '4', '8', '15', '18', '5', '3', '5', '0.708333333', '98', '1', '1', '0', '0.288888889', '0', '0', '9.555555556', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . net . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , location ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , location ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } } FileOutputStream fos = new FileOutputStream ( dest ) ; InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( "Can't get " + source + " to " + dest , location ) ; } byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) System . out . print ( "." ) ; } if ( verbose ) System . out . println ( ) ; fos . close ( ) ; is . close ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) touchFile ( dest , remoteTimestamp ) ; } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( ioe , location ) ; } } protected boolean touchFile ( File file , long timemillis ) throws BuildException { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; touch . setFile ( file ) ; touch . setMillis ( timemillis ) ; touch . touch ( ) ; return true ; } else { return false ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { useTimestamp = v ; } } } 	0	['8', '3', '0', '6', '46', '10', '0', '6', '7', '0.771428571', '394', '1', '0', '0.840909091', '0.375', '1', '1', '47.625', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { public void setJavac ( Javac attributes ) ; public boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . IOException ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; public class LogOutputStream extends OutputStream { private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) processBuffer ( ) ; } else buffer . write ( cc ) ; skip = ( c == '\r' ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) processBuffer ( ) ; super . close ( ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['7', '2', '1', '8', '15', '1', '7', '1', '4', '0.583333333', '92', '1', '1', '0.454545455', '0.464285714', '1', '1', '11.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private final static int SLEEP = 5 ; private final static int SIZE = 128 ; private InputStream is ; private OutputStream os ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } } } 	0	['2', '1', '0', '1', '6', '0', '1', '0', '2', '1', '39', '1', '0', '0', '0.666666667', '0', '0', '16.5', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DirectoryScanner implements FileScanner { protected final static String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/%*%" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected boolean haveSlowResults = false ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } protected static boolean matchPath ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } protected static boolean match ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' && ch != strArr [ i ] ) { return false ; } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxStart ] ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxEnd ] ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void scan ( ) { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { dirsExcluded . addElement ( name ) ; } } else { dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { filesIncluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name ) ) { return true ; } } return false ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['23', '1', '1', '22', '51', '181', '20', '2', '14', '0.731404959', '1407', '1', '0', '0', '0.290909091', '0', '0', '59.69565217', '35', '5.8696', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors , warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) parseEmacsOutput ( reader ) ; else parseStandardOutput ( reader ) ; } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) continue ; if ( lower . indexOf ( "error" ) != - 1 ) setError ( true ) ; else if ( lower . indexOf ( "warning" ) != - 1 ) setError ( false ) ; else { if ( emacsMode ) setError ( true ) ; } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) errorFlag = true ; } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '21', '44', '1', '2', '5', '0.805194805', '147', '1', '1', '0', '0.261904762', '0', '0', '10.66666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; import java . text . * ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; project . setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; project . setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; project . setProperty ( "TODAY" , today . format ( d ) ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( project , d , location ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } public class CustomFormat { private String propertyName ; private String pattern ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { if ( unit . equalsIgnoreCase ( "millisecond" ) ) { field = Calendar . MILLISECOND ; } else if ( unit . equalsIgnoreCase ( "second" ) ) { field = Calendar . SECOND ; } else if ( unit . equalsIgnoreCase ( "minute" ) ) { field = Calendar . MINUTE ; } else if ( unit . equalsIgnoreCase ( "hour" ) ) { field = Calendar . HOUR_OF_DAY ; } else if ( unit . equalsIgnoreCase ( "day" ) ) { field = Calendar . DATE ; } else if ( unit . equalsIgnoreCase ( "week" ) ) { field = Calendar . WEEK_OF_YEAR ; } else if ( unit . equalsIgnoreCase ( "month" ) ) { field = Calendar . MONTH ; } else if ( unit . equalsIgnoreCase ( "year" ) ) { field = Calendar . YEAR ; } else { throw new BuildException ( unit + " is not a unit supported by the tstamp task" ) ; } } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } project . setProperty ( propertyName , sdf . format ( date ) ) ; } } } 	0	['3', '3', '0', '5', '17', '0', '1', '5', '3', '0', '91', '1', '0', '0.948717949', '1', '0', '0', '29', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '2', '5', '6', '1', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class CompilerAdapterFactory { private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { return new Javac12 ( ) ; } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) ) { try { Class . forName ( "com.sun.tools.javac.Main" ) ; } catch ( ClassNotFoundException cnfe ) { task . log ( "Modern compiler is not available - using " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } return new Javac13 ( ) ; } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } return resolveClassName ( compilerType ) ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	0	['3', '1', '0', '8', '16', '3', '1', '7', '1', '2', '125', '0', '0', '0', '0.444444444', '0', '0', '40.66666667', '1', '0.6667', '0']
package org . apache . tools . ant ; interface Constants { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import java . io . * ; import java . util . Vector ; import java . util . zip . * ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { super . setZipfile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['9', '6', '0', '7', '33', '28', '0', '7', '6', '0.8125', '163', '1', '0', '0.950617284', '0.4', '4', '6', '16.88888889', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '7', '22', '0', '0', '7', '7', '0.625', '147', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.42857143', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; public class Available extends Task { private String property ; private String classname ; private File file ; private String resource ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; } public void setResource ( String resource ) { this . resource = resource ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , location ) ; } if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|resource) is required" , location ) ; } if ( classpath != null ) { this . loader = new AntClassLoader ( project , classpath , false ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } if ( ( file != null ) && ! checkFile ( file ) ) { log ( "Unable to find file " + file + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } this . project . setProperty ( property , value ) ; } private boolean checkFile ( File file ) { return file . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { l . loadClass ( classname ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { return false ; } catch ( NoClassDefFoundError e ) { return false ; } } } 	0	['13', '3', '0', '7', '35', '52', '0', '7', '10', '0.869047619', '273', '1', '2', '0.755102041', '0.353846154', '1', '1', '19.46153846', '6', '1.6923', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; public class Transform extends ExecuteOn { protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; protected boolean srcIsFirst = true ; public void setDest ( File destDir ) { this . destDir = destDir ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple targetfile elements." , location ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } protected void checkConfiguration ( ) { super . checkConfiguration ( ) ; if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , location ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , location ) ; } mapper = mapperElement . getImplementation ( ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } protected String [ ] getCommandline ( String [ ] srcFiles , File baseDir ) { if ( targetFilePos == null ) { return super . getCommandline ( srcFiles , baseDir ) ; } Vector targets = new Vector ( ) ; Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ srcIndex + i ] = ( new File ( baseDir , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , baseDir ) ; } } 	0	['9', '5', '0', '12', '36', '0', '0', '12', '4', '0.525', '375', '1', '3', '0.930434783', '0.4', '2', '4', '40.11111111', '11', '2.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . File ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( String src ) { this . src = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void setReplace ( String replace ) { this . replace = project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( replace && dest . exists ( ) ) { if ( ! dest . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + dest ) ; } } if ( ! src . renameTo ( dest ) ) { throw new BuildException ( "Unable to rename " + src + " to " + dest ) ; } } } 	0	['5', '3', '0', '4', '18', '0', '0', '4', '5', '0.666666667', '107', '1', '0', '0.902439024', '0.8', '1', '1', '19.8', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { String systemDefault = System . getProperty ( "ant.regexp.matcherimpl" ) ; if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['3', '1', '0', '3', '9', '3', '1', '2', '2', '2', '43', '0', '0', '0', '0.666666667', '0', '0', '13.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; Vector properties = new Vector ( ) ; Project p1 ; public void init ( ) { p1 = new Project ( ) ; p1 . setJavaVersionProperty ( ) ; p1 . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; for ( int i = 0 ; i < properties . size ( ) ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) p1 . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { Vector listeners = project . getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { p1 . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { try { PrintStream out = new PrintStream ( new FileOutputStream ( output ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; p1 . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; Class taskClass = ( Class ) taskdefs . get ( taskName ) ; p1 . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; p1 . addDataTypeDefinition ( typeName , typeClass ) ; } Hashtable prop1 = project . getProperties ( ) ; e = prop1 . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) prop1 . get ( arg ) ; p1 . setProperty ( arg , value ) ; } } public void execute ( ) throws BuildException { try { if ( p1 == null ) { reinit ( ) ; } if ( dir == null ) dir = project . getBaseDir ( ) ; initializeProject ( ) ; p1 . setBaseDir ( dir ) ; p1 . setUserProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . execute ( ) ; } if ( antFile == null ) antFile = "build.xml" ; File file = new File ( antFile ) ; if ( ! file . isAbsolute ( ) ) { antFile = ( new File ( dir , antFile ) ) . getAbsolutePath ( ) ; file = ( new File ( antFile ) ) ; if ( ! file . isFile ( ) ) { throw new BuildException ( "Build file " + file + " not found." ) ; } } p1 . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( p1 , new File ( antFile ) ) ; if ( target == null ) { target = p1 . getDefaultTarget ( ) ; } if ( p1 . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && p1 . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent target" ) ; } p1 . executeTarget ( target ) ; } finally { p1 = null ; } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( p1 == null ) { reinit ( ) ; } Property p = ( Property ) p1 . createTask ( "property" ) ; p . setUserProperty ( true ) ; properties . addElement ( p ) ; return p ; } } 	0	['10', '3', '0', '9', '70', '1', '1', '8', '8', '0.703703704', '440', '0.666666667', '1', '0.804347826', '0.466666667', '1', '1', '42.4', '6', '1.9', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; public class Path extends DataType implements Cloneable { private Vector elements ; private Project project ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { try { parts = new String [ ] { translateFile ( loc . getCanonicalPath ( ) ) } ; } catch ( IOException e ) { if ( project != null ) { project . log ( e . getMessage ( ) , Project . MSG_WARN ) ; } parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } } public void setPath ( String path ) { parts = Path . translatePath ( project , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { this . project = project ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( project ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) return ; String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( project != null ) { f = project . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , project ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( project ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { String [ ] parts = ( ( Path ) o ) . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( project ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String canonicalPath ; File f = new File ( dir , s [ j ] ) ; try { canonicalPath = f . getCanonicalPath ( ) ; } catch ( IOException e ) { canonicalPath = f . getAbsolutePath ( ) ; } addUnlessPresent ( result , translateFile ( canonicalPath ) ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) return new String [ 0 ] ; PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; element . append ( resolveFile ( project , tok . nextToken ( ) ) ) ; for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) return "" ; final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( project ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; try { return f . getCanonicalPath ( ) ; } catch ( IOException e ) { project . log ( e . getMessage ( ) , Project . MSG_WARN ) ; return f . getAbsolutePath ( ) ; } } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( project ) ; String order = project . getProperty ( "build.sysclasspath" ) ; if ( order == null ) order = defValue ; if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { project . log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } } 	0	['24', '3', '0', '27', '80', '182', '20', '8', '18', '0.565217391', '693', '0.666666667', '2', '0.588235294', '0.154150198', '2', '5', '27.75', '13', '2.2917', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public String [ ] getIncludedFiles ( ) { String [ ] result = new String [ 1 ] ; result [ 0 ] = srcFile . getAbsolutePath ( ) ; return result ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } } 	0	['6', '2', '0', '3', '11', '13', '2', '1', '6', '0.8', '68', '1', '0', '0.924242424', '0.444444444', '1', '5', '10.16666667', '3', '1.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class SignJar extends Task { protected String jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected String signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; public void setJar ( final String jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final String signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The signjar task is only available on JDK versions 1.2 or greater" ) ; } if ( null == jar ) { throw new BuildException ( "jar attribute must be set" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( ) ) return ; final StringBuffer sb = new StringBuffer ( ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "jarsigner" ) ; if ( null != keystore ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != signedjar ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( signedjar ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jar ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + ( new File ( jar ) ) . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( ) { if ( null != jar && null != signedjar ) { final File jarFile = new File ( jar ) ; final File signedjarFile = new File ( signedjar ) ; if ( ! jarFile . exists ( ) ) return false ; if ( ! signedjarFile . exists ( ) ) return false ; if ( jarFile . equals ( signedjarFile ) ) return false ; if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) return true ; } return false ; } } 	0	['14', '3', '0', '5', '35', '63', '0', '5', '13', '0.909090909', '307', '1', '0', '0.74', '0.595238095', '2', '3', '20.14285714', '7', '1.3571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import org . apache . tools . ant . * ; import java . util . Random ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '29', '0', '0', '5', '0', '0', '176', '1', '2', '0', '0.6', '0', '0', '85.5', '10', '5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jikes" ) ; if ( deprecation == true ) cmd . createArgument ( ) . setValue ( "-deprecation" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null && ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '23', '1', '1', '8', '2', '2', '204', '0', '0', '0.958333333', '1', '1', '1', '101', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public interface ExecuteStreamHandler { public void setProcessInputStream ( OutputStream os ) throws IOException ; public void setProcessErrorStream ( InputStream is ) throws IOException ; public void setProcessOutputStream ( InputStream is ) throws IOException ; public void start ( ) throws IOException ; public void stop ( ) ; } 	0	['5', '1', '0', '10', '5', '10', '10', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaOroMatcher implements RegexpMatcher { protected Perl5Matcher reg = new Perl5Matcher ( ) ; protected Perl5Compiler comp = new Perl5Compiler ( ) ; private Pattern pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = comp . compile ( pattern ) ; } catch ( MalformedPatternException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern . getPattern ( ) ; } public boolean matches ( String argument ) { return reg . contains ( argument , pattern ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = reg . getMatch ( ) ; for ( int i = 0 ; i < mr . groups ( ) ; i ++ ) { v . addElement ( mr . group ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '7', '17', '0', '0', '7', '5', '0.5', '75', '1', '0', '0', '0.8', '0', '0', '13.4', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public abstract class MatchingTask extends Task { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { Vector tmpExcludes = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } } 	0	['12', '3', '11', '18', '37', '0', '12', '6', '11', '0.454545455', '164', '1', '1', '0.770833333', '0.416666667', '0', '0', '12.5', '6', '1.5833', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; import java . io . * ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; PrintStream err = System . err ; PrintStream out = System . out ; try { PrintStream logstr = new PrintStream ( new LogOutputStream ( attributes , Project . MSG_WARN ) ) ; System . setOut ( logstr ) ; System . setErr ( logstr ) ; Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } finally { System . setErr ( err ) ; System . setOut ( out ) ; } } } 	0	['2', '2', '0', '8', '17', '1', '1', '7', '2', '2', '97', '1', '0', '0.958333333', '1', '0', '0', '47', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . InputStream ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } } 	0	['1', '2', '0', '9', '3', '0', '6', '3', '1', '2', '14', '0', '0', '1', '1', '0', '0', '13', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Delete extends MatchingTask { protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir attributes, or a fileset element, must be set." ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! file . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + file . getAbsolutePath ( ) ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( project ) , files , dirs ) ; } if ( usedMatchingTask && dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) list = new String [ 0 ] ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = 0 ; j < dirs . length ; j ++ ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! dir . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	0	['18', '4', '0', '8', '49', '19', '0', '8', '16', '0.773109244', '579', '1', '0', '0.821052632', '0.296296296', '2', '3', '30.77777778', '14', '2.1111', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Properties ; import java . util . zip . * ; import java . sql . * ; public class SQLExec extends Task { private int goodSql = 0 , totalSql = 0 ; private Path classpath ; private AntClassLoader loader ; private Connection conn = null ; private boolean autocommit = false ; private Statement statement = null ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String rdbms = null ; private String version = null ; private String onError = "abort" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setUserid ( String userId ) { this . userId = userId ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setRdbms ( String vendor ) { this . rdbms = vendor . toLowerCase ( ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( ) ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { sqlCommand = sqlCommand . trim ( ) ; if ( srcFile == null && sqlCommand . length ( ) == 0 ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file, transactions or sql statement must be set!" , location ) ; } } else { Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; } if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , location ) ; } if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , location ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , location ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , location ) ; } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = new AntClassLoader ( project , classpath , false ) ; dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , location ) ; } try { log ( "connecting to " + url , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , userId ) ; info . put ( "password" , password ) ; conn = driverInstance . connect ( url , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } if ( ! isValidRdbms ( conn ) ) return ; conn . setAutoCommit ( autocommit ) ; statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! autocommit ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; try { while ( ( line = in . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "//" ) ) continue ; if ( line . trim ( ) . startsWith ( "--" ) ) continue ; sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) sql += "\n" ; if ( sql . endsWith ( ";" ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - 1 ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } catch ( SQLException e ) { throw e ; } } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) return true ; try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) return ; try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } if ( print ) { printResults ( out ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) throw e ; log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; FileReader reader = new FileReader ( tSrcFile ) ; runStatements ( reader , out ) ; reader . close ( ) ; } } } } 	0	['23', '3', '0', '10', '96', '175', '1', '10', '19', '0.886363636', '1034', '1', '2', '0.627118644', '0.191304348', '3', '3', '43.08695652', '7', '1.3043', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import java . io . File ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; private Path src ; private File destDir ; private Path compileClasspath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; protected boolean failOnError = true ; protected File [ ] compileList = new File [ 0 ] ; public Path createSrc ( ) { if ( src == null ) { src = new Path ( project ) ; } return src . createPath ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , location ) ; } resetFileLists ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = ( File ) project . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , location ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } String compiler = project . getProperty ( "build.compiler" ) ; if ( compiler == null ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.3" ) ) { compiler = "modern" ; } else { compiler = "classic" ; } } if ( compileList . length > 0 ) { CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compiler , this ) ; log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , location ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String files [ ] ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } } 	0	['42', '4', '1', '19', '74', '741', '7', '13', '40', '0.948350072', '550', '1', '4', '0.655462185', '0.210884354', '3', '3', '11.69047619', '2', '1.2143', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; import java . util . Enumeration ; import java . util . Vector ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . toString ( ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '144', '1', '1', '0', '0.9', '0', '0', '27.2', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class Exit extends Task { private String message ; public void setMessage ( String value ) { this . message = value ; } public void execute ( ) throws BuildException { if ( message != null && message . length ( ) > 0 ) { throw new BuildException ( message ) ; } else { throw new BuildException ( "No message" ) ; } } } 	0	['3', '3', '0', '2', '6', '1', '0', '2', '3', '0.5', '29', '1', '0', '0.948717949', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { public void buildStarted ( BuildEvent event ) ; public void buildFinished ( BuildEvent event ) ; public void targetStarted ( BuildEvent event ) ; public void targetFinished ( BuildEvent event ) ; public void taskStarted ( BuildEvent event ) ; public void taskFinished ( BuildEvent event ) ; public void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '6', '7', '21', '5', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { public void setFrom ( String from ) ; public void setTo ( String to ) ; public String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '15', '3', '3', '15', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . * ; import java . util . Properties ; import java . util . Stack ; public class Mapper extends DataType { protected Project p ; protected MapperType type = null ; public Mapper ( Project p ) { this . p = p ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( p ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( p , classpath ) ; c = al . loadClass ( classname ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof Mapper ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['11', '3', '0', '11', '37', '11', '3', '8', '10', '0.683333333', '285', '1', '3', '0.75', '0.287878788', '1', '1', '24.36363636', '3', '1.9091', '0']
package org . apache . tools . ant ; public class Location { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { this . fileName = fileName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['5', '1', '0', '51', '10', '8', '51', '0', '3', '0.3125', '69', '0.75', '1', '0', '0.583333333', '0', '0', '12', '3', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GUnzip extends Task { private File source ; private File dest ; public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No source for gunzip specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "source doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( len > 3 && ".gz" . equalsIgnoreCase ( sourceName . substring ( len - 3 ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - 3 ) ) ; } else { dest = new File ( dest , sourceName ) ; } } if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; try { out = new FileOutputStream ( dest ) ; zIn = new GZIPInputStream ( new FileInputStream ( source ) ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['4', '3', '0', '4', '32', '2', '0', '4', '4', '0.666666667', '215', '1', '0', '0.925', '0.75', '1', '1', '52.25', '1', '0.75', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '7', '15', '13', '5', '3', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; class JavacOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private boolean errorFlag = false ; JavacOutputStream ( Task task ) { this . task = task ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; if ( s . indexOf ( "error" ) > - 1 ) { errorFlag = true ; } task . log ( s ) ; line = new StringBuffer ( ) ; } boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['4', '2', '0', '1', '11', '0', '0', '1', '1', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReferences ( ) . get ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '0', '16', '12', '4', '14', '2', '5', '0.25', '55', '1', '0', '0', '0.533333333', '0', '0', '9.8', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . tar . * ; import org . apache . tools . ant . types . * ; public class Tar extends MatchingTask { static public final String WARN = "warn" ; static public final String FAIL = "fail" ; static public final String TRUNCATE = "truncate" ; static public final String GNU = "gnu" ; static public final String OMIT = "omit" ; private String [ ] validModes = new String [ ] { WARN , FAIL , TRUNCATE , GNU , OMIT } ; File tarFile ; File baseDir ; String longFileMode = WARN ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { for ( int i = 0 ; i < validModes . length ; ++ i ) { if ( mode . equalsIgnoreCase ( validModes [ i ] ) ) { this . longFileMode = mode ; return ; } } throw new BuildException ( "The longfile value " + mode + " is not a valid value" ) ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; mainFileSet . setDefaultexcludes ( useDefaultExcludes ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basdir attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( new FileOutputStream ( tarFile ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . equalsIgnoreCase ( TRUNCATE ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . equalsIgnoreCase ( FAIL ) || longFileMode . equalsIgnoreCase ( OMIT ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( baseDir , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . equalsIgnoreCase ( OMIT ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . equalsIgnoreCase ( WARN ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed successfully" + " by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . equalsIgnoreCase ( FAIL ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setSize ( file . length ( ) ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; tOut . closeEntry ( ) ; } finally { fIn . close ( ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } static public class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; files = ds . getIncludedFiles ( ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } } } 	0	['8', '4', '0', '12', '65', '2', '0', '12', '6', '0.916666667', '583', '0.166666667', '0', '0.917647059', '0.333333333', '3', '3', '70.375', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . * ; public class XSLTProcess extends MatchingTask { private File destDir = null ; private File baseDir = null ; private File xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private XSLTLiaison liaison ; public XSLTProcess ( ) { } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; if ( liaison == null ) { try { setProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { setProcessor ( "xslp" ) ; } catch ( Throwable e2 ) { try { setProcessor ( "xalan" ) ; } catch ( Throwable e3 ) { throw new BuildException ( e1 ) ; } } } } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; long styleSheetLastModified = 0 ; if ( xslFile != null ) { try { File file = new File ( baseDir , xslFile . toString ( ) ) ; styleSheetLastModified = file . lastModified ( ) ; log ( "Loading stylesheet " + file , Project . MSG_INFO ) ; liaison . setStylesheet ( file . toString ( ) ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to read stylesheet " + xslFile , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , styleSheetLastModified ) ; return ; } list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , styleSheetLastModified ) ; } dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) process ( baseDir , list [ i ] , destDir , styleSheetLastModified ) ; } } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = new File ( xslFile ) ; } public void setProcessor ( String processor ) throws Exception { if ( processor . equals ( "trax" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( processor . equals ( "xslp" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( processor . equals ( "xalan" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) Class . forName ( processor ) . newInstance ( ) ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , long styleSheetLastModified ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { inFile = new File ( baseDir , xmlFile ) ; int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Transforming into " + destDir ) ; liaison . transform ( inFile . toString ( ) , outFile . toString ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , long styleSheetLastModified ) throws BuildException { try { log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; liaison . transform ( inFile . toString ( ) , outFile . toString ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) outFile . delete ( ) ; throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) throw new BuildException ( "Name attribute is missing." ) ; return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) throw new BuildException ( "Expression attribute is missing." ) ; return expression ; } } } 	0	['13', '4', '0', '7', '55', '30', '1', '7', '10', '0.802083333', '590', '1', '1', '0.866666667', '0.5', '2', '2', '43.76923077', '1', '0.9231', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + CopyDir instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; int length ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public void setSrc ( String s ) { this . source = project . resolveFile ( s ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '3', '40', '10', '0', '3', '8', '0.714285714', '271', '1', '0', '0.840909091', '0.40625', '1', '1', '32.375', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . * ; public class ExecuteJava { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private PrintStream out ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { this . out = out ; } public void execute ( Project project ) throws BuildException { PrintStream sOut = System . out ; PrintStream sErr = System . err ; final String classname = javaCommand . getExecutable ( ) ; final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } if ( out != null ) { System . setErr ( out ) ; System . setOut ( out ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { AntClassLoader loader = new AntClassLoader ( project , classpath , false ) ; loader . setIsolated ( true ) ; target = loader . forceLoadClass ( classname ) ; } final Method main = target . getMethod ( "main" , param ) ; main . invoke ( null , argument ) ; } catch ( NullPointerException e ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + ". Make sure you have it in your classpath" ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof SecurityException ) ) { throw new BuildException ( t ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } if ( out != null ) { System . setOut ( sOut ) ; System . setErr ( sErr ) ; out . close ( ) ; } } } } 	0	['6', '1', '0', '7', '26', '0', '1', '6', '6', '0.65', '185', '1', '3', '0', '0.305555556', '0', '0', '29.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { public void setPattern ( String pattern ) throws BuildException ; public String getPattern ( ) ; public boolean matches ( String argument ) ; public Vector getGroups ( String argument ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import java . io . * ; import java . util . zip . * ; public class Jar extends Zip { private File manifest ; private boolean manifestAdded ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; } public void setJarfile ( File jarFile ) { super . setZipfile ( jarFile ) ; } public void setManifest ( File manifestFile ) { manifest = manifestFile ; if ( ! manifest . exists ( ) ) throw new BuildException ( "Manifest file: " + manifest + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( manifest . getParent ( ) ) ) ; fs . setIncludes ( manifest . getName ( ) ) ; fs . setFullpath ( "META-INF/MANIFEST.MF" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( manifest == null ) { String s = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = this . getClass ( ) . getResourceAsStream ( s ) ; if ( in == null ) throw new BuildException ( "Could not find: " + s ) ; zipDir ( null , zOut , "META-INF/" ) ; zipFile ( in , zOut , "META-INF/MANIFEST.MF" , System . currentTimeMillis ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { if ( manifest == null || ! manifest . equals ( file ) || manifestAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/MANIFEST.MF which will be ignored " + "(please use manifest attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; manifestAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { manifestAdded = false ; super . cleanUp ( ) ; } } 	0	['6', '5', '1', '6', '33', '7', '1', '5', '3', '0.7', '164', '1', '0', '0.961538462', '0.5', '3', '6', '26', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; public void init ( ) { callee = ( Ant ) project . createTask ( "ant" ) ; callee . setOwningTarget ( target ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( location ) ; callee . init ( ) ; } public void execute ( ) { if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , location ) ; } callee . setDir ( project . getBaseDir ( ) ) ; callee . setAntfile ( project . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . execute ( ) ; } public Property createParam ( ) { return callee . createProperty ( ) ; } public void setTarget ( String target ) { subTarget = target ; } } 	0	['5', '3', '0', '7', '20', '2', '0', '7', '5', '0.625', '76', '1', '1', '0.902439024', '0.6', '2', '2', '13.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , location ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , location ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , location ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class ExecuteWatchdog implements Runnable { private Process process ; private int timeout ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; public ExecuteWatchdog ( int timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; final Thread thread = new Thread ( this , "WATCHDOG" ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } public synchronized void stop ( ) { watch = false ; notifyAll ( ) ; } public synchronized void run ( ) { try { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( watch && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } try { process . exitValue ( ) ; } catch ( IllegalThreadStateException e ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['8', '1', '0', '6', '25', '0', '5', '1', '7', '0.6', '169', '1', '0', '0', '0.416666667', '0', '0', '19.5', '7', '1.875', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . File ; import java . util . Vector ; public class SourceFileScanner { protected Task task ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; StringBuffer targetList = new StringBuffer ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String [ ] targets = mapper . mapFileName ( files [ i ] ) ; if ( targets == null || targets . length == 0 ) { task . log ( files [ i ] + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } File src = new File ( srcDir , files [ i ] ) ; if ( src . lastModified ( ) > now ) { task . log ( "Warning: " + files [ i ] + " modified in the future." , Project . MSG_WARN ) ; } boolean added = false ; targetList . setLength ( 0 ) ; for ( int j = 0 ; ! added && j < targets . length ; j ++ ) { File dest = null ; if ( destDir == null ) { dest = new File ( targets [ j ] ) ; } else { dest = new File ( destDir , targets [ j ] ) ; } if ( ! dest . exists ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else if ( src . lastModified ( ) > dest . lastModified ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " is outdated." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( dest . getAbsolutePath ( ) ) ; } } if ( ! added ) { task . log ( files [ i ] + " omitted as " + targetList . toString ( ) + ( targets . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } String [ ] result = new String [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } } 	0	['3', '1', '0', '9', '25', '1', '7', '2', '3', '0', '277', '1', '1', '0', '0.666666667', '0', '0', '91', '14', '5.3333', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( new File ( "." ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } } 	0	['9', '5', '0', '10', '20', '4', '3', '7', '9', '0.6875', '110', '1', '0', '0.919191919', '0.388888889', '2', '7', '10.77777778', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . * ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public void setPreserveLastModified ( String preserve ) { preserveLastModified = Project . toBoolean ( preserve ) ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to copy." ) ; } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , destDir , srcFiles , srcDirs ) ; } doFileOperations ( ) ; if ( destFile != null ) { destDir = null ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of destfile and destdir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of destfile or destdir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Cannot concatenate multple files into a single file." ) ; } if ( destFile != null ) { destDir = new File ( destFile . getParent ( ) ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; project . copyFile ( fromFile , toFile , filtering , forceOverwrite , preserveLastModified ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Copied " + count + " empty director" + ( count == 1 ? "y" : "ies" ) + " to " + destDir . getAbsolutePath ( ) ) ; } } } } 	0	['17', '3', '1', '12', '64', '52', '1', '11', '13', '0.793269231', '642', '1', '1', '0.698113208', '0.242647059', '1', '1', '36', '11', '2', '0']
package org . apache . tools . tar ; public interface TarConstants { public static final int NAMELEN = 100 ; public static final int MODELEN = 8 ; public static final int UIDLEN = 8 ; public static final int GIDLEN = 8 ; public static final int CHKSUMLEN = 8 ; public static final int SIZELEN = 12 ; public static final int MAGICLEN = 8 ; public static final int MODTIMELEN = 12 ; public static final int UNAMELEN = 32 ; public static final int GNAMELEN = 32 ; public static final int DEVLEN = 8 ; public static final byte LF_OLDNORM = 0 ; public static final byte LF_NORMAL = ( byte ) '0' ; public static final byte LF_LINK = ( byte ) '1' ; public static final byte LF_SYMLINK = ( byte ) '2' ; public static final byte LF_CHR = ( byte ) '3' ; public static final byte LF_BLK = ( byte ) '4' ; public static final byte LF_DIR = ( byte ) '5' ; public static final byte LF_FIFO = ( byte ) '6' ; public static final byte LF_CONTIG = ( byte ) '7' ; public static final String TMAGIC = "ustar" ; public static final String GNU_TMAGIC = "ustar  " ; public static final String GNU_LONGLINK = "././@LongLink" ; public static final byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . tar ; import java . io . * ; import java . util . * ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String Win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , Win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( Win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['31', '1', '0', '6', '65', '243', '4', '2', '30', '0.726666667', '747', '1', '0', '0', '0.182795699', '1', '1', '22.61290323', '4', '1.1613', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	0	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	0	['3', '1', '1', '5', '9', '0', '3', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarOutputStream extends FilterOutputStream { static public final int LONGFILE_ERROR = 0 ; static public final int LONGFILE_TRUNCATE = 1 ; static public final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant ; import java . io . * ; public interface FileScanner { public void addDefaultExcludes ( ) ; public File getBasedir ( ) ; public String [ ] getExcludedDirectories ( ) ; public String [ ] getExcludedFiles ( ) ; public String [ ] getIncludedDirectories ( ) ; public String [ ] getIncludedFiles ( ) ; public String [ ] getNotIncludedDirectories ( ) ; public String [ ] getNotIncludedFiles ( ) ; public void scan ( ) ; public void setBasedir ( String basedir ) ; public void setBasedir ( File basedir ) ; public void setExcludes ( String [ ] excludes ) ; public void setIncludes ( String [ ] includes ) ; } 	0	['13', '1', '0', '4', '13', '78', '4', '0', '13', '2', '13', '0', '0', '0', '0.326923077', '0', '0', '0', '1', '1', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] result = new byte [ length ] ; int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '274', '0', '0', '0', '0.45', '0', '0', '33.25', '7', '2.875', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GZip extends Task { private File zipFile ; private File source ; public void setZipfile ( String zipFilename ) { zipFile = project . resolveFile ( zipFilename ) ; } public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void execute ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , location ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } log ( "Building gzip: " + zipFile . getAbsolutePath ( ) ) ; GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; if ( source . isDirectory ( ) ) { log ( "Cannot Gzip a directory!" , Project . MSG_ERR ) ; } else { zipFile ( source , zOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } private void zipFile ( InputStream in , GZIPOutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } private void zipFile ( File file , GZIPOutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } } 	0	['6', '3', '0', '4', '25', '11', '0', '4', '4', '0.8', '157', '1', '0', '0.880952381', '0.4', '2', '2', '24.83333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Locale ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private static Method setLastModified = null ; private static Object lockReflection = new Object ( ) ; public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void execute ( ) throws BuildException { if ( file . exists ( ) && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe , location ) ; } } if ( millis >= 0 && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( file + " will be created but its modification time cannot be set in JDK 1.1" , Project . MSG_WARN ) ; } touch ( ) ; } void touch ( ) throws BuildException { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( new byte [ 0 ] ) ; fos . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , location ) ; } } if ( project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse , location ) ; } } } } Long [ ] times = new Long [ 1 ] ; if ( millis < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( millis ) ; } try { log ( "Setting modification time for " + file , Project . MSG_VERBOSE ) ; setLastModified . invoke ( file , times ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time of " + file , nested , location ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time of " + file , other , location ) ; } } } 	0	['8', '3', '0', '7', '32', '8', '3', '4', '5', '0.738095238', '300', '0.833333333', '0', '0.860465116', '0.357142857', '1', '1', '35.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jvc" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '19', '1', '1', '8', '2', '2', '120', '0', '0', '0.958333333', '1', '1', '1', '59', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; public class Taskdef extends Task { private String name ; private String value ; private Path classpath ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { if ( name == null || value == null ) { String msg = "name or classname attributes of taskdef element " + "are undefined" ; throw new BuildException ( msg ) ; } try { ClassLoader loader = null ; if ( classpath != null ) { AntClassLoader al = new AntClassLoader ( project , classpath , false ) ; al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; loader = al ; } else { loader = this . getClass ( ) . getClassLoader ( ) ; } Class taskClass = null ; if ( loader != null ) { taskClass = loader . loadClass ( value ) ; } else { taskClass = Class . forName ( value ) ; } project . addTaskDefinition ( name , taskClass ) ; } catch ( ClassNotFoundException cnfe ) { String msg = "taskdef class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "taskdef class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } } 	0	['8', '3', '0', '8', '25', '14', '1', '7', '8', '0.714285714', '157', '1', '1', '0.840909091', '0.375', '0', '0', '18.25', '2', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; public class ExecTask extends Task { private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Integer timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; public void setTimeout ( Integer value ) { timeout = value ; } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; if ( isValidOs ( ) ) { runExec ( prepareExec ( ) ) ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) dir = project . getBaseDir ( ) ; log ( cmdl . toString ( ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected void runExec ( Execute exe ) throws BuildException { int err = - 1 ; try { exe . setCommandline ( cmdl . getCommandline ( ) ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) return null ; return new ExecuteWatchdog ( timeout . intValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) fos . close ( ) ; } catch ( IOException io ) { } } } 	0	['19', '3', '1', '18', '56', '97', '5', '13', '12', '0.814814815', '406', '1', '2', '0.672727273', '0.190789474', '0', '0', '19.89473684', '3', '1.0526', '0']
package org . apache . tools . mail ; import java . io . * ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . charAt ( 3 ) == '-' ; } private void append ( String line ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } 	0	['5', '1', '0', '1', '18', '0', '1', '0', '3', '0.5', '96', '1', '0', '0', '0.533333333', '0', '0', '17.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private boolean fork = false ; private File dir = null ; private File out ; private boolean failOnError = false ; public void execute ( ) throws BuildException { int err = - 1 ; if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( fork ) { log ( "Forking " + cmdl . toString ( ) , Project . MSG_VERBOSE ) ; return run ( cmdl . getCommandline ( ) ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . getJavaCommand ( ) . toString ( ) , Project . MSG_VERBOSE ) ; run ( cmdl ) ; return 0 ; } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setClassname ( String s ) { cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { createJvmarg ( ) . setValue ( "-mx" + max ) ; } else { createJvmarg ( ) . setValue ( "-Xmx" + max ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; if ( out != null ) { try { exe . setOutput ( new PrintStream ( new FileOutputStream ( out ) ) ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } } exe . execute ( project ) ; } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; } else { fos = new FileOutputStream ( out ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , null ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } } 	0	['22', '3', '0', '17', '77', '95', '0', '17', '19', '0.742857143', '439', '1', '1', '0.637931034', '0.172727273', '1', '1', '18.72727273', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { Argument argument = new Argument ( ) ; arguments . addElement ( argument ) ; return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) return ; this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) return args ; final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } } 	0	['19', '1', '0', '23', '46', '65', '22', '3', '17', '0.416666667', '448', '1', '0', '0', '0.289473684', '0', '0', '22.47368421', '16', '2.4211', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class Expand extends MatchingTask { private File dest ; private File source ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; if ( source == null ) { throw new BuildException ( "Source attribute must be specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( source . isDirectory ( ) ) { DirectoryScanner ds = super . getDirectoryScanner ( source ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( source , files [ i ] ) ; expandFile ( touch , file , dest ) ; } } else { expandFile ( touch , source , dest ) ; } } private void expandFile ( Touch touch , File srcF , File dir ) { ZipInputStream zis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { File f = new File ( dir , project . translatePath ( ze . getName ( ) ) ) ; try { log ( "expand-file " + ze . getName ( ) , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( ze . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = zis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( ze . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } } 	0	['5', '4', '0', '8', '45', '6', '0', '8', '4', '0.75', '261', '1', '0', '0.951219512', '0.6', '4', '5', '50.8', '7', '2', '0']
package org . apache . tools . ant . util ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; private StringBuffer sb = new StringBuffer ( ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( ( ( Text ) child ) . getData ( ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; } public String encode ( String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '1', '35', '4', '1', '0', '4', '0.583333333', '354', '1', '0', '0', '0.5', '0', '0', '69.2', '8', '3.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . tar . * ; import java . io . * ; public class Untar extends Task { private String dest ; private String source ; public void execute ( ) throws BuildException { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; File srcF = project . resolveFile ( source ) ; TarInputStream tis = null ; try { if ( source == null ) { throw new BuildException ( "No source specified" , location ) ; } if ( ! srcF . exists ( ) ) { throw new BuildException ( "source " + srcF + " doesn't exist" , location ) ; } if ( dest == null ) { throw new BuildException ( "No destination specified" , location ) ; } File dir = project . resolveFile ( dest ) ; log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( new FileInputStream ( srcF ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { try { File f = new File ( dir , project . translatePath ( te . getName ( ) ) ) ; log ( "expand-file " + te . getName ( ) , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( te . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = tis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( te . getModTime ( ) . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "FileNotFoundException: " + te . getName ( ) , Project . MSG_WARN ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( String d ) { this . dest = d ; } public void setSrc ( String s ) { this . source = s ; } } 	0	['4', '3', '0', '8', '42', '2', '0', '8', '4', '0.666666667', '242', '1', '0', '0.925', '0.75', '2', '3', '59', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . io . * ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , location ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "ISO8859_1" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } Enumeration dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; printHead ( out , dataTypes ) ; Vector tasks = new Vector ( ) ; Enumeration enum = project . getTaskDefinitions ( ) . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String taskName = ( String ) enum . nextElement ( ) ; tasks . addElement ( taskName ) ; } printTargetDecl ( out , tasks ) ; dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) project . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { String taskName = ( String ) tasks . elementAt ( i ) ; printElementDecl ( out , taskName , ( Class ) project . getTaskDefinitions ( ) . get ( taskName ) ) ; } printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , location ) ; } finally { if ( out != null ) { out . close ( ) ; } } } private void printHead ( PrintWriter out , Enumeration enum ) { out . println ( "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | property | taskdef" ) ; while ( enum . hasMoreElements ( ) ) { String typeName = ( String ) enum . nextElement ( ) ; out . print ( " | " + typeName ) ; } out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #REQUIRED" ) ; out . println ( "          default CDATA #REQUIRED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out , Vector tasks ) { out . print ( "<!ELEMENT target (" ) ; for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { String taskName = ( String ) tasks . elementAt ( i ) ; if ( i > 0 ) { out . print ( " | " ) ; } out . print ( taskName ) ; } out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( element ) ; StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } Enumeration enum = ih . getNestedElements ( ) ; while ( enum . hasMoreElements ( ) ) { v . addElement ( ( String ) enum . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( v . size ( ) > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb . setLength ( 0 ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; enum = ih . getAttributes ( ) ; while ( enum . hasMoreElements ( ) ) { String attrName = ( String ) enum . nextElement ( ) ; if ( "id" . equals ( attrName ) ) continue ; sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( "%boolean; " ) ; } else if ( org . apache . tools . ant . types . Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } private void printTail ( PrintWriter out ) { } } 	0	['8', '3', '0', '6', '55', '24', '0', '6', '3', '0.80952381', '643', '0.5', '0', '0.840909091', '0.303571429', '0', '0', '78.625', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public interface XSLTLiaison { public void setStylesheet ( String fileName ) throws Exception ; public void addParam ( String name , String expression ) throws Exception ; public void transform ( String infile , String outfile ) throws Exception ; } 	0	['3', '1', '0', '1', '3', '3', '1', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	0	['11', '1', '1', '8', '17', '41', '6', '2', '8', '0.7', '93', '1', '0', '0', '0.666666667', '0', '0', '7.090909091', '1', '0.7273', '0']
package org . apache . tools . ant ; import java . util . * ; import java . io . * ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { tokenizer = new StringTokenizer ( path , ":;" , false ) ; dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } return token ; } } 	0	['3', '1', '0', '2', '15', '0', '2', '0', '3', '0.166666667', '100', '1', '0', '0', '0.666666667', '0', '0', '31.33333333', '2', '1', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; public class DesirableFilter implements FilenameFilter { public boolean accept ( File dir , String name ) { if ( name . endsWith ( "~" ) ) { return false ; } if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) { return false ; } if ( name . startsWith ( "%" ) && name . endsWith ( "%" ) ) { return false ; } if ( name . equals ( "CVS" ) ) { return false ; } if ( name . equals ( ".cvsignore" ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '0', '6', '1', '0', '0', '2', '2', '45', '0', '0', '0', '0.666666667', '0', '0', '21.5', '8', '4', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private String name ; private String path ; private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) return string ; final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "keytool -genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setCommand ( new Commandline ( sb . toString ( ) ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '6', '33', '65', '0', '6', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '2', '3', '27', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . FileInputStream ; import org . apache . tools . ant . * ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or only a filtersFile parameter is required" , location ) ; } if ( isSingleFilter ) { project . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Project proj = getProject ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String strPropName = ( String ) enum . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; proj . addFilter ( strPropName , strValue ) ; } } catch ( Exception e ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( java . io . IOException ioex ) { } } } } } 	0	['6', '3', '0', '4', '24', '5', '0', '4', '5', '0.733333333', '153', '1', '0', '0.880952381', '0.5', '0', '0', '24', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setDir ( new File ( src . getParent ( ) ) ) ; fs . createInclude ( ) . setName ( src . getName ( ) ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , location ) ; } if ( defaultSet . getDir ( project ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( taskType + " doesn\'t support the executable attribute" , location ) ; } public void setCommand ( String e ) { throw new BuildException ( taskType + " doesn\'t support the command attribute" , location ) ; } protected boolean isValidOs ( ) { return System . getProperty ( "path.separator" ) . equals ( ":" ) && ( ! System . getProperty ( "os.name" ) . startsWith ( "Mac" ) || System . getProperty ( "os.name" ) . endsWith ( "X" ) ) && super . isValidOs ( ) ; } } 	0	['14', '5', '0', '10', '43', '15', '0', '10', '12', '0.615384615', '168', '1', '1', '0.891666667', '0.392857143', '3', '5', '10.85714286', '5', '1.3571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; try { OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } } } 	0	['3', '2', '0', '8', '18', '3', '1', '7', '2', '1', '132', '0', '0', '0.92', '0.5', '0', '0', '42', '1', '0.6667', '0']
package org . apache . tools . ant ; public abstract class Task { protected Project project = null ; protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this ) ; } return wrapper ; } protected void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } } 	0	['19', '1', '34', '78', '23', '119', '75', '5', '16', '0.873015873', '125', '1', '4', '0', '0.218045113', '0', '0', '5.210526316', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . Enumeration ; import java . util . Date ; import java . util . Vector ; public class UpToDate extends MatchingTask { private String _property ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { if ( sourceFileSets . size ( ) == 0 ) { throw new BuildException ( "At least one <srcfiles> element must be set" ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested mapper element must be set" ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) return ; Enumeration enum = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; upToDate = upToDate && scanDir ( fs . getDir ( project ) , ds . getIncludedFiles ( ) ) ; } if ( upToDate ) { this . project . setProperty ( _property , "true" ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up to date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files have been up to date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String files [ ] ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , null , mapper ) . length == 0 ; } } 	0	['7', '4', '0', '11', '32', '0', '0', '11', '6', '0.666666667', '189', '1', '1', '0.928571429', '0.342857143', '1', '1', '25.42857143', '3', '1.1429', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; public class TaskAdapter extends Task { Object proxy ; public void execute ( ) throws BuildException { Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No execute in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No execute in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	0	['4', '3', '0', '6', '15', '0', '4', '2', '4', '0.333333333', '82', '0', '0', '0.925', '0.625', '1', '1', '19.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '6', '35', '4', '0', '6', '7', '0.714285714', '265', '1', '0', '0.917647059', '0.46875', '3', '3', '31.375', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public class DocletInfo { private String name ; private Path path ; private Vector params = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { project . log ( this , "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add11ArgIf ( boolean b , String arg ) { if ( javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean foundJavaFile = false ; private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private String sourceFiles = null ; private String packageNames = null ; private String excludePackageNames = null ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private Vector compileList = new Vector ( 10 ) ; private String packageList = null ; private Vector links = new Vector ( 2 ) ; private Vector groups = new Vector ( 2 ) ; private boolean useDefaultExcludes = true ; public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( project ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { sourceFiles = src ; } public void setPackagenames ( String src ) { packageNames = src ; } public void setExcludePackageNames ( String src ) { excludePackageNames = src ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setDoclet ( String src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setName ( src ) ; } public void setDocletPath ( Path src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setPath ( src ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void setOld ( boolean b ) { add12ArgIf ( b , "-1.1" ) ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-locale" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean src ) { version = src ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean src ) { author = src ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String src ) { add12ArgIfNotEmpty ( "-windowtitle" , src ) ; } public void setDoctitle ( String src ) { add12ArgIfNotEmpty ( "-doctitle" , src ) ; } public void setHeader ( String src ) { add12ArgIfNotEmpty ( "-header" , src ) ; } public void setFooter ( String src ) { add12ArgIfNotEmpty ( "-footer" , src ) ; } public void setBottom ( String src ) { add12ArgIfNotEmpty ( "-bottom" , src ) ; } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include a URL and " + "a package-list file location separated by a space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( tok . nextToken ( ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { packageList = src ; } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private String packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( String src ) { packagelistLoc = src ; } public String getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private String title ; private String packages ; public GroupArgument ( ) { } public void setTitle ( String src ) { title = src ; } public String getTitle ( ) { return title ; } public void setPackages ( String src ) { packages = src ; } public String getPackages ( ) { return packages ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( taskType ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } if ( sourcePath == null ) { String msg = "sourcePath attribute must be set!" ; throw new BuildException ( msg ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "javadoc" ) ; if ( classpath == null ) classpath = Path . systemClasspath ; else classpath = classpath . concatSystemClasspath ( "ignore" ) ; if ( ! javadoc1 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourcePath ) ; } else { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setValue ( sourcePath . toString ( ) + System . getProperty ( "path.separator" ) + classpath . toString ( ) ) ; } if ( version && doclet == null ) toExecute . createArgument ( ) . setValue ( "-version" ) ; if ( author && doclet == null ) toExecute . createArgument ( ) . setValue ( "-author" ) ; if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be specified." , location ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( doclet . getPath ( ) ) ; } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null ) { throw new BuildException ( "Links must provide the URL to the external class documentation." ) ; } if ( la . isLinkOffline ( ) ) { String packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list location for link " + la . getHref ( ) + " must be provided because the link is offline" ) ; } toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListLocation ) ; } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must be specified for group elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( title ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } } if ( ( packageNames != null ) && ( packageNames . length ( ) > 0 ) ) { Vector packages = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( packageNames , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String name = tok . nextToken ( ) . trim ( ) ; if ( name . endsWith ( ".*" ) ) { packages . addElement ( name ) ; } else { toExecute . createArgument ( ) . setValue ( name ) ; } } Vector excludePackages = new Vector ( ) ; if ( ( excludePackageNames != null ) && ( excludePackageNames . length ( ) > 0 ) ) { StringTokenizer exTok = new StringTokenizer ( excludePackageNames , "," , false ) ; while ( exTok . hasMoreTokens ( ) ) { excludePackages . addElement ( exTok . nextToken ( ) . trim ( ) ) ; } } if ( packages . size ( ) > 0 ) { evaluatePackages ( toExecute , sourcePath , packages , excludePackages ) ; } } if ( ( sourceFiles != null ) && ( sourceFiles . length ( ) > 0 ) ) { StringTokenizer tok = new StringTokenizer ( sourceFiles , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { toExecute . createArgument ( ) . setValue ( tok . nextToken ( ) . trim ( ) ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( "Javadoc args: " + toExecute , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , location ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , location ) ; } finally { out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void evaluatePackages ( Commandline toExecute , Path sourcePath , Vector packages , Vector excludePackages ) { log ( "Source path = " + sourcePath . toString ( ) , Project . MSG_VERBOSE ) ; log ( "Packages = " + packages , Project . MSG_VERBOSE ) ; log ( "Exclude Packages = " + excludePackages , Project . MSG_VERBOSE ) ; Vector addedPackages = new Vector ( ) ; String [ ] list = sourcePath . list ( ) ; if ( list == null ) list = new String [ 0 ] ; FileSet fs = new FileSet ( ) ; fs . setDefaultexcludes ( useDefaultExcludes ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createInclude ( ) . setName ( pkg ) ; } e = excludePackages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createExclude ( ) . setName ( pkg ) ; } for ( int j = 0 ; j < list . length ; j ++ ) { File source = project . resolveFile ( list [ j ] ) ; fs . setDir ( source ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] packageDirs = ds . getIncludedDirectories ( ) ; for ( int i = 0 ; i < packageDirs . length ; i ++ ) { File pd = new File ( source , packageDirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { String pkgDir = packageDirs [ i ] . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; if ( ! addedPackages . contains ( pkgDir ) ) { toExecute . createArgument ( ) . setValue ( pkgDir ) ; addedPackages . addElement ( pkgDir ) ; } } } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; else super . processLine ( queuedLine , Project . MSG_INFO ) ; queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } } 	0	['65', '3', '0', '21', '155', '1670', '6', '21', '59', '0.9171875', '1504', '1', '5', '0.37', '0.244140625', '3', '3', '21.83076923', '10', '1.5231', '0']
package org . apache . tools . ant ; import java . io . * ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String msg ) { super ( msg ) ; } public BuildException ( String msg , Throwable cause ) { super ( msg ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String msg , Location location ) { super ( msg ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { ps . println ( this ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { pw . println ( this ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['14', '4', '0', '99', '28', '0', '98', '1', '14', '0.384615385', '153', '1', '1', '0.65', '0.333333333', '1', '2', '9.785714286', '2', '0.6429', '0']
package org . apache . tools . ant ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( lSep + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '3', '16', '0', '0', '3', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . mail ; import java . io . * ; import java . net . * ; import java . util . * ; public class MailMessage { String host ; String from ; Vector to , cc ; Hashtable headers ; MailPrintStream out ; SmtpResponseReader in ; Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" ) ; } public MailMessage ( String host ) throws IOException { this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { sendDot ( ) ; sendQuit ( ) ; disconnect ( ) ; } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , 25 ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; send ( "QUIT" , ok ) ; } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; if ( socket != null ) socket . close ( ) ; } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte buf [ ] , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['27', '1', '0', '3', '63', '297', '1', '2', '10', '0.778846154', '527', '0', '2', '0', '0.37962963', '0', '0', '18.22222222', '11', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . File ; public class PathConvert extends Task { public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public Path createPath ( ) { if ( isReference ( ) ) throw noChildrenAllowed ( ) ; if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { targetOS = target . toLowerCase ( ) ; if ( ! targetOS . equals ( "windows" ) && ! target . equals ( "unix" ) ) { throw new BuildException ( "targetos must be one of 'unix' or 'windows'" ) ; } targetWindows = targetOS . equals ( "windows" ) ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) throw noChildrenAllowed ( ) ; refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else { throw new BuildException ( "'refid' does not refer to a path or fileset" ) ; } } validateSetup ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; onWindows = ( osname . indexOf ( "windows" ) >= 0 ) ; char fromDirSep = onWindows ? '\\' : '/' ; char toDirSep = dirSep . charAt ( 0 ) ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; elem = elem . replace ( fromDirSep , toDirSep ) ; if ( i != 0 ) rslt . append ( pathSep ) ; rslt . append ( elem ) ; } String value = rslt . toString ( ) ; log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setProperty ( property , value ) ; } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) throw new BuildException ( "You must specify a path to convert" ) ; if ( property == null ) throw new BuildException ( "You must specify a property" ) ; if ( targetOS == null && pathSep == null && dirSep == null ) throw new BuildException ( "You must specify at least one of targetOS, dirSep, or pathSep" ) ; String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested PATH elements when using refid" ) ; } private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; } 	0	['14', '3', '0', '8', '41', '33', '1', '8', '10', '0.760683761', '385', '1', '2', '0.74', '0.357142857', '1', '1', '25.85714286', '4', '1.5714', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . tar . * ; import java . io . * ; public class Untar extends Task { private File dest ; private File source ; private boolean overwrite = true ; public void execute ( ) throws BuildException { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; File srcF = source ; TarInputStream tis = null ; try { if ( source == null ) { throw new BuildException ( "No source specified" , location ) ; } if ( ! srcF . exists ( ) ) { throw new BuildException ( "source " + srcF + " doesn't exist" , location ) ; } if ( dest == null ) { throw new BuildException ( "No destination specified" , location ) ; } File dir = dest ; log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( new FileInputStream ( srcF ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { try { File f = new File ( dir , project . translatePath ( te . getName ( ) ) ) ; if ( ! overwrite && f . exists ( ) && f . lastModified ( ) >= te . getModTime ( ) . getTime ( ) ) { log ( "Skipping " + f + " as it is up-to-date" , Project . MSG_DEBUG ) ; continue ; } log ( "expanding " + te . getName ( ) + " to " + f , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( te . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = tis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( te . getModTime ( ) . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "FileNotFoundException: " + te . getName ( ) , Project . MSG_WARN ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } public void setOverwrite ( boolean b ) { overwrite = b ; } } 	0	['5', '3', '0', '9', '43', '0', '0', '9', '5', '0.666666667', '276', '1', '0', '0.902439024', '0.533333333', '2', '3', '53.6', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } try { err . flush ( ) ; } catch ( IOException e ) { } try { out . flush ( ) ; } catch ( IOException e ) { } } protected OutputStream getErr ( ) { return err ; } protected OutputStream getOut ( ) { return out ; } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	0	['13', '1', '1', '8', '20', '46', '6', '2', '8', '0.666666667', '111', '1', '0', '0', '0.615384615', '0', '0', '7.230769231', '1', '0.7692', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '35', '4', '0', '7', '7', '0.714285714', '265', '1', '0', '0.917647059', '0.46875', '3', '3', '31.375', '5', '1.375', '0']
package org . apache . tools . tar ; import java . io . * ; import java . util . * ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String Win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , Win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( Win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['31', '1', '0', '6', '65', '243', '4', '2', '30', '0.726666667', '747', '1', '0', '0', '0.182795699', '1', '1', '22.61290323', '4', '1.1613', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarOutputStream extends FilterOutputStream { static public final int LONGFILE_ERROR = 0 ; static public final int LONGFILE_TRUNCATE = 1 ; static public final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors , warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) parseEmacsOutput ( reader ) ; else parseStandardOutput ( reader ) ; } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) continue ; if ( lower . indexOf ( "error" ) != - 1 ) setError ( true ) ; else if ( lower . indexOf ( "warning" ) != - 1 ) setError ( false ) ; else { if ( emacsMode ) setError ( true ) ; } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) errorFlag = true ; } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '21', '44', '1', '2', '5', '0.805194805', '147', '1', '1', '0', '0.261904762', '0', '0', '10.66666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; cmd . setExecutable ( "sj" ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '9', '1', '1', '5', '2', '2', '33', '0', '0', '0.958333333', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . FileInputStream ; import org . apache . tools . ant . * ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or only a filtersFile parameter is required" , location ) ; } if ( isSingleFilter ) { project . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; project . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '16', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '8', '22', '0', '0', '8', '7', '0.625', '147', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.42857143', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Parallel extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) throws BuildException { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { TaskThread [ ] threads = new TaskThread [ nestedTasks . size ( ) ] ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; threads [ threadNumber ] = new TaskThread ( threadNumber , nestedTask ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . start ( ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { try { threads [ i ] . join ( ) ; } catch ( InterruptedException ie ) { } } StringBuffer exceptionMessage = new StringBuffer ( ) ; String lSep = System . getProperty ( "line.separator" ) ; int numExceptions = 0 ; Throwable firstException = null ; Location firstLocation = Location . UNKNOWN_LOCATION ; ; for ( int i = 0 ; i < threads . length ; ++ i ) { Throwable t = threads [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( lSep ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } class TaskThread extends Thread { private Throwable exception ; private Task task ; private int taskNumber ; TaskThread ( int taskNumber , Task task ) { this . task = task ; this . taskNumber = taskNumber ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } } public Throwable getException ( ) { return exception ; } } } 	0	['3', '3', '0', '5', '22', '0', '1', '5', '3', '0', '149', '1', '0', '0.948717949', '0.666666667', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { Argument argument = new Argument ( ) ; arguments . addElement ( argument ) ; return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) return ; this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) return args ; final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } } 	0	['19', '1', '0', '30', '46', '65', '29', '3', '17', '0.416666667', '448', '1', '0', '0', '0.289473684', '0', '0', '22.47368421', '16', '2.4211', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . IOException ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '10', '9', '1', '6', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; public class Path extends DataType implements Cloneable { private Vector elements ; private Project project ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( project , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { this . project = project ; elements = new Vector ( ) ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( project ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) return ; String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( project != null ) { f = project . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , project ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( project ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( project ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( project ) ; for ( int j = 0 ; j < s . length ; j ++ ) { File f = new File ( dir , s [ j ] ) ; String absolutePath = f . getAbsolutePath ( ) ; addUnlessPresent ( result , translateFile ( absolutePath ) ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) return new String [ 0 ] ; PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) return "" ; final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( project ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( project ) ; String order = defValue ; if ( project != null ) { String o = project . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { project . log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } } 	0	['26', '3', '0', '33', '80', '201', '26', '8', '20', '0.573333333', '719', '0.666666667', '2', '0.566037736', '0.152727273', '2', '11', '26.53846154', '14', '2.2692', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . text . * ; import java . lang . RuntimeException ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import java . io . File ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; cmd . setExecutable ( "gcj" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { attributes . log ( "gcj doesn't support -encoding option." , Project . MSG_WARN ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; return cmd ; } } 	0	['3', '2', '0', '9', '22', '3', '1', '8', '2', '2', '128', '0', '0', '0.92', '1', '1', '1', '41.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['9', '3', '0', '9', '29', '0', '0', '9', '9', '0.583333333', '168', '1', '1', '0.822222222', '0.444444444', '0', '0', '17.33333333', '2', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GUnzip extends Task { private File source ; private File dest ; public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No source for gunzip specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "source doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( len > 3 && ".gz" . equalsIgnoreCase ( sourceName . substring ( len - 3 ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - 3 ) ) ; } else { dest = new File ( dest , sourceName ) ; } } if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; try { out = new FileOutputStream ( dest ) ; zIn = new GZIPInputStream ( new FileInputStream ( source ) ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['4', '3', '0', '5', '32', '2', '0', '5', '4', '0.666666667', '215', '1', '0', '0.925', '0.75', '1', '1', '52.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private final static int SLEEP = 5 ; private final static int SIZE = 128 ; private InputStream is ; private OutputStream os ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } } } 	0	['2', '1', '0', '1', '6', '0', '1', '0', '2', '1', '39', '1', '0', '0', '0.666666667', '0', '0', '16.5', '2', '1', '0']
package org . apache . tools . ant ; import java . util . * ; import java . io . * ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { tokenizer = new StringTokenizer ( path , ":;" , false ) ; dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } return token ; } } 	0	['3', '1', '0', '2', '15', '0', '2', '0', '3', '0.166666667', '100', '1', '0', '0', '0.666666667', '0', '0', '31.33333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . * ; import java . io . * ; public abstract class Definer extends Task { private String name ; private String value ; private Path classpath ; private File file ; private String resource ; private boolean reverseLoader = false ; public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { AntClassLoader al = createLoader ( ) ; if ( file == null && resource == null ) { if ( name == null || value == null ) { String msg = "name or classname attributes of " + getTaskName ( ) + " element " + "are undefined" ; throw new BuildException ( msg ) ; } addDefinition ( al , name , value ) ; } else { try { if ( name != null || value != null ) { String msg = "You must not specify name or value " + "together with file or resource." ; throw new BuildException ( msg , location ) ; } if ( file != null && resource != null ) { String msg = "You must not specify both, file and resource." ; throw new BuildException ( msg , location ) ; } Properties props = new Properties ( ) ; InputStream is = null ; if ( file != null ) { log ( "Loading definitions from file " + file , Project . MSG_VERBOSE ) ; is = new FileInputStream ( file ) ; if ( is == null ) { log ( "Could not load definitions from file " + file + ". It doesn\'t exist." , Project . MSG_WARN ) ; } } if ( resource != null ) { log ( "Loading definitions from resource " + resource , Project . MSG_VERBOSE ) ; is = al . getResourceAsStream ( resource ) ; if ( is == null ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } if ( is != null ) { props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String n = ( String ) keys . nextElement ( ) ; String v = props . getProperty ( n ) ; addDefinition ( al , n , v ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } } private void addDefinition ( ClassLoader al , String name , String value ) { try { Class c = al . loadClass ( value ) ; AntClassLoader . initializeClass ( c ) ; addDefinition ( name , c ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } private AntClassLoader createLoader ( ) { AntClassLoader al = null ; if ( classpath != null ) { al = new AntClassLoader ( project , classpath , ! reverseLoader ) ; } else { al = new AntClassLoader ( project , Path . systemClasspath , ! reverseLoader ) ; } al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; return al ; } public void setFile ( File file ) { this . file = file ; } public void setResource ( String res ) { this . resource = res ; } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } protected abstract void addDefinition ( String name , Class c ) ; } 	0	['14', '3', '2', '11', '41', '67', '3', '8', '11', '0.846153846', '366', '1', '1', '0.74', '0.223214286', '1', '1', '24.71428571', '4', '1.2857', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import org . xml . sax . * ; import org . w3c . dom . * ; import org . apache . tools . ant . taskdefs . * ; import javax . xml . parsers . * ; public class ProjectHelper { private static SAXParserFactory parserFactory = null ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; public static void configureProject ( Project project , File buildFile ) throws BuildException { new ProjectHelper ( project , buildFile ) . parse ( ) ; } private ProjectHelper ( Project project , File buildFile ) { this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; } private void parse ( ) throws BuildException { FileInputStream inputStream = null ; InputSource inputSource = null ; try { SAXParser saxParser = getParserFactory ( ) . newSAXParser ( ) ; parser = saxParser . getParser ( ) ; String uri = "file:" + buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int index = uri . indexOf ( '#' ) ; index != - 1 ; index = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , index ) + "%23" + uri . substring ( index + 1 ) ; } inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; saxParser . parse ( inputSource , new RootHandler ( ) ) ; } catch ( ParserConfigurationException exc ) { throw new BuildException ( "Parser has not been configured correctly" , exc ) ; } catch ( SAXParseException exc ) { Location location = new Location ( buildFile . toString ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file" , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } private class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; public AbstractHandler ( DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , locator ) ; } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { String s = new String ( buf , start , end ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , locator ) ; } } protected void finished ( ) { } public void endElement ( String name ) throws SAXException { finished ( ) ; parser . setDocumentHandler ( parentHandler ) ; } } private class RootHandler extends HandlerBase { public InputSource resolveEntity ( String publicId , String systemId ) { project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = systemId . substring ( 5 ) ; int index = path . indexOf ( "file:" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + path . substring ( index + 5 ) ; index = path . indexOf ( "file:" ) ; } String entitySystemId = path ; index = path . indexOf ( "%23" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + "#" + path . substring ( index + 3 ) ; index = path . indexOf ( "%23" ) ; } File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( "file:" + entitySystemId ) ; return inputSource ; } catch ( FileNotFoundException fne ) { project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected XML type" , locator ) ; } } public void setDocumentLocator ( Locator locator ) { ProjectHelper . this . locator = locator ; } } private class ProjectHandler extends AbstractHandler { public ProjectHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , locator ) ; } } if ( def == null ) { throw new SAXParseException ( "The default attribute of project is required" , locator ) ; } project . setDefaultTarget ( def ) ; if ( name != null ) { project . setName ( name ) ; project . addReference ( name , project ) ; } if ( id != null ) project . addReference ( id , project ) ; if ( project . getProperty ( "basedir" ) != null ) { project . setBasedir ( project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { project . setBasedir ( buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { project . setBasedir ( baseDir ) ; } else { project . setBaseDir ( project . resolveFile ( baseDir , buildFileParent ) ) ; } } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "taskdef" ) ) { handleTaskdef ( name , attrs ) ; } else if ( name . equals ( "property" ) ) { handleProperty ( name , attrs ) ; } else if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { handleDataType ( name , attrs ) ; } else { throw new SAXParseException ( "Unexpected element \"" + name + "\"" , locator ) ; } } private void handleTaskdef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleProperty ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( this , null , null ) ) . init ( name , attrs ) ; } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( this ) . init ( tag , attrs ) ; } private void handleDataType ( String name , AttributeList attrs ) throws SAXParseException { new DataTypeHandler ( this ) . init ( name , attrs ) ; } } private class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( DocumentHandler parentHandler ) { super ( parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , locator ) ; } target = new Target ( ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) project . addReference ( id , target ) ; if ( depends . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depends , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { target . addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( project . getDataTypeDefinitions ( ) . get ( name ) != null ) { new DataTypeHandler ( this , target ) . init ( name , attrs ) ; } else { new TaskHandler ( this , target , target ) . init ( name , attrs ) ; } } } private class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( DocumentHandler parentHandler , TaskContainer container , Target target ) { super ( parentHandler ) ; this . container = container ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( project ) ; task . setTaskType ( tag ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( buildFile . toString ( ) , locator . getLineNumber ( ) , locator . getColumnNumber ( ) ) ) ; configureId ( task , attrs ) ; if ( target != null ) { task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; } else { task . init ( ) ; configure ( task , attrs , project ) ; } } protected void finished ( ) { if ( task != null && target == null ) { task . execute ( ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( wrapper == null ) { try { addText ( project , task , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { wrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) task , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , task , wrapper , target ) . init ( name , attrs ) ; } } } private class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( parentHandler ) ; if ( parent instanceof TaskAdapter ) { this . parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { if ( parent instanceof UnknownElement ) { child = new UnknownElement ( propType . toLowerCase ( ) ) ; ( ( UnknownElement ) parent ) . addChild ( ( UnknownElement ) child ) ; } else { child = ih . createElement ( project , parent , propType . toLowerCase ( ) ) ; } configureId ( child , attrs ) ; if ( parentWrapper != null ) { childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } else { configure ( child , attrs , project ) ; ih . storeElement ( project , parent , child , propType . toLowerCase ( ) ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { if ( parentWrapper == null ) { try { addText ( project , child , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } else { childWrapper . addText ( buf , start , end ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( this , ( TaskContainer ) child , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( this , child , childWrapper , target ) . init ( name , attrs ) ; } } } private class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( DocumentHandler parentHandler ) { this ( parentHandler , null ) ; } public DataTypeHandler ( DocumentHandler parentHandler , Target target ) { super ( parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } if ( target != null ) { wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } else { configure ( element , attrs , project ) ; configureId ( element , attrs ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void characters ( char [ ] buf , int start , int end ) throws SAXParseException { try { addText ( project , element , buf , start , end ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , locator , exc ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( this , element , wrapper , target ) . init ( name , attrs ) ; } } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int end ) throws BuildException { addText ( project , target , new String ( buf , start , end ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null || text . trim ( ) . length ( ) == 0 ) { return ; } if ( target instanceof TaskAdapter ) target = ( ( TaskAdapter ) target ) . getProxy ( ) ; IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( ! keys . containsKey ( propertyName ) ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( keys . containsKey ( propertyName ) ) ? ( String ) keys . get ( propertyName ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { fragments . addElement ( value . substring ( pos + 1 , pos + 2 ) ) ; prev = pos + 2 ; } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } private static SAXParserFactory getParserFactory ( ) { if ( parserFactory == null ) { parserFactory = SAXParserFactory . newInstance ( ) ; } return parserFactory ; } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['19', '1', '0', '24', '81', '147', '17', '8', '7', '0.861111111', '560', '1', '1', '0', '0.171296296', '0', '0', '28.15789474', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + CopyDir instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; int length ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '265', '1', '0', '0.840909091', '0.325', '1', '1', '31.625', '4', '1.25', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DirectoryScanner implements FileScanner { protected final static String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected boolean haveSlowResults = false ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } protected static boolean matchPath ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } protected static boolean match ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' && ch != strArr [ i ] ) { return false ; } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxStart ] ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxEnd ] ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void scan ( ) { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { filesIncluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name ) ) { return true ; } } return false ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['23', '1', '1', '25', '52', '181', '23', '2', '14', '0.731404959', '1489', '1', '0', '0', '0.290909091', '0', '0', '63.26086957', '35', '6.087', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '5', '13', '0', '4', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "javac" ) ; setupJavacCommandlineSwitches ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '11', '1', '1', '5', '2', '2', '37', '0', '0', '0.958333333', '1', '0', '0', '17.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '0', '2', '15', '0', '1', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public abstract class MatchingTask extends Task { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { Vector tmpExcludes = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } } 	0	['14', '3', '12', '20', '41', '0', '13', '7', '13', '0.461538462', '174', '1', '1', '0.74', '0.392857143', '0', '0', '11.28571429', '6', '1.5', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '2', '5', '6', '1', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . * ; public class ExecuteJava { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; final Object [ ] argument = { javaCommand . getArguments ( ) } ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = new AntClassLoader ( project . getCoreLoader ( ) , project , classpath , false ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; target = loader . forceLoadClass ( classname ) ; AntClassLoader . initializeClass ( target ) ; } final Method main = target . getMethod ( "main" , param ) ; main . invoke ( null , argument ) ; } catch ( NullPointerException e ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + ". Make sure you have it in your classpath" ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof SecurityException ) ) { throw new BuildException ( t ) ; } else { throw ( SecurityException ) t ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } } 	0	['6', '1', '0', '7', '28', '1', '1', '6', '6', '0.6', '173', '1', '3', '0', '0.305555556', '0', '0', '27.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; public abstract class Task extends ProjectComponent { protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } protected void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } protected void handleOutput ( String line ) { log ( line , Project . MSG_INFO ) ; } protected void handleErrorOutput ( String line ) { log ( line , Project . MSG_ERR ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public final void perform ( ) { try { project . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; project . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } project . fireTaskFinished ( this , exc ) ; throw exc ; } } } 	0	['20', '2', '40', '100', '28', '158', '96', '6', '16', '0.877192982', '164', '1', '3', '0.321428571', '0.258333333', '1', '3', '6.9', '3', '1.1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReferences ( ) . get ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '0', '19', '12', '4', '17', '2', '5', '0.25', '55', '1', '0', '0', '0.533333333', '0', '0', '9.8', '1', '0.6', '0']
package org . apache . tools . mail ; import java . io . * ; import java . net . * ; import java . util . * ; public class MailMessage { String host ; String from ; Vector to , cc ; Hashtable headers ; MailPrintStream out ; SmtpResponseReader in ; Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" ) ; } public MailMessage ( String host ) throws IOException { this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { sendDot ( ) ; sendQuit ( ) ; disconnect ( ) ; } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , 25 ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; send ( "QUIT" , ok ) ; } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; if ( socket != null ) socket . close ( ) ; } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte buf [ ] , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['27', '1', '0', '3', '63', '297', '1', '2', '10', '0.778846154', '527', '0', '2', '0', '0.37962963', '0', '0', '18.22222222', '11', '1.4444', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { public void buildStarted ( BuildEvent event ) ; public void buildFinished ( BuildEvent event ) ; public void targetStarted ( BuildEvent event ) ; public void targetFinished ( BuildEvent event ) ; public void taskStarted ( BuildEvent event ) ; public void taskFinished ( BuildEvent event ) ; public void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '11', '7', '21', '10', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Vector ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { super . setZipfile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { log ( "addArchives called" , Project . MSG_DEBUG ) ; fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "appxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/aplication.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will be ignored " + "(please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['7', '6', '0', '8', '31', '13', '0', '8', '4', '0.75', '151', '1', '0', '0.9625', '0.4', '4', '9', '20.28571429', '2', '1', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { public void setPattern ( String pattern ) throws BuildException ; public String getPattern ( ) ; public boolean matches ( String argument ) ; public Vector getGroups ( String argument ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . PatternSet ; import java . util . * ; public class CompileTask extends Javac { protected Vector taskList = new Vector ( ) ; public Taskdef createTaskdef ( ) { Taskdef task = new Taskdef ( ) ; taskList . addElement ( task ) ; return task ; } public void init ( ) { log ( "!! CompileTask is deprecated. !!" ) ; log ( "Use <taskdef> elements nested into <target>s instead" ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; String source = task . getClassname ( ) . replace ( '.' , '/' ) + ".java" ; PatternSet . NameEntry include = super . createInclude ( ) ; include . setName ( "**/" + source ) ; } super . init ( ) ; super . execute ( ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; task . init ( ) ; } } public void execute ( ) { } } 	0	['4', '5', '0', '6', '21', '0', '0', '6', '4', '0.333333333', '87', '1', '0', '0.98089172', '1', '1', '1', '20.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed, messages should have been provided." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , location ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , location ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_INFO ) ; } String compiler = project . getProperty ( "build.rmic" ) ; RmicAdapter adapter = RmicAdapterFactory . getRmic ( compiler , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = new AntClassLoader ( project , classpath ) ; if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , location ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } compileList . removeAllElements ( ) ; } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { String sourceFileName = classFileName . substring ( 0 , classFileName . length ( ) - 6 ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { project . copyFile ( oldFile , newFile , filtering ) ; oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } protected void scanDir ( File baseDir , String files [ ] , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } } 	0	['44', '4', '0', '19', '91', '802', '6', '14', '40', '0.94369645', '724', '0.947368421', '2', '0.644628099', '0.156818182', '3', '3', '15.02272727', '7', '1.4091', '0']
package org . apache . tools . ant ; import java . util . Vector ; public class UnknownElement extends Task { private String elementName ; private Task realTask ; private Vector children = new Vector ( ) ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public void maybeConfigure ( ) throws BuildException { realTask = makeTask ( this , wrapper ) ; wrapper . setProxy ( realTask ) ; realTask . setRuntimeConfigurableWrapper ( wrapper ) ; handleChildren ( realTask , wrapper ) ; realTask . maybeConfigure ( ) ; target . replaceTask ( this , realTask ) ; } public void execute ( ) { if ( realTask == null ) { throw new BuildException ( "Could not create task of type: " + elementName , location ) ; } realTask . execute ( ) ; } public void addChild ( UnknownElement child ) { children . addElement ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TaskAdapter ) { parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) children . elementAt ( i ) ; Object realChild = null ; if ( parent instanceof TaskContainer ) { realChild = makeTask ( child , childWrapper ) ; ( ( TaskContainer ) parent ) . addTask ( ( Task ) realChild ) ; } else { realChild = ih . createElement ( project , parent , child . getTag ( ) ) ; } childWrapper . setProxy ( realChild ) ; if ( realChild instanceof Task ) { ( ( Task ) realChild ) . setRuntimeConfigurableWrapper ( childWrapper ) ; } child . handleChildren ( realChild , childWrapper ) ; if ( realChild instanceof Task ) { ( ( Task ) realChild ) . maybeConfigure ( ) ; } } } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w ) { Task task = project . createTask ( ue . getTag ( ) ) ; if ( task == null ) { log ( "Could not create task of type: " + elementName + " Common solutions" + " are adding the task to defaults.properties and executing bin/bootstrap" , Project . MSG_DEBUG ) ; throw new BuildException ( "Could not create task of type: " + elementName + ". Common solutions are to use taskdef to declare" + " your task, or, if this is an optional task," + " to put the optional.jar in the lib directory of" + " your ant installation (ANT_HOME)." , location ) ; } task . setLocation ( getLocation ( ) ) ; String id = w . getAttributes ( ) . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , task ) ; } task . setOwningTarget ( target ) ; task . init ( ) ; return task ; } public String getTaskName ( ) { return realTask == null ? super . getTaskName ( ) : realTask . getTaskName ( ) ; } } 	0	['8', '3', '0', '12', '38', '4', '3', '10', '6', '0.523809524', '243', '1', '1', '0.840909091', '0.35', '1', '4', '29', '3', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final String EOL = System . getProperty ( "line.separator" ) ; private final char shifts [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "user.home" ) + "/.cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) throw new BuildException ( "cvsroot is required" ) ; if ( password == null ) throw new BuildException ( "password is required" ) ; log ( "cvsRoot: " + cvsRoot , project . MSG_DEBUG ) ; log ( "password: " + password , project . MSG_DEBUG ) ; log ( "passFile: " + passFile , project . MSG_DEBUG ) ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { BufferedReader reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line + EOL ) ; } } reader . close ( ) ; } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , project . MSG_DEBUG ) ; PrintWriter writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; writer . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '2', '29', '0', '0', '2', '5', '0.64', '1260', '1', '0', '0.880952381', '0.555555556', '1', '1', '208.1666667', '2', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent { protected Project project = null ; public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( project != null ) { project . log ( msg , msgLevel ) ; } } } 	0	['5', '1', '2', '59', '7', '0', '59', '1', '5', '0', '33', '1', '1', '0', '0.45', '0', '0', '5.4', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . apache . tools . ant . util . DOMElementWriter ; public class XmlLogger implements BuildListener { private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private Document doc ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; static private class TimedElement { long startTime ; Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; doc = builder . newDocument ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; } try { String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } Writer out = new OutputStreamWriter ( new FileOutputStream ( outFilename ) , "UTF8" ) ; out . write ( "<?xml:stylesheet type=\"text/xsl\" href=\"log.xsl\"?>\n\n" ) ; ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to close log file" , exc ) ; } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; String name = task . getClass ( ) . getName ( ) ; int pos = name . lastIndexOf ( "." ) ; if ( pos != - 1 ) { name = name . substring ( pos + 1 ) ; } taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } public void messageLogged ( BuildEvent event ) { Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = ( TimedElement ) tasks . get ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement == null ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack != null ) { if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } } 	0	['11', '1', '0', '11', '61', '0', '0', '11', '8', '0.913333333', '517', '1', '1', '0', '0.8', '0', '0', '44.63636364', '9', '2.7273', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; import java . util . Enumeration ; import java . util . Vector ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . toString ( ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '144', '1', '1', '0', '0.9', '0', '0', '27.2', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '4', '2', '0', '4', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; public class XSLTProcess extends MatchingTask { private File destDir = null ; private File baseDir = null ; private String xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private String processor ; private Path classpath = null ; private XSLTLiaison liaison ; private boolean stylesheetLoaded = false ; private boolean force = false ; private FileUtils fileUtils ; public XSLTProcess ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( xslFile == null ) { throw new BuildException ( "no stylesheet specified" , location ) ; } if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } liaison = getLiaison ( ) ; log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; File stylesheet = project . resolveFile ( xslFile ) ; if ( ! stylesheet . exists ( ) ) { stylesheet = fileUtils . resolveFile ( baseDir , xslFile ) ; if ( stylesheet . exists ( ) ) { log ( "DEPRECATED - the style attribute should be relative to the project\'s" ) ; log ( "             basedir, not the tasks\'s basedir." ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , stylesheet ) ; return ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , stylesheet ) ; } dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) process ( baseDir , list [ i ] , destDir , stylesheet ) ; } } public void setForce ( boolean force ) { this . force = force ; } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = xslFile ; } public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProcessor ( String processor ) { this . processor = processor ; } private void resolveProcessor ( String proc ) throws Exception { if ( proc . equals ( "trax" ) ) { final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xslp" ) ) { log ( "DEPRECATED - xslp processor is deprecated. Use trax or xalan instead." ) ; final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( proc . equals ( "xalan" ) ) { final Class clazz = loadClass ( "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) loadClass ( proc ) . newInstance ( ) ; } } private Class loadClass ( String classname ) throws Exception { if ( classpath == null ) { return Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; Class c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; return c ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , File stylesheet ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { long styleSheetLastModified = stylesheet . lastModified ( ) ; inFile = new File ( baseDir , xmlFile ) ; int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Transforming into " + destDir ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , File stylesheet ) throws BuildException { try { long styleSheetLastModified = stylesheet . lastModified ( ) ; log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( force || inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; configureLiaison ( stylesheet ) ; liaison . transform ( inFile , outFile ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) outFile . delete ( ) ; throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } protected XSLTLiaison getLiaison ( ) { if ( liaison == null ) { if ( processor != null ) { try { resolveProcessor ( processor ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } else { try { resolveProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { resolveProcessor ( "xslp" ) ; } catch ( Throwable e2 ) { try { resolveProcessor ( "xalan" ) ; } catch ( Throwable e3 ) { e3 . printStackTrace ( ) ; e2 . printStackTrace ( ) ; throw new BuildException ( e1 ) ; } } } } } return liaison ; } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) throw new BuildException ( "Name attribute is missing." ) ; return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) throw new BuildException ( "Expression attribute is missing." ) ; return expression ; } } protected void configureLiaison ( File stylesheet ) throws BuildException { if ( stylesheetLoaded ) { return ; } stylesheetLoaded = true ; try { log ( "Loading stylesheet " + stylesheet , Project . MSG_INFO ) ; liaison . setStylesheet ( stylesheet ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to read stylesheet " + stylesheet , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } } 	0	['21', '4', '0', '13', '73', '128', '1', '13', '14', '0.85', '737', '1', '3', '0.795918367', '0.301587302', '3', '3', '33.47619048', '3', '1.0952', '0']
package org . apache . tools . ant . taskdefs ; import java . util . * ; import java . io . * ; import org . apache . tools . ant . BuildException ; public class Manifest { static public final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; static public final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; static public final String ATTRIBUTE_NAME = "Name" ; static public final String ATTRIBUTE_FROM = "From" ; static public final String DEFAULT_MANIFEST_VERSION = "1.0" ; static public final int MAX_LINE_LENGTH = 70 ; static public class Attribute { private String name = null ; private String value = null ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; this . value = value ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Attribute ) ) { return false ; } Attribute rhsAttribute = ( Attribute ) rhs ; return ( name != null && rhsAttribute . name != null && name . toLowerCase ( ) . equals ( rhsAttribute . name . toLowerCase ( ) ) && value != null && value . equals ( rhsAttribute . value ) ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid" ) ; } name = line . substring ( 0 , index ) ; value = line . substring ( index + 2 ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void addContinuation ( String line ) { value += line . substring ( 1 ) ; } public void write ( PrintWriter writer ) throws IOException { String line = name + ": " + value ; while ( line . getBytes ( ) . length > MAX_LINE_LENGTH ) { int breakIndex = MAX_LINE_LENGTH ; String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( ) . length > MAX_LINE_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . println ( section ) ; line = " " + line . substring ( breakIndex ) ; } writer . println ( line ) ; } } static public class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { throw new ManifestException ( "Can't start an attribute with a continuation line " + line ) ; } attribute . addContinuation ( line ) ; } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections with different names" ) ; } for ( Enumeration e = section . attributes . keys ( ) ; e . hasMoreElements ( ) ; ) { String attributeName = ( String ) e . nextElement ( ) ; attributes . put ( attributeName , section . attributes . get ( attributeName ) ) ; } for ( Enumeration e = section . warnings . elements ( ) ; e . hasMoreElements ( ) ; ) { warnings . addElement ( e . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } for ( Enumeration e = attributes . elements ( ) ; e . hasMoreElements ( ) ; ) { Attribute attribute = ( Attribute ) e . nextElement ( ) ; attribute . write ( writer ) ; } writer . println ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { attributes . remove ( attributeName . toLowerCase ( ) ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Use the \"name\" attribute of the <section> element rather than using " + "the \"Name\" attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes should not occur in the " + "main section and must be the first element in all " + "other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getName ( ) . toLowerCase ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( "Manifest attributes should not start with \"" + ATTRIBUTE_FROM + "\" in \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else if ( attributes . containsKey ( attribute . getName ( ) . toLowerCase ( ) ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not " + "occur more than once in the same section" ) ; } else { attributes . put ( attribute . getName ( ) . toLowerCase ( ) , attribute ) ; } return null ; } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Section ) ) { return false ; } Section rhsSection = ( Section ) rhs ; if ( attributes . size ( ) != rhsSection . attributes . size ( ) ) { return false ; } for ( Enumeration e = attributes . elements ( ) ; e . hasMoreElements ( ) ; ) { Attribute attribute = ( Attribute ) e . nextElement ( ) ; Attribute rshAttribute = ( Attribute ) rhsSection . attributes . get ( attribute . getName ( ) . toLowerCase ( ) ) ; if ( ! attribute . equals ( rshAttribute ) ) { return false ; } } return true ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; public Manifest ( ) { } public Manifest ( InputStream is ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { if ( section . getName ( ) == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( section . getName ( ) . toLowerCase ( ) , section ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { mainSection . addConfiguredAttribute ( attribute ) ; } public void merge ( Manifest other ) throws ManifestException { manifestVersion = other . manifestVersion ; mainSection . merge ( other . mainSection ) ; for ( Enumeration e = other . sections . keys ( ) ; e . hasMoreElements ( ) ; ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { sections . put ( sectionName . toLowerCase ( ) , otherSection ) ; } else { ourSection . merge ( otherSection ) ; } } } public void write ( PrintWriter writer ) throws IOException { writer . println ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . println ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { mainSection . addConfiguredAttribute ( new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ) ; } catch ( ManifestException e ) { } } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; for ( Enumeration e2 = mainSection . getWarnings ( ) ; e2 . hasMoreElements ( ) ; ) { warnings . addElement ( e2 . nextElement ( ) ) ; } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; for ( Enumeration e2 = section . getWarnings ( ) ; e2 . hasMoreElements ( ) ; ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public boolean equals ( Object rhs ) { if ( ! ( rhs instanceof Manifest ) ) { return false ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( sections . size ( ) != rhsManifest . sections . size ( ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } for ( Enumeration e = sections . elements ( ) ; e . hasMoreElements ( ) ; ) { Section section = ( Section ) e . nextElement ( ) ; Section rhsSection = ( Section ) rhsManifest . sections . get ( section . getName ( ) . toLowerCase ( ) ) ; if ( ! section . equals ( rhsSection ) ) { return false ; } } return true ; } } 	0	['9', '1', '0', '5', '53', '0', '1', '4', '9', '0.819444444', '396', '0.333333333', '1', '0', '0.238095238', '0', '0', '42', '7', '1.7778', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; class JavacOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private boolean errorFlag = false ; JavacOutputStream ( Task task ) { this . task = task ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; if ( s . indexOf ( "error" ) > - 1 ) { errorFlag = true ; } task . log ( s ) ; line = new StringBuffer ( ) ; } boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['4', '2', '0', '1', '11', '0', '0', '1', '1', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import java . text . * ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . util . FileUtils ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; private static String javaVersion ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private String name ; private String description ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable references = new Hashtable ( ) ; private String defaultTarget ; private Hashtable dataClassDefinitions = new Hashtable ( ) ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Hashtable threadTasks = new Hashtable ( ) ; static { try { javaVersion = JAVA_1_0 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; } catch ( ClassNotFoundException cnfe ) { } } private FileUtils fileUtils ; public Project ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; String defs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( defs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class taskClass = Class . forName ( value ) ; addTaskDefinition ( key , taskClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default task list" ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class dataClass = Class . forName ( value ) ; addDataTypeDefinition ( key , dataClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default datatype list" ) ; } setSystemProperties ( ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public void addBuildListener ( BuildListener listener ) { listeners . addElement ( listener ) ; } public void removeBuildListener ( BuildListener listener ) { listeners . removeElement ( listener ) ; } public Vector getBuildListeners ( ) { return listeners ; } public void log ( String msg ) { log ( msg , MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { fireMessageLogged ( this , msg , msgLevel ) ; } public void log ( Task task , String msg , int msgLevel ) { fireMessageLogged ( task , msg , msgLevel ) ; } public void log ( Target target , String msg , int msgLevel ) { fireMessageLogged ( target , msg , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public void setProperty ( String name , String value ) { if ( null != userProperties . get ( name ) ) { log ( "Override ignored for user property " + name , MSG_VERBOSE ) ; return ; } log ( "Setting project property: " + name + " -> " + value , MSG_DEBUG ) ; properties . put ( name , value ) ; } public void setUserProperty ( String name , String value ) { log ( "Setting ro project property: " + name + " -> " + value , MSG_DEBUG ) ; userProperties . put ( name , value ) ; properties . put ( name , value ) ; } public String getProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) properties . get ( name ) ; return property ; } public String getUserProperty ( String name ) { if ( name == null ) return null ; String property = ( String ) userProperties . get ( name ) ; return property ; } public Hashtable getProperties ( ) { return properties ; } public Hashtable getUserProperties ( ) { return userProperties ; } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = fileUtils . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; if ( ! baseDir . isDirectory ( ) ) throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; this . baseDir = baseDir ; setProperty ( "basedir" , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public static String getJavaVersion ( ) { return javaVersion ; } public void setJavaVersionProperty ( ) { setProperty ( "ant.java.version" , javaVersion ) ; if ( javaVersion == JAVA_1_0 ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; String value = systemP . get ( name ) . toString ( ) ; this . setProperty ( name . toString ( ) , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) { String msg = " +User task: " + taskName + "     " + taskClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; taskClassDefinitions . put ( taskName , taskClass ) ; } public Hashtable getTaskDefinitions ( ) { return taskClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; dataClassDefinitions . put ( typeName , typeClass ) ; } public Hashtable getDataTypeDefinitions ( ) { return dataClassDefinitions ; } public void addTarget ( Target target ) { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { Class c = ( Class ) taskClassDefinitions . get ( taskType ) ; if ( c == null ) return null ; try { Object o = c . newInstance ( ) ; Task task = null ; if ( o instanceof Task ) { task = ( Task ) o ; } else { TaskAdapter taskA = new TaskAdapter ( ) ; taskA . setProxy ( o ) ; task = taskA ; } task . setProject ( this ) ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; log ( msg , MSG_DEBUG ) ; return task ; } catch ( Throwable t ) { String msg = "Could not create task of type: " + taskType + " due to " + t ; throw new BuildException ( msg , t ) ; } } public Object createDataType ( String typeName ) throws BuildException { Class c = ( Class ) dataClassDefinitions . get ( typeName ) ; if ( c == null ) return null ; try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { getClass ( ) } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { this } ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setProject ( this ) ; } String msg = "   +DataType: " + typeName ; log ( msg , MSG_DEBUG ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } catch ( Throwable t ) { String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } } public void executeTargets ( Vector targetNames ) throws BuildException { Throwable error = null ; for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void demuxOutput ( String line , boolean isError ) { Task task = ( Task ) threadTasks . get ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , line , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorOutput ( line ) ; } else { task . handleOutput ( line ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; int curidx = 0 ; Target curtarget ; do { curtarget = ( Target ) sortedTargets . elementAt ( curidx ++ ) ; curtarget . performTasks ( ) ; } while ( ! curtarget . getName ( ) . equals ( targetName ) ) ; } public File resolveFile ( String fileName , File rootDir ) { return fileUtils . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return fileUtils . resolveFile ( baseDir , fileName ) ; } static public String translatePath ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( to_process . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( to_process ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( getJavaVersion ( ) == JAVA_1_1 ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } fileUtils . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( s . equalsIgnoreCase ( "on" ) || s . equalsIgnoreCase ( "true" ) || s . equalsIgnoreCase ( "yes" ) ) ; } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) ( en . nextElement ( ) ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) ( targets . get ( root ) ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { if ( null != references . get ( name ) ) { log ( "Overriding previous definition of reference to " + name , MSG_WARN ) ; } log ( "Adding reference: " + name + " -> " + value , MSG_DEBUG ) ; references . put ( name , value ) ; } public Hashtable getReferences ( ) { return references ; } protected void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildStarted ( event ) ; } } protected void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { threadTasks . put ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { threadTasks . remove ( Thread . currentThread ( ) ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { event . setMessage ( message , priority ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . messageLogged ( event ) ; } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } } 	0	['76', '1', '0', '120', '177', '2446', '114', '12', '63', '0.969462366', '1776', '0.612903226', '3', '0', '0.118518519', '0', '0', '21.96052632', '5', '1.3289', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class RecorderEntry implements BuildLogger { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0l ; private static String lSep = System . getProperty ( "line.separator" ) ; protected RecorderEntry ( String name ) { filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) record = state . booleanValue ( ) ; } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( lSep + "BUILD SUCCESSFUL" ) ; } else { out . println ( lSep + "BUILD FAILED" + lSep ) ; error . printStackTrace ( out ) ; } out . flush ( ) ; out . close ( ) ; } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( lSep + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; out . flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TAST STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; out . flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = "[" + event . getTask ( ) . getTaskName ( ) + "]" ; for ( int i = 0 ; i < ( 12 - name . length ( ) ) ; i ++ ) { buf . append ( " " ) ; } buf . append ( name ) ; } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) ) { out . println ( mesg ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) loglevel = level ; } public void setOutputPrintStream ( PrintStream output ) { out = output ; } public void setEmacsMode ( boolean emacsMode ) { throw new java . lang . RuntimeException ( "Method setEmacsMode() not yet implemented." ) ; } public void setErrorPrintStream ( PrintStream err ) { out = err ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	0	['17', '1', '0', '5', '39', '74', '1', '4', '13', '0.65625', '359', '1', '0', '0', '0.2421875', '0', '0', '19.76470588', '5', '1.5882', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['2', '5', '0', '1', '7', '0', '1', '0', '2', '0', '20', '1', '0', '0.928571429', '0.75', '0', '0', '8.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . tar . * ; import org . apache . tools . ant . types . * ; public class Tar extends MatchingTask { static public final String WARN = "warn" ; static public final String FAIL = "fail" ; static public final String TRUNCATE = "truncate" ; static public final String GNU = "gnu" ; static public final String OMIT = "omit" ; private String [ ] validModes = new String [ ] { WARN , FAIL , TRUNCATE , GNU , OMIT } ; File tarFile ; File baseDir ; String longFileMode = WARN ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { for ( int i = 0 ; i < validModes . length ; ++ i ) { if ( mode . equalsIgnoreCase ( validModes [ i ] ) ) { this . longFileMode = mode ; return ; } } throw new BuildException ( "The longfile value " + mode + " is not a valid value" ) ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basdir attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( new FileOutputStream ( tarFile ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . equalsIgnoreCase ( TRUNCATE ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . equalsIgnoreCase ( FAIL ) || longFileMode . equalsIgnoreCase ( OMIT ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( fs . getDir ( project ) , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = null ; if ( vPath . length ( ) <= 0 ) { return ; } if ( file . isDirectory ( ) && ! vPath . endsWith ( "/" ) ) { vPath += "/" ; } try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . equalsIgnoreCase ( OMIT ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . equalsIgnoreCase ( WARN ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed successfully" + " by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . equalsIgnoreCase ( FAIL ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setSize ( file . length ( ) ) ; te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; if ( ! file . isDirectory ( ) ) { fIn = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } tOut . closeEntry ( ) ; } finally { if ( fIn != null ) fIn . close ( ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } static public class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; String [ ] directories = ds . getIncludedDirectories ( ) ; String [ ] filesPerSe = ds . getIncludedFiles ( ) ; files = new String [ directories . length + filesPerSe . length ] ; System . arraycopy ( directories , 0 , files , 0 , directories . length ) ; System . arraycopy ( filesPerSe , 0 , files , directories . length , filesPerSe . length ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } } } 	0	['8', '4', '0', '13', '65', '2', '0', '13', '6', '0.916666667', '608', '0.166666667', '0', '0.917647059', '0.333333333', '2', '2', '73.5', '3', '1.25', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . BuildException ; import java . io . * ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; public class PatternSet extends DataType { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( name ) ; if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { try { BufferedReader patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = ProjectHelper . replaceProperties ( p , line , p . getProperties ( ) ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( ) { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } private PatternSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) return null ; Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String result [ ] = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } } 	0	['20', '3', '0', '10', '60', '114', '5', '6', '14', '0.605263158', '557', '1', '0', '0.612244898', '0.264285714', '1', '1', '26.65', '9', '2.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private boolean fork = false ; private File dir = null ; private File out ; private PrintStream outStream = null ; private boolean failOnError = false ; public void execute ( ) throws BuildException { int err = - 1 ; if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null && cmdl . getJar ( ) == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( ! fork && cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot execute a jar in non-forked mode. Please set fork='true'. " ) ; } if ( fork ) { log ( "Forking " + cmdl . toString ( ) , Project . MSG_VERBOSE ) ; return run ( cmdl . getCommandline ( ) ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . getJavaCommand ( ) . toString ( ) , Project . MSG_VERBOSE ) ; try { run ( cmdl ) ; return 0 ; } catch ( ExitException ex ) { return ex . getStatus ( ) ; } } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setJar ( File jarfile ) throws BuildException { if ( cmdl . getClassname ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' attributes in same command." ) ; } cmdl . setJar ( jarfile . getAbsolutePath ( ) ) ; } public void setClassname ( String s ) throws BuildException { if ( cmdl . getJar ( ) != null ) { throw new BuildException ( "Cannot use 'jar' and 'classname' attributes in same command" ) ; } cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { cmdl . setMaxmemory ( max ) ; } public void setJVMVersion ( String value ) { cmdl . setVmversion ( value ) ; } protected void handleOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( outStream != null ) { outStream . println ( line ) ; } else { super . handleErrorOutput ( line ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; if ( out != null ) { try { outStream = new PrintStream ( new FileOutputStream ( out ) ) ; exe . execute ( project ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( outStream != null ) { outStream . close ( ) ; } } } else { exe . execute ( project ) ; } } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; } else { fos = new FileOutputStream ( out ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , null ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } } 	0	['26', '3', '0', '19', '87', '105', '0', '19', '21', '0.773333333', '514', '1', '1', '0.596774194', '0.176923077', '1', '3', '18.53846154', '2', '1.0385', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . File ; import java . util . Vector ; public class SourceFileScanner { protected Task task ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; StringBuffer targetList = new StringBuffer ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String [ ] targets = mapper . mapFileName ( files [ i ] ) ; if ( targets == null || targets . length == 0 ) { task . log ( files [ i ] + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } File src = new File ( srcDir , files [ i ] ) ; if ( src . lastModified ( ) > now ) { task . log ( "Warning: " + files [ i ] + " modified in the future." , Project . MSG_WARN ) ; } boolean added = false ; targetList . setLength ( 0 ) ; for ( int j = 0 ; ! added && j < targets . length ; j ++ ) { File dest = null ; if ( destDir == null ) { dest = new File ( targets [ j ] ) ; } else { dest = new File ( destDir , targets [ j ] ) ; } if ( ! dest . exists ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else if ( src . lastModified ( ) > dest . lastModified ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " is outdated." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( dest . getAbsolutePath ( ) ) ; } } if ( ! added ) { task . log ( files [ i ] + " omitted as " + targetList . toString ( ) + ( targets . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } String [ ] result = new String [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } } 	0	['3', '1', '0', '9', '25', '1', '7', '2', '3', '0', '277', '1', '1', '0', '0.666666667', '0', '0', '91', '14', '5.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; public abstract String [ ] getValues ( ) ; public EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { if ( ! containsValue ( value ) ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . value = value ; } public final boolean containsValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return false ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return true ; } } return false ; } public final String getValue ( ) { return value ; } } 	0	['5', '1', '11', '21', '11', '8', '20', '1', '5', '0.75', '59', '1', '0', '0', '0.7', '0', '0', '10.6', '5', '1.6', '0']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	0	['8', '1', '0', '4', '39', '22', '1', '3', '6', '0.785714286', '377', '0.5', '0', '0', '0.166666667', '0', '0', '45.875', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { public void setJavac ( Javac attributes ) ; public boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Vector ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private FileUtils fileUtils ; public Touch ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to touch directories." ) ; } if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative milliseconds value relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe , location ) ; } } touch ( ) ; } protected void touch ( ) throws BuildException { if ( file != null ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( new byte [ 0 ] ) ; fos . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , location ) ; } } touch ( file ) ; } if ( millis >= 0 && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( "modification time of files cannot be set in JDK 1.1" , Project . MSG_WARN ) ; return ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { touch ( new File ( fromDir , srcFiles [ j ] ) ) ; } for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new File ( fromDir , srcDirs [ j ] ) ) ; } } } protected void touch ( File file ) throws BuildException { if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of read-only file " + file ) ; } if ( project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } if ( millis < 0 ) { fileUtils . setFileLastModified ( file , System . currentTimeMillis ( ) ) ; } else { fileUtils . setFileLastModified ( file , millis ) ; } } } 	0	['8', '3', '0', '11', '39', '0', '3', '8', '6', '0.657142857', '294', '1', '1', '0.840909091', '0.325', '0', '0', '35.125', '1', '0.875', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import org . apache . tools . ant . * ; import java . util . Random ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '29', '0', '0', '5', '0', '0', '176', '1', '2', '0', '0.6', '0', '0', '85.5', '10', '5', '0']
package org . apache . tools . zip ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry { private int internalAttributes = 0 ; private long externalAttributes = 0 ; private Vector extraFields = new Vector ( ) ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry . getName ( ) ) ; setComment ( entry . getComment ( ) ) ; setMethod ( entry . getMethod ( ) ) ; setTime ( entry . getTime ( ) ) ; long size = entry . getSize ( ) ; if ( size > 0 ) { setSize ( size ) ; } long cSize = entry . getCompressedSize ( ) ; if ( cSize > 0 ) { setComprSize ( cSize ) ; } long crc = entry . getCrc ( ) ; if ( crc > 0 ) { setCrc ( crc ) ; } byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } public Object clone ( ) { ZipEntry e = null ; try { e = new ZipEntry ( ( java . util . zip . ZipEntry ) super . clone ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields . removeAllElements ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } private Long compressedSize = null ; public void setComprSize ( long size ) { if ( haveSetCompressedSize ( ) ) { performSetCompressedSize ( this , size ) ; } else { compressedSize = new Long ( size ) ; } } public long getCompressedSize ( ) { if ( compressedSize != null ) { return compressedSize . longValue ( ) ; } return super . getCompressedSize ( ) ; } private static Method setCompressedSizeMethod = null ; private static Object lockReflection = new Object ( ) ; private static boolean triedToGetMethod = false ; private static boolean haveSetCompressedSize ( ) { checkSCS ( ) ; return setCompressedSizeMethod != null ; } private static void performSetCompressedSize ( ZipEntry ze , long size ) { Long [ ] s = { new Long ( size ) } ; try { setCompressedSizeMethod . invoke ( ze , s ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + nested . getMessage ( ) ) ; } catch ( Throwable other ) { throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + other . getMessage ( ) ) ; } } private static void checkSCS ( ) { if ( ! triedToGetMethod ) { synchronized ( lockReflection ) { triedToGetMethod = true ; try { setCompressedSizeMethod = java . util . zip . ZipEntry . class . getMethod ( "setCompressedSize" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { } } } } } 	0	['23', '2', '0', '5', '68', '181', '2', '3', '17', '0.806818182', '462', '0.875', '0', '0.547619048', '0.140909091', '0', '0', '18.73913043', '5', '1.4783', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . net . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , location ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , location ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } } FileOutputStream fos = new FileOutputStream ( dest ) ; InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( "Can't get " + source + " to " + dest , location ) ; } byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) System . out . print ( "." ) ; } if ( verbose ) System . out . println ( ) ; fos . close ( ) ; is . close ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) touchFile ( dest , remoteTimestamp ) ; } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( ioe , location ) ; } } protected boolean touchFile ( File file , long timemillis ) throws BuildException { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; touch . setFile ( file ) ; touch . setMillis ( timemillis ) ; touch . touch ( ) ; return true ; } else { return false ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { useTimestamp = v ; } } } 	0	['8', '3', '0', '7', '46', '10', '0', '7', '7', '0.771428571', '394', '1', '0', '0.840909091', '0.375', '1', '1', '47.625', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; public interface FileScanner { public void addDefaultExcludes ( ) ; public File getBasedir ( ) ; public String [ ] getExcludedDirectories ( ) ; public String [ ] getExcludedFiles ( ) ; public String [ ] getIncludedDirectories ( ) ; public String [ ] getIncludedFiles ( ) ; public String [ ] getNotIncludedDirectories ( ) ; public String [ ] getNotIncludedFiles ( ) ; public void scan ( ) ; public void setBasedir ( String basedir ) ; public void setBasedir ( File basedir ) ; public void setExcludes ( String [ ] excludes ) ; public void setIncludes ( String [ ] includes ) ; } 	0	['13', '1', '0', '5', '13', '78', '5', '0', '13', '2', '13', '0', '0', '0', '0.326923077', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class FilterSet extends DataType { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { this . token = token ; this . value = value ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { readFiltersFromFile ( file ) ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public Hashtable getFilterHash ( ) { int filterSize = getFilters ( ) . size ( ) ; Hashtable filterHash = new Hashtable ( filterSize ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } readFiltersFromFile ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration enum = props . propertyNames ( ) ; Vector filters = getFilters ( ) ; while ( enum . hasMoreElements ( ) ) { String strPropName = ( String ) enum . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filters . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception e ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioex ) { } } } } else { throw new BuildException ( "Must specify a file not a directory in the filtersfile attribute:" + filtersFile ) ; } } public String replaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } } while ( ( index = line . indexOf ( beginToken , i ) ) > - 1 ) ; b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } public void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( new Filter ( token , value ) ) ; } public void addFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { filters . addElement ( ( Filter ) e . nextElement ( ) ) ; } } public boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } } 	0	['18', '3', '0', '10', '59', '103', '6', '5', '14', '0.774509804', '466', '0.5', '0', '0.652173913', '0.3', '0', '0', '24.55555556', '5', '1.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . ZipInputStream ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . zip . * ; public class Zip extends MatchingTask { private File zipFile ; private File baseDir ; private boolean doCompress = true ; private boolean doUpdate = false ; private boolean doFilesonly = false ; protected String archiveType = "zip" ; private static long emptyCrc = new CRC32 ( ) . getValue ( ) ; protected String emptyBehavior = "skip" ; private Vector filesets = new Vector ( ) ; private Hashtable addedDirs = new Hashtable ( ) ; private Vector addedFiles = new Vector ( ) ; private boolean addingNewFiles ; private String encoding = null ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean c ) { doCompress = c ; } public void setFilesonly ( boolean f ) { doFilesonly = f ; } public void setUpdate ( boolean c ) { doUpdate = c ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addZipfileset ( ZipFileSet set ) { filesets . addElement ( set ) ; } public static class WhenEmpty extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "fail" , "skip" , "create" } ; } } public void setWhenempty ( WhenEmpty we ) { emptyBehavior = we . getValue ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void execute ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 && "zip" . equals ( archiveType ) ) { throw new BuildException ( "basedir attribute must be set, or at least " + "one fileset must be given!" ) ; } if ( zipFile == null ) { throw new BuildException ( "You must specify the " + archiveType + " file to create!" ) ; } File renamedFile = null ; addingNewFiles = true ; boolean reallyDoUpdate = false ; if ( doUpdate && zipFile . exists ( ) ) { reallyDoUpdate = true ; int i ; for ( i = 0 ; i < 1000 ; i ++ ) { renamedFile = new File ( zipFile . getParent ( ) , "tmp." + i ) ; if ( ! renamedFile . exists ( ) ) { break ; } } if ( i == 1000 ) { throw new BuildException ( "Can't find available temporary filename to which to rename old file." ) ; } try { if ( ! zipFile . renameTo ( renamedFile ) ) { throw new BuildException ( "Unable to rename old file to temporary file" ) ; } } catch ( SecurityException e ) { throw new BuildException ( "Not allowed to rename old file to temporary file" ) ; } } Vector dss = new Vector ( ) ; if ( baseDir != null ) { dss . addElement ( getDirectoryScanner ( baseDir ) ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; dss . addElement ( fs . getDirectoryScanner ( project ) ) ; } int dssSize = dss . size ( ) ; FileScanner [ ] scanners = new FileScanner [ dssSize ] ; dss . copyInto ( scanners ) ; if ( isUpToDate ( scanners , zipFile ) ) { return ; } String action = reallyDoUpdate ? "Updating " : "Building " ; log ( action + archiveType + ": " + zipFile . getAbsolutePath ( ) ) ; boolean success = false ; try { ZipOutputStream zOut = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; zOut . setEncoding ( encoding ) ; try { if ( doCompress ) { zOut . setMethod ( ZipOutputStream . DEFLATED ) ; } else { zOut . setMethod ( ZipOutputStream . STORED ) ; } initZipOutputStream ( zOut ) ; if ( baseDir != null ) { addFiles ( getDirectoryScanner ( baseDir ) , zOut , "" , "" ) ; } addFiles ( filesets , zOut ) ; if ( reallyDoUpdate ) { addingNewFiles = false ; ZipFileSet oldFiles = new ZipFileSet ( ) ; oldFiles . setSrc ( renamedFile ) ; StringBuffer exclusionPattern = new StringBuffer ( ) ; for ( int i = 0 ; i < addedFiles . size ( ) ; i ++ ) { if ( i != 0 ) { exclusionPattern . append ( "," ) ; } exclusionPattern . append ( ( String ) addedFiles . elementAt ( i ) ) ; } oldFiles . setExcludes ( exclusionPattern . toString ( ) ) ; Vector tmp = new Vector ( ) ; tmp . addElement ( oldFiles ) ; addFiles ( tmp , zOut ) ; } finalizeZipOutputStream ( zOut ) ; success = true ; } finally { try { if ( zOut != null ) { zOut . close ( ) ; } } catch ( IOException ex ) { if ( success ) throw ex ; } } } catch ( IOException ioe ) { String msg = "Problem creating " + archiveType + ": " + ioe . getMessage ( ) ; if ( ! zipFile . delete ( ) ) { msg += " (and the archive is probably corrupt but I could not delete it)" ; } if ( reallyDoUpdate ) { if ( ! renamedFile . renameTo ( zipFile ) ) { msg += " (and I couldn't rename the temporary file " + renamedFile . getName ( ) + " back)" ; } } throw new BuildException ( msg , ioe , location ) ; } finally { cleanUp ( ) ; } if ( success && reallyDoUpdate ) { if ( ! renamedFile . delete ( ) ) { log ( "Warning: unable to delete temporary file " + renamedFile . getName ( ) , Project . MSG_WARN ) ; } } } protected boolean isAddingNewFiles ( ) { return addingNewFiles ; } protected void addFiles ( FileScanner scanner , ZipOutputStream zOut , String prefix , String fullpath ) throws IOException { if ( prefix . length ( ) > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "Both prefix and fullpath attributes may not be set on the same fileset." ) ; File thisBaseDir = scanner . getBasedir ( ) ; String [ ] dirs = scanner . getIncludedDirectories ( ) ; if ( dirs . length > 0 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( "" . equals ( dirs [ i ] ) ) { continue ; } String name = dirs [ i ] . replace ( File . separatorChar , '/' ) ; if ( ! name . endsWith ( "/" ) ) { name += "/" ; } addParentDirs ( thisBaseDir , name , zOut , prefix ) ; } String [ ] files = scanner . getIncludedFiles ( ) ; if ( files . length > 1 && fullpath . length ( ) > 0 ) throw new BuildException ( "fullpath attribute may only be specified for filesets that specify a single file." ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( thisBaseDir , files [ i ] ) ; if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; zipFile ( f , zOut , fullpath ) ; } else { String name = files [ i ] . replace ( File . separatorChar , '/' ) ; addParentDirs ( thisBaseDir , name , zOut , prefix ) ; zipFile ( f , zOut , prefix + name ) ; } } } protected void addZipEntries ( ZipFileSet fs , DirectoryScanner ds , ZipOutputStream zOut , String prefix ) throws IOException { ZipScanner zipScanner = ( ZipScanner ) ds ; File zipSrc = fs . getSrc ( ) ; ZipEntry entry ; java . util . zip . ZipEntry origEntry ; ZipInputStream in = null ; try { in = new ZipInputStream ( new FileInputStream ( zipSrc ) ) ; while ( ( origEntry = in . getNextEntry ( ) ) != null ) { entry = new ZipEntry ( origEntry ) ; String vPath = entry . getName ( ) ; if ( zipScanner . match ( vPath ) ) { addParentDirs ( null , vPath , zOut , prefix ) ; if ( ! entry . isDirectory ( ) ) { zipFile ( in , zOut , prefix + vPath , entry . getTime ( ) ) ; } } } } finally { if ( in != null ) { in . close ( ) ; } } } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { } protected boolean createEmptyZip ( File zipFile ) { log ( "Note: creating empty " + archiveType + " archive " + zipFile , Project . MSG_INFO ) ; try { OutputStream os = new FileOutputStream ( zipFile ) ; try { byte [ ] empty = new byte [ 22 ] ; empty [ 0 ] = 80 ; empty [ 1 ] = 75 ; empty [ 2 ] = 5 ; empty [ 3 ] = 6 ; os . write ( empty ) ; } finally { os . close ( ) ; } } catch ( IOException ioe ) { throw new BuildException ( "Could not create empty ZIP archive" , ioe , location ) ; } return true ; } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { String [ ] [ ] fileNames = grabFileNames ( scanners ) ; File [ ] files = grabFiles ( scanners , fileNames ) ; if ( files . length == 0 ) { if ( emptyBehavior . equals ( "skip" ) ) { log ( "Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included." , Project . MSG_WARN ) ; return true ; } else if ( emptyBehavior . equals ( "fail" ) ) { throw new BuildException ( "Cannot create " + archiveType + " archive " + zipFile + ": no files were included." , location ) ; } else { return createEmptyZip ( zipFile ) ; } } else { for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } } if ( ! zipFile . exists ( ) ) return false ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( zipFile . getAbsolutePath ( ) ) ; for ( int i = 0 ; i < scanners . length ; i ++ ) { if ( sfs . restrict ( fileNames [ i ] , scanners [ i ] . getBasedir ( ) , null , mm ) . length > 0 ) { return false ; } } return true ; } } protected static File [ ] grabFiles ( FileScanner [ ] scanners ) { return grabFiles ( scanners , grabFileNames ( scanners ) ) ; } protected static File [ ] grabFiles ( FileScanner [ ] scanners , String [ ] [ ] fileNames ) { Vector files = new Vector ( ) ; for ( int i = 0 ; i < fileNames . length ; i ++ ) { File thisBaseDir = scanners [ i ] . getBasedir ( ) ; for ( int j = 0 ; j < fileNames [ i ] . length ; j ++ ) files . addElement ( new File ( thisBaseDir , fileNames [ i ] [ j ] ) ) ; } File [ ] toret = new File [ files . size ( ) ] ; files . copyInto ( toret ) ; return toret ; } protected static String [ ] [ ] grabFileNames ( FileScanner [ ] scanners ) { String [ ] [ ] result = new String [ scanners . length ] [ ] ; for ( int i = 0 ; i < scanners . length ; i ++ ) { String [ ] files = scanners [ i ] . getIncludedFiles ( ) ; String [ ] dirs = scanners [ i ] . getIncludedDirectories ( ) ; result [ i ] = new String [ files . length + dirs . length ] ; System . arraycopy ( files , 0 , result [ i ] , 0 , files . length ) ; System . arraycopy ( dirs , 0 , result [ i ] , files . length , dirs . length ) ; } return result ; } protected void zipDir ( File dir , ZipOutputStream zOut , String vPath ) throws IOException { if ( addedDirs . get ( vPath ) != null ) { return ; } addedDirs . put ( vPath , vPath ) ; ZipEntry ze = new ZipEntry ( vPath ) ; if ( dir != null && dir . exists ( ) ) { ze . setTime ( dir . lastModified ( ) ) ; } else { ze . setTime ( System . currentTimeMillis ( ) ) ; } ze . setSize ( 0 ) ; ze . setMethod ( ZipEntry . STORED ) ; ze . setCrc ( emptyCrc ) ; ze . setExternalAttributes ( 0x41FD0010L ) ; zOut . putNextEntry ( ze ) ; } protected void zipFile ( InputStream in , ZipOutputStream zOut , String vPath , long lastModified ) throws IOException { ZipEntry ze = new ZipEntry ( vPath ) ; ze . setTime ( lastModified ) ; if ( ! doCompress ) { long size = 0 ; CRC32 cal = new CRC32 ( ) ; if ( ! in . markSupported ( ) ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; bos . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } else { in . mark ( Integer . MAX_VALUE ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { size += count ; cal . update ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . reset ( ) ; } ze . setSize ( size ) ; ze . setCrc ( cal . getValue ( ) ) ; } zOut . putNextEntry ( ze ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { if ( count != 0 ) { zOut . write ( buffer , 0 , count ) ; } count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; addedFiles . addElement ( vPath ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( file . equals ( zipFile ) ) { throw new BuildException ( "A zip file cannot include itself" , location ) ; } FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut , vPath , file . lastModified ( ) ) ; } finally { fIn . close ( ) ; } } protected void addParentDirs ( File baseDir , String entry , ZipOutputStream zOut , String prefix ) throws IOException { if ( ! doFilesonly ) { Stack directories = new Stack ( ) ; int slashPos = entry . length ( ) ; while ( ( slashPos = entry . lastIndexOf ( ( int ) '/' , slashPos - 1 ) ) != - 1 ) { String dir = entry . substring ( 0 , slashPos + 1 ) ; if ( addedDirs . get ( prefix + dir ) != null ) { break ; } directories . push ( dir ) ; } while ( ! directories . isEmpty ( ) ) { String dir = ( String ) directories . pop ( ) ; File f = null ; if ( baseDir != null ) { f = new File ( baseDir , dir ) ; } else { f = new File ( dir ) ; } zipDir ( f , zOut , prefix + dir ) ; } } } protected void addFiles ( Vector filesets , ZipOutputStream zOut ) throws IOException { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String prefix = "" ; String fullpath = "" ; if ( fs instanceof ZipFileSet ) { ZipFileSet zfs = ( ZipFileSet ) fs ; prefix = zfs . getPrefix ( ) ; fullpath = zfs . getFullpath ( ) ; } if ( prefix . length ( ) > 0 && ! prefix . endsWith ( "/" ) && ! prefix . endsWith ( "\\" ) ) { prefix += "/" ; } if ( prefix . length ( ) > 0 ) { addParentDirs ( null , prefix , zOut , "" ) ; zipDir ( null , zOut , prefix ) ; } else if ( fullpath . length ( ) > 0 ) { addParentDirs ( null , fullpath , zOut , "" ) ; } if ( fs instanceof ZipFileSet && ( ( ZipFileSet ) fs ) . getSrc ( ) != null ) { addZipEntries ( ( ZipFileSet ) fs , ds , zOut , prefix ) ; } else { addFiles ( ds , zOut , prefix , fullpath ) ; } } } protected void cleanUp ( ) { addedDirs = new Hashtable ( ) ; addedFiles = new Vector ( ) ; } } 	0	['28', '4', '1', '21', '123', '302', '3', '18', '11', '0.868945869', '1423', '1', '0', '0.75', '0.158024691', '4', '5', '49.35714286', '3', '1.1071', '0']
package org . apache . tools . zip ; public interface UnixStat { public static final int PERM_MASK = 07777 ; public static final int LINK_FLAG = 0120000 ; public static final int FILE_FLAG = 0100000 ; public static final int DIR_FLAG = 040000 ; public static final int DEFAULT_LINK_PERM = 0777 ; public static final int DEFAULT_DIR_PERM = 0755 ; public static final int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . regexp . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaRegexpMatcher implements RegexpMatcher { protected RE reg = null ; private String pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = pattern ; reg = new RE ( pattern ) ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern ; } public boolean matches ( String argument ) { return reg . match ( argument ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < reg . getParenCount ( ) ; i ++ ) { v . addElement ( reg . getParen ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '4', '13', '0', '0', '4', '5', '0.5', '65', '1', '0', '0', '0.8', '0', '0', '11.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; import java . io . * ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '7', '13', '1', '1', '6', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '150', '0', '0', '0.92', '0.5', '0', '0', '48', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; public class FileSet extends DataType { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . useDefaultExcludes = fileset . useDefaultExcludes ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExcludesFile ( ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for fileset." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; for ( int i = 0 ; i < additionalPatterns . size ( ) ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } p . log ( "FileSet: Setup file scanner in dir " + dir + " with " + defaultPatterns , p . MSG_DEBUG ) ; ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( useDefaultExcludes ) ds . addDefaultExcludes ( ) ; } protected FileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a fileset" ; throw new BuildException ( msg ) ; } else { return ( FileSet ) o ; } } } 	0	['18', '3', '2', '31', '62', '0', '23', '8', '16', '0.617647059', '396', '1', '1', '0.652173913', '0.215277778', '1', '1', '20.77777778', '5', '1.8889', '0']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private final static ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ( new ZipShort ( getMode ( ) ) ) . getBytes ( ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ( new ZipLong ( linkArray . length ) ) . getBytes ( ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ( new ZipShort ( getUserId ( ) ) ) . getBytes ( ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ( new ZipShort ( getGroupId ( ) ) ) . getBytes ( ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ( new ZipLong ( checksum ) ) . getBytes ( ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ( new ZipLong ( data , offset ) ) . getValue ( ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ( new ZipShort ( tmp , 0 ) ) . getValue ( ) ; byte [ ] linkArray = new byte [ ( int ) ( new ZipLong ( tmp , 2 ) ) . getValue ( ) ] ; uid = ( new ZipShort ( tmp , 6 ) ) . getValue ( ) ; gid = ( new ZipShort ( tmp , 8 ) ) . getValue ( ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	0	['20', '1', '0', '4', '42', '130', '0', '4', '18', '0.736842105', '376', '1', '1', '0', '0.284210526', '0', '0', '17.45', '3', '1.15', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Vector ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { super . setZipfile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['9', '6', '0', '8', '33', '28', '0', '8', '6', '0.8125', '163', '1', '0', '0.950617284', '0.4', '4', '9', '16.88888889', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import java . net . * ; import java . lang . reflect . * ; public class Launcher { static private File determineAntHome11 ( ) { String classpath = System . getProperty ( "java.class.path" ) ; StringTokenizer tokenizer = new StringTokenizer ( classpath , System . getProperty ( "path.separator" ) ) ; while ( tokenizer . hasMoreTokens ( ) ) { String path = tokenizer . nextToken ( ) ; if ( path . endsWith ( "ant.jar" ) ) { File antJarFile = new File ( path ) ; File libDirectory = new File ( antJarFile . getParent ( ) ) ; File antHome = new File ( libDirectory . getParent ( ) ) ; return antHome ; } } return null ; } static private File determineAntHome ( ClassLoader systemClassLoader ) { try { String className = Launcher . class . getName ( ) . replace ( '.' , '/' ) + ".class" ; URL classResource = systemClassLoader . getResource ( className ) ; String fileComponent = classResource . getFile ( ) ; if ( classResource . getProtocol ( ) . equals ( "file" ) ) { int classFileIndex = fileComponent . lastIndexOf ( className ) ; if ( classFileIndex != - 1 ) { fileComponent = fileComponent . substring ( 0 , classFileIndex ) ; } File classFilesDir = new File ( fileComponent ) ; File buildDir = new File ( classFilesDir . getParent ( ) ) ; File devAntHome = new File ( buildDir . getParent ( ) ) ; return devAntHome ; } else if ( classResource . getProtocol ( ) . equals ( "jar" ) ) { int classSeparatorIndex = fileComponent . lastIndexOf ( "!" ) ; if ( classSeparatorIndex != - 1 ) { fileComponent = fileComponent . substring ( 0 , classSeparatorIndex ) ; } URL antJarURL = new URL ( fileComponent ) ; File antJarFile = new File ( antJarURL . getFile ( ) ) ; File libDirectory = new File ( antJarFile . getParent ( ) ) ; File antHome = new File ( libDirectory . getParent ( ) ) ; return antHome ; } } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } return null ; } static private void addDirJars ( AntClassLoader classLoader , File jarDir ) { String [ ] fileList = jarDir . list ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ) ; if ( fileList != null ) { for ( int i = 0 ; i < fileList . length ; ++ i ) { File jarFile = new File ( jarDir , fileList [ i ] ) ; classLoader . addPathElement ( jarFile . getAbsolutePath ( ) ) ; } } } static private void addToolsJar ( AntClassLoader antLoader ) { String javaHome = System . getProperty ( "java.home" ) ; if ( javaHome . endsWith ( "jre" ) ) { javaHome = javaHome . substring ( 0 , javaHome . length ( ) - 4 ) ; } System . out . println ( "Java home is " + javaHome ) ; File toolsJar = new File ( javaHome , "lib/tools.jar" ) ; if ( ! toolsJar . exists ( ) ) { System . out . println ( "Unable to find tools.jar at " + toolsJar . getPath ( ) ) ; } else { antLoader . addPathElement ( toolsJar . getAbsolutePath ( ) ) ; } } static public void main ( String [ ] args ) { File antHome = null ; ClassLoader systemClassLoader = Launcher . class . getClassLoader ( ) ; if ( systemClassLoader == null ) { antHome = determineAntHome11 ( ) ; } else { antHome = determineAntHome ( systemClassLoader ) ; } if ( antHome == null ) { System . err . println ( "Unable to determine ANT_HOME" ) ; System . exit ( 1 ) ; } System . out . println ( "ANT_HOME is " + antHome ) ; AntClassLoader antLoader = new AntClassLoader ( systemClassLoader , false ) ; addToolsJar ( antLoader ) ; File libDir = new File ( antHome , "lib" ) ; addDirJars ( antLoader , libDir ) ; File optionalDir = new File ( antHome , "lib/optional" ) ; addDirJars ( antLoader , optionalDir ) ; Properties launchProperties = new Properties ( ) ; launchProperties . put ( "ant.home" , antHome . getAbsolutePath ( ) ) ; try { Class mainClass = antLoader . loadClass ( "org.apache.tools.ant.Main" ) ; antLoader . initializeClass ( mainClass ) ; final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) , Properties . class , ClassLoader . class } ; final Method startMethod = mainClass . getMethod ( "start" , param ) ; final Object [ ] argument = { args , launchProperties , systemClassLoader } ; startMethod . invoke ( null , argument ) ; } catch ( Exception e ) { System . out . println ( "Exception running Ant: " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } } 	0	['7', '1', '0', '2', '52', '19', '0', '2', '2', '0.944444444', '412', '0', '0', '0', '0.166666667', '0', '0', '57.42857143', '6', '3', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( p . getBaseDir ( ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } } 	0	['9', '5', '0', '11', '20', '4', '4', '7', '9', '0.6875', '108', '1', '0', '0.919191919', '0.388888889', '2', '7', '10.55555556', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class SignJar extends Task { protected String jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected String signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setJar ( final String jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final String signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && null == filesets ) { throw new BuildException ( "jar must be set through jar attribute or nested filesets" ) ; } if ( null != jar ) { doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( jarFiles [ j ] , null ) ; } } } } private void doOneJar ( String jarSource , String jarTarget ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The signjar task is only available on JDK versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) return ; final StringBuffer sb = new StringBuffer ( ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "jarsigner" ) ; if ( null != keystore ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + ( new File ( jarSource ) ) . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( String jarSource , String jarTarget ) { if ( null == jarSource ) { return false ; } if ( null != jarTarget ) { final File jarFile = new File ( jarSource ) ; final File signedjarFile = new File ( jarTarget ) ; if ( ! jarFile . exists ( ) ) return false ; if ( ! signedjarFile . exists ( ) ) return false ; if ( jarFile . equals ( signedjarFile ) ) return false ; if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) return true ; } else { if ( lazy ) { return isSigned ( jarSource ) ; } } return false ; } protected boolean isSigned ( String jarFilename ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; File file = new File ( jarFilename ) ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['18', '3', '0', '8', '55', '119', '0', '8', '15', '0.882352941', '474', '1', '0', '0.685185185', '0.472222222', '0', '0', '24.61111111', '13', '2', '0']
package org . apache . tools . ant ; import java . io . * ; public interface BuildLogger extends BuildListener { public void setMessageOutputLevel ( int level ) ; public void setOutputPrintStream ( PrintStream output ) ; public void setEmacsMode ( boolean emacsMode ) ; public void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '4', '4', '6', '3', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public interface ExecuteStreamHandler { public void setProcessInputStream ( OutputStream os ) throws IOException ; public void setProcessErrorStream ( InputStream is ) throws IOException ; public void setProcessOutputStream ( InputStream is ) throws IOException ; public void start ( ) throws IOException ; public void stop ( ) ; } 	0	['5', '1', '0', '10', '5', '10', '10', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class ExecuteWatchdog implements Runnable { private Process process ; private int timeout ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; public ExecuteWatchdog ( int timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; final Thread thread = new Thread ( this , "WATCHDOG" ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } public synchronized void stop ( ) { watch = false ; notifyAll ( ) ; } public synchronized void run ( ) { try { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( watch && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } try { process . exitValue ( ) ; } catch ( IllegalThreadStateException e ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['8', '1', '0', '6', '25', '0', '5', '1', '7', '0.6', '169', '1', '0', '0', '0.416666667', '0', '0', '19.5', '7', '1.875', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	0	['3', '1', '1', '6', '9', '0', '4', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . * ; public class Available extends Task implements Condition { private String property ; private String classname ; private File file ; private Path filepath ; private String resource ; private String type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( project ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { this . type = type ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , location ) ; } if ( eval ( ) ) { this . project . setProperty ( property , value ) ; } } public boolean eval ( ) throws BuildException { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|resource) is required" , location ) ; } if ( type != null ) { if ( ! type . equalsIgnoreCase ( "file" ) && ! type . equalsIgnoreCase ( "dir" ) ) { throw new BuildException ( "Type must be one of either dir or file" ) ; } } if ( classpath != null ) { classpath . setProject ( project ) ; this . loader = new AntClassLoader ( project , classpath ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { log ( "Unable to find " + file + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + " to set property " + property , Project . MSG_VERBOSE ) ; return false ; } if ( loader != null ) { loader . cleanup ( ) ; } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( file ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_VERBOSE ) ; if ( new File ( paths [ i ] , file . getName ( ) ) . isFile ( ) ) { return true ; } } } return false ; } private boolean checkFile ( File file ) { if ( type != null ) { if ( type . equalsIgnoreCase ( "dir" ) ) { return file . isDirectory ( ) ; } else if ( type . equalsIgnoreCase ( "file" ) ) { return file . isFile ( ) ; } } return file . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { l . loadClass ( classname ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { return false ; } catch ( NoClassDefFoundError e ) { return false ; } } } 	0	['18', '3', '0', '10', '49', '115', '1', '9', '14', '0.836601307', '397', '1', '3', '0.685185185', '0.333333333', '0', '0', '20.55555556', '6', '1.8333', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] result = new byte [ length ] ; int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '274', '0', '0', '0', '0.45', '0', '0', '33.25', '7', '2.875', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class Main { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private PrintStream out = System . out ; private PrintStream err = System . err ; private Vector targets = new Vector ( 5 ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 5 ) ; private String loggerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = null ; try { m = new Main ( args ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; m . definedProps . put ( key , property ) ; } } try { m . runBuild ( coreLoader ) ; System . exit ( 0 ) ; } catch ( BuildException be ) { if ( m . err != System . err ) { printMessage ( be ) ; } System . exit ( 1 ) ; } catch ( Throwable exc ) { printMessage ( exc ) ; System . exit ( 1 ) ; } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } protected Main ( String [ ] args ) throws BuildException { String searchForThis = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; out = new PrintStream ( new FileOutputStream ( logFile ) ) ; err = out ; System . setOut ( out ) ; System . setErr ( out ) ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write permissions." ; System . out . println ( msg ) ; return ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; System . out . println ( msg ) ; return ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) value = args [ ++ i ] ; definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { System . out . println ( "Only one logger class may be specified." ) ; return ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { System . out . println ( "You must specify a classname when " + "using the -logger argument" ) ; return ; } } else if ( arg . equals ( "-emacs" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; return ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; SecurityManager oldsm = System . getSecurityManager ( ) ; try { System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; project . fireBuildStarted ( ) ; project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; String noParserMessage = "No JAXP compliant XML parser found. Please visit http://xml.apache.org for a suitable parser" ; try { Class . forName ( "javax.xml.parsers.SAXParserFactory" ) ; ProjectHelper . configureProject ( project , buildFile ) ; } catch ( NoClassDefFoundError ncdfe ) { throw new BuildException ( noParserMessage , ncdfe ) ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( noParserMessage , cnfe ) ; } catch ( NullPointerException npe ) { throw new BuildException ( noParserMessage , npe ) ; } if ( targets . size ( ) == 0 ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } if ( ! projectHelp ) { project . executeTargets ( targets ) ; } } finally { System . setOut ( out ) ; System . setErr ( err ) ; } if ( projectHelp ) { printDescription ( project ) ; printTargets ( project ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { project . fireBuildFinished ( error ) ; } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { logger = ( BuildLogger ) ( Class . forName ( loggerClassname ) . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help                  print this message" + lSep ) ; msg . append ( "  -projecthelp           print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -quiet                 be extra quiet" + lSep ) ; msg . append ( "  -verbose               be extra verbose" + lSep ) ; msg . append ( "  -debug                 print debugging information" + lSep ) ; msg . append ( "  -emacs                 produce logging information without adornments" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -find <file>           search for buildfile towards the root of the" + lSep ) ; msg . append ( "                         filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public synchronized static String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { System . out . println ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { Vector defaultName = new Vector ( ) ; Vector defaultDesc = null ; defaultName . addElement ( defaultTarget ) ; int indexOfDefDesc = topNames . indexOf ( defaultTarget ) ; if ( indexOfDefDesc >= 0 ) { defaultDesc = new Vector ( ) ; defaultDesc . addElement ( topDescriptions . elementAt ( indexOfDefDesc ) ) ; } printTargets ( defaultName , defaultDesc , "Default target:" , maxLength ) ; } printTargets ( topNames , topDescriptions , "Main targets:" , maxLength ) ; printTargets ( subNames , null , "Subtargets:" , 0 ) ; } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) < maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } System . out . println ( msg . toString ( ) ) ; } } 	0	['18', '1', '0', '8', '91', '123', '0', '8', '3', '0.806722689', '1400', '0.857142857', '0', '0', '0.141176471', '0', '0', '76', '7', '2.1111', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . File ; public class Mkdir extends Task { private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , location ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = dir . mkdirs ( ) ; if ( result == false ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , location ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } } 	0	['3', '3', '0', '3', '14', '1', '0', '3', '3', '0.5', '84', '1', '0', '0.948717949', '0.666666667', '1', '1', '26.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { public void setFrom ( String from ) ; public void setTo ( String to ) ; public String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '17', '3', '3', '17', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; import java . util . * ; public class FixCRLF extends MatchingTask { private static final int UNDEF = - 1 ; private static final int NOTJAVA = 0 ; private static final int LOOKING = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int ASIS = 0 ; private static final int CR = 1 ; private static final int LF = 2 ; private static final int CRLF = 3 ; private static final int ADD = 1 ; private static final int REMOVE = - 1 ; private static final int SPACES = - 1 ; private static final int TABS = 1 ; private static final int INBUFLEN = 8192 ; private static final int LINEBUFLEN = 200 ; private static final char CTRLZ = '' ; private int tablength = 8 ; private String spaces = "        " ; private StringBuffer linebuf = new StringBuffer ( 1024 ) ; private StringBuffer linebuf2 = new StringBuffer ( 1024 ) ; private int eol ; private String eolstr ; private int ctrlz ; private int tabs ; private boolean javafiles = false ; private File srcDir ; private File destDir = null ; public FixCRLF ( ) { tabs = ASIS ; if ( System . getProperty ( "path.separator" ) . equals ( ":" ) ) { ctrlz = REMOVE ; if ( System . getProperty ( "os.name" ) . indexOf ( "Mac" ) > - 1 ) { eol = CR ; eolstr = "\r" ; } else { eol = LF ; eolstr = "\n" ; } } else { ctrlz = ASIS ; eol = CRLF ; eolstr = "\r\n" ; } } public void setSrcdir ( File srcDir ) { this . srcDir = srcDir ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setEol ( CrLf attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "asis" ) ) { eol = ASIS ; } else if ( option . equals ( "cr" ) ) { eol = CR ; eolstr = "\r" ; } else if ( option . equals ( "lf" ) ) { eol = LF ; eolstr = "\n" ; } else { eol = CRLF ; eolstr = "\r\n" ; } } public void setCr ( AddAsisRemove attr ) { log ( "DEPRECATED: The cr attribute has been deprecated," , Project . MSG_WARN ) ; log ( "Please us the eol attribute instead" , Project . MSG_WARN ) ; String option = attr . getValue ( ) ; CrLf c = new CrLf ( ) ; if ( option . equals ( "remove" ) ) { c . setValue ( "lf" ) ; } else if ( option . equals ( "asis" ) ) { c . setValue ( "asis" ) ; } else { c . setValue ( "crlf" ) ; } setEol ( c ) ; } public void setTab ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { tabs = SPACES ; } else if ( option . equals ( "asis" ) ) { tabs = ASIS ; } else { tabs = TABS ; } } public void setTablength ( int tlength ) throws BuildException { if ( tlength < 2 || tlength > 80 ) { throw new BuildException ( "tablength must be between 2 and 80" , location ) ; } tablength = tlength ; StringBuffer sp = new StringBuffer ( ) ; for ( int i = 0 ; i < tablength ; i ++ ) { sp . append ( ' ' ) ; } spaces = sp . toString ( ) ; } public void setEof ( AddAsisRemove attr ) { String option = attr . getValue ( ) ; if ( option . equals ( "remove" ) ) { ctrlz = REMOVE ; } else if ( option . equals ( "asis" ) ) { ctrlz = ASIS ; } else { ctrlz = ADD ; } } public void execute ( ) throws BuildException { if ( srcDir == null ) { throw new BuildException ( "srcdir attribute must be set!" ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir does not exist!" ) ; } if ( ! srcDir . isDirectory ( ) ) { throw new BuildException ( "srcdir is not a directory!" ) ; } if ( destDir != null ) { if ( ! destDir . exists ( ) ) { throw new BuildException ( "destdir does not exist!" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destdir is not a directory!" ) ; } } log ( "options:" + " eol=" + ( eol == ASIS ? "asis" : eol == CR ? "cr" : eol == LF ? "lf" : "crlf" ) + " tab=" + ( tabs == TABS ? "add" : tabs == ASIS ? "asis" : "remove" ) + " eof=" + ( ctrlz == ADD ? "add" : ctrlz == ASIS ? "asis" : "remove" ) + " tablength=" + tablength , Project . MSG_VERBOSE ) ; DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { processFile ( files [ i ] ) ; } } private File createTempFile ( ) { String name = "fixcrlf" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; if ( destDir == null ) { return new File ( srcDir , name ) ; } else { return new File ( destDir , name ) ; } } private boolean filesEqual ( File file1 , File file2 ) { BufferedReader reader1 ; BufferedReader reader2 ; char buf1 [ ] = new char [ INBUFLEN ] ; char buf2 [ ] = new char [ INBUFLEN ] ; int buflen ; if ( file1 . length ( ) != file2 . length ( ) ) { return false ; } try { reader1 = new BufferedReader ( new FileReader ( file1 ) , INBUFLEN ) ; reader2 = new BufferedReader ( new FileReader ( file2 ) , INBUFLEN ) ; while ( ( buflen = reader1 . read ( buf1 , 0 , INBUFLEN ) ) != - 1 ) { reader2 . read ( buf2 , 0 , INBUFLEN ) ; for ( int i = 0 ; i < buflen ; i ++ ) { if ( buf1 [ i ] != buf2 [ i ] ) { reader1 . close ( ) ; reader2 . close ( ) ; return false ; } } } reader1 . close ( ) ; reader2 . close ( ) ; return true ; } catch ( IOException e ) { throw new BuildException ( "IOException in filesEqual: " + file1 + " : " + file2 ) ; } } private void processFile ( String file ) throws BuildException { File srcFile = new File ( srcDir , file ) ; File tmpFile = null ; BufferedWriter outWriter ; OneLiner . BufferLine line ; OneLiner lines = new OneLiner ( srcFile ) ; try { try { tmpFile = createTempFile ( ) ; FileWriter writer = new FileWriter ( tmpFile ) ; outWriter = new BufferedWriter ( writer ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } while ( lines . hasMoreElements ( ) ) { int endComment ; try { line = ( OneLiner . BufferLine ) lines . nextElement ( ) ; } catch ( NoSuchElementException e ) { throw new BuildException ( e ) ; } String lineString = line . getLineString ( ) ; int linelen = line . length ( ) ; if ( tabs == ASIS ) { try { outWriter . write ( lineString ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int ptr ; while ( ( ptr = line . getNext ( ) ) < linelen ) { switch ( lines . getState ( ) ) { case NOTJAVA : notInConstant ( line , line . length ( ) , outWriter ) ; break ; case IN_MULTI_COMMENT : if ( ( endComment = lineString . indexOf ( "*/" , line . getNext ( ) ) ) >= 0 ) { endComment += 2 ; lines . setState ( LOOKING ) ; } else { endComment = linelen ; } notInConstant ( line , endComment , outWriter ) ; break ; case IN_SINGLE_COMMENT : notInConstant ( line , line . length ( ) , outWriter ) ; lines . setState ( LOOKING ) ; break ; case IN_CHAR_CONST : case IN_STR_CONST : int begin = line . getNext ( ) ; char terminator = ( lines . getState ( ) == IN_STR_CONST ? '\"' : '\'' ) ; endOfCharConst ( line , terminator ) ; while ( line . getNext ( ) < line . getLookahead ( ) ) { if ( line . getNextCharInc ( ) == '\t' ) { line . setColumn ( line . getColumn ( ) + tablength - line . getColumn ( ) % tablength ) ; } else { line . incColumn ( ) ; } } try { outWriter . write ( line . substring ( begin , line . getNext ( ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } lines . setState ( LOOKING ) ; break ; case LOOKING : nextStateChange ( line ) ; notInConstant ( line , line . getLookahead ( ) , outWriter ) ; break ; } } } try { outWriter . write ( eolstr ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } try { if ( ctrlz == ASIS ) { outWriter . write ( lines . getEofStr ( ) ) ; } else if ( ctrlz == ADD ) { outWriter . write ( CTRLZ ) ; } outWriter . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } File destFile = new File ( destDir == null ? srcDir : destDir , file ) ; try { lines . close ( ) ; lines = null ; } catch ( IOException e ) { throw new BuildException ( "Unable to close source file " + srcFile ) ; } if ( destFile . exists ( ) ) { log ( "destFile exists" , Project . MSG_DEBUG ) ; if ( ! filesEqual ( destFile , tmpFile ) ) { log ( destFile + " is being written" , Project . MSG_DEBUG ) ; if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + destFile ) ; } if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } else { log ( destFile + " is not written, as the contents are identical" , Project . MSG_DEBUG ) ; if ( ! tmpFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + tmpFile ) ; } } } else { log ( "destFile does not exist" , Project . MSG_DEBUG ) ; if ( ! tmpFile . renameTo ( destFile ) ) { throw new BuildException ( "Failed to transform " + srcFile + " to " + destFile + ". Couldn't rename temporary file: " + tmpFile ) ; } } tmpFile = null ; } finally { try { if ( lines != null ) { lines . close ( ) ; } } catch ( IOException io ) { log ( "Error closing " + srcFile , Project . MSG_ERR ) ; } if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private void nextStateChange ( OneLiner . BufferLine bufline ) throws BuildException { int eol = bufline . length ( ) ; int ptr = bufline . getNext ( ) ; while ( ptr < eol ) { switch ( bufline . getChar ( ptr ++ ) ) { case '\'' : bufline . setState ( IN_CHAR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '\"' : bufline . setState ( IN_STR_CONST ) ; bufline . setLookahead ( -- ptr ) ; return ; case '/' : if ( ptr < eol ) { if ( bufline . getChar ( ptr ) == '*' ) { bufline . setState ( IN_MULTI_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } else if ( bufline . getChar ( ptr ) == '/' ) { bufline . setState ( IN_SINGLE_COMMENT ) ; bufline . setLookahead ( -- ptr ) ; return ; } } break ; } } bufline . setLookahead ( ptr ) ; } private void endOfCharConst ( OneLiner . BufferLine bufline , char terminator ) throws BuildException { int ptr = bufline . getNext ( ) ; int eol = bufline . length ( ) ; char c ; ptr ++ ; while ( ptr < eol ) { if ( ( c = bufline . getChar ( ptr ++ ) ) == '\\' ) { ptr ++ ; } else { if ( c == terminator ) { bufline . setLookahead ( ptr ) ; return ; } } } throw new BuildException ( "endOfCharConst: unterminated char constant" ) ; } private void notInConstant ( OneLiner . BufferLine bufline , int end , BufferedWriter outWriter ) { int nextTab ; int nextStop ; int tabspaces ; String line = bufline . substring ( bufline . getNext ( ) , end ) ; int place = 0 ; int col = bufline . getColumn ( ) ; linebuf . setLength ( 0 ) ; while ( ( nextTab = line . indexOf ( ( int ) '\t' , place ) ) >= 0 ) { linebuf . append ( line . substring ( place , nextTab ) ) ; col += nextTab - place ; tabspaces = tablength - ( col % tablength ) ; linebuf . append ( spaces . substring ( 0 , tabspaces ) ) ; col += tabspaces ; place = nextTab + 1 ; } linebuf . append ( line . substring ( place , line . length ( ) ) ) ; String linestring = new String ( linebuf . toString ( ) ) ; if ( tabs == REMOVE ) { try { outWriter . write ( linestring ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } else { int tabCol ; linebuf2 . setLength ( 0 ) ; place = 0 ; col = bufline . getColumn ( ) ; int placediff = col - 0 ; nextStop = col + ( tablength - col % tablength ) ; if ( nextStop - col < 2 ) { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; place = nextStop - placediff ; nextStop += tablength ; } for ( ; nextStop - placediff <= linestring . length ( ) ; nextStop += tablength ) { for ( tabCol = nextStop ; -- tabCol - placediff >= place && linestring . charAt ( tabCol - placediff ) == ' ' ; ) { ; } if ( nextStop - tabCol > 2 ) { linebuf2 . append ( linestring . substring ( place , ++ tabCol - placediff ) ) ; linebuf2 . append ( '\t' ) ; } else { linebuf2 . append ( linestring . substring ( place , nextStop - placediff ) ) ; } place = nextStop - placediff ; } linebuf2 . append ( linestring . substring ( place , linestring . length ( ) ) ) ; try { outWriter . write ( linebuf2 . toString ( ) ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } bufline . setColumn ( bufline . getColumn ( ) + linestring . length ( ) ) ; bufline . setNext ( end ) ; } class OneLiner implements Enumeration { private int state = javafiles ? LOOKING : NOTJAVA ; private StringBuffer eolStr = new StringBuffer ( LINEBUFLEN ) ; private StringBuffer eofStr = new StringBuffer ( ) ; private BufferedReader reader ; private String line ; public OneLiner ( File srcFile ) throws BuildException { try { reader = new BufferedReader ( new FileReader ( srcFile ) , INBUFLEN ) ; nextLine ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } protected void nextLine ( ) throws BuildException { int ch ; int eolcount = 0 ; eolStr . setLength ( 0 ) ; try { int linelen ; reader . mark ( INBUFLEN ) ; line = reader . readLine ( ) ; if ( line == null ) { linelen = 0 ; } else { linelen = line . length ( ) ; } reader . reset ( ) ; reader . skip ( ( long ) linelen ) ; reader . mark ( INBUFLEN ) ; ch = reader . read ( ) ; switch ( ( char ) ch ) { case '\r' : ++ eolcount ; eolStr . append ( '\r' ) ; switch ( ( char ) ( ch = reader . read ( ) ) ) { case '\r' : if ( ( char ) ( ch = reader . read ( ) ) == '\n' ) { eolcount += 2 ; eolStr . append ( "\r\n" ) ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } break ; case '\n' : ++ eolcount ; eolStr . append ( '\n' ) ; break ; } reader . reset ( ) ; reader . skip ( ( long ) eolcount ) ; if ( line != null && eolcount == 0 ) { int i = linelen ; while ( -- i >= 0 && line . charAt ( i ) == CTRLZ ) { } if ( i < linelen - 1 ) { eofStr . append ( line . substring ( i + 1 ) ) ; line = i < 0 ? null : line . substring ( 0 , i + 1 ) ; } } } catch ( IOException e ) { throw new BuildException ( e ) ; } } public String getEofStr ( ) { return eofStr . toString ( ) ; } public int getState ( ) { return state ; } public void setState ( int state ) { this . state = state ; } public boolean hasMoreElements ( ) { return line != null ; } public Object nextElement ( ) throws NoSuchElementException { if ( ! hasMoreElements ( ) ) { throw new NoSuchElementException ( "OneLiner" ) ; } BufferLine tmpLine = new BufferLine ( line , eolStr . toString ( ) ) ; nextLine ( ) ; return tmpLine ; } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } class BufferLine { private int next = 0 ; private int column = 0 ; private int lookahead = UNDEF ; private String line ; private String eolStr ; public BufferLine ( String line , String eolStr ) throws BuildException { next = 0 ; column = 0 ; this . line = line ; this . eolStr = eolStr ; } public int getNext ( ) { return next ; } public void setNext ( int next ) { this . next = next ; } public int getLookahead ( ) { return lookahead ; } public void setLookahead ( int lookahead ) { this . lookahead = lookahead ; } public char getChar ( int i ) { return line . charAt ( i ) ; } public char getNextChar ( ) { return getChar ( next ) ; } public char getNextCharInc ( ) { return getChar ( next ++ ) ; } public int getColumn ( ) { return column ; } public void setColumn ( int col ) { column = col ; } public int incColumn ( ) { return column ++ ; } public int length ( ) { return line . length ( ) ; } public int getEolLength ( ) { return eolStr . length ( ) ; } public String getLineString ( ) { return line ; } public String getEol ( ) { return eolStr ; } public String substring ( int begin ) { return line . substring ( begin ) ; } public String substring ( int begin , int end ) { return line . substring ( begin , end ) ; } public void setState ( int state ) { OneLiner . this . setState ( state ) ; } public int getState ( ) { return OneLiner . this . getState ( ) ; } } } public static class AddAsisRemove extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } } public static class CrLf extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" } ; } } } 	0	['17', '4', '0', '10', '83', '70', '1', '10', '10', '0.965517241', '1273', '1', '0', '0.829787234', '0.176470588', '2', '2', '72.17647059', '8', '2.1765', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public class DocletInfo { private String name ; private Path path ; private Vector params = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } public static class PackageName { private String name ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String toString ( ) { return getName ( ) ; } } public static class SourceFile { private File file ; public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } } public static class Html { private StringBuffer text = new StringBuffer ( ) ; public void addText ( String t ) { text . append ( t ) ; } public String getText ( ) { return text . toString ( ) ; } } public static class AccessType extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "protected" , "public" , "package" , "private" } ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { project . log ( this , "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add11ArgIf ( boolean b , String arg ) { if ( javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean foundJavaFile = false ; private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private Vector sourceFiles = new Vector ( ) ; private Vector packageNames = new Vector ( 5 ) ; private Vector excludePackageNames = new Vector ( 1 ) ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private Vector compileList = new Vector ( 10 ) ; private String packageList = null ; private Vector links = new Vector ( 2 ) ; private Vector groups = new Vector ( 2 ) ; private boolean useDefaultExcludes = true ; private Html doctitle = null ; private Html header = null ; private Html footer = null ; private Html bottom = null ; private boolean useExternalFile = false ; private File tmpList = null ; public void setUseExternalFile ( boolean b ) { if ( ! javadoc1 ) { useExternalFile = b ; } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( project ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String f = tok . nextToken ( ) ; SourceFile sf = new SourceFile ( ) ; sf . setFile ( project . resolveFile ( f ) ) ; addSource ( sf ) ; } } public void addSource ( SourceFile sf ) { sourceFiles . addElement ( sf ) ; } public void setPackagenames ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packageNames . addElement ( pn ) ; } public void setExcludePackageNames ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addExcludePackage ( pn ) ; } } public void addExcludePackage ( PackageName pn ) { excludePackageNames . addElement ( pn ) ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setAccess ( AccessType at ) { cmd . createArgument ( ) . setValue ( "-" + at . getValue ( ) ) ; } public void setDoclet ( String src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setName ( src ) ; } public void setDocletPath ( Path src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setPath ( src ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void setOld ( boolean b ) { add12ArgIf ( b , "-1.1" ) ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-locale" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean src ) { version = src ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean src ) { author = src ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String src ) { add12ArgIfNotEmpty ( "-windowtitle" , src ) ; } public void setDoctitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addDoctitle ( h ) ; } public void addDoctitle ( Html text ) { if ( ! javadoc1 ) { doctitle = text ; } } public void setHeader ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addHeader ( h ) ; } public void addHeader ( Html text ) { if ( ! javadoc1 ) { header = text ; } } public void setFooter ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addFooter ( h ) ; } public void addFooter ( Html text ) { if ( ! javadoc1 ) { footer = text ; } } public void setBottom ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addBottom ( h ) ; } public void addBottom ( Html text ) { if ( ! javadoc1 ) { bottom = text ; } } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include a URL and " + "a package-list file location separated by a space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( project . resolveFile ( tok . nextToken ( ) ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { packageList = src ; } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private File packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( File src ) { packagelistLoc = src ; } public File getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private Html title ; private Vector packages = new Vector ( 3 ) ; public GroupArgument ( ) { } public void setTitle ( String src ) { Html h = new Html ( ) ; h . addText ( src ) ; addTitle ( h ) ; } public void addTitle ( Html text ) { title = text ; } public String getTitle ( ) { return title != null ? title . getText ( ) : null ; } public void setPackages ( String src ) { StringTokenizer tok = new StringTokenizer ( src , "," ) ; while ( tok . hasMoreTokens ( ) ) { String p = tok . nextToken ( ) ; PackageName pn = new PackageName ( ) ; pn . setName ( p ) ; addPackage ( pn ) ; } } public void addPackage ( PackageName pn ) { packages . addElement ( pn ) ; } public String getPackages ( ) { StringBuffer p = new StringBuffer ( ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { p . append ( ":" ) ; } p . append ( packages . elementAt ( i ) . toString ( ) ) ; } return p . toString ( ) ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( taskType ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } if ( sourcePath == null ) { String msg = "sourcePath attribute must be set!" ; throw new BuildException ( msg ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; if ( doctitle != null ) { cmd . createArgument ( ) . setValue ( "-doctitle" ) ; cmd . createArgument ( ) . setValue ( expand ( doctitle . getText ( ) ) ) ; } if ( header != null ) { cmd . createArgument ( ) . setValue ( "-header" ) ; cmd . createArgument ( ) . setValue ( expand ( header . getText ( ) ) ) ; } if ( footer != null ) { cmd . createArgument ( ) . setValue ( "-footer" ) ; cmd . createArgument ( ) . setValue ( expand ( footer . getText ( ) ) ) ; } if ( bottom != null ) { cmd . createArgument ( ) . setValue ( "-bottom" ) ; cmd . createArgument ( ) . setValue ( expand ( bottom . getText ( ) ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( getJavadocExecutableName ( ) ) ; if ( classpath == null ) classpath = Path . systemClasspath ; else classpath = classpath . concatSystemClasspath ( "ignore" ) ; if ( ! javadoc1 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourcePath ) ; } else { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setValue ( sourcePath . toString ( ) + System . getProperty ( "path.separator" ) + classpath . toString ( ) ) ; } if ( version && doclet == null ) toExecute . createArgument ( ) . setValue ( "-version" ) ; if ( author && doclet == null ) toExecute . createArgument ( ) . setValue ( "-author" ) ; if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be specified." , location ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( doclet . getPath ( ) ) ; } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null ) { throw new BuildException ( "Links must provide the URL to the external class documentation." ) ; } if ( la . isLinkOffline ( ) ) { File packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list location for link " + la . getHref ( ) + " must be provided because the link is offline" ) ; } File packageList = new File ( packageListLocation , "package-list" ) ; if ( packageList . exists ( ) ) { toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListLocation . getAbsolutePath ( ) ) ; } else { log ( "Warning: No package list was found at " + packageListLocation , Project . MSG_VERBOSE ) ; } } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must be specified for group elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( expand ( title ) ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } } tmpList = null ; if ( packageNames . size ( ) > 0 ) { Vector packages = new Vector ( ) ; Enumeration enum = packageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName pn = ( PackageName ) enum . nextElement ( ) ; String name = pn . getName ( ) . trim ( ) ; if ( name . endsWith ( ".*" ) ) { packages . addElement ( name ) ; } else { toExecute . createArgument ( ) . setValue ( name ) ; } } Vector excludePackages = new Vector ( ) ; if ( excludePackageNames . size ( ) > 0 ) { enum = excludePackageNames . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PackageName pn = ( PackageName ) enum . nextElement ( ) ; excludePackages . addElement ( pn . getName ( ) . trim ( ) ) ; } } if ( packages . size ( ) > 0 ) { evaluatePackages ( toExecute , sourcePath , packages , excludePackages ) ; } } if ( sourceFiles . size ( ) > 0 ) { PrintWriter srcListWriter = null ; try { if ( useExternalFile ) { if ( tmpList == null ) { tmpList = createTempFile ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; } srcListWriter = new PrintWriter ( new FileWriter ( tmpList . getAbsolutePath ( ) , true ) ) ; } Enumeration enum = sourceFiles . elements ( ) ; while ( enum . hasMoreElements ( ) ) { SourceFile sf = ( SourceFile ) enum . nextElement ( ) ; String sourceFileName = sf . getFile ( ) . getAbsolutePath ( ) ; if ( useExternalFile ) { srcListWriter . println ( sourceFileName ) ; } else { toExecute . createArgument ( ) . setValue ( sourceFileName ) ; } } } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e , location ) ; } finally { if ( srcListWriter != null ) { srcListWriter . close ( ) ; } } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( "Javadoc args: " + toExecute , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( null ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , location ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , location ) ; } finally { if ( tmpList != null ) { tmpList . delete ( ) ; tmpList = null ; } out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void evaluatePackages ( Commandline toExecute , Path sourcePath , Vector packages , Vector excludePackages ) { log ( "Source path = " + sourcePath . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer msg = new StringBuffer ( "Packages = " ) ; for ( int i = 0 ; i < packages . size ( ) ; i ++ ) { if ( i > 0 ) { msg . append ( "," ) ; } msg . append ( packages . elementAt ( i ) ) ; } log ( msg . toString ( ) , Project . MSG_VERBOSE ) ; msg . setLength ( 0 ) ; msg . append ( "Exclude Packages = " ) ; for ( int i = 0 ; i < excludePackages . size ( ) ; i ++ ) { if ( i > 0 ) { msg . append ( "," ) ; } msg . append ( excludePackages . elementAt ( i ) ) ; } log ( msg . toString ( ) , Project . MSG_VERBOSE ) ; Vector addedPackages = new Vector ( ) ; String [ ] list = sourcePath . list ( ) ; if ( list == null ) list = new String [ 0 ] ; FileSet fs = new FileSet ( ) ; fs . setDefaultexcludes ( useDefaultExcludes ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createInclude ( ) . setName ( pkg ) ; } e = excludePackages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createExclude ( ) . setName ( pkg ) ; } PrintWriter packageListWriter = null ; try { if ( useExternalFile ) { tmpList = createTempFile ( ) ; toExecute . createArgument ( ) . setValue ( "@" + tmpList . getAbsolutePath ( ) ) ; packageListWriter = new PrintWriter ( new FileWriter ( tmpList ) ) ; } for ( int j = 0 ; j < list . length ; j ++ ) { File source = project . resolveFile ( list [ j ] ) ; fs . setDir ( source ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] packageDirs = ds . getIncludedDirectories ( ) ; for ( int i = 0 ; i < packageDirs . length ; i ++ ) { File pd = new File ( source , packageDirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { String pkgDir = packageDirs [ i ] . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; if ( ! addedPackages . contains ( pkgDir ) ) { if ( useExternalFile ) { packageListWriter . println ( pkgDir ) ; } else { toExecute . createArgument ( ) . setValue ( pkgDir ) ; } addedPackages . addElement ( pkgDir ) ; } } } } } catch ( IOException ioex ) { throw new BuildException ( "Error creating temporary file" , ioex , location ) ; } finally { if ( packageListWriter != null ) { packageListWriter . close ( ) ; } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; else super . processLine ( queuedLine , Project . MSG_INFO ) ; queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } protected String expand ( String content ) { return ProjectHelper . replaceProperties ( project , content , project . getProperties ( ) ) ; } private File createTempFile ( ) { return new File ( "javadoc" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; } private String getJavadocExecutableName ( ) { String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; boolean dosBased = os . indexOf ( "windows" ) >= 0 || os . indexOf ( "os/2" ) >= 0 ; String extension = dosBased ? ".exe" : "" ; File jdocExecutable = new File ( System . getProperty ( "java.home" ) + "/../bin/javadoc" + extension ) ; if ( jdocExecutable . exists ( ) ) { return jdocExecutable . getAbsolutePath ( ) ; } else { log ( "Unable to locate " + jdocExecutable . getAbsolutePath ( ) + ". Using \"javadoc\" instead." , Project . MSG_VERBOSE ) ; return "javadoc" ; } } } 	0	['77', '3', '0', '28', '196', '2320', '6', '28', '68', '0.935222672', '2040', '1', '9', '0.330357143', '0.161184211', '3', '3', '25.15584416', '19', '1.7143', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { public ZipShort getHeaderId ( ) ; public ZipShort getLocalFileDataLength ( ) ; public ZipShort getCentralDirectoryLength ( ) ; public byte [ ] getLocalFileDataData ( ) ; public byte [ ] getCentralDirectoryData ( ) ; public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . File ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( replace && dest . exists ( ) ) { if ( ! dest . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + dest ) ; } } if ( ! src . renameTo ( dest ) ) { throw new BuildException ( "Unable to rename " + src + " to " + dest ) ; } } } 	0	['5', '3', '0', '4', '17', '0', '0', '4', '5', '0.666666667', '101', '1', '0', '0.902439024', '0.533333333', '1', '1', '18.6', '1', '0.8', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '12', '15', '13', '9', '4', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . zip . * ; import java . io . * ; import java . util . Enumeration ; public class Jar extends Zip { private File manifestFile ; private Manifest manifest ; private Manifest execManifest ; private boolean buildFileManifest = false ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; } public void setJarfile ( File jarFile ) { super . setZipfile ( jarFile ) ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } manifest . merge ( newManifest ) ; buildFileManifest = true ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; InputStream is = null ; try { is = new FileInputStream ( manifestFile ) ; Manifest newManifest = new Manifest ( is ) ; if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } manifest . merge ( newManifest ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile , e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { try { if ( manifest == null ) { execManifest = null ; } else { execManifest = new Manifest ( ) ; execManifest . merge ( manifest ) ; } zipDir ( null , zOut , "META-INF/" ) ; super . initZipOutputStream ( zOut ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private Manifest getDefaultManifest ( ) { try { String s = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = this . getClass ( ) . getResourceAsStream ( s ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + s ) ; } return new Manifest ( in ) ; } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( execManifest == null ) { execManifest = getDefaultManifest ( ) ; } for ( Enumeration e = execManifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( baos ) ; execManifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , "META-INF/MANIFEST.MF" , System . currentTimeMillis ( ) ) ; super . finalizeZipOutputStream ( zOut ) ; } private void zipManifestEntry ( InputStream is ) throws IOException { try { if ( execManifest == null ) { execManifest = new Manifest ( is ) ; } else if ( isAddingNewFiles ( ) ) { execManifest . merge ( new Manifest ( is ) ) ; } } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { InputStream is = null ; try { is = new FileInputStream ( file ) ; zipManifestEntry ( is ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + file , e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { try { zipManifestEntry ( is ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " , e ) ; } } else { super . zipFile ( is , zOut , vPath , lastModified ) ; } } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { if ( buildFileManifest || manifestFile == null ) { java . util . zip . ZipFile theZipFile = null ; try { theZipFile = new java . util . zip . ZipFile ( zipFile ) ; java . util . zip . ZipEntry entry = theZipFile . getEntry ( "META-INF/MANIFEST.MF" ) ; if ( entry == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; return false ; } Manifest currentManifest = new Manifest ( theZipFile . getInputStream ( entry ) ) ; if ( manifest == null ) { manifest = getDefaultManifest ( ) ; } if ( ! currentManifest . equals ( manifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; return false ; } } catch ( Exception e ) { log ( "Updating jar since cannot read current jar manifest: " + e . getClass ( ) . getName ( ) + e . getMessage ( ) , Project . MSG_VERBOSE ) ; return false ; } finally { if ( theZipFile != null ) { try { theZipFile . close ( ) ; } catch ( IOException e ) { } } } } else if ( manifestFile . lastModified ( ) > zipFile . lastModified ( ) ) { return false ; } return super . isUpToDate ( scanners , zipFile ) ; } protected boolean createEmptyZip ( File zipFile ) { return false ; } protected void cleanUp ( ) { super . cleanUp ( ) ; } } 	0	['14', '5', '2', '12', '64', '69', '2', '10', '5', '0.807692308', '531', '1', '2', '0.905797101', '0.246031746', '2', '7', '36.64285714', '6', '1.3571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Delete extends MatchingTask { protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir attributes, or a fileset element, must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be set to true" , location ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! file . delete ( ) ) { String message = "Unable to delete file " + file . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , Project . MSG_VERBOSE ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; try { DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( project ) , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( usedMatchingTask && dir != null ) { try { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) list = new String [ 0 ] ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! dir . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) throw new BuildException ( message ) ; else log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	0	['19', '4', '0', '10', '52', '27', '0', '10', '17', '0.777777778', '699', '1', '0', '0.8125', '0.298245614', '3', '4', '35.36842105', '16', '2.3158', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . * ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String msg ) { super ( msg ) ; } public BuildException ( String msg , Throwable cause ) { super ( msg ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String msg , Location location ) { super ( msg ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['14', '4', '0', '136', '26', '0', '135', '1', '14', '0.384615385', '153', '1', '1', '0.65', '0.333333333', '1', '2', '9.785714286', '2', '0.6429', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaOroMatcher implements RegexpMatcher { protected Perl5Matcher reg = new Perl5Matcher ( ) ; protected Perl5Compiler comp = new Perl5Compiler ( ) ; private Pattern pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = comp . compile ( pattern ) ; } catch ( MalformedPatternException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern . getPattern ( ) ; } public boolean matches ( String argument ) { return reg . contains ( argument , pattern ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = reg . getMatch ( ) ; for ( int i = 0 ; i < mr . groups ( ) ; i ++ ) { v . addElement ( mr . group ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '7', '17', '0', '0', '7', '5', '0.5', '75', '1', '0', '0', '0.8', '0', '0', '13.4', '3', '1.2', '0']
package org . apache . tools . ant ; import java . util . * ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private Vector dependencies = new Vector ( 2 ) ; private Vector children = new Vector ( 5 ) ; private Project project ; private String description = null ; public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { addDependency ( tok . nextToken ( ) . trim ( ) ) ; } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . addElement ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . addElement ( r ) ; } public Task [ ] getTasks ( ) { Vector tasks = new Vector ( children . size ( ) ) ; Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { tasks . addElement ( o ) ; } } Task [ ] retval = new Task [ tasks . size ( ) ] ; tasks . copyInto ( retval ) ; return retval ; } public void addDependency ( String dependency ) { dependencies . addElement ( dependency ) ; } public Enumeration getDependencies ( ) { return dependencies . elements ( ) ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + this . ifCondition + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + this . unlessCondition + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { try { project . fireTargetStarted ( this ) ; execute ( ) ; project . fireTargetFinished ( this , null ) ; } catch ( RuntimeException exc ) { project . fireTargetFinished ( this , exc ) ; throw exc ; } } void replaceTask ( UnknownElement el , Task t ) { int index = - 1 ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . setElementAt ( t , index ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = ProjectHelper . replaceProperties ( getProject ( ) , ifCondition , getProject ( ) . getProperties ( ) ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = ProjectHelper . replaceProperties ( getProject ( ) , unlessCondition , getProject ( ) . getProperties ( ) ) ; return project . getProperty ( test ) == null ; } } 	0	['21', '1', '0', '24', '48', '116', '20', '7', '18', '0.814285714', '322', '1', '1', '0', '0.253968254', '0', '0', '14', '3', '1.4762', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { protected void addDefinition ( String name , Class c ) { project . addDataTypeDefinition ( name , c ) ; } } 	0	['2', '6', '0', '3', '4', '1', '0', '3', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . currentThread ( ) . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { long sleepTime = getSleepTime ( ) ; if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '21', '21', '0', '2', '9', '0.6', '135', '1', '0', '0.804347826', '0.4', '1', '1', '12', '1', '0.9', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jikes" ) ; if ( deprecation == true ) cmd . createArgument ( ) . setValue ( "-deprecation" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '24', '1', '1', '8', '2', '2', '222', '0', '0', '0.958333333', '1', '1', '1', '110', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; try { Class c = Class . forName ( "at.dms.kjc.Main" ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use kjc compiler, as it is not available" + " A common solution is to set the environment variable" + " CLASSPATH to your kjc archive (kjc.jar)." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting kjc compiler: " , ex , location ) ; } } } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { addExtdirsToClasspath ( cp ) ; } cp . append ( classpath ) ; cp . append ( src ) ; cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['4', '2', '0', '10', '25', '6', '1', '9', '2', '1', '183', '0', '0', '0.884615385', '0.5', '0', '0', '44.5', '9', '2.75', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DemuxOutputStream extends OutputStream { static private final int MAX_SIZE = 1024 ; private Hashtable buffers = new Hashtable ( ) ; private boolean skip = false ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private ByteArrayOutputStream getBuffer ( ) { Thread current = Thread . currentThread ( ) ; ByteArrayOutputStream buffer = ( ByteArrayOutputStream ) buffers . get ( current ) ; if ( buffer == null ) { buffer = new ByteArrayOutputStream ( ) ; buffers . put ( current , buffer ) ; } return buffer ; } private void resetBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { ByteArrayOutputStream buffer = getBuffer ( ) ; buffer . write ( cc ) ; if ( buffer . size ( ) > MAX_SIZE ) { processBuffer ( ) ; } } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { String output = getBuffer ( ) . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBuffer ( ) ; } public void close ( ) throws IOException { flush ( ) ; } public void flush ( ) throws IOException { if ( getBuffer ( ) . size ( ) > 0 ) { processBuffer ( ) ; } } } 	0	['7', '2', '0', '2', '18', '11', '1', '1', '4', '0.633333333', '118', '1', '1', '0.454545455', '0.357142857', '1', '1', '15.14285714', '2', '1', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public void skip ( int numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; for ( int num = numToSkip ; num > 0 ; ) { int numRead = this . read ( skipBuf , 0 , ( num > skipBuf . length ? skipBuf . length : num ) ) ; if ( numRead == - 1 ) { break ; } num -= numRead ; } } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . entrySize = 0 ; this . entryOffset = 0 ; this . currEntry = null ; throw new IOException ( "bad header in block " + this . buffer . getCurrentBlockNum ( ) + " record " + this . buffer . getCurrentRecordNum ( ) + ", " + "header magic is not 'ustar', but '" + headerBuf [ 257 ] + headerBuf [ 258 ] + headerBuf [ 259 ] + headerBuf [ 260 ] + headerBuf [ 261 ] + "', or (dec) " + ( ( int ) headerBuf [ 257 ] ) + ", " + ( ( int ) headerBuf [ 258 ] ) + ", " + ( ( int ) headerBuf [ 259 ] ) + ", " + ( ( int ) headerBuf [ 260 ] ) + ", " + ( ( int ) headerBuf [ 261 ] ) ) ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	0	['16', '3', '0', '3', '40', '84', '1', '2', '16', '0.658333333', '604', '1', '2', '0.580645161', '0.291666667', '2', '7', '36.25', '1', '0.8125', '0']
package org . apache . tools . zip ; public class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	0	['7', '1', '0', '6', '8', '0', '6', '0', '7', '0', '89', '1', '0', '0', '0.428571429', '1', '1', '11.57142857', '4', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . * ; import java . util . Properties ; import java . util . Stack ; public class Mapper extends DataType { protected Project p ; protected MapperType type = null ; public Mapper ( Project p ) { this . p = p ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( p ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( p , classpath ) ; c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof Mapper ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['11', '3', '0', '11', '38', '11', '3', '8', '10', '0.683333333', '287', '1', '3', '0.75', '0.287878788', '1', '1', '24.54545455', '3', '1.9091', '0']
package org . apache . tools . ant . taskdefs ; public class Taskdef extends Definer { protected void addDefinition ( String name , Class c ) { project . addTaskDefinition ( name , c ) ; } } 	0	['2', '6', '0', '4', '4', '1', '1', '3', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . * ; import java . lang . reflect . Method ; import java . util . StringTokenizer ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FilterSetCollection ; public class FileUtils { private static Object lockReflection = new Object ( ) ; private static java . lang . reflect . Method setLastModified = null ; public static FileUtils newFileUtils ( ) { return new FileUtils ( ) ; } protected FileUtils ( ) { } public void copyFile ( String sourceFile , String destFile ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , null , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , false , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , false ) ; } public void copyFile ( String sourceFile , String destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { copyFile ( new File ( sourceFile ) , new File ( destFile ) , filters , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { copyFile ( sourceFile , destFile , null , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters ) throws IOException { copyFile ( sourceFile , destFile , filters , false , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite ) throws IOException { copyFile ( sourceFile , destFile , filters , overwrite , false ) ; } public void copyFile ( File sourceFile , File destFile , FilterSetCollection filters , boolean overwrite , boolean preserveLastModified ) throws IOException { if ( overwrite || ! destFile . exists ( ) || destFile . lastModified ( ) < sourceFile . lastModified ( ) ) { if ( destFile . exists ( ) && destFile . isFile ( ) ) { destFile . delete ( ) ; } File parent = new File ( destFile . getParent ( ) ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } if ( filters != null && filters . hasFilters ( ) ) { BufferedReader in = new BufferedReader ( new FileReader ( sourceFile ) ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( destFile ) ) ; int length ; String newline = null ; String line = in . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { out . newLine ( ) ; } else { newline = filters . replaceTokens ( line ) ; out . write ( newline ) ; out . newLine ( ) ; } line = in . readLine ( ) ; } out . close ( ) ; in . close ( ) ; } else { FileInputStream in = new FileInputStream ( sourceFile ) ; FileOutputStream out = new FileOutputStream ( destFile ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; in . close ( ) ; out . close ( ) ; } if ( preserveLastModified ) { setFileLastModified ( destFile , sourceFile . lastModified ( ) ) ; } } } protected final Method getSetLastModified ( ) { if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return null ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse ) ; } } } } return setLastModified ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } Long [ ] times = new Long [ 1 ] ; if ( time < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( time ) ; } try { getSetLastModified ( ) . invoke ( file , times ) ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time " + "of " + file , nested ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time " + "of " + file , other ) ; } } public File resolveFile ( File file , String filename ) { filename = filename . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( filename . startsWith ( File . separator ) || ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) ) { return normalize ( filename ) ; } if ( filename . length ( ) >= 2 && Character . isLetter ( filename . charAt ( 0 ) ) && filename . charAt ( 1 ) == ':' ) { return normalize ( filename ) ; } File helpFile = new File ( file . getAbsolutePath ( ) ) ; StringTokenizer tok = new StringTokenizer ( filename , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String part = tok . nextToken ( ) ; if ( part . equals ( ".." ) ) { String parentFile = helpFile . getParent ( ) ; if ( parentFile == null ) { String msg = "The file or path you specified (" + filename + ") is invalid relative to " + file . getPath ( ) ; throw new BuildException ( msg ) ; } helpFile = new File ( parentFile ) ; } else if ( part . equals ( "." ) ) { } else { helpFile = new File ( helpFile , part ) ; } } return new File ( helpFile . getAbsolutePath ( ) ) ; } public File normalize ( String path ) { String orig = path ; path = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( ! path . startsWith ( File . separator ) && ! ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) ) { String msg = path + " is not an absolute path" ; throw new BuildException ( msg ) ; } boolean dosWithDrive = false ; String root = null ; if ( path . length ( ) >= 2 && Character . isLetter ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) { dosWithDrive = true ; char [ ] ca = path . replace ( '/' , '\\' ) . toCharArray ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( Character . toUpperCase ( ca [ 0 ] ) ) . append ( ':' ) ; for ( int i = 2 ; i < ca . length ; i ++ ) { if ( ( ca [ i ] != '\\' ) || ( ca [ i ] == '\\' && ca [ i - 1 ] != '\\' ) ) { sb . append ( ca [ i ] ) ; } } path = sb . toString ( ) . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) == 2 ) { root = path ; path = "" ; } else { root = path . substring ( 0 , 3 ) ; path = path . substring ( 3 ) ; } } else { if ( path . length ( ) == 1 ) { root = File . separator ; path = "" ; } else if ( path . charAt ( 1 ) == File . separatorChar ) { root = File . separator + File . separator ; path = path . substring ( 2 ) ; } else { root = File . separator ; path = path . substring ( 1 ) ; } } Stack s = new Stack ( ) ; s . push ( root ) ; StringTokenizer tok = new StringTokenizer ( path , File . separator ) ; while ( tok . hasMoreTokens ( ) ) { String thisToken = tok . nextToken ( ) ; if ( "." . equals ( thisToken ) ) { continue ; } else if ( ".." . equals ( thisToken ) ) { if ( s . size ( ) < 2 ) { throw new BuildException ( "Cannot resolve path " + orig ) ; } else { s . pop ( ) ; } } else { s . push ( thisToken ) ; } } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i > 1 ) { sb . append ( File . separatorChar ) ; } sb . append ( s . elementAt ( i ) ) ; } path = sb . toString ( ) ; if ( dosWithDrive ) { path = path . replace ( '/' , '\\' ) ; } return new File ( path ) ; } } 	0	['16', '1', '0', '7', '78', '118', '5', '3', '12', '0.888888889', '745', '0.666666667', '0', '0', '0.411111111', '0', '0', '45.375', '22', '3.125', '0']
package org . apache . tools . zip ; import java . io . * ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . ZipException ; public class ZipOutputStream extends DeflaterOutputStream { private ZipEntry entry ; private String comment = "" ; private int level = Deflater . DEFAULT_COMPRESSION ; private int method = DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private ZipLong cdOffset = new ZipLong ( 0 ) ; private ZipLong cdLength = new ZipLong ( 0 ) ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; public static final int DEFLATED = ZipEntry . DEFLATED ; public static final int STORED = ZipEntry . STORED ; public ZipOutputStream ( OutputStream out ) { super ( out , new Deflater ( Deflater . DEFAULT_COMPRESSION , true ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = new ZipLong ( written ) ; for ( int i = 0 ; i < entries . size ( ) ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = new ZipLong ( written - cdOffset . getValue ( ) ) ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( def . getTotalIn ( ) ) ; entry . setComprSize ( def . getTotalOut ( ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for STORED method" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED method" ) ; } entry . setComprSize ( entry . getSize ( ) ) ; } else { def . setLevel ( level ) ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { super . write ( b , offset , length ) ; } else { out . write ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } protected static final ZipLong LFH_SIG = new ZipLong ( 0X04034B50L ) ; protected static final ZipLong DD_SIG = new ZipLong ( 0X08074B50L ) ; protected static final ZipLong CFH_SIG = new ZipLong ( 0X02014B50L ) ; protected static final ZipLong EOCD_SIG = new ZipLong ( 0X06054B50L ) ; protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , new ZipLong ( written ) ) ; out . write ( LFH_SIG . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( LZERO ) ; out . write ( LZERO ) ; out . write ( LZERO ) ; } else { out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED ) { return ; } out . write ( DD_SIG . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { out . write ( CFH_SIG . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] comment = getBytes ( comm ) ; out . write ( ( new ZipShort ( comment . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ZERO ) ; written += 2 ; out . write ( ( new ZipShort ( ze . getInternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ( new ZipLong ( ze . getExternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( ( ZipLong ) offsets . get ( ze ) ) . getBytes ( ) ) ; written += 4 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; out . write ( comment ) ; written += comment . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { out . write ( EOCD_SIG . getBytes ( ) ) ; out . write ( ZERO ) ; out . write ( ZERO ) ; byte [ ] num = ( new ZipShort ( entries . size ( ) ) ) . getBytes ( ) ; out . write ( num ) ; out . write ( num ) ; out . write ( cdLength . getBytes ( ) ) ; out . write ( cdOffset . getBytes ( ) ) ; byte [ ] data = getBytes ( comment ) ; out . write ( ( new ZipShort ( data . length ) ) . getBytes ( ) ) ; out . write ( data ) ; } private static final ZipLong DOS_TIME_MIN = new ZipLong ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { int year = time . getYear ( ) + 1900 ; int month = time . getMonth ( ) + 1 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return new ZipLong ( result ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } } 	0	['17', '4', '0', '7', '81', '40', '4', '3', '10', '0.821428571', '1159', '0.904761905', '8', '0.516129032', '0.25', '2', '4', '65.94117647', '2', '0.9412', '0']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	0	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '9', '0', '0', '1', '1', '0', '58', '1', '1', '0.714285714', '0.666666667', '1', '1', '17.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GZip extends Task { private File zipFile ; private File source ; public void setZipfile ( File zipFilename ) { zipFile = zipFilename ; } public void setSrc ( File src ) { source = src ; } public void execute ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , location ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } log ( "Building gzip: " + zipFile . getAbsolutePath ( ) ) ; GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; if ( source . isDirectory ( ) ) { log ( "Cannot Gzip a directory!" , Project . MSG_ERR ) ; } else { zipFile ( source , zOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } private void zipFile ( InputStream in , GZIPOutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } private void zipFile ( File file , GZIPOutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } } 	0	['6', '3', '0', '3', '24', '11', '0', '3', '4', '0.8', '151', '1', '0', '0.880952381', '0.5', '2', '2', '23.83333333', '1', '0.8333', '0']
package org . apache . tools . ant ; public class Location { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { this . fileName = fileName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['5', '1', '0', '58', '10', '8', '58', '0', '3', '0.3125', '69', '0.75', '1', '0', '0.583333333', '0', '0', '12', '3', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . IOException ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; public class LogOutputStream extends OutputStream { private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) processBuffer ( ) ; } else buffer . write ( cc ) ; skip = ( c == '\r' ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) processBuffer ( ) ; super . close ( ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['7', '2', '1', '7', '15', '1', '6', '1', '4', '0.583333333', '92', '1', '1', '0.454545455', '0.464285714', '1', '1', '11.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jvc" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '19', '1', '1', '8', '2', '2', '120', '0', '0', '0.958333333', '1', '1', '1', '59', '1', '0.5', '0']
package org . apache . tools . zip ; public class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000l ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return result ; } public long getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '7', '0', '147', '1', '0', '0', '0.342857143', '1', '1', '19.85714286', '4', '1', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; public class DesirableFilter implements FilenameFilter { public boolean accept ( File dir , String name ) { if ( name . endsWith ( "~" ) ) { return false ; } if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) { return false ; } if ( name . startsWith ( "%" ) && name . endsWith ( "%" ) ) { return false ; } if ( name . equals ( "CVS" ) ) { return false ; } if ( name . equals ( ".cvsignore" ) ) { return false ; } if ( name . startsWith ( ".#" ) ) { return false ; } if ( name . equals ( "SCCS" ) ) { return false ; } if ( name . equals ( "vssver.scc" ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '0', '6', '1', '0', '0', '2', '2', '63', '0', '0', '0', '0.666666667', '0', '0', '30.5', '11', '5.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , location ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , location ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , location ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { project . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '5', '21', '1', '0', '5', '6', '0.7', '136', '1', '0', '0.880952381', '0.416666667', '2', '2', '21', '1', '0.8333', '0']
package org . apache . tools . ant ; interface Constants { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . mail ; import java . io . * ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . charAt ( 3 ) == '-' ; } private void append ( String line ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } 	0	['5', '1', '0', '1', '18', '0', '1', '0', '3', '0.5', '96', '1', '0', '0', '0.533333333', '0', '0', '17.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { public final static String FILE_PROTOCOL_PREFIX = "file:///" ; public void setStylesheet ( File stylesheet ) throws Exception ; public void addParam ( String name , String expression ) throws Exception ; public void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public String [ ] getIncludedFiles ( ) { String [ ] result = new String [ 1 ] ; result [ 0 ] = srcFile . getAbsolutePath ( ) ; return result ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } } 	0	['6', '2', '0', '3', '11', '13', '2', '1', '6', '0.8', '68', '1', '0', '0.924242424', '0.444444444', '1', '5', '10.16666667', '3', '1.5', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	0	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public abstract class DataType extends ProjectComponent { protected String description = null ; protected Reference ref = null ; protected boolean checked = true ; public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( p ) ; if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } checked = true ; } protected Object getCheckedRef ( Class requiredClass , String dataTypeName ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } else { return o ; } } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one attribute" + " when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular reference." ) ; } } 	0	['10', '2', '7', '14', '24', '19', '10', '4', '5', '0.666666667', '146', '1', '1', '0.5', '0.266666667', '0', '0', '13.3', '3', '1.2', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; import java . util . zip . * ; import java . io . * ; import java . net . * ; import org . apache . tools . ant . types . Path ; public class AntClassLoader extends ClassLoader implements BuildListener { private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } static private final int BUFFER_SIZE = 8192 ; Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; private static Method getContextClassLoader = null ; private static Method setContextClassLoader = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; getContextClassLoader = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; args = new Class [ ] { ClassLoader . class } ; setContextClassLoader = Thread . class . getMethod ( "setContextClassLoader" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( Project project , Path classpath ) { parent = AntClassLoader . class . getClassLoader ( ) ; this . project = project ; project . addBuildListener ( this ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( ( String ) pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { this . parent = parent ; } this . parentFirst = parentFirst ; addSystemPackageRoot ( "java" ) ; addSystemPackageRoot ( "javax" ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { if ( parent != null ) { this . parent = parent ; } else { parent = AntClassLoader . class . getClassLoader ( ) ; } project = null ; this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( getContextClassLoader != null && setContextClassLoader != null ) { try { savedContextLoader = ( ClassLoader ) getContextClassLoader . invoke ( Thread . currentThread ( ) , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { this } ; setContextClassLoader . invoke ( Thread . currentThread ( ) , args ) ; isContextLoaderSaved = true ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; throw new BuildException ( t . toString ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e . toString ( ) ) ; } } } public void resetThreadContextLoader ( ) { if ( isContextLoaderSaved && getContextClassLoader != null && setContextClassLoader != null ) { try { Object [ ] args = new Object [ ] { savedContextLoader } ; setContextClassLoader . invoke ( Thread . currentThread ( ) , args ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; throw new BuildException ( t . toString ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e . toString ( ) ) ; } } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; pathComponents . addElement ( pathComponent ) ; } public void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } static public void initializeClass ( Class theClass ) { try { theClass . newInstance ( ) ; } catch ( Throwable t ) { } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + "." ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + "." ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) && stream == null ; ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) && url == null ; ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { return new ResourceEnumeration ( name ) ; } private URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return new URL ( "file:" + resource . toString ( ) ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:file:" + file . toString ( ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } private Class getClassFromStream ( InputStream stream , String classname ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { for ( Enumeration e = pathComponents . elements ( ) ; e . hasMoreElements ( ) ; ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { return getClassFromStream ( stream , name ) ; } } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public void cleanup ( ) { pathComponents = null ; project = null ; for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { cleanup ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['39', '2', '0', '15', '103', '609', '10', '6', '24', '0.886363636', '1377', '0.636363636', '1', '0.5', '0.184210526', '1', '5', '33.74358974', '12', '1.8462', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , location ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , location ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , location ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . taskdefs . XSLTLiaison ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . Transformer ; import javax . xml . transform . Templates ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; public class TraXLiaison implements XSLTLiaison { private TransformerFactory tfactory = null ; private FileInputStream xslStream = null ; private Templates templates = null ; private Transformer transformer = null ; public TraXLiaison ( ) throws Exception { tfactory = TransformerFactory . newInstance ( ) ; } public void setStylesheet ( File stylesheet ) throws Exception { xslStream = new FileInputStream ( stylesheet ) ; StreamSource src = new StreamSource ( xslStream ) ; src . setSystemId ( getSystemId ( stylesheet ) ) ; templates = tfactory . newTemplates ( src ) ; transformer = templates . newTransformer ( ) ; } public void transform ( File infile , File outfile ) throws Exception { FileInputStream fis = null ; FileOutputStream fos = null ; try { fis = new FileInputStream ( infile ) ; fos = new FileOutputStream ( outfile ) ; StreamSource src = new StreamSource ( fis ) ; src . setSystemId ( getSystemId ( infile ) ) ; StreamResult res = new StreamResult ( fos ) ; res . setSystemId ( getSystemId ( outfile ) ) ; transformer . transform ( src , res ) ; } finally { try { if ( xslStream != null ) { xslStream . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } try { if ( fos != null ) { fos . close ( ) ; } } catch ( IOException ignored ) { } } } protected String getSystemId ( File file ) { String path = file . getAbsolutePath ( ) ; path = path . replace ( '\\' , '/' ) ; return FILE_PROTOCOL_PREFIX + path ; } public void addParam ( String name , String value ) { transformer . setParameter ( name , value ) ; } } 	0	['5', '1', '0', '1', '24', '0', '0', '1', '4', '0.5625', '147', '1', '0', '0', '0.6', '0', '0', '27.6', '1', '0.8', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Vector ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable { private String elementTag = null ; private Vector children = new Vector ( ) ; private Object wrappedObject = null ; private AttributeList attributes ; private StringBuffer characters = new StringBuffer ( ) ; public RuntimeConfigurable ( Object proxy , String elementTag ) { wrappedObject = proxy ; this . elementTag = elementTag ; } void setProxy ( Object proxy ) { wrappedObject = proxy ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { children . addElement ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . elementAt ( index ) ; } public void addText ( String data ) { characters . append ( data ) ; } public void addText ( char [ ] buf , int start , int end ) { addText ( new String ( buf , start , end ) ) ; } public String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { String id = null ; if ( attributes != null ) { ProjectHelper . configure ( wrappedObject , attributes , p ) ; id = attributes . getValue ( "id" ) ; attributes = null ; } if ( characters . length ( ) != 0 ) { ProjectHelper . addText ( p , wrappedObject , characters . toString ( ) ) ; characters . setLength ( 0 ) ; } Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) enum . nextElement ( ) ; child . maybeConfigure ( p ) ; ProjectHelper . storeChild ( p , wrappedObject , child . wrappedObject , child . getElementTag ( ) . toLowerCase ( ) ) ; } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } } } 	0	['10', '1', '0', '9', '30', '17', '6', '3', '8', '0.733333333', '149', '1', '0', '0', '0.25', '0', '0', '13.4', '1', '0.9', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public class FileList extends DataType { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String result [ ] = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileList ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a filelist" ; throw new BuildException ( msg ) ; } else { return ( FileList ) o ; } } } 	0	['8', '3', '0', '5', '29', '0', '1', '4', '6', '0.428571429', '177', '1', '0', '0.833333333', '0.3125', '1', '1', '20.875', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; private static final int BUFFER_SIZE = 512 ; public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) dir = project . getBaseDir ( ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( project . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) throw new BuildException ( "Property 'ant.home' not found" , location ) ; String antRun = project . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , this ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , this ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , location ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = project . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } ; protected void logFlush ( ) { if ( fos != null ) fos . close ( ) ; } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; private Exec parent ; public StreamPumper ( InputStream is , int messageLevel , Exec parent ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; this . parent = parent ; } public void pumpStream ( ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '6', '41', '21', '1', '6', '7', '0.793650794', '360', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . util ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; private StringBuffer sb = new StringBuffer ( ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( ( ( Text ) child ) . getData ( ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '1', '36', '4', '1', '0', '4', '0.583333333', '375', '1', '0', '0', '0.5', '0', '0', '73.4', '10', '3.6', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { String systemDefault = System . getProperty ( "ant.regexp.matcherimpl" ) ; if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['3', '1', '0', '3', '9', '3', '1', '2', '2', '2', '48', '0', '0', '0', '0.666666667', '0', '0', '15', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; import java . text . * ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; project . setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; project . setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; project . setProperty ( "TODAY" , today . format ( d ) ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( project , d , location ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } public class CustomFormat { private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { if ( unit . equalsIgnoreCase ( "millisecond" ) ) { field = Calendar . MILLISECOND ; } else if ( unit . equalsIgnoreCase ( "second" ) ) { field = Calendar . SECOND ; } else if ( unit . equalsIgnoreCase ( "minute" ) ) { field = Calendar . MINUTE ; } else if ( unit . equalsIgnoreCase ( "hour" ) ) { field = Calendar . HOUR_OF_DAY ; } else if ( unit . equalsIgnoreCase ( "day" ) ) { field = Calendar . DATE ; } else if ( unit . equalsIgnoreCase ( "week" ) ) { field = Calendar . WEEK_OF_YEAR ; } else if ( unit . equalsIgnoreCase ( "month" ) ) { field = Calendar . MONTH ; } else if ( unit . equalsIgnoreCase ( "year" ) ) { field = Calendar . YEAR ; } else { throw new BuildException ( unit + " is not a unit supported by the tstamp task" , getLocation ( ) ) ; } } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } project . setProperty ( propertyName , sdf . format ( date ) ) ; } } } 	0	['3', '3', '0', '6', '17', '0', '1', '6', '3', '0', '91', '1', '0', '0.948717949', '1', '0', '0', '29', '1', '0.6667', '0']
package org . apache . tools . tar ; public interface TarConstants { public static final int NAMELEN = 100 ; public static final int MODELEN = 8 ; public static final int UIDLEN = 8 ; public static final int GIDLEN = 8 ; public static final int CHKSUMLEN = 8 ; public static final int SIZELEN = 12 ; public static final int MAGICLEN = 8 ; public static final int MODTIMELEN = 12 ; public static final int UNAMELEN = 32 ; public static final int GNAMELEN = 32 ; public static final int DEVLEN = 8 ; public static final byte LF_OLDNORM = 0 ; public static final byte LF_NORMAL = ( byte ) '0' ; public static final byte LF_LINK = ( byte ) '1' ; public static final byte LF_SYMLINK = ( byte ) '2' ; public static final byte LF_CHR = ( byte ) '3' ; public static final byte LF_BLK = ( byte ) '4' ; public static final byte LF_DIR = ( byte ) '5' ; public static final byte LF_FIFO = ( byte ) '6' ; public static final byte LF_CONTIG = ( byte ) '7' ; public static final String TMAGIC = "ustar" ; public static final String GNU_TMAGIC = "ustar  " ; public static final String GNU_LONGLINK = "././@LongLink" ; public static final byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; public class TaskAdapter extends Task { Object proxy ; public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { project } ) ; } } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No execute in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No execute in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	0	['5', '3', '0', '7', '19', '4', '4', '4', '4', '0.75', '151', '0', '0', '0.902439024', '0.4', '1', '1', '28.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . * ; import org . apache . tools . ant . taskdefs . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . File ; import java . util . Random ; import java . util . Vector ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; if ( attributes . getClasspath ( ) == null ) { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "ignore" ) ) ; } } if ( attributes . getIncludejavaruntime ( ) ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; classpath . addFileset ( msZipFiles ) ; } else if ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else if ( System . getProperty ( "java.vm.name" ) . equals ( "Kaffe" ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; classpath . addFileset ( kaffeJarFiles ) ; } else { classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; classpath . addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { addExtdirsToClasspath ( classpath ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.1" ) ; else if ( "1.2" . equals ( stubVersion ) ) cmd . createArgument ( ) . setValue ( "-v1.2" ) ; else cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation args: " + cmd . toString ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected void addExtdirsToClasspath ( Path classpath ) { Path extdirs = attributes . getExtdirs ( ) ; if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( attributes . getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( ! dirs [ i ] . endsWith ( File . separator ) ) { dirs [ i ] += File . separator ; } File dir = attributes . getProject ( ) . resolveFile ( dirs [ i ] ) ; FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; classpath . addFileset ( fs ) ; } } private final static Random rand = new Random ( ) ; private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . indexOf ( ".class" ) ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['17', '1', '3', '15', '66', '90', '4', '12', '6', '0.791666667', '630', '1', '2', '0', '0.197916667', '0', '0', '35.88235294', '14', '2.4118', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . lang . reflect . * ; import java . io . File ; import java . util . * ; public class IntrospectionHelper implements BuildListener { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private Hashtable nestedStorers ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; nestedStorers = new Hashtable ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && ( ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( args [ 0 ] ) ) || ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( args [ 0 ] ) ) ) ) { continue ; } if ( org . apache . tools . ant . TaskContainer . class . isAssignableFrom ( bean ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; AttributeSetter as = createAttributeSetter ( m , args [ 0 ] ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } } ) ; } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; return o ; } } ) ; nestedStorers . put ( propName , new NestedStorer ( ) { public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { m . invoke ( parent , new Object [ ] { child } ) ; } } ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; m . invoke ( parent , new Object [ ] { o } ) ; return o ; } } ) ; } catch ( NoSuchMethodException nse ) { } } } } public synchronized static IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) { if ( addText == null ) { String msg = getElementName ( project , element ) + " doesn't support nested text data." ; throw new BuildException ( msg ) ; } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object createElement ( Project project , Object element , String elementName ) throws BuildException { NestedCreator nc = ( NestedCreator ) nestedCreators . get ( elementName ) ; if ( nc == null ) { String msg = getElementName ( project , element ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } try { Object nestedElement = nc . create ( element ) ; if ( nestedElement instanceof DataType ) { ( ( DataType ) nestedElement ) . setProject ( project ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void storeElement ( Project project , Object element , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedStorer ns = ( NestedStorer ) nestedStorers . get ( elementName ) ; if ( ns == null ) { return ; } try { ns . store ( element , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , final Class arg ) { if ( java . lang . String . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( arg ) || java . lang . Character . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Byte . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Byte [ ] { new Byte ( value ) } ) ; } } ; } else if ( java . lang . Short . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Short [ ] { new Short ( value ) } ) ; } } ; } else if ( java . lang . Integer . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Integer [ ] { new Integer ( value ) } ) ; } } ; } else if ( java . lang . Long . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Long [ ] { new Long ( value ) } ) ; } } ; } else if ( java . lang . Float . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Float [ ] { new Float ( value ) } ) ; } } ; } else if ( java . lang . Double . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Double [ ] { new Double ( value ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( arg ) || java . lang . Boolean . TYPE . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( arg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { org . apache . tools . ant . types . EnumeratedAttribute ea = ( org . apache . tools . ant . types . EnumeratedAttribute ) arg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = arg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object attribute = c . newInstance ( new String [ ] { value } ) ; if ( attribute instanceof DataType ) { ( ( DataType ) attribute ) . setProject ( p ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } protected String getElementName ( Project project , Object element ) { Hashtable elements = project . getTaskDefinitions ( ) ; String typeName = "task" ; if ( ! elements . contains ( element . getClass ( ) ) ) { elements = project . getDataTypeDefinitions ( ) ; typeName = "data type" ; if ( ! elements . contains ( element . getClass ( ) ) ) { elements = null ; } } if ( elements != null ) { Enumeration e = elements . keys ( ) ; while ( e . hasMoreElements ( ) ) { String elementName = ( String ) e . nextElement ( ) ; Class elementClass = ( Class ) elements . get ( elementName ) ; if ( element . getClass ( ) . equals ( elementClass ) ) { return "The <" + elementName + "> " + typeName ; } } } return "Class " + element . getClass ( ) . getName ( ) ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( ) ; } private interface NestedCreator { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface NestedStorer { public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { attributeTypes . clear ( ) ; attributeSetters . clear ( ) ; nestedTypes . clear ( ) ; nestedCreators . clear ( ) ; addText = null ; helpers . clear ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['23', '1', '0', '31', '82', '201', '22', '27', '17', '0.893939394', '1093', '0.444444444', '0', '0', '0.318181818', '0', '0', '45.73913043', '24', '2.3043', '0']
package org . apache . tools . ant ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( lSep + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '3', '16', '0', '0', '3', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '37', '4', '0', '7', '7', '0.714285714', '277', '1', '0', '0.917647059', '0.46875', '4', '4', '32.875', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . filters . StringInputStream ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import java . io . File ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; public final class LoadProperties extends Task { private File srcFile = null ; private final Vector filterChains = new Vector ( ) ; public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "Source file not defined." ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist." ) ; } if ( ! srcFile . isFile ( ) ) { throw new BuildException ( "Source file is not a file." ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; try { final long len = srcFile . length ( ) ; final int size = ( int ) len ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; instream = new InputStreamReader ( bis ) ; ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( size ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } final StringInputStream sis = new StringInputStream ( text ) ; final Properties props = new Properties ( ) ; props . load ( sis ) ; final Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { final String key = ( String ) e . nextElement ( ) ; final String value = props . getProperty ( key ) ; if ( key != null && value != null && value . trim ( ) . length ( ) > 0 ) { project . setNewProperty ( key , value ) ; } } sis . close ( ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , location ) ; } catch ( final BuildException be ) { throw be ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['4', '3', '0', '8', '39', '0', '0', '8', '4', '0.333333333', '200', '1', '0', '0.925', '0.5', '1', '1', '48.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class ChangeLogTask extends Task { private File m_usersFile ; private Vector m_cvsUsers = new Vector ( ) ; private File m_dir ; private File m_destfile ; private Date m_start ; private Date m_stop ; private final Vector m_filesets = new Vector ( ) ; public void setDir ( final File dir ) { m_dir = dir ; } public void setDestfile ( final File destfile ) { m_destfile = destfile ; } public void setUsersfile ( final File usersFile ) { m_usersFile = usersFile ; } public void addUser ( final CvsUser user ) { m_cvsUsers . addElement ( user ) ; } public void setStart ( final Date start ) { m_start = start ; } public void setEnd ( final Date stop ) { m_stop = stop ; } public void setDaysinpast ( final int days ) { final long time = System . currentTimeMillis ( ) - ( long ) days * 24 * 60 * 60 * 1000 ; setStart ( new Date ( time ) ) ; } public void addFileset ( final FileSet fileSet ) { m_filesets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { File savedDir = m_dir ; try { validate ( ) ; final Properties userList = new Properties ( ) ; loadUserlist ( userList ) ; for ( Enumeration e = m_cvsUsers . elements ( ) ; e . hasMoreElements ( ) ; ) { final CvsUser user = ( CvsUser ) e . nextElement ( ) ; user . validate ( ) ; userList . put ( user . getUserID ( ) , user . getDisplayname ( ) ) ; } final Commandline command = new Commandline ( ) ; command . setExecutable ( "cvs" ) ; command . createArgument ( ) . setValue ( "log" ) ; if ( null != m_start ) { final SimpleDateFormat outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; final String dateRange = "-d >=" + outputDate . format ( m_start ) ; command . createArgument ( ) . setValue ( dateRange ) ; } if ( ! m_filesets . isEmpty ( ) ) { final Enumeration e = m_filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { final FileSet fileSet = ( FileSet ) e . nextElement ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( project ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { command . createArgument ( ) . setValue ( files [ i ] ) ; } } } final ChangeLogParser parser = new ChangeLogParser ( ) ; final RedirectingStreamHandler handler = new RedirectingStreamHandler ( parser ) ; log ( "ChangeLog command: [" + command . toString ( ) + "]" , Project . MSG_VERBOSE ) ; final Execute exe = new Execute ( handler ) ; exe . setWorkingDirectory ( m_dir ) ; exe . setCommandline ( command . getCommandline ( ) ) ; exe . setAntRun ( getProject ( ) ) ; try { final int resultCode = exe . execute ( ) ; if ( 0 != resultCode ) { throw new BuildException ( "Error running cvs log" ) ; } } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) ) ; } final String errors = handler . getErrors ( ) ; if ( null != errors ) { log ( errors , Project . MSG_ERR ) ; } final CVSEntry [ ] entrySet = parser . getEntrySetAsArray ( ) ; final CVSEntry [ ] filteredEntrySet = filterEntrySet ( entrySet ) ; replaceAuthorIdWithName ( userList , filteredEntrySet ) ; writeChangeLog ( filteredEntrySet ) ; } finally { m_dir = savedDir ; } } private void validate ( ) throws BuildException { if ( null == m_dir ) { m_dir = getProject ( ) . getBaseDir ( ) ; } if ( null == m_destfile ) { final String message = "Destfile must be set." ; throw new BuildException ( message ) ; } if ( ! m_dir . exists ( ) ) { final String message = "Cannot find base dir " + m_dir . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } if ( null != m_usersFile && ! m_usersFile . exists ( ) ) { final String message = "Cannot find user lookup list " + m_usersFile . getAbsolutePath ( ) ; throw new BuildException ( message ) ; } } private void loadUserlist ( final Properties userList ) throws BuildException { if ( null != m_usersFile ) { try { userList . load ( new FileInputStream ( m_usersFile ) ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } } } private CVSEntry [ ] filterEntrySet ( final CVSEntry [ ] entrySet ) { final Vector results = new Vector ( ) ; for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry cvsEntry = entrySet [ i ] ; final Date date = cvsEntry . getDate ( ) ; if ( null != m_start && m_start . after ( date ) ) { continue ; } if ( null != m_stop && m_stop . before ( date ) ) { continue ; } results . addElement ( cvsEntry ) ; } final CVSEntry [ ] resultArray = new CVSEntry [ results . size ( ) ] ; results . copyInto ( resultArray ) ; return resultArray ; } private void replaceAuthorIdWithName ( final Properties userList , final CVSEntry [ ] entrySet ) { for ( int i = 0 ; i < entrySet . length ; i ++ ) { final CVSEntry entry = entrySet [ i ] ; if ( userList . containsKey ( entry . getAuthor ( ) ) ) { entry . setAuthor ( userList . getProperty ( entry . getAuthor ( ) ) ) ; } } } private void writeChangeLog ( final CVSEntry [ ] entrySet ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( m_destfile ) ; final PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; final ChangeLogWriter serializer = new ChangeLogWriter ( ) ; serializer . printChangeLog ( writer , entrySet ) ; } catch ( final UnsupportedEncodingException uee ) { getProject ( ) . log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { } } } } } 	0	['15', '3', '0', '16', '77', '69', '0', '16', '10', '0.826530612', '504', '1', '0', '0.725490196', '0.233333333', '1', '1', '32.13333333', '6', '1.4', '0']
package org . apache . tools . tar ; import java . io . FilterOutputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarOutputStream extends FilterOutputStream { public static final int LONGFILE_ERROR = 0 ; public static final int LONGFILE_TRUNCATE = 1 ; public static final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . JavaEnvUtils ; public class SignJar extends Task { protected File jar ; protected String alias ; protected File keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected File sigfile ; protected File signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final File keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final File sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && null == filesets ) { throw new BuildException ( "jar must be set through jar attribute " + "or nested filesets" ) ; } if ( null != jar ) { doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( new File ( fs . getDir ( project ) , jarFiles [ j ] ) , null ) ; } } } } private void doOneJar ( File jarSource , File jarTarget ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "The signjar task is only available on " + "JDK versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) { return ; } final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "jarsigner" ) ; if ( null != keystore ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore . toString ( ) ) ; } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile . toString ( ) ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget . toString ( ) ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource . toString ( ) ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + jarSource . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile ) { return false ; } if ( null != signedjarFile ) { if ( ! jarFile . exists ( ) ) { return false ; } if ( ! signedjarFile . exists ( ) ) { return false ; } if ( jarFile . equals ( signedjarFile ) ) { return false ; } if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) { return true ; } } else { if ( lazy ) { return isSigned ( jarFile ) ; } } return false ; } protected boolean isSigned ( File file ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['18', '3', '0', '10', '56', '119', '0', '10', '15', '0.882352941', '460', '1', '0', '0.685185185', '0.377777778', '0', '0', '23.83333333', '13', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; public interface BuildLogger extends BuildListener { void setMessageOutputLevel ( int level ) ; void setOutputPrintStream ( PrintStream output ) ; void setEmacsMode ( boolean emacsMode ) ; void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import java . util . Hashtable ; import java . util . Vector ; import java . io . File ; import java . io . IOException ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private boolean relative = false ; private boolean parallel = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple " + "srcfile elements." , location ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple " + "targetfile elements." , location ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( taskName ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 ) { throw new BuildException ( "no filesets specified" , location ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , location ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , location ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; File base = fs . getDir ( project ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; if ( ! "dir" . equals ( type ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( type ) ) { String [ ] s = getDirs ( base , ds ) ; ; for ( int j = 0 ; j < s . length ; j ++ ) { fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['16', '4', '2', '19', '56', '48', '2', '17', '10', '0.745454545', '757', '1', '4', '0.836956522', '0.19375', '3', '7', '45.625', '14', '2.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += project . replaceProperties ( msg ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '7', '21', '0', '0', '7', '7', '0.625', '144', '1', '0', '0.860465116', '0.342857143', '1', '1', '19', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public interface ExecuteStreamHandler { void setProcessInputStream ( OutputStream os ) throws IOException ; void setProcessErrorStream ( InputStream is ) throws IOException ; void setProcessOutputStream ( InputStream is ) throws IOException ; void start ( ) throws IOException ; void stop ( ) ; } 	0	['5', '1', '0', '11', '5', '10', '11', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . util . StringUtils ; import java . util . Vector ; import java . util . Enumeration ; public class Parallel extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) throws BuildException { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { TaskThread [ ] threads = new TaskThread [ nestedTasks . size ( ) ] ; int threadNumber = 0 ; for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; threadNumber ++ ) { Task nestedTask = ( Task ) e . nextElement ( ) ; threads [ threadNumber ] = new TaskThread ( threadNumber , nestedTask ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { threads [ i ] . start ( ) ; } for ( int i = 0 ; i < threads . length ; ++ i ) { try { threads [ i ] . join ( ) ; } catch ( InterruptedException ie ) { } } StringBuffer exceptionMessage = new StringBuffer ( ) ; int numExceptions = 0 ; Throwable firstException = null ; Location firstLocation = Location . UNKNOWN_LOCATION ; ; for ( int i = 0 ; i < threads . length ; ++ i ) { Throwable t = threads [ i ] . getException ( ) ; if ( t != null ) { numExceptions ++ ; if ( firstException == null ) { firstException = t ; } if ( t instanceof BuildException && firstLocation == Location . UNKNOWN_LOCATION ) { firstLocation = ( ( BuildException ) t ) . getLocation ( ) ; } exceptionMessage . append ( StringUtils . LINE_SEP ) ; exceptionMessage . append ( t . getMessage ( ) ) ; } } if ( numExceptions == 1 ) { if ( firstException instanceof BuildException ) { throw ( BuildException ) firstException ; } else { throw new BuildException ( firstException ) ; } } else if ( numExceptions > 1 ) { throw new BuildException ( exceptionMessage . toString ( ) , firstLocation ) ; } } class TaskThread extends Thread { private Throwable exception ; private Task task ; private int taskNumber ; TaskThread ( int taskNumber , Task task ) { this . task = task ; this . taskNumber = taskNumber ; } public void run ( ) { try { task . perform ( ) ; } catch ( Throwable t ) { exception = t ; } } public Throwable getException ( ) { return exception ; } } } 	0	['3', '3', '0', '6', '21', '0', '1', '6', '3', '0', '146', '1', '0', '0.948717949', '0.666666667', '0', '0', '47.33333333', '1', '0.6667', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public final void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private final String getLineBreaks ( ) { return lineBreaks ; } public final Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0	['7', '5', '0', '5', '17', '0', '1', '4', '5', '0.777777778', '107', '1', '0', '0.848484848', '0.476190476', '2', '5', '13.85714286', '5', '1.2857', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	0	['3', '1', '1', '7', '9', '0', '5', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Date ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; public class DependSet extends MatchingTask { private Vector sourceFileSets = new Vector ( ) ; private Vector sourceFileLists = new Vector ( ) ; private Vector targetFileSets = new Vector ( ) ; private Vector targetFileLists = new Vector ( ) ; public DependSet ( ) { } public void addSrcfileset ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public void addSrcfilelist ( FileList fl ) { sourceFileLists . addElement ( fl ) ; } public void addTargetfileset ( FileSet fs ) { targetFileSets . addElement ( fs ) ; } public void addTargetfilelist ( FileList fl ) { targetFileLists . addElement ( fl ) ; } public void execute ( ) throws BuildException { if ( ( sourceFileSets . size ( ) == 0 ) && ( sourceFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <srcfileset> or <srcfilelist>" + " element must be set" ) ; } if ( ( targetFileSets . size ( ) == 0 ) && ( targetFileLists . size ( ) == 0 ) ) { throw new BuildException ( "At least one <targetfileset> or" + " <targetfilelist> element must be set" ) ; } long now = ( new Date ( ) ) . getTime ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector allTargets = new Vector ( ) ; long oldestTargetTime = 0 ; File oldestTarget = null ; Enumeration enumTargetSets = targetFileSets . elements ( ) ; while ( enumTargetSets . hasMoreElements ( ) ) { FileSet targetFS = ( FileSet ) enumTargetSets . nextElement ( ) ; if ( ! targetFS . getDir ( getProject ( ) ) . exists ( ) ) { continue ; } DirectoryScanner targetDS = targetFS . getDirectoryScanner ( project ) ; String [ ] targetFiles = targetDS . getIncludedFiles ( ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFS . getDir ( project ) , targetFiles [ i ] ) ; allTargets . addElement ( dest ) ; if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } boolean upToDate = true ; Enumeration enumTargetLists = targetFileLists . elements ( ) ; while ( enumTargetLists . hasMoreElements ( ) ) { FileList targetFL = ( FileList ) enumTargetLists . nextElement ( ) ; String [ ] targetFiles = targetFL . getFiles ( project ) ; for ( int i = 0 ; i < targetFiles . length ; i ++ ) { File dest = new File ( targetFL . getDir ( project ) , targetFiles [ i ] ) ; if ( ! dest . exists ( ) ) { log ( targetFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; continue ; } else { allTargets . addElement ( dest ) ; } if ( dest . lastModified ( ) > now ) { log ( "Warning: " + targetFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( oldestTarget == null || dest . lastModified ( ) < oldestTargetTime ) { oldestTargetTime = dest . lastModified ( ) ; oldestTarget = dest ; } } } if ( oldestTarget != null ) { log ( oldestTarget + " is oldest target file" , Project . MSG_VERBOSE ) ; } else { upToDate = false ; } if ( upToDate ) { Enumeration enumSourceLists = sourceFileLists . elements ( ) ; while ( upToDate && enumSourceLists . hasMoreElements ( ) ) { FileList sourceFL = ( FileList ) enumSourceLists . nextElement ( ) ; String [ ] sourceFiles = sourceFL . getFiles ( project ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFL . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( ! src . exists ( ) ) { log ( sourceFiles [ i ] + " does not exist." , Project . MSG_VERBOSE ) ; upToDate = false ; break ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( upToDate ) { Enumeration enumSourceSets = sourceFileSets . elements ( ) ; while ( upToDate && enumSourceSets . hasMoreElements ( ) ) { FileSet sourceFS = ( FileSet ) enumSourceSets . nextElement ( ) ; DirectoryScanner sourceDS = sourceFS . getDirectoryScanner ( project ) ; String [ ] sourceFiles = sourceDS . getIncludedFiles ( ) ; for ( int i = 0 ; upToDate && i < sourceFiles . length ; i ++ ) { File src = new File ( sourceFS . getDir ( project ) , sourceFiles [ i ] ) ; if ( src . lastModified ( ) > now ) { log ( "Warning: " + sourceFiles [ i ] + " modified in the future." , Project . MSG_WARN ) ; } if ( src . lastModified ( ) > oldestTargetTime ) { upToDate = false ; log ( oldestTarget + " is out of date with respect to " + sourceFiles [ i ] , Project . MSG_VERBOSE ) ; } } } } if ( ! upToDate ) { log ( "Deleting all target files. " , Project . MSG_VERBOSE ) ; for ( Enumeration e = allTargets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileToRemove = ( File ) e . nextElement ( ) ; log ( "Deleting file " + fileToRemove . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; fileToRemove . delete ( ) ; } } } } 	0	['6', '4', '0', '10', '33', '0', '0', '10', '6', '0.6', '511', '1', '0', '0.939759036', '0.555555556', '1', '1', '83.5', '1', '0.8333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Reference ; public class ExtendSelector extends BaseSelector { private String classname = null ; private FileSelector dynselector = null ; private Vector paramVec = new Vector ( ) ; private Path classpath = null ; public ExtendSelector ( ) { } public void setClassname ( String classname ) { this . classname = classname ; } public void selectorCreate ( ) { if ( classname != null && classname . length ( ) > 0 ) { try { Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( getProject ( ) , classpath ) ; c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; } dynselector = ( FileSelector ) c . newInstance ( ) ; } catch ( ClassNotFoundException cnfexcept ) { setError ( "Selector " + classname + " not initialized, no such class" ) ; } catch ( InstantiationException iexcept ) { setError ( "Selector " + classname + " not initialized, could not create class" ) ; } catch ( IllegalAccessException iaexcept ) { setError ( "Selector " + classname + " not initialized, class not accessible" ) ; } } else { setError ( "There is no classname specified" ) ; } } public void addParam ( Parameter p ) { paramVec . addElement ( p ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathref ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public void verifySettings ( ) { if ( dynselector == null ) { selectorCreate ( ) ; } if ( classname == null || classname . length ( ) < 1 ) { setError ( "The classname attribute is required" ) ; } else if ( dynselector == null ) { setError ( "Internal Error: The custom selector was not created" ) ; } else if ( ! ( dynselector instanceof ExtendFileSelector ) && ( paramVec . size ( ) > 0 ) ) { setError ( "Cannot set parameters on custom selector that does not " + "implement ExtendFileSelector" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) throws BuildException { validate ( ) ; if ( paramVec . size ( ) > 0 && dynselector instanceof ExtendFileSelector ) { Parameter [ ] paramArray = new Parameter [ paramVec . size ( ) ] ; paramVec . copyInto ( paramArray ) ; ( ( ExtendFileSelector ) dynselector ) . setParameters ( paramArray ) ; } return dynselector . isSelected ( basedir , filename , file ) ; } } 	0	['10', '4', '0', '16', '36', '3', '4', '12', '10', '0.583333333', '246', '1', '2', '0.795454545', '0.266666667', '1', '3', '23.2', '7', '2.3', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Available extends Task implements Condition { private String property ; private String classname ; private String file ; private Path filepath ; private String resource ; private FileDir type ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; private boolean isTask = false ; private boolean ignoreSystemclasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFilepath ( Path filepath ) { createFilepath ( ) . append ( filepath ) ; } public Path createFilepath ( ) { if ( this . filepath == null ) { this . filepath = new Path ( project ) ; } return this . filepath . createPath ( ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File f ) { this . file = FileUtils . newFileUtils ( ) . removeLeadingPath ( getProject ( ) . getBaseDir ( ) , f ) ; } public void setResource ( String resource ) { this . resource = resource ; } public void setType ( String type ) { log ( "DEPRECATED - The setType(String) method has been deprecated." + " Use setType(Available.FileDir) instead." ) ; this . type = new FileDir ( ) ; this . type . setValue ( type ) ; } public void setType ( FileDir type ) { this . type = type ; } public void setIgnoresystemclasses ( boolean ignore ) { this . ignoreSystemclasses = ignore ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , location ) ; } isTask = true ; try { if ( eval ( ) ) { if ( null != getProject ( ) . getProperty ( property ) ) { log ( "DEPRECATED - <available> used to override an existing" + " property." + StringUtils . LINE_SEP + "  Build file should not reuse the same property" + " name for different values." ) ; } getProject ( ) . setProperty ( property , value ) ; } } finally { isTask = false ; } } public boolean eval ( ) throws BuildException { if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|" + "resource) is required" , location ) ; } if ( type != null ) { if ( file == null ) { throw new BuildException ( "The type attribute is only valid " + "when specifying the file " + "attribute." , location ) ; } } if ( classpath != null ) { classpath . setProject ( project ) ; this . loader = new AntClassLoader ( project , classpath ) ; } String appendix = "" ; if ( isTask ) { appendix = " to set property " + property ; } else { setTaskName ( "available" ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( ( file != null ) && ! checkFile ( ) ) { if ( type != null ) { log ( "Unable to find " + type + " " + file + appendix , Project . MSG_VERBOSE ) ; } else { log ( "Unable to find " + file + appendix , Project . MSG_VERBOSE ) ; } return false ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + appendix , Project . MSG_VERBOSE ) ; return false ; } if ( loader != null ) { loader . cleanup ( ) ; loader = null ; } if ( ! isTask ) { setTaskName ( null ) ; } return true ; } private boolean checkFile ( ) { if ( filepath == null ) { return checkFile ( project . resolveFile ( file ) , file ) ; } else { String [ ] paths = filepath . list ( ) ; for ( int i = 0 ; i < paths . length ; ++ i ) { log ( "Searching " + paths [ i ] , Project . MSG_DEBUG ) ; File path = new File ( paths [ i ] ) ; if ( path . exists ( ) && file . equals ( paths [ i ] ) ) { if ( type == null ) { log ( "Found: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) && path . isDirectory ( ) ) { log ( "Found directory: " + path , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isFile ( ) && path . isFile ( ) ) { log ( "Found file: " + path , Project . MSG_VERBOSE ) ; return true ; } return false ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; File parent = fileUtils . getParentFile ( path ) ; if ( parent != null && parent . exists ( ) && file . equals ( parent . getAbsolutePath ( ) ) ) { if ( type == null ) { log ( "Found: " + parent , Project . MSG_VERBOSE ) ; return true ; } else if ( type . isDir ( ) ) { log ( "Found directory: " + parent , Project . MSG_VERBOSE ) ; return true ; } return false ; } if ( path . exists ( ) && path . isDirectory ( ) ) { if ( checkFile ( new File ( path , file ) , file + " in " + path ) ) { return true ; } } if ( parent != null && parent . exists ( ) ) { if ( checkFile ( new File ( parent , file ) , file + " in " + parent ) ) { return true ; } } if ( parent != null ) { File grandParent = fileUtils . getParentFile ( parent ) ; if ( grandParent != null && grandParent . exists ( ) ) { if ( checkFile ( new File ( grandParent , file ) , file + " in " + grandParent ) ) { return true ; } } } } } return false ; } private boolean checkFile ( File f , String text ) { if ( type != null ) { if ( type . isDir ( ) ) { if ( f . isDirectory ( ) ) { log ( "Found directory: " + text , Project . MSG_VERBOSE ) ; } return f . isDirectory ( ) ; } else if ( type . isFile ( ) ) { if ( f . isFile ( ) ) { log ( "Found file: " + text , Project . MSG_VERBOSE ) ; } return f . isFile ( ) ; } } if ( f . exists ( ) ) { log ( "Found: " + text , Project . MSG_VERBOSE ) ; } return f . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { Class requiredClass = null ; if ( ignoreSystemclasses ) { loader = new AntClassLoader ( null , getProject ( ) , classpath , false ) ; if ( loader != null ) { try { requiredClass = loader . findClass ( classname ) ; } catch ( SecurityException se ) { return true ; } } else { return false ; } } else if ( loader != null ) { requiredClass = loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { requiredClass = l . loadClass ( classname ) ; } else { requiredClass = Class . forName ( classname ) ; } } AntClassLoader . initializeClass ( requiredClass ) ; return true ; } catch ( ClassNotFoundException e ) { log ( "class \"" + classname + "\" was not found" , Project . MSG_DEBUG ) ; return false ; } catch ( NoClassDefFoundError e ) { log ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" , Project . MSG_DEBUG ) ; return false ; } } public static class FileDir extends EnumeratedAttribute { private static final String [ ] values = { "file" , "dir" } ; public String [ ] getValues ( ) { return values ; } public boolean isDir ( ) { return "dir" . equalsIgnoreCase ( getValue ( ) ) ; } public boolean isFile ( ) { return "file" . equalsIgnoreCase ( getValue ( ) ) ; } } } 	0	['20', '3', '0', '14', '67', '130', '1', '13', '16', '0.846889952', '812', '1', '4', '0.660714286', '0.25', '1', '1', '39.05', '25', '3.05', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { public boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '15', '1', '0', '14', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; public class Path extends DataType implements Cloneable { private Vector elements ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public void addFilelist ( FileList fl ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fl ) ; checked = false ; } public void addDirset ( DirSet dset ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( dset ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( getProject ( ) ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( getProject ( ) != null ) { f = getProject ( ) . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or" + " path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( getProject ( ) ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof DirSet ) { DirSet dset = ( DirSet ) o ; DirectoryScanner ds = dset . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedDirectories ( ) ; File dir = dset . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileList ) { FileList fl = ( FileList ) o ; String [ ] s = fl . getFiles ( getProject ( ) ) ; File dir = fl . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( getProject ( ) ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } private static void addUnlessPresent ( Vector v , File dir , String [ ] s ) { for ( int j = 0 ; j < s . length ; j ++ ) { File d = new File ( dir , s [ j ] ) ; String absolutePath = d . getAbsolutePath ( ) ; addUnlessPresent ( v , translateFile ( absolutePath ) ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } public void addJavaRuntime ( ) { if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else if ( "Kaffe" . equals ( System . getProperty ( "java.vm.name" ) ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = getProject ( ) . resolveFile ( dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } } 	0	['28', '3', '0', '44', '96', '286', '32', '13', '22', '0.592592593', '1047', '0.5', '1', '0.545454545', '0.126984127', '2', '5', '36.32142857', '15', '2.5357', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; if ( line == null ) { ch = - 1 ; } else { int commentsSize = comments . size ( ) ; for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } return read ( ) ; } } return ch ; } public final void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private final Vector getComments ( ) { return comments ; } public final Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '164', '1', '0', '0.823529412', '0.375', '2', '5', '19.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; import java . util . Enumeration ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void maybeConfigure ( ) throws BuildException { if ( isInvalid ( ) ) { super . maybeConfigure ( ) ; } else { getRuntimeConfigurableWrapper ( ) . maybeConfigure ( getProject ( ) , false ) ; } } public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['4', '3', '0', '6', '16', '0', '0', '6', '4', '0.333333333', '46', '1', '0', '0.925', '0.625', '1', '1', '10.25', '1', '0.75', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public final class TaskLogger { private Task m_task ; public TaskLogger ( final Task task ) { this . m_task = task ; } public void info ( final String message ) { m_task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { m_task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { m_task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { m_task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { m_task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Gcj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { Commandline cmd ; attributes . log ( "Using gcj compiler" , Project . MSG_VERBOSE ) ; cmd = setupGCJCommand ( ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected Commandline setupGCJCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } cmd . setExecutable ( "gcj" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; if ( destDir . mkdirs ( ) ) { throw new BuildException ( "Can't make output directories. " + "Maybe permission is wrong. " ) ; } ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "--encoding=" + encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g1" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } cmd . createArgument ( ) . setValue ( "-C" ) ; addCurrentCompilerArgs ( cmd ) ; return cmd ; } } 	0	['3', '2', '0', '9', '26', '3', '1', '8', '2', '2', '147', '0', '0', '0.92', '1', '1', '1', '48', '10', '3.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public final static String NAME_KEY = "name" ; public final static String CASE_KEY = "casesensitive" ; public final static String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '9', '23', '0', '4', '5', '8', '0.761904762', '198', '0.5', '0', '0.844444444', '0.35', '1', '4', '23', '6', '2.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPInputStream ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; FileInputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '4', '20', '3', '0', '4', '1', '1.5', '124', '1', '0', '0.960784314', '1', '2', '3', '40', '8', '3', '0']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; public String [ ] getDeselectedDirectories ( ) ; public String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '0', '3', '1', '0', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . io . File ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '17', '0', '2', '1', '3', '0.25', '196', '1', '0', '0', '0.666666667', '0', '0', '63', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . util . Properties ; import java . util . Enumeration ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . IOException ; public abstract class Definer extends Task { private String name ; private String value ; private Path classpath ; private File file ; private String resource ; private boolean reverseLoader = false ; private String loaderId = null ; private String classpathId = null ; private static final String REUSE_LOADER_REF = "ant.reuse.loader" ; public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setLoaderRef ( Reference r ) { loaderId = r . getRefId ( ) ; } public void execute ( ) throws BuildException { AntClassLoader al = createLoader ( ) ; if ( file == null && resource == null ) { if ( name == null || value == null ) { String msg = "name or classname attributes of " + getTaskName ( ) + " element " + "are undefined" ; throw new BuildException ( msg ) ; } addDefinition ( al , name , value ) ; } else { InputStream is = null ; try { if ( name != null || value != null ) { String msg = "You must not specify name or value " + "together with file or resource." ; throw new BuildException ( msg , location ) ; } if ( file != null && resource != null ) { String msg = "You must not specify both, file and " + "resource." ; throw new BuildException ( msg , location ) ; } Properties props = new Properties ( ) ; if ( file != null ) { log ( "Loading definitions from file " + file , Project . MSG_VERBOSE ) ; is = new FileInputStream ( file ) ; if ( is == null ) { log ( "Could not load definitions from file " + file + ". It doesn\'t exist." , Project . MSG_WARN ) ; } } if ( resource != null ) { log ( "Loading definitions from resource " + resource , Project . MSG_VERBOSE ) ; is = al . getResourceAsStream ( resource ) ; if ( is == null ) { log ( "Could not load definitions from resource " + resource + ". It could not be found." , Project . MSG_WARN ) ; } } if ( is != null ) { props . load ( is ) ; Enumeration keys = props . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String n = ( String ) keys . nextElement ( ) ; String v = props . getProperty ( n ) ; addDefinition ( al , n , v ) ; } } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } } private void addDefinition ( ClassLoader al , String name , String value ) throws BuildException { try { Class c = al . loadClass ( value ) ; AntClassLoader . initializeClass ( c ) ; addDefinition ( name , c ) ; } catch ( ClassNotFoundException cnfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = getTaskName ( ) + " class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } private AntClassLoader createLoader ( ) { if ( project . getProperty ( REUSE_LOADER_REF ) != null ) { if ( loaderId == null && classpathId != null ) { loaderId = "ant.loader." + classpathId ; } } if ( loaderId != null ) { Object reusedLoader = project . getReference ( loaderId ) ; if ( reusedLoader != null ) { if ( reusedLoader instanceof AntClassLoader ) { return ( AntClassLoader ) reusedLoader ; } } } AntClassLoader al = null ; if ( classpath != null ) { al = new AntClassLoader ( project , classpath , ! reverseLoader ) ; } else { al = new AntClassLoader ( project , Path . systemClasspath , ! reverseLoader ) ; } al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; if ( loaderId != null ) { if ( project . getReference ( loaderId ) == null ) { project . addReference ( loaderId , al ) ; } } return al ; } public void setFile ( File file ) { this . file = file ; } public void setResource ( String res ) { this . resource = res ; } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } protected abstract void addDefinition ( String name , Class c ) ; } 	0	['15', '3', '2', '10', '47', '73', '2', '8', '12', '0.865079365', '452', '1', '1', '0.725490196', '0.225', '1', '1', '28.53333333', '12', '1.8', '0']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; FileInputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , location ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , location ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( bis != null ) { try { bis . close ( ) ; } catch ( IOException ioex ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '5', '24', '3', '0', '5', '1', '1.5', '163', '1', '0', '0.960784314', '1', '2', '3', '53', '11', '4', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . InputStream ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Locale ; import org . xml . sax . AttributeList ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import org . apache . tools . ant . util . LoaderUtils ; public class ProjectHelper { public static final String HELPER_PROPERTY = "org.apache.tools.ant.ProjectHelper" ; public static final String SERVICE_ID = "META-INF/services/org.apache.tools.ant.ProjectHelper" ; public static void configureProject ( Project project , File buildFile ) throws BuildException { ProjectHelper helper = ProjectHelper . getProjectHelper ( ) ; helper . parse ( project , buildFile ) ; } public ProjectHelper ( ) { } public void parse ( Project project , Object source ) throws BuildException { throw new BuildException ( "ProjectHelper.parse() must be implemented " + "in a helper plugin " + this . getClass ( ) . getName ( ) ) ; } public static ProjectHelper getProjectHelper ( ) throws BuildException { ProjectHelper helper = null ; String helperClass = System . getProperty ( HELPER_PROPERTY ) ; try { if ( helperClass != null ) { helper = newHelper ( helperClass ) ; } } catch ( SecurityException e ) { System . out . println ( "Unable to load ProjectHelper class \"" + helperClass + " specified in system property " + HELPER_PROPERTY ) ; } if ( helper == null ) { try { ClassLoader classLoader = getContextClassLoader ( ) ; InputStream is = null ; if ( classLoader != null ) { is = classLoader . getResourceAsStream ( SERVICE_ID ) ; } if ( is == null ) { is = ClassLoader . getSystemResourceAsStream ( SERVICE_ID ) ; } if ( is != null ) { InputStreamReader isr ; try { isr = new InputStreamReader ( is , "UTF-8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { isr = new InputStreamReader ( is ) ; } BufferedReader rd = new BufferedReader ( isr ) ; String helperClassName = rd . readLine ( ) ; rd . close ( ) ; if ( helperClassName != null && ! "" . equals ( helperClassName ) ) { helper = newHelper ( helperClassName ) ; } } } catch ( Exception ex ) { System . out . println ( "Unable to load ProjectHelper " + "from service \"" + SERVICE_ID ) ; } } if ( helper != null ) { return helper ; } else { try { return new ProjectHelperImpl ( ) ; } catch ( Throwable e ) { String message = "Unable to load default ProjectHelper due to " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) ; throw new BuildException ( message , e ) ; } } } private static ProjectHelper newHelper ( String helperClass ) throws BuildException { ClassLoader classLoader = getContextClassLoader ( ) ; try { Class clazz = null ; if ( classLoader != null ) { try { clazz = classLoader . loadClass ( helperClass ) ; } catch ( ClassNotFoundException ex ) { } } if ( clazz == null ) { clazz = Class . forName ( helperClass ) ; } return ( ( ProjectHelper ) clazz . newInstance ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public static ClassLoader getContextClassLoader ( ) { if ( ! LoaderUtils . isContextLoaderAvailable ( ) ) { return null ; } return LoaderUtils . getContextClassLoader ( ) ; } public static void configure ( Object target , AttributeList attrs , Project project ) throws BuildException { if ( target instanceof TaskAdapter ) { target = ( ( TaskAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper ih = IntrospectionHelper . getHelper ( target . getClass ( ) ) ; project . addBuildListener ( ih ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String value = replaceProperties ( project , attrs . getValue ( i ) , project . getProperties ( ) ) ; try { ih . setAttribute ( project , target , attrs . getName ( i ) . toLowerCase ( Locale . US ) , value ) ; } catch ( BuildException be ) { if ( ! attrs . getName ( i ) . equals ( "id" ) ) { throw be ; } } } } public static void addText ( Project project , Object target , char [ ] buf , int start , int count ) throws BuildException { addText ( project , target , new String ( buf , start , count ) ) ; } public static void addText ( Project project , Object target , String text ) throws BuildException { if ( text == null ) { return ; } if ( target instanceof TaskAdapter ) { target = ( ( TaskAdapter ) target ) . getProxy ( ) ; } IntrospectionHelper . getHelper ( target . getClass ( ) ) . addText ( project , target , text ) ; } public static void storeChild ( Project project , Object parent , Object child , String tag ) { IntrospectionHelper ih = IntrospectionHelper . getHelper ( parent . getClass ( ) ) ; ih . storeElement ( project , parent , child , tag ) ; } public static String replaceProperties ( Project project , String value ) throws BuildException { return project . replaceProperties ( value ) ; } public static String replaceProperties ( Project project , String value , Hashtable keys ) throws BuildException { if ( value == null ) { return null ; } Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; parsePropertyString ( value , fragments , propertyRefs ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( ! keys . containsKey ( propertyName ) ) { project . log ( "Property ${" + propertyName + "} has not been set" , Project . MSG_VERBOSE ) ; } fragment = ( keys . containsKey ( propertyName ) ) ? ( String ) keys . get ( propertyName ) : "${" + propertyName + "}" ; } sb . append ( fragment ) ; } return sb . toString ( ) ; } public static void parsePropertyString ( String value , Vector fragments , Vector propertyRefs ) throws BuildException { int prev = 0 ; int pos ; while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { if ( pos > 0 ) { fragments . addElement ( value . substring ( prev , pos ) ) ; } if ( pos == ( value . length ( ) - 1 ) ) { fragments . addElement ( "$" ) ; prev = pos + 1 ; } else if ( value . charAt ( pos + 1 ) != '{' ) { if ( value . charAt ( pos + 1 ) == '$' ) { fragments . addElement ( "$" ) ; prev = pos + 2 ; } else { fragments . addElement ( value . substring ( pos , pos + 2 ) ) ; prev = pos + 2 ; } } else { int endName = value . indexOf ( '}' , pos ) ; if ( endName < 0 ) { throw new BuildException ( "Syntax error in property: " + value ) ; } String propertyName = value . substring ( pos + 2 , endName ) ; fragments . addElement ( null ) ; propertyRefs . addElement ( propertyName ) ; prev = endName + 1 ; } } if ( prev < value . length ( ) ) { fragments . addElement ( value . substring ( prev ) ) ; } } } 	0	['13', '1', '1', '15', '66', '78', '10', '7', '12', '1.083333333', '476', '0', '0', '0', '0.207692308', '0', '0', '35.46153846', '2', '1', '0']
package org . apache . tools . ant . input ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( getInputStream ( ) ) ) ; do { System . out . println ( prompt ) ; try { String input = in . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( "(" ) ; Enumeration enum = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( enum . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( "," ) ; } sb . append ( enum . nextElement ( ) ) ; first = false ; } sb . append ( ")" ) ; prompt = sb . toString ( ) ; } return prompt ; } protected InputStream getInputStream ( ) { return System . in ; } } 	0	['4', '1', '0', '6', '21', '6', '2', '4', '2', '2', '91', '0', '0', '0', '0.75', '0', '0', '21.75', '4', '1.5', '0']
package org . apache . tools . ant . types ; import java . util . Properties ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private String vmVersion ; private String maxMemory = null ; private boolean executeJar = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; public String [ ] getVariables ( ) throws BuildException { String [ ] props = super . getVariables ( ) ; if ( props == null ) { return null ; } for ( int i = 0 ; i < props . length ; i ++ ) { props [ i ] = "-D" + props [ i ] ; } return props ; } public int size ( ) { return variables . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . keys ( ) ; e . hasMoreElements ( ) ; ) { Object o = e . nextElement ( ) ; p . put ( o , sys . get ( o ) ) ; } for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { String [ ] result = new String [ size ( ) ] ; int pos = 0 ; String [ ] vmArgs = getActualVMCommand ( ) . getCommandline ( ) ; result [ pos ++ ] = vmArgs [ 0 ] ; System . arraycopy ( vmArgs , 1 , result , pos , vmArgs . length - 1 ) ; pos += vmArgs . length - 1 ; if ( sysProperties . size ( ) > 0 ) { System . arraycopy ( sysProperties . getVariables ( ) , 0 , result , pos , sysProperties . size ( ) ) ; pos += sysProperties . size ( ) ; } Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { result [ pos ++ ] = "-classpath" ; result [ pos ++ ] = fullClasspath . toString ( ) ; } if ( executeJar ) { result [ pos ++ ] = "-jar" ; } System . arraycopy ( javaCommand . getCommandline ( ) , 0 , result , pos , javaCommand . size ( ) ) ; return result ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } private Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; if ( fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ) { size += 2 ; } if ( executeJar ) { size ++ ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) { CommandlineJava c = new CommandlineJava ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; c . maxMemory = maxMemory ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } c . vmVersion = vmVersion ; c . executeJar = executeJar ; return c ; } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } } 	0	['27', '1', '0', '10', '60', '145', '1', '9', '26', '0.648351648', '401', '1', '4', '0', '0.314814815', '0', '0', '13.59259259', '6', '1.5185', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private long linesRead = 0 ; private long lines = 10 ; private char [ ] buffer = new char [ 4096 ] ; private int returnedCharPos = - 1 ; private boolean completedReadAhead = false ; private int bufferPos = 0 ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( ! completedReadAhead ) { int ch = - 1 ; while ( ( ch = in . read ( ) ) != - 1 ) { if ( buffer . length == bufferPos ) { if ( returnedCharPos != - 1 ) { final char [ ] tmpBuffer = new char [ buffer . length ] ; System . arraycopy ( buffer , returnedCharPos + 1 , tmpBuffer , 0 , buffer . length - ( returnedCharPos + 1 ) ) ; buffer = tmpBuffer ; bufferPos = bufferPos - ( returnedCharPos + 1 ) ; returnedCharPos = - 1 ; } else { final char [ ] tmpBuffer = new char [ buffer . length * 2 ] ; System . arraycopy ( buffer , 0 , tmpBuffer , 0 , bufferPos ) ; buffer = tmpBuffer ; } } if ( ch == '\n' || ch == - 1 ) { ++ linesRead ; if ( linesRead == lines ) { int i = 0 ; for ( i = returnedCharPos + 1 ; buffer [ i ] != 0 && buffer [ i ] != '\n' ; i ++ ) { } returnedCharPos = i ; -- linesRead ; } } if ( ch == - 1 ) { break ; } buffer [ bufferPos ] = ( char ) ch ; bufferPos ++ ; } completedReadAhead = true ; } ++ returnedCharPos ; if ( returnedCharPos >= bufferPos ) { return - 1 ; } else { return buffer [ returnedCharPos ] ; } } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; break ; } } } } } 	0	['7', '5', '0', '5', '19', '1', '1', '4', '5', '0.523809524', '285', '1', '0', '0.848484848', '0.476190476', '2', '5', '38.71428571', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . listener ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . mail . MailMessage ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . StringTokenizer ; public class MailLogger extends DefaultLogger { private StringBuffer buffer = new StringBuffer ( ) ; public void buildFinished ( BuildEvent event ) { super . buildFinished ( event ) ; Project project = event . getProject ( ) ; Hashtable properties = project . getProperties ( ) ; Properties fileProperties = new Properties ( ) ; String filename = ( String ) properties . get ( "MailLogger.properties.file" ) ; if ( filename != null ) { InputStream is = null ; try { is = new FileInputStream ( filename ) ; fileProperties . load ( is ) ; } catch ( IOException ioe ) { } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } for ( Enumeration e = fileProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = fileProperties . getProperty ( key ) ; properties . put ( key , project . replaceProperties ( value ) ) ; } boolean success = ( event . getException ( ) == null ) ; String prefix = success ? "success" : "failure" ; try { boolean notify = Project . toBoolean ( getValue ( properties , prefix + ".notify" , "on" ) ) ; if ( ! notify ) { return ; } String mailhost = getValue ( properties , "mailhost" , "localhost" ) ; String from = getValue ( properties , "from" , null ) ; String toList = getValue ( properties , prefix + ".to" , null ) ; String subject = getValue ( properties , prefix + ".subject" , ( success ) ? "Build Success" : "Build Failure" ) ; sendMail ( mailhost , from , toList , subject , buffer . toString ( ) ) ; } catch ( Exception e ) { System . out . println ( "MailLogger failed to send e-mail!" ) ; e . printStackTrace ( System . err ) ; } } protected void log ( String message ) { buffer . append ( message ) . append ( StringUtils . LINE_SEP ) ; } private String getValue ( Hashtable properties , String name , String defaultValue ) throws Exception { String propertyName = "MailLogger." + name ; String value = ( String ) properties . get ( propertyName ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { throw new Exception ( "Missing required parameter: " + propertyName ) ; } return value ; } private void sendMail ( String mailhost , String from , String toList , String subject , String message ) throws IOException { MailMessage mailMessage = new MailMessage ( mailhost ) ; mailMessage . from ( from ) ; StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } mailMessage . setSubject ( subject ) ; PrintStream ps = mailMessage . getPrintStream ( ) ; ps . println ( message ) ; mailMessage . sendAndClose ( ) ; } } 	0	['5', '2', '0', '5', '37', '4', '0', '5', '2', '0.5', '250', '1', '0', '0.8', '0.5', '1', '3', '48.8', '11', '2.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . util . StringUtils ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StringReader ; import java . util . Vector ; import java . util . Enumeration ; public class Concat extends Task { private File destinationFile = null ; private boolean append = false ; private String encoding = null ; private StringBuffer textBuffer ; private Vector fileSets = new Vector ( ) ; public Concat ( ) { } public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void addFileset ( FileSet set ) { fileSets . addElement ( set ) ; } public void addFilelist ( FileList list ) { fileSets . addElement ( list ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void execute ( ) throws BuildException { sanitizeText ( ) ; if ( fileSets . size ( ) == 0 && textBuffer == null ) { throw new BuildException ( "At least one file " + "must be provided, or " + "some text." ) ; } if ( fileSets . size ( ) > 0 && textBuffer != null ) { throw new BuildException ( "Cannot include inline text " + "when using filesets." ) ; } boolean savedAppend = append ; try { for ( Enumeration e = fileSets . elements ( ) ; e . hasMoreElements ( ) ; ) { File fileSetBase = null ; String [ ] srcFiles = null ; Object next = e . nextElement ( ) ; if ( next instanceof FileSet ) { FileSet fileSet = ( FileSet ) next ; DirectoryScanner scanner = fileSet . getDirectoryScanner ( project ) ; fileSetBase = fileSet . getDir ( project ) ; srcFiles = scanner . getIncludedFiles ( ) ; } else if ( next instanceof FileList ) { FileList fileList = ( FileList ) next ; fileSetBase = fileList . getDir ( project ) ; srcFiles = fileList . getFiles ( project ) ; } if ( srcFiles != null ) { catFiles ( fileSetBase , srcFiles ) ; } } } finally { append = savedAppend ; } catText ( ) ; } public void reset ( ) { append = false ; destinationFile = null ; encoding = null ; fileSets = new Vector ( ) ; } private void catFiles ( File base , String [ ] files ) { final int len = files . length ; String [ ] input = new String [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { File current = new File ( base , files [ i ] ) ; if ( ! current . exists ( ) ) { log ( "File " + current + " does not exist." , Project . MSG_ERR ) ; continue ; } input [ i ] = current . getAbsolutePath ( ) ; } if ( encoding == null ) { OutputStream os = null ; InputStream is = null ; try { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; append = true ; } for ( int i = 0 ; i < len ; i ++ ) { if ( destinationFile != null && destinationFile . getAbsolutePath ( ) . equals ( input [ i ] ) ) { log ( destinationFile . getName ( ) + ": input file is " + "output file." , Project . MSG_WARN ) ; } is = new FileInputStream ( input [ i ] ) ; byte [ ] buffer = new byte [ 8096 ] ; while ( true ) { int bytesRead = is . read ( buffer ) ; if ( bytesRead == - 1 ) { break ; } os . write ( buffer , 0 , bytesRead ) ; } os . flush ( ) ; is . close ( ) ; is = null ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception ignore ) { } } if ( os != null ) { try { os . close ( ) ; } catch ( Exception ignore ) { } } } } else { PrintWriter out = null ; BufferedReader in = null ; try { if ( destinationFile == null ) { out = new PrintWriter ( new OutputStreamWriter ( new LogOutputStream ( this , Project . MSG_WARN ) ) ) ; } else { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) , encoding ) ) ; append = true ; } for ( int i = 0 ; i < len ; i ++ ) { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( input [ i ] ) , encoding ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( line ) ; } in . close ( ) ; in = null ; } } catch ( IOException ioe ) { throw new BuildException ( "Error while concatenating: " + ioe . getMessage ( ) , ioe ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception ignore ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( Exception ignore ) { } } } } } private void catText ( ) { if ( textBuffer == null ) { return ; } String text = textBuffer . toString ( ) ; text = ProjectHelper . replaceProperties ( project , text , project . getProperties ( ) ) ; FileWriter writer = null ; if ( destinationFile != null ) { try { writer = new FileWriter ( destinationFile . getAbsolutePath ( ) , append ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error creating destination " + "file." , ioe ) ; } } BufferedReader reader = null ; try { reader = new BufferedReader ( new StringReader ( text ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( destinationFile == null ) { log ( line , Project . MSG_WARN ) ; } else { writer . write ( line ) ; writer . write ( StringUtils . LINE_SEP ) ; writer . flush ( ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while concatenating " + "text." , ioe ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception ignore ) { } } if ( writer != null ) { try { writer . close ( ) ; } catch ( Exception ignore ) { } } } } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . toString ( ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } } 	0	['12', '3', '0', '11', '64', '0', '0', '11', '9', '0.618181818', '581', '1', '0', '0.770833333', '0.238095238', '0', '0', '47', '20', '3.4167', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '12', '15', '13', '9', '4', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . zip . ZipOutputStream ; import java . io . IOException ; import java . io . File ; import java . io . InputStream ; import java . io . Reader ; import java . io . FileReader ; import java . io . ByteArrayOutputStream ; import java . io . PrintWriter ; import java . io . ByteArrayInputStream ; import java . io . OutputStreamWriter ; import java . io . InputStreamReader ; import java . util . Enumeration ; public class Jar extends Zip { private static final String INDEX_NAME = "META-INF/INDEX.LIST" ; private Manifest configuredManifest ; private Manifest savedConfiguredManifest ; private Manifest filesetManifest ; private FilesetManifestConfig filesetManifestConfig ; private boolean manifestOnFinalize = true ; private boolean mergeManifestsMain = true ; private Manifest manifest ; private File manifestFile ; private boolean index = false ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; setEncoding ( "UTF8" ) ; } public void setWhenempty ( WhenEmpty we ) { log ( "JARs are never empty, they contain at least a manifest file" , Project . MSG_WARN ) ; } public void setJarfile ( File jarFile ) { setDestFile ( jarFile ) ; } public void setIndex ( boolean flag ) { index = flag ; } public void addConfiguredManifest ( Manifest newManifest ) throws ManifestException { if ( configuredManifest == null ) { configuredManifest = newManifest ; } else { configuredManifest . merge ( newManifest ) ; } savedConfiguredManifest = configuredManifest ; } public void setManifest ( File manifestFile ) { if ( ! manifestFile . exists ( ) ) { throw new BuildException ( "Manifest file: " + manifestFile + " does not exist." , getLocation ( ) ) ; } this . manifestFile = manifestFile ; } private Manifest getManifest ( File manifestFile ) { Manifest newManifest = null ; Reader r = null ; try { r = new FileReader ( manifestFile ) ; newManifest = getManifest ( r ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file: " + manifestFile + " (" + e . getMessage ( ) + ")" , e ) ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { } } } return newManifest ; } private Manifest getManifest ( Reader r ) { Manifest newManifest = null ; try { newManifest = new Manifest ( r ) ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest: " + manifestFile , e , getLocation ( ) ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest file" + " (" + e . getMessage ( ) + ")" , e ) ; } return newManifest ; } public void addMetainf ( ZipFileSet fs ) { fs . setPrefix ( "META-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( filesetManifestConfig == null || filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { manifestOnFinalize = false ; Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; } } private Manifest createManifest ( ) throws IOException , BuildException { try { Manifest finalManifest = Manifest . getDefaultManifest ( ) ; if ( manifest == null ) { if ( manifestFile != null ) { manifest = getManifest ( manifestFile ) ; finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; } else if ( configuredManifest != null ) { finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest , ! mergeManifestsMain ) ; } else if ( filesetManifest != null ) { finalManifest . merge ( filesetManifest , ! mergeManifestsMain ) ; } } else { finalManifest . merge ( filesetManifest ) ; finalManifest . merge ( configuredManifest ) ; finalManifest . merge ( manifest , ! mergeManifestsMain ) ; } return finalManifest ; } catch ( ManifestException e ) { log ( "Manifest is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } private void writeManifest ( ZipOutputStream zOut , Manifest manifest ) throws IOException { for ( Enumeration e = manifest . getWarnings ( ) ; e . hasMoreElements ( ) ; ) { log ( "Manifest warning: " + ( String ) e . nextElement ( ) , Project . MSG_WARN ) ; } zipDir ( null , zOut , "META-INF/" ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( baos ) ; manifest . write ( writer ) ; writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , "META-INF/MANIFEST.MF" , System . currentTimeMillis ( ) , null ) ; super . initZipOutputStream ( zOut ) ; } protected void finalizeZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( manifestOnFinalize ) { Manifest jarManifest = createManifest ( ) ; writeManifest ( zOut , jarManifest ) ; } if ( index ) { createIndexList ( zOut ) ; } } private void createIndexList ( ZipOutputStream zOut ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( baos , "UTF8" ) ) ; writer . println ( "JarIndex-Version: 1.0" ) ; writer . println ( ) ; writer . println ( zipFile . getName ( ) ) ; Enumeration enum = addedDirs . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String dir = ( String ) enum . nextElement ( ) ; dir = dir . replace ( '\\' , '/' ) ; int pos = dir . lastIndexOf ( '/' ) ; if ( pos != - 1 ) { dir = dir . substring ( 0 , pos ) ; } if ( dir . startsWith ( "META-INF" ) ) { continue ; } writer . println ( dir ) ; } writer . flush ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; super . zipFile ( bais , zOut , INDEX_NAME , System . currentTimeMillis ( ) , null ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( "META-INF/MANIFEST.MF" . equalsIgnoreCase ( vPath ) ) { filesetManifest ( file , null ) ; } else { super . zipFile ( file , zOut , vPath ) ; } } protected void zipFile ( InputStream is , ZipOutputStream zOut , String vPath , long lastModified , File file ) throws IOException { if ( "META-INF/MANIFEST.MF" . equalsIgnoreCase ( vPath ) ) { filesetManifest ( file , is ) ; } else { super . zipFile ( is , zOut , vPath , lastModified , null ) ; } } private void filesetManifest ( File file , InputStream is ) { if ( manifestFile != null && manifestFile . equals ( file ) ) { log ( "Found manifest " + file , Project . MSG_VERBOSE ) ; if ( is != null ) { manifest = getManifest ( new InputStreamReader ( is ) ) ; } else { manifest = getManifest ( file ) ; } } else if ( filesetManifestConfig != null && ! filesetManifestConfig . getValue ( ) . equals ( "skip" ) ) { log ( "Found manifest to merge in file " + file , Project . MSG_VERBOSE ) ; try { Manifest newManifest = null ; if ( is != null ) { newManifest = getManifest ( new InputStreamReader ( is ) ) ; } else { newManifest = getManifest ( file ) ; } if ( filesetManifest == null ) { filesetManifest = newManifest ; } else { filesetManifest . merge ( newManifest ) ; } } catch ( ManifestException e ) { log ( "Manifest in file " + file + " is invalid: " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( "Invalid Manifest" , e , getLocation ( ) ) ; } } else { int logLevel = filesetManifestConfig == null ? Project . MSG_WARN : Project . MSG_VERBOSE ; log ( "File " + file + " includes a META-INF/MANIFEST.MF which will be ignored. " + "To include this file, set filesetManifest to a value other " + "than 'skip'." , logLevel ) ; } } protected boolean isUpToDate ( FileScanner [ ] scanners , File zipFile ) throws BuildException { if ( configuredManifest != null || manifestFile == null ) { java . util . zip . ZipFile theZipFile = null ; try { theZipFile = new java . util . zip . ZipFile ( zipFile ) ; java . util . zip . ZipEntry entry = theZipFile . getEntry ( "META-INF/MANIFEST.MF" ) ; if ( entry == null ) { log ( "Updating jar since the current jar has no manifest" , Project . MSG_VERBOSE ) ; return false ; } Manifest currentManifest = new Manifest ( new InputStreamReader ( theZipFile . getInputStream ( entry ) ) ) ; Manifest newManifest = createManifest ( ) ; if ( ! currentManifest . equals ( newManifest ) ) { log ( "Updating jar since jar manifest has changed" , Project . MSG_VERBOSE ) ; return false ; } } catch ( Exception e ) { log ( "Updating jar since cannot read current jar manifest: " + e . getClass ( ) . getName ( ) + " - " + e . getMessage ( ) , Project . MSG_VERBOSE ) ; return false ; } finally { if ( theZipFile != null ) { try { theZipFile . close ( ) ; } catch ( IOException e ) { } } } } else if ( manifestFile . lastModified ( ) > zipFile . lastModified ( ) ) { return false ; } return super . isUpToDate ( scanners , zipFile ) ; } protected boolean createEmptyZip ( File zipFile ) { return true ; } protected void cleanUp ( ) { super . cleanUp ( ) ; manifest = null ; configuredManifest = savedConfiguredManifest ; filesetManifest = null ; } public void reset ( ) { super . reset ( ) ; configuredManifest = null ; filesetManifestConfig = null ; mergeManifestsMain = false ; manifestFile = null ; index = false ; } public static class FilesetManifestConfig extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "skip" , "merge" , "mergewithoutmain" } ; } } } 	0	['21', '5', '2', '15', '83', '142', '2', '13', '8', '0.78', '799', '1', '5', '0.862068966', '0.186507937', '3', '7', '36.57142857', '9', '1.5238', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import java . io . File ; import java . util . Vector ; public class Delete extends MatchingTask { protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; private boolean failonerror = true ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; if ( quiet ) { this . failonerror = false ; } } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { usedMatchingTask = true ; return super . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { usedMatchingTask = true ; return super . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  " + "Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir " + "attributes, or a fileset element, " + "must be set." ) ; } if ( quiet && failonerror ) { throw new BuildException ( "quiet and failonerror cannot both be " + "set to true" , location ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  " + "Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! file . delete ( ) ) { String message = "Unable to delete file " + file . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." , Project . MSG_VERBOSE ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; try { DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( project ) , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } if ( usedMatchingTask && dir != null ) { try { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } catch ( BuildException be ) { if ( failonerror ) { throw be ; } else { log ( be . getMessage ( ) , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { list = new String [ 0 ] ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) ) { String message = "Unable to delete file " + f . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = dirs . length - 1 ; j >= 0 ; j -- ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! dir . delete ( ) ) { String message = "Unable to delete directory " + dir . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message ) ; } else { log ( message , quiet ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	0	['21', '4', '0', '11', '56', '24', '0', '11', '19', '0.7875', '715', '1', '0', '0.795918367', '0.285714286', '3', '4', '32.66666667', '16', '2.1905', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . tar . TarInputStream ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . zip . GZIPInputStream ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Untar extends Expand { private UntarCompressionMethod compression = new UntarCompressionMethod ( ) ; public void setCompression ( UntarCompressionMethod method ) { compression = method ; } protected void expandFile ( FileUtils fileUtils , File srcF , File dir ) { TarInputStream tis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( compression . decompress ( srcF , new BufferedInputStream ( new FileInputStream ( srcF ) ) ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { extractFile ( fileUtils , srcF , dir , tis , te . getName ( ) , te . getModTime ( ) , te . isDirectory ( ) ) ; } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public static final class UntarCompressionMethod extends EnumeratedAttribute { private static final String NONE = "none" ; private static final String GZIP = "gzip" ; private static final String BZIP2 = "bzip2" ; public UntarCompressionMethod ( ) { super ( ) ; setValue ( NONE ) ; } public String [ ] getValues ( ) { return new String [ ] { NONE , GZIP , BZIP2 } ; } private InputStream decompress ( final File file , final InputStream istream ) throws IOException , BuildException { final String value = getValue ( ) ; if ( GZIP . equals ( value ) ) { return new GZIPInputStream ( istream ) ; } else { if ( BZIP2 . equals ( value ) ) { final char [ ] magic = new char [ ] { 'B' , 'Z' } ; for ( int i = 0 ; i < magic . length ; i ++ ) { if ( istream . read ( ) != magic [ i ] ) { throw new BuildException ( "Invalid bz2 file." + file . toString ( ) ) ; } } return new CBZip2InputStream ( istream ) ; } } return istream ; } } } 	0	['3', '4', '0', '8', '22', '0', '0', '8', '2', '0', '104', '1', '1', '0.962264151', '0.5', '2', '2', '33.33333333', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; public class ManifestTask extends Task { private Manifest nestedManifest = new Manifest ( ) ; private File manifestFile ; private Mode mode ; public static class Mode extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "update" , "replace" } ; } } public ManifestTask ( ) { mode = new Mode ( ) ; mode . setValue ( "replace" ) ; } public void addConfiguredSection ( Manifest . Section section ) throws ManifestException { nestedManifest . addConfiguredSection ( section ) ; } public void addConfiguredAttribute ( Manifest . Attribute attribute ) throws ManifestException { nestedManifest . addConfiguredAttribute ( attribute ) ; } public void setFile ( File f ) { manifestFile = f ; } public void setMode ( Mode m ) { mode = m ; } public void execute ( ) throws BuildException { if ( manifestFile == null ) { throw new BuildException ( "the file attribute is required" ) ; } Manifest toWrite = Manifest . getDefaultManifest ( ) ; Manifest current = null ; BuildException error = null ; if ( manifestFile . exists ( ) ) { FileReader f = null ; try { f = new FileReader ( manifestFile ) ; current = new Manifest ( f ) ; } catch ( ManifestException m ) { error = new BuildException ( "Existing manifest " + manifestFile + " is invalid" , m , location ) ; } catch ( IOException e ) { error = new BuildException ( "Failed to read " + manifestFile , e , location ) ; } finally { if ( f != null ) { try { f . close ( ) ; } catch ( IOException e ) { } } } } try { if ( mode . getValue ( ) . equals ( "update" ) && manifestFile . exists ( ) ) { if ( current != null ) { toWrite . merge ( current ) ; } else if ( error != null ) { throw error ; } } toWrite . merge ( nestedManifest ) ; } catch ( ManifestException m ) { throw new BuildException ( "Manifest is invalid" , m , location ) ; } if ( toWrite . equals ( current ) ) { log ( "Manifest has not changed, do not recreate" , Project . MSG_VERBOSE ) ; return ; } PrintWriter w = null ; try { w = new PrintWriter ( new FileWriter ( manifestFile ) ) ; toWrite . write ( w ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to write " + manifestFile , e , location ) ; } finally { if ( w != null ) { w . close ( ) ; } } } } 	0	['6', '3', '0', '9', '32', '0', '0', '9', '6', '0.6', '216', '1', '2', '0.880952381', '0.333333333', '2', '2', '34.5', '1', '0.8333', '0']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private static final ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ( new ZipShort ( getMode ( ) ) ) . getBytes ( ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ( new ZipLong ( linkArray . length ) ) . getBytes ( ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ( new ZipShort ( getUserId ( ) ) ) . getBytes ( ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ( new ZipShort ( getGroupId ( ) ) ) . getBytes ( ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ( new ZipLong ( checksum ) ) . getBytes ( ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ( new ZipLong ( data , offset ) ) . getValue ( ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ( new ZipShort ( tmp , 0 ) ) . getValue ( ) ; byte [ ] linkArray = new byte [ ( int ) ( new ZipLong ( tmp , 2 ) ) . getValue ( ) ] ; uid = ( new ZipShort ( tmp , 6 ) ) . getValue ( ) ; gid = ( new ZipShort ( tmp , 8 ) ) . getValue ( ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	0	['20', '1', '0', '4', '42', '130', '0', '4', '18', '0.736842105', '376', '1', '1', '0', '0.284210526', '0', '0', '17.45', '3', '1.15', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof Substitution ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a substitution" ; throw new BuildException ( msg ) ; } else { return ( Substitution ) o ; } } } 	0	['4', '3', '0', '4', '15', '0', '0', '4', '4', '0.833333333', '70', '0.5', '0', '0.909090909', '0.583333333', '0', '0', '16', '3', '1.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private Vector contains = new Vector ( ) ; private String line = null ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { String goodLine = null ; line = readLine ( ) ; if ( line == null ) { ch = - 1 ; } else { int containsSize = contains . size ( ) ; for ( int i = 0 ; i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; if ( line . indexOf ( containsStr ) == - 1 ) { line = null ; break ; } } return read ( ) ; } } return ch ; } public final void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private final Vector getContains ( ) { return contains ; } public final Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '167', '1', '0', '0.823529412', '0.375', '2', '5', '19.5', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . * ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Enumeration ; public abstract class MatchingTask extends Task implements SelectorContainer { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } } 	0	['36', '3', '11', '35', '84', '0', '11', '24', '35', '0.485714286', '302', '1', '1', '0.513888889', '0.0875', '2', '2', '7.333333333', '6', '1.1944', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FlatFileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; private boolean failonerror = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Hashtable completeDirMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; private Vector filterChains = new Vector ( ) ; private Vector filterSets = new Vector ( ) ; private FileUtils fileUtils ; private String encoding = null ; public Copy ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } protected FileUtils getFileUtils ( ) { return fileUtils ; } public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public FilterChain createFilterChain ( ) { FilterChain filterChain = new FilterChain ( ) ; filterChains . addElement ( filterChain ) ; return filterChain ; } public FilterSet createFilterSet ( ) { FilterSet filterSet = new FilterSet ( ) ; filterSets . addElement ( filterSet ) ; return filterSet ; } public void setPreserveLastModified ( String preserve ) { setPreserveLastModified ( Project . toBoolean ( preserve ) ) ; } public void setPreserveLastModified ( boolean preserve ) { preserveLastModified = preserve ; } public boolean getPreserveLastModified ( ) { return preserveLastModified ; } protected Vector getFilterSets ( ) { return filterSets ; } protected Vector getFilterChains ( ) { return filterChains ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void execute ( ) throws BuildException { File savedFile = file ; File savedDestFile = destFile ; File savedDestDir = destDir ; FileSet savedFileSet = null ; if ( file == null && destFile != null && filesets . size ( ) == 1 ) { savedFileSet = ( FileSet ) filesets . elementAt ( 0 ) ; } validateAttributes ( ) ; try { if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } else { log ( file + " omitted as " + destFile + " is up to date." , Project . MSG_VERBOSE ) ; } } else { String message = "Warning: Could not find file " + file . getAbsolutePath ( ) + " to copy." ; if ( ! failonerror ) { log ( message ) ; } else { throw new BuildException ( message ) ; } } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; boolean isEverythingIncluded = ds . isEverythingIncluded ( ) ; if ( isEverythingIncluded && ! flatten && mapperElement == null ) { completeDirMap . put ( fromDir , destDir ) ; } scan ( fromDir , destDir , srcFiles , srcDirs ) ; } doFileOperations ( ) ; } finally { file = savedFile ; destFile = savedDestFile ; destDir = savedDestDir ; if ( savedFileSet != null ) { filesets . insertElementAt ( savedFileSet , 0 ) ; } fileCopyMap . clear ( ) ; dirCopyMap . clear ( ) ; completeDirMap . clear ( ) ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source " + "- a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of tofile and todir " + "may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of tofile or todir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Cannot concatenate multiple files into a single file." ) ; } else { FileSet fs = ( FileSet ) filesets . elementAt ( 0 ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; if ( srcFiles . length == 0 ) { throw new BuildException ( "Cannot perform operation from directory to file." ) ; } else if ( srcFiles . length == 1 ) { if ( file == null ) { file = new File ( ds . getBasedir ( ) , srcFiles [ 0 ] ) ; filesets . removeElementAt ( 0 ) ; } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } else { throw new BuildException ( "Cannot concatenate multiple " + "files into a single file." ) ; } } } if ( destFile != null ) { destDir = fileUtils . getParentFile ( destFile ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = filterSets . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } fileUtils . copyFile ( fromFile , toFile , executionFilters , filterChains , forceOverwrite , preserveLastModified , encoding , project ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Copied " + count + " empty director" + ( count == 1 ? "y" : "ies" ) + " to " + destDir . getAbsolutePath ( ) ) ; } } } } 	0	['27', '3', '1', '18', '87', '217', '1', '17', '20', '0.870445344', '919', '1', '2', '0.587301587', '0.212962963', '2', '2', '32.33333333', '13', '1.7037', '0']
package org . apache . tools . ant . types ; public class DTDLocation { private String publicId = null ; private String location = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } } 	0	['5', '1', '0', '1', '6', '0', '1', '0', '5', '0.5', '30', '1', '0', '0', '0.7', '0', '0', '4.6', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class Typedef extends Definer { protected void addDefinition ( String name , Class c ) throws BuildException { project . addDataTypeDefinition ( name , c ) ; } } 	0	['2', '6', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; public class FlexInteger { private Integer value ; public FlexInteger ( String value ) { this . value = Integer . decode ( value ) ; } public int intValue ( ) { return value . intValue ( ) ; } public String toString ( ) { return value . toString ( ) ; } } 	0	['3', '1', '0', '0', '7', '0', '0', '0', '3', '0', '19', '1', '0', '0', '0.666666667', '0', '0', '5', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '20', '21', '0', '2', '9', '0.6', '130', '1', '0', '0.804347826', '0.4', '1', '1', '11.5', '1', '0.9', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; class ChangeLogWriter { private static final SimpleDateFormat c_outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat c_outputTime = new SimpleDateFormat ( "hh:mm" ) ; public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; output . println ( "<changelog>" ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( output , entry ) ; } output . println ( "</changelog>" ) ; output . flush ( ) ; output . close ( ) ; } private void printEntry ( final PrintWriter output , final CVSEntry entry ) { output . println ( "\t<entry>" ) ; output . println ( "\t\t<date>" + c_outputDate . format ( entry . getDate ( ) ) + "</date>" ) ; output . println ( "\t\t<time>" + c_outputTime . format ( entry . getDate ( ) ) + "</time>" ) ; output . println ( "\t\t<author><![CDATA[" + entry . getAuthor ( ) + "]]></author>" ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; output . println ( "\t\t<file>" ) ; output . println ( "\t\t\t<name>" + file . getName ( ) + "</name>" ) ; output . println ( "\t\t\t<revision>" + file . getRevision ( ) + "</revision>" ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { output . println ( "\t\t\t<prevrevision>" + previousRevision + "</prevrevision>" ) ; } output . println ( "\t\t</file>" ) ; } output . println ( "\t\t<msg><![CDATA[" + entry . getComment ( ) + "]]></msg>" ) ; output . println ( "\t</entry>" ) ; } } 	0	['4', '1', '0', '3', '23', '4', '1', '2', '1', '0.333333333', '174', '1', '0', '0', '0.583333333', '0', '0', '42', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . BuildException ; class RedirectingStreamHandler extends PumpStreamHandler { RedirectingStreamHandler ( final ChangeLogParser parser ) { super ( new RedirectingOutputStream ( parser ) , new ByteArrayOutputStream ( ) ) ; } String getErrors ( ) { try { final ByteArrayOutputStream error = ( ByteArrayOutputStream ) getErr ( ) ; return error . toString ( "ASCII" ) ; } catch ( final Exception e ) { return null ; } } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( final IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '1', '2', '40', '0', '0', '0.857142857', '0.666666667', '0', '0', '12.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '1', '28', '11', '4', '26', '2', '5', '0.25', '54', '1', '0', '0', '0.533333333', '0', '0', '9.6', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setProject ( Project project ) { super . setProject ( project ) ; defaultSet . setProject ( project ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setDir ( new File ( src . getParent ( ) ) ) ; fs . createInclude ( ) . setName ( src . getName ( ) ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , location ) ; } if ( defaultSetDefined && defaultSet . getDir ( project ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( project ) == null ) { try { super . execute ( ) ; } finally { if ( defaultSetDefined && defaultSet . getDir ( project ) != null ) { filesets . removeElement ( defaultSet ) ; } } } else if ( isValidOs ( ) ) { Execute execute = prepareExec ( ) ; Commandline cloned = ( Commandline ) cmdl . clone ( ) ; cloned . createArgument ( ) . setValue ( defaultSet . getDir ( project ) . getPath ( ) ) ; try { execute . setCommandline ( cloned . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( taskType + " doesn\'t support the executable attribute" , location ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( taskType + " doesn\'t support the command attribute" , location ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( taskType + " doesn\'t support the skipemptyfileset attribute" , location ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	0	['17', '5', '0', '15', '57', '22', '0', '15', '15', '0.583333333', '298', '1', '1', '0.869918699', '0.264705882', '4', '7', '16.35294118', '4', '1.2353', '0']
package org . apache . tools . ant . util ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . util . Vector ; public final class StringUtils { public static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static Vector lineSplit ( String data ) { return split ( data , '\n' ) ; } public static Vector split ( String data , int ch ) { Vector elems = new Vector ( ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( ch , i ) ) != - 1 ) { String elem = data . substring ( i , pos ) ; elems . addElement ( elem ) ; i = pos + 1 ; } elems . addElement ( data . substring ( i ) ) ; return elems ; } public static String replace ( String data , String from , String to ) { StringBuffer buf = new StringBuffer ( data . length ( ) ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( from , i ) ) != - 1 ) { buf . append ( data . substring ( i , pos ) ) . append ( to ) ; i = pos + from . length ( ) ; } buf . append ( data . substring ( i ) ) ; return buf . toString ( ) ; } public static String getStackTrace ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; pw . close ( ) ; return sw . toString ( ) ; } } 	0	['6', '1', '0', '14', '24', '15', '14', '0', '5', '1', '116', '0', '0', '0', '0.3', '0', '0', '18.16666667', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class PrefixLines extends BaseParamFilterReader implements ChainableReader { private static final String PREFIX_KEY = "prefix" ; private String prefix = null ; private String queuedData = null ; public PrefixLines ( ) { super ( ) ; } public PrefixLines ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readLine ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { if ( prefix != null ) { queuedData = prefix + queuedData ; } return read ( ) ; } } return ch ; } public final void setPrefix ( final String prefix ) { this . prefix = prefix ; } private final String getPrefix ( ) { return prefix ; } public final Reader chain ( final Reader rdr ) { PrefixLines newFilter = new PrefixLines ( rdr ) ; newFilter . setPrefix ( getPrefix ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( PREFIX_KEY . equals ( params [ i ] . getName ( ) ) ) { prefix = params [ i ] . getValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '5', '22', '0', '1', '4', '5', '0.555555556', '150', '1', '0', '0.848484848', '0.476190476', '2', '5', '20', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '7', '13', '1', '1', '6', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class HeadFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private long linesRead = 0 ; private long lines = 10 ; public HeadFilter ( ) { super ( ) ; } public HeadFilter ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( linesRead < lines ) { ch = in . read ( ) ; if ( ch == '\n' ) { linesRead ++ ; } } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final Reader chain ( final Reader rdr ) { HeadFilter newFilter = new HeadFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { lines = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '5', '0.555555556', '113', '1', '0', '0.848484848', '0.476190476', '2', '4', '14.71428571', '4', '1.1429', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . util . StringUtils ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public NoBannerLogger ( ) { } public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( StringUtils . LINE_SEP + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '4', '16', '0', '0', '4', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class MailMessage { public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector to ; private Vector cc ; private Hashtable headers ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['29', '1', '0', '5', '66', '348', '2', '3', '12', '0.810714286', '567', '0.9', '2', '0', '0.317241379', '0', '0', '18.20689655', '11', '1.3793', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; public abstract class BaseParamFilterReader extends BaseFilterReader implements Parameterizable { private Parameter [ ] parameters ; public BaseParamFilterReader ( ) { super ( ) ; } public BaseParamFilterReader ( final Reader in ) { super ( in ) ; } public final void setParameters ( final Parameter [ ] parameters ) { this . parameters = parameters ; setInitialized ( false ) ; } protected final Parameter [ ] getParameters ( ) { return parameters ; } } 	0	['4', '4', '9', '12', '7', '4', '9', '3', '3', '0.666666667', '22', '1', '1', '0.928571429', '0.5', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . PrintStream ; import java . io . StringReader ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . DateUtils ; public class DefaultLogger implements BuildLogger { public static final int LEFT_COLUMN_SIZE = 12 ; protected PrintStream out ; protected PrintStream err ; protected int msgOutputLevel = Project . MSG_ERR ; private long startTime = System . currentTimeMillis ( ) ; protected static final String lSep = StringUtils . LINE_SEP ; protected boolean emacsMode = false ; public DefaultLogger ( ) { } public void setMessageOutputLevel ( int level ) { this . msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . out = new PrintStream ( output , true ) ; } public void setErrorPrintStream ( PrintStream err ) { this . err = new PrintStream ( err , true ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void buildStarted ( BuildEvent event ) { startTime = System . currentTimeMillis ( ) ; } public void buildFinished ( BuildEvent event ) { Throwable error = event . getException ( ) ; StringBuffer message = new StringBuffer ( ) ; if ( error == null ) { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD SUCCESSFUL" ) ; } else { message . append ( StringUtils . LINE_SEP ) ; message . append ( "BUILD FAILED" ) ; message . append ( StringUtils . LINE_SEP ) ; if ( Project . MSG_VERBOSE <= msgOutputLevel || ! ( error instanceof BuildException ) ) { message . append ( StringUtils . getStackTrace ( error ) ) ; } else { if ( error instanceof BuildException ) { message . append ( error . toString ( ) ) . append ( lSep ) ; } else { message . append ( error . getMessage ( ) ) . append ( lSep ) ; } } } message . append ( StringUtils . LINE_SEP ) ; message . append ( "Total time: " ) ; message . append ( formatTime ( System . currentTimeMillis ( ) - startTime ) ) ; String msg = message . toString ( ) ; if ( error == null ) { printMessage ( msg , out , Project . MSG_VERBOSE ) ; } else { printMessage ( msg , err , Project . MSG_ERR ) ; } log ( msg ) ; } public void targetStarted ( BuildEvent event ) { if ( Project . MSG_INFO <= msgOutputLevel ) { String msg = StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" ; printMessage ( msg , out , event . getPriority ( ) ) ; log ( msg ) ; } } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "] " ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( " " ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; while ( line != null ) { if ( ! first ) { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } protected static String formatTime ( final long millis ) { return DateUtils . formatElapsedTime ( millis ) ; } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { stream . println ( message ) ; } protected void log ( String message ) { } } 	0	['16', '1', '3', '13', '38', '80', '6', '7', '12', '0.876190476', '334', '0.857142857', '0', '0', '0.285714286', '0', '0', '19.4375', '8', '1.6875', '0']
package org . apache . tools . tar ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; private boolean v7Format ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; this . v7Format = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public long skip ( long numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; long skip = numToSkip ; while ( skip > 0 ) { int realSkip = ( int ) ( skip > skipBuf . length ? skipBuf . length : skip ) ; int numRead = this . read ( skipBuf , 0 , realSkip ) ; if ( numRead == - 1 ) { break ; } skip -= numRead ; } return ( numToSkip - skip ) ; } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . v7Format = true ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	0	['16', '3', '0', '3', '38', '84', '1', '2', '16', '0.674074074', '541', '1', '2', '0.580645161', '0.25', '2', '8', '32.25', '1', '0.8125', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0	['1', '1', '0', '18', '1', '0', '17', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . LogOutputStream ; class RedirectingOutputStream extends LogOutputStream { private final ChangeLogParser m_parser ; public RedirectingOutputStream ( final ChangeLogParser parser ) { super ( null , 0 ) ; m_parser = parser ; } protected void processLine ( final String line ) { m_parser . stdout ( line ) ; } } 	0	['2', '4', '0', '4', '4', '0', '1', '3', '1', '0', '16', '1', '1', '0.9375', '0.666666667', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String a1 ) { string = a1 ; } public void setSubstring ( String a2 ) { subString = a2 ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . xml . sax . Locator ; import org . xml . sax . InputSource ; import org . xml . sax . HandlerBase ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . DocumentHandler ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . XMLReaderAdapter ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . TaskAdapter ; import org . apache . tools . ant . util . JAXPUtils ; public class ProjectHelperImpl extends ProjectHelper { private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by default plugin" ) ; } File buildFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( buildFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = "file:" + buildFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; for ( int index = uri . indexOf ( '#' ) ; index != - 1 ; index = uri . indexOf ( '#' ) ) { uri = uri . substring ( 0 , index ) + "%23" + uri . substring ( index + 1 ) ; } inputStream = new FileInputStream ( buildFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + buildFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException ioe ) { } } } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } protected void finished ( ) { } public void endElement ( String name ) throws SAXException { finished ( ) ; helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = systemId . substring ( 5 ) ; int index = path . indexOf ( "file:" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + path . substring ( index + 5 ) ; index = path . indexOf ( "file:" ) ; } String entitySystemId = path ; index = path . indexOf ( "%23" ) ; while ( index != - 1 ) { path = path . substring ( 0 , index ) + "#" + path . substring ( index + 3 ) ; index = path . indexOf ( "%23" ) ; } File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( helperImpl . buildFileParent , path ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( "file:" + entitySystemId ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def == null ) { throw new SAXParseException ( "The default attribute of project " + "is required" , helperImpl . locator ) ; } else { helperImpl . project . setDefaultTarget ( def ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { helperImpl . project . setBaseDir ( helperImpl . project . resolveFile ( baseDir , helperImpl . buildFileParent ) ) ; } } } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "taskdef" ) ) { handleTaskdef ( name , attrs ) ; } else if ( name . equals ( "typedef" ) ) { handleTypedef ( name , attrs ) ; } else if ( name . equals ( "property" ) ) { handleProperty ( name , attrs ) ; } else if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( name ) != null ) { handleDataType ( name , attrs ) ; } else { throw new SAXParseException ( "Unexpected element \"" + name + "\"" , helperImpl . locator ) ; } } private void handleTaskdef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( helperImpl , this , null , null , null ) ) . init ( name , attrs ) ; } private void handleTypedef ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( helperImpl , this , null , null , null ) ) . init ( name , attrs ) ; } private void handleProperty ( String name , AttributeList attrs ) throws SAXParseException { ( new TaskHandler ( helperImpl , this , null , null , null ) ) . init ( name , attrs ) ; } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } private void handleDataType ( String name , AttributeList attrs ) throws SAXParseException { new DataTypeHandler ( helperImpl , this ) . init ( name , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( name ) != null ) { new DataTypeHandler ( helperImpl , this , target ) . init ( name , attrs ) ; } else { new TaskHandler ( helperImpl , this , target , null , target ) . init ( name , attrs ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator . getSystemId ( ) , helperImpl . locator . getLineNumber ( ) , helperImpl . locator . getColumnNumber ( ) ) ) ; helperImpl . configureId ( task , attrs ) ; if ( target != null ) { task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } else { task . init ( ) ; configure ( task , attrs , helperImpl . project ) ; } } protected void finished ( ) { if ( task != null && target == null ) { task . execute ( ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { if ( wrapper == null ) { try { ProjectHelper . addText ( helperImpl . project , task , buf , start , count ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } else { wrapper . addText ( buf , start , count ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TaskAdapter ) { this . parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; if ( parentWrapper != null ) { childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } else { configure ( child , attrs , helperImpl . project ) ; ih . storeElement ( helperImpl . project , parent , child , elementName ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { if ( parentWrapper == null ) { try { ProjectHelper . addText ( helperImpl . project , child , buf , start , count ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } else { childWrapper . addText ( buf , start , count ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this ( helperImpl , parentHandler , null ) ; } public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } if ( target != null ) { wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } else { configure ( element , attrs , helperImpl . project ) ; helperImpl . configureId ( element , attrs ) ; } } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { try { ProjectHelper . addText ( helperImpl . project , element , buf , start , count ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['9', '2', '0', '12', '50', '24', '8', '6', '2', '0.85', '288', '1', '1', '0.68', '0.296296296', '1', '1', '30.44444444', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class Taskdef extends Definer { protected void addDefinition ( String name , Class c ) throws BuildException { project . addTaskDefinition ( name , c ) ; } } 	0	['2', '6', '0', '4', '4', '1', '0', '4', '1', '2', '11', '0', '0', '0.987179487', '0.666666667', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public final void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private final int getTablength ( ) { return tabLength ; } public final Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '5', '0.708333333', '126', '1', '0', '0.848484848', '0.476190476', '2', '5', '16.42857143', '5', '1.2857', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat c_inputDate = new SimpleDateFormat ( "yyyy/MM/dd hh:mm:ss" ) ; private String m_file ; private String m_date ; private String m_author ; private String m_comment ; private String m_revision ; private String m_previousRevision ; private int m_status = GET_FILE ; private final Hashtable m_entries = new Hashtable ( ) ; CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ m_entries . size ( ) ] ; Enumeration enum = m_entries . elements ( ) ; int i = 0 ; while ( enum . hasMoreElements ( ) ) { array [ i ++ ] = ( CVSEntry ) enum . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( m_status ) { case GET_FILE : processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . startsWith ( "======" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; saveEntry ( ) ; m_status = GET_FILE ; } else if ( line . startsWith ( "----------------------------" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; m_status = GET_PREVIOUS_REV ; } else { m_comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { m_file = line . substring ( 14 , line . length ( ) ) ; m_status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { m_revision = line . substring ( 9 ) ; m_status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { m_status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { m_date = line . substring ( 6 , 25 ) ; String lineData = line . substring ( line . indexOf ( ";" ) + 1 ) ; m_author = lineData . substring ( 10 , lineData . indexOf ( ";" ) ) ; m_status = GET_COMMENT ; m_comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision" ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } m_previousRevision = line . substring ( 9 ) ; saveEntry ( ) ; m_revision = m_previousRevision ; m_status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = m_date + m_author + m_comment ; CVSEntry entry ; if ( ! m_entries . containsKey ( entryKey ) ) { entry = new CVSEntry ( parseDate ( m_date ) , m_author , m_comment ) ; m_entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) m_entries . get ( entryKey ) ; } entry . addFile ( m_file , m_revision , m_previousRevision ) ; } private Date parseDate ( final String date ) { try { return c_inputDate . parse ( date ) ; } catch ( ParseException e ) { return null ; } } } 	0	['11', '1', '0', '4', '34', '0', '3', '1', '1', '0.785714286', '312', '1', '0', '0', '0.85', '0', '0', '26.09090909', '3', '1.7273', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { int MATCH_DEFAULT = 0x00000000 ; int MATCH_CASE_INSENSITIVE = 0x00000100 ; int MATCH_MULTILINE = 0x00001000 ; int MATCH_SINGLELINE = 0x00010000 ; void setPattern ( String pattern ) throws BuildException ; String getPattern ( ) throws BuildException ; boolean matches ( String argument ) throws BuildException ; Vector getGroups ( String argument ) throws BuildException ; boolean matches ( String input , int options ) throws BuildException ; Vector getGroups ( String input , int options ) throws BuildException ; } 	0	['6', '1', '0', '7', '6', '15', '6', '1', '6', '1.2', '10', '0', '0', '0', '0.722222222', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public abstract class BaseFilterReader extends FilterReader { private boolean initialized = false ; private Project project = null ; public BaseFilterReader ( ) { super ( new StringReader ( new String ( ) ) ) ; try { close ( ) ; } catch ( IOException ioe ) { } } public BaseFilterReader ( final Reader in ) { super ( in ) ; } public final int read ( final char cbuf [ ] , final int off , final int len ) throws IOException { for ( int i = 0 ; i < len ; i ++ ) { final int ch = read ( ) ; if ( ch == - 1 ) { if ( i == 0 ) { return - 1 ; } else { return i ; } } cbuf [ off + i ] = ( char ) ch ; } return len ; } public final long skip ( final long n ) throws IOException { if ( n < 0L ) { throw new IllegalArgumentException ( "skip value is negative" ) ; } for ( long i = 0 ; i < n ; i ++ ) { if ( read ( ) == - 1 ) { return i ; } } return n ; } protected final void setInitialized ( final boolean initialized ) { this . initialized = initialized ; } protected final boolean getInitialized ( ) { return initialized ; } public final void setProject ( final Project project ) { this . project = project ; } protected final Project getProject ( ) { return project ; } protected final String readLine ( ) throws IOException { int ch = in . read ( ) ; if ( ch == - 1 ) { return null ; } StringBuffer line = new StringBuffer ( ) ; while ( ch != - 1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n' ) { break ; } ch = in . read ( ) ; } return line . toString ( ) ; } protected final String readFully ( ) throws IOException { return FileUtils . readFully ( in , 8192 ) ; } } 	0	['10', '3', '4', '16', '21', '23', '14', '2', '5', '0.666666667', '149', '1', '1', '0.692307692', '0.228571429', '1', '2', '13.7', '1', '0.8', '0']
package org . apache . tools . zip ; import java . io . OutputStream ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Date ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . ZipException ; public class ZipOutputStream extends DeflaterOutputStream { private ZipEntry entry ; private String comment = "" ; private int level = Deflater . DEFAULT_COMPRESSION ; private boolean hasCompressionLevelChanged = false ; private int method = DEFLATED ; private Vector entries = new Vector ( ) ; private CRC32 crc = new CRC32 ( ) ; private long written = 0 ; private long dataStart = 0 ; private ZipLong cdOffset = new ZipLong ( 0 ) ; private ZipLong cdLength = new ZipLong ( 0 ) ; private static final byte [ ] ZERO = { 0 , 0 } ; private static final byte [ ] LZERO = { 0 , 0 , 0 , 0 } ; private Hashtable offsets = new Hashtable ( ) ; private String encoding = null ; public static final int DEFLATED = ZipEntry . DEFLATED ; public static final int STORED = ZipEntry . STORED ; public ZipOutputStream ( OutputStream out ) { super ( out , new Deflater ( Deflater . DEFAULT_COMPRESSION , true ) ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void finish ( ) throws IOException { closeEntry ( ) ; cdOffset = new ZipLong ( written ) ; for ( int i = 0 ; i < entries . size ( ) ; i ++ ) { writeCentralFileHeader ( ( ZipEntry ) entries . elementAt ( i ) ) ; } cdLength = new ZipLong ( written - cdOffset . getValue ( ) ) ; writeCentralDirectoryEnd ( ) ; offsets . clear ( ) ; entries . removeAllElements ( ) ; } public void closeEntry ( ) throws IOException { if ( entry == null ) { return ; } long realCrc = crc . getValue ( ) ; crc . reset ( ) ; if ( entry . getMethod ( ) == DEFLATED ) { def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } entry . setSize ( def . getTotalIn ( ) ) ; entry . setComprSize ( def . getTotalOut ( ) ) ; entry . setCrc ( realCrc ) ; def . reset ( ) ; written += entry . getCompressedSize ( ) ; } else { if ( entry . getCrc ( ) != realCrc ) { throw new ZipException ( "bad CRC checksum for entry " + entry . getName ( ) + ": " + Long . toHexString ( entry . getCrc ( ) ) + " instead of " + Long . toHexString ( realCrc ) ) ; } if ( entry . getSize ( ) != written - dataStart ) { throw new ZipException ( "bad size for entry " + entry . getName ( ) + ": " + entry . getSize ( ) + " instead of " + ( written - dataStart ) ) ; } } writeDataDescriptor ( entry ) ; entry = null ; } public void putNextEntry ( ZipEntry ze ) throws IOException { closeEntry ( ) ; entry = ze ; entries . addElement ( entry ) ; if ( entry . getMethod ( ) == - 1 ) { entry . setMethod ( method ) ; } if ( entry . getTime ( ) == - 1 ) { entry . setTime ( System . currentTimeMillis ( ) ) ; } if ( entry . getMethod ( ) == STORED ) { if ( entry . getSize ( ) == - 1 ) { throw new ZipException ( "uncompressed size is required for STORED method" ) ; } if ( entry . getCrc ( ) == - 1 ) { throw new ZipException ( "crc checksum is required for STORED method" ) ; } entry . setComprSize ( entry . getSize ( ) ) ; } else if ( hasCompressionLevelChanged ) { def . setLevel ( level ) ; hasCompressionLevelChanged = false ; } writeLocalFileHeader ( entry ) ; } public void setComment ( String comment ) { this . comment = comment ; } public void setLevel ( int level ) { hasCompressionLevelChanged = ( this . level != level ) ; this . level = level ; } public void setMethod ( int method ) { this . method = method ; } public void write ( byte [ ] b , int offset , int length ) throws IOException { if ( entry . getMethod ( ) == DEFLATED ) { super . write ( b , offset , length ) ; } else { out . write ( b , offset , length ) ; written += length ; } crc . update ( b , offset , length ) ; } protected static final ZipLong LFH_SIG = new ZipLong ( 0X04034B50L ) ; protected static final ZipLong DD_SIG = new ZipLong ( 0X08074B50L ) ; protected static final ZipLong CFH_SIG = new ZipLong ( 0X02014B50L ) ; protected static final ZipLong EOCD_SIG = new ZipLong ( 0X06054B50L ) ; protected void writeLocalFileHeader ( ZipEntry ze ) throws IOException { offsets . put ( ze , new ZipLong ( written ) ) ; out . write ( LFH_SIG . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( LZERO ) ; out . write ( LZERO ) ; out . write ( LZERO ) ; } else { out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; } written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getLocalFileDataExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; dataStart = written ; } protected void writeDataDescriptor ( ZipEntry ze ) throws IOException { if ( ze . getMethod ( ) != DEFLATED ) { return ; } out . write ( DD_SIG . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( entry . getSize ( ) ) ) . getBytes ( ) ) ; written += 16 ; } protected void writeCentralFileHeader ( ZipEntry ze ) throws IOException { out . write ( CFH_SIG . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; written += 2 ; if ( ze . getMethod ( ) == DEFLATED ) { out . write ( ( new ZipShort ( 20 ) ) . getBytes ( ) ) ; out . write ( ( new ZipShort ( 8 ) ) . getBytes ( ) ) ; } else { out . write ( ( new ZipShort ( 10 ) ) . getBytes ( ) ) ; out . write ( ZERO ) ; } written += 4 ; out . write ( ( new ZipShort ( ze . getMethod ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( toDosTime ( new Date ( ze . getTime ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( new ZipLong ( ze . getCrc ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getCompressedSize ( ) ) ) . getBytes ( ) ) ; out . write ( ( new ZipLong ( ze . getSize ( ) ) ) . getBytes ( ) ) ; written += 12 ; byte [ ] name = getBytes ( ze . getName ( ) ) ; out . write ( ( new ZipShort ( name . length ) ) . getBytes ( ) ) ; written += 2 ; byte [ ] extra = ze . getCentralDirectoryExtra ( ) ; out . write ( ( new ZipShort ( extra . length ) ) . getBytes ( ) ) ; written += 2 ; String comm = ze . getComment ( ) ; if ( comm == null ) { comm = "" ; } byte [ ] comment = getBytes ( comm ) ; out . write ( ( new ZipShort ( comment . length ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ZERO ) ; written += 2 ; out . write ( ( new ZipShort ( ze . getInternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 2 ; out . write ( ( new ZipLong ( ze . getExternalAttributes ( ) ) ) . getBytes ( ) ) ; written += 4 ; out . write ( ( ( ZipLong ) offsets . get ( ze ) ) . getBytes ( ) ) ; written += 4 ; out . write ( name ) ; written += name . length ; out . write ( extra ) ; written += extra . length ; out . write ( comment ) ; written += comment . length ; } protected void writeCentralDirectoryEnd ( ) throws IOException { out . write ( EOCD_SIG . getBytes ( ) ) ; out . write ( ZERO ) ; out . write ( ZERO ) ; byte [ ] num = ( new ZipShort ( entries . size ( ) ) ) . getBytes ( ) ; out . write ( num ) ; out . write ( num ) ; out . write ( cdLength . getBytes ( ) ) ; out . write ( cdOffset . getBytes ( ) ) ; byte [ ] data = getBytes ( comment ) ; out . write ( ( new ZipShort ( data . length ) ) . getBytes ( ) ) ; out . write ( data ) ; } private static final ZipLong DOS_TIME_MIN = new ZipLong ( 0x00002100L ) ; protected static ZipLong toDosTime ( Date time ) { int year = time . getYear ( ) + 1900 ; int month = time . getMonth ( ) + 1 ; if ( year < 1980 ) { return DOS_TIME_MIN ; } long value = ( ( year - 1980 ) << 25 ) | ( month << 21 ) | ( time . getDate ( ) << 16 ) | ( time . getHours ( ) << 11 ) | ( time . getMinutes ( ) << 5 ) | ( time . getSeconds ( ) > > 1 ) ; byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return new ZipLong ( result ) ; } protected byte [ ] getBytes ( String name ) throws ZipException { if ( encoding == null ) { return name . getBytes ( ) ; } else { try { return name . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException uee ) { throw new ZipException ( uee . getMessage ( ) ) ; } } } } 	0	['17', '4', '0', '7', '81', '40', '4', '3', '10', '0.823863636', '1178', '0.909090909', '8', '0.516129032', '0.25', '2', '4', '67', '2', '1', '0']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	0	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '0']
package org . apache . tools . ant ; import java . util . Vector ; public class UnknownElement extends Task { private String elementName ; private Object realThing ; private Vector children = new Vector ( ) ; public UnknownElement ( String elementName ) { this . elementName = elementName ; } public String getTag ( ) { return elementName ; } public void maybeConfigure ( ) throws BuildException { realThing = makeObject ( this , wrapper ) ; wrapper . setProxy ( realThing ) ; if ( realThing instanceof Task ) { ( ( Task ) realThing ) . setRuntimeConfigurableWrapper ( wrapper ) ; } handleChildren ( realThing , wrapper ) ; wrapper . maybeConfigure ( project ) ; } protected void handleOutput ( String line ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleOutput ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( realThing instanceof Task ) { ( ( Task ) realThing ) . handleErrorOutput ( line ) ; } else { super . handleErrorOutput ( line ) ; } } public void execute ( ) { if ( realThing == null ) { throw new BuildException ( "Could not create task of type: " + elementName , location ) ; } if ( realThing instanceof Task ) { ( ( Task ) realThing ) . execute ( ) ; } } public void addChild ( UnknownElement child ) { children . addElement ( child ) ; } protected void handleChildren ( Object parent , RuntimeConfigurable parentWrapper ) throws BuildException { if ( parent instanceof TaskAdapter ) { parent = ( ( TaskAdapter ) parent ) . getProxy ( ) ; } Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( parentClass ) ; for ( int i = 0 ; i < children . size ( ) ; i ++ ) { RuntimeConfigurable childWrapper = parentWrapper . getChild ( i ) ; UnknownElement child = ( UnknownElement ) children . elementAt ( i ) ; Object realChild = null ; if ( parent instanceof TaskContainer ) { realChild = makeTask ( child , childWrapper , false ) ; ( ( TaskContainer ) parent ) . addTask ( ( Task ) realChild ) ; } else { realChild = ih . createElement ( project , parent , child . getTag ( ) ) ; } childWrapper . setProxy ( realChild ) ; if ( parent instanceof TaskContainer ) { ( ( Task ) realChild ) . setRuntimeConfigurableWrapper ( childWrapper ) ; } child . handleChildren ( realChild , childWrapper ) ; if ( parent instanceof TaskContainer ) { ( ( Task ) realChild ) . maybeConfigure ( ) ; } } } protected Object makeObject ( UnknownElement ue , RuntimeConfigurable w ) { Object o = makeTask ( ue , w , true ) ; if ( o == null ) { o = project . createDataType ( ue . getTag ( ) ) ; } if ( o == null ) { throw getNotFoundException ( "task or type" , ue . getTag ( ) ) ; } return o ; } protected Task makeTask ( UnknownElement ue , RuntimeConfigurable w , boolean onTopLevel ) { Task task = project . createTask ( ue . getTag ( ) ) ; if ( task == null && ! onTopLevel ) { throw getNotFoundException ( "task" , ue . getTag ( ) ) ; } if ( task != null ) { task . setLocation ( getLocation ( ) ) ; task . setOwningTarget ( target ) ; task . init ( ) ; } return task ; } protected BuildException getNotFoundException ( String what , String elementName ) { String lSep = System . getProperty ( "line.separator" ) ; String msg = "Could not create " + what + " of type: " + elementName + "." + lSep + lSep + "Ant could not find the task or a class this " + "task relies upon." + lSep + lSep + "This is common and has a number of causes; the usual " + lSep + "solutions are to read the manual pages then download and" + lSep + "install needed JAR files, or fix the build file: " + lSep + " - You have misspelt '" + elementName + "'." + lSep + "   Fix: check your spelling." + lSep + " - The task needs an external JAR file to execute" + lSep + "   and this is not found at the right place in the classpath." + lSep + "   Fix: check the documentation for dependencies." + lSep + "   Fix: declare the task." + lSep + " - The task is an Ant optional task and optional.jar is absent" + lSep + "   Fix: look for optional.jar in ANT_HOME/lib, download if needed" + lSep + " - The task was not built into optional.jar as dependent" + lSep + "   libraries were not found at build time." + lSep + "   Fix: look in the JAR to verify, then rebuild with the needed" + lSep + "   libraries, or download a release version from apache.org" + lSep + " - The build file was written for a later version of Ant" + lSep + "   Fix: upgrade to at least the latest release version of Ant" + lSep + " - The task is not an Ant core or optional task " + lSep + "   and needs to be declared using <taskdef>." + lSep + lSep + "Remember that for JAR files to be visible to Ant tasks implemented" + lSep + "in ANT_HOME/lib, the files must be in the same directory or on the" + lSep + "classpath" + lSep + lSep + "Please neither file bug reports on this problem, nor email the" + lSep + "Ant mailing lists, until all of these causes have been explored," + lSep + "as this is not an Ant bug." ; return new BuildException ( msg , location ) ; } public String getTaskName ( ) { return realThing == null || ! ( realThing instanceof Task ) ? super . getTaskName ( ) : ( ( Task ) realThing ) . getTaskName ( ) ; } public Task getTask ( ) { if ( realThing instanceof Task ) { return ( Task ) realThing ; } return null ; } } 	0	['13', '3', '0', '12', '43', '36', '3', '10', '7', '0.638888889', '424', '1', '0', '0.755102041', '0.320512821', '1', '6', '31.38461538', '4', '1.8462', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '3', '30', '0', '0', '3', '5', '0.6', '1262', '1', '0', '0.880952381', '0.555555556', '1', '1', '208.6666667', '2', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent { protected Project project = null ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( project != null ) { project . log ( msg , msgLevel ) ; } } } 	0	['5', '1', '10', '98', '7', '0', '98', '1', '5', '0', '33', '1', '1', '0', '0.45', '0', '0', '5.4', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import java . io . IOException ; import java . io . FileOutputStream ; import java . util . zip . GZIPOutputStream ; public class GZip extends Pack { protected void pack ( ) { GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '4', '12', '1', '0', '4', '1', '2', '55', '0', '0', '0.980392157', '1', '1', '2', '26.5', '4', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . Checksum ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase extends ProjectComponent { private Vector conditions = new Vector ( ) ; protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return conditions . elements ( ) ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addChecksum ( Checksum c ) { conditions . addElement ( c ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } public void addIsSet ( IsSet i ) { conditions . addElement ( i ) ; } public void addHttp ( Http h ) { conditions . addElement ( h ) ; } public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } public void addFilesMatch ( FilesMatch test ) { conditions . addElement ( test ) ; } public void addContains ( Contains test ) { conditions . addElement ( test ) ; } public void addIsTrue ( IsTrue test ) { conditions . addElement ( test ) ; } public void addIsFalse ( IsFalse test ) { conditions . addElement ( test ) ; } } 	0	['18', '2', '5', '18', '23', '0', '5', '16', '16', '0', '110', '1', '0', '0.346153846', '0.114583333', '0', '0', '5.055555556', '1', '0.9444', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Hashtable ; import org . apache . tools . ant . types . Parameter ; public final class ReplaceTokens extends BaseParamFilterReader implements ChainableReader { private static final char DEFAULT_BEGIN_TOKEN = '@' ; private static final char DEFAULT_END_TOKEN = '@' ; private String queuedData = null ; private Hashtable hash = new Hashtable ( ) ; private char beginToken = DEFAULT_BEGIN_TOKEN ; private char endToken = DEFAULT_END_TOKEN ; public ReplaceTokens ( ) { super ( ) ; } public ReplaceTokens ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } if ( queuedData != null && queuedData . length ( ) > 0 ) { final int ch = queuedData . charAt ( 0 ) ; if ( queuedData . length ( ) > 1 ) { queuedData = queuedData . substring ( 1 ) ; } else { queuedData = null ; } return ch ; } int ch = in . read ( ) ; if ( ch == beginToken ) { final StringBuffer key = new StringBuffer ( "" ) ; do { ch = in . read ( ) ; if ( ch != - 1 ) { key . append ( ( char ) ch ) ; } else { break ; } } while ( ch != endToken ) ; if ( ch == - 1 ) { queuedData = beginToken + key . toString ( ) ; return read ( ) ; } else { key . setLength ( key . length ( ) - 1 ) ; final String replaceWith = ( String ) hash . get ( key . toString ( ) ) ; if ( replaceWith != null ) { queuedData = replaceWith ; return read ( ) ; } else { queuedData = beginToken + key . toString ( ) + endToken ; return read ( ) ; } } } return ch ; } public final void setBeginToken ( final char beginToken ) { this . beginToken = beginToken ; } private final char getBeginToken ( ) { return beginToken ; } public final void setEndToken ( final char endToken ) { this . endToken = endToken ; } private final char getEndToken ( ) { return endToken ; } public final void addConfiguredToken ( final Token token ) { hash . put ( token . getKey ( ) , token . getValue ( ) ) ; } private void setTokens ( final Hashtable hash ) { this . hash = hash ; } private final Hashtable getTokens ( ) { return hash ; } public final Reader chain ( final Reader rdr ) { ReplaceTokens newFilter = new ReplaceTokens ( rdr ) ; newFilter . setBeginToken ( getBeginToken ( ) ) ; newFilter . setEndToken ( getEndToken ( ) ) ; newFilter . setTokens ( getTokens ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { final String type = params [ i ] . getType ( ) ; if ( "tokenchar" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; if ( "begintoken" . equals ( name ) ) { beginToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } else if ( "endtoken" . equals ( name ) ) { endToken = params [ i ] . getValue ( ) . charAt ( 0 ) ; } } else if ( "token" . equals ( type ) ) { final String name = params [ i ] . getName ( ) ; final String value = params [ i ] . getValue ( ) ; hash . put ( name , value ) ; } } } } } public static class Token { private String key ; private String value ; public final void setKey ( String key ) { this . key = key ; } public final void setValue ( String value ) { this . value = value ; } public final String getKey ( ) { return key ; } public final String getValue ( ) { return value ; } } } 	0	['12', '5', '0', '6', '37', '0', '1', '5', '7', '0.696969697', '308', '1', '0', '0.736842105', '0.3', '2', '5', '24.16666667', '7', '1.3333', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; import java . util . Vector ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . toString ( ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '144', '1', '1', '0', '0.9', '0', '0', '27.2', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . mail . MailMessage ; class PlainMailer extends Mailer { public void send ( ) { try { MailMessage mailMessage = new MailMessage ( host , port ) ; mailMessage . from ( from . toString ( ) ) ; Enumeration e ; e = toList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . to ( e . nextElement ( ) . toString ( ) ) ; } e = ccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . cc ( e . nextElement ( ) . toString ( ) ) ; } e = bccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . bcc ( e . nextElement ( ) . toString ( ) ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } mailMessage . setHeader ( "Date" , getDate ( ) ) ; mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) ) ; PrintStream out = mailMessage . getPrintStream ( ) ; message . print ( out ) ; e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; attach ( file , out ) ; } mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail" , ioe ) ; } } protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } if ( includeFileNames ) { out . println ( ) ; String filename = file . getName ( ) ; int filenamelength = filename . length ( ) ; out . println ( filename ) ; for ( int star = 0 ; star < filenamelength ; star ++ ) { out . print ( '=' ) ; } out . println ( ) ; } int length ; byte [ ] buf = new byte [ 1024 ] ; FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr , buf . length ) ; while ( ( length = in . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { finstr . close ( ) ; } } } 	0	['3', '2', '0', '6', '38', '3', '1', '5', '1', '2', '198', '0', '0', '0.9', '0.555555556', '1', '1', '65', '6', '2.3333', '0']
package org . apache . tools . ant ; import java . io . PrintWriter ; import java . io . PrintStream ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String message ) { super ( message ) ; } public BuildException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String message , Location location ) { super ( message ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['14', '4', '0', '193', '26', '0', '192', '1', '14', '0.384615385', '153', '1', '1', '0.65', '0.333333333', '1', '2', '9.785714286', '2', '0.6429', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; public class WLRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; AntClassLoader loader = null ; try { Class c = null ; if ( getRmic ( ) . getClasspath ( ) == null ) { c = Class . forName ( "weblogic.rmic" ) ; } else { loader = new AntClassLoader ( getRmic ( ) . getProject ( ) , getRmic ( ) . getClasspath ( ) ) ; c = loader . loadClass ( "weblogic.rmic" ) ; AntClassLoader . initializeClass ( c ) ; } Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use WebLogic rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting WebLogic rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; } } } public String getStubClassSuffix ( ) { return "_WLStub" ; } public String getSkelClassSuffix ( ) { return "_WLSkel" ; } } 	0	['5', '2', '0', '11', '24', '10', '1', '10', '4', '1', '133', '0', '0', '0.764705882', '0.5', '0', '0', '25.4', '1', '0.8', '0']
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static void panic ( ) { System . out . println ( "panic" ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { int nNodes , nHeap , n1 , n2 , i , j , k ; boolean tooLong ; int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( i = 0 ; i < alphaSize ; i ++ ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } while ( true ) { nNodes = alphaSize ; nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; { int zz , tmp ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) ) { panic ( ) ; } while ( nHeap > 1 ) { n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; weight [ nNodes ] = ( ( weight [ n1 ] & 0xffffff00 ) + ( weight [ n2 ] & 0xffffff00 ) ) | ( 1 + ( ( ( weight [ n1 ] & 0x000000ff ) > ( weight [ n2 ] & 0x000000ff ) ) ? ( weight [ n1 ] & 0x000000ff ) : ( weight [ n2 ] & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; { int zz = 0 , tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) ) { panic ( ) ; } tooLong = false ; for ( i = 1 ; i <= alphaSize ; i ++ ) { j = 0 ; k = i ; while ( parent [ k ] >= 0 ) { k = parent [ k ] ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( ! tooLong ) { break ; } for ( i = 1 ; i < alphaSize ; i ++ ) { j = weight [ i ] > > 8 ; j = 1 + ( j / 2 ) ; weight [ i ] = j << 8 ; } } } int last ; int origPtr ; int blockSize100k ; boolean blockRandomised ; int bytesIn ; int bytesOut ; int bsBuff ; int bsLive ; CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private char [ ] block ; private int [ ] quadrant ; private int [ ] zptr ; private short [ ] szptr ; private int [ ] ftab ; private int nMTF ; private int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; private int workFactor ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int nBlocksRandomised ; private int currentChar = - 1 ; private int runLength = 0 ; public CBZip2OutputStream ( OutputStream inStream ) throws IOException { this ( inStream , 9 ) ; } public CBZip2OutputStream ( OutputStream inStream , int inBlockSize ) throws IOException { block = null ; quadrant = null ; zptr = null ; ftab = null ; bsSetStream ( inStream ) ; workFactor = 50 ; if ( inBlockSize > 9 ) { inBlockSize = 9 ; } if ( inBlockSize < 1 ) { inBlockSize = 1 ; } blockSize100k = inBlockSize ; allocateCompressStructures ( ) ; initialize ( ) ; initBlock ( ) ; } public void write ( int bv ) throws IOException { int b = ( 256 + bv ) % 256 ; if ( currentChar != - 1 ) { if ( currentChar == b ) { runLength ++ ; if ( runLength > 254 ) { writeRun ( ) ; currentChar = - 1 ; runLength = 0 ; } } else { writeRun ( ) ; runLength = 1 ; currentChar = b ; } } else { currentChar = b ; runLength ++ ; } } private void writeRun ( ) throws IOException { if ( last < allowableBlockSize ) { inUse [ currentChar ] = true ; for ( int i = 0 ; i < runLength ; i ++ ) { mCrc . updateCRC ( ( char ) currentChar ) ; } switch ( runLength ) { case 1 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 2 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 3 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; default : inUse [ runLength - 4 ] = true ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) ( runLength - 4 ) ; break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } boolean closed = false ; public void finalize ( ) throws Throwable { close ( ) ; } public void close ( ) throws IOException { if ( closed ) { return ; } if ( runLength > 0 ) { writeRun ( ) ; } currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; closed = true ; super . close ( ) ; bsStream . close ( ) ; } public void flush ( ) throws IOException { super . flush ( ) ; bsStream . flush ( ) ; } private int blockCRC , combinedCRC ; private void initialize ( ) throws IOException { bytesIn = 0 ; bytesOut = 0 ; nBlocksRandomised = 0 ; bsPutUChar ( 'h' ) ; bsPutUChar ( '0' + blockSize100k ) ; combinedCRC = 0 ; } private int allowableBlockSize ; private void initBlock ( ) { mCrc . initialiseCRC ( ) ; last = - 1 ; for ( int i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } allowableBlockSize = baseBlockSize * blockSize100k - 20 ; } private void endBlock ( ) throws IOException { blockCRC = mCrc . getFinalCRC ( ) ; combinedCRC = ( combinedCRC << 1 ) | ( combinedCRC > > > 31 ) ; combinedCRC ^= blockCRC ; doReversibleTransformation ( ) ; bsPutUChar ( 0x31 ) ; bsPutUChar ( 0x41 ) ; bsPutUChar ( 0x59 ) ; bsPutUChar ( 0x26 ) ; bsPutUChar ( 0x53 ) ; bsPutUChar ( 0x59 ) ; bsPutint ( blockCRC ) ; if ( blockRandomised ) { bsW ( 1 , 1 ) ; nBlocksRandomised ++ ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUChar ( 0x17 ) ; bsPutUChar ( 0x72 ) ; bsPutUChar ( 0x45 ) ; bsPutUChar ( 0x38 ) ; bsPutUChar ( 0x50 ) ; bsPutUChar ( 0x90 ) ; bsPutint ( combinedCRC ) ; bsFinishedWithStream ( ) ; } private void hbAssignCodes ( int [ ] code , char [ ] length , int minLen , int maxLen , int alphaSize ) { int n , vec , i ; vec = 0 ; for ( n = minLen ; n <= maxLen ; n ++ ) { for ( i = 0 ; i < alphaSize ; i ++ ) { if ( length [ i ] == n ) { code [ i ] = vec ; vec ++ ; } } ; vec <<= 1 ; } } private void bsSetStream ( OutputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; bytesOut = 0 ; bytesIn = 0 ; } private void bsFinishedWithStream ( ) throws IOException { while ( bsLive > 0 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } } private void bsW ( int n , int v ) throws IOException { while ( bsLive >= 8 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } bsBuff |= ( v << ( 32 - bsLive - n ) ) ; bsLive += n ; } private void bsPutUChar ( int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutint ( int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void bsPutIntVS ( int numBits , int c ) throws IOException { bsW ( numBits , c ) ; } private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups , nBytes ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 == 1 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } ; totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } nBytes = bytesOut ; for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } nBytes = bytesOut ; bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } nBytes = bytesOut ; for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } nBytes = bytesOut ; selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } } private void moveToFrontCodeAndSend ( ) throws IOException { bsPutIntVS ( 24 , origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private OutputStream bsStream ; private void simpleSort ( int lo , int hi , int d ) { int i , j , h , bigN , hp ; int v ; bigN = hi - lo + 1 ; if ( bigN < 2 ) { return ; } hp = 0 ; while ( incs [ hp ] < bigN ) { hp ++ ; } hp -- ; for ( ; hp >= 0 ; hp -- ) { h = incs [ hp ] ; i = lo + h ; while ( true ) { if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( workDone > workLimit && firstAttempt ) { return ; } } } } private void vswap ( int p1 , int p2 , int n ) { int temp = 0 ; while ( n > 0 ) { temp = zptr [ p1 ] ; zptr [ p1 ] = zptr [ p2 ] ; zptr [ p2 ] = temp ; p1 ++ ; p2 ++ ; n -- ; } } private char med3 ( char a , char b , char c ) { char t ; if ( a > b ) { t = a ; a = b ; b = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } if ( a > b ) { b = a ; } return b ; } private class StackElem { int ll ; int hh ; int dd ; } private void qSort3 ( int loSt , int hiSt , int dSt ) { int unLo , unHi , ltLo , gtHi , med , n , m ; int sp , lo , hi , d ; StackElem [ ] stack = new StackElem [ QSORT_STACK_SIZE ] ; for ( int count = 0 ; count < QSORT_STACK_SIZE ; count ++ ) { stack [ count ] = new StackElem ( ) ; } sp = 0 ; stack [ sp ] . ll = loSt ; stack [ sp ] . hh = hiSt ; stack [ sp ] . dd = dSt ; sp ++ ; while ( sp > 0 ) { if ( sp >= QSORT_STACK_SIZE ) { panic ( ) ; } sp -- ; lo = stack [ sp ] . ll ; hi = stack [ sp ] . hh ; d = stack [ sp ] . dd ; if ( hi - lo < SMALL_THRESH || d > DEPTH_THRESH ) { simpleSort ( lo , hi , d ) ; if ( workDone > workLimit && firstAttempt ) { return ; } continue ; } med = med3 ( block [ zptr [ lo ] + d + 1 ] , block [ zptr [ hi ] + d + 1 ] , block [ zptr [ ( lo + hi ) > > 1 ] + d + 1 ] ) ; unLo = ltLo = lo ; unHi = gtHi = hi ; while ( true ) { while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unLo ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ ltLo ] ; zptr [ ltLo ] = temp ; ltLo ++ ; unLo ++ ; continue ; } ; if ( n > 0 ) { break ; } unLo ++ ; } while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unHi ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unHi ] ; zptr [ unHi ] = zptr [ gtHi ] ; zptr [ gtHi ] = temp ; gtHi -- ; unHi -- ; continue ; } ; if ( n < 0 ) { break ; } unHi -- ; } if ( unLo > unHi ) { break ; } int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ unHi ] ; zptr [ unHi ] = temp ; unLo ++ ; unHi -- ; } if ( gtHi < ltLo ) { stack [ sp ] . ll = lo ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d + 1 ; sp ++ ; continue ; } n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( lo , unLo - n , n ) ; m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack [ sp ] . ll = lo ; stack [ sp ] . hh = n ; stack [ sp ] . dd = d ; sp ++ ; stack [ sp ] . ll = n + 1 ; stack [ sp ] . hh = m - 1 ; stack [ sp ] . dd = d + 1 ; sp ++ ; stack [ sp ] . ll = m ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d ; sp ++ ; } } private void mainSort ( ) { int i , j , ss , sb ; int [ ] runningOrder = new int [ 256 ] ; int [ ] copy = new int [ 256 ] ; boolean [ ] bigDone = new boolean [ 256 ] ; int c1 , c2 ; int numQSorted ; for ( i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ last + i + 2 ] = block [ ( i % ( last + 1 ) ) + 1 ] ; } for ( i = 0 ; i <= last + NUM_OVERSHOOT_BYTES ; i ++ ) { quadrant [ i ] = 0 ; } block [ 0 ] = ( char ) ( block [ last + 1 ] ) ; if ( last < 4000 ) { for ( i = 0 ; i <= last ; i ++ ) { zptr [ i ] = i ; } firstAttempt = false ; workDone = workLimit = 0 ; simpleSort ( 0 , last , 0 ) ; } else { numQSorted = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { bigDone [ i ] = false ; } for ( i = 0 ; i <= 65536 ; i ++ ) { ftab [ i ] = 0 ; } c1 = block [ 0 ] ; for ( i = 0 ; i <= last ; i ++ ) { c2 = block [ i + 1 ] ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( i = 1 ; i <= 65536 ; i ++ ) { ftab [ i ] += ftab [ i - 1 ] ; } c1 = block [ 1 ] ; for ( i = 0 ; i < last ; i ++ ) { c2 = block [ i + 2 ] ; j = ( c1 << 8 ) + c2 ; c1 = c2 ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = i ; } j = ( ( block [ last + 1 ] ) << 8 ) + ( block [ 1 ] ) ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = last ; for ( i = 0 ; i <= 255 ; i ++ ) { runningOrder [ i ] = i ; } { int vv ; int h = 1 ; do { h = 3 * h + 1 ; } while ( h <= 256 ) ; do { h = h / 3 ; for ( i = h ; i <= 255 ; i ++ ) { vv = runningOrder [ i ] ; j = i ; while ( ( ftab [ ( ( runningOrder [ j - h ] ) + 1 ) << 8 ] - ftab [ ( runningOrder [ j - h ] ) << 8 ] ) > ( ftab [ ( ( vv ) + 1 ) << 8 ] - ftab [ ( vv ) << 8 ] ) ) { runningOrder [ j ] = runningOrder [ j - h ] ; j = j - h ; if ( j <= ( h - 1 ) ) { break ; } } runningOrder [ j ] = vv ; } } while ( h != 1 ) ; } for ( i = 0 ; i <= 255 ; i ++ ) { ss = runningOrder [ i ] ; for ( j = 0 ; j <= 255 ; j ++ ) { sb = ( ss << 8 ) + j ; if ( ! ( ( ftab [ sb ] & SETMASK ) == SETMASK ) ) { int lo = ftab [ sb ] & CLEARMASK ; int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { qSort3 ( lo , hi , 2 ) ; numQSorted += ( hi - lo + 1 ) ; if ( workDone > workLimit && firstAttempt ) { return ; } } ftab [ sb ] |= SETMASK ; } } bigDone [ ss ] = true ; if ( i < 255 ) { int bbStart = ftab [ ss << 8 ] & CLEARMASK ; int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( j = 0 ; j < bbSize ; j ++ ) { int a2update = zptr [ bbStart + j ] ; int qVal = ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + last + 1 ] = qVal ; } } if ( ! ( ( ( bbSize - 1 ) > > shifts ) <= 65535 ) ) { panic ( ) ; } } for ( j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( j = ftab [ ss << 8 ] & CLEARMASK ; j < ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j ++ ) { c1 = block [ zptr [ j ] ] ; if ( ! bigDone [ c1 ] ) { zptr [ copy [ c1 ] ] = zptr [ j ] == 0 ? last : zptr [ j ] - 1 ; copy [ c1 ] ++ ; } } for ( j = 0 ; j <= 255 ; j ++ ) { ftab [ ( j << 8 ) + ss ] |= SETMASK ; } } } } private void randomiseBlock ( ) { int i ; int rNToGo = 0 ; int rTPos = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i <= last ; i ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; block [ i + 1 ] &= 0xFF ; inUse [ block [ i + 1 ] ] = true ; } } private void doReversibleTransformation ( ) { int i ; workLimit = workFactor * last ; workDone = 0 ; blockRandomised = false ; firstAttempt = true ; mainSort ( ) ; if ( workDone > workLimit && firstAttempt ) { randomiseBlock ( ) ; workLimit = workDone = 0 ; blockRandomised = true ; firstAttempt = false ; mainSort ( ) ; } origPtr = - 1 ; for ( i = 0 ; i <= last ; i ++ ) { if ( zptr [ i ] == 0 ) { origPtr = i ; break ; } } ; if ( origPtr == - 1 ) { panic ( ) ; } } private boolean fullGtU ( int i1 , int i2 ) { int k ; char c1 , c2 ; int s1 , s2 ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; k = last + 1 ; do { c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; if ( i1 > last ) { i1 -= last ; i1 -- ; } ; if ( i2 > last ) { i2 -= last ; i2 -- ; } ; k -= 4 ; workDone ++ ; } while ( k >= 0 ) ; return false ; } private int [ ] incs = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; private void allocateCompressStructures ( ) { int n = baseBlockSize * blockSize100k ; block = new char [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; quadrant = new int [ ( n + NUM_OVERSHOOT_BYTES ) ] ; zptr = new int [ n ] ; ftab = new int [ 65537 ] ; if ( block == null || quadrant == null || zptr == null || ftab == null ) { } szptr = new short [ 2 * n ] ; } private void generateMTFValues ( ) { char [ ] yy = new char [ 256 ] ; int i , j ; char tmp ; char tmp2 ; int zPend ; int wr ; int EOB ; makeMaps ( ) ; EOB = nInUse + 1 ; for ( i = 0 ; i <= EOB ; i ++ ) { mtfFreq [ i ] = 0 ; } wr = 0 ; zPend = 0 ; for ( i = 0 ; i < nInUse ; i ++ ) { yy [ i ] = ( char ) i ; } for ( i = 0 ; i <= last ; i ++ ) { char ll_i ; ll_i = unseqToSeq [ block [ zptr [ i ] ] ] ; j = 0 ; tmp = yy [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } ; yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } ; if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } ; zPend = 0 ; } szptr [ wr ] = ( short ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } } szptr [ wr ] = ( short ) EOB ; wr ++ ; mtfFreq [ EOB ] ++ ; nMTF = wr ; } } 	0	['33', '2', '0', '6', '43', '322', '3', '4', '6', '0.859375', '4244', '0.761904762', '1', '0.138888889', '0.257575758', '1', '1', '126.3333333', '32', '5.6061', '0']
package org . apache . tools . ant . util ; import java . text . ChoiceFormat ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; public final class DateUtils { public static final String ISO8601_DATETIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss" ; public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd" ; public static final String ISO8601_TIME_PATTERN = "HH:mm:ss" ; private static final MessageFormat MINUTE_SECONDS = new MessageFormat ( "{0}{1}" ) ; private static final double [ ] LIMITS = { 0 , 1 , 2 } ; private static final String [ ] MINUTES_PART = { "" , "1 minute " , "{0,number} minutes " } ; private static final String [ ] SECONDS_PART = { "0 seconds" , "1 second" , "{1,number} seconds" } ; private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat ( LIMITS , MINUTES_PART ) ; private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat ( LIMITS , SECONDS_PART ) ; static { MINUTE_SECONDS . setFormat ( 0 , MINUTES_FORMAT ) ; MINUTE_SECONDS . setFormat ( 1 , SECONDS_FORMAT ) ; } private DateUtils ( ) { } public static String format ( long date , String pattern ) { return format ( new Date ( date ) , pattern ) ; } public static String format ( Date date , String pattern ) { DateFormat df = createDateFormat ( pattern ) ; return df . format ( date ) ; } public static String formatElapsedTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; Object [ ] args = { new Long ( minutes ) , new Long ( seconds % 60 ) } ; return MINUTE_SECONDS . format ( args ) ; } private static DateFormat createDateFormat ( String pattern ) { SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; TimeZone gmt = TimeZone . getTimeZone ( "GMT" ) ; sdf . setTimeZone ( gmt ) ; sdf . setLenient ( true ) ; return sdf ; } public static int getPhaseOfMoon ( Calendar cal ) { int dayOfTheYear = cal . get ( Calendar . DAY_OF_YEAR ) ; int yearInMetonicCycle = ( ( cal . get ( Calendar . YEAR ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * yearInMetonicCycle + 18 ) % 30 ; if ( ( epact == 25 && yearInMetonicCycle > 11 ) || epact == 24 ) { epact ++ ; } return ( ( ( ( ( dayOfTheYear + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; } } 	0	['7', '1', '0', '1', '20', '19', '1', '0', '4', '1.037037037', '197', '0.666666667', '0', '0', '0.266666667', '0', '0', '25.85714286', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public interface SelectorContainer { public boolean hasSelectors ( ) ; public int selectorCount ( ) ; public FileSelector [ ] getSelectors ( Project p ) ; public Enumeration selectorElements ( ) ; public void appendSelector ( FileSelector selector ) ; public void addSelector ( SelectSelector selector ) ; public void addAnd ( AndSelector selector ) ; public void addOr ( OrSelector selector ) ; public void addNot ( NotSelector selector ) ; public void addNone ( NoneSelector selector ) ; public void addMajority ( MajoritySelector selector ) ; public void addDate ( DateSelector selector ) ; public void addSize ( SizeSelector selector ) ; public void addFilename ( FilenameSelector selector ) ; public void addCustom ( ExtendSelector selector ) ; public void addContains ( ContainsSelector selector ) ; public void addPresent ( PresentSelector selector ) ; public void addDepth ( DepthSelector selector ) ; public void addDepend ( DependSelector selector ) ; } 	0	['19', '1', '0', '19', '19', '171', '3', '16', '19', '2', '19', '0', '0', '0', '0.108359133', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class Exit extends Task { private String message ; private String ifCondition , unlessCondition ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { if ( message != null && message . length ( ) > 0 ) { throw new BuildException ( message ) ; } else { throw new BuildException ( "No message" ) ; } } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += project . replaceProperties ( msg ) ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return project . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return project . getProperty ( unlessCondition ) == null ; } } 	0	['8', '3', '0', '4', '17', '18', '0', '4', '6', '0.714285714', '112', '1', '0', '0.840909091', '0.75', '0', '0', '12.625', '4', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , location ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , location ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , location ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { project . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '5', '22', '1', '0', '5', '6', '0.7', '137', '1', '0', '0.880952381', '0.416666667', '3', '3', '21.16666667', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . InputStream ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; import java . util . Stack ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; public class Project { public static final int MSG_ERR = 0 ; public static final int MSG_WARN = 1 ; public static final int MSG_INFO = 2 ; public static final int MSG_VERBOSE = 3 ; public static final int MSG_DEBUG = 4 ; private static final String VISITING = "VISITING" ; private static final String VISITED = "VISITED" ; public static final String JAVA_1_0 = JavaEnvUtils . JAVA_1_0 ; public static final String JAVA_1_1 = JavaEnvUtils . JAVA_1_1 ; public static final String JAVA_1_2 = JavaEnvUtils . JAVA_1_2 ; public static final String JAVA_1_3 = JavaEnvUtils . JAVA_1_3 ; public static final String JAVA_1_4 = JavaEnvUtils . JAVA_1_4 ; public static final String TOKEN_START = FilterSet . DEFAULT_TOKEN_START ; public static final String TOKEN_END = FilterSet . DEFAULT_TOKEN_END ; private String name ; private String description ; private Hashtable properties = new Hashtable ( ) ; private Hashtable userProperties = new Hashtable ( ) ; private Hashtable inheritedProperties = new Hashtable ( ) ; private Hashtable references = new Hashtable ( ) ; private String defaultTarget ; private Hashtable dataClassDefinitions = new Hashtable ( ) ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private Hashtable createdTasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private FilterSet globalFilterSet = new FilterSet ( ) ; private FilterSetCollection globalFilters = new FilterSetCollection ( globalFilterSet ) ; private File baseDir ; private Vector listeners = new Vector ( ) ; private ClassLoader coreLoader = null ; private Hashtable threadTasks = new Hashtable ( ) ; private InputHandler inputHandler = null ; public void setInputHandler ( InputHandler handler ) { inputHandler = handler ; } public InputHandler getInputHandler ( ) { return inputHandler ; } private FileUtils fileUtils ; public Project ( ) { fileUtils = FileUtils . newFileUtils ( ) ; inputHandler = new DefaultInputHandler ( ) ; } public void init ( ) throws BuildException { setJavaVersionProperty ( ) ; String defs = "/org/apache/tools/ant/taskdefs/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( defs ) ; if ( in == null ) { throw new BuildException ( "Can't load default task list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class taskClass = Class . forName ( value ) ; addTaskDefinition ( key , taskClass ) ; } catch ( NoClassDefFoundError ncdfe ) { log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for task " + key , MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { log ( "Could not load class (" + value + ") for task " + key , MSG_DEBUG ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default task list" ) ; } String dataDefs = "/org/apache/tools/ant/types/defaults.properties" ; try { Properties props = new Properties ( ) ; InputStream in = this . getClass ( ) . getResourceAsStream ( dataDefs ) ; if ( in == null ) { throw new BuildException ( "Can't load default datatype list" ) ; } props . load ( in ) ; in . close ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String key = ( String ) enum . nextElement ( ) ; String value = props . getProperty ( key ) ; try { Class dataClass = Class . forName ( value ) ; addDataTypeDefinition ( key , dataClass ) ; } catch ( NoClassDefFoundError ncdfe ) { } catch ( ClassNotFoundException cnfe ) { } } } catch ( IOException ioe ) { throw new BuildException ( "Can't load default datatype list" ) ; } setSystemProperties ( ) ; } public void setCoreLoader ( ClassLoader coreLoader ) { this . coreLoader = coreLoader ; } public ClassLoader getCoreLoader ( ) { return coreLoader ; } public void addBuildListener ( BuildListener listener ) { listeners . addElement ( listener ) ; } public void removeBuildListener ( BuildListener listener ) { listeners . removeElement ( listener ) ; } public Vector getBuildListeners ( ) { return ( Vector ) listeners . clone ( ) ; } public void log ( String message ) { log ( message , MSG_INFO ) ; } public void log ( String message , int msgLevel ) { fireMessageLogged ( this , message , msgLevel ) ; } public void log ( Task task , String message , int msgLevel ) { fireMessageLogged ( task , message , msgLevel ) ; } public void log ( Target target , String message , int msgLevel ) { fireMessageLogged ( target , message , msgLevel ) ; } public FilterSet getGlobalFilterSet ( ) { return globalFilterSet ; } public synchronized void setProperty ( String name , String value ) { if ( null != userProperties . get ( name ) ) { log ( "Override ignored for user property " + name , MSG_VERBOSE ) ; return ; } if ( null != properties . get ( name ) ) { log ( "Overriding previous definition of property " + name , MSG_VERBOSE ) ; } log ( "Setting project property: " + name + " -> " + value , MSG_DEBUG ) ; properties . put ( name , value ) ; } public synchronized void setNewProperty ( String name , String value ) { if ( null != properties . get ( name ) ) { log ( "Override ignored for property " + name , MSG_VERBOSE ) ; return ; } log ( "Setting project property: " + name + " -> " + value , MSG_DEBUG ) ; properties . put ( name , value ) ; } public synchronized void setUserProperty ( String name , String value ) { log ( "Setting ro project property: " + name + " -> " + value , MSG_DEBUG ) ; userProperties . put ( name , value ) ; properties . put ( name , value ) ; } public synchronized void setInheritedProperty ( String name , String value ) { inheritedProperties . put ( name , value ) ; setUserProperty ( name , value ) ; } private void setPropertyInternal ( String name , String value ) { if ( null != userProperties . get ( name ) ) { return ; } properties . put ( name , value ) ; } public String getProperty ( String name ) { if ( name == null ) { return null ; } String property = ( String ) properties . get ( name ) ; return property ; } public String replaceProperties ( String value ) throws BuildException { return ProjectHelper . replaceProperties ( this , value , properties ) ; } public String getUserProperty ( String name ) { if ( name == null ) { return null ; } String property = ( String ) userProperties . get ( name ) ; return property ; } public Hashtable getProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = properties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public Hashtable getUserProperties ( ) { Hashtable propertiesCopy = new Hashtable ( ) ; Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; Object value = properties . get ( name ) ; propertiesCopy . put ( name , value ) ; } return propertiesCopy ; } public void copyUserProperties ( Project other ) { Enumeration e = userProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object arg = e . nextElement ( ) ; if ( inheritedProperties . containsKey ( arg ) ) { continue ; } Object value = userProperties . get ( arg ) ; other . setUserProperty ( arg . toString ( ) , value . toString ( ) ) ; } } public void copyInheritedProperties ( Project other ) { Enumeration e = inheritedProperties . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = e . nextElement ( ) . toString ( ) ; if ( other . getUserProperty ( arg ) != null ) { continue ; } Object value = inheritedProperties . get ( arg ) ; other . setInheritedProperty ( arg , value . toString ( ) ) ; } } public void setDefaultTarget ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public String getDefaultTarget ( ) { return defaultTarget ; } public void setDefault ( String defaultTarget ) { this . defaultTarget = defaultTarget ; } public void setName ( String name ) { setUserProperty ( "ant.project.name" , name ) ; this . name = name ; } public String getName ( ) { return name ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public void addFilter ( String token , String value ) { if ( token == null ) { return ; } globalFilterSet . addFilter ( new FilterSet . Filter ( token , value ) ) ; } public Hashtable getFilters ( ) { return globalFilterSet . getFilterHash ( ) ; } public void setBasedir ( String baseD ) throws BuildException { setBaseDir ( new File ( baseD ) ) ; } public void setBaseDir ( File baseDir ) throws BuildException { baseDir = fileUtils . normalize ( baseDir . getAbsolutePath ( ) ) ; if ( ! baseDir . exists ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " does not exist" ) ; } if ( ! baseDir . isDirectory ( ) ) { throw new BuildException ( "Basedir " + baseDir . getAbsolutePath ( ) + " is not a directory" ) ; } this . baseDir = baseDir ; setPropertyInternal ( "basedir" , this . baseDir . getPath ( ) ) ; String msg = "Project base dir set to: " + this . baseDir ; log ( msg , MSG_VERBOSE ) ; } public File getBaseDir ( ) { if ( baseDir == null ) { try { setBasedir ( "." ) ; } catch ( BuildException ex ) { ex . printStackTrace ( ) ; } } return baseDir ; } public static String getJavaVersion ( ) { return JavaEnvUtils . getJavaVersion ( ) ; } public void setJavaVersionProperty ( ) throws BuildException { String javaVersion = JavaEnvUtils . getJavaVersion ( ) ; setPropertyInternal ( "ant.java.version" , javaVersion ) ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) ) { throw new BuildException ( "Ant cannot work on Java 1.0" ) ; } log ( "Detected Java version: " + javaVersion + " in: " + System . getProperty ( "java.home" ) , MSG_VERBOSE ) ; log ( "Detected OS: " + System . getProperty ( "os.name" ) , MSG_VERBOSE ) ; } public void setSystemProperties ( ) { Properties systemP = System . getProperties ( ) ; Enumeration e = systemP . keys ( ) ; while ( e . hasMoreElements ( ) ) { Object name = e . nextElement ( ) ; String value = systemP . get ( name ) . toString ( ) ; this . setPropertyInternal ( name . toString ( ) , value ) ; } } public void addTaskDefinition ( String taskName , Class taskClass ) throws BuildException { Class old = ( Class ) taskClassDefinitions . get ( taskName ) ; if ( null != old ) { if ( old . equals ( taskClass ) ) { log ( "Ignoring override for task " + taskName + ", it is already defined by the same class." , MSG_VERBOSE ) ; return ; } else { int logLevel = MSG_WARN ; if ( old . getName ( ) . equals ( taskClass . getName ( ) ) ) { ClassLoader oldLoader = old . getClassLoader ( ) ; ClassLoader newLoader = taskClass . getClassLoader ( ) ; if ( oldLoader != null && newLoader != null && oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) { logLevel = MSG_VERBOSE ; } } log ( "Trying to override old definition of task " + taskName , logLevel ) ; invalidateCreatedTasks ( taskName ) ; } } String msg = " +User task: " + taskName + "     " + taskClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; checkTaskClass ( taskClass ) ; taskClassDefinitions . put ( taskName , taskClass ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , this ) ; } } public Hashtable getTaskDefinitions ( ) { return taskClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { synchronized ( dataClassDefinitions ) { Class old = ( Class ) dataClassDefinitions . get ( typeName ) ; if ( null != old ) { if ( old . equals ( typeClass ) ) { log ( "Ignoring override for datatype " + typeName + ", it is already defined by the same class." , MSG_VERBOSE ) ; return ; } else { log ( "Trying to override old definition of datatype " + typeName , MSG_WARN ) ; } } dataClassDefinitions . put ( typeName , typeClass ) ; } String msg = " +User datatype: " + typeName + "     " + typeClass . getName ( ) ; log ( msg , MSG_DEBUG ) ; } public Hashtable getDataTypeDefinitions ( ) { return dataClassDefinitions ; } public void addTarget ( Target target ) throws BuildException { String name = target . getName ( ) ; if ( targets . get ( name ) != null ) { throw new BuildException ( "Duplicate target: `" + name + "'" ) ; } addOrReplaceTarget ( name , target ) ; } public void addTarget ( String targetName , Target target ) throws BuildException { if ( targets . get ( targetName ) != null ) { throw new BuildException ( "Duplicate target: `" + targetName + "'" ) ; } addOrReplaceTarget ( targetName , target ) ; } public void addOrReplaceTarget ( Target target ) { addOrReplaceTarget ( target . getName ( ) , target ) ; } public void addOrReplaceTarget ( String targetName , Target target ) { String msg = " +Target: " + targetName ; log ( msg , MSG_DEBUG ) ; target . setProject ( this ) ; targets . put ( targetName , target ) ; } public Hashtable getTargets ( ) { return targets ; } public Task createTask ( String taskType ) throws BuildException { Class c = ( Class ) taskClassDefinitions . get ( taskType ) ; if ( c == null ) { return null ; } try { Object o = c . newInstance ( ) ; Task task = null ; if ( o instanceof Task ) { task = ( Task ) o ; } else { TaskAdapter taskA = new TaskAdapter ( ) ; taskA . setProxy ( o ) ; task = taskA ; } task . setProject ( this ) ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; String msg = "   +Task: " + taskType ; log ( msg , MSG_DEBUG ) ; addCreatedTask ( taskType , task ) ; return task ; } catch ( Throwable t ) { String msg = "Could not create task of type: " + taskType + " due to " + t ; throw new BuildException ( msg , t ) ; } } private void addCreatedTask ( String type , Task task ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v == null ) { v = new Vector ( ) ; createdTasks . put ( type , v ) ; } v . addElement ( task ) ; } } private void invalidateCreatedTasks ( String type ) { synchronized ( createdTasks ) { Vector v = ( Vector ) createdTasks . get ( type ) ; if ( v != null ) { Enumeration enum = v . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Task t = ( Task ) enum . nextElement ( ) ; t . markInvalid ( ) ; } v . removeAllElements ( ) ; createdTasks . remove ( type ) ; } } } public Object createDataType ( String typeName ) throws BuildException { Class c = ( Class ) dataClassDefinitions . get ( typeName ) ; if ( c == null ) { return null ; } try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { this } ) ; } if ( o instanceof ProjectComponent ) { ( ( ProjectComponent ) o ) . setProject ( this ) ; } String msg = "   +DataType: " + typeName ; log ( msg , MSG_DEBUG ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } catch ( Throwable t ) { String msg = "Could not create datatype of type: " + typeName + " due to " + t ; throw new BuildException ( msg , t ) ; } } public void executeTargets ( Vector targetNames ) throws BuildException { Throwable error = null ; for ( int i = 0 ; i < targetNames . size ( ) ; i ++ ) { executeTarget ( ( String ) targetNames . elementAt ( i ) ) ; } } public void demuxOutput ( String line , boolean isError ) { Task task = ( Task ) threadTasks . get ( Thread . currentThread ( ) ) ; if ( task == null ) { fireMessageLogged ( this , line , isError ? MSG_ERR : MSG_INFO ) ; } else { if ( isError ) { task . handleErrorOutput ( line ) ; } else { task . handleOutput ( line ) ; } } } public void executeTarget ( String targetName ) throws BuildException { if ( targetName == null ) { String msg = "No target specified" ; throw new BuildException ( msg ) ; } Vector sortedTargets = topoSort ( targetName , targets ) ; int curidx = 0 ; Target curtarget ; do { curtarget = ( Target ) sortedTargets . elementAt ( curidx ++ ) ; curtarget . performTasks ( ) ; } while ( ! curtarget . getName ( ) . equals ( targetName ) ) ; } public File resolveFile ( String fileName , File rootDir ) { return fileUtils . resolveFile ( rootDir , fileName ) ; } public File resolveFile ( String fileName ) { return fileUtils . resolveFile ( baseDir , fileName ) ; } public static String translatePath ( String toProcess ) { if ( toProcess == null || toProcess . length ( ) == 0 ) { return "" ; } StringBuffer path = new StringBuffer ( toProcess . length ( ) + 50 ) ; PathTokenizer tokenizer = new PathTokenizer ( toProcess ) ; while ( tokenizer . hasMoreTokens ( ) ) { String pathComponent = tokenizer . nextToken ( ) ; pathComponent = pathComponent . replace ( '/' , File . separatorChar ) ; pathComponent = pathComponent . replace ( '\\' , File . separatorChar ) ; if ( path . length ( ) != 0 ) { path . append ( File . pathSeparatorChar ) ; } path . append ( pathComponent ) ; } return path . toString ( ) ; } public void copyFile ( String sourceFile , String destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( String sourceFile , String destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void copyFile ( File sourceFile , File destFile ) throws IOException { fileUtils . copyFile ( sourceFile , destFile ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite ) ; } public void copyFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite , boolean preserveLastModified ) throws IOException { fileUtils . copyFile ( sourceFile , destFile , filtering ? globalFilters : null , overwrite , preserveLastModified ) ; } public void setFileLastModified ( File file , long time ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } fileUtils . setFileLastModified ( file , time ) ; log ( "Setting modification time for " + file , MSG_VERBOSE ) ; } public static boolean toBoolean ( String s ) { return ( s . equalsIgnoreCase ( "on" ) || s . equalsIgnoreCase ( "true" ) || s . equalsIgnoreCase ( "yes" ) ) ; } public final Vector topoSort ( String root , Hashtable targets ) throws BuildException { Vector ret = new Vector ( ) ; Hashtable state = new Hashtable ( ) ; Stack visiting = new Stack ( ) ; tsort ( root , targets , state , visiting , ret ) ; log ( "Build sequence for target `" + root + "' is " + ret , MSG_VERBOSE ) ; for ( Enumeration en = targets . keys ( ) ; en . hasMoreElements ( ) ; ) { String curTarget = ( String ) en . nextElement ( ) ; String st = ( String ) state . get ( curTarget ) ; if ( st == null ) { tsort ( curTarget , targets , state , visiting , ret ) ; } else if ( st == VISITING ) { throw new RuntimeException ( "Unexpected node in visiting state: " + curTarget ) ; } } log ( "Complete build sequence is " + ret , MSG_VERBOSE ) ; return ret ; } private final void tsort ( String root , Hashtable targets , Hashtable state , Stack visiting , Vector ret ) throws BuildException { state . put ( root , VISITING ) ; visiting . push ( root ) ; Target target = ( Target ) targets . get ( root ) ; if ( target == null ) { StringBuffer sb = new StringBuffer ( "Target `" ) ; sb . append ( root ) ; sb . append ( "' does not exist in this project. " ) ; visiting . pop ( ) ; if ( ! visiting . empty ( ) ) { String parent = ( String ) visiting . peek ( ) ; sb . append ( "It is used from target `" ) ; sb . append ( parent ) ; sb . append ( "'." ) ; } throw new BuildException ( new String ( sb ) ) ; } for ( Enumeration en = target . getDependencies ( ) ; en . hasMoreElements ( ) ; ) { String cur = ( String ) en . nextElement ( ) ; String m = ( String ) state . get ( cur ) ; if ( m == null ) { tsort ( cur , targets , state , visiting , ret ) ; } else if ( m == VISITING ) { throw makeCircularException ( cur , visiting ) ; } } String p = ( String ) visiting . pop ( ) ; if ( root != p ) { throw new RuntimeException ( "Unexpected internal error: expected to " + "pop " + root + " but got " + p ) ; } state . put ( root , VISITED ) ; ret . addElement ( target ) ; } private static BuildException makeCircularException ( String end , Stack stk ) { StringBuffer sb = new StringBuffer ( "Circular dependency: " ) ; sb . append ( end ) ; String c ; do { c = ( String ) stk . pop ( ) ; sb . append ( " <- " ) ; sb . append ( c ) ; } while ( ! c . equals ( end ) ) ; return new BuildException ( new String ( sb ) ) ; } public void addReference ( String name , Object value ) { synchronized ( references ) { Object old = references . get ( name ) ; if ( old == value ) { return ; } if ( old != null ) { log ( "Overriding previous definition of reference to " + name , MSG_WARN ) ; } log ( "Adding reference: " + name + " -> " + value , MSG_DEBUG ) ; references . put ( name , value ) ; } } public Hashtable getReferences ( ) { return references ; } public Object getReference ( String key ) { return references . get ( key ) ; } public String getElementName ( Object element ) { Hashtable elements = taskClassDefinitions ; Class elementClass = element . getClass ( ) ; String typeName = "task" ; if ( ! elements . contains ( elementClass ) ) { elements = dataClassDefinitions ; typeName = "data type" ; if ( ! elements . contains ( elementClass ) ) { elements = null ; } } if ( elements != null ) { Enumeration e = elements . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; Class clazz = ( Class ) elements . get ( name ) ; if ( elementClass . equals ( clazz ) ) { return "The <" + name + "> " + typeName ; } } } return "Class " + elementClass . getName ( ) ; } public void fireBuildStarted ( ) { BuildEvent event = new BuildEvent ( this ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildStarted ( event ) ; } } public void fireBuildFinished ( Throwable exception ) { BuildEvent event = new BuildEvent ( this ) ; event . setException ( exception ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . buildFinished ( event ) ; } } protected void fireTargetStarted ( Target target ) { BuildEvent event = new BuildEvent ( target ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetStarted ( event ) ; } } protected void fireTargetFinished ( Target target , Throwable exception ) { BuildEvent event = new BuildEvent ( target ) ; event . setException ( exception ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . targetFinished ( event ) ; } } protected void fireTaskStarted ( Task task ) { registerThreadTask ( Thread . currentThread ( ) , task ) ; BuildEvent event = new BuildEvent ( task ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskStarted ( event ) ; } } protected void fireTaskFinished ( Task task , Throwable exception ) { registerThreadTask ( Thread . currentThread ( ) , null ) ; System . out . flush ( ) ; System . err . flush ( ) ; BuildEvent event = new BuildEvent ( task ) ; event . setException ( exception ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . taskFinished ( event ) ; } } private void fireMessageLoggedEvent ( BuildEvent event , String message , int priority ) { event . setMessage ( message , priority ) ; Vector listeners = getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { BuildListener listener = ( BuildListener ) listeners . elementAt ( i ) ; listener . messageLogged ( event ) ; } } protected void fireMessageLogged ( Project project , String message , int priority ) { BuildEvent event = new BuildEvent ( project ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Target target , String message , int priority ) { BuildEvent event = new BuildEvent ( target ) ; fireMessageLoggedEvent ( event , message , priority ) ; } protected void fireMessageLogged ( Task task , String message , int priority ) { BuildEvent event = new BuildEvent ( task ) ; fireMessageLoggedEvent ( event , message , priority ) ; } public synchronized void registerThreadTask ( Thread thread , Task task ) { if ( task != null ) { threadTasks . put ( thread , task ) ; } else { threadTasks . remove ( thread ) ; } } public Task getThreadTask ( Thread thread ) { return ( Task ) threadTasks . get ( thread ) ; } } 	0	['91', '1', '0', '157', '212', '3687', '148', '17', '77', '0.97047619', '2452', '0.6', '4', '0', '0.105494505', '0', '0', '25.56043956', '6', '1.4945', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . util . StringUtils ; import java . io . PrintStream ; public class RecorderEntry implements BuildLogger { private String filename = null ; private boolean record = true ; private int loglevel = Project . MSG_INFO ; private PrintStream out = null ; private long targetStartTime = 0l ; private boolean emacsMode = false ; protected RecorderEntry ( String name ) { filename = name ; } public String getFilename ( ) { return filename ; } public void setRecordState ( Boolean state ) { if ( state != null ) { record = state . booleanValue ( ) ; } } public void buildStarted ( BuildEvent event ) { log ( "> BUILD STARTED" , Project . MSG_DEBUG ) ; } public void buildFinished ( BuildEvent event ) { log ( "< BUILD FINISHED" , Project . MSG_DEBUG ) ; Throwable error = event . getException ( ) ; if ( error == null ) { out . println ( StringUtils . LINE_SEP + "BUILD SUCCESSFUL" ) ; } else { out . println ( StringUtils . LINE_SEP + "BUILD FAILED" + StringUtils . LINE_SEP ) ; error . printStackTrace ( out ) ; } out . flush ( ) ; out . close ( ) ; } public void targetStarted ( BuildEvent event ) { log ( ">> TARGET STARTED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; log ( StringUtils . LINE_SEP + event . getTarget ( ) . getName ( ) + ":" , Project . MSG_INFO ) ; targetStartTime = System . currentTimeMillis ( ) ; } public void targetFinished ( BuildEvent event ) { log ( "<< TARGET FINISHED -- " + event . getTarget ( ) , Project . MSG_DEBUG ) ; String time = formatTime ( System . currentTimeMillis ( ) - targetStartTime ) ; log ( event . getTarget ( ) + ":  duration " + time , Project . MSG_VERBOSE ) ; out . flush ( ) ; } public void taskStarted ( BuildEvent event ) { log ( ">>> TASK STARTED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; } public void taskFinished ( BuildEvent event ) { log ( "<<< TASK FINISHED -- " + event . getTask ( ) , Project . MSG_DEBUG ) ; out . flush ( ) ; } public void messageLogged ( BuildEvent event ) { log ( "--- MESSAGE LOGGED" , Project . MSG_DEBUG ) ; StringBuffer buf = new StringBuffer ( ) ; if ( event . getTask ( ) != null ) { String name = event . getTask ( ) . getTaskName ( ) ; if ( ! emacsMode ) { String label = "[" + name + "] " ; int size = DefaultLogger . LEFT_COLUMN_SIZE - label . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { buf . append ( " " ) ; } buf . append ( label ) ; } } buf . append ( event . getMessage ( ) ) ; log ( buf . toString ( ) , event . getPriority ( ) ) ; } private void log ( String mesg , int level ) { if ( record && ( level <= loglevel ) ) { out . println ( mesg ) ; } } public void setMessageOutputLevel ( int level ) { if ( level >= Project . MSG_ERR && level <= Project . MSG_DEBUG ) { loglevel = level ; } } public void setOutputPrintStream ( PrintStream output ) { out = output ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setErrorPrintStream ( PrintStream err ) { out = err ; } private static String formatTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; if ( minutes > 0 ) { return Long . toString ( minutes ) + " minute" + ( minutes == 1 ? " " : "s " ) + Long . toString ( seconds % 60 ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } else { return Long . toString ( seconds ) + " second" + ( seconds % 60 == 1 ? "" : "s" ) ; } } } 	0	['16', '1', '0', '6', '36', '58', '1', '5', '13', '0.633333333', '363', '1', '0', '0', '0.2421875', '0', '0', '21.3125', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . GlobPatternMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapter ; import org . apache . tools . ant . taskdefs . compilers . CompilerAdapterFactory ; import java . io . File ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed; see the compiler error output for details." ; private Path src ; private File destDir ; private Path compileClasspath ; private Path compileSourcepath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private boolean fork = false ; private String forkedExecutable = null ; private boolean nowarn = false ; private String memoryInitialSize ; private String memoryMaximumSize ; private FacadeTaskHelper facade = null ; protected boolean failOnError = true ; protected boolean listFiles = false ; protected File [ ] compileList = new File [ 0 ] ; private String source ; private String debugLevel ; public Javac ( ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { facade = new FacadeTaskHelper ( "javac1.1" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) ) { facade = new FacadeTaskHelper ( "javac1.2" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { facade = new FacadeTaskHelper ( "javac1.3" ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { facade = new FacadeTaskHelper ( "javac1.4" ) ; } else { facade = new FacadeTaskHelper ( "classic" ) ; } } public String getDebugLevel ( ) { return debugLevel ; } public void setDebugLevel ( String v ) { this . debugLevel = v ; } public String getSource ( ) { return source ; } public void setSource ( String v ) { this . source = v ; } public Path createSrc ( ) { if ( src == null ) { src = new Path ( project ) ; } return src . createPath ( ) ; } protected Path recreateSrc ( ) { src = null ; return createSrc ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setSourcepath ( Path sourcepath ) { if ( compileSourcepath == null ) { compileSourcepath = sourcepath ; } else { compileSourcepath . append ( sourcepath ) ; } } public Path getSourcepath ( ) { return compileSourcepath ; } public Path createSourcepath ( ) { if ( compileSourcepath == null ) { compileSourcepath = new Path ( project ) ; } return compileSourcepath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public void setListfiles ( boolean list ) { listFiles = list ; } public boolean getListfiles ( ) { return listFiles ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setMemoryInitialSize ( String memoryInitialSize ) { this . memoryInitialSize = memoryInitialSize ; } public String getMemoryInitialSize ( ) { return memoryInitialSize ; } public void setMemoryMaximumSize ( String memoryMaximumSize ) { this . memoryMaximumSize = memoryMaximumSize ; } public String getMemoryMaximumSize ( ) { return memoryMaximumSize ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setFork ( boolean f ) { fork = f ; } public void setExecutable ( String forkExec ) { forkedExecutable = forkExec ; } public boolean isForkedJavac ( ) { return fork || "extJavac" . equals ( getCompiler ( ) ) ; } public String getJavacExecutable ( ) { if ( forkedExecutable == null && isForkedJavac ( ) ) { forkedExecutable = getSystemJavac ( ) ; } else if ( forkedExecutable != null && ! isForkedJavac ( ) ) { forkedExecutable = null ; } return forkedExecutable ; } public void setNowarn ( boolean flag ) { this . nowarn = flag ; } public boolean getNowarn ( ) { return nowarn ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { String chosen = facade . getExplicitChoice ( ) ; facade . setImplementation ( getCompiler ( ) ) ; try { return facade . getArgs ( ) ; } finally { facade . setImplementation ( chosen ) ; } } public void execute ( ) throws BuildException { checkParameters ( ) ; resetFileLists ( ) ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = project . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , location ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } compile ( ) ; } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String [ ] files ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } protected boolean isJdkCompiler ( String compilerImpl ) { return "modern" . equals ( compilerImpl ) || "classic" . equals ( compilerImpl ) || "javac1.1" . equals ( compilerImpl ) || "javac1.2" . equals ( compilerImpl ) || "javac1.3" . equals ( compilerImpl ) || "javac1.4" . equals ( compilerImpl ) ; } protected String getSystemJavac ( ) { return JavaEnvUtils . getJdkExecutable ( "javac" ) ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { String compilerImpl = getCompilerVersion ( ) ; if ( fork ) { if ( isJdkCompiler ( compilerImpl ) ) { log ( "Since fork is true, ignoring compiler setting." , Project . MSG_WARN ) ; compilerImpl = "extJavac" ; } else { log ( "Since compiler setting isn't classic or modern," + "ignoring fork setting." , Project . MSG_WARN ) ; } } return compilerImpl ; } public String getCompilerVersion ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.compiler" ) ) ; return facade . getImplementation ( ) ; } protected void checkParameters ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( src . size ( ) == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist " + "or is not a directory" , location ) ; } } protected void compile ( ) { String compilerImpl = getCompiler ( ) ; if ( compileList . length > 0 ) { log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; if ( listFiles ) { for ( int i = 0 ; i < compileList . length ; i ++ ) { String filename = compileList [ i ] . getAbsolutePath ( ) ; log ( filename ) ; } } CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compilerImpl , this ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , location ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	0	['72', '4', '0', '27', '116', '2338', '11', '18', '65', '0.96400626', '900', '1', '6', '0.523489933', '0.206349206', '1', '1', '11.125', '8', '1.4722', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { String FILE_PROTOCOL_PREFIX = "file://" ; void setStylesheet ( File stylesheet ) throws Exception ; void addParam ( String name , String expression ) throws Exception ; void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '1', '3', '3', '1', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; public class EmailAddress { private String name ; private String address ; public EmailAddress ( ) { } public EmailAddress ( String address ) { this . address = address ; } public void setName ( String name ) { this . name = name ; } public void setAddress ( String address ) { this . address = address ; } public String toString ( ) { if ( name == null ) { return address ; } else { return name + " <" + address + ">" ; } } public String getAddress ( ) { return address ; } public String getName ( ) { return name ; } } 	0	['7', '1', '0', '3', '11', '3', '3', '0', '7', '0.583333333', '53', '1', '0', '0', '0.714285714', '0', '0', '6.285714286', '2', '0.8571', '0']
package org . apache . tools . ant . util ; public interface TimeoutObserver { void timeoutOccured ( Watchdog w ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . OutputStream ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class SunRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.rmi.rmic.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use SUN rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting SUN rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '22', '3', '1', '7', '2', '1', '152', '0', '0', '0.866666667', '0.5', '0', '0', '48.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public String [ ] getIncludedFiles ( ) { String [ ] result = new String [ 1 ] ; result [ 0 ] = srcFile . getAbsolutePath ( ) ; return result ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } } 	0	['6', '2', '0', '3', '11', '13', '2', '1', '6', '0.8', '68', '1', '0', '0.924242424', '0.444444444', '1', '5', '10.16666667', '3', '1.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . BuildException ; public class DepthSelector extends BaseExtendSelector { public int min = - 1 ; public int max = - 1 ; public final static String MIN_KEY = "min" ; public final static String MAX_KEY = "max" ; public DepthSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{depthselector min: " ) ; buf . append ( min ) ; buf . append ( " max: " ) ; buf . append ( max ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMin ( int min ) { this . min = min ; } public void setMax ( int max ) { this . max = max ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MIN_KEY . equalsIgnoreCase ( paramname ) ) { try { setMin ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid minimum value " + parameters [ i ] . getValue ( ) ) ; } } else if ( MAX_KEY . equalsIgnoreCase ( paramname ) ) { try { setMax ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid maximum value " + parameters [ i ] . getValue ( ) ) ; } } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( min < 0 && max < 0 ) { setError ( "You must set at least one of the min or the " + "max levels." ) ; } if ( max < min && max > - 1 ) { setError ( "The maximum depth is lower than the minimum." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int depth = - 1 ; String abs_base = basedir . getAbsolutePath ( ) ; String abs_file = file . getAbsolutePath ( ) ; StringTokenizer tok_base = new StringTokenizer ( abs_base , File . separator ) ; StringTokenizer tok_file = new StringTokenizer ( abs_file , File . separator ) ; while ( tok_file . hasMoreTokens ( ) ) { String filetoken = tok_file . nextToken ( ) ; if ( tok_base . hasMoreTokens ( ) ) { String basetoken = tok_base . nextToken ( ) ; if ( ! basetoken . equals ( filetoken ) ) { throw new BuildException ( "File " + filename + " does not appear within " + abs_base + "directory" ) ; } } else { depth += 1 ; if ( max > - 1 && depth > max ) { return false ; } } } if ( tok_base . hasMoreTokens ( ) ) { throw new BuildException ( "File " + filename + " is outside of " + abs_base + "directory tree" ) ; } if ( min > - 1 && depth < min ) { return false ; } return true ; } } 	0	['7', '5', '0', '8', '26', '0', '4', '4', '7', '0.666666667', '261', '0', '0', '0.863636364', '0.342857143', '2', '5', '35.71428571', '8', '3', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; public class PatternSet extends DataType { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( name ) ; if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occured while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof PatternSet ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a patternset" ; throw new BuildException ( msg ) ; } else { return ( PatternSet ) o ; } } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } } 	0	['21', '3', '0', '12', '62', '134', '7', '6', '15', '0.6', '630', '1', '0', '0.6', '0.272108844', '1', '1', '28.80952381', '9', '3', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class CompilerAdapterFactory { private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { boolean isClassicCompilerSupported = true ; if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_4 ) ) { isClassicCompilerSupported = false ; } if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { if ( isClassicCompilerSupported ) { return new Javac12 ( ) ; } else { task . log ( "This version of java does " + "not support the classic " + "compiler; upgrading to modern" , Project . MSG_WARN ) ; compilerType = "modern" ; } } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) ) { if ( doesModernCompilerExist ( ) ) { return new Javac13 ( ) ; } else { if ( isClassicCompilerSupported ) { task . log ( "Modern compiler not found - looking for " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } else { throw new BuildException ( "Unable to find a javac " + "compiler;\n" + "com.sun.tools.javac.Main " + "is not on the " + "classpath.\n" + "Perhaps JAVA_HOME does not" + " point to the JDK" ) ; } } } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static boolean doesModernCompilerExist ( ) { try { Class . forName ( "com.sun.tools.javac.Main" ) ; return true ; } catch ( ClassNotFoundException cnfe ) { return false ; } } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( "Compiler Adapter '" + className + "' can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( "Compiler Adapter " + className + " caused an interesting exception." , t ) ; } } } 	0	['4', '1', '0', '13', '23', '6', '1', '12', '1', '2', '195', '0', '0', '0', '0.333333333', '0', '0', '47.75', '1', '0.75', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . io . File ; import java . util . Vector ; public class SourceFileScanner { protected Task task ; private FileUtils fileUtils ; public SourceFileScanner ( Task task ) { this . task = task ; fileUtils = FileUtils . newFileUtils ( ) ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; StringBuffer targetList = new StringBuffer ( ) ; if ( Os . isFamily ( "windows" ) ) { now += 2000 ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String [ ] targets = mapper . mapFileName ( files [ i ] ) ; if ( targets == null || targets . length == 0 ) { task . log ( files [ i ] + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } File src = fileUtils . resolveFile ( srcDir , files [ i ] ) ; if ( src . lastModified ( ) > now ) { task . log ( "Warning: " + files [ i ] + " modified in the future." , Project . MSG_WARN ) ; } boolean added = false ; targetList . setLength ( 0 ) ; for ( int j = 0 ; ! added && j < targets . length ; j ++ ) { File dest = fileUtils . resolveFile ( destDir , targets [ j ] ) ; if ( ! dest . exists ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else if ( src . lastModified ( ) > dest . lastModified ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " is outdated." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( dest . getAbsolutePath ( ) ) ; } } if ( ! added ) { task . log ( files [ i ] + " omitted as " + targetList . toString ( ) + ( targets . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } String [ ] result = new String [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } } 	0	['3', '1', '0', '11', '24', '1', '7', '4', '3', '0', '264', '1', '2', '0', '0.666666667', '0', '0', '86.33333333', '13', '5', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; private int index = - 1 ; public abstract String [ ] getValues ( ) ; protected EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { int index = indexOfValue ( value ) ; if ( index == - 1 ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . index = index ; this . value = value ; } public final boolean containsValue ( String value ) { return ( indexOfValue ( value ) != - 1 ) ; } public final int indexOfValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return - 1 ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return i ; } } return - 1 ; } public final String getValue ( ) { return value ; } public final int getIndex ( ) { return index ; } public String toString ( ) { return getValue ( ) ; } } 	0	['8', '1', '26', '46', '14', '20', '45', '1', '7', '0.714285714', '87', '1', '0', '0', '0.6875', '0', '0', '9.625', '5', '1.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Dirname extends Task { private File file ; private String property ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , location ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , location ) ; } else { String value = file . getParent ( ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['4', '3', '0', '5', '9', '2', '0', '5', '4', '0.666666667', '48', '1', '0', '0.925', '0.5', '0', '0', '10.5', '1', '0.75', '0']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	0	['8', '1', '0', '4', '39', '22', '1', '3', '6', '0.785714286', '377', '0.5', '0', '0', '0.166666667', '0', '0', '45.875', '3', '1.25', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } } 	0	['23', '4', '4', '19', '40', '223', '6', '19', '23', '0.045454545', '179', '1', '0', '0.614035088', '0.09382151', '0', '0', '6.739130435', '4', '1.2609', '0']
package org . apache . tools . ant ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . Hashtable ; import java . util . zip . ZipFile ; import java . util . zip . ZipEntry ; import java . io . File ; import java . io . InputStream ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . ByteArrayOutputStream ; import java . net . URL ; import java . net . MalformedURLException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class AntClassLoader extends ClassLoader implements BuildListener { private class ResourceEnumeration implements Enumeration { private String resourceName ; private int pathElementsIndex ; private URL nextResource ; ResourceEnumeration ( String name ) { this . resourceName = name ; this . pathElementsIndex = 0 ; findNextResource ( ) ; } public boolean hasMoreElements ( ) { return ( this . nextResource != null ) ; } public Object nextElement ( ) { URL ret = this . nextResource ; findNextResource ( ) ; return ret ; } private void findNextResource ( ) { URL url = null ; while ( ( pathElementsIndex < pathComponents . size ( ) ) && ( url == null ) ) { try { File pathComponent = ( File ) pathComponents . elementAt ( pathElementsIndex ) ; url = getResourceURL ( pathComponent , this . resourceName ) ; pathElementsIndex ++ ; } catch ( BuildException e ) { } } this . nextResource = url ; } } private static final int BUFFER_SIZE = 8192 ; private Vector pathComponents = new Vector ( ) ; private Project project ; private boolean parentFirst = true ; private Vector systemPackages = new Vector ( ) ; private Vector loaderPackages = new Vector ( ) ; private boolean ignoreBase = false ; private ClassLoader parent = null ; private Hashtable zipFiles = new Hashtable ( ) ; private ClassLoader savedContextLoader = null ; private boolean isContextLoaderSaved = false ; private static Method getProtectionDomain = null ; private static Method defineClassProtectionDomain = null ; static { try { getProtectionDomain = Class . class . getMethod ( "getProtectionDomain" , new Class [ 0 ] ) ; Class protectionDomain = Class . forName ( "java.security.ProtectionDomain" ) ; Class [ ] args = new Class [ ] { String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE , protectionDomain } ; defineClassProtectionDomain = ClassLoader . class . getDeclaredMethod ( "defineClass" , args ) ; } catch ( Exception e ) { } } public AntClassLoader ( Project project , Path classpath ) { parent = AntClassLoader . class . getClassLoader ( ) ; this . project = project ; project . addBuildListener ( this ) ; if ( classpath != null ) { Path actualClasspath = classpath . concatSystemClasspath ( "ignore" ) ; String [ ] pathElements = actualClasspath . list ( ) ; for ( int i = 0 ; i < pathElements . length ; ++ i ) { try { addPathElement ( pathElements [ i ] ) ; } catch ( BuildException e ) { } } } } public AntClassLoader ( ClassLoader parent , Project project , Path classpath , boolean parentFirst ) { this ( project , classpath ) ; if ( parent != null ) { this . parent = parent ; } this . parentFirst = parentFirst ; addSystemPackageRoot ( "java" ) ; addSystemPackageRoot ( "javax" ) ; } public AntClassLoader ( Project project , Path classpath , boolean parentFirst ) { this ( null , project , classpath , parentFirst ) ; } public AntClassLoader ( ClassLoader parent , boolean parentFirst ) { if ( parent != null ) { this . parent = parent ; } else { parent = AntClassLoader . class . getClassLoader ( ) ; } project = null ; this . parentFirst = parentFirst ; } protected void log ( String message , int priority ) { if ( project != null ) { project . log ( message , priority ) ; } } public void setThreadContextLoader ( ) { if ( isContextLoaderSaved ) { throw new BuildException ( "Context loader has not been reset" ) ; } if ( LoaderUtils . isContextLoaderAvailable ( ) ) { savedContextLoader = LoaderUtils . getContextClassLoader ( ) ; ClassLoader loader = this ; if ( project != null && "only" . equals ( project . getProperty ( "build.sysclasspath" ) ) ) { loader = this . getClass ( ) . getClassLoader ( ) ; } LoaderUtils . setContextClassLoader ( loader ) ; isContextLoaderSaved = true ; } } public void resetThreadContextLoader ( ) { if ( LoaderUtils . isContextLoaderAvailable ( ) && isContextLoaderSaved ) { LoaderUtils . setContextClassLoader ( savedContextLoader ) ; savedContextLoader = null ; isContextLoaderSaved = false ; } } public void addPathElement ( String pathElement ) throws BuildException { File pathComponent = project != null ? project . resolveFile ( pathElement ) : new File ( pathElement ) ; pathComponents . addElement ( pathComponent ) ; } public String getClasspath ( ) { StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; Enumeration enum = pathComponents . elements ( ) ; while ( enum . hasMoreElements ( ) ) { if ( ! firstPass ) { sb . append ( System . getProperty ( "path.separator" ) ) ; } else { firstPass = false ; } sb . append ( ( ( File ) enum . nextElement ( ) ) . getAbsolutePath ( ) ) ; } return sb . toString ( ) ; } public void setIsolated ( boolean isolated ) { ignoreBase = isolated ; } public static void initializeClass ( Class theClass ) { final Constructor [ ] cons = theClass . getDeclaredConstructors ( ) ; if ( cons != null ) { if ( cons . length > 0 && cons [ 0 ] != null ) { final String [ ] strs = new String [ 256 ] ; try { cons [ 0 ] . newInstance ( strs ) ; } catch ( Throwable t ) { } } } } public void addSystemPackageRoot ( String packageRoot ) { systemPackages . addElement ( packageRoot + "." ) ; } public void addLoaderPackageRoot ( String packageRoot ) { loaderPackages . addElement ( packageRoot + "." ) ; } public Class forceLoadClass ( String classname ) throws ClassNotFoundException { log ( "force loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findClass ( classname ) ; } return theClass ; } public Class forceLoadSystemClass ( String classname ) throws ClassNotFoundException { log ( "force system loading " + classname , Project . MSG_DEBUG ) ; Class theClass = findLoadedClass ( classname ) ; if ( theClass == null ) { theClass = findBaseClass ( classname ) ; } return theClass ; } public InputStream getResourceAsStream ( String name ) { InputStream resourceStream = null ; if ( isParentFirst ( name ) ) { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } else { resourceStream = loadResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } else { resourceStream = loadBaseResource ( name ) ; if ( resourceStream != null ) { log ( "ResourceStream for " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } } if ( resourceStream == null ) { log ( "Couldn't load ResourceStream for " + name , Project . MSG_DEBUG ) ; } return resourceStream ; } private InputStream loadResource ( String name ) { InputStream stream = null ; Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && stream == null ) { File pathComponent = ( File ) e . nextElement ( ) ; stream = getResourceStream ( pathComponent , name ) ; } return stream ; } private InputStream loadBaseResource ( String name ) { if ( parent == null ) { return getSystemResourceAsStream ( name ) ; } else { return parent . getResourceAsStream ( name ) ; } } private InputStream getResourceStream ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { return new FileInputStream ( resource ) ; } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { return zipFile . getInputStream ( entry ) ; } } } catch ( Exception e ) { log ( "Ignoring Exception " + e . getClass ( ) . getName ( ) + ": " + e . getMessage ( ) + " reading resource " + resourceName + " from " + file , Project . MSG_VERBOSE ) ; } return null ; } private boolean isParentFirst ( String resourceName ) { boolean useParentFirst = parentFirst ; for ( Enumeration e = systemPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = true ; break ; } } for ( Enumeration e = loaderPackages . elements ( ) ; e . hasMoreElements ( ) ; ) { String packageName = ( String ) e . nextElement ( ) ; if ( resourceName . startsWith ( packageName ) ) { useParentFirst = false ; break ; } } return useParentFirst ; } public URL getResource ( String name ) { URL url = null ; if ( isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; } if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } else { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) && url == null ) { File pathComponent = ( File ) e . nextElement ( ) ; url = getResourceURL ( pathComponent , name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } } if ( url == null && ! isParentFirst ( name ) ) { url = ( parent == null ) ? super . getResource ( name ) : parent . getResource ( name ) ; if ( url != null ) { log ( "Resource " + name + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( url == null ) { log ( "Couldn't load Resource " + name , Project . MSG_DEBUG ) ; } return url ; } protected Enumeration findResources ( String name ) throws IOException { return new ResourceEnumeration ( name ) ; } private URL getResourceURL ( File file , String resourceName ) { try { if ( ! file . exists ( ) ) { return null ; } if ( file . isDirectory ( ) ) { File resource = new File ( file , resourceName ) ; if ( resource . exists ( ) ) { try { return new URL ( "file:" + resource . toString ( ) ) ; } catch ( MalformedURLException ex ) { return null ; } } } else { ZipFile zipFile = ( ZipFile ) zipFiles . get ( file ) ; if ( zipFile == null ) { zipFile = new ZipFile ( file ) ; zipFiles . put ( file , zipFile ) ; } ZipEntry entry = zipFile . getEntry ( resourceName ) ; if ( entry != null ) { try { return new URL ( "jar:file:" + file . toString ( ) + "!/" + entry ) ; } catch ( MalformedURLException ex ) { return null ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } protected Class loadClass ( String classname , boolean resolve ) throws ClassNotFoundException { Class theClass = findLoadedClass ( classname ) ; if ( theClass != null ) { return theClass ; } if ( isParentFirst ( classname ) ) { try { theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } } else { try { theClass = findClass ( classname ) ; log ( "Class " + classname + " loaded from ant loader" , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { if ( ignoreBase ) { throw cnfe ; } theClass = findBaseClass ( classname ) ; log ( "Class " + classname + " loaded from parent loader" , Project . MSG_DEBUG ) ; } } if ( resolve ) { resolveClass ( theClass ) ; } return theClass ; } private String getClassFilename ( String classname ) { return classname . replace ( '.' , '/' ) + ".class" ; } private Class getClassFromStream ( InputStream stream , String classname ) throws IOException , SecurityException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; int bytesRead = - 1 ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; while ( ( bytesRead = stream . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { baos . write ( buffer , 0 , bytesRead ) ; } byte [ ] classData = baos . toByteArray ( ) ; if ( defineClassProtectionDomain != null ) { try { Object domain = getProtectionDomain . invoke ( Project . class , new Object [ 0 ] ) ; Object [ ] args = new Object [ ] { classname , classData , new Integer ( 0 ) , new Integer ( classData . length ) , domain } ; return ( Class ) defineClassProtectionDomain . invoke ( this , args ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof ClassFormatError ) { throw ( ClassFormatError ) t ; } else if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } else if ( t instanceof SecurityException ) { throw ( SecurityException ) t ; } else { throw new IOException ( t . toString ( ) ) ; } } catch ( Exception e ) { throw new IOException ( e . toString ( ) ) ; } } else { return defineClass ( classname , classData , 0 , classData . length ) ; } } public Class findClass ( String name ) throws ClassNotFoundException { log ( "Finding class " + name , Project . MSG_DEBUG ) ; return findClassInComponents ( name ) ; } private Class findClassInComponents ( String name ) throws ClassNotFoundException { InputStream stream = null ; String classFilename = getClassFilename ( name ) ; try { Enumeration e = pathComponents . elements ( ) ; while ( e . hasMoreElements ( ) ) { File pathComponent = ( File ) e . nextElement ( ) ; try { stream = getResourceStream ( pathComponent , classFilename ) ; if ( stream != null ) { return getClassFromStream ( stream , name ) ; } } catch ( SecurityException se ) { throw se ; } catch ( IOException ioe ) { log ( "Exception reading component " + pathComponent , Project . MSG_VERBOSE ) ; } } throw new ClassNotFoundException ( name ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { } } } private Class findBaseClass ( String name ) throws ClassNotFoundException { if ( parent == null ) { return findSystemClass ( name ) ; } else { return parent . loadClass ( name ) ; } } public synchronized void cleanup ( ) { for ( Enumeration e = zipFiles . elements ( ) ; e . hasMoreElements ( ) ; ) { ZipFile zipFile = ( ZipFile ) e . nextElement ( ) ; try { zipFile . close ( ) ; } catch ( IOException ioe ) { } } zipFiles = new Hashtable ( ) ; } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { project . removeBuildListener ( this ) ; project = null ; cleanup ( ) ; } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } private void addJavaLibraries ( ) { Vector packages = JavaEnvUtils . getJrePackages ( ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String packageName = ( String ) e . nextElement ( ) ; addSystemPackageRoot ( packageName ) ; } } } 	0	['42', '2', '0', '20', '115', '703', '14', '8', '25', '0.881899872', '1369', '0.684210526', '1', '0.478873239', '0.176829268', '1', '5', '31.14285714', '12', '1.9286', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import java . util . Vector ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private Vector filesets = new Vector ( ) ; private FileUtils fileUtils ; public Touch ( ) { fileUtils = FileUtils . newFileUtils ( ) ; } public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { long savedMillis = millis ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or " + "a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to touch directories." ) ; } try { if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative " + "milliseconds value " + "relative to epoch " + "(January 1, 1970, " + "00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe , location ) ; } } touch ( ) ; } finally { millis = savedMillis ; } } protected void touch ( ) throws BuildException { if ( file != null ) { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { fileUtils . createNewFile ( file ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , location ) ; } } } if ( millis >= 0 && JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { log ( "modification time of files cannot be set in JDK 1.1" , Project . MSG_WARN ) ; return ; } boolean resetMillis = false ; if ( millis < 0 ) { resetMillis = true ; millis = System . currentTimeMillis ( ) ; } if ( file != null ) { touch ( file ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { touch ( new File ( fromDir , srcFiles [ j ] ) ) ; } for ( int j = 0 ; j < srcDirs . length ; j ++ ) { touch ( new File ( fromDir , srcDirs [ j ] ) ) ; } } if ( resetMillis ) { millis = - 1 ; } } protected void touch ( File file ) throws BuildException { if ( ! file . canWrite ( ) ) { throw new BuildException ( "Can not change modification date of " + "read-only file " + file ) ; } if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { return ; } fileUtils . setFileLastModified ( file , millis ) ; } } 	0	['8', '3', '0', '10', '37', '0', '0', '10', '6', '0.628571429', '315', '1', '1', '0.840909091', '0.325', '0', '0', '37.75', '1', '0.875', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  " + "Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , location ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , location ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , location ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . BuildException ; public class SizeSelector extends BaseExtendSelector { private long size = - 1 ; private long multiplier = 1 ; private long sizelimit = - 1 ; private int cmp = 2 ; public final static String SIZE_KEY = "value" ; public final static String UNITS_KEY = "units" ; public final static String WHEN_KEY = "when" ; public SizeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{sizeselector value: " ) ; buf . append ( sizelimit ) ; buf . append ( "compare: " ) ; if ( cmp == 0 ) { buf . append ( "less" ) ; } else if ( cmp == 1 ) { buf . append ( "more" ) ; } else { buf . append ( "equal" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setValue ( long size ) { this . size = size ; if ( ( multiplier != 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setUnits ( ByteUnits units ) { int i = units . getIndex ( ) ; multiplier = 0 ; if ( ( i > - 1 ) && ( i < 4 ) ) { multiplier = 1000 ; } else if ( ( i > 3 ) && ( i < 9 ) ) { multiplier = 1024 ; } else if ( ( i > 8 ) && ( i < 13 ) ) { multiplier = 1000000 ; } else if ( ( i > 12 ) && ( i < 18 ) ) { multiplier = 1048576 ; } else if ( ( i > 17 ) && ( i < 22 ) ) { multiplier = 1000000000L ; } else if ( ( i > 21 ) && ( i < 27 ) ) { multiplier = 1073741824L ; } else if ( ( i > 26 ) && ( i < 31 ) ) { multiplier = 1000000000000L ; } else if ( ( i > 30 ) && ( i < 36 ) ) { multiplier = 1099511627776L ; } if ( ( multiplier > 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setWhen ( SizeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( SIZE_KEY . equalsIgnoreCase ( paramname ) ) { try { setValue ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid size setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( UNITS_KEY . equalsIgnoreCase ( paramname ) ) { ByteUnits units = new ByteUnits ( ) ; units . setValue ( parameters [ i ] . getValue ( ) ) ; setUnits ( units ) ; } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { SizeComparisons cmp = new SizeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( size < 0 ) { setError ( "The value attribute is required, and must be positive" ) ; } else if ( multiplier < 1 ) { setError ( "Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti" ) ; } else if ( sizelimit < 0 ) { setError ( "Internal error: Code is not setting sizelimit correctly" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } if ( cmp == 0 ) { return ( file . length ( ) < sizelimit ) ; } else if ( cmp == 1 ) { return ( file . length ( ) > sizelimit ) ; } else { return ( file . length ( ) == sizelimit ) ; } } public static class ByteUnits extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "K" , "k" , "kilo" , "KILO" , "Ki" , "KI" , "ki" , "kibi" , "KIBI" , "M" , "m" , "mega" , "MEGA" , "Mi" , "MI" , "mi" , "mebi" , "MEBI" , "G" , "g" , "giga" , "GIGA" , "Gi" , "GI" , "gi" , "gibi" , "GIBI" , "T" , "t" , "tera" , "TERA" , "Ti" , "TI" , "ti" , "tebi" , "TEBI" } ; } } public static class SizeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "less" , "more" , "equal" } ; } } } 	0	['8', '5', '0', '10', '28', '0', '4', '6', '8', '0.693877551', '365', '0.571428571', '0', '0.844444444', '0.25', '1', '4', '43.75', '19', '5.375', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Vector ; import org . xml . sax . AttributeList ; import org . xml . sax . helpers . AttributeListImpl ; public class RuntimeConfigurable { private String elementTag = null ; private Vector children = new Vector ( ) ; private Object wrappedObject = null ; private AttributeList attributes ; private StringBuffer characters = new StringBuffer ( ) ; private boolean proxyConfigured = false ; public RuntimeConfigurable ( Object proxy , String elementTag ) { wrappedObject = proxy ; this . elementTag = elementTag ; proxyConfigured = false ; } void setProxy ( Object proxy ) { wrappedObject = proxy ; proxyConfigured = false ; } public void setAttributes ( AttributeList attributes ) { this . attributes = new AttributeListImpl ( attributes ) ; } public AttributeList getAttributes ( ) { return attributes ; } public void addChild ( RuntimeConfigurable child ) { children . addElement ( child ) ; } RuntimeConfigurable getChild ( int index ) { return ( RuntimeConfigurable ) children . elementAt ( index ) ; } public void addText ( String data ) { characters . append ( data ) ; } public void addText ( char [ ] buf , int start , int count ) { addText ( new String ( buf , start , count ) ) ; } public String getElementTag ( ) { return elementTag ; } public void maybeConfigure ( Project p ) throws BuildException { maybeConfigure ( p , true ) ; } public void maybeConfigure ( Project p , boolean configureChildren ) throws BuildException { String id = null ; if ( proxyConfigured ) { return ; } if ( attributes != null ) { ProjectHelper . configure ( wrappedObject , attributes , p ) ; id = attributes . getValue ( "id" ) ; } if ( characters . length ( ) != 0 ) { ProjectHelper . addText ( p , wrappedObject , characters . toString ( ) ) ; } Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { RuntimeConfigurable child = ( RuntimeConfigurable ) enum . nextElement ( ) ; if ( child . wrappedObject instanceof Task ) { Task childTask = ( Task ) child . wrappedObject ; childTask . setRuntimeConfigurableWrapper ( child ) ; } if ( configureChildren ) { if ( child . wrappedObject instanceof Task ) { Task childTask = ( Task ) child . wrappedObject ; childTask . maybeConfigure ( ) ; } else { child . maybeConfigure ( p ) ; } ProjectHelper . storeChild ( p , wrappedObject , child . wrappedObject , child . getElementTag ( ) . toLowerCase ( Locale . US ) ) ; } } if ( id != null ) { p . addReference ( id , wrappedObject ) ; } proxyConfigured = true ; } } 	0	['11', '1', '0', '12', '32', '27', '9', '4', '9', '0.683333333', '190', '1', '0', '0', '0.232323232', '0', '0', '15.72727273', '1', '0.9091', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . io . File ; import java . io . PrintWriter ; import java . io . OutputStreamWriter ; import java . io . FileOutputStream ; import java . io . UnsupportedEncodingException ; import java . io . FileWriter ; import java . io . IOException ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private final String BOOLEAN = "%boolean;" ; private final String TASKS = "%tasks;" ; private final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , location ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printHead ( out , project . getTaskDefinitions ( ) . keys ( ) , project . getDataTypeDefinitions ( ) . keys ( ) ) ; printTargetDecl ( out ) ; Enumeration dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) project . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = project . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; printElementDecl ( out , taskName , ( Class ) project . getTaskDefinitions ( ) . get ( taskName ) ) ; } printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , location ) ; } finally { if ( out != null ) { out . close ( ) ; } visited . clear ( ) ; } } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String taskName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( taskName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | property | taskdef" ) ; out . print ( " | typedef | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #IMPLIED" ) ; out . println ( "          default CDATA #REQUIRED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration enum = ih . getNestedElements ( ) ; while ( enum . hasMoreElements ( ) ) { v . addElement ( enum . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( count > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb . setLength ( 0 ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; enum = ih . getAttributes ( ) ; while ( enum . hasMoreElements ( ) ) { String attrName = ( String ) enum . nextElement ( ) ; if ( "id" . equals ( attrName ) ) { continue ; } sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( org . apache . tools . ant . types . Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } private void printTail ( PrintWriter out ) { } protected boolean isNmtoken ( String s ) { final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } protected boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } 	0	['10', '3', '0', '7', '61', '37', '0', '7', '3', '0.9', '758', '0.6', '0', '0.804347826', '0.285714286', '0', '0', '73.8', '7', '2.1', '0']
package org . apache . tools . ant . util ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; public class LoaderUtils { private static Method getContextClassLoader ; private static Method setContextClassLoader ; static { try { getContextClassLoader = Thread . class . getMethod ( "getContextClassLoader" , new Class [ 0 ] ) ; Class [ ] setContextArgs = new Class [ ] { ClassLoader . class } ; setContextClassLoader = Thread . class . getMethod ( "setContextClassLoader" , setContextArgs ) ; } catch ( Exception e ) { } } public static void setContextClassLoader ( ClassLoader loader ) { if ( setContextClassLoader == null ) { return ; } try { Thread currentThread = Thread . currentThread ( ) ; setContextClassLoader . invoke ( currentThread , new Object [ ] { loader } ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Unexpected IllegalAccessException" , e ) ; } catch ( InvocationTargetException e ) { throw new BuildException ( "Unexpected InvocationTargetException" , e ) ; } } public static ClassLoader getContextClassLoader ( ) { if ( getContextClassLoader == null ) { return null ; } try { Thread currentThread = Thread . currentThread ( ) ; return ( ClassLoader ) getContextClassLoader . invoke ( currentThread , new Object [ 0 ] ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Unexpected IllegalAccessException" , e ) ; } catch ( InvocationTargetException e ) { throw new BuildException ( "Unexpected InvocationTargetException" , e ) ; } } public static boolean isContextLoaderAvailable ( ) { return getContextClassLoader != null && setContextClassLoader != null ; } } 	0	['6', '1', '0', '3', '14', '5', '2', '1', '4', '0.8', '131', '0.5', '0', '0', '0.2', '0', '0', '20.16666667', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; private static final int BUFFER_SIZE = 512 ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = project . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( project . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not " + "found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , this ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , this ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , location ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = project . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; private Exec parent ; public StreamPumper ( InputStream is , int messageLevel , Exec parent ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; this . parent = parent ; } public void pumpStream ( ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '6', '42', '21', '1', '6', '7', '0.793650794', '369', '1', '0', '0.804347826', '0.45', '0', '0', '35.2', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Unpack extends Task { protected File source ; protected File dest ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( project . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( project . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { source = src ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No Src specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "Src doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; } 	0	['10', '3', '2', '7', '24', '29', '2', '5', '6', '0.555555556', '162', '1', '0', '0.804347826', '0.5', '0', '0', '15', '4', '1.2', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class FilterSet extends DataType implements Cloneable { public static class Filter { String token ; String value ; public Filter ( String token , String value ) { this . token = token ; this . value = value ; } public Filter ( ) { } public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public String getToken ( ) { return token ; } public String getValue ( ) { return value ; } } public class FiltersFile { public FiltersFile ( ) { } public void setFile ( File file ) { readFiltersFromFile ( file ) ; } } public static final String DEFAULT_TOKEN_START = "@" ; public static final String DEFAULT_TOKEN_END = "@" ; private String startOfToken = DEFAULT_TOKEN_START ; private String endOfToken = DEFAULT_TOKEN_END ; private Vector filters = new Vector ( ) ; public FilterSet ( ) { } protected FilterSet ( FilterSet filterset ) { super ( ) ; this . filters = ( Vector ) filterset . getFilters ( ) . clone ( ) ; } protected Vector getFilters ( ) { if ( isReference ( ) ) { return getRef ( ) . getFilters ( ) ; } return filters ; } protected FilterSet getRef ( ) { return ( FilterSet ) getCheckedRef ( FilterSet . class , "filterset" ) ; } public Hashtable getFilterHash ( ) { int filterSize = getFilters ( ) . size ( ) ; Hashtable filterHash = new Hashtable ( filterSize ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } return filterHash ; } public void setFiltersfile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } readFiltersFromFile ( filtersFile ) ; } public void setBeginToken ( String startOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( startOfToken == null || "" . equals ( startOfToken ) ) { throw new BuildException ( "beginToken must not be empty" ) ; } this . startOfToken = startOfToken ; } public String getBeginToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getBeginToken ( ) ; } return startOfToken ; } public void setEndToken ( String endOfToken ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( endOfToken == null || "" . equals ( endOfToken ) ) { throw new BuildException ( "endToken must not be empty" ) ; } this . endOfToken = endOfToken ; } public String getEndToken ( ) { if ( isReference ( ) ) { return getRef ( ) . getEndToken ( ) ; } return endOfToken ; } public void readFiltersFromFile ( File filtersFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filtersFile . isFile ( ) ) { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Enumeration enum = props . propertyNames ( ) ; Vector filters = getFilters ( ) ; while ( enum . hasMoreElements ( ) ) { String strPropName = ( String ) enum . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; filters . addElement ( new Filter ( strPropName , strValue ) ) ; } } catch ( Exception e ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ioex ) { } } } } else { throw new BuildException ( "Must specify a file not a directory in " + "the filtersfile attribute:" + filtersFile ) ; } } public String replaceTokens ( String line ) { String beginToken = getBeginToken ( ) ; String endToken = getEndToken ( ) ; int index = line . indexOf ( beginToken ) ; if ( index > - 1 ) { Hashtable tokens = getFilterHash ( ) ; try { StringBuffer b = new StringBuffer ( ) ; int i = 0 ; String token = null ; String value = null ; do { int endIndex = line . indexOf ( endToken , index + beginToken . length ( ) + 1 ) ; if ( endIndex == - 1 ) { break ; } token = line . substring ( index + beginToken . length ( ) , endIndex ) ; b . append ( line . substring ( i , index ) ) ; if ( tokens . containsKey ( token ) ) { value = ( String ) tokens . get ( token ) ; log ( "Replacing: " + beginToken + token + endToken + " -> " + value , Project . MSG_VERBOSE ) ; b . append ( value ) ; i = index + beginToken . length ( ) + token . length ( ) + endToken . length ( ) ; } else { b . append ( beginToken ) ; i = index + beginToken . length ( ) ; } } while ( ( index = line . indexOf ( beginToken , i ) ) > - 1 ) ; b . append ( line . substring ( i ) ) ; return b . toString ( ) ; } catch ( StringIndexOutOfBoundsException e ) { return line ; } } else { return line ; } } public void addFilter ( Filter filter ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( filter ) ; } public FiltersFile createFiltersfile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return new FiltersFile ( ) ; } public void addFilter ( String token , String value ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } filters . addElement ( new Filter ( token , value ) ) ; } public void addFilterSet ( FilterSet filterSet ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } for ( Enumeration e = filterSet . getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { filters . addElement ( e . nextElement ( ) ) ; } } public boolean hasFilters ( ) { return getFilters ( ) . size ( ) > 0 ; } public Object clone ( ) throws BuildException { if ( isReference ( ) ) { return new FilterSet ( getRef ( ) ) ; } else { return new FilterSet ( this ) ; } } } 	0	['19', '3', '0', '11', '61', '121', '7', '5', '15', '0.75', '503', '0.5', '0', '0.638297872', '0.294736842', '2', '2', '25.15789474', '5', '2', '0']
package org . apache . tools . ant . types ; public class DirSet extends AbstractFileSet { public DirSet ( ) { super ( ) ; } protected DirSet ( DirSet dirset ) { super ( dirset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return new DirSet ( ( DirSet ) getRef ( getProject ( ) ) ) ; } else { return new DirSet ( this ) ; } } } 	0	['3', '4', '0', '7', '8', '3', '3', '4', '2', '2', '27', '0', '0', '0.988636364', '0.666666667', '3', '4', '8', '2', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public final class AntFilterReader extends DataType implements Cloneable { private String className ; private final Vector parameters = new Vector ( ) ; private Path classpath ; public final void setClassName ( final String className ) { this . className = className ; } public final String getClassName ( ) { return className ; } public final void addParam ( final Parameter param ) { parameters . addElement ( param ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public final Parameter [ ] getParams ( ) { Parameter [ ] params = new Parameter [ parameters . size ( ) ] ; parameters . copyInto ( params ) ; return params ; } public void setRefid ( Reference r ) throws BuildException { if ( ! parameters . isEmpty ( ) || className != null || classpath != null ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof AntFilterReader ) { AntFilterReader afr = ( AntFilterReader ) o ; setClassName ( afr . getClassName ( ) ) ; setClasspath ( afr . getClasspath ( ) ) ; Parameter [ ] p = afr . getParams ( ) ; if ( p != null ) { for ( int i = 0 ; i < p . length ; i ++ ) { addParam ( p [ i ] ) ; } } } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterReader" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['10', '3', '0', '9', '31', '15', '2', '7', '10', '0.666666667', '166', '1', '1', '0.769230769', '0.3', '1', '1', '15.3', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import java . text . SimpleDateFormat ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( project , d , location ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; project . setNewProperty ( prefix + "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; project . setNewProperty ( prefix + "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; project . setNewProperty ( prefix + "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( prefix ) ; customFormats . addElement ( cts ) ; return cts ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; private String prefix = "" ; public CustomFormat ( String prefix ) { this . prefix = prefix ; } public void setProperty ( String propertyName ) { this . propertyName = prefix + propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } project . setNewProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Hashtable calendarFields = new Hashtable ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['4', '3', '0', '6', '22', '0', '1', '6', '4', '0.166666667', '142', '1', '0', '0.925', '0.625', '0', '0', '34', '2', '1', '0']
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class params [ ] = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( ClassNotFoundException cnfe ) { throw new IOException ( cnfe . getMessage ( ) ) ; } catch ( NoSuchMethodException nsme ) { throw new IOException ( nsme . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new IOException ( iae . getMessage ( ) ) ; } catch ( IllegalArgumentException iarge ) { throw new IOException ( iarge . getMessage ( ) ) ; } catch ( InvocationTargetException ite ) { throw new IOException ( ite . getMessage ( ) ) ; } } } return ch ; } public final Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	0	['5', '4', '0', '3', '20', '4', '1', '2', '4', '0.833333333', '168', '0.666666667', '0', '0.896551724', '0.466666667', '2', '4', '32', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '5', '2', '0', '5', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0	['6', '1', '0', '3', '11', '1', '1', '2', '6', '0.7', '74', '1', '0', '0', '0.555555556', '0', '0', '10.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Hashtable ; public class WaitFor extends ConditionBase { private long maxWaitMillis = 1000l * 60l * 3l ; private long maxWaitMultiplier = 1l ; private long checkEveryMillis = 500l ; private long checkEveryMultiplier = 1l ; private String timeoutProperty ; public void setMaxWait ( long time ) { maxWaitMillis = time ; } public void setMaxWaitUnit ( Unit unit ) { maxWaitMultiplier = unit . getMultiplier ( ) ; } public void setCheckEvery ( long time ) { checkEveryMillis = time ; } public void setCheckEveryUnit ( Unit unit ) { checkEveryMultiplier = unit . getMultiplier ( ) ; } public void setTimeoutProperty ( String p ) { timeoutProperty = p ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <waitfor>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<waitfor>" ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; long savedMaxWaitMillis = maxWaitMillis ; long savedCheckEveryMillis = checkEveryMillis ; try { maxWaitMillis *= maxWaitMultiplier ; checkEveryMillis *= checkEveryMultiplier ; long start = System . currentTimeMillis ( ) ; long end = start + maxWaitMillis ; while ( System . currentTimeMillis ( ) < end ) { if ( c . eval ( ) ) { return ; } try { Thread . sleep ( checkEveryMillis ) ; } catch ( InterruptedException e ) { } } if ( timeoutProperty != null ) { project . setNewProperty ( timeoutProperty , "true" ) ; } } finally { maxWaitMillis = savedMaxWaitMillis ; checkEveryMillis = savedCheckEveryMillis ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK } ; private Hashtable timeTable = new Hashtable ( ) ; public Unit ( ) { timeTable . put ( MILLISECOND , new Long ( 1l ) ) ; timeTable . put ( SECOND , new Long ( 1000l ) ) ; timeTable . put ( MINUTE , new Long ( 1000l * 60l ) ) ; timeTable . put ( HOUR , new Long ( 1000l * 60l * 60l ) ) ; timeTable . put ( DAY , new Long ( 1000l * 60l * 60l * 24l ) ) ; timeTable . put ( WEEK , new Long ( 1000l * 60l * 60l * 24l * 7l ) ) ; } public long getMultiplier ( ) { String key = getValue ( ) . toLowerCase ( ) ; Long l = ( Long ) timeTable . get ( key ) ; return l . longValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['7', '3', '0', '6', '17', '1', '0', '6', '7', '0.7', '138', '1', '0', '0.842105263', '0.428571429', '0', '0', '18', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringWriter ; import java . io . UnsupportedEncodingException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . CollectionUtils ; public class Manifest { public static final String ATTRIBUTE_MANIFEST_VERSION = "Manifest-Version" ; public static final String ATTRIBUTE_SIGNATURE_VERSION = "Signature-Version" ; public static final String ATTRIBUTE_NAME = "Name" ; public static final String ATTRIBUTE_FROM = "From" ; public static final String ATTRIBUTE_CLASSPATH = "class-path" ; public static final String DEFAULT_MANIFEST_VERSION = "1.0" ; public static final int MAX_LINE_LENGTH = 72 ; public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2 ; public static final String EOL = "\r\n" ; public static class Attribute { private String name = null ; private Vector values = new Vector ( ) ; private int currentIndex = 0 ; public Attribute ( ) { } public Attribute ( String line ) throws ManifestException { parse ( line ) ; } public Attribute ( String name , String value ) { this . name = name ; setValue ( value ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += values . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Attribute rhsAttribute = ( Attribute ) rhs ; String lhsKey = getKey ( ) ; String rhsKey = rhsAttribute . getKey ( ) ; if ( ( lhsKey == null && rhsKey != null ) || ( lhsKey != null && rhsKey == null ) || ! lhsKey . equals ( rhsKey ) ) { return false ; } return CollectionUtils . equals ( values , rhsAttribute . values ) ; } public void parse ( String line ) throws ManifestException { int index = line . indexOf ( ": " ) ; if ( index == - 1 ) { throw new ManifestException ( "Manifest line \"" + line + "\" is not valid as it does not " + "contain a name and a value separated by ': ' " ) ; } name = line . substring ( 0 , index ) ; setValue ( line . substring ( index + 2 ) ) ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String getKey ( ) { if ( name == null ) { return null ; } return name . toLowerCase ( ) ; } public void setValue ( String value ) { if ( currentIndex >= values . size ( ) ) { values . addElement ( value ) ; currentIndex = values . size ( ) - 1 ; } else { values . setElementAt ( value , currentIndex ) ; } } public String getValue ( ) { if ( values . size ( ) == 0 ) { return null ; } String fullValue = "" ; for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { String value = ( String ) e . nextElement ( ) ; fullValue += value + " " ; } return fullValue . trim ( ) ; } public void addValue ( String value ) { currentIndex ++ ; setValue ( value ) ; } public Enumeration getValues ( ) { return values . elements ( ) ; } public void addContinuation ( String line ) { String currentValue = ( String ) values . elementAt ( currentIndex ) ; setValue ( currentValue + line . substring ( 1 ) ) ; } public void write ( PrintWriter writer ) throws IOException { for ( Enumeration e = getValues ( ) ; e . hasMoreElements ( ) ; ) { writeValue ( writer , ( String ) e . nextElement ( ) ) ; } } private void writeValue ( PrintWriter writer , String value ) throws IOException { String line = name + ": " + value ; while ( line . getBytes ( ) . length > MAX_LINE_LENGTH ) { int breakIndex = MAX_SECTION_LENGTH ; String section = line . substring ( 0 , breakIndex ) ; while ( section . getBytes ( ) . length > MAX_SECTION_LENGTH && breakIndex > 0 ) { breakIndex -- ; section = line . substring ( 0 , breakIndex ) ; } if ( breakIndex == 0 ) { throw new IOException ( "Unable to write manifest line " + name + ": " + value ) ; } writer . print ( section + EOL ) ; line = " " + line . substring ( breakIndex ) ; } writer . print ( line + EOL ) ; } } public static class Section { private Vector warnings = new Vector ( ) ; private String name = null ; private Hashtable attributes = new Hashtable ( ) ; private Vector attributeIndex = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public String read ( BufferedReader reader ) throws ManifestException , IOException { Attribute attribute = null ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null || line . length ( ) == 0 ) { return null ; } if ( line . charAt ( 0 ) == ' ' ) { if ( attribute == null ) { if ( name != null ) { name += line . substring ( 1 ) ; } else { throw new ManifestException ( "Can't start an " + "attribute with a continuation line " + line ) ; } } else { attribute . addContinuation ( line ) ; } } else { attribute = new Attribute ( line ) ; String nameReadAhead = addAttributeAndCheck ( attribute ) ; if ( nameReadAhead != null ) { return nameReadAhead ; } } } } public void merge ( Section section ) throws ManifestException { if ( name == null && section . getName ( ) != null || name != null && ! ( name . equalsIgnoreCase ( section . getName ( ) ) ) ) { throw new ManifestException ( "Unable to merge sections " + "with different names" ) ; } Enumeration e = section . getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String attributeName = ( String ) e . nextElement ( ) ; Attribute attribute = section . getAttribute ( attributeName ) ; if ( attributeName . equals ( ATTRIBUTE_CLASSPATH ) && attributes . containsKey ( attributeName ) ) { Attribute ourClassPath = getAttribute ( attributeName ) ; Enumeration cpe = attribute . getValues ( ) ; while ( cpe . hasMoreElements ( ) ) { String value = ( String ) cpe . nextElement ( ) ; ourClassPath . addValue ( value ) ; } } else { storeAttribute ( attribute ) ; } } Enumeration warnEnum = section . warnings . elements ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } } public void write ( PrintWriter writer ) throws IOException { if ( name != null ) { Attribute nameAttr = new Attribute ( ATTRIBUTE_NAME , name ) ; nameAttr . write ( writer ) ; } Enumeration e = getAttributeKeys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; Attribute attribute = getAttribute ( key ) ; attribute . write ( writer ) ; } writer . print ( EOL ) ; } public Attribute getAttribute ( String attributeName ) { return ( Attribute ) attributes . get ( attributeName . toLowerCase ( ) ) ; } public Enumeration getAttributeKeys ( ) { return attributeIndex . elements ( ) ; } public String getAttributeValue ( String attributeName ) { Attribute attribute = getAttribute ( attributeName . toLowerCase ( ) ) ; if ( attribute == null ) { return null ; } return attribute . getValue ( ) ; } public void removeAttribute ( String attributeName ) { String key = attributeName . toLowerCase ( ) ; attributes . remove ( key ) ; attributeIndex . removeElement ( key ) ; } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { String check = addAttributeAndCheck ( attribute ) ; if ( check != null ) { throw new BuildException ( "Specify the section name using " + "the \"name\" attribute of the <section> element rather " + "than using a \"Name\" manifest attribute" ) ; } } public String addAttributeAndCheck ( Attribute attribute ) throws ManifestException { if ( attribute . getName ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { warnings . addElement ( "\"" + ATTRIBUTE_NAME + "\" attributes " + "should not occur in the main section and must be the " + "first element in all other sections: \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; return attribute . getValue ( ) ; } if ( attribute . getKey ( ) . startsWith ( ATTRIBUTE_FROM . toLowerCase ( ) ) ) { warnings . addElement ( "Manifest attributes should not start " + "with \"" + ATTRIBUTE_FROM + "\" in \"" + attribute . getName ( ) + ": " + attribute . getValue ( ) + "\"" ) ; } else { String attributeKey = attribute . getKey ( ) ; if ( attributeKey . equals ( ATTRIBUTE_CLASSPATH ) ) { Attribute classpathAttribute = ( Attribute ) attributes . get ( attributeKey ) ; if ( classpathAttribute == null ) { storeAttribute ( attribute ) ; } else { Enumeration e = attribute . getValues ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; classpathAttribute . addValue ( value ) ; } } } else if ( attributes . containsKey ( attributeKey ) ) { throw new ManifestException ( "The attribute \"" + attribute . getName ( ) + "\" may not occur more " + "than once in the same section" ) ; } else { storeAttribute ( attribute ) ; } } return null ; } private void storeAttribute ( Attribute attribute ) { if ( attribute == null ) { return ; } String attributeKey = attribute . getKey ( ) ; attributes . put ( attributeKey , attribute ) ; if ( ! attributeIndex . contains ( attributeKey ) ) { attributeIndex . addElement ( attributeKey ) ; } } public Enumeration getWarnings ( ) { return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( name != null ) { hashCode += name . hashCode ( ) ; } hashCode += attributes . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Section rhsSection = ( Section ) rhs ; return CollectionUtils . equals ( attributes , rhsSection . attributes ) ; } } private String manifestVersion = DEFAULT_MANIFEST_VERSION ; private Section mainSection = new Section ( ) ; private Hashtable sections = new Hashtable ( ) ; private Vector sectionIndex = new Vector ( ) ; public static Manifest getDefaultManifest ( ) throws BuildException { try { String defManifest = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = Manifest . class . getResourceAsStream ( defManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find default manifest: " + defManifest ) ; } try { return new Manifest ( new InputStreamReader ( in , "ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { return new Manifest ( new InputStreamReader ( in ) ) ; } } catch ( ManifestException e ) { throw new BuildException ( "Default manifest is invalid !!" , e ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read default manifest" , e ) ; } } public Manifest ( ) { manifestVersion = null ; } public Manifest ( Reader r ) throws ManifestException , IOException { BufferedReader reader = new BufferedReader ( r ) ; String nextSectionName = mainSection . read ( reader ) ; String readManifestVersion = mainSection . getAttributeValue ( ATTRIBUTE_MANIFEST_VERSION ) ; if ( readManifestVersion != null ) { manifestVersion = readManifestVersion ; mainSection . removeAttribute ( ATTRIBUTE_MANIFEST_VERSION ) ; } String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) == 0 ) { continue ; } Section section = new Section ( ) ; if ( nextSectionName == null ) { Attribute sectionName = new Attribute ( line ) ; if ( ! sectionName . getName ( ) . equalsIgnoreCase ( ATTRIBUTE_NAME ) ) { throw new ManifestException ( "Manifest sections should " + "start with a \"" + ATTRIBUTE_NAME + "\" attribute and not \"" + sectionName . getName ( ) + "\"" ) ; } nextSectionName = sectionName . getValue ( ) ; } else { Attribute firstAttribute = new Attribute ( line ) ; section . addAttributeAndCheck ( firstAttribute ) ; } section . setName ( nextSectionName ) ; nextSectionName = section . read ( reader ) ; addConfiguredSection ( section ) ; } } public void addConfiguredSection ( Section section ) throws ManifestException { String sectionName = section . getName ( ) ; if ( sectionName == null ) { throw new BuildException ( "Sections must have a name" ) ; } sections . put ( sectionName , section ) ; if ( ! sectionIndex . contains ( sectionName ) ) { sectionIndex . addElement ( sectionName ) ; } } public void addConfiguredAttribute ( Attribute attribute ) throws ManifestException { if ( attribute . getKey ( ) == null || attribute . getValue ( ) == null ) { throw new BuildException ( "Attributes must have name and value" ) ; } if ( attribute . getKey ( ) . equalsIgnoreCase ( ATTRIBUTE_MANIFEST_VERSION ) ) { manifestVersion = attribute . getValue ( ) ; } else { mainSection . addConfiguredAttribute ( attribute ) ; } } public void merge ( Manifest other ) throws ManifestException { merge ( other , false ) ; } public void merge ( Manifest other , boolean overwriteMain ) throws ManifestException { if ( other != null ) { if ( overwriteMain ) { mainSection = other . mainSection ; } else { mainSection . merge ( other . mainSection ) ; } if ( other . manifestVersion != null ) { manifestVersion = other . manifestVersion ; } Enumeration e = other . getSectionNames ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section ourSection = ( Section ) sections . get ( sectionName ) ; Section otherSection = ( Section ) other . sections . get ( sectionName ) ; if ( ourSection == null ) { if ( otherSection != null ) { addConfiguredSection ( otherSection ) ; } } else { ourSection . merge ( otherSection ) ; } } } } public void write ( PrintWriter writer ) throws IOException { writer . print ( ATTRIBUTE_MANIFEST_VERSION + ": " + manifestVersion + EOL ) ; String signatureVersion = mainSection . getAttributeValue ( ATTRIBUTE_SIGNATURE_VERSION ) ; if ( signatureVersion != null ) { writer . print ( ATTRIBUTE_SIGNATURE_VERSION + ": " + signatureVersion + EOL ) ; mainSection . removeAttribute ( ATTRIBUTE_SIGNATURE_VERSION ) ; } mainSection . write ( writer ) ; if ( signatureVersion != null ) { try { Attribute svAttr = new Attribute ( ATTRIBUTE_SIGNATURE_VERSION , signatureVersion ) ; mainSection . addConfiguredAttribute ( svAttr ) ; } catch ( ManifestException e ) { } } Enumeration e = sectionIndex . elements ( ) ; while ( e . hasMoreElements ( ) ) { String sectionName = ( String ) e . nextElement ( ) ; Section section = getSection ( sectionName ) ; section . write ( writer ) ; } } public String toString ( ) { StringWriter sw = new StringWriter ( ) ; try { write ( new PrintWriter ( sw ) ) ; } catch ( IOException e ) { return null ; } return sw . toString ( ) ; } public Enumeration getWarnings ( ) { Vector warnings = new Vector ( ) ; Enumeration warnEnum = mainSection . getWarnings ( ) ; while ( warnEnum . hasMoreElements ( ) ) { warnings . addElement ( warnEnum . nextElement ( ) ) ; } Enumeration e = sections . elements ( ) ; while ( e . hasMoreElements ( ) ) { Section section = ( Section ) e . nextElement ( ) ; Enumeration e2 = section . getWarnings ( ) ; while ( e2 . hasMoreElements ( ) ) { warnings . addElement ( e2 . nextElement ( ) ) ; } } return warnings . elements ( ) ; } public int hashCode ( ) { int hashCode = 0 ; if ( manifestVersion != null ) { hashCode += manifestVersion . hashCode ( ) ; } hashCode += mainSection . hashCode ( ) ; hashCode += sections . hashCode ( ) ; return hashCode ; } public boolean equals ( Object rhs ) { if ( rhs == null || rhs . getClass ( ) != getClass ( ) ) { return false ; } if ( rhs == this ) { return true ; } Manifest rhsManifest = ( Manifest ) rhs ; if ( manifestVersion == null ) { if ( rhsManifest . manifestVersion != null ) { return false ; } } else if ( ! manifestVersion . equals ( rhsManifest . manifestVersion ) ) { return false ; } if ( ! mainSection . equals ( rhsManifest . mainSection ) ) { return false ; } return CollectionUtils . equals ( sections , rhsManifest . sections ) ; } public String getManifestVersion ( ) { return manifestVersion ; } public Section getMainSection ( ) { return mainSection ; } public Section getSection ( String name ) { return ( Section ) sections . get ( name ) ; } public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } } 	0	['17', '1', '0', '7', '71', '14', '2', '5', '16', '0.866071429', '569', '0.285714286', '1', '0', '0.163398693', '1', '1', '31.64705882', '8', '1.5294', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; public class DependSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private int granularity = 0 ; public DependSelector ( ) { if ( Os . isFamily ( "dos" ) ) { granularity = 2000 ; } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir . getName ( ) + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return SelectorUtils . isOutOfDate ( file , destfile , granularity ) ; } } 	0	['7', '4', '0', '13', '25', '0', '4', '9', '7', '0.458333333', '201', '1', '2', '0.853658537', '0.392857143', '1', '3', '27.14285714', '4', '2.1429', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . FactoryConfigurationError ; public class JAXPUtils { private static SAXParserFactory parserFactory = null ; public synchronized static SAXParserFactory getParserFactory ( ) throws BuildException { if ( parserFactory == null ) { parserFactory = newParserFactory ( ) ; } return parserFactory ; } public static SAXParserFactory newParserFactory ( ) throws BuildException { try { return SAXParserFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "XML parser factory has not been " + "configured correctly: " + e . getMessage ( ) , e ) ; } } public static Parser getParser ( ) throws BuildException { try { return newSAXParser ( ) . getParser ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getXMLReader ( ) throws BuildException { try { return newSAXParser ( ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static SAXParser newSAXParser ( ) throws BuildException { try { return getParserFactory ( ) . newSAXParser ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( "Cannot create parser for the given " + "configuration: " + e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static BuildException convertToBuildException ( SAXException e ) { Exception nested = e . getException ( ) ; if ( nested != null ) { return new BuildException ( nested ) ; } else { return new BuildException ( e ) ; } } } 	0	['8', '1', '0', '2', '21', '26', '1', '1', '5', '0.714285714', '89', '1', '0', '0', '0.142857143', '0', '0', '10', '2', '0.875', '0']
package org . apache . tools . tar ; import java . io . File ; import java . util . Date ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } else if ( osname . toLowerCase ( ) . indexOf ( "netware" ) > - 1 ) { int colon = name . indexOf ( ':' ) ; if ( colon != - 1 ) { name = name . substring ( colon + 1 ) ; } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public int getMode ( ) { return this . mode ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['32', '1', '0', '6', '69', '264', '4', '2', '31', '0.733333333', '771', '1', '0', '0', '0.180555556', '1', '1', '22.625', '4', '1.1563', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FilenameFilter ; import java . io . PrintStream ; import java . io . InputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Properties ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; public final class Diagnostics { private Diagnostics ( ) { } public static boolean isOptionalAvailable ( ) { try { Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; } catch ( ClassNotFoundException e ) { return false ; } return true ; } public static void validateVersion ( ) throws BuildException { try { Class optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; String coreVersion = getImplementationVersion ( Main . class ) ; String optionalVersion = getImplementationVersion ( optional ) ; if ( coreVersion != null && ! coreVersion . equals ( optionalVersion ) ) { throw new BuildException ( "Invalid implementation version between Ant core and Ant optional tasks.\n" + " core    : " + coreVersion + "\n" + " optional: " + optionalVersion ) ; } } catch ( ClassNotFoundException e ) { } } public static File [ ] listLibraries ( ) { String home = System . getProperty ( "ant.home" ) ; File libDir = new File ( home , "lib" ) ; FilenameFilter filter = new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . endsWith ( ".jar" ) ; } } ; String [ ] filenames = libDir . list ( filter ) ; File [ ] files = new File [ filenames . length ] ; for ( int i = 0 ; i < filenames . length ; i ++ ) { files [ i ] = new File ( libDir , filenames [ i ] ) ; } return files ; } public static void main ( String [ ] args ) { doReport ( System . out ) ; } private static String getImplementationVersion ( Class clazz ) { try { Method method = Class . class . getMethod ( "getPackage" , new Class [ 0 ] ) ; Object pkg = method . invoke ( clazz , null ) ; if ( pkg != null ) { method = pkg . getClass ( ) . getMethod ( "getImplementationVersion" , new Class [ 0 ] ) ; Object version = method . invoke ( pkg , null ) ; return ( String ) version ; } } catch ( Exception e ) { return "?.?" ; } return null ; } public static void doReport ( PrintStream out ) { out . println ( "------- Ant diagnostics report -------" ) ; out . println ( Main . getAntVersion ( ) ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Implementation Version (JDK1.2+ only)" ) ; out . println ( "-------------------------------------------" ) ; out . println ( "core tasks     : " + getImplementationVersion ( Main . class ) ) ; Class optional = null ; try { optional = Class . forName ( "org.apache.tools.ant.taskdefs.optional.Test" ) ; out . println ( "optional tasks : " + getImplementationVersion ( optional ) ) ; } catch ( ClassNotFoundException e ) { out . println ( "optional tasks : not available" ) ; } out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " ANT_HOME/lib jar listing" ) ; out . println ( "-------------------------------------------" ) ; doReportLibraries ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " Tasks availability" ) ; out . println ( "-------------------------------------------" ) ; doReportTasksAvailability ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " org.apache.env.Which diagnostics" ) ; out . println ( "-------------------------------------------" ) ; doReportWhich ( out ) ; out . println ( ) ; out . println ( "-------------------------------------------" ) ; out . println ( " System properties" ) ; out . println ( "-------------------------------------------" ) ; doReportSystemProperties ( out ) ; out . println ( ) ; } private static void doReportSystemProperties ( PrintStream out ) { for ( Enumeration keys = System . getProperties ( ) . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; out . println ( key + " : " + System . getProperty ( key ) ) ; } } private static void doReportLibraries ( PrintStream out ) { File [ ] libs = listLibraries ( ) ; for ( int i = 0 ; i < libs . length ; i ++ ) { out . println ( libs [ i ] . getName ( ) + " (" + libs [ i ] . length ( ) + " bytes)" ) ; } } private static void doReportWhich ( PrintStream out ) { Throwable error = null ; try { Class which = Class . forName ( "org.apache.env.Which" ) ; Method method = which . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; method . invoke ( null , new Object [ ] { new String [ ] { } } ) ; } catch ( ClassNotFoundException e ) { out . println ( "Not available." ) ; out . println ( "Download it at http://xml.apache.org/commons/" ) ; } catch ( InvocationTargetException e ) { error = e . getTargetException ( ) == null ? e : e . getTargetException ( ) ; } catch ( Exception e ) { error = e ; } if ( error != null ) { out . println ( "Error while running org.apache.env.Which" ) ; error . printStackTrace ( ) ; } } private static void doReportTasksAvailability ( PrintStream out ) { InputStream is = Main . class . getResourceAsStream ( "/org/apache/tools/ant/taskdefs/defaults.properties" ) ; if ( is == null ) { out . println ( "None available" ) ; } else { Properties props = new Properties ( ) ; try { props . load ( is ) ; for ( Enumeration keys = props . keys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; String classname = props . getProperty ( key ) ; try { Class . forName ( classname ) ; props . remove ( key ) ; } catch ( ClassNotFoundException e ) { out . println ( key + " : Not Available" ) ; } } if ( props . size ( ) == 0 ) { out . println ( "All defined tasks are available" ) ; } } catch ( IOException e ) { out . println ( e . getMessage ( ) ) ; } } } } 	0	['12', '1', '0', '3', '47', '60', '1', '3', '5', '0.818181818', '466', '0', '0', '0', '0.15', '0', '0', '37.58333333', '4', '1.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import java . io . BufferedReader ; import java . io . OutputStream ; import java . io . InputStream ; import java . io . IOException ; import java . io . InputStreamReader ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; cmd . setExecutable ( "sj" ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '9', '1', '1', '5', '2', '2', '33', '0', '0', '0.958333333', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or " + "only a filtersFile parameter is " + "required" , location ) ; } if ( isSingleFilter ) { project . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; project . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '16', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = new Boolean ( value ) ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '7', '0', '1', '3', '3', '0', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . Task ; import java . io . PrintStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Hashtable ; public class Recorder extends Task { private String filename = null ; private Boolean append = null ; private Boolean start = null ; private int loglevel = - 1 ; private boolean emacsMode = false ; private static Hashtable recorderEntries = new Hashtable ( ) ; public void setName ( String fname ) { filename = fname ; } public void setAction ( ActionChoices action ) { if ( action . getValue ( ) . equalsIgnoreCase ( "start" ) ) { start = Boolean . TRUE ; } else { start = Boolean . FALSE ; } } public void setAppend ( boolean append ) { this . append = new Boolean ( append ) ; } public void setEmacsMode ( boolean emacsMode ) { this . emacsMode = emacsMode ; } public void setLoglevel ( VerbosityLevelChoices level ) { String lev = level . getValue ( ) ; if ( lev . equalsIgnoreCase ( "error" ) ) { loglevel = Project . MSG_ERR ; } else if ( lev . equalsIgnoreCase ( "warn" ) ) { loglevel = Project . MSG_WARN ; } else if ( lev . equalsIgnoreCase ( "info" ) ) { loglevel = Project . MSG_INFO ; } else if ( lev . equalsIgnoreCase ( "verbose" ) ) { loglevel = Project . MSG_VERBOSE ; } else if ( lev . equalsIgnoreCase ( "debug" ) ) { loglevel = Project . MSG_DEBUG ; } } public void execute ( ) throws BuildException { if ( filename == null ) { throw new BuildException ( "No filename specified" ) ; } getProject ( ) . log ( "setting a recorder for name " + filename , Project . MSG_DEBUG ) ; RecorderEntry recorder = getRecorder ( filename , getProject ( ) ) ; recorder . setMessageOutputLevel ( loglevel ) ; recorder . setRecordState ( start ) ; recorder . setEmacsMode ( emacsMode ) ; } public static class ActionChoices extends EnumeratedAttribute { private static final String [ ] values = { "start" , "stop" } ; public String [ ] getValues ( ) { return values ; } } public static class VerbosityLevelChoices extends EnumeratedAttribute { private static final String [ ] values = { "error" , "warn" , "info" , "verbose" , "debug" } ; public String [ ] getValues ( ) { return values ; } } protected RecorderEntry getRecorder ( String name , Project proj ) throws BuildException { Object o = recorderEntries . get ( name ) ; RecorderEntry entry ; if ( o == null ) { try { entry = new RecorderEntry ( name ) ; PrintStream out = null ; if ( append == null ) { out = new PrintStream ( new FileOutputStream ( name ) ) ; } else { out = new PrintStream ( new FileOutputStream ( name , append . booleanValue ( ) ) ) ; } entry . setErrorPrintStream ( out ) ; entry . setOutputPrintStream ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Problems creating a recorder entry" , ioe ) ; } proj . addBuildListener ( entry ) ; recorderEntries . put ( name , entry ) ; } else { entry = ( RecorderEntry ) o ; } return entry ; } } 	0	['9', '3', '0', '9', '34', '10', '0', '9', '7', '0.729166667', '214', '1', '0', '0.840909091', '0.3125', '1', '1', '22.11111111', '6', '1.4444', '0']
package org . apache . tools . bzip2 ; class CRC { public static int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; public CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } int globalCrc ; } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '1', '0.5', '1082', '0', '0', '0', '0.666666667', '0', '0', '153.2857143', '2', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; watch = false ; process = null ; } public void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['8', '1', '0', '8', '22', '0', '5', '3', '7', '0.542857143', '141', '1', '1', '0', '0.34375', '0', '0', '16', '5', '1.625', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . StringUtils ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; protected static final String DISCLAIMER = StringUtils . LINE_SEP + "The \' characters around the executable and arguments are" + StringUtils . LINE_SEP + "not part of the command." + StringUtils . LINE_SEP ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public static class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { if ( line == null ) { return ; } parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { return this . createArgument ( false ) ; } public Argument createArgument ( boolean insertAtStart ) { Argument argument = new Argument ( ) ; if ( insertAtStart ) { arguments . insertElementAt ( argument , 0 ) ; } else { arguments . addElement ( argument ) ; } return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) { return ; } this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) { return args ; } final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; if ( s != null ) { for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } public String describeCommand ( ) { return describeCommand ( this ) ; } public String describeArguments ( ) { return describeArguments ( this ) ; } public static String describeCommand ( Commandline line ) { return describeCommand ( line . getCommandline ( ) ) ; } public static String describeArguments ( Commandline line ) { return describeArguments ( line . getArguments ( ) ) ; } public static String describeCommand ( String [ ] args ) { if ( args == null || args . length == 0 ) { return "" ; } StringBuffer buf = new StringBuffer ( "Executing \'" ) ; buf . append ( args [ 0 ] ) ; buf . append ( "\'" ) ; if ( args . length > 0 ) { buf . append ( " with " ) ; buf . append ( describeArguments ( args , 1 ) ) ; } else { buf . append ( DISCLAIMER ) ; } return buf . toString ( ) ; } public static String describeArguments ( String [ ] args ) { return describeArguments ( args , 0 ) ; } protected static String describeArguments ( String [ ] args , int offset ) { if ( args == null || args . length <= offset ) { return "" ; } StringBuffer buf = new StringBuffer ( "argument" ) ; if ( args . length > offset ) { buf . append ( "s" ) ; } buf . append ( ":" ) . append ( StringUtils . LINE_SEP ) ; for ( int i = offset ; i < args . length ; i ++ ) { buf . append ( "\'" ) . append ( args [ i ] ) . append ( "\'" ) . append ( StringUtils . LINE_SEP ) ; } buf . append ( DISCLAIMER ) ; return buf . toString ( ) ; } } 	0	['28', '1', '0', '31', '57', '266', '29', '4', '24', '0.641975309', '602', '1', '0', '0', '0.197530864', '0', '0', '20.39285714', '16', '2.25', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['3', '6', '0', '6', '11', '3', '4', '3', '3', '2', '37', '0', '0', '0.96969697', '1', '2', '3', '11.33333333', '2', '1.3333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private Vector regexps = new Vector ( ) ; private String line = null ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; if ( line == null ) { ch = - 1 ; } else { final int regexpsSize = regexps . size ( ) ; for ( int i = 0 ; i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; boolean matches = re . matches ( line ) ; if ( ! matches ) { line = null ; break ; } } return read ( ) ; } } return ch ; } public final void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private final Vector getRegexps ( ) { return regexps ; } public final Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } } } } } 	0	['8', '5', '0', '9', '29', '0', '1', '8', '5', '0.571428571', '179', '1', '0', '0.823529412', '0.375', '2', '5', '21', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . IOException ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '9', '9', '1', '5', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] result = new byte [ length ] ; int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '274', '0', '0', '0', '0.45', '0', '0', '33.25', '7', '2.75', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public interface Regexp extends RegexpMatcher { int REPLACE_FIRST = 0x00000001 ; int REPLACE_ALL = 0x00000010 ; String substitute ( String input , String argument , int options ) throws BuildException ; } 	0	['1', '1', '0', '5', '1', '0', '3', '2', '1', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . facade ; import java . util . Enumeration ; import java . util . Vector ; public class FacadeTaskHelper { private Vector args = new Vector ( ) ; private String userChoice ; private String magicValue ; private String defaultValue ; public FacadeTaskHelper ( String defaultValue ) { this ( defaultValue , null ) ; } public FacadeTaskHelper ( String defaultValue , String magicValue ) { this . defaultValue = defaultValue ; this . magicValue = magicValue ; } public void setMagicValue ( String magicValue ) { this . magicValue = magicValue ; } public void setImplementation ( String userChoice ) { this . userChoice = userChoice ; } public String getImplementation ( ) { return userChoice != null ? userChoice : ( magicValue != null ? magicValue : defaultValue ) ; } public String getExplicitChoice ( ) { return userChoice ; } public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . addElement ( arg ) ; } public String [ ] getArgs ( ) { Vector tmp = new Vector ( args . size ( ) ) ; for ( Enumeration enum = args . elements ( ) ; enum . hasMoreElements ( ) ; ) { ImplementationSpecificArgument arg = ( ( ImplementationSpecificArgument ) enum . nextElement ( ) ) ; String [ ] curr = arg . getParts ( getImplementation ( ) ) ; for ( int i = 0 ; i < curr . length ; i ++ ) { tmp . addElement ( curr [ i ] ) ; } } String [ ] res = new String [ tmp . size ( ) ] ; tmp . copyInto ( res ) ; return res ; } } 	0	['8', '1', '0', '3', '18', '10', '2', '1', '8', '0.535714286', '108', '1', '0', '0', '0.541666667', '0', '0', '12', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import java . io . File ; public class Mkdir extends Task { private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , location ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file " + "already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = dir . mkdirs ( ) ; if ( ! result ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not successful for an unknown reason" ; throw new BuildException ( msg , location ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } } 	0	['3', '3', '0', '3', '14', '1', '0', '3', '3', '0.5', '82', '1', '0', '0.948717949', '0.666666667', '1', '1', '26', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Reference ; public class SelectSelector extends AndSelector { public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<select> tag" ) ; } } } 	0	['9', '6', '0', '10', '24', '36', '4', '7', '8', '2', '104', '0', '0', '0.888888889', '0.407407407', '3', '8', '10.55555556', '2', '1.6667', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '19', '3', '3', '19', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private File directory ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void setDir ( File directory ) throws BuildException { this . directory = directory ; } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; if ( directory != null ) { if ( directory . exists ( ) && directory . isDirectory ( ) ) { exe . setWorkingDirectory ( directory ) ; } else if ( ! directory . isDirectory ( ) ) { throw new BuildException ( directory + " is not a directory." , location ) ; } else { throw new BuildException ( "directory " + directory + " doesn\'t exist" , location ) ; } } else { exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['10', '3', '0', '11', '36', '0', '0', '11', '10', '0.694444444', '236', '1', '1', '0.804347826', '0.45', '1', '1', '22.2', '2', '1.4', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { String value ; if ( property == null ) { throw new BuildException ( "property attribute required" , location ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , location ) ; } else { value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . indexOf ( '.' ) ; value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['5', '3', '0', '5', '13', '4', '0', '5', '5', '0.75', '71', '1', '0', '0.902439024', '0.533333333', '0', '0', '12.6', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private static final int SLEEP = 5 ; private static final int SIZE = 128 ; private InputStream is ; private OutputStream os ; private boolean finished ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { synchronized ( this ) { finished = false ; } final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } finally { synchronized ( this ) { finished = true ; notify ( ) ; } } } public synchronized boolean isFinished ( ) { return finished ; } public synchronized void waitFor ( ) throws InterruptedException { while ( ! isFinished ( ) ) { wait ( ) ; } } } 	0	['4', '1', '0', '1', '10', '2', '1', '0', '4', '0.866666667', '93', '1', '0', '0', '0.5', '0', '0', '21', '5', '1.75', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private static final RegexpFactory factory = new RegexpFactory ( ) ; private Regexp regexp ; public RegularExpression ( ) { this . regexp = factory . newRegexp ( ) ; } public void setPattern ( String pattern ) { this . regexp . setPattern ( pattern ) ; } public String getPattern ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } return this . regexp ; } public RegularExpression getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof RegularExpression ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + DATA_TYPE_NAME ; throw new BuildException ( msg ) ; } else { return ( RegularExpression ) o ; } } } 	0	['6', '3', '0', '8', '21', '1', '1', '7', '5', '0.8', '95', '0.666666667', '2', '0.882352941', '0.6', '0', '0', '14.33333333', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { ZipShort getHeaderId ( ) ; ZipShort getLocalFileDataLength ( ) ; ZipShort getCentralDirectoryLength ( ) ; byte [ ] getLocalFileDataData ( ) ; byte [ ] getCentralDirectoryData ( ) ; void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0	['3', '3', '2', '6', '6', '1', '5', '1', '3', '0.5', '25', '1', '0', '0.882352941', '0.833333333', '1', '1', '7', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NoneSelector extends BaseSelectorContainer { public NoneSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{noneselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import java . io . File ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( replace && dest . exists ( ) ) { if ( ! dest . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + dest ) ; } } if ( ! src . renameTo ( dest ) ) { throw new BuildException ( "Unable to rename " + src + " to " + dest ) ; } } } 	0	['5', '3', '0', '4', '17', '0', '0', '4', '5', '0.666666667', '99', '1', '0', '0.902439024', '0.533333333', '1', '1', '18.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( bw != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '282', '1', '0', '0.840909091', '0.325', '1', '1', '33.75', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . io . IOException ; public class FilesMatch implements Condition { private File file1 , file2 ; private FileUtils fu = FileUtils . newFileUtils ( ) ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = fu . contentEquals ( file1 , file2 ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0	['4', '1', '0', '4', '13', '0', '1', '3', '4', '0.666666667', '60', '1', '1', '0', '0.75', '0', '0', '13.25', '1', '0.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public final Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . types . selectors . SelectorScanner ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . SelectorUtils ; import org . apache . tools . ant . util . FileUtils ; public class DirectoryScanner implements FileScanner , SelectorScanner { protected static final String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/.#*" , "**/%*%" , "**/._*" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" , "**/SCCS" , "**/SCCS/**" , "**/vssver.scc" , "**/.svn" , "**/.svn/**" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected FileSelector [ ] selectors = null ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected Vector filesDeselected ; protected Vector dirsDeselected ; protected boolean haveSlowResults = false ; protected boolean isCaseSensitive = true ; private boolean followSymlinks = true ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; protected boolean everythingIncluded = true ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { return SelectorUtils . matchPatternStart ( pattern , str ) ; } protected static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPatternStart ( pattern , str , isCaseSensitive ) ; } protected static boolean matchPath ( String pattern , String str ) { return SelectorUtils . matchPath ( pattern , str ) ; } protected static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . matchPath ( pattern , str , isCaseSensitive ) ; } public static boolean match ( String pattern , String str ) { return SelectorUtils . match ( pattern , str ) ; } protected static boolean match ( String pattern , String str , boolean isCaseSensitive ) { return SelectorUtils . match ( pattern , str , isCaseSensitive ) ; } private static Vector tokenizePath ( String path ) { return SelectorUtils . tokenizePath ( path ) ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void setSelectors ( FileSelector [ ] selectors ) { this . selectors = selectors ; } public boolean isEverythingIncluded ( ) { return everythingIncluded ; } public void scan ( ) throws IllegalStateException { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir " + basedir + " is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; filesDeselected = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; dirsDeselected = new Vector ( ) ; if ( isIncluded ( "" ) ) { if ( ! isExcluded ( "" ) ) { if ( isSelected ( "" , basedir ) ) { dirsIncluded . addElement ( "" ) ; } else { dirsDeselected . addElement ( "" ) ; } } else { dirsExcluded . addElement ( "" ) ; } } else { dirsNotIncluded . addElement ( "" ) ; } scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { if ( ! couldHoldIncluded ( excl [ i ] ) ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } if ( ! followSymlinks ) { Vector noLinks = new Vector ( ) ; for ( int i = 0 ; i < newfiles . length ; i ++ ) { try { if ( fileUtils . isSymbolicLink ( dir , newfiles [ i ] ) ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { dirsExcluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { noLinks . addElement ( newfiles [ i ] ) ; } } catch ( IOException ioe ) { String msg = "IOException caught while checking " + "for links, couldn't get cannonical path!" ; System . err . println ( msg ) ; noLinks . addElement ( newfiles [ i ] ) ; } } newfiles = new String [ noLinks . size ( ) ] ; noLinks . copyInto ( newfiles ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { everythingIncluded = false ; dirsDeselected . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { everythingIncluded = false ; dirsExcluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } } else { everythingIncluded = false ; dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { if ( isSelected ( name , file ) ) { filesIncluded . addElement ( name ) ; } else { everythingIncluded = false ; filesDeselected . addElement ( name ) ; } } else { everythingIncluded = false ; filesExcluded . addElement ( name ) ; } } else { everythingIncluded = false ; filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name , isCaseSensitive ) ) { return true ; } } return false ; } protected boolean isSelected ( String name , File file ) { if ( selectors != null ) { for ( int i = 0 ; i < selectors . length ; i ++ ) { if ( ( selectors [ i ] . isSelected ( basedir , name , file ) ) == false ) { return false ; } } } return true ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getDeselectedFiles ( ) { slowScan ( ) ; int count = filesDeselected . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesDeselected . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public String [ ] getDeselectedDirectories ( ) { slowScan ( ) ; int count = dirsDeselected . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsDeselected . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['34', '1', '1', '33', '67', '437', '27', '6', '21', '0.752525253', '1171', '1', '2', '0', '0.257575758', '0', '0', '32.91176471', '23', '2.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . BuildException ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '13', '25', '0', '4', '9', '7', '0.458333333', '199', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.85714286', '5', '2.5714', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '6', '13', '0', '5', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . types . Commandline ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both " + "as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both " + "as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "keytool" ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '8', '33', '65', '0', '8', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '1', '2', '27', '2', '1', '0']
package org . apache . tools . ant . input ; import org . apache . tools . ant . BuildException ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '3', '19', '0', '0', '3', '2', '0.75', '104', '0.5', '0', '0', '0.666666667', '0', '0', '33', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '5', '14', '3', '4', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . filters . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . util . FileUtils ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . io . FilterReader ; import java . io . Reader ; import java . io . IOException ; import java . util . Vector ; public final class ChainReaderHelper { public Reader primaryReader ; public int bufferSize = 8192 ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public final void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public final void setProject ( final Project project ) { this . project = project ; } public final Project getProject ( ) { return project ; } public final void setBufferSize ( int size ) { bufferSize = size ; } public final void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public final Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project project = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = new AntClassLoader ( project , classpath ) ; clazz = al . loadClass ( className ) ; AntClassLoader . initializeClass ( clazz ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { break ; } } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( rdr ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader && o instanceof Reader ) { if ( project != null && o instanceof BaseFilterReader ) { ( ( BaseFilterReader ) o ) . setProject ( project ) ; } instream = ( ( ChainableReader ) o ) . chain ( instream ) ; } } } return instream ; } public final String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	0	['9', '1', '0', '14', '38', '12', '3', '12', '8', '0.857142857', '310', '0.142857143', '1', '0', '0.259259259', '0', '0', '32.66666667', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . InputStreamReader ; import java . io . IOException ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; public class Checksum extends MatchingTask implements Condition { private File file = null ; private String algorithm = "MD5" ; private String provider = null ; private String fileext ; private String property ; private boolean forceOverwrite ; private String verifyProperty ; private Vector filesets = new Vector ( ) ; private Hashtable includeFileMap = new Hashtable ( ) ; private MessageDigest messageDigest ; private boolean isCondition ; private int readBufferSize = 8 * 1024 ; public void setFile ( File file ) { this . file = file ; } public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void setFileext ( String fileext ) { this . fileext = fileext ; } public void setProperty ( String property ) { this . property = property ; } public void setVerifyproperty ( String verifyProperty ) { this . verifyProperty = verifyProperty ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void setReadBufferSize ( int size ) { this . readBufferSize = size ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { isCondition = false ; boolean value = validateAndExecute ( ) ; if ( verifyProperty != null ) { project . setNewProperty ( verifyProperty , new Boolean ( value ) . toString ( ) ) ; } } public boolean eval ( ) throws BuildException { isCondition = true ; return validateAndExecute ( ) ; } private boolean validateAndExecute ( ) throws BuildException { String savedFileExt = fileext ; if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Checksum cannot be generated for directories" ) ; } if ( property != null && fileext != null ) { throw new BuildException ( "Property and FileExt cannot co-exist." ) ; } if ( property != null ) { if ( forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when Property is specified" ) ; } if ( file != null ) { if ( filesets . size ( ) > 0 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } else { if ( filesets . size ( ) > 1 ) { throw new BuildException ( "Multiple files cannot be used " + "when Property is specified" ) ; } } } if ( verifyProperty != null ) { isCondition = true ; } if ( verifyProperty != null && forceOverwrite ) { throw new BuildException ( "VerifyProperty and ForceOverwrite cannot co-exist." ) ; } if ( isCondition && forceOverwrite ) { throw new BuildException ( "ForceOverwrite cannot be used when " + "conditions are being used." ) ; } messageDigest = null ; if ( provider != null ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , location ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider , location ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo , location ) ; } } if ( messageDigest == null ) { throw new BuildException ( "Unable to create Message Digest" , location ) ; } if ( fileext == null ) { fileext = "." + algorithm ; } else if ( fileext . trim ( ) . length ( ) == 0 ) { throw new BuildException ( "File extension when specified must not be an empty string" ) ; } try { addToIncludeFileMap ( file ) ; int sizeofFileSet = filesets . size ( ) ; for ( int i = 0 ; i < sizeofFileSet ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File src = new File ( fs . getDir ( project ) , srcFiles [ j ] ) ; addToIncludeFileMap ( src ) ; } } return generateChecksums ( ) ; } finally { fileext = savedFileExt ; includeFileMap . clear ( ) ; } } private void addToIncludeFileMap ( File file ) throws BuildException { if ( file != null ) { if ( file . exists ( ) ) { if ( property == null ) { File dest = new File ( file . getParent ( ) , file . getName ( ) + fileext ) ; if ( forceOverwrite || isCondition || ( file . lastModified ( ) > dest . lastModified ( ) ) ) { includeFileMap . put ( file , dest ) ; } else { log ( file + " omitted as " + dest + " is up to date." , Project . MSG_VERBOSE ) ; } } else { includeFileMap . put ( file , property ) ; } } else { String message = "Could not find file " + file . getAbsolutePath ( ) + " to generate checksum for." ; log ( message ) ; throw new BuildException ( message , location ) ; } } } private boolean generateChecksums ( ) throws BuildException { boolean checksumMatches = true ; FileInputStream fis = null ; FileOutputStream fos = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { for ( Enumeration e = includeFileMap . keys ( ) ; e . hasMoreElements ( ) ; ) { messageDigest . reset ( ) ; File src = ( File ) e . nextElement ( ) ; if ( ! isCondition ) { log ( "Calculating " + algorithm + " checksum for " + src ) ; } fis = new FileInputStream ( src ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { ; } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } String checksum = checksumSb . toString ( ) ; Object destination = includeFileMap . get ( src ) ; if ( destination instanceof java . lang . String ) { String prop = ( String ) destination ; if ( isCondition ) { checksumMatches = checksum . equals ( property ) ; } else { project . setNewProperty ( prop , checksum ) ; } } else if ( destination instanceof java . io . File ) { if ( isCondition ) { File existingFile = ( File ) destination ; if ( existingFile . exists ( ) ) { fis = new FileInputStream ( existingFile ) ; InputStreamReader isr = new InputStreamReader ( fis ) ; BufferedReader br = new BufferedReader ( isr ) ; String suppliedChecksum = br . readLine ( ) ; fis . close ( ) ; fis = null ; br . close ( ) ; isr . close ( ) ; checksumMatches = checksum . equals ( suppliedChecksum ) ; } else { checksumMatches = false ; } } else { File dest = ( File ) destination ; fos = new FileOutputStream ( dest ) ; fos . write ( checksum . getBytes ( ) ) ; fos . close ( ) ; fos = null ; } } } } catch ( Exception e ) { throw new BuildException ( e , location ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException e ) { } } } return checksumMatches ; } } 	0	['15', '4', '0', '11', '72', '39', '1', '10', '12', '0.714285714', '683', '1', '0', '0.847826087', '0.277777778', '0', '0', '43.73333333', '1', '0.9333', '0']
package org . apache . tools . ant ; import java . util . Enumeration ; import java . util . Vector ; import java . util . StringTokenizer ; public class Target implements TaskContainer { private String name ; private String ifCondition = "" ; private String unlessCondition = "" ; private Vector dependencies = new Vector ( 2 ) ; private Vector children = new Vector ( 5 ) ; private Project project ; private String description = null ; public Target ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setDepends ( String depS ) { if ( depS . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( depS , "," , true ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; if ( token . equals ( "" ) || token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" has an empty string for dependency." ) ; } addDependency ( token ) ; if ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( ! tok . hasMoreTokens ( ) || ! token . equals ( "," ) ) { throw new BuildException ( "Syntax Error: Depend " + "attribute for target \"" + getName ( ) + "\" ends with a , character" ) ; } } } } } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void addTask ( Task task ) { children . addElement ( task ) ; } public void addDataType ( RuntimeConfigurable r ) { children . addElement ( r ) ; } public Task [ ] getTasks ( ) { Vector tasks = new Vector ( children . size ( ) ) ; Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { tasks . addElement ( o ) ; } } Task [ ] retval = new Task [ tasks . size ( ) ] ; tasks . copyInto ( retval ) ; return retval ; } public void addDependency ( String dependency ) { dependencies . addElement ( dependency ) ; } public Enumeration getDependencies ( ) { return dependencies . elements ( ) ; } public void setIf ( String property ) { this . ifCondition = ( property == null ) ? "" : property ; } public void setUnless ( String property ) { this . unlessCondition = ( property == null ) ? "" : property ; } public void setDescription ( String description ) { this . description = description ; } public String getDescription ( ) { return description ; } public String toString ( ) { return name ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { Enumeration enum = children . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Task ) { Task task = ( Task ) o ; task . perform ( ) ; } else { RuntimeConfigurable r = ( RuntimeConfigurable ) o ; r . maybeConfigure ( project ) ; } } } else if ( ! testIfCondition ( ) ) { project . log ( this , "Skipped because property '" + this . ifCondition + "' not set." , Project . MSG_VERBOSE ) ; } else { project . log ( this , "Skipped because property '" + this . unlessCondition + "' set." , Project . MSG_VERBOSE ) ; } } public final void performTasks ( ) { try { project . fireTargetStarted ( this ) ; execute ( ) ; project . fireTargetFinished ( this , null ) ; } catch ( RuntimeException exc ) { project . fireTargetFinished ( this , exc ) ; throw exc ; } } void replaceChild ( Task el , RuntimeConfigurable o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . setElementAt ( o , index ) ; } } void replaceChild ( Task el , Task o ) { int index ; while ( ( index = children . indexOf ( el ) ) >= 0 ) { children . setElementAt ( o , index ) ; } } private boolean testIfCondition ( ) { if ( "" . equals ( ifCondition ) ) { return true ; } String test = project . replaceProperties ( ifCondition ) ; return project . getProperty ( test ) != null ; } private boolean testUnlessCondition ( ) { if ( "" . equals ( unlessCondition ) ) { return true ; } String test = project . replaceProperties ( unlessCondition ) ; return project . getProperty ( test ) == null ; } } 	0	['22', '1', '0', '19', '49', '125', '16', '5', '18', '0.80952381', '382', '1', '1', '0', '0.309090909', '0', '0', '16.04545455', '8', '1.7273', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ClassConstants ; import org . apache . tools . ant . filters . ExpandProperties ; import org . apache . tools . ant . filters . HeadFilter ; import org . apache . tools . ant . filters . LineContains ; import org . apache . tools . ant . filters . LineContainsRegExp ; import org . apache . tools . ant . filters . PrefixLines ; import org . apache . tools . ant . filters . ReplaceTokens ; import org . apache . tools . ant . filters . StripJavaComments ; import org . apache . tools . ant . filters . StripLineBreaks ; import org . apache . tools . ant . filters . StripLineComments ; import org . apache . tools . ant . filters . TabsToSpaces ; import org . apache . tools . ant . filters . TailFilter ; public final class FilterChain extends DataType implements Cloneable { private Vector filterReaders = new Vector ( ) ; public final void addFilterReader ( final AntFilterReader filterReader ) { filterReaders . addElement ( filterReader ) ; } public final Vector getFilterReaders ( ) { return filterReaders ; } public final void addClassConstants ( final ClassConstants classConstants ) { filterReaders . addElement ( classConstants ) ; } public final void addExpandProperties ( final ExpandProperties expandProperties ) { filterReaders . addElement ( expandProperties ) ; } public final void addHeadFilter ( final HeadFilter headFilter ) { filterReaders . addElement ( headFilter ) ; } public final void addLineContains ( final LineContains lineContains ) { filterReaders . addElement ( lineContains ) ; } public final void addLineContainsRegExp ( final LineContainsRegExp lineContainsRegExp ) { filterReaders . addElement ( lineContainsRegExp ) ; } public final void addPrefixLines ( final PrefixLines prefixLines ) { filterReaders . addElement ( prefixLines ) ; } public final void addReplaceTokens ( final ReplaceTokens replaceTokens ) { filterReaders . addElement ( replaceTokens ) ; } public final void addStripJavaComments ( final StripJavaComments stripJavaComments ) { filterReaders . addElement ( stripJavaComments ) ; } public final void addStripLineBreaks ( final StripLineBreaks stripLineBreaks ) { filterReaders . addElement ( stripLineBreaks ) ; } public final void addStripLineComments ( final StripLineComments stripLineComments ) { filterReaders . addElement ( stripLineComments ) ; } public final void addTabsToSpaces ( final TabsToSpaces tabsToSpaces ) { filterReaders . addElement ( tabsToSpaces ) ; } public final void addTailFilter ( final TailFilter tailFilter ) { filterReaders . addElement ( tailFilter ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! filterReaders . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof FilterChain ) { FilterChain fc = ( FilterChain ) o ; filterReaders = fc . getFilterReaders ( ) ; } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterChain" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['16', '3', '0', '22', '29', '0', '4', '18', '16', '0', '135', '1', '0', '0.666666667', '0.125', '1', '1', '7.375', '1', '0.9375', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '4', '5', '6', '3', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . taskdefs . condition . Os ; public class DateSelector extends BaseExtendSelector { private long millis = - 1 ; private String dateTime = null ; private boolean includeDirs = false ; private int granularity = 0 ; private int cmp = 2 ; public final static String MILLIS_KEY = "millis" ; public final static String DATETIME_KEY = "datetime" ; public final static String CHECKDIRS_KEY = "checkdirs" ; public final static String GRANULARITY_KEY = "granularity" ; public final static String WHEN_KEY = "when" ; public DateSelector ( ) { if ( Os . isFamily ( "dos" ) ) { granularity = 2000 ; } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dateselector date: " ) ; buf . append ( dateTime ) ; buf . append ( " compare: " ) ; if ( cmp == 0 ) { buf . append ( "before" ) ; } else if ( cmp == 1 ) { buf . append ( "after" ) ; } else { buf . append ( "equal" ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMillis ( long millis ) { this . millis = millis ; } public long getMillis ( ) { return millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value relative" + " to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { setError ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + " MM/DD/YYYY HH:MM AM_PM format." ) ; } } } public void setCheckdirs ( boolean includeDirs ) { this . includeDirs = includeDirs ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public void setWhen ( TimeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MILLIS_KEY . equalsIgnoreCase ( paramname ) ) { try { setMillis ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid millisecond setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( DATETIME_KEY . equalsIgnoreCase ( paramname ) ) { setDatetime ( parameters [ i ] . getValue ( ) ) ; } else if ( CHECKDIRS_KEY . equalsIgnoreCase ( paramname ) ) { setCheckdirs ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( GRANULARITY_KEY . equalsIgnoreCase ( paramname ) ) { try { setGranularity ( new Integer ( parameters [ i ] . getValue ( ) ) . intValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid granularity setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { TimeComparisons cmp = new TimeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( dateTime == null && millis < 0 ) { setError ( "You must provide a datetime or the number of " + "milliseconds." ) ; } else if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds" + " value relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) && ( includeDirs == false ) ) { return true ; } if ( cmp == 0 ) { return ( ( file . lastModified ( ) - granularity ) < millis ) ; } else if ( cmp == 1 ) { return ( ( file . lastModified ( ) + granularity ) > millis ) ; } else { return ( Math . abs ( file . lastModified ( ) - millis ) <= granularity ) ; } } public static class TimeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "before" , "after" , "equal" } ; } } } 	0	['11', '5', '0', '11', '38', '1', '4', '7', '11', '0.84', '391', '0.5', '0', '0.791666667', '0.215909091', '1', '4', '33.63636364', '8', '2.7273', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . InputStream ; import java . io . StringReader ; public class StringInputStream extends InputStream { private StringReader in ; public StringInputStream ( String source ) { in = new StringReader ( source ) ; } public int read ( ) throws IOException { return in . read ( ) ; } public void close ( ) throws IOException { in . close ( ) ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized void reset ( ) throws IOException { in . reset ( ) ; } public boolean markSupported ( ) { return in . markSupported ( ) ; } } 	0	['6', '2', '0', '1', '15', '0', '1', '0', '6', '0', '45', '1', '0', '0.642857143', '0.444444444', '1', '1', '6.333333333', '1', '0.8333', '0']
package org . apache . tools . ant ; public abstract class Task extends ProjectComponent { protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; private boolean invalid = false ; public Task ( ) { } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } public void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( ! invalid ) { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } else { getReplacement ( ) ; } } protected void handleOutput ( String line ) { log ( line , Project . MSG_INFO ) ; } protected void handleErrorOutput ( String line ) { log ( line , Project . MSG_ERR ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public final void perform ( ) { if ( ! invalid ) { try { project . fireTaskStarted ( this ) ; maybeConfigure ( ) ; execute ( ) ; project . fireTaskFinished ( this , null ) ; } catch ( RuntimeException exc ) { if ( exc instanceof BuildException ) { BuildException be = ( BuildException ) exc ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( getLocation ( ) ) ; } } project . fireTaskFinished ( this , exc ) ; throw exc ; } } else { UnknownElement ue = getReplacement ( ) ; Task task = ue . getTask ( ) ; task . perform ( ) ; } } final void markInvalid ( ) { invalid = true ; } protected final boolean isInvalid ( ) { return invalid ; } private UnknownElement replacement ; private UnknownElement getReplacement ( ) { if ( replacement == null ) { replacement = new UnknownElement ( taskType ) ; replacement . setProject ( project ) ; replacement . setTaskType ( taskType ) ; replacement . setTaskName ( taskName ) ; replacement . setLocation ( location ) ; replacement . setOwningTarget ( target ) ; replacement . setRuntimeConfigurableWrapper ( wrapper ) ; wrapper . setProxy ( replacement ) ; target . replaceChild ( this , replacement ) ; replacement . maybeConfigure ( ) ; } return replacement ; } } 	0	['23', '2', '52', '117', '37', '179', '114', '7', '17', '0.818181818', '255', '1', '4', '0.290322581', '0.246376812', '1', '3', '9.739130435', '4', '1.1739', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Commandline ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jikes" ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; cmd . createArgument ( ) . setValue ( attributes . getSource ( ) ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '26', '1', '1', '8', '2', '2', '248', '0', '0', '0.958333333', '1', '1', '1', '123', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private File m_file ; public void setFile ( final File file ) { m_file = file ; } public void execute ( ) throws BuildException { File savedFile = m_file ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( m_file ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . save ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + m_file ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { } } m_file = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = m_file + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( m_file ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { } } } } private void validate ( ) throws BuildException { if ( null == m_file ) { m_file = getProject ( ) . resolveFile ( DEFAULT_FILENAME ) ; } if ( ! m_file . exists ( ) ) { try { FileUtils . newFileUtils ( ) . createNewFile ( m_file ) ; } catch ( final IOException ioe ) { final String message = m_file + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! m_file . canRead ( ) ) { final String message = "Unable to read from " + m_file + "." ; throw new BuildException ( message ) ; } if ( ! m_file . canWrite ( ) ) { final String message = "Unable to write to " + m_file + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '3', '0', '5', '34', '0', '0', '5', '3', '0.866666667', '237', '1', '0', '0.880952381', '0.444444444', '0', '0', '38', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . Method ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; try { Class c = Class . forName ( "at.dms.kjc.Main" ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use kjc compiler, as it is not " + "available. A common solution is to " + "set the environment variable CLASSPATH " + "to your kjc archive (kjc.jar)." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting kjc compiler: " , ex , location ) ; } } } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; if ( compileSourcepath != null ) { cp . append ( compileSourcepath ) ; } else { cp . append ( src ) ; } cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['4', '2', '0', '10', '26', '6', '1', '9', '2', '1', '195', '0', '0', '0.884615385', '0.5', '0', '0', '47.5', '10', '3', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . InputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_NORMAL = 0 ; private static final int ATTR_BRIGHT = 1 ; private static final int ATTR_DIM = 2 ; private static final int ATTR_UNDERLINE = 3 ; private static final int ATTR_BLINK = 5 ; private static final int ATTR_REVERSE = 7 ; private static final int ATTR_HIDDEN = 8 ; private static final int FG_BLACK = 30 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_YELLOW = 33 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final int FG_WHITE = 37 ; private static final int BG_BLACK = 40 ; private static final int BG_RED = 41 ; private static final int BG_GREEN = 42 ; private static final int BG_YELLOW = 44 ; private static final int BG_BLUE = 44 ; private static final int BG_MAGENTA = 45 ; private static final int BG_CYAN = 46 ; private static final int BG_WHITE = 47 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private final void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String err = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( err != null ) { errColor = PREFIX + err + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected final void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0	['3', '2', '0', '1', '18', '0', '0', '1', '1', '1.242424242', '274', '1', '0', '0.888888889', '0.5', '1', '3', '79.33333333', '12', '5.6667', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . FileInputStream ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . BuildException ; public class ContainsSelector extends BaseExtendSelector { private String contains = null ; private boolean casesensitive = true ; public final static String CONTAINS_KEY = "text" ; public final static String CASE_KEY = "casesensitive" ; public ContainsSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsselector text: " ) ; buf . append ( contains ) ; buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setText ( String contains ) { this . contains = contains ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( CONTAINS_KEY . equalsIgnoreCase ( paramname ) ) { setText ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( contains == null ) { setError ( "The text attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } String userstr = contains ; if ( ! casesensitive ) { userstr = contains . toLowerCase ( ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! casesensitive ) { teststr = teststr . toLowerCase ( ) ; } if ( teststr . indexOf ( userstr ) > - 1 ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read file " + filename ) ; } finally { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close file " + filename ) ; } } } } 	0	['7', '5', '0', '9', '28', '0', '4', '5', '7', '0.708333333', '215', '0.5', '0', '0.863636364', '0.342857143', '1', '4', '29.14285714', '9', '2.8571', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . io . File ; import java . util . Random ; import java . util . Vector ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random rand = new Random ( ) ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; if ( attributes . getClasspath ( ) == null ) { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( Path . systemClasspath ) ; } } else { if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( attributes . getClasspath ( ) . concatSystemClasspath ( "ignore" ) ) ; } } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { classpath . addExtdirs ( attributes . getExtdirs ( ) ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.1" ) ; } else if ( "1.2" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.2" ) ; } else { cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['16', '1', '3', '15', '56', '86', '4', '12', '6', '0.8', '375', '1', '2', '0', '0.226666667', '0', '0', '22.25', '14', '2.0625', '0']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public final void setName ( final String name ) { this . name = name ; } public final void setType ( final String type ) { this . type = type ; } public final void setValue ( final String value ) { this . value = value ; } public final String getName ( ) { return name ; } public final String getType ( ) { return type ; } public final String getValue ( ) { return value ; } } 	0	['7', '1', '0', '20', '8', '3', '20', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . DynamicConfigurator ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . lang . reflect . Method ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Constructor ; import java . io . File ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; public class IntrospectionHelper implements BuildListener { private Hashtable attributeTypes ; private Hashtable attributeSetters ; private Hashtable nestedTypes ; private Hashtable nestedCreators ; private Hashtable nestedStorers ; private Method addText = null ; private Class bean ; private static Hashtable helpers = new Hashtable ( ) ; private static final Hashtable PRIMITIVE_TYPE_MAP = new Hashtable ( 8 ) ; static { Class [ ] primitives = { Boolean . TYPE , Byte . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE } ; Class [ ] wrappers = { Boolean . class , Byte . class , Character . class , Short . class , Integer . class , Long . class , Float . class , Double . class } ; for ( int i = 0 ; i < primitives . length ; i ++ ) { PRIMITIVE_TYPE_MAP . put ( primitives [ i ] , wrappers [ i ] ) ; } } private IntrospectionHelper ( final Class bean ) { attributeTypes = new Hashtable ( ) ; attributeSetters = new Hashtable ( ) ; nestedTypes = new Hashtable ( ) ; nestedCreators = new Hashtable ( ) ; nestedStorers = new Hashtable ( ) ; this . bean = bean ; Method [ ] methods = bean . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method m = methods [ i ] ; final String name = m . getName ( ) ; Class returnType = m . getReturnType ( ) ; Class [ ] args = m . getParameterTypes ( ) ; if ( org . apache . tools . ant . Task . class . isAssignableFrom ( bean ) && args . length == 1 && isHiddenSetMethod ( name , args [ 0 ] ) ) { continue ; } if ( org . apache . tools . ant . TaskContainer . class . isAssignableFrom ( bean ) && args . length == 1 && "addTask" . equals ( name ) && org . apache . tools . ant . Task . class . equals ( args [ 0 ] ) ) { continue ; } if ( "addText" . equals ( name ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && java . lang . String . class . equals ( args [ 0 ] ) ) { addText = methods [ i ] ; } else if ( name . startsWith ( "set" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! args [ 0 ] . isArray ( ) ) { String propName = getPropertyName ( name , "set" ) ; if ( attributeSetters . get ( propName ) != null ) { if ( java . lang . String . class . equals ( args [ 0 ] ) ) { continue ; } } AttributeSetter as = createAttributeSetter ( m , args [ 0 ] ) ; if ( as != null ) { attributeTypes . put ( propName , args [ 0 ] ) ; attributeSetters . put ( propName , as ) ; } } else if ( name . startsWith ( "create" ) && ! returnType . isArray ( ) && ! returnType . isPrimitive ( ) && args . length == 0 ) { String propName = getPropertyName ( name , "create" ) ; nestedTypes . put ( propName , returnType ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException { return m . invoke ( parent , new Object [ ] { } ) ; } } ) ; nestedStorers . remove ( propName ) ; } else if ( name . startsWith ( "addConfigured" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "addConfigured" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; return o ; } } ) ; nestedStorers . put ( propName , new NestedStorer ( ) { public void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException { m . invoke ( parent , new Object [ ] { child } ) ; } } ) ; } catch ( NoSuchMethodException nse ) { } } else if ( name . startsWith ( "add" ) && java . lang . Void . TYPE . equals ( returnType ) && args . length == 1 && ! java . lang . String . class . equals ( args [ 0 ] ) && ! args [ 0 ] . isArray ( ) && ! args [ 0 ] . isPrimitive ( ) ) { try { final Constructor c = args [ 0 ] . getConstructor ( new Class [ ] { } ) ; String propName = getPropertyName ( name , "add" ) ; nestedTypes . put ( propName , args [ 0 ] ) ; nestedCreators . put ( propName , new NestedCreator ( ) { public Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException { Object o = c . newInstance ( new Object [ ] { } ) ; m . invoke ( parent , new Object [ ] { o } ) ; return o ; } } ) ; nestedStorers . remove ( name ) ; } catch ( NoSuchMethodException nse ) { } } } } private boolean isHiddenSetMethod ( String name , Class type ) { if ( "setLocation" . equals ( name ) && org . apache . tools . ant . Location . class . equals ( type ) ) { return true ; } if ( "setTaskType" . equals ( name ) && java . lang . String . class . equals ( type ) ) { return true ; } return false ; } public static synchronized IntrospectionHelper getHelper ( Class c ) { IntrospectionHelper ih = ( IntrospectionHelper ) helpers . get ( c ) ; if ( ih == null ) { ih = new IntrospectionHelper ( c ) ; helpers . put ( c , ih ) ; } return ih ; } public void setAttribute ( Project p , Object element , String attributeName , String value ) throws BuildException { AttributeSetter as = ( AttributeSetter ) attributeSetters . get ( attributeName ) ; if ( as == null ) { if ( element instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) element ; dc . setDynamicAttribute ( attributeName , value ) ; return ; } else { String msg = getElementName ( p , element ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } } try { as . set ( p , element , value ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void addText ( Project project , Object element , String text ) throws BuildException { if ( addText == null ) { if ( text . trim ( ) . length ( ) == 0 ) { return ; } else { String msg = project . getElementName ( element ) + " doesn't support nested text data." ; throw new BuildException ( msg ) ; } } try { addText . invoke ( element , new String [ ] { text } ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Object createElement ( Project project , Object parent , String elementName ) throws BuildException { NestedCreator nc = ( NestedCreator ) nestedCreators . get ( elementName ) ; if ( nc == null && parent instanceof DynamicConfigurator ) { DynamicConfigurator dc = ( DynamicConfigurator ) parent ; Object nestedElement = dc . createDynamicElement ( elementName ) ; if ( nestedElement != null ) { if ( nestedElement instanceof ProjectComponent ) { ( ( ProjectComponent ) nestedElement ) . setProject ( project ) ; } return nestedElement ; } } if ( nc == null ) { String msg = project . getElementName ( parent ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } try { Object nestedElement = nc . create ( parent ) ; if ( nestedElement instanceof ProjectComponent ) { ( ( ProjectComponent ) nestedElement ) . setProject ( project ) ; } return nestedElement ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public void storeElement ( Project project , Object parent , Object child , String elementName ) throws BuildException { if ( elementName == null ) { return ; } NestedStorer ns = ( NestedStorer ) nestedStorers . get ( elementName ) ; if ( ns == null ) { return ; } try { ns . store ( parent , child ) ; } catch ( IllegalAccessException ie ) { throw new BuildException ( ie ) ; } catch ( InstantiationException ine ) { throw new BuildException ( ine ) ; } catch ( InvocationTargetException ite ) { Throwable t = ite . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( t ) ; } } public Class getElementType ( String elementName ) throws BuildException { Class nt = ( Class ) nestedTypes . get ( elementName ) ; if ( nt == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the nested \"" + elementName + "\" element." ; throw new BuildException ( msg ) ; } return nt ; } public Class getAttributeType ( String attributeName ) throws BuildException { Class at = ( Class ) attributeTypes . get ( attributeName ) ; if ( at == null ) { String msg = "Class " + bean . getName ( ) + " doesn't support the \"" + attributeName + "\" attribute." ; throw new BuildException ( msg ) ; } return at ; } public boolean supportsCharacters ( ) { return addText != null ; } public Enumeration getAttributes ( ) { return attributeSetters . keys ( ) ; } public Enumeration getNestedElements ( ) { return nestedTypes . keys ( ) ; } private AttributeSetter createAttributeSetter ( final Method m , Class arg ) { final Class reflectedArg = PRIMITIVE_TYPE_MAP . containsKey ( arg ) ? ( Class ) PRIMITIVE_TYPE_MAP . get ( arg ) : arg ; if ( java . lang . String . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new String [ ] { value } ) ; } } ; } else if ( java . lang . Character . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Character [ ] { new Character ( value . charAt ( 0 ) ) } ) ; } } ; } else if ( java . lang . Boolean . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Boolean [ ] { new Boolean ( Project . toBoolean ( value ) ) } ) ; } } ; } else if ( java . lang . Class . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { m . invoke ( parent , new Class [ ] { Class . forName ( value ) } ) ; } catch ( ClassNotFoundException ce ) { throw new BuildException ( ce ) ; } } } ; } else if ( java . io . File . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new File [ ] { p . resolveFile ( value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . Path . class . equals ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException { m . invoke ( parent , new Path [ ] { new Path ( p , value ) } ) ; } } ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( reflectedArg ) ) { return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { org . apache . tools . ant . types . EnumeratedAttribute ea = ( org . apache . tools . ant . types . EnumeratedAttribute ) reflectedArg . newInstance ( ) ; ea . setValue ( value ) ; m . invoke ( parent , new EnumeratedAttribute [ ] { ea } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } else { try { final Constructor c = reflectedArg . getConstructor ( new Class [ ] { java . lang . String . class } ) ; return new AttributeSetter ( ) { public void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException { try { Object attribute = c . newInstance ( new String [ ] { value } ) ; if ( attribute instanceof ProjectComponent ) { ( ( ProjectComponent ) attribute ) . setProject ( p ) ; } m . invoke ( parent , new Object [ ] { attribute } ) ; } catch ( InstantiationException ie ) { throw new BuildException ( ie ) ; } } } ; } catch ( NoSuchMethodException nme ) { } } return null ; } protected String getElementName ( Project project , Object element ) { return project . getElementName ( element ) ; } private String getPropertyName ( String methodName , String prefix ) { int start = prefix . length ( ) ; return methodName . substring ( start ) . toLowerCase ( Locale . US ) ; } private interface NestedCreator { Object create ( Object parent ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface NestedStorer { void store ( Object parent , Object child ) throws InvocationTargetException , IllegalAccessException , InstantiationException ; } private interface AttributeSetter { void set ( Project p , Object parent , String value ) throws InvocationTargetException , IllegalAccessException , BuildException ; } public void buildFinished ( BuildEvent event ) { attributeTypes . clear ( ) ; attributeSetters . clear ( ) ; nestedTypes . clear ( ) ; nestedCreators . clear ( ) ; addText = null ; helpers . clear ( ) ; } public void buildStarted ( BuildEvent event ) { } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['24', '1', '0', '25', '78', '218', '16', '21', '17', '0.914782609', '1203', '0.36', '0', '0', '0.322981366', '0', '0', '48.08333333', '17', '1.9167', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . OutputStream ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is " + "not available.  A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '151', '0', '0', '0.92', '0.5', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; public class FileSet extends AbstractFileSet { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return new FileSet ( ( FileSet ) getRef ( getProject ( ) ) ) ; } else { return new FileSet ( this ) ; } } } 	0	['3', '4', '2', '30', '8', '3', '26', '4', '2', '2', '27', '0', '0', '0.988636364', '0.666666667', '3', '4', '8', '2', '0.6667', '0']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) ; } } 	0	['3', '2', '0', '3', '8', '0', '2', '1', '3', '0', '32', '1', '0', '0.75', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsFalse extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = new Boolean ( value ) ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for falsehood" ) ; } return ! value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '7', '0', '1', '3', '3', '0', '33', '1', '0', '0.818181818', '0.666666667', '0', '0', '9.666666667', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class MajoritySelector extends BaseSelectorContainer { private boolean allowtie = true ; public MajoritySelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{majorityselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void setAllowtie ( boolean tiebreaker ) { allowtie = tiebreaker ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int yesvotes = 0 ; int novotes = 0 ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { yesvotes = yesvotes + 1 ; } else { novotes = novotes + 1 ; } } if ( yesvotes > novotes ) { return true ; } else if ( novotes > yesvotes ) { return false ; } return allowtie ; } } 	0	['4', '5', '0', '5', '15', '0', '4', '2', '4', '0.333333333', '83', '1', '0', '0.953846154', '0.4375', '1', '1', '19.5', '5', '2', '0']
package org . apache . tools . ant ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . Hashtable ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean skip = false ; } private static final int MAX_SIZE = 1024 ; private Hashtable buffers = new Hashtable ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . skip = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . skip = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! bufferInfo . skip ) { processBuffer ( bufferInfo . buffer ) ; } } else { bufferInfo . buffer . write ( cc ) ; if ( bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } bufferInfo . skip = ( c == '\r' ) ; } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processBuffer ( bufferInfo . buffer ) ; } } } 	0	['8', '2', '0', '4', '25', '14', '1', '3', '4', '0.571428571', '163', '1', '1', '0.416666667', '0.3', '1', '1', '18.875', '2', '1', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpFactory extends RegexpMatcherFactory { public RegexpFactory ( ) { } public Regexp newRegexp ( ) throws BuildException { return ( Regexp ) newRegexp ( null ) ; } public Regexp newRegexp ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createRegexpInstance ( systemDefault ) ; } try { return createRegexpInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp" ) ; } catch ( BuildException be ) { } try { return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaOroRegexp" ) ; } catch ( BuildException be ) { } try { return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpRegexp" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected Regexp createRegexpInstance ( String classname ) throws BuildException { RegexpMatcher m = createInstance ( classname ) ; if ( m instanceof Regexp ) { return ( Regexp ) m ; } else { throw new BuildException ( classname + " doesn't implement the Regexp interface" ) ; } } } 	0	['4', '2', '0', '6', '12', '6', '1', '5', '3', '2', '71', '0', '0', '0.625', '0.5', '0', '0', '16.75', '1', '0.75', '0']
package org . apache . tools . zip ; public final class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	0	['7', '1', '0', '6', '8', '0', '6', '0', '7', '0', '89', '1', '0', '0', '0.428571429', '1', '1', '11.57142857', '4', '1', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '9', '7', '21', '8', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Pack extends Task { protected File zipFile ; protected File source ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setSrc ( File src ) { source = src ; } private void validate ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , location ) ; } if ( zipFile . isDirectory ( ) ) { throw new BuildException ( "zipfile attribute must not " + "represent a directory!" , location ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Src attribute must not " + "represent a directory!" , location ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( zipFile . lastModified ( ) < source . lastModified ( ) ) { log ( "Building: " + zipFile . getAbsolutePath ( ) ) ; pack ( ) ; } else { log ( "Nothing to do: " + zipFile . getAbsolutePath ( ) + " is up to date." ) ; } } private void zipFile ( InputStream in , OutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , OutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } protected abstract void pack ( ) ; } 	0	['8', '3', '2', '5', '21', '18', '2', '3', '4', '0.714285714', '145', '1', '0', '0.840909091', '0.4375', '1', '1', '16.875', '1', '0.875', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; import java . util . Properties ; import java . util . Stack ; public class Mapper extends DataType implements Cloneable { protected MapperType type = null ; public Mapper ( Project p ) { setProject ( p ) ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( getProject ( ) , classpath ) ; c = al . loadClass ( classname ) ; AntClassLoader . initializeClass ( c ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Mapper ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; implementations . put ( "package" , "org.apache.tools.ant.util.PackageNameMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" , "package" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['11', '3', '0', '14', '40', '17', '5', '9', '10', '0.7', '286', '1', '2', '0.75', '0.287878788', '1', '1', '24.54545455', '3', '1.9091', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Parameter ; public abstract class BaseExtendSelector extends BaseSelector implements ExtendFileSelector { protected Parameter [ ] parameters = null ; public BaseExtendSelector ( ) { } public void setParameters ( Parameter [ ] parameters ) { this . parameters = parameters ; } protected Parameter [ ] getParameters ( ) { return parameters ; } public abstract boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['4', '4', '5', '9', '5', '0', '5', '4', '3', '0.333333333', '18', '1', '1', '0.921052632', '0.4375', '0', '0', '3.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String m_userID ; private String m_displayName ; public void setDisplayname ( final String displayName ) { m_displayName = displayName ; } public void setUserid ( final String userID ) { m_userID = userID ; } String getUserID ( ) { return m_userID ; } String getDisplayname ( ) { return m_displayName ; } void validate ( ) throws BuildException { if ( null == m_userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == m_displayName ) { final String message = "Displayname attribute must be set for userID " + m_userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '3', '0.6', '54', '1', '0', '0', '0.666666667', '0', '0', '7.666666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '5', '14', '1', '0', '5', '1', '2', '66', '0', '0', '0.980392157', '1', '1', '2', '32', '4', '2', '0']
package org . apache . tools . ant . util ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . Vector ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } if ( v1 . size ( ) != v2 . size ( ) ) { return false ; } Enumeration e1 = v1 . elements ( ) ; Enumeration e2 = v2 . elements ( ) ; while ( e1 . hasMoreElements ( ) ) { if ( ! e1 . nextElement ( ) . equals ( e2 . nextElement ( ) ) ) { return false ; } } return true ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } } 	0	['3', '1', '0', '3', '12', '3', '3', '0', '3', '2', '90', '0', '0', '0', '0.333333333', '1', '1', '29', '8', '5', '0']
package org . apache . tools . ant . util . regexp ; public class RegexpUtil { public static final boolean hasFlag ( int options , int flag ) { return ( ( options & flag ) > 0 ) ; } public static final int removeFlag ( int options , int flag ) { return ( options & ( 0xFFFFFFFF - flag ) ) ; } } 	0	['3', '1', '0', '0', '4', '3', '0', '0', '3', '2', '20', '0', '0', '0', '0.5', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . tools . bzip2 ; import java . io . InputStream ; import java . io . IOException ; public class CBZip2InputStream extends InputStream implements BZip2Constants { private static void cadvise ( ) { System . out . println ( "CRC Error" ) ; } private static void badBGLengths ( ) { cadvise ( ) ; } private static void bitStreamEOF ( ) { cadvise ( ) ; } private static void compressedStreamEOF ( ) { cadvise ( ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } private int last ; private int origPtr ; private int blockSize100k ; private boolean blockRandomised ; private int bytesIn ; private int bytesOut ; private int bsBuff ; private int bsLive ; private CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private int [ ] tt ; private char [ ] ll8 ; private int unzftab [ ] = new int [ 256 ] ; private int limit [ ] [ ] = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int base [ ] [ ] = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int perm [ ] [ ] = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int minLens [ ] = new int [ N_GROUPS ] ; private InputStream bsStream ; private boolean streamEnd = false ; private int currentChar = - 1 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; private static final int RAND_PART_B_STATE = 3 ; private static final int RAND_PART_C_STATE = 4 ; private static final int NO_RAND_PART_A_STATE = 5 ; private static final int NO_RAND_PART_B_STATE = 6 ; private static final int NO_RAND_PART_C_STATE = 7 ; private int currentState = START_BLOCK_STATE ; private int storedBlockCRC , storedCombinedCRC ; private int computedBlockCRC , computedCombinedCRC ; int i2 , count , chPrev , ch2 ; int i , tPos ; int rNToGo = 0 ; int rTPos = 0 ; int j2 ; char z ; public CBZip2InputStream ( InputStream zStream ) { ll8 = null ; tt = null ; bsSetStream ( zStream ) ; initialize ( ) ; initBlock ( ) ; setupBlock ( ) ; } public int read ( ) { if ( streamEnd ) { return - 1 ; } else { int retChar = currentChar ; switch ( currentState ) { case START_BLOCK_STATE : break ; case RAND_PART_A_STATE : break ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : break ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : break ; } return retChar ; } } private void initialize ( ) { char magic3 , magic4 ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; if ( magic3 != 'h' || magic4 < '1' || magic4 > '9' ) { bsFinishedWithStream ( ) ; streamEnd = true ; return ; } setDecompressStructureSizes ( magic4 - '0' ) ; computedCombinedCRC = 0 ; } private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 ) { complete ( ) ; return ; } if ( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; } private void endBlock ( ) { computedBlockCRC = mCrc . getFinalCRC ( ) ; if ( storedBlockCRC != computedBlockCRC ) { crcError ( ) ; } computedCombinedCRC = ( computedCombinedCRC << 1 ) | ( computedCombinedCRC > > > 31 ) ; computedCombinedCRC ^= computedBlockCRC ; } private void complete ( ) { storedCombinedCRC = bsGetInt32 ( ) ; if ( storedCombinedCRC != computedCombinedCRC ) { crcError ( ) ; } bsFinishedWithStream ( ) ; streamEnd = true ; } private static void blockOverrun ( ) { cadvise ( ) ; } private static void badBlockHeader ( ) { cadvise ( ) ; } private static void crcError ( ) { cadvise ( ) ; } private void bsFinishedWithStream ( ) { try { if ( this . bsStream != null ) { if ( this . bsStream != System . in ) { this . bsStream . close ( ) ; this . bsStream = null ; } } } catch ( IOException ioe ) { } } private void bsSetStream ( InputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; bytesOut = 0 ; bytesIn = 0 ; } private int bsR ( int n ) { int v ; { while ( bsLive < n ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } v = ( bsBuff > > ( bsLive - n ) ) & ( ( 1 << n ) - 1 ) ; bsLive -= n ; return v ; } private char bsGetUChar ( ) { return ( char ) bsR ( 8 ) ; } private int bsGetint ( ) { int u = 0 ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; return u ; } private int bsGetIntVS ( int numBits ) { return ( int ) bsR ( numBits ) ; } private int bsGetInt32 ( ) { return ( int ) bsGetint ( ) ; } private void hbCreateDecodeTables ( int [ ] limit , int [ ] base , int [ ] perm , char [ ] length , int minLen , int maxLen , int alphaSize ) { int pp , i , j , vec ; pp = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { for ( j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ] = j ; pp ++ ; } } } ; for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] = 0 ; } for ( i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( i = 1 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] += base [ i - 1 ] ; } for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { limit [ i ] = 0 ; } vec = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { vec += ( base [ i + 1 ] - base [ i ] ) ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } } private void recvDecodingTables ( ) { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int i , j , t , nGroups , nSelectors , alphaSize ; int minLen , maxLen ; boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { if ( bsR ( 1 ) == 1 ) { inUse16 [ i ] = true ; } else { inUse16 [ i ] = false ; } } for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( bsR ( 1 ) == 1 ) { inUse [ i * 16 + j ] = true ; } } } } makeMaps ( ) ; alphaSize = nInUse + 2 ; nGroups = bsR ( 3 ) ; nSelectors = bsR ( 15 ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { j = 0 ; while ( bsR ( 1 ) == 1 ) { j ++ ; } selectorMtf [ i ] = ( char ) j ; } { char [ ] pos = new char [ N_GROUPS ] ; char tmp , v ; for ( v = 0 ; v < nGroups ; v ++ ) { pos [ v ] = v ; } for ( i = 0 ; i < nSelectors ; i ++ ) { v = selectorMtf [ i ] ; tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( bsR ( 1 ) == 1 ) { if ( bsR ( 1 ) == 0 ) { curr ++ ; } else { curr -- ; } } len [ t ] [ i ] = ( char ) curr ; } } for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } hbCreateDecodeTables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; minLens [ t ] = minLen ; } } private void getAndMoveToFrontDecode ( ) { char [ ] yy = new char [ 256 ] ; int i , j , nextSym , limitLast ; int EOB , groupNo , groupPos ; limitLast = baseBlockSize * blockSize100k ; origPtr = bsGetIntVS ( 24 ) ; recvDecodingTables ( ) ; EOB = nInUse + 1 ; groupNo = - 1 ; groupPos = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { unzftab [ i ] = 0 ; } for ( i = 0 ; i <= 255 ; i ++ ) { yy [ i ] = ( char ) i ; } last = - 1 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } while ( true ) { if ( nextSym == EOB ) { break ; } if ( nextSym == RUNA || nextSym == RUNB ) { char ch ; int s = - 1 ; int N = 1 ; do { if ( nextSym == RUNA ) { s = s + ( 0 + 1 ) * N ; } else if ( nextSym == RUNB ) { s = s + ( 1 + 1 ) * N ; } N = N * 2 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } ; nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } } while ( nextSym == RUNA || nextSym == RUNB ) ; s ++ ; ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch ] += s ; while ( s > 0 ) { last ++ ; ll8 [ last ] = ch ; s -- ; } ; if ( last >= limitLast ) { blockOverrun ( ) ; } continue ; } else { char tmp ; last ++ ; if ( last >= limitLast ) { blockOverrun ( ) ; } tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] ] ++ ; ll8 [ last ] = seqToUnseq [ tmp ] ; j = nextSym - 1 ; for ( ; j > 3 ; j -= 4 ) { yy [ j ] = yy [ j - 1 ] ; yy [ j - 1 ] = yy [ j - 2 ] ; yy [ j - 2 ] = yy [ j - 3 ] ; yy [ j - 3 ] = yy [ j - 4 ] ; } for ( ; j > 0 ; j -- ) { yy [ j ] = yy [ j - 1 ] ; } yy [ 0 ] = tmp ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } ; nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } continue ; } } } private void setupBlock ( ) { int [ ] cftab = new int [ 257 ] ; char ch ; cftab [ 0 ] = 0 ; for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] = unzftab [ i - 1 ] ; } for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] += cftab [ i - 1 ] ; } for ( i = 0 ; i <= last ; i ++ ) { ch = ( char ) ll8 [ i ] ; tt [ cftab [ ch ] ] = i ; cftab [ ch ] ++ ; } cftab = null ; tPos = tt [ origPtr ] ; count = 0 ; i2 = 0 ; ch2 = 256 ; if ( blockRandomised ) { rNToGo = 0 ; rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; ch2 ^= ( int ) ( ( rNToGo == 1 ) ? 1 : 0 ) ; i2 ++ ; currentChar = ch2 ; currentState = RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupNoRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; i2 ++ ; currentChar = ch2 ; currentState = NO_RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupRandPartB ( ) { if ( ch2 != chPrev ) { currentState = RAND_PART_A_STATE ; count = 1 ; setupRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; z ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; j2 = 0 ; currentState = RAND_PART_C_STATE ; setupRandPartC ( ) ; } else { currentState = RAND_PART_A_STATE ; setupRandPartA ( ) ; } } } private void setupRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupRandPartA ( ) ; } } private void setupNoRandPartB ( ) { if ( ch2 != chPrev ) { currentState = NO_RAND_PART_A_STATE ; count = 1 ; setupNoRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; currentState = NO_RAND_PART_C_STATE ; j2 = 0 ; setupNoRandPartC ( ) ; } else { currentState = NO_RAND_PART_A_STATE ; setupNoRandPartA ( ) ; } } } private void setupNoRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = NO_RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupNoRandPartA ( ) ; } } private void setDecompressStructureSizes ( int newSize100k ) { if ( ! ( 0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9 ) ) { } blockSize100k = newSize100k ; if ( newSize100k == 0 ) { return ; } int n = baseBlockSize * newSize100k ; ll8 = new char [ n ] ; tt = new int [ n ] ; } } 	0	['32', '2', '0', '4', '40', '330', '2', '2', '2', '0.781056966', '2014', '0.787234043', '1', '0.225', '0.20625', '1', '1', '60.46875', '26', '4.0938', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private FacadeTaskHelper facade ; public Rmic ( ) { try { Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; facade = new FacadeTaskHelper ( "kaffe" ) ; } catch ( ClassNotFoundException cnfe ) { facade = new FacadeTaskHelper ( "sun" ) ; } } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , location ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , location ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = new AntClassLoader ( project , classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , location ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { if ( ! generatedFiles [ i ] . endsWith ( ".class" ) ) { continue ; } String sourceFileName = generatedFiles [ i ] . substring ( 0 , classFileName . length ( ) - 6 ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { fileUtils . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { fileUtils . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	0	['48', '4', '0', '25', '108', '964', '7', '20', '44', '0.946301925', '816', '0.952380952', '4', '0.624', '0.154166667', '3', '3', '15.5625', '7', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . IOException ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { System . err . println ( "As of Ant 1.2 released in October 2000, the TaskOutputStream class" ) ; System . err . println ( "is considered to be dead code by the Ant developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '10', '0', '0', '1', '1', '0', '67', '1', '1', '0.714285714', '0.666666667', '1', '1', '20.33333333', '1', '0.6667', '0']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class RmicAdapterFactory { private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { if ( rmicType . equalsIgnoreCase ( "sun" ) ) { return new SunRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "kaffe" ) ) { return new KaffeRmic ( ) ; } else if ( rmicType . equalsIgnoreCase ( "weblogic" ) ) { return new WLRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( RmicAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a rmic adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	0	['3', '1', '0', '7', '14', '3', '1', '6', '1', '2', '88', '0', '0', '0', '0.444444444', '0', '0', '28.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String m_name ; private String m_revision ; private String m_previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { m_name = name ; m_revision = revision ; if ( ! revision . equals ( previousRevision ) ) { m_previousRevision = previousRevision ; } } String getName ( ) { return m_name ; } String getRevision ( ) { return m_revision ; } String getPreviousRevision ( ) { return m_previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant . types ; public class Description extends DataType { public void addText ( String text ) { String currentDescription = project . getDescription ( ) ; if ( currentDescription == null ) { project . setDescription ( text ) ; } else { project . setDescription ( currentDescription + text ) ; } } } 	0	['2', '3', '0', '3', '8', '1', '0', '3', '2', '2', '28', '0', '0', '0.967741935', '0.75', '0', '0', '13', '2', '1', '0']
package org . apache . tools . ant ; public class Location { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { this . fileName = fileName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['5', '1', '0', '69', '10', '8', '69', '0', '3', '0.3125', '69', '0.75', '1', '0', '0.583333333', '0', '0', '12', '3', '0.6', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( getJavac ( ) . getJavacExecutable ( ) ) ; setupModernJavacCommandlineSwitches ( cmd ) ; int firstFileName = assumeJava11 ( ) ? - 1 : cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '14', '1', '1', '5', '2', '2', '44', '0', '0', '0.958333333', '1', '0', '0', '21', '1', '0.5', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '1', '3', '15', '0', '2', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . FileScanner ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . * ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public abstract class AbstractFileSet extends DataType implements Cloneable , SelectorContainer { private PatternSet defaultPatterns = new PatternSet ( ) ; private Vector additionalPatterns = new Vector ( ) ; private Vector selectors = new Vector ( ) ; private File dir ; private boolean useDefaultExcludes = true ; private boolean isCaseSensitive = true ; private boolean followSymlinks = true ; public AbstractFileSet ( ) { super ( ) ; } protected AbstractFileSet ( AbstractFileSet fileset ) { this . dir = fileset . dir ; this . defaultPatterns = fileset . defaultPatterns ; this . additionalPatterns = fileset . additionalPatterns ; this . selectors = fileset . selectors ; this . useDefaultExcludes = fileset . useDefaultExcludes ; this . isCaseSensitive = fileset . isCaseSensitive ; this . followSymlinks = fileset . followSymlinks ; setProject ( fileset . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( dir != null || defaultPatterns . hasPatterns ( getProject ( ) ) ) { throw tooManyAttributes ( ) ; } if ( ! additionalPatterns . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } if ( ! selectors . isEmpty ( ) ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public PatternSet createPatternSet ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PatternSet patterns = new PatternSet ( ) ; additionalPatterns . addElement ( patterns ) ; return patterns ; } public PatternSet . NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return defaultPatterns . createExcludesFile ( ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludes ( excludes ) ; } public void setIncludesfile ( File incl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setIncludesfile ( incl ) ; } public void setExcludesfile ( File excl ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } defaultPatterns . setExcludesfile ( excl ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . useDefaultExcludes = useDefaultExcludes ; } public void setCaseSensitive ( boolean isCaseSensitive ) { this . isCaseSensitive = isCaseSensitive ; } public void setFollowSymlinks ( boolean followSymlinks ) { this . followSymlinks = followSymlinks ; } protected String getDataTypeName ( ) { Project project = getProject ( ) ; if ( project != null ) { Hashtable typedefs = project . getDataTypeDefinitions ( ) ; for ( Enumeration e = typedefs . keys ( ) ; e . hasMoreElements ( ) ; ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; if ( typeClass == getClass ( ) ) { return typeName ; } } } String classname = getClass ( ) . getName ( ) ; int dotIndex = classname . lastIndexOf ( "." ) ; if ( dotIndex == - 1 ) { return classname ; } return classname . substring ( dotIndex + 1 ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for " + getDataTypeName ( ) + "." ) ; } if ( ! dir . exists ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " not found." ) ; } if ( ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a directory." ) ; } DirectoryScanner ds = new DirectoryScanner ( ) ; setupDirectoryScanner ( ds , p ) ; ds . setFollowSymlinks ( followSymlinks ) ; ds . scan ( ) ; return ds ; } public void setupDirectoryScanner ( FileScanner ds , Project p ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds cannot be null" ) ; } ds . setBasedir ( dir ) ; final int count = additionalPatterns . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object o = additionalPatterns . elementAt ( i ) ; defaultPatterns . append ( ( PatternSet ) o , p ) ; } p . log ( getDataTypeName ( ) + ": Setup scanner in dir " + dir + " with " + defaultPatterns , Project . MSG_DEBUG ) ; ds . setIncludes ( defaultPatterns . getIncludePatterns ( p ) ) ; ds . setExcludes ( defaultPatterns . getExcludePatterns ( p ) ) ; if ( ds instanceof SelectorScanner ) { SelectorScanner ss = ( SelectorScanner ) ds ; ss . setSelectors ( getSelectors ( p ) ) ; } if ( useDefaultExcludes ) { ds . addDefaultExcludes ( ) ; } ds . setCaseSensitive ( isCaseSensitive ) ; } protected AbstractFileSet getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! getClass ( ) . isAssignableFrom ( o . getClass ( ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + getDataTypeName ( ) ; throw new BuildException ( msg ) ; } else { return ( AbstractFileSet ) o ; } } public boolean hasSelectors ( ) { return ! ( selectors . isEmpty ( ) ) ; } public boolean hasPatterns ( ) { if ( defaultPatterns . hasPatterns ( getProject ( ) ) ) { return true ; } Enumeration enum = additionalPatterns . elements ( ) ; while ( enum . hasMoreElements ( ) ) { PatternSet ps = ( PatternSet ) enum . nextElement ( ) ; if ( ps . hasPatterns ( getProject ( ) ) ) { return true ; } } return false ; } public int selectorCount ( ) { return selectors . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getSelectors ( p ) ; } else { FileSelector [ ] result = new FileSelector [ selectors . size ( ) ] ; selectors . copyInto ( result ) ; return result ; } } public Enumeration selectorElements ( ) { return selectors . elements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } selectors . addElement ( selector ) ; } public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } } 	0	['41', '3', '2', '52', '102', '560', '26', '26', '38', '0.796428571', '698', '1', '1', '0.434782609', '0.076352068', '1', '3', '15.85365854', '5', '1.6585', '0']
package org . apache . tools . ant . taskdefs . email ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Locale ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; abstract class Mailer { protected String host = null ; protected int port = - 1 ; protected Message message ; protected EmailAddress from ; protected Vector toList = null ; protected Vector ccList = null ; protected Vector bccList = null ; protected Vector files = null ; protected String subject = null ; protected Task task ; protected boolean includeFileNames = false ; private static DateFormat df = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss " , Locale . US ) ; public void setHost ( String host ) { this . host = host ; } public void setPort ( int port ) { this . port = port ; } public void setMessage ( Message m ) { this . message = m ; } public void setFrom ( EmailAddress from ) { this . from = from ; } public void setToList ( Vector list ) { this . toList = list ; } public void setCcList ( Vector list ) { this . ccList = list ; } public void setBccList ( Vector list ) { this . bccList = list ; } public void setFiles ( Vector files ) { this . files = files ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setTask ( Task task ) { this . task = task ; } public void setIncludeFileNames ( boolean b ) { this . includeFileNames = b ; } public abstract void send ( ) throws BuildException ; protected final String getDate ( ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; int offset = tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , cal . get ( Calendar . MILLISECOND ) ) ; StringBuffer tzMarker = new StringBuffer ( offset < 0 ? "-" : "+" ) ; offset = Math . abs ( offset ) ; int hours = offset / ( 60 * 60 * 1000 ) ; int minutes = offset / ( 60 * 1000 ) - 60 * hours ; if ( hours < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( hours ) ; if ( minutes < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( minutes ) ; return df . format ( cal . getTime ( ) ) + tzMarker . toString ( ) ; } } 	0	['15', '1', '1', '6', '29', '87', '2', '4', '12', '0.946428571', '190', '1', '3', '0', '0.223214286', '0', '0', '10.86666667', '4', '1.0667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . MergingMapper ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; public class UpToDate extends Task implements Condition { private String _property ; private String _value ; private File _sourceFile ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setValue ( String value ) { _value = value ; } private String getValue ( ) { return ( _value != null ) ? _value : "true" ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void setSrcfile ( File file ) { _sourceFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 && _sourceFile == null ) { throw new BuildException ( "At least one srcfile or a nested " + "<srcfiles> element must be set." ) ; } if ( sourceFileSets . size ( ) > 0 && _sourceFile != null ) { throw new BuildException ( "Cannot specify both the srcfile " + "attribute and a nested <srcfiles> " + "element." ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested " + "mapper element must be set." ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) { return false ; } if ( _sourceFile != null && ! _sourceFile . exists ( ) ) { throw new BuildException ( _sourceFile . getAbsolutePath ( ) + " not found." ) ; } Enumeration enum = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; upToDate = upToDate && scanDir ( fs . getDir ( project ) , ds . getIncludedFiles ( ) ) ; } if ( _sourceFile != null ) { if ( mapperElement == null ) { upToDate = upToDate && ( _targetFile . lastModified ( ) > _sourceFile . lastModified ( ) ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; upToDate = upToDate && ( sfs . restrict ( new String [ ] { _sourceFile . getAbsolutePath ( ) } , null , null , mapperElement . getImplementation ( ) ) . length == 0 ) ; } } return upToDate ; } public void execute ( ) throws BuildException { if ( _property == null ) { throw new BuildException ( "property attribute is required." , location ) ; } boolean upToDate = eval ( ) ; if ( upToDate ) { this . project . setNewProperty ( _property , getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up-to-date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files are up-to-date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; File dir = srcDir ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; dir = null ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } } 	0	['11', '3', '0', '14', '37', '19', '1', '13', '9', '0.75', '317', '1', '1', '0.787234043', '0.327272727', '1', '1', '27.27272727', '21', '3', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . taskdefs . condition . Os ; import java . io . File ; import java . util . Vector ; public class JavaEnvUtils { private static final boolean isDos = Os . isFamily ( "dos" ) ; private static final boolean isNetware = Os . isName ( "netware" ) ; private static final boolean isAix = Os . isName ( "aix" ) ; private static final String javaHome = System . getProperty ( "java.home" ) ; private static final FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; } catch ( ClassNotFoundException cnfe ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static boolean isJavaVersion ( String version ) { return javaVersion == version ; } public static String getJreExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( isNetware ) { return command ; } File jExecutable = null ; if ( isAix ) { jExecutable = findInDir ( javaHome + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( javaHome + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( isDos ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = fileUtils . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 14 : jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun." ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } } 	0	['11', '1', '0', '15', '26', '31', '14', '2', '7', '0.892307692', '361', '0.615384615', '1', '0', '0.3', '0', '0', '30.63636364', '5', '2.1818', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public final class StripJavaComments extends BaseFilterReader implements ChainableReader { private int readAheadCh = - 1 ; private boolean inString = false ; public StripJavaComments ( ) { super ( ) ; } public StripJavaComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( readAheadCh != - 1 ) { ch = readAheadCh ; readAheadCh = - 1 ; } else { ch = in . read ( ) ; if ( ch == '"' ) { inString = ! inString ; } else { if ( ! inString ) { if ( ch == '/' ) { ch = in . read ( ) ; if ( ch == '/' ) { while ( ch != '\n' && ch != - 1 ) { ch = in . read ( ) ; } } else if ( ch == '*' ) { while ( ch != - 1 ) { ch = in . read ( ) ; if ( ch == '*' ) { ch = in . read ( ) ; while ( ch == '*' && ch != - 1 ) { ch = in . read ( ) ; } if ( ch == '/' ) { ch = read ( ) ; break ; } } } } else { readAheadCh = ch ; ch = '/' ; } } } } } return ch ; } public final Reader chain ( final Reader rdr ) { StripJavaComments newFilter = new StripJavaComments ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '3', '7', '0', '1', '2', '4', '0', '130', '1', '0', '0.928571429', '0.75', '2', '4', '31', '1', '0.5', '0']
package org . apache . tools . mail ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null && line . length ( ) >= 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . length ( ) > 3 && line . charAt ( 3 ) == '-' ; } private void append ( String line ) { if ( line . length ( ) > 4 ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } } 	0	['5', '1', '0', '1', '19', '0', '1', '0', '3', '0.5', '108', '1', '0', '0', '0.533333333', '0', '0', '20.2', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import java . io . File ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . io . Reader ; import java . io . InputStreamReader ; import java . io . IOException ; import java . util . Vector ; public final class LoadFile extends Task { private File srcFile = null ; private boolean failOnError = true ; private String encoding = null ; private String property = null ; private final Vector filterChains = new Vector ( ) ; public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void setProperty ( final String property ) { this . property = property ; } public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setFailonerror ( final boolean fail ) { failOnError = fail ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "source file not defined" ) ; } if ( property == null ) { throw new BuildException ( "output property not defined" ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; log ( "loading " + srcFile + " into property " + property , Project . MSG_VERBOSE ) ; try { final long len = srcFile . length ( ) ; log ( "file size = " + len , Project . MSG_DEBUG ) ; final int size = ( int ) len ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } String text = "" ; if ( size != 0 ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( size ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( project ) ; instream = crh . getAssembledReader ( ) ; text = crh . readFully ( instream ) ; } if ( text != null ) { if ( text . length ( ) > 0 ) { project . setNewProperty ( property , text ) ; log ( "loaded " + text . length ( ) + " characters" , Project . MSG_VERBOSE ) ; log ( property + " := " + text , Project . MSG_DEBUG ) ; } } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; if ( failOnError ) { throw new BuildException ( message , ioe , location ) ; } else { log ( message , Project . MSG_ERR ) ; } } catch ( final BuildException be ) { if ( failOnError ) { throw be ; } else { log ( be . getMessage ( ) , Project . MSG_ERR ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['7', '3', '0', '7', '36', '0', '0', '7', '7', '0.666666667', '261', '1', '0', '0.860465116', '0.342857143', '2', '2', '35.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FileSet ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; public class Move extends Copy { public Move ( ) { super ( ) ; forceOverwrite = true ; } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; continue ; } boolean moved = false ; File f = new File ( fromFile ) ; if ( f . exists ( ) ) { File d = new File ( toFile ) ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( f , d , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } if ( ! moved ) { try { log ( "Moving " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( project . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( f , d , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , project ) ; f = new File ( fromFile ) ; if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + f . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Moved " + count + " empty directories to " + destDir . getAbsolutePath ( ) ) ; } } if ( filesets . size ( ) > 0 ) { Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; File dir = fs . getDir ( project ) ; if ( okToDelete ( dir ) ) { deleteDir ( dir ) ; } } } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = true ; if ( ( getFilterSets ( ) != null && getFilterSets ( ) . size ( ) > 0 ) || ( getFilterChains ( ) != null && getFilterChains ( ) . size ( ) > 0 ) ) { renamed = false ; } else { if ( ! filtering ) { String parentPath = destFile . getParent ( ) ; if ( parentPath != null ) { File parent = new File ( parentPath ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } } if ( destFile . exists ( ) && destFile . isFile ( ) ) { if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } } renamed = sourceFile . renameTo ( destFile ) ; } else { renamed = false ; } } return renamed ; } } 	0	['5', '4', '0', '11', '46', '10', '0', '11', '1', '2', '587', '0', '0', '0.952380952', '0.6', '4', '6', '116.4', '18', '5.8', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class CvsTagEntry { String m_filename ; String m_prevRevision ; String m_revision ; public CvsTagEntry ( String filename ) { this ( filename , null , null ) ; } public CvsTagEntry ( String filename , String revision ) { this ( filename , revision , null ) ; } public CvsTagEntry ( String filename , String revision , String prevRevision ) { m_filename = filename ; m_revision = revision ; m_prevRevision = prevRevision ; } public String getFile ( ) { return m_filename ; } public String getRevision ( ) { return m_revision ; } public String getPreviousRevision ( ) { return m_prevRevision ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( m_filename ) ; if ( ( m_revision == null ) && ( m_prevRevision == null ) ) { buffer . append ( " was removed" ) ; } else if ( m_revision != null && m_prevRevision == null ) { buffer . append ( " is new; current revision is " ) . append ( m_revision ) ; } else if ( m_revision != null && m_prevRevision != null ) { buffer . append ( " has changed from " ) . append ( m_prevRevision ) . append ( " to " ) . append ( m_revision ) ; } return buffer . toString ( ) ; } } 	0	['7', '1', '0', '1', '11', '7', '1', '0', '7', '0.333333333', '98', '0', '0', '0', '0.714285714', '0', '0', '12.57142857', '7', '1.4286', '0']
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static final StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0	['3', '1', '0', '5', '19', '1', '0', '5', '2', '0.5', '89', '1', '0', '0', '0.5', '0', '0', '28.33333333', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class TempFile extends Task { private String property ; private File destDir = null ; private String prefix ; private String suffix = "" ; public void setProperty ( String property ) { this . property = property ; } public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null || property . length ( ) == 0 ) { throw new BuildException ( "no property specified" ) ; } if ( destDir == null ) { destDir = project . resolveFile ( "." ) ; } FileUtils utils = FileUtils . newFileUtils ( ) ; File tfile = utils . createTempFile ( prefix , suffix , destDir ) ; project . setNewProperty ( property , tfile . toString ( ) ) ; } } 	0	['6', '3', '0', '5', '14', '1', '0', '5', '6', '0.7', '75', '1', '0', '0.880952381', '0.555555556', '0', '0', '10.83333333', '1', '0.8333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public abstract class BaseSelector extends DataType implements FileSelector { private String errmsg = null ; public BaseSelector ( ) { } public void setError ( String msg ) { if ( errmsg == null ) { errmsg = msg ; } } public String getError ( ) { return errmsg ; } public void verifySettings ( ) { } public void validate ( ) { if ( getError ( ) == null ) { verifySettings ( ) ; } if ( getError ( ) != null ) { throw new BuildException ( errmsg ) ; } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; } 	0	['6', '3', '5', '15', '8', '3', '12', '3', '6', '0.4', '39', '1', '0', '0.857142857', '0.5', '0', '0', '5.333333333', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class AndSelector extends BaseSelectorContainer { public AndSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{andselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . util . Vector ; import java . util . Date ; class CVSEntry { private Date m_date ; private String m_author ; private final String m_comment ; private final Vector m_files = new Vector ( ) ; public CVSEntry ( Date date , String author , String comment ) { m_date = date ; m_author = author ; m_comment = comment ; } public void addFile ( String file , String revision ) { m_files . addElement ( new RCSFile ( file , revision ) ) ; } public void addFile ( String file , String revision , String previousRevision ) { m_files . addElement ( new RCSFile ( file , revision , previousRevision ) ) ; } Date getDate ( ) { return m_date ; } void setAuthor ( final String author ) { m_author = author ; } String getAuthor ( ) { return m_author ; } String getComment ( ) { return m_comment ; } Vector getFiles ( ) { return m_files ; } public String toString ( ) { return getAuthor ( ) + "\n" + getDate ( ) + "\n" + getFiles ( ) + "\n" + getComment ( ) ; } } 	0	['9', '1', '0', '4', '18', '14', '3', '1', '4', '0.65625', '88', '1', '0', '0', '0.518518519', '0', '0', '8.333333333', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . SQLException ; import java . util . Hashtable ; import java . util . Properties ; public abstract class JDBCTask extends Task { private static Hashtable loaderMap = new Hashtable ( 3 ) ; private boolean caching = true ; private Path classpath ; private AntClassLoader loader ; private boolean autocommit = false ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private String rdbms = null ; private String version = null ; public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public void setCaching ( boolean enable ) { caching = enable ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setRdbms ( String rdbms ) { this . rdbms = rdbms ; } public void setVersion ( String version ) { this . version = version ; } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) { return true ; } try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected static Hashtable getLoaderMap ( ) { return loaderMap ; } protected AntClassLoader getLoader ( ) { return loader ; } protected Connection getConnection ( ) throws BuildException { if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , location ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , location ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , location ) ; } try { log ( "connecting to " + getUrl ( ) , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , getUserId ( ) ) ; info . put ( "password" , getPassword ( ) ) ; Connection conn = getDriver ( ) . connect ( getUrl ( ) , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } conn . setAutoCommit ( autocommit ) ; return conn ; } catch ( SQLException e ) { throw new BuildException ( e , location ) ; } } private Driver getDriver ( ) throws BuildException { if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , location ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { synchronized ( loaderMap ) { if ( caching ) { loader = ( AntClassLoader ) loaderMap . get ( driver ) ; } if ( loader == null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = new AntClassLoader ( project , classpath ) ; if ( caching ) { loaderMap . put ( driver , loader ) ; } } else { log ( "Loading " + driver + " using a cached AntClassLoader." , Project . MSG_VERBOSE ) ; } } dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , location ) ; } return driverInstance ; } public void isCaching ( boolean value ) { caching = value ; } public Path getClasspath ( ) { return classpath ; } public boolean isAutocommit ( ) { return autocommit ; } public String getUrl ( ) { return url ; } public String getUserId ( ) { return userId ; } public void setUserid ( String userId ) { this . userId = userId ; } public String getPassword ( ) { return password ; } public String getRdbms ( ) { return rdbms ; } public String getVersion ( ) { return version ; } } 	0	['26', '3', '1', '9', '54', '225', '1', '8', '20', '0.872727273', '539', '1', '2', '0.606557377', '0.24', '0', '0', '19.30769231', '7', '1.1923', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property = null ; private String value = "true" ; public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <condition>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<condition>" ) ; } if ( property == null ) { throw new BuildException ( "The property attribute is required." ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { log ( "Condition true; setting " + property + " to " + value , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { log ( "Condition false; not setting " + property , Project . MSG_DEBUG ) ; } } } 	0	['4', '3', '0', '5', '16', '0', '0', '5', '4', '0.333333333', '95', '1', '0', '0.914285714', '0.75', '0', '0', '22.25', '1', '0.75', '0']
package org . apache . tools . tar ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	0	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '0']
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '2064', '0', '0', '0', '0', '0', '0', '2052', '0', '0', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public abstract class DataType extends ProjectComponent { protected String description = null ; protected Reference ref = null ; protected boolean checked = true ; public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( p ) ; if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } checked = true ; } protected Object getCheckedRef ( Class requiredClass , String dataTypeName ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } else { return o ; } } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one " + "attribute when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements " + "when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular " + "reference." ) ; } } 	0	['10', '2', '13', '22', '24', '19', '18', '4', '5', '0.666666667', '146', '1', '1', '0.5', '0.266666667', '0', '0', '13.3', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { void setJavac ( Javac attributes ) ; boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public interface DynamicConfigurator { public void setDynamicAttribute ( String name , String value ) throws BuildException ; public Object createDynamicElement ( String name ) throws BuildException ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = tokenizePath ( pattern ) ; Vector strDirs = tokenizePath ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = tokenizePath ( pattern ) ; Vector strDirs = tokenizePath ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) , isCaseSensitive ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { Vector ret = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( path , File . separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } } 	0	['11', '1', '0', '3', '26', '53', '3', '0', '9', '0.9', '725', '1', '1', '0', '0.26', '0', '0', '64.81818182', '47', '8.4545', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import java . util . Random ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '30', '0', '0', '5', '0', '0', '186', '1', '2', '0', '0.6', '0', '0', '90.5', '10', '5', '0']
package org . apache . tools . zip ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . zip . ZipException ; public class ZipEntry extends java . util . zip . ZipEntry { private int internalAttributes = 0 ; private long externalAttributes = 0 ; private Vector extraFields = new Vector ( ) ; public ZipEntry ( String name ) { super ( name ) ; } public ZipEntry ( java . util . zip . ZipEntry entry ) throws ZipException { super ( entry . getName ( ) ) ; setComment ( entry . getComment ( ) ) ; setMethod ( entry . getMethod ( ) ) ; setTime ( entry . getTime ( ) ) ; long size = entry . getSize ( ) ; if ( size > 0 ) { setSize ( size ) ; } long cSize = entry . getCompressedSize ( ) ; if ( cSize > 0 ) { setComprSize ( cSize ) ; } long crc = entry . getCrc ( ) ; if ( crc > 0 ) { setCrc ( crc ) ; } byte [ ] extra = entry . getExtra ( ) ; if ( extra != null ) { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } else { setExtra ( ) ; } } public ZipEntry ( ZipEntry entry ) throws ZipException { this ( ( java . util . zip . ZipEntry ) entry ) ; setInternalAttributes ( entry . getInternalAttributes ( ) ) ; setExternalAttributes ( entry . getExternalAttributes ( ) ) ; setExtraFields ( entry . getExtraFields ( ) ) ; } public Object clone ( ) { ZipEntry e = null ; try { e = new ZipEntry ( ( java . util . zip . ZipEntry ) super . clone ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } e . setInternalAttributes ( getInternalAttributes ( ) ) ; e . setExternalAttributes ( getExternalAttributes ( ) ) ; e . setExtraFields ( getExtraFields ( ) ) ; return e ; } public int getInternalAttributes ( ) { return internalAttributes ; } public void setInternalAttributes ( int value ) { internalAttributes = value ; } public long getExternalAttributes ( ) { return externalAttributes ; } public void setExternalAttributes ( long value ) { externalAttributes = value ; } public void setExtraFields ( ZipExtraField [ ] fields ) { extraFields . removeAllElements ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { extraFields . addElement ( fields [ i ] ) ; } setExtra ( ) ; } public ZipExtraField [ ] getExtraFields ( ) { ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } public void addExtraField ( ZipExtraField ze ) { ZipShort type = ze . getHeaderId ( ) ; boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . setElementAt ( ze , i ) ; done = true ; } } if ( ! done ) { extraFields . addElement ( ze ) ; } setExtra ( ) ; } public void removeExtraField ( ZipShort type ) { boolean done = false ; for ( int i = 0 ; ! done && i < extraFields . size ( ) ; i ++ ) { if ( ( ( ZipExtraField ) extraFields . elementAt ( i ) ) . getHeaderId ( ) . equals ( type ) ) { extraFields . removeElementAt ( i ) ; done = true ; } } if ( ! done ) { throw new java . util . NoSuchElementException ( ) ; } setExtra ( ) ; } public void setExtra ( byte [ ] extra ) throws RuntimeException { try { setExtraFields ( ExtraFieldUtils . parse ( extra ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } protected void setExtra ( ) { super . setExtra ( ExtraFieldUtils . mergeLocalFileDataData ( getExtraFields ( ) ) ) ; } public byte [ ] getLocalFileDataExtra ( ) { byte [ ] extra = getExtra ( ) ; return extra != null ? extra : new byte [ 0 ] ; } public byte [ ] getCentralDirectoryExtra ( ) { return ExtraFieldUtils . mergeCentralDirectoryData ( getExtraFields ( ) ) ; } private Long compressedSize = null ; public void setComprSize ( long size ) { if ( haveSetCompressedSize ( ) ) { performSetCompressedSize ( this , size ) ; } else { compressedSize = new Long ( size ) ; } } public long getCompressedSize ( ) { if ( compressedSize != null ) { return compressedSize . longValue ( ) ; } return super . getCompressedSize ( ) ; } private static Method setCompressedSizeMethod = null ; private static Object lockReflection = new Object ( ) ; private static boolean triedToGetMethod = false ; private static boolean haveSetCompressedSize ( ) { checkSCS ( ) ; return setCompressedSizeMethod != null ; } private static void performSetCompressedSize ( ZipEntry ze , long size ) { Long [ ] s = { new Long ( size ) } ; try { setCompressedSizeMethod . invoke ( ze , s ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + nested . getMessage ( ) ) ; } catch ( Throwable other ) { throw new RuntimeException ( "Exception setting the compressed size " + "of " + ze + ": " + other . getMessage ( ) ) ; } } private static void checkSCS ( ) { if ( ! triedToGetMethod ) { synchronized ( lockReflection ) { triedToGetMethod = true ; try { setCompressedSizeMethod = java . util . zip . ZipEntry . class . getMethod ( "setCompressedSize" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { } } } } } 	0	['23', '2', '0', '5', '68', '181', '2', '3', '17', '0.806818182', '462', '0.875', '0', '0.547619048', '0.140909091', '0', '0', '18.73913043', '5', '1.4783', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; public class FileList extends DataType { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof FileList ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a filelist" ; throw new BuildException ( msg ) ; } else { return ( FileList ) o ; } } } 	0	['8', '3', '0', '9', '31', '0', '4', '5', '6', '0.428571429', '181', '1', '0', '0.833333333', '0.3125', '1', '1', '21.375', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Properties ; import java . util . Vector ; import java . util . Enumeration ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref ; protected String prefix ; private Project fallback ; protected boolean userProperty ; public Property ( ) { this ( false ) ; } protected Property ( boolean userProperty ) { this ( userProperty , null ) ; } protected Property ( boolean userProperty , Project fallback ) { this . userProperty = userProperty ; this . fallback = fallback ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public String getPrefix ( ) { return prefix ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setUserProperty ( boolean userProperty ) { log ( "DEPRECATED: Ignoring request to set user property in Property" + " task." , Project . MSG_WARN ) ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or " + "refid with the name attribute" , location ) ; } } else { if ( file == null && resource == null && env == null ) { throw new BuildException ( "You must specify file, resource or " + "environment when not using the " + "name attribute" , location ) ; } } if ( file == null && resource == null && prefix != null ) { throw new BuildException ( "Prefix is only valid when loading from " + "a file or resource" , location ) ; } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) { loadFile ( file ) ; } if ( resource != null ) { loadResource ( resource ) ; } if ( env != null ) { loadEnvironment ( env ) ; } if ( ( name != null ) && ( ref != null ) ) { try { addProperty ( name , ref . getReferencedObject ( getProject ( ) ) . toString ( ) ) ; } catch ( BuildException be ) { if ( fallback != null ) { addProperty ( name , ref . getReferencedObject ( fallback ) . toString ( ) ) ; } else { throw be ; } } } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; InputStream is = null ; try { ClassLoader cL = null ; if ( classpath != null ) { cL = new AntClassLoader ( project , classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , location ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) { prefix += "." ; } log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; String v = project . replaceProperties ( value ) ; if ( prefix != null ) { name = prefix + name ; } addProperty ( name , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( project . getUserProperty ( n ) == null ) { project . setInheritedProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { project . setNewProperty ( n , v ) ; } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; boolean resolved = false ; while ( ! resolved ) { Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; resolved = true ; if ( propertyRefs . size ( ) != 0 ) { StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( propertyName . equals ( name ) ) { throw new BuildException ( "Property " + name + " was circularly " + "defined." ) ; } fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { fragment = props . getProperty ( propertyName ) ; resolved = false ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; props . put ( name , value ) ; } } } } } 	0	['30', '3', '0', '12', '77', '365', '2', '10', '22', '0.896551724', '717', '1', '3', '0.578125', '0.204166667', '0', '0', '22.56666667', '7', '1.4667', '0']
package org . apache . tools . ant ; import java . io . File ; public interface FileScanner { void addDefaultExcludes ( ) ; File getBasedir ( ) ; String [ ] getExcludedDirectories ( ) ; String [ ] getExcludedFiles ( ) ; String [ ] getIncludedDirectories ( ) ; String [ ] getIncludedFiles ( ) ; String [ ] getNotIncludedDirectories ( ) ; String [ ] getNotIncludedFiles ( ) ; void scan ( ) throws IllegalStateException ; void setBasedir ( String basedir ) ; void setBasedir ( File basedir ) ; void setExcludes ( String [ ] excludes ) ; void setIncludes ( String [ ] includes ) ; void setCaseSensitive ( boolean isCaseSensitive ) ; } 	0	['14', '1', '0', '5', '14', '91', '5', '0', '14', '2', '14', '0', '0', '0', '0.271428571', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . Writer ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Attr ; import org . w3c . dom . NodeList ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; private StringBuffer sb = new StringBuffer ( ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; write ( root , wri , 0 , "  " ) ; wri . flush ( ) ; } public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } break ; } } return sb . toString ( ) ; } public String encodedata ( final String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } 	0	['8', '1', '0', '1', '40', '18', '1', '0', '7', '0.666666667', '464', '1', '0', '0', '0.346938776', '0', '0', '56.625', '11', '3.875', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { return newRegexpMatcher ( null ) ; } public RegexpMatcher newRegexpMatcher ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['4', '1', '1', '5', '11', '6', '2', '3', '3', '2', '62', '0', '0', '0', '0.5', '0', '0', '14.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import java . util . Locale ; public class Os implements Condition { private static final String osName = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String osArch = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String osVersion = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String pathSep = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { if ( family . equals ( "windows" ) ) { isFamily = osName . indexOf ( "windows" ) > - 1 ; } else if ( family . equals ( "os/2" ) ) { isFamily = osName . indexOf ( "os/2" ) > - 1 ; } else if ( family . equals ( "netware" ) ) { isFamily = osName . indexOf ( "netware" ) > - 1 ; } else if ( family . equals ( "dos" ) ) { isFamily = pathSep . equals ( ";" ) && ! isFamily ( "netware" ) ; } else if ( family . equals ( "mac" ) ) { isFamily = osName . indexOf ( "mac" ) > - 1 ; } else if ( family . equals ( "unix" ) ) { isFamily = pathSep . equals ( ":" ) && ( ! isFamily ( "mac" ) || osName . endsWith ( "x" ) ) ; } else if ( family . equals ( "win9x" ) ) { isFamily = isFamily ( "windows" ) && ! ( osName . indexOf ( "nt" ) >= 0 || osName . indexOf ( "2000" ) >= 0 || osName . indexOf ( "xp" ) >= 0 ) ; } else if ( family . equals ( "z/os" ) ) { isFamily = osName . indexOf ( "z/os" ) > - 1 || osName . indexOf ( "os/390" ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( osName ) ; } if ( arch != null ) { isArch = arch . equals ( osArch ) ; } if ( version != null ) { isVersion = version . equals ( osVersion ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	0	['13', '1', '0', '14', '23', '68', '12', '2', '12', '0.697916667', '308', '1', '0', '0', '0.708333333', '0', '0', '22.07692308', '36', '3.4615', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration enum = getConditions ( ) ; while ( enum . hasMoreElements ( ) ) { Condition c = ( Condition ) enum . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class KaffeRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; try { Class c = Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Constructor cons = c . getConstructor ( new Class [ ] { String [ ] . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { cmd . getArguments ( ) } ) ; Method doRmic = c . getMethod ( "run" , null ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , null ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use Kaffe rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting Kaffe rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } } 	0	['3', '2', '0', '7', '19', '3', '1', '6', '2', '1', '93', '0', '0', '0.866666667', '0.5', '0', '0', '29.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . input ; public class InputRequest { private String prompt ; private String input ; public InputRequest ( String prompt ) { if ( prompt == null ) { throw new IllegalArgumentException ( "prompt must not be null" ) ; } this . prompt = prompt ; } public String getPrompt ( ) { return prompt ; } public void setInput ( String input ) { this . input = input ; } public boolean isInputValid ( ) { return true ; } public String getInput ( ) { return input ; } } 	0	['5', '1', '1', '5', '7', '6', '5', '0', '5', '0.75', '32', '1', '0', '0', '0.7', '0', '0', '5', '1', '0.8', '0']
package org . apache . tools . ant . util ; import java . util . Enumeration ; import java . util . Vector ; public class Watchdog implements Runnable { private Vector observers = new Vector ( 1 ) ; private long timeout = - 1 ; private boolean stopped = false ; public Watchdog ( long timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public void addTimeoutObserver ( TimeoutObserver to ) { observers . addElement ( to ) ; } public void removeTimeoutObserver ( TimeoutObserver to ) { observers . removeElement ( to ) ; } protected final void fireTimeoutOccured ( ) { Enumeration enum = observers . elements ( ) ; while ( enum . hasMoreElements ( ) ) { ( ( TimeoutObserver ) enum . nextElement ( ) ) . timeoutOccured ( this ) ; } } public synchronized void start ( ) { stopped = false ; Thread t = new Thread ( this , "WATCHDOG" ) ; t . setDaemon ( true ) ; t . start ( ) ; } public synchronized void stop ( ) { stopped = true ; notifyAll ( ) ; } public synchronized void run ( ) { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( ! stopped && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } if ( ! stopped ) { fireTimeoutOccured ( ) ; } } } 	0	['7', '1', '0', '3', '22', '0', '3', '1', '6', '0.555555556', '111', '1', '0', '0', '0.476190476', '0', '0', '14.42857143', '4', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class SendEmail extends EmailTask { public void setMailport ( Integer value ) { setMailport ( value . intValue ( ) ) ; } } 	0	['2', '4', '0', '1', '5', '1', '0', '1', '2', '2', '10', '0', '0', '0.985507246', '0.75', '1', '1', '4', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . util . StringTokenizer ; import java . util . Vector ; import java . io . File ; public class PathConvert extends Task { private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private boolean setonempty = true ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; public PathConvert ( ) { onWindows = Os . isFamily ( "dos" ) ; } public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set " + "in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public static class TargetOs extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "windows" , "unix" , "netware" , "os/2" } ; } } public Path createPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { TargetOs to = new TargetOs ( ) ; to . setValue ( target ) ; setTargetos ( to ) ; } public void setTargetos ( TargetOs target ) { targetOS = target . getValue ( ) ; targetWindows = ! targetOS . equals ( "unix" ) ; } public void setSetonempty ( boolean setonempty ) { this . setonempty = setonempty ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) { throw noChildrenAllowed ( ) ; } refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { Path savedPath = path ; String savedPathSep = pathSep ; String savedDirSep = dirSep ; try { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else if ( obj instanceof DirSet ) { DirSet ds = ( DirSet ) obj ; path . addDirset ( ds ) ; } else if ( obj instanceof FileList ) { FileList fl = ( FileList ) obj ; path . addFilelist ( fl ) ; } else { throw new BuildException ( "'refid' does not refer to a " + "path, fileset, dirset, or " + "filelist." ) ; } } validateSetup ( ) ; String fromDirSep = onWindows ? "\\" : "/" ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; if ( i != 0 ) { rslt . append ( pathSep ) ; } StringTokenizer stDirectory = new StringTokenizer ( elem , fromDirSep , true ) ; String token = null ; while ( stDirectory . hasMoreTokens ( ) ) { token = stDirectory . nextToken ( ) ; if ( fromDirSep . equals ( token ) ) { rslt . append ( dirSep ) ; } else { rslt . append ( token ) ; } } } String value = rslt . toString ( ) ; if ( setonempty ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { if ( rslt . length ( ) > 0 ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } finally { path = savedPath ; dirSep = savedDirSep ; pathSep = savedPathSep ; } } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) { throw new BuildException ( "You must specify a path to convert" ) ; } if ( property == null ) { throw new BuildException ( "You must specify a property" ) ; } if ( targetOS == null && pathSep == null && dirSep == null ) { throw new BuildException ( "You must specify at least one of " + "targetOS, dirSep, or pathSep" ) ; } String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested <path> " + "elements when using the refid attribute." ) ; } } 	0	['16', '3', '0', '13', '48', '58', '1', '13', '12', '0.786666667', '480', '1', '2', '0.711538462', '0.25', '2', '2', '28.375', '4', '1.4375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean inheritAll = true ; private boolean inheritRefs = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = ( Ant ) getProject ( ) . createTask ( "ant" ) ; callee . setOwningTarget ( getOwningTarget ( ) ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( getLocation ( ) ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , location ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void setTarget ( String target ) { subTarget = target ; } protected void handleOutput ( String line ) { if ( callee != null ) { callee . handleOutput ( line ) ; } else { super . handleOutput ( line ) ; } } protected void handleErrorOutput ( String line ) { if ( callee != null ) { callee . handleErrorOutput ( line ) ; } else { super . handleErrorOutput ( line ) ; } } } 	0	['10', '3', '0', '9', '33', '3', '0', '9', '8', '0.722222222', '145', '1', '1', '0.804347826', '0.4', '2', '4', '13.1', '2', '1.3', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . IOException ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; public class LogOutputStream extends OutputStream { private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['7', '2', '2', '9', '15', '1', '8', '1', '4', '0.583333333', '92', '1', '1', '0.454545455', '0.464285714', '1', '1', '11.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Commandline ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } classpath . addExtdirs ( extdirs ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jvc" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '20', '1', '1', '8', '2', '2', '132', '0', '0', '0.958333333', '1', '1', '1', '65', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . zip ; public final class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000l ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return result ; } public long getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '7', '0', '147', '1', '0', '0', '0.342857143', '1', '1', '19.85714286', '4', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; public interface ChainableReader { public Reader chain ( Reader rdr ) ; } 	0	['1', '1', '0', '13', '1', '0', '13', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . io . IOException ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; try { java . net . Socket socket = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } return true ; } } 	0	['4', '2', '0', '4', '12', '0', '1', '3', '4', '0.333333333', '70', '1', '0', '0.75', '0.5', '0', '0', '16', '1', '0.75', '0']
package org . apache . tools . ant . input ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '3', '19', '0', '0', '3', '2', '0.75', '104', '0.5', '0', '0', '0.666666667', '0', '0', '33', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . filters . util ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . filters . BaseFilterReader ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . types . AntFilterReader ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public final class ChainReaderHelper { private static final int DEFAULT_BUFFER_SIZE = 8192 ; public Reader primaryReader ; public int bufferSize = DEFAULT_BUFFER_SIZE ; public Vector filterChains = new Vector ( ) ; private Project project = null ; public final void setPrimaryReader ( Reader rdr ) { primaryReader = rdr ; } public final void setProject ( final Project project ) { this . project = project ; } public final Project getProject ( ) { return project ; } public final void setBufferSize ( int size ) { bufferSize = size ; } public final void setFilterChains ( Vector fchain ) { filterChains = fchain ; } public final Reader getAssembledReader ( ) throws BuildException { if ( primaryReader == null ) { throw new BuildException ( "primaryReader must not be null." ) ; } Reader instream = primaryReader ; final int filterReadersCount = filterChains . size ( ) ; final Vector finalFilters = new Vector ( ) ; for ( int i = 0 ; i < filterReadersCount ; i ++ ) { final FilterChain filterchain = ( FilterChain ) filterChains . elementAt ( i ) ; final Vector filterReaders = filterchain . getFilterReaders ( ) ; final int readerCount = filterReaders . size ( ) ; for ( int j = 0 ; j < readerCount ; j ++ ) { finalFilters . addElement ( filterReaders . elementAt ( j ) ) ; } } final int filtersCount = finalFilters . size ( ) ; if ( filtersCount > 0 ) { for ( int i = 0 ; i < filtersCount ; i ++ ) { Object o = finalFilters . elementAt ( i ) ; if ( o instanceof AntFilterReader ) { final AntFilterReader filter = ( AntFilterReader ) finalFilters . elementAt ( i ) ; final String className = filter . getClassName ( ) ; final Path classpath = filter . getClasspath ( ) ; final Project project = filter . getProject ( ) ; if ( className != null ) { try { Class clazz = null ; if ( classpath == null ) { clazz = Class . forName ( className ) ; } else { AntClassLoader al = project . createClassLoader ( classpath ) ; clazz = Class . forName ( className , true , al ) ; } if ( clazz != null ) { if ( ! FilterReader . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( className + " does not extend java.io.FilterReader" ) ; } final Constructor [ ] constructors = clazz . getConstructors ( ) ; int j = 0 ; boolean consPresent = false ; for ( ; j < constructors . length ; j ++ ) { Class [ ] types = constructors [ j ] . getParameterTypes ( ) ; if ( types . length == 1 && types [ 0 ] . isAssignableFrom ( Reader . class ) ) { consPresent = true ; break ; } } if ( ! consPresent ) { throw new BuildException ( className + " does not define a public constructor" + " that takes in a Reader as its " + "single argument." ) ; } final Reader [ ] rdr = { instream } ; instream = ( Reader ) constructors [ j ] . newInstance ( rdr ) ; setProjectOnObject ( instream ) ; if ( Parameterizable . class . isAssignableFrom ( clazz ) ) { final Parameter [ ] params = filter . getParams ( ) ; ( ( Parameterizable ) instream ) . setParameters ( params ) ; } } } catch ( final ClassNotFoundException cnfe ) { throw new BuildException ( cnfe ) ; } catch ( final InstantiationException ie ) { throw new BuildException ( ie ) ; } catch ( final IllegalAccessException iae ) { throw new BuildException ( iae ) ; } catch ( final InvocationTargetException ite ) { throw new BuildException ( ite ) ; } } } else if ( o instanceof ChainableReader ) { setProjectOnObject ( o ) ; instream = ( ( ChainableReader ) o ) . chain ( instream ) ; setProjectOnObject ( instream ) ; } } } return instream ; } private void setProjectOnObject ( Object obj ) { if ( project == null ) { return ; } if ( obj instanceof BaseFilterReader ) { ( ( BaseFilterReader ) obj ) . setProject ( project ) ; return ; } project . setProjectReference ( obj ) ; } public final String readFully ( Reader rdr ) throws IOException { return FileUtils . readFully ( rdr , bufferSize ) ; } } 	0	['10', '1', '0', '15', '39', '19', '4', '12', '8', '0.888888889', '344', '0.25', '1', '0', '0.228571429', '0', '0', '32.6', '3', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . JavaEnvUtils ; public class SignJar extends Task { protected File jar ; protected String alias ; private String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected File signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; private String maxMemory ; protected Vector filesets = new Vector ( ) ; protected boolean lazy ; public void setMaxmemory ( String max ) { maxMemory = max ; } public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final File signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void setLazy ( final boolean lazy ) { this . lazy = lazy ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( null == jar && filesets . size ( ) == 0 ) { throw new BuildException ( "jar must be set through jar attribute " + "or nested filesets" ) ; } if ( null != jar ) { if ( filesets . size ( ) != 0 ) { log ( "nested filesets will be ignored if the jar attribute has" + " been specified." , Project . MSG_WARN ) ; } doOneJar ( jar , signedjar ) ; return ; } else { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] jarFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < jarFiles . length ; j ++ ) { doOneJar ( new File ( fs . getDir ( getProject ( ) ) , jarFiles [ j ] ) , null ) ; } } } } private void doOneJar ( File jarSource , File jarTarget ) throws BuildException { if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( jarSource , jarTarget ) ) { return ; } final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "jarsigner" ) ) ; if ( maxMemory != null ) { cmd . createArg ( ) . setValue ( "-J-Xmx" + maxMemory ) ; } if ( null != keystore ) { File keystoreFile = getProject ( ) . resolveFile ( keystore ) ; if ( keystoreFile . exists ( ) ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystoreFile . getPath ( ) ) ; } else { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != jarTarget ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( jarTarget . toString ( ) ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jarSource . toString ( ) ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + jarSource . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( File jarFile , File signedjarFile ) { if ( null == jarFile ) { return false ; } if ( null != signedjarFile ) { if ( ! jarFile . exists ( ) ) { return false ; } if ( ! signedjarFile . exists ( ) ) { return false ; } if ( jarFile . equals ( signedjarFile ) ) { return false ; } if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) { return true ; } } else { if ( lazy ) { return isSigned ( jarFile ) ; } } return false ; } protected boolean isSigned ( File file ) { final String SIG_START = "META-INF/" ; final String SIG_END = ".SF" ; if ( ! file . exists ( ) ) { return false ; } ZipFile jarFile = null ; try { jarFile = new ZipFile ( file ) ; if ( null == alias ) { Enumeration entries = jarFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String name = ( ( ZipEntry ) entries . nextElement ( ) ) . getName ( ) ; if ( name . startsWith ( SIG_START ) && name . endsWith ( SIG_END ) ) { return true ; } } return false ; } else { return jarFile . getEntry ( SIG_START + alias . toUpperCase ( ) + SIG_END ) != null ; } } catch ( IOException e ) { return false ; } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['19', '3', '0', '10', '61', '135', '0', '10', '16', '0.888888889', '504', '1', '0', '0.672727273', '0.378947368', '1', '1', '24.78947368', '13', '1.9474', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '30', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.666666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . AbstractFileSet ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private Vector filelists = new Vector ( ) ; private boolean relative = false ; private boolean parallel = false ; private boolean forwardSlash = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; private boolean skipEmpty = false ; protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; private int maxParallel = - 1 ; private boolean addSourceFile = true ; private boolean verbose = false ; protected boolean srcIsFirst = true ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void addDirset ( DirSet set ) { filesets . addElement ( set ) ; } public void addFilelist ( FileList list ) { filelists . addElement ( list ) ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public void setSkipEmptyFilesets ( boolean skip ) { skipEmpty = skip ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setForwardslash ( boolean forwardSlash ) { this . forwardSlash = forwardSlash ; } public void setMaxParallel ( int max ) { maxParallel = max ; } public void setAddsourcefile ( boolean b ) { addSourceFile = b ; } public void setVerbose ( boolean b ) { verbose = b ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "srcfile elements." , getLocation ( ) ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support multiple " + "targetfile elements." , getLocation ( ) ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } protected void checkConfiguration ( ) { if ( "execon" . equals ( getTaskName ( ) ) ) { log ( "!! execon is deprecated. Use apply instead. !!" ) ; } super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 && filelists . size ( ) == 0 ) { throw new BuildException ( "no filesets and no filelists specified" , getLocation ( ) ) ; } if ( targetFilePos != null || mapperElement != null || destDir != null ) { if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , getLocation ( ) ) ; } mapper = mapperElement . getImplementation ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { int totalFiles = 0 ; int totalDirs = 0 ; boolean haveExecuted = false ; try { Vector fileNames = new Vector ( ) ; Vector baseDirs = new Vector ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { String currentType = type ; AbstractFileSet fs = ( AbstractFileSet ) filesets . elementAt ( i ) ; if ( fs instanceof DirSet ) { if ( ! "dir" . equals ( type ) ) { log ( "Found a nested dirset but type is " + type + ". " + "Temporarily switching to type=\"dir\" on the" + " assumption that you really did mean" + " <dirset> not <fileset>." , Project . MSG_DEBUG ) ; currentType = "dir" ; } } File base = fs . getDir ( getProject ( ) ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; if ( ! "dir" . equals ( currentType ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalFiles ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( ! "file" . equals ( currentType ) ) { String [ ] s = getDirs ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { totalDirs ++ ; fileNames . addElement ( s [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping fileset for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } for ( int i = 0 ; i < filelists . size ( ) ; i ++ ) { FileList list = ( FileList ) filelists . elementAt ( i ) ; File base = list . getDir ( getProject ( ) ) ; String [ ] names = list . getFiles ( getProject ( ) ) ; for ( int j = 0 ; j < names . length ; j ++ ) { File f = new File ( base , names [ j ] ) ; if ( ( f . isFile ( ) && ! "dir" . equals ( type ) ) || ( f . isDirectory ( ) && ! "file" . equals ( type ) ) ) { if ( f . isFile ( ) ) { totalFiles ++ ; } else { totalDirs ++ ; } fileNames . addElement ( names [ j ] ) ; baseDirs . addElement ( base ) ; } } if ( fileNames . size ( ) == 0 && skipEmpty ) { log ( "Skipping filelist for directory " + base + ". It is empty." , Project . MSG_INFO ) ; continue ; } if ( ! parallel ) { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( haveExecuted ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; haveExecuted = true ; } fileNames . removeAllElements ( ) ; baseDirs . removeAllElements ( ) ; } } if ( parallel && ( fileNames . size ( ) > 0 || ! skipEmpty ) ) { runParallel ( exe , fileNames , baseDirs ) ; haveExecuted = true ; } if ( haveExecuted ) { log ( "Applied " + cmdl . getExecutable ( ) + " to " + totalFiles + " file" + ( totalFiles != 1 ? "s" : "" ) + " and " + totalDirs + " director" + ( totalDirs != 1 ? "ies" : "y" ) + "." , verbose ? Project . MSG_INFO : Project . MSG_VERBOSE ) ; } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File [ ] baseDirs ) { final char fileSeparator = File . separatorChar ; Vector targets = new Vector ( ) ; if ( targetFilePos != null ) { Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = null ; if ( ! relative ) { name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; } else { name = subTargets [ j ] ; } if ( forwardSlash && fileSeparator != '/' ) { name = name . replace ( fileSeparator , '/' ) ; } if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; if ( ! addSourceFile ) { srcFiles = new String [ 0 ] ; } String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } if ( targetFilePos != null ) { int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } } else { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , orig . length - srcIndex ) ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { if ( ! relative ) { result [ srcIndex + i ] = ( new File ( baseDirs [ i ] , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } else { result [ srcIndex + i ] = srcFiles [ i ] ; } if ( forwardSlash && fileSeparator != '/' ) { result [ srcIndex + i ] = result [ srcIndex + i ] . replace ( fileSeparator , '/' ) ; } } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , new File [ ] { baseDir } ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedFiles ( ) ; } } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { if ( mapper != null ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } else { return ds . getIncludedDirectories ( ) ; } } protected void runParallel ( Execute exe , Vector fileNames , Vector baseDirs ) throws IOException , BuildException { String [ ] s = new String [ fileNames . size ( ) ] ; fileNames . copyInto ( s ) ; File [ ] b = new File [ baseDirs . size ( ) ] ; baseDirs . copyInto ( b ) ; if ( maxParallel <= 0 || s . length == 0 ) { String [ ] command = getCommandline ( s , b ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; runExecute ( exe ) ; } else { int stillToDo = fileNames . size ( ) ; int currentOffset = 0 ; while ( stillToDo > 0 ) { int currentAmount = Math . min ( stillToDo , maxParallel ) ; String [ ] cs = new String [ currentAmount ] ; System . arraycopy ( s , currentOffset , cs , 0 , currentAmount ) ; File [ ] cb = new File [ currentAmount ] ; System . arraycopy ( b , currentOffset , cb , 0 , currentAmount ) ; String [ ] command = getCommandline ( cs , cb ) ; log ( Commandline . describeCommand ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; if ( currentOffset > 0 ) { exe . setStreamHandler ( createHandler ( ) ) ; } runExecute ( exe ) ; stillToDo -= currentAmount ; currentOffset += currentAmount ; } } } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['23', '4', '2', '22', '77', '149', '2', '20', '16', '0.826704545', '1164', '1', '4', '0.777777778', '0.142857143', '3', '7', '48.91304348', '19', '2.3043', '0']
package org . apache . tools . bzip2 ; class CRC { public static int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; public CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } int globalCrc ; } 	0	['7', '1', '0', '2', '8', '0', '2', '0', '1', '0.5', '1082', '0', '0', '0', '0.666666667', '0', '0', '153.2857143', '2', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public ExecuteWatchdog ( int timeout ) { this ( ( long ) timeout ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; watch = false ; process = null ; } public void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['9', '1', '0', '8', '23', '0', '5', '3', '8', '0.5', '148', '1', '1', '0', '0.288888889', '0', '0', '14.88888889', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['3', '6', '0', '7', '11', '3', '5', '3', '3', '2', '37', '0', '0', '0.96969697', '1', '2', '3', '11.33333333', '2', '1.3333', '0']
package org . apache . tools . ant . types ; import java . lang . reflect . Method ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; private Path catalogPath ; public static final String APACHE_RESOLVER = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver" ; public static final String CATALOG_RESOLVER = "org.apache.xml.resolver.tools.CatalogResolver" ; public XMLCatalog ( ) { setChecked ( false ) ; } private Vector getElements ( ) { return getRef ( ) . elements ; } private Path getClasspath ( ) { return getRef ( ) . classpath ; } private void setElements ( Vector aVector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements = aVector ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } setChecked ( false ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path createCatalogPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . catalogPath == null ) { this . catalogPath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . catalogPath . createPath ( ) ; } public void setCatalogPathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createCatalogPath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path getCatalogPath ( ) { return getRef ( ) . catalogPath ; } public void addDTD ( ResourceLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; setChecked ( false ) ; } public void addEntity ( ResourceLocation entity ) throws BuildException { addDTD ( entity ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration e = newElements . elements ( ) ; while ( e . hasMoreElements ( ) ) { ourElements . addElement ( e . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; Path nestedCatalogPath = catalog . getCatalogPath ( ) ; createCatalogPath ( ) . append ( nestedCatalogPath ) ; setChecked ( false ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( isReference ( ) ) { return getRef ( ) . resolveEntity ( publicId , systemId ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = getCatalogResolver ( ) . resolveEntity ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( isReference ( ) ) { return getRef ( ) . resolve ( href , base ) ; } if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = ( SAXSource ) getCatalogResolver ( ) . resolve ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; URL baseURL = null ; try { if ( base == null ) { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } else { baseURL = new URL ( base ) ; } URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private XMLCatalog getRef ( ) { if ( ! isReference ( ) ) { return this ; } return ( XMLCatalog ) getCheckedRef ( XMLCatalog . class , "xmlcatalog" ) ; } private CatalogResolver catalogResolver = null ; private CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { AntClassLoader loader = null ; loader = getProject ( ) . createClassLoader ( Path . systemClasspath ) ; try { Class clazz = Class . forName ( APACHE_RESOLVER , true , loader ) ; ClassLoader apacheResolverLoader = clazz . getClassLoader ( ) ; Class baseResolverClass = Class . forName ( CATALOG_RESOLVER , true , apacheResolverLoader ) ; ClassLoader baseResolverLoader = baseResolverClass . getClassLoader ( ) ; clazz = Class . forName ( APACHE_RESOLVER , true , baseResolverLoader ) ; Object obj = clazz . newInstance ( ) ; catalogResolver = new ExternalResolver ( clazz , obj ) ; } catch ( Throwable ex ) { catalogResolver = new InternalResolver ( ) ; if ( getCatalogPath ( ) != null && getCatalogPath ( ) . list ( ) . length != 0 ) { log ( "Warning: catalogpath listing external catalogs" + " will be ignored" , Project . MSG_WARN ) ; } log ( "Failed to load Apache resolver: " + ex , Project . MSG_DEBUG ) ; } } return catalogResolver ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private ResourceLocation findMatchingEntry ( String publicId ) { Enumeration e = getElements ( ) . elements ( ) ; ResourceLocation element = null ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof ResourceLocation ) { element = ( ResourceLocation ) o ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } } return null ; } private String removeFragment ( String uri ) { String result = uri ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; } return result ; } private InputSource filesystemLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; uri = uri . replace ( File . separatorChar , '/' ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { File testFile = new File ( uri ) ; if ( testFile . exists ( ) && testFile . canRead ( ) ) { log ( "uri : '" + uri + "' matches a readable file" , Project . MSG_DEBUG ) ; try { url = fileUtils . getFileURL ( testFile ) ; } catch ( MalformedURLException ex1 ) { throw new BuildException ( "could not find an URL for :" + testFile . getAbsolutePath ( ) ) ; } } else { log ( "uri : '" + uri + "' does not match a readable file" , Project . MSG_DEBUG ) ; } } if ( url != null ) { String fileName = url . getFile ( ) ; if ( fileName != null ) { log ( "fileName " + fileName , Project . MSG_DEBUG ) ; File resFile = new File ( fileName ) ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; String sysid = JAXPUtils . getSystemId ( resFile ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( IOException ex ) { } } } } return source ; } private InputSource classpathLookup ( ResourceLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; Path cp = classpath ; if ( cp != null ) { cp = classpath . concatSystemClasspath ( "ignore" ) ; } else { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } loader = getProject ( ) . createClassLoader ( cp ) ; InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = fileUtils . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private interface CatalogResolver extends URIResolver , EntityResolver { InputSource resolveEntity ( String publicId , String systemId ) ; Source resolve ( String href , String base ) throws TransformerException ; } private class InternalResolver implements CatalogResolver { public InternalResolver ( ) { log ( "Apache resolver library not found, internal resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source == null ) { source = urlLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } private class ExternalResolver implements CatalogResolver { private Method setXMLCatalog = null ; private Method parseCatalog = null ; private Method resolveEntity = null ; private Method resolve = null ; private Object resolverImpl = null ; private boolean externalCatalogsProcessed = false ; public ExternalResolver ( Class resolverImplClass , Object resolverImpl ) { this . resolverImpl = resolverImpl ; try { setXMLCatalog = resolverImplClass . getMethod ( "setXMLCatalog" , new Class [ ] { XMLCatalog . class } ) ; parseCatalog = resolverImplClass . getMethod ( "parseCatalog" , new Class [ ] { String . class } ) ; resolveEntity = resolverImplClass . getMethod ( "resolveEntity" , new Class [ ] { String . class , String . class } ) ; resolve = resolverImplClass . getMethod ( "resolve" , new Class [ ] { String . class , String . class } ) ; } catch ( NoSuchMethodException ex ) { throw new BuildException ( ex ) ; } log ( "Apache resolver library found, xml-commons resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } private void processExternalCatalogs ( ) { if ( ! externalCatalogsProcessed ) { try { setXMLCatalog . invoke ( resolverImpl , new Object [ ] { XMLCatalog . this } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } Path catPath = getCatalogPath ( ) ; if ( catPath != null ) { log ( "Using catalogpath '" + getCatalogPath ( ) + "'" , Project . MSG_DEBUG ) ; String [ ] catPathList = getCatalogPath ( ) . list ( ) ; for ( int i = 0 ; i < catPathList . length ; i ++ ) { File catFile = new File ( catPathList [ i ] ) ; log ( "Parsing " + catFile , Project . MSG_DEBUG ) ; try { parseCatalog . invoke ( resolverImpl , new Object [ ] { catFile . getPath ( ) } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } } externalCatalogsProcessed = true ; } } } 	0	['30', '3', '0', '15', '109', '395', '4', '13', '13', '0.869731801', '929', '0.555555556', '4', '0.517241379', '0.211206897', '1', '1', '29.66666667', '8', '1.9667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private Vector regexps = new Vector ( ) ; private String line = null ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int regexpsSize = regexps . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; boolean matches = re . matches ( line ) ; if ( ! matches ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private final Vector getRegexps ( ) { return regexps ; } public final Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } } } } } 	0	['8', '5', '0', '9', '29', '0', '1', '8', '5', '0.571428571', '187', '1', '0', '0.823529412', '0.375', '2', '5', '22', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . types . Reference ; public class SubAnt extends Task { private Path buildpath ; private String target = null ; private String antfile = "build.xml" ; private File genericantfile = null ; private boolean inheritAll = false ; private boolean inheritRefs = false ; private boolean failOnError = true ; private String output = null ; private Vector properties = new Vector ( ) ; private Vector references = new Vector ( ) ; private Vector propertySets = new Vector ( ) ; public void execute ( ) { if ( buildpath == null ) { throw new BuildException ( "No buildpath specified" ) ; } final String [ ] filenames = buildpath . list ( ) ; final int count = filenames . length ; if ( count < 1 ) { log ( "No sub-builds to iterate on" , Project . MSG_WARN ) ; return ; } BuildException buildException = null ; for ( int i = 0 ; i < count ; ++ i ) { File file = null ; Throwable thrownException = null ; try { File directory = null ; file = new File ( filenames [ i ] ) ; if ( file . isDirectory ( ) ) { if ( genericantfile != null ) { directory = file ; file = genericantfile ; } else { file = new File ( file , antfile ) ; } } execute ( file , directory ) ; } catch ( RuntimeException ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw ex ; } thrownException = ex ; } catch ( Throwable ex ) { if ( ! ( getProject ( ) . isKeepGoingMode ( ) ) ) { throw new BuildException ( ex ) ; } thrownException = ex ; } if ( thrownException != null ) { if ( thrownException instanceof BuildException ) { log ( "File '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; if ( buildException == null ) { buildException = ( BuildException ) thrownException ; } } else { log ( "Target '" + file + "' failed with message '" + thrownException . getMessage ( ) + "'." , Project . MSG_ERR ) ; thrownException . printStackTrace ( System . err ) ; if ( buildException == null ) { buildException = new BuildException ( thrownException ) ; } } } } if ( buildException != null ) { throw buildException ; } } private void execute ( File file , File directory ) throws BuildException { if ( ! file . exists ( ) || file . isDirectory ( ) || ! file . canRead ( ) ) { String msg = "Invalid file: " + file ; if ( failOnError ) { throw new BuildException ( msg ) ; } log ( msg , Project . MSG_WARN ) ; return ; } Ant ant = createAntTask ( directory ) ; String antfilename = null ; try { antfilename = file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } ant . setAntfile ( antfilename ) ; try { ant . execute ( ) ; } catch ( BuildException e ) { if ( failOnError ) { throw e ; } log ( "Failure for target '" + target + "' of: " + antfilename + "\n" + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void setAntfile ( String antfile ) { this . antfile = antfile ; } public void setGenericAntfile ( File afile ) { this . genericantfile = afile ; } public void setFailonerror ( boolean failOnError ) { this . failOnError = failOnError ; } public void setTarget ( String target ) { this . target = target ; } public void setOutput ( String s ) { this . output = s ; } public void setInheritall ( boolean b ) { this . inheritAll = b ; } public void setInheritrefs ( boolean b ) { this . inheritRefs = b ; } public void addProperty ( Property p ) { properties . addElement ( p ) ; } public void addReference ( Ant . Reference r ) { references . addElement ( r ) ; } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addDirset ( DirSet set ) { getBuildpath ( ) . addDirset ( set ) ; } public void addFileset ( FileSet set ) { getBuildpath ( ) . addFileset ( set ) ; } public void addFilelist ( FileList list ) { getBuildpath ( ) . addFilelist ( list ) ; } public void setBuildpath ( Path s ) { getBuildpath ( ) . append ( s ) ; } public Path createBuildpath ( ) { return getBuildpath ( ) . createPath ( ) ; } public Path . PathElement createBuildpathElement ( ) { return getBuildpath ( ) . createPathElement ( ) ; } private Path getBuildpath ( ) { if ( buildpath == null ) { buildpath = new Path ( getProject ( ) ) ; } return buildpath ; } public void setBuildpathRef ( Reference r ) { createBuildpath ( ) . setRefid ( r ) ; } private Ant createAntTask ( File directory ) { Ant ant = ( Ant ) getProject ( ) . createTask ( "ant" ) ; ant . setOwningTarget ( getOwningTarget ( ) ) ; ant . setTaskName ( getTaskName ( ) ) ; ant . init ( ) ; if ( target != null && target . length ( ) > 0 ) { ant . setTarget ( target ) ; } if ( output != null ) { ant . setOutput ( output ) ; } if ( directory != null ) { ant . setDir ( directory ) ; } ant . setInheritAll ( inheritAll ) ; for ( Enumeration i = properties . elements ( ) ; i . hasMoreElements ( ) ; ) { copyProperty ( ant . createProperty ( ) , ( Property ) i . nextElement ( ) ) ; } for ( Enumeration i = propertySets . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addPropertyset ( ( PropertySet ) i . nextElement ( ) ) ; } ant . setInheritRefs ( inheritRefs ) ; for ( Enumeration i = references . elements ( ) ; i . hasMoreElements ( ) ; ) { ant . addReference ( ( Ant . Reference ) i . nextElement ( ) ) ; } return ant ; } private static void copyProperty ( Property to , Property from ) { to . setName ( from . getName ( ) ) ; if ( from . getValue ( ) != null ) { to . setValue ( from . getValue ( ) ) ; } if ( from . getFile ( ) != null ) { to . setFile ( from . getFile ( ) ) ; } if ( from . getResource ( ) != null ) { to . setResource ( from . getResource ( ) ) ; } if ( from . getPrefix ( ) != null ) { to . setPrefix ( from . getPrefix ( ) ) ; } if ( from . getRefid ( ) != null ) { to . setRefid ( from . getRefid ( ) ) ; } if ( from . getEnvironment ( ) != null ) { to . setEnvironment ( from . getEnvironment ( ) ) ; } if ( from . getClasspath ( ) != null ) { to . setClasspath ( from . getClasspath ( ) ) ; } } } 	0	['23', '3', '0', '15', '88', '201', '0', '15', '19', '0.847107438', '541', '1', '1', '0.627118644', '0.144927536', '2', '2', '22.04347826', '13', '2.1304', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '16', '1', '0', '15', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Enumeration ; import java . util . Locale ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . PathTokenizer ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Path extends DataType implements Cloneable { private Vector elements ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } public void setPath ( String path ) { parts = Path . translatePath ( getProject ( ) , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { setProject ( project ) ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; setChecked ( false ) ; } public void addFilelist ( FileList fl ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fl ) ; setChecked ( false ) ; } public void addDirset ( DirSet dset ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( dset ) ; setChecked ( false ) ; } public void add ( Path path ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( path ) ; setChecked ( false ) ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( getProject ( ) ) ; elements . addElement ( p ) ; setChecked ( false ) ; return p ; } public void append ( Path other ) { if ( other == null ) { return ; } String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { addExisting ( source , false ) ; } public void addExisting ( Path source , boolean tryUserDir ) { String [ ] list = source . list ( ) ; File userDir = ( tryUserDir ) ? new File ( System . getProperty ( "user.dir" ) ) : null ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( getProject ( ) != null ) { f = getProject ( ) . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( tryUserDir && ! f . exists ( ) ) { f = new File ( userDir , list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } else { log ( "dropping " + f + " from path as it doesn't exist" , Project . MSG_VERBOSE ) ; } } } public String [ ] list ( ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path " + o ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or" + " path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { Path p = ( Path ) o ; if ( p . getProject ( ) == null ) { p . setProject ( getProject ( ) ) ; } String [ ] parts = p . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof DirSet ) { DirSet dset = ( DirSet ) o ; DirectoryScanner ds = dset . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedDirectories ( ) ; File dir = dset . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } else if ( o instanceof FileList ) { FileList fl = ( FileList ) o ; String [ ] s = fl . getFiles ( getProject ( ) ) ; File dir = fl . getDir ( getProject ( ) ) ; addUnlessPresent ( result , dir , s ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) { return "" ; } final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) { return new String [ 0 ] ; } PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String pathElement = tok . nextToken ( ) ; try { element . append ( resolveFile ( project , pathElement ) ) ; } catch ( BuildException e ) { project . log ( "Dropping path element " + pathElement + " as it is not valid relative to the project" , Project . MSG_VERBOSE ) ; } for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; element = new StringBuffer ( ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) { return "" ; } final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { try { Path p = ( Path ) super . clone ( ) ; p . elements = ( Vector ) elements . clone ( ) ; return p ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } Enumeration e = elements . elements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } setChecked ( true ) ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; return f . getAbsolutePath ( ) ; } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } private static void addUnlessPresent ( Vector v , File dir , String [ ] s ) { for ( int j = 0 ; j < s . length ; j ++ ) { File d = new File ( dir , s [ j ] ) ; String absolutePath = d . getAbsolutePath ( ) ; addUnlessPresent ( v , translateFile ( absolutePath ) ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( getProject ( ) ) ; String order = defValue ; if ( getProject ( ) != null ) { String o = getProject ( ) . getProperty ( "build.sysclasspath" ) ; if ( o != null ) { order = o ; } } if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath , true ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath , true ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath , true ) ; } return result ; } public void addJavaRuntime ( ) { if ( "Kaffe" . equals ( System . getProperty ( "java.vm.name" ) ) ) { File kaffeShare = new File ( System . getProperty ( "java.home" ) + File . separator + "share" + File . separator + "kaffe" ) ; if ( kaffeShare . isDirectory ( ) ) { FileSet kaffeJarFiles = new FileSet ( ) ; kaffeJarFiles . setDir ( kaffeShare ) ; kaffeJarFiles . setIncludes ( "*.jar" ) ; addFileset ( kaffeJarFiles ) ; } } if ( System . getProperty ( "java.vendor" ) . toLowerCase ( Locale . US ) . indexOf ( "microsoft" ) >= 0 ) { FileSet msZipFiles = new FileSet ( ) ; msZipFiles . setDir ( new File ( System . getProperty ( "java.home" ) + File . separator + "Packages" ) ) ; msZipFiles . setIncludes ( "*.ZIP" ) ; addFileset ( msZipFiles ) ; } else if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "classes.zip" ) ) ; } else { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + "rt.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "jre" + File . separator + "lib" + File . separator + "rt.jar" ) ) ; String [ ] secJars = { "jce" , "jsse" } ; for ( int i = 0 ; i < secJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + secJars [ i ] + ".jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + secJars [ i ] + ".jar" ) ) ; } String [ ] ibmJars = { "core" , "graphics" , "security" , "server" , "xml" } ; for ( int i = 0 ; i < ibmJars . length ; i ++ ) { addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + "lib" + File . separator + ibmJars [ i ] + ".jar" ) ) ; } addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "classes.jar" ) ) ; addExisting ( new Path ( null , System . getProperty ( "java.home" ) + File . separator + ".." + File . separator + "Classes" + File . separator + "ui.jar" ) ) ; } } public void addExtdirs ( Path extdirs ) { if ( extdirs == null ) { String extProp = System . getProperty ( "java.ext.dirs" ) ; if ( extProp != null ) { extdirs = new Path ( getProject ( ) , extProp ) ; } else { return ; } } String [ ] dirs = extdirs . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { File dir = getProject ( ) . resolveFile ( dirs [ i ] ) ; if ( dir . exists ( ) && dir . isDirectory ( ) ) { FileSet fs = new FileSet ( ) ; fs . setDir ( dir ) ; fs . setIncludes ( "*" ) ; addFileset ( fs ) ; } } } } 	0	['30', '3', '0', '51', '102', '301', '40', '13', '24', '0.603448276', '1238', '0.5', '1', '0.526315789', '0.12183908', '2', '6', '40.2', '15', '2.6333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private final Vector getComments ( ) { return comments ; } public final Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '172', '1', '0', '0.823529412', '0.375', '2', '5', '20.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = nestedTasks . elements ( ) ; e . hasMoreElements ( ) ; ) { Task nestedTask = ( Task ) e . nextElement ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task m_task ; public TaskLogger ( final Task task ) { this . m_task = task ; } public void info ( final String message ) { m_task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { m_task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { m_task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { m_task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { m_task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0	['13', '5', '0', '11', '34', '68', '5', '7', '12', '0.75', '199', '1', '0', '0.837837838', '0.292307692', '2', '8', '14.15384615', '5', '2.1538', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public static final String NAME_KEY = "name" ; public static final String CASE_KEY = "casesensitive" ; public static final String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '10', '23', '0', '5', '5', '8', '0.761904762', '198', '0.5', '0', '0.844444444', '0.35', '1', '4', '23', '6', '2.25', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType type = new FileType ( ) ; type . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( type ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0	['6', '5', '0', '9', '22', '0', '4', '5', '6', '0.6', '105', '0.5', '0', '0.88372093', '0.333333333', '2', '5', '16.16666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; FileInputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '4', '21', '3', '0', '4', '1', '1.5', '144', '1', '0', '0.960784314', '1', '2', '3', '46.66666667', '9', '3.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0	['5', '3', '0', '5', '15', '4', '0', '5', '5', '0.75', '90', '1', '0', '0.902439024', '0.533333333', '0', '0', '16.4', '1', '0.8', '0']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; String [ ] getDeselectedDirectories ( ) ; String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '0', '3', '1', '0', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant ; import java . io . File ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . apache . tools . ant . taskdefs . condition . Os ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) && ! token . startsWith ( "." ) && ! token . startsWith ( ".." ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '17', '0', '2', '1', '3', '0.25', '204', '1', '0', '0', '0.666666667', '0', '0', '65.66666667', '2', '1', '0']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Reference ; public class IsReference extends ProjectComponent implements Condition { private Reference ref ; private String type ; public void setRefid ( Reference r ) { ref = r ; } public void setType ( String type ) { this . type = type ; } public boolean eval ( ) throws BuildException { if ( ref == null ) { throw new BuildException ( "No reference specified for isreference " + "condition" ) ; } Object o = getProject ( ) . getReference ( ref . getRefId ( ) ) ; if ( o == null ) { return false ; } else if ( type == null ) { return true ; } else { Class typeClass = ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( type ) ; if ( typeClass == null ) { typeClass = ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( type ) ; } if ( typeClass == null ) { return false ; } return typeClass . isAssignableFrom ( o . getClass ( ) ) ; } } } 	0	['4', '2', '0', '6', '14', '2', '1', '5', '4', '0.666666667', '68', '1', '1', '0.75', '0.5', '0', '0', '15.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; FileInputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = new FileInputStream ( source ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( bis != null ) { try { bis . close ( ) ; } catch ( IOException ioex ) { } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException ioex ) { } } if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['3', '4', '0', '5', '25', '3', '0', '5', '1', '1.5', '191', '1', '0', '0.960784314', '1', '2', '3', '62.33333333', '13', '4.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitutions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '39', '10', '0', '2', '8', '0.714285714', '308', '1', '0', '0.840909091', '0.325', '1', '1', '37', '4', '1.25', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final void setSkip ( final long skip ) { this . skip = skip ; } private final long getSkip ( ) { return skip ; } public final Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0	['10', '5', '0', '6', '30', '0', '1', '5', '6', '0.688888889', '328', '1', '1', '0.777777778', '0.375', '2', '5', '30.8', '12', '2.3', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public final Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . net . URL ; public class ResourceLocation { private String name = null ; private String publicId = null ; private String location = null ; private URL base = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public void setBase ( URL base ) { this . base = base ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } public URL getBase ( ) { return base ; } } 	0	['7', '1', '1', '5', '8', '3', '5', '0', '7', '0.75', '47', '1', '0', '0', '0.476190476', '0', '0', '5.142857143', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; private static final FileUtils fu = FileUtils . newFileUtils ( ) ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { setDestFile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "webxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! fu . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['10', '6', '0', '10', '33', '35', '0', '10', '6', '0.851851852', '165', '1', '1', '0.950617284', '0.351851852', '3', '9', '15.2', '2', '0.9', '0']
package org . apache . tools . ant . taskdefs ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . HashMap ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class MacroDef extends AntlibDefinition { private NestedSequential nestedSequential ; private String name ; private List attributes = new ArrayList ( ) ; private Map elements = new HashMap ( ) ; public void setName ( String name ) { this . name = name ; } public NestedSequential createSequential ( ) { if ( this . nestedSequential != null ) { throw new BuildException ( "Only one sequential allowed" ) ; } this . nestedSequential = new NestedSequential ( ) ; return this . nestedSequential ; } public static class NestedSequential implements TaskContainer { private List nested = new ArrayList ( ) ; public void addTask ( Task task ) { nested . add ( task ) ; } public List getNested ( ) { return nested ; } public boolean similar ( NestedSequential other ) { if ( nested . size ( ) != other . nested . size ( ) ) { return false ; } for ( int i = 0 ; i < nested . size ( ) ; ++ i ) { UnknownElement me = ( UnknownElement ) nested . get ( i ) ; UnknownElement o = ( UnknownElement ) other . nested . get ( i ) ; if ( ! me . similar ( o ) ) { return false ; } } return true ; } } public UnknownElement getNestedTask ( ) { UnknownElement ret = new UnknownElement ( "sequential" ) ; ret . setTaskName ( "sequential" ) ; ret . setNamespace ( "" ) ; ret . setQName ( "sequential" ) ; new RuntimeConfigurable ( ret , "sequential" ) ; for ( int i = 0 ; i < nestedSequential . getNested ( ) . size ( ) ; ++ i ) { UnknownElement e = ( UnknownElement ) nestedSequential . getNested ( ) . get ( i ) ; ret . addChild ( e ) ; ret . getWrapper ( ) . addChild ( e . getWrapper ( ) ) ; } return ret ; } public List getAttributes ( ) { return attributes ; } public Map getElements ( ) { return elements ; } public static boolean isValidNameCharacter ( char c ) { return Character . isLetterOrDigit ( c ) || c == '.' || c == '-' ; } private static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) { return false ; } for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isValidNameCharacter ( name . charAt ( i ) ) ) { return false ; } } return true ; } public void addConfiguredAttribute ( Attribute attribute ) { if ( attribute . getName ( ) == null ) { throw new BuildException ( "the attribute nested element needed a \"name\" attribute" ) ; } for ( int i = 0 ; i < attributes . size ( ) ; ++ i ) { if ( ( ( Attribute ) attributes . get ( i ) ) . getName ( ) . equals ( attribute . getName ( ) ) ) { throw new BuildException ( "the attribute " + attribute . getName ( ) + " has already been specified" ) ; } } attributes . add ( attribute ) ; } public void addConfiguredElement ( TemplateElement element ) { if ( element . getName ( ) == null ) { throw new BuildException ( "the element nested element needed a \"name\" attribute" ) ; } if ( elements . get ( element . getName ( ) ) != null ) { throw new BuildException ( "the element " + element . getName ( ) + " has already been specified" ) ; } elements . put ( element . getName ( ) , element ) ; } public void execute ( ) { if ( nestedSequential == null ) { throw new BuildException ( "Missing sequential element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; MyAntTypeDefinition def = new MyAntTypeDefinition ( this ) ; def . setName ( name ) ; def . setClass ( MacroInstance . class ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; helper . addDataTypeDefinition ( def ) ; } public static class Attribute { private String name ; private String defaultValue ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setDefault ( String defaultValue ) { this . defaultValue = defaultValue ; } public String getDefault ( ) { return defaultValue ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } Attribute other = ( Attribute ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } if ( defaultValue == null ) { if ( other . defaultValue != null ) { return false ; } } else if ( ! defaultValue . equals ( other . defaultValue ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( defaultValue ) + objectHashCode ( name ) ; } } public static class TemplateElement { private String name ; private boolean optional = false ; public void setName ( String name ) { if ( ! isValidName ( name ) ) { throw new BuildException ( "Illegal name [" + name + "] for attribute" ) ; } this . name = name ; } public String getName ( ) { return name ; } public void setOptional ( boolean optional ) { this . optional = optional ; } public boolean isOptional ( ) { return optional ; } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj . getClass ( ) != getClass ( ) ) { return false ; } TemplateElement other = ( TemplateElement ) obj ; if ( name == null ) { if ( other . name != null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } return optional == other . optional ; } public int hashCode ( ) { return objectHashCode ( name ) + ( optional ? 1 : 0 ) ; } } public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! obj . getClass ( ) . equals ( getClass ( ) ) ) { return false ; } MacroDef other = ( MacroDef ) obj ; if ( name == null ) { return other . name == null ; } if ( ! name . equals ( other . name ) ) { return false ; } if ( getURI ( ) == null || getURI ( ) . equals ( "" ) || getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) { if ( ! ( other . getURI ( ) == null || other . getURI ( ) . equals ( "" ) || other . getURI ( ) . equals ( ProjectHelper . ANT_CORE_URI ) ) ) { return false ; } } else { if ( ! getURI ( ) . equals ( other . getURI ( ) ) ) { return false ; } } if ( ! nestedSequential . similar ( other . nestedSequential ) ) { return false ; } if ( ! attributes . equals ( other . attributes ) ) { return false ; } if ( ! elements . equals ( other . elements ) ) { return false ; } return true ; } public int hashCode ( ) { return objectHashCode ( name ) + objectHashCode ( getURI ( ) ) + objectHashCode ( nestedSequential ) + objectHashCode ( attributes ) + objectHashCode ( elements ) ; } private static class MyAntTypeDefinition extends AntTypeDefinition { private MacroDef macroDef ; public MyAntTypeDefinition ( MacroDef macroDef ) { this . macroDef = macroDef ; } public Object create ( Project project ) { Object o = super . create ( project ) ; if ( o == null ) { return null ; } ( ( MacroInstance ) o ) . setMacroDef ( macroDef ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . sameDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( ! super . similarDefinition ( other , project ) ) { return false ; } MyAntTypeDefinition otherDef = ( MyAntTypeDefinition ) other ; return macroDef . equals ( otherDef . macroDef ) ; } } private static int objectHashCode ( Object o ) { if ( o == null ) { return 0 ; } else { return o . hashCode ( ) ; } } } 	0	['17', '4', '0', '15', '62', '78', '4', '14', '12', '0.8125', '416', '0.8', '1', '0.719298246', '0.205882353', '0', '0', '23.17647059', '16', '2.8235', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '7', '39', '4', '0', '7', '7', '0.714285714', '277', '1', '0', '0.917647059', '0.46875', '4', '4', '32.875', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; public final class LoadProperties extends Task { private File srcFile = null ; private final Vector filterChains = new Vector ( ) ; private String encoding = null ; public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "Source file not defined." ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist." ) ; } if ( ! srcFile . isFile ( ) ) { throw new BuildException ( "Source file is not a file." ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; ByteArrayInputStream tis = null ; try { final long len = srcFile . length ( ) ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; String text = crh . readFully ( instream ) ; if ( text != null ) { if ( ! text . endsWith ( "\n" ) ) { text = text + "\n" ; } if ( encoding == null ) { tis = new ByteArrayInputStream ( text . getBytes ( ) ) ; } else { tis = new ByteArrayInputStream ( text . getBytes ( encoding ) ) ; } final Properties props = new Properties ( ) ; props . load ( tis ) ; Property propertyTask = ( Property ) getProject ( ) . createTask ( "property" ) ; propertyTask . setTaskName ( getTaskName ( ) ) ; propertyTask . addProperties ( props ) ; } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; throw new BuildException ( message , ioe , getLocation ( ) ) ; } catch ( final BuildException be ) { throw be ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } try { if ( tis != null ) { tis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['5', '3', '0', '8', '41', '0', '0', '8', '5', '0.5', '230', '1', '0', '0.902439024', '0.4', '2', '2', '44.4', '1', '0.8', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public class HashvalueAlgorithm implements Algorithm { public boolean isValid ( ) { return true ; } public String getValue ( File file ) { try { if ( ! file . canRead ( ) ) { return null ; } java . io . FileInputStream fis = new java . io . FileInputStream ( file ) ; byte [ ] content = new byte [ fis . available ( ) ] ; fis . read ( content ) ; fis . close ( ) ; String s = new String ( content ) ; int hash = s . hashCode ( ) ; return Integer . toString ( hash ) ; } catch ( Exception e ) { return null ; } } public String toString ( ) { return "HashvalueAlgorithm" ; } } 	0	['4', '1', '0', '1', '13', '6', '0', '1', '4', '2', '45', '0', '0', '0', '0.625', '0', '0', '10.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import sun . misc . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0	['2', '3', '0', '4', '15', '1', '0', '4', '0', '2', '59', '0', '0', '0.952380952', '0.666666667', '1', '1', '28.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class MatchingTask extends Task implements SelectorContainer { protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { fileset . setDefaultexcludes ( useDefaultExcludes ) ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; return fileset . getDirectoryScanner ( getProject ( ) ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { fileset . addContainsRegexp ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { fileset . addDifferent ( selector ) ; } public void addType ( TypeSelector selector ) { fileset . addType ( selector ) ; } public void addModified ( ModifiedSelector selector ) { fileset . addModified ( selector ) ; } public void add ( FileSelector selector ) { fileset . add ( selector ) ; } protected final FileSet getImplicitFileSet ( ) { return fileset ; } } 	0	['42', '3', '11', '39', '96', '0', '11', '28', '40', '0', '328', '1', '1', '0.474358974', '0.073412698', '2', '2', '6.785714286', '6', '1.1667', '0']
package org . apache . tools . ant . types ; public class DTDLocation extends ResourceLocation { } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { } 	0	['1', '6', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . types . resolver ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogEntry ; import org . apache . xml . resolver . helpers . PublicId ; public class ApacheCatalog extends Catalog { private ApacheCatalogResolver resolver = null ; protected Catalog newCatalog ( ) { ApacheCatalog cat = ( ApacheCatalog ) super . newCatalog ( ) ; cat . setResolver ( resolver ) ; return cat ; } public void setResolver ( ApacheCatalogResolver resolver ) { this . resolver = resolver ; } public void addEntry ( CatalogEntry entry ) { int type = entry . getEntryType ( ) ; if ( type == PUBLIC ) { String publicid = PublicId . normalize ( entry . getEntryArg ( 0 ) ) ; String systemid = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addPublicEntry ( publicid , systemid , base ) ; } } else if ( type == URI ) { String uri = normalizeURI ( entry . getEntryArg ( 0 ) ) ; String altURI = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addURIEntry ( uri , altURI , base ) ; } } super . addEntry ( entry ) ; } } 	0	['4', '2', '0', '6', '14', '0', '1', '6', '3', '0', '96', '1', '1', '0.916666667', '0.5', '1', '3', '22.75', '5', '1.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . InputStream ; import java . io . StringReader ; public class StringInputStream extends InputStream { private StringReader in ; private String encoding ; private byte [ ] slack ; private int begin ; public StringInputStream ( String source ) { in = new StringReader ( source ) ; } public StringInputStream ( String source , String encoding ) { in = new StringReader ( source ) ; this . encoding = encoding ; } public synchronized int read ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } byte result ; if ( slack != null && begin < slack . length ) { result = slack [ begin ] ; if ( ++ begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) <= 0 ) { return - 1 ; } result = buf [ 0 ] ; } if ( result < 0 ) { return 256 + result ; } else { return result ; } } public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } while ( slack == null ) { char [ ] buf = new char [ len ] ; int n = in . read ( buf ) ; if ( n == - 1 ) { return - 1 ; } if ( n > 0 ) { String s = new String ( buf , 0 , n ) ; if ( encoding == null ) { slack = s . getBytes ( ) ; } else { slack = s . getBytes ( encoding ) ; } begin = 0 ; } } if ( len > slack . length - begin ) { len = slack . length - begin ; } System . arraycopy ( slack , begin , b , off , len ) ; if ( ( begin += len ) >= slack . length ) { slack = null ; } return len ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized int available ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( slack != null ) { return slack . length - begin ; } if ( in . ready ( ) ) { return 1 ; } else { return 0 ; } } public boolean markSupported ( ) { return false ; } public synchronized void reset ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } slack = null ; in . reset ( ) ; } public synchronized void close ( ) throws IOException { in . close ( ) ; slack = null ; in = null ; } } 	0	['9', '2', '0', '0', '23', '0', '0', '0', '9', '0.53125', '250', '1', '0', '0.5625', '0.388888889', '1', '2', '26.33333333', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; import java . util . TimeZone ; class ChangeLogWriter { private static final SimpleDateFormat c_outputDate = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat c_outputTime = new SimpleDateFormat ( "HH:mm" ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; c_outputDate . setTimeZone ( utc ) ; c_outputTime . setTimeZone ( utc ) ; } public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; output . println ( "<changelog>" ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( output , entry ) ; } output . println ( "</changelog>" ) ; output . flush ( ) ; output . close ( ) ; } private void printEntry ( final PrintWriter output , final CVSEntry entry ) { output . println ( "\t<entry>" ) ; output . println ( "\t\t<date>" + c_outputDate . format ( entry . getDate ( ) ) + "</date>" ) ; output . println ( "\t\t<time>" + c_outputTime . format ( entry . getDate ( ) ) + "</time>" ) ; output . println ( "\t\t<author><![CDATA[" + entry . getAuthor ( ) + "]]></author>" ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; output . println ( "\t\t<file>" ) ; output . println ( "\t\t\t<name>" + file . getName ( ) + "</name>" ) ; output . println ( "\t\t\t<revision>" + file . getRevision ( ) + "</revision>" ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { output . println ( "\t\t\t<prevrevision>" + previousRevision + "</prevrevision>" ) ; } output . println ( "\t\t</file>" ) ; } output . println ( "\t\t<msg><![CDATA[" + entry . getComment ( ) + "]]></msg>" ) ; output . println ( "\t</entry>" ) ; } } 	0	['4', '1', '0', '3', '25', '4', '1', '2', '1', '0.333333333', '183', '1', '0', '0', '0.583333333', '0', '0', '44.25', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private File myFile ; public void setFile ( final File file ) { myFile = file ; } public void execute ( ) throws BuildException { File savedFile = myFile ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( myFile ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . store ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + myFile ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing output stream " + ioe , Project . MSG_ERR ) ; } } myFile = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = myFile + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( myFile ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { getProject ( ) . log ( "error closing input stream " + ioe , Project . MSG_ERR ) ; } } } } private void validate ( ) throws BuildException { if ( null == myFile ) { myFile = getProject ( ) . resolveFile ( DEFAULT_FILENAME ) ; } if ( ! myFile . exists ( ) ) { try { FileUtils . newFileUtils ( ) . createNewFile ( myFile ) ; } catch ( final IOException ioe ) { final String message = myFile + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! myFile . canRead ( ) ) { final String message = "Unable to read from " + myFile + "." ; throw new BuildException ( message ) ; } if ( ! myFile . canWrite ( ) ) { final String message = "Unable to write to " + myFile + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '3', '0', '5', '35', '0', '0', '5', '3', '0.866666667', '300', '1', '0', '0.880952381', '0.444444444', '1', '1', '48.5', '1', '0.8333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '1', '35', '11', '4', '33', '2', '5', '0.25', '54', '1', '0', '0', '0.533333333', '0', '0', '9.6', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean defaultSetDefined = false ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; super . setSkipEmptyFilesets ( true ) ; } public void setProject ( Project project ) { super . setProject ( project ) ; defaultSet . setProject ( project ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setFile ( src ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { defaultSetDefined = true ; return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { defaultSetDefined = true ; return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { defaultSetDefined = true ; return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSetDefined = true ; defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSetDefined = true ; defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSetDefined = true ; defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , getLocation ( ) ) ; } if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void execute ( ) throws BuildException { if ( defaultSetDefined || defaultSet . getDir ( getProject ( ) ) == null ) { try { super . execute ( ) ; } finally { if ( defaultSetDefined && defaultSet . getDir ( getProject ( ) ) != null ) { filesets . removeElement ( defaultSet ) ; } } } else if ( isValidOs ( ) ) { Execute execute = prepareExec ( ) ; Commandline cloned = ( Commandline ) cmdl . clone ( ) ; cloned . createArgument ( ) . setValue ( defaultSet . getDir ( getProject ( ) ) . getPath ( ) ) ; try { execute . setCommandline ( cloned . getCommandline ( ) ) ; runExecute ( execute ) ; } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , getLocation ( ) ) ; } finally { logFlush ( ) ; } } } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable attribute" , getLocation ( ) ) ; } public void setCommand ( Commandline cmdl ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the command attribute" , getLocation ( ) ) ; } public void setSkipEmptyFilesets ( boolean skip ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the skipemptyfileset attribute" , getLocation ( ) ) ; } public void setAddsourcefile ( boolean b ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the addsourcefile attribute" , getLocation ( ) ) ; } protected boolean isValidOs ( ) { return Os . isFamily ( "unix" ) && super . isValidOs ( ) ; } } 	0	['18', '5', '0', '15', '58', '39', '0', '15', '16', '0.607843137', '316', '1', '1', '0.862903226', '0.268518519', '4', '7', '16.38888889', '4', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0	['5', '3', '3', '8', '12', '2', '6', '2', '5', '0.625', '49', '1', '0', '0.902439024', '0.466666667', '0', '0', '8.4', '1', '0.8', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; import org . apache . tools . ant . ProjectComponent ; public class LineTokenizer extends ProjectComponent implements Tokenizer { private String lineEnd = "" ; private int pushed = - 2 ; private boolean includeDelims = false ; public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } lineEnd = "" ; StringBuffer line = new StringBuffer ( ) ; int state = 0 ; while ( ch != - 1 ) { if ( state == 0 ) { if ( ch == '\r' ) { state = 1 ; } else if ( ch == '\n' ) { lineEnd = "\n" ; break ; } else { line . append ( ( char ) ch ) ; } } else { state = 0 ; if ( ch == '\n' ) { lineEnd = "\r\n" ; } else { pushed = ch ; lineEnd = "\r" ; } break ; } ch = in . read ( ) ; } if ( ch == - 1 && state == 1 ) { lineEnd = "\r" ; } if ( includeDelims ) { line . append ( lineEnd ) ; } return line . toString ( ) ; } public String getPostToken ( ) { if ( includeDelims ) { return "" ; } return lineEnd ; } } 	0	['4', '2', '0', '6', '10', '0', '4', '2', '4', '0.333333333', '125', '1', '0', '0.75', '0.5', '0', '0', '29.5', '2', '1', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; public class TaskAdapter extends Task implements TypeAdapter { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { try { final Method executeM = taskClass . getMethod ( "execute" , null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } } public void checkProxyClass ( Class proxyClass ) { checkTaskClass ( proxyClass , getProject ( ) ) ; } public void execute ( ) throws BuildException { Method setProjectM = null ; try { Class c = proxy . getClass ( ) ; setProjectM = c . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { getProject ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No public execute() in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No public execute() in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( java . lang . reflect . InvocationTargetException ie ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return proxy ; } } 	0	['7', '3', '0', '6', '26', '15', '2', '5', '6', '0.833333333', '237', '0.5', '0', '0.860465116', '0.285714286', '1', '1', '32.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class DefaultRmicAdapter implements RmicAdapter { private Rmic attributes ; private FileNameMapper mapper ; private static final Random rand = new Random ( ) ; public DefaultRmicAdapter ( ) { } public void setRmic ( Rmic attributes ) { this . attributes = attributes ; mapper = new RmicFileNameMapper ( ) ; } public Rmic getRmic ( ) { return attributes ; } protected String getStubClassSuffix ( ) { return "_Stub" ; } protected String getSkelClassSuffix ( ) { return "_Skel" ; } protected String getTieClassSuffix ( ) { return "_Tie" ; } public FileNameMapper getMapper ( ) { return mapper ; } public Path getClasspath ( ) { return getCompileClasspath ( ) ; } protected Path getCompileClasspath ( ) { Path classpath = new Path ( attributes . getProject ( ) ) ; classpath . setLocation ( attributes . getBase ( ) ) ; Path cp = attributes . getClasspath ( ) ; if ( cp == null ) { cp = new Path ( attributes . getProject ( ) ) ; } if ( attributes . getIncludeantruntime ( ) ) { classpath . addExisting ( cp . concatSystemClasspath ( "last" ) ) ; } else { classpath . addExisting ( cp . concatSystemClasspath ( "ignore" ) ) ; } if ( attributes . getIncludejavaruntime ( ) ) { classpath . addJavaRuntime ( ) ; } return classpath ; } protected Commandline setupRmicCommand ( ) { return setupRmicCommand ( null ) ; } protected Commandline setupRmicCommand ( String [ ] options ) { Commandline cmd = new Commandline ( ) ; if ( options != null ) { for ( int i = 0 ; i < options . length ; i ++ ) { cmd . createArgument ( ) . setValue ( options [ i ] ) ; } } Path classpath = getCompileClasspath ( ) ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( attributes . getBase ( ) ) ; if ( attributes . getExtdirs ( ) != null ) { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { classpath . addExtdirs ( attributes . getExtdirs ( ) ) ; } else { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( attributes . getExtdirs ( ) ) ; } } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; String stubVersion = attributes . getStubVersion ( ) ; if ( null != stubVersion ) { if ( "1.1" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.1" ) ; } else if ( "1.2" . equals ( stubVersion ) ) { cmd . createArgument ( ) . setValue ( "-v1.2" ) ; } else { cmd . createArgument ( ) . setValue ( "-vcompat" ) ; } } if ( null != attributes . getSourceBase ( ) ) { cmd . createArgument ( ) . setValue ( "-keepgenerated" ) ; } if ( attributes . getIiop ( ) ) { attributes . log ( "IIOP has been turned on." , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( "-iiop" ) ; if ( attributes . getIiopopts ( ) != null ) { attributes . log ( "IIOP Options: " + attributes . getIiopopts ( ) , Project . MSG_INFO ) ; cmd . createArgument ( ) . setValue ( attributes . getIiopopts ( ) ) ; } } if ( attributes . getIdl ( ) ) { cmd . createArgument ( ) . setValue ( "-idl" ) ; attributes . log ( "IDL has been turned on." , Project . MSG_INFO ) ; if ( attributes . getIdlopts ( ) != null ) { cmd . createArgument ( ) . setValue ( attributes . getIdlopts ( ) ) ; attributes . log ( "IDL Options: " + attributes . getIdlopts ( ) , Project . MSG_INFO ) ; } } if ( attributes . getDebug ( ) ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } cmd . addArguments ( attributes . getCurrentCompilerArgs ( ) ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { Vector compileList = attributes . getCompileList ( ) ; attributes . log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; for ( int i = 0 ; i < compileList . size ( ) ; i ++ ) { String arg = ( String ) compileList . elementAt ( i ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " + arg ) ; } attributes . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } private class RmicFileNameMapper implements FileNameMapper { RmicFileNameMapper ( ) { } public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String name ) { if ( name == null || ! name . endsWith ( ".class" ) || name . endsWith ( getStubClassSuffix ( ) + ".class" ) || name . endsWith ( getSkelClassSuffix ( ) + ".class" ) || name . endsWith ( getTieClassSuffix ( ) + ".class" ) ) { return null ; } String base = name . substring ( 0 , name . length ( ) - 6 ) ; String classname = base . replace ( File . separatorChar , '.' ) ; if ( attributes . getVerify ( ) && ! attributes . isValidRmiRemote ( classname ) ) { return null ; } String [ ] target = new String [ ] { name + ".tmp." + rand . nextLong ( ) } ; if ( ! attributes . getIiop ( ) && ! attributes . getIdl ( ) ) { if ( "1.2" . equals ( attributes . getStubVersion ( ) ) ) { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" } ; } else { target = new String [ ] { base + getStubClassSuffix ( ) + ".class" , base + getSkelClassSuffix ( ) + ".class" , } ; } } else if ( ! attributes . getIdl ( ) ) { int lastSlash = base . lastIndexOf ( File . separatorChar ) ; String dirname = "" ; int index = - 1 ; if ( lastSlash == - 1 ) { index = 0 ; } else { index = lastSlash + 1 ; dirname = base . substring ( 0 , index ) ; } String filename = base . substring ( index ) ; try { Class c = attributes . getLoader ( ) . loadClass ( classname ) ; if ( c . isInterface ( ) ) { target = new String [ ] { dirname + "_" + filename + getStubClassSuffix ( ) + ".class" } ; } else { Class interf = attributes . getRemoteInterface ( c ) ; String iName = interf . getName ( ) ; String iDir = "" ; int iIndex = - 1 ; int lastDot = iName . lastIndexOf ( "." ) ; if ( lastDot == - 1 ) { iIndex = 0 ; } else { iIndex = lastDot + 1 ; iDir = iName . substring ( 0 , iIndex ) ; iDir = iDir . replace ( '.' , File . separatorChar ) ; } target = new String [ ] { dirname + "_" + filename + getTieClassSuffix ( ) + ".class" , iDir + "_" + iName . substring ( iIndex ) + getStubClassSuffix ( ) + ".class" } ; } } catch ( ClassNotFoundException e ) { attributes . log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { attributes . log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { attributes . log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } return target ; } } } 	0	['16', '1', '3', '15', '56', '86', '4', '12', '6', '0.8', '372', '1', '2', '0', '0.226666667', '0', '0', '22.0625', '14', '2', '0']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public final void setName ( final String name ) { this . name = name ; } public final void setType ( final String type ) { this . type = type ; } public final void setValue ( final String value ) { this . value = value ; } public final String getName ( ) { return name ; } public final String getType ( ) { return type ; } public final String getValue ( ) { return value ; } } 	0	['7', '1', '0', '24', '8', '3', '24', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is " + "not available.  A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '20', '3', '1', '7', '2', '1', '151', '0', '0', '0.92', '0.5', '0', '0', '48.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; public class FileSet extends AbstractFileSet { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	0	['3', '4', '3', '32', '9', '3', '28', '4', '2', '2', '23', '0', '0', '0.988636364', '0.666666667', '3', '4', '6.666666667', '2', '0.6667', '0']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) ; } } 	0	['3', '2', '0', '3', '8', '0', '2', '1', '3', '0', '32', '1', '0', '0.75', '0.555555556', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['31', '1', '0', '5', '68', '407', '2', '3', '13', '0.904761905', '624', '0.904761905', '2', '0', '0.316129032', '0', '0', '18.4516129', '11', '1.4516', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Hashtable ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean crSeen = false ; } private static final int MAX_SIZE = 1024 ; private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private Hashtable buffers = new Hashtable ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; bufferInfo . crSeen = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . crSeen = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( c == '\n' ) { bufferInfo . buffer . write ( cc ) ; processBuffer ( bufferInfo . buffer ) ; } else { if ( bufferInfo . crSeen ) { processBuffer ( bufferInfo . buffer ) ; } bufferInfo . buffer . write ( cc ) ; } bufferInfo . crSeen = ( c == '\r' ) ; if ( ! bufferInfo . crSeen && bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } protected void processFlush ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxFlush ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processFlush ( bufferInfo . buffer ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; BufferInfo bufferInfo = getBufferInfo ( ) ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { bufferInfo . buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['10', '2', '0', '4', '30', '27', '1', '3', '5', '0.761904762', '252', '1', '1', '0.357142857', '0.283333333', '1', '1', '23.5', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class DifferentSelector extends MappingSelector { private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private boolean ignoreFileTimes = true ; public void setIgnoreFileTimes ( boolean ignoreFileTimes ) { this . ignoreFileTimes = ignoreFileTimes ; } protected boolean selectionTest ( File srcfile , File destfile ) { if ( srcfile . exists ( ) != destfile . exists ( ) ) { return true ; } if ( srcfile . length ( ) != destfile . length ( ) ) { return true ; } if ( ! ignoreFileTimes ) { boolean sameDate ; sameDate = destfile . lastModified ( ) >= srcfile . lastModified ( ) - granularity && destfile . lastModified ( ) <= srcfile . lastModified ( ) + granularity ; if ( ! sameDate ) { return true ; } } try { return ! fileUtils . contentEquals ( srcfile , destfile ) ; } catch ( IOException e ) { throw new BuildException ( "while comparing " + srcfile + " and " + destfile , e ) ; } } } 	0	['3', '5', '0', '7', '14', '0', '4', '3', '2', '0.25', '92', '1', '1', '0.953488372', '0.555555556', '1', '1', '29', '8', '3', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { void buildStarted ( BuildEvent event ) ; void buildFinished ( BuildEvent event ) ; void targetStarted ( BuildEvent event ) ; void targetFinished ( BuildEvent event ) ; void taskStarted ( BuildEvent event ) ; void taskFinished ( BuildEvent event ) ; void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '9', '7', '21', '8', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . net . URL ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . helper . ProjectHelper2 ; import org . apache . tools . ant . UnknownElement ; public class Antlib extends Task implements TaskContainer { public static final String TAG = "antlib" ; public static Antlib createAntlib ( Project project , URL antlibUrl , String uri ) { try { antlibUrl . openConnection ( ) . connect ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to find " + antlibUrl , ex ) ; } ComponentHelper helper = ComponentHelper . getComponentHelper ( project ) ; helper . enterAntLib ( uri ) ; try { ProjectHelper2 parser = new ProjectHelper2 ( ) ; UnknownElement ue = parser . parseUnknownElement ( project , antlibUrl ) ; if ( ! ( ue . getTag ( ) . equals ( TAG ) ) ) { throw new BuildException ( "Unexpected tag " + ue . getTag ( ) + " expecting " + TAG , ue . getLocation ( ) ) ; } Antlib antlib = new Antlib ( ) ; antlib . setProject ( project ) ; antlib . setLocation ( ue . getLocation ( ) ) ; antlib . init ( ) ; ue . configure ( antlib ) ; return antlib ; } finally { helper . exitAntLib ( ) ; } } private ClassLoader classLoader ; private String uri = "" ; private List tasks = new ArrayList ( ) ; protected void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } protected void setURI ( String uri ) { this . uri = uri ; } private ClassLoader getClassLoader ( ) { if ( classLoader == null ) { classLoader = Antlib . class . getClassLoader ( ) ; } return classLoader ; } public void addTask ( Task nestedTask ) { tasks . add ( nestedTask ) ; } public void execute ( ) { for ( Iterator i = tasks . iterator ( ) ; i . hasNext ( ) ; ) { UnknownElement ue = ( UnknownElement ) i . next ( ) ; setLocation ( ue . getLocation ( ) ) ; ue . maybeConfigure ( ) ; Object configuredObject = ue . getRealThing ( ) ; if ( configuredObject == null ) { continue ; } if ( ! ( configuredObject instanceof AntlibDefinition ) ) { throw new BuildException ( "Invalid task in antlib " + ue . getTag ( ) + " " + configuredObject . getClass ( ) + " does not " + "extend org.apache.tools.ant.taskdefs.AntlibDefinition" ) ; } AntlibDefinition def = ( AntlibDefinition ) configuredObject ; def . setURI ( uri ) ; def . setAntlibClassLoader ( getClassLoader ( ) ) ; def . init ( ) ; def . execute ( ) ; } } } 	0	['8', '3', '0', '11', '45', '16', '1', '10', '4', '0.771428571', '216', '0.6', '0', '0.840909091', '0.270833333', '1', '1', '25.375', '4', '1.875', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String m_userID ; private String m_displayName ; public void setDisplayname ( final String displayName ) { m_displayName = displayName ; } public void setUserid ( final String userID ) { m_userID = userID ; } String getUserID ( ) { return m_userID ; } String getDisplayname ( ) { return m_displayName ; } void validate ( ) throws BuildException { if ( null == m_userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == m_displayName ) { final String message = "Displayname attribute must be set for userID " + m_userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '3', '0.6', '56', '1', '0', '0', '0.666666667', '0', '0', '8', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '5', '15', '1', '0', '5', '1', '2', '67', '0', '0', '0.980392157', '1', '1', '2', '32.5', '4', '2', '0']
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0	['5', '1', '0', '7', '5', '10', '6', '1', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { super ( "ProcessDestroyer Shutdown Hook" ) ; } public void run ( ) { if ( shouldDestroy ) { ProcessDestroyer . this . run ( ) ; } } public void setShouldDestroy ( boolean shouldDestroy ) { this . shouldDestroy = shouldDestroy ; } } public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; addShutdownHookMethod = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; removeShutdownHookMethod = Runtime . class . getMethod ( "removeShutdownHook" , paramTypes ) ; } catch ( NoSuchMethodException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void addShutdownHook ( ) { if ( addShutdownHookMethod != null ) { destroyProcessThread = new ProcessDestroyerImpl ( ) ; Object [ ] args = { destroyProcessThread } ; try { addShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; added = true ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } private void removeShutdownHook ( ) { if ( removeShutdownHookMethod != null && destroyProcessThread != null ) { Object [ ] args = { destroyProcessThread } ; try { Boolean removed = ( Boolean ) removeShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; if ( ! removed . booleanValue ( ) ) { System . err . println ( "Could not remove shutdown hook" ) ; } destroyProcessThread . setShouldDestroy ( false ) ; destroyProcessThread . start ( ) ; try { destroyProcessThread . join ( 20000 ) ; } catch ( InterruptedException ie ) { } destroyProcessThread = null ; added = false ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } } public boolean isAddedAsShutdownHook ( ) { return added ; } public boolean add ( Process process ) { synchronized ( processes ) { if ( processes . size ( ) == 0 ) { addShutdownHook ( ) ; } processes . addElement ( process ) ; return processes . contains ( process ) ; } } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( processes . size ( ) == 0 ) { processes . notifyAll ( ) ; removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { synchronized ( processes ) { Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } try { processes . wait ( ) ; } catch ( InterruptedException interrupt ) { } } } } 	0	['8', '1', '0', '2', '33', '4', '2', '1', '5', '0.673469388', '269', '0.714285714', '1', '0', '0.416666667', '0', '0', '31.75', '4', '1.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '14', '26', '0', '5', '9', '7', '0.458333333', '199', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.85714286', '5', '2.5714', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '6', '13', '0', '5', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . JavaEnvUtils ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) getProject ( ) . createTask ( "exec" ) ; cmd . setExecutable ( "keytool" ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '8', '34', '65', '0', '8', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '1', '2', '27', '2', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0	['7', '1', '0', '2', '7', '21', '2', '0', '7', '2', '7', '0', '0', '0', '0.642857143', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class EmailTask extends Task { public static final String AUTO = "auto" ; public static final String MIME = "mime" ; public static final String UU = "uu" ; public static final String PLAIN = "plain" ; public static class Encoding extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { AUTO , MIME , UU , PLAIN } ; } } private String encoding = AUTO ; private String host = "localhost" ; private int port = 25 ; private String subject = null ; private Message message = null ; private boolean failOnError = true ; private boolean includeFileNames = false ; private String messageMimeType = null ; private EmailAddress from = null ; private Vector replyToList = new Vector ( ) ; private Vector toList = new Vector ( ) ; private Vector ccList = new Vector ( ) ; private Vector bccList = new Vector ( ) ; private Vector files = new Vector ( ) ; private Vector filesets = new Vector ( ) ; private String charset = null ; private String user = null ; private String password = null ; private boolean SSL = false ; public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean SSL ) { this . SSL = SSL ; } public void setEncoding ( Encoding encoding ) { this . encoding = encoding . getValue ( ) ; } public void setMailport ( int port ) { this . port = port ; } public void setMailhost ( String host ) { this . host = host ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setMessage ( String message ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( message ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageFile ( File file ) { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = new Message ( file ) ; this . message . setProject ( getProject ( ) ) ; } public void setMessageMimeType ( String type ) { this . messageMimeType = type ; } public void addMessage ( Message message ) throws BuildException { if ( this . message != null ) { throw new BuildException ( "Only one message can be sent in an " + "email" ) ; } this . message = message ; } public void addFrom ( EmailAddress address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = address ; } public void setFrom ( String address ) { if ( this . from != null ) { throw new BuildException ( "Emails can only be from one address" ) ; } this . from = new EmailAddress ( address ) ; } public void addReplyTo ( EmailAddress address ) { this . replyToList . add ( address ) ; } public void setReplyTo ( String address ) { this . replyToList . add ( new EmailAddress ( address ) ) ; } public void addTo ( EmailAddress address ) { toList . addElement ( address ) ; } public void setToList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { toList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addCc ( EmailAddress address ) { ccList . addElement ( address ) ; } public void setCcList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { ccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void addBcc ( EmailAddress address ) { bccList . addElement ( address ) ; } public void setBccList ( String list ) { StringTokenizer tokens = new StringTokenizer ( list , "," ) ; while ( tokens . hasMoreTokens ( ) ) { bccList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setFiles ( String filenames ) { StringTokenizer t = new StringTokenizer ( filenames , ", " ) ; while ( t . hasMoreTokens ( ) ) { files . addElement ( getProject ( ) . resolveFile ( t . nextToken ( ) ) ) ; } } public void addFileset ( FileSet fs ) { filesets . addElement ( fs ) ; } public void setIncludefilenames ( boolean includeFileNames ) { this . includeFileNames = includeFileNames ; } public boolean getIncludeFileNames ( ) { return includeFileNames ; } public void execute ( ) { Message savedMessage = message ; Vector savedFiles = ( Vector ) files . clone ( ) ; try { Mailer mailer = null ; boolean autoFound = false ; if ( encoding . equals ( MIME ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using MIME mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } if ( autoFound == false && ( ( user != null ) || ( password != null ) ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SMTP auth only possible with MIME mail" ) ; } if ( autoFound == false && ( SSL ) && ( encoding . equals ( UU ) || encoding . equals ( PLAIN ) ) ) { throw new BuildException ( "SSL only possible with MIME mail" ) ; } if ( encoding . equals ( UU ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.UUMailer" ) . newInstance ( ) ; autoFound = true ; log ( "Using UU mail" , Project . MSG_VERBOSE ) ; } catch ( Throwable e ) { log ( "Failed to initialise UU mail" , Project . MSG_WARN ) ; } } if ( encoding . equals ( PLAIN ) || ( encoding . equals ( AUTO ) && ! autoFound ) ) { mailer = new PlainMailer ( ) ; autoFound = true ; log ( "Using plain mail" , Project . MSG_VERBOSE ) ; } if ( mailer == null ) { throw new BuildException ( "Failed to initialise encoding: " + encoding ) ; } if ( message == null ) { message = new Message ( ) ; message . setProject ( getProject ( ) ) ; } if ( from == null || from . getAddress ( ) == null ) { throw new BuildException ( "A from element is required" ) ; } if ( toList . isEmpty ( ) && ccList . isEmpty ( ) && bccList . isEmpty ( ) ) { throw new BuildException ( "At least one of to,cc or bcc must " + "be supplied" ) ; } if ( messageMimeType != null ) { if ( message . isMimeTypeSpecified ( ) ) { throw new BuildException ( "The mime type can only be " + "specified in one location" ) ; } else { message . setMimeType ( messageMimeType ) ; } } if ( charset != null ) { if ( message . getCharset ( ) != null ) { throw new BuildException ( "The charset can only be " + "specified in one location" ) ; } else { message . setCharset ( charset ) ; } } Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] includedFiles = ds . getIncludedFiles ( ) ; File baseDir = ds . getBasedir ( ) ; for ( int j = 0 ; j < includedFiles . length ; ++ j ) { File file = new File ( baseDir , includedFiles [ j ] ) ; files . addElement ( file ) ; } } log ( "Sending email: " + subject , Project . MSG_INFO ) ; log ( "From " + from , Project . MSG_VERBOSE ) ; log ( "ReplyTo " + replyToList , Project . MSG_VERBOSE ) ; log ( "To " + toList , Project . MSG_VERBOSE ) ; log ( "Cc " + ccList , Project . MSG_VERBOSE ) ; log ( "Bcc " + bccList , Project . MSG_VERBOSE ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( SSL ) ; mailer . setMessage ( message ) ; mailer . setFrom ( from ) ; mailer . setReplyToList ( replyToList ) ; mailer . setToList ( toList ) ; mailer . setCcList ( ccList ) ; mailer . setBccList ( bccList ) ; mailer . setFiles ( files ) ; mailer . setSubject ( subject ) ; mailer . setTask ( this ) ; mailer . setIncludeFileNames ( includeFileNames ) ; mailer . send ( ) ; int count = files . size ( ) ; log ( "Sent email with " + count + " attachment" + ( count == 1 ? "" : "s" ) , Project . MSG_INFO ) ; } catch ( BuildException e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw e ; } } catch ( Exception e ) { log ( "Failed to send email" , Project . MSG_WARN ) ; if ( failOnError ) { throw new BuildException ( e ) ; } } finally { message = savedMessage ; files = savedFiles ; } } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['30', '3', '1', '14', '89', '301', '1', '13', '30', '0.935532234', '844', '0.826086957', '2', '0.560606061', '0.207407407', '3', '3', '26.36666667', '39', '2.5', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '2', '5', '15', '0', '4', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String m_name ; private String m_revision ; private String m_previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { m_name = name ; m_revision = revision ; if ( ! revision . equals ( previousRevision ) ) { m_previousRevision = previousRevision ; } } String getName ( ) { return m_name ; } String getRevision ( ) { return m_revision ; } String getPreviousRevision ( ) { return m_previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . Writer ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Enumeration ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XmlLogger implements BuildLogger { private int msgOutputLevel = Project . MSG_DEBUG ; private PrintStream outStream ; private static DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private static final String STACKTRACE_TAG = "stacktrace" ; private Document doc = builder . newDocument ( ) ; private Hashtable tasks = new Hashtable ( ) ; private Hashtable targets = new Hashtable ( ) ; private Hashtable threadStacks = new Hashtable ( ) ; private TimedElement buildElement = null ; private static class TimedElement { private long startTime ; private Element element ; } public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildElement = new TimedElement ( ) ; buildElement . startTime = System . currentTimeMillis ( ) ; buildElement . element = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildElement . startTime ; buildElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . element . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; Throwable t = event . getException ( ) ; Text errText = doc . createCDATASection ( StringUtils . getStackTrace ( t ) ) ; Element stacktrace = doc . createElement ( STACKTRACE_TAG ) ; stacktrace . appendChild ( errText ) ; buildElement . element . appendChild ( stacktrace ) ; } String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } String xslUri = event . getProject ( ) . getProperty ( "ant.XmlLogger.stylesheet.uri" ) ; if ( xslUri == null ) { xslUri = "log.xsl" ; } Writer out = null ; try { OutputStream stream = outStream ; if ( stream == null ) { stream = new FileOutputStream ( outFilename ) ; } out = new OutputStreamWriter ( stream , "UTF8" ) ; out . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; if ( xslUri . length ( ) > 0 ) { out . write ( "<?xml-stylesheet type=\"text/xsl\" href=\"" + xslUri + "\"?>\n\n" ) ; } ( new DOMElementWriter ( ) ) . write ( buildElement . element , out , 0 , "\t" ) ; out . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } buildElement = null ; } private Stack getStack ( ) { Stack threadStack = ( Stack ) threadStacks . get ( Thread . currentThread ( ) ) ; if ( threadStack == null ) { threadStack = new Stack ( ) ; threadStacks . put ( Thread . currentThread ( ) , threadStack ) ; } return threadStack ; } public void targetStarted ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = new TimedElement ( ) ; targetElement . startTime = System . currentTimeMillis ( ) ; targetElement . element = doc . createElement ( TARGET_TAG ) ; targetElement . element . setAttribute ( NAME_ATTR , target . getName ( ) ) ; targets . put ( target , targetElement ) ; getStack ( ) . push ( targetElement ) ; } public void targetFinished ( BuildEvent event ) { Target target = event . getTarget ( ) ; TimedElement targetElement = ( TimedElement ) targets . get ( target ) ; if ( targetElement != null ) { long totalTime = System . currentTimeMillis ( ) - targetElement . startTime ; targetElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; TimedElement parentElement = null ; Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != targetElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished target element = " + targetElement . element ) ; } if ( ! threadStack . empty ( ) ) { parentElement = ( TimedElement ) threadStack . peek ( ) ; } } if ( parentElement == null ) { buildElement . element . appendChild ( targetElement . element ) ; } else { parentElement . element . appendChild ( targetElement . element ) ; } } } public void taskStarted ( BuildEvent event ) { TimedElement taskElement = new TimedElement ( ) ; taskElement . startTime = System . currentTimeMillis ( ) ; taskElement . element = doc . createElement ( TASK_TAG ) ; Task task = event . getTask ( ) ; String name = event . getTask ( ) . getTaskName ( ) ; taskElement . element . setAttribute ( NAME_ATTR , name ) ; taskElement . element . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; tasks . put ( task , taskElement ) ; getStack ( ) . push ( taskElement ) ; } public void taskFinished ( BuildEvent event ) { Task task = event . getTask ( ) ; TimedElement taskElement = ( TimedElement ) tasks . get ( task ) ; if ( taskElement != null ) { long totalTime = System . currentTimeMillis ( ) - taskElement . startTime ; taskElement . element . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; Target target = task . getOwningTarget ( ) ; TimedElement targetElement = null ; if ( target != null ) { targetElement = ( TimedElement ) targets . get ( target ) ; } if ( targetElement == null ) { buildElement . element . appendChild ( taskElement . element ) ; } else { targetElement . element . appendChild ( taskElement . element ) ; } Stack threadStack = getStack ( ) ; if ( ! threadStack . empty ( ) ) { TimedElement poppedStack = ( TimedElement ) threadStack . pop ( ) ; if ( poppedStack != taskElement ) { throw new RuntimeException ( "Mismatch - popped element = " + poppedStack . element + " finished task element = " + taskElement . element ) ; } } } } private TimedElement getTaskElement ( Task task ) { TimedElement element = ( TimedElement ) tasks . get ( task ) ; if ( element != null ) { return element ; } for ( Enumeration e = tasks . keys ( ) ; e . hasMoreElements ( ) ; ) { Task key = ( Task ) e . nextElement ( ) ; if ( key instanceof UnknownElement ) { if ( ( ( UnknownElement ) key ) . getTask ( ) == task ) { return ( TimedElement ) tasks . get ( key ) ; } } } return null ; } public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority > msgOutputLevel ) { return ; } Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createCDATASection ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; TimedElement parentElement = null ; Task task = event . getTask ( ) ; Target target = event . getTarget ( ) ; if ( task != null ) { parentElement = getTaskElement ( task ) ; } if ( parentElement == null && target != null ) { parentElement = ( TimedElement ) targets . get ( target ) ; } if ( parentElement != null ) { parentElement . element . appendChild ( messageElement ) ; } else { buildElement . element . appendChild ( messageElement ) ; } } public void setMessageOutputLevel ( int level ) { msgOutputLevel = level ; } public void setOutputPrintStream ( PrintStream output ) { this . outStream = new PrintStream ( output , true ) ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { } } 	0	['16', '1', '0', '13', '74', '50', '0', '13', '12', '0.937037037', '635', '1', '1', '0', '0.288888889', '0', '0', '37.5625', '9', '2.6875', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import java . util . Vector ; public class Description extends DataType { public void addText ( String text ) { ProjectHelper ph = ProjectHelper . getProjectHelper ( ) ; if ( ! ( ph instanceof ProjectHelperImpl ) ) { return ; } String currentDescription = getProject ( ) . getDescription ( ) ; if ( currentDescription == null ) { getProject ( ) . setDescription ( text ) ; } else { getProject ( ) . setDescription ( currentDescription + text ) ; } } public static String getDescription ( Project project ) { StringBuffer description = new StringBuffer ( ) ; Vector targets = ( Vector ) project . getReference ( "ant.targets" ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { Target t = ( Target ) targets . elementAt ( i ) ; concatDescriptions ( project , t , description ) ; } return description . toString ( ) ; } private static void concatDescriptions ( Project project , Target t , StringBuffer description ) { if ( t == null ) { return ; } Vector tasks = findElementInTarget ( project , t , "description" ) ; if ( tasks == null ) { return ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { Task task = ( Task ) tasks . elementAt ( i ) ; if ( ! ( task instanceof UnknownElement ) ) { continue ; } UnknownElement ue = ( ( UnknownElement ) task ) ; StringBuffer descComp = ue . getWrapper ( ) . getText ( ) ; if ( descComp != null ) { description . append ( ( Object ) descComp ) ; } } } private static Vector findElementInTarget ( Project project , Target t , String name ) { Task [ ] tasks = t . getTasks ( ) ; Vector elems = new Vector ( ) ; for ( int i = 0 ; i < tasks . length ; i ++ ) { if ( name . equals ( tasks [ i ] . getTaskName ( ) ) ) { elems . addElement ( tasks [ i ] ) ; } } return elems ; } } 	0	['5', '3', '0', '9', '24', '10', '1', '9', '3', '2', '137', '0', '0', '0.882352941', '0.4', '0', '0', '26.4', '6', '2.8', '0']
package org . apache . tools . ant ; import java . io . Serializable ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . Locator ; public class Location implements Serializable { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( Locator loc ) { this ( loc . getSystemId ( ) , loc . getLineNumber ( ) , loc . getColumnNumber ( ) ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { if ( fileName != null && fileName . startsWith ( "file:" ) ) { this . fileName = FileUtils . newFileUtils ( ) . fromURI ( fileName ) ; } else { this . fileName = fileName ; } this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getFileName ( ) { return fileName ; } public int getLineNumber ( ) { return lineNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['8', '1', '0', '80', '19', '18', '79', '1', '6', '0.428571429', '99', '0.75', '1', '0', '0.392857143', '0', '0', '10.875', '3', '0.625', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . IOException ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; private boolean inheritAll = true ; private boolean inheritRefs = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = ( Ant ) getProject ( ) . createTask ( "ant" ) ; callee . setOwningTarget ( getOwningTarget ( ) ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( getLocation ( ) ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , getLocation ( ) ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void addPropertyset ( org . apache . tools . ant . types . PropertySet ps ) { if ( callee == null ) { init ( ) ; } callee . addPropertyset ( ps ) ; } public void setTarget ( String target ) { subTarget = target ; } public void handleOutput ( String output ) { if ( callee != null ) { callee . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( callee != null ) { return callee . handleInput ( buffer , offset , length ) ; } else { return super . handleInput ( buffer , offset , length ) ; } } public void handleFlush ( String output ) { if ( callee != null ) { callee . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( callee != null ) { callee . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( callee != null ) { callee . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } } 	0	['14', '3', '0', '10', '44', '0', '0', '10', '14', '0.730769231', '199', '1', '1', '0.74', '0.255102041', '2', '4', '12.92857143', '2', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '6', '2', '0', '6', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '24', '1', '1', '8', '2', '2', '147', '0', '0', '0.958333333', '1', '0', '0', '72.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0	['3', '5', '0', '9', '11', '3', '5', '4', '3', '2', '76', '0', '0', '0.953488372', '0.666666667', '1', '1', '24.33333333', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0	['24', '1', '0', '23', '24', '276', '3', '20', '24', '2', '24', '0', '0', '0', '0.089285714', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Exit extends Task { private String message ; private String ifCondition , unlessCondition ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void execute ( ) throws BuildException { if ( testIfCondition ( ) && testUnlessCondition ( ) ) { String text = null ; if ( message != null && message . length ( ) > 0 ) { text = message ; } else { if ( getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } else { if ( text == null ) { text = "No message" ; } } } throw new BuildException ( text ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } } 	0	['8', '3', '0', '4', '18', '10', '0', '4', '6', '0.714285714', '172', '1', '0', '0.840909091', '0.75', '0', '0', '20.125', '4', '1.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , getLocation ( ) ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , getLocation ( ) ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , getLocation ( ) ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { getProject ( ) . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '5', '24', '1', '0', '5', '6', '0.7', '137', '1', '0', '0.880952381', '0.416666667', '3', '3', '21.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . Tokenizer ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . regexp . Regexp ; public class TokenFilter extends BaseFilterReader implements ChainableReader { public interface Filter { String filter ( String string ) ; } private Vector filters = new Vector ( ) ; private Tokenizer tokenizer = null ; private String delimOutput = null ; private String line = null ; private int linePos = 0 ; public TokenFilter ( ) { super ( ) ; } public TokenFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } while ( line == null || line . length ( ) == 0 ) { line = tokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } for ( Enumeration e = filters . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; line = filter . filter ( line ) ; if ( line == null ) { break ; } } linePos = 0 ; if ( line != null ) { if ( tokenizer . getPostToken ( ) . length ( ) != 0 ) { if ( delimOutput != null ) { line = line + delimOutput ; } else { line = line + tokenizer . getPostToken ( ) ; } } } } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final Reader chain ( final Reader reader ) { TokenFilter newFilter = new TokenFilter ( reader ) ; newFilter . filters = filters ; newFilter . tokenizer = tokenizer ; newFilter . delimOutput = delimOutput ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } public void setDelimOutput ( String delimOutput ) { this . delimOutput = resolveBackSlash ( delimOutput ) ; } public void addLineTokenizer ( LineTokenizer tokenizer ) { add ( tokenizer ) ; } public void addStringTokenizer ( StringTokenizer tokenizer ) { add ( tokenizer ) ; } public void addFileTokenizer ( FileTokenizer tokenizer ) { add ( tokenizer ) ; } public void add ( Tokenizer tokenizer ) { if ( this . tokenizer != null ) { throw new BuildException ( "Only one tokenizer allowed" ) ; } this . tokenizer = tokenizer ; } public void addReplaceString ( ReplaceString filter ) { filters . addElement ( filter ) ; } public void addContainsString ( ContainsString filter ) { filters . addElement ( filter ) ; } public void addReplaceRegex ( ReplaceRegex filter ) { filters . addElement ( filter ) ; } public void addContainsRegex ( ContainsRegex filter ) { filters . addElement ( filter ) ; } public void addTrim ( Trim filter ) { filters . addElement ( filter ) ; } public void addIgnoreBlank ( IgnoreBlank filter ) { filters . addElement ( filter ) ; } public void addDeleteCharacters ( DeleteCharacters filter ) { filters . addElement ( filter ) ; } public void add ( Filter filter ) { filters . addElement ( filter ) ; } public static class FileTokenizer extends ProjectComponent implements Tokenizer { public String getToken ( Reader in ) throws IOException { return FileUtils . readFully ( in ) ; } public String getPostToken ( ) { return "" ; } } public static class StringTokenizer extends ProjectComponent implements Tokenizer { private String intraString = "" ; private int pushed = - 2 ; private char [ ] delims = null ; private boolean delimsAreTokens = false ; private boolean suppressDelims = false ; private boolean includeDelims = false ; public void setDelims ( String delims ) { this . delims = resolveBackSlash ( delims ) . toCharArray ( ) ; } public void setDelimsAreTokens ( boolean delimsAreTokens ) { this . delimsAreTokens = delimsAreTokens ; } public void setSuppressDelims ( boolean suppressDelims ) { this . suppressDelims = suppressDelims ; } public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } boolean inToken = true ; intraString = "" ; StringBuffer word = new StringBuffer ( ) ; StringBuffer padding = new StringBuffer ( ) ; while ( ch != - 1 ) { char c = ( char ) ch ; boolean isDelim = isDelim ( c ) ; if ( inToken ) { if ( isDelim ) { if ( delimsAreTokens ) { if ( word . length ( ) == 0 ) { word . append ( c ) ; } else { pushed = ch ; } break ; } padding . append ( c ) ; inToken = false ; } else { word . append ( c ) ; } } else { if ( isDelim ) { padding . append ( c ) ; } else { pushed = ch ; break ; } } ch = in . read ( ) ; } intraString = padding . toString ( ) ; if ( includeDelims ) { word . append ( intraString ) ; } return word . toString ( ) ; } public String getPostToken ( ) { if ( suppressDelims || includeDelims ) { return "" ; } return intraString ; } private boolean isDelim ( char ch ) { if ( delims == null ) { return Character . isWhitespace ( ch ) ; } for ( int i = 0 ; i < delims . length ; ++ i ) { if ( delims [ i ] == ch ) { return true ; } } return false ; } } public abstract static class ChainableReaderFilter extends ProjectComponent implements ChainableReader , Filter { private boolean byLine = true ; public void setByLine ( boolean byLine ) { this . byLine = byLine ; } public Reader chain ( Reader reader ) { TokenFilter tokenFilter = new TokenFilter ( reader ) ; if ( ! byLine ) { tokenFilter . add ( new FileTokenizer ( ) ) ; } tokenFilter . add ( this ) ; return tokenFilter ; } } public static class ReplaceString extends ChainableReaderFilter { private String from ; private String to ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String filter ( String line ) { if ( from == null ) { throw new BuildException ( "Missing from in stringreplace" ) ; } StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = line . indexOf ( from ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( line . substring ( start , found ) ) ; } if ( to != null ) { ret . append ( to ) ; } start = found + from . length ( ) ; found = line . indexOf ( line , start ) ; } if ( line . length ( ) > start ) { ret . append ( line . substring ( start , line . length ( ) ) ) ; } return ret . toString ( ) ; } } public static class ContainsString extends ProjectComponent implements Filter { private String contains ; public void setContains ( String contains ) { this . contains = contains ; } public String filter ( String string ) { if ( contains == null ) { throw new BuildException ( "Missing contains in containsstring" ) ; } if ( string . indexOf ( contains ) > - 1 ) { return string ; } return null ; } } public static class ReplaceRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing pattern in replaceregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { to = "" ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String line ) { initialize ( ) ; if ( ! regexp . matches ( line , options ) ) { return line ; } return regexp . substitute ( line , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class ContainsRegex extends ChainableReaderFilter { private String from ; private String to ; private Project project ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing from in containsregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( project ) ; if ( to == null ) { return ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String string ) { initialize ( ) ; if ( ! regexp . matches ( string , options ) ) { return null ; } if ( substitution == null ) { return string ; } return regexp . substitute ( string , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class Trim extends ChainableReaderFilter { public String filter ( String line ) { return line . trim ( ) ; } } public static class IgnoreBlank extends ChainableReaderFilter { public String filter ( String line ) { if ( line . trim ( ) . length ( ) == 0 ) { return null ; } return line ; } } public static class DeleteCharacters extends ProjectComponent implements Filter , ChainableReader { private String deleteChars = "" ; public void setChars ( String deleteChars ) { this . deleteChars = resolveBackSlash ( deleteChars ) ; } public String filter ( String string ) { StringBuffer output = new StringBuffer ( string . length ( ) ) ; for ( int i = 0 ; i < string . length ( ) ; ++ i ) { char ch = string . charAt ( i ) ; if ( ! ( isDeleteCharacter ( ch ) ) ) { output . append ( ch ) ; } } return output . toString ( ) ; } public Reader chain ( Reader reader ) { return new BaseFilterReader ( reader ) { public int read ( ) throws IOException { while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { return c ; } if ( ! ( isDeleteCharacter ( ( char ) c ) ) ) { return c ; } } } } ; } private boolean isDeleteCharacter ( char c ) { for ( int d = 0 ; d < deleteChars . length ( ) ; ++ d ) { if ( deleteChars . charAt ( d ) == c ) { return true ; } } return false ; } } public static String resolveBackSlash ( String input ) { StringBuffer b = new StringBuffer ( ) ; boolean backSlashSeen = false ; for ( int i = 0 ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; if ( ! backSlashSeen ) { if ( c == '\\' ) { backSlashSeen = true ; } else { b . append ( c ) ; } } else { switch ( c ) { case '\\' : b . append ( ( char ) '\\' ) ; break ; case 'n' : b . append ( ( char ) '\n' ) ; break ; case 'r' : b . append ( ( char ) '\r' ) ; break ; case 't' : b . append ( ( char ) '\t' ) ; break ; case 'f' : b . append ( ( char ) '\f' ) ; break ; case 's' : b . append ( " \t\n\r\f" ) ; break ; default : b . append ( c ) ; } backSlashSeen = false ; } } return b . toString ( ) ; } public static int convertRegexOptions ( String flags ) { if ( flags == null ) { return 0 ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } return options ; } } 	0	['19', '4', '0', '18', '40', '23', '6', '16', '19', '0.688888889', '386', '1', '1', '0.604651163', '0.119298246', '2', '4', '19.05263158', '11', '1.7368', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public final class StripJavaComments extends BaseFilterReader implements ChainableReader { private int readAheadCh = - 1 ; private boolean inString = false ; private boolean quoted = false ; public StripJavaComments ( ) { super ( ) ; } public StripJavaComments ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { int ch = - 1 ; if ( readAheadCh != - 1 ) { ch = readAheadCh ; readAheadCh = - 1 ; } else { ch = in . read ( ) ; if ( ch == '"' && ! quoted ) { inString = ! inString ; quoted = false ; } else if ( ch == '\\' ) { quoted = ! quoted ; } else { quoted = false ; if ( ! inString ) { if ( ch == '/' ) { ch = in . read ( ) ; if ( ch == '/' ) { while ( ch != '\n' && ch != - 1 && ch != '\r' ) { ch = in . read ( ) ; } } else if ( ch == '*' ) { while ( ch != - 1 ) { ch = in . read ( ) ; if ( ch == '*' ) { ch = in . read ( ) ; while ( ch == '*' && ch != - 1 ) { ch = in . read ( ) ; } if ( ch == '/' ) { ch = read ( ) ; break ; } } } } else { readAheadCh = ch ; ch = '/' ; } } } } } return ch ; } public final Reader chain ( final Reader rdr ) { StripJavaComments newFilter = new StripJavaComments ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '3', '7', '0', '1', '2', '4', '0', '161', '1', '0', '0.928571429', '0.75', '2', '4', '38.5', '1', '0.5', '0']
package org . apache . tools . mail ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null && line . length ( ) >= 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . length ( ) > 3 && line . charAt ( 3 ) == '-' ; } private void append ( String line ) { if ( line . length ( ) > 4 ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } } 	0	['5', '1', '0', '1', '19', '0', '1', '0', '3', '0.5', '108', '1', '0', '0', '0.533333333', '0', '0', '20.2', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; public final class LoadFile extends Task { private File srcFile = null ; private boolean failOnError = true ; private String encoding = null ; private String property = null ; private final Vector filterChains = new Vector ( ) ; public final void setEncoding ( final String encoding ) { this . encoding = encoding ; } public final void setProperty ( final String property ) { this . property = property ; } public final void setSrcFile ( final File srcFile ) { this . srcFile = srcFile ; } public final void setFailonerror ( final boolean fail ) { failOnError = fail ; } public final void execute ( ) throws BuildException { if ( srcFile == null ) { throw new BuildException ( "source file not defined" ) ; } if ( property == null ) { throw new BuildException ( "output property not defined" ) ; } FileInputStream fis = null ; BufferedInputStream bis = null ; Reader instream = null ; log ( "loading " + srcFile + " into property " + property , Project . MSG_VERBOSE ) ; try { final long len = srcFile . length ( ) ; log ( "file size = " + len , Project . MSG_DEBUG ) ; final int size = ( int ) len ; fis = new FileInputStream ( srcFile ) ; bis = new BufferedInputStream ( fis ) ; if ( encoding == null ) { instream = new InputStreamReader ( bis ) ; } else { instream = new InputStreamReader ( bis , encoding ) ; } String text = "" ; if ( size != 0 ) { ChainReaderHelper crh = new ChainReaderHelper ( ) ; crh . setBufferSize ( size ) ; crh . setPrimaryReader ( instream ) ; crh . setFilterChains ( filterChains ) ; crh . setProject ( getProject ( ) ) ; instream = crh . getAssembledReader ( ) ; text = crh . readFully ( instream ) ; } if ( text != null ) { if ( text . length ( ) > 0 ) { getProject ( ) . setNewProperty ( property , text ) ; log ( "loaded " + text . length ( ) + " characters" , Project . MSG_VERBOSE ) ; log ( property + " := " + text , Project . MSG_DEBUG ) ; } } } catch ( final IOException ioe ) { final String message = "Unable to load file: " + ioe . toString ( ) ; if ( failOnError ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } } catch ( final BuildException be ) { if ( failOnError ) { throw be ; } else { log ( be . getMessage ( ) , Project . MSG_ERR ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ioex ) { } } } public final void addFilterChain ( FilterChain filter ) { filterChains . addElement ( filter ) ; } } 	0	['7', '3', '0', '7', '38', '0', '0', '7', '7', '0.666666667', '262', '1', '0', '0.860465116', '0.342857143', '2', '2', '35.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . util ; import java . util . Hashtable ; import java . util . Enumeration ; public class LazyHashtable extends Hashtable { protected boolean initAllDone = false ; public LazyHashtable ( ) { super ( ) ; } protected void initAll ( ) { if ( initAllDone ) { return ; } initAllDone = true ; } public Enumeration elements ( ) { initAll ( ) ; return super . elements ( ) ; } public boolean isEmpty ( ) { initAll ( ) ; return super . isEmpty ( ) ; } public int size ( ) { initAll ( ) ; return super . size ( ) ; } public boolean contains ( Object value ) { initAll ( ) ; return super . contains ( value ) ; } public boolean containsKey ( Object value ) { initAll ( ) ; return super . containsKey ( value ) ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } public Enumeration keys ( ) { initAll ( ) ; return super . keys ( ) ; } } 	0	['9', '3', '0', '0', '16', '34', '0', '0', '8', '0', '60', '1', '0', '0.8', '0.666666667', '1', '1', '5.555555556', '2', '1', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public ExitException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['3', '5', '0', '2', '8', '0', '2', '0', '3', '0', '28', '1', '0', '0.928571429', '0.666666667', '0', '0', '8', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FilterSet ; import org . apache . tools . ant . types . FilterSetCollection ; public class Move extends Copy { public Move ( ) { super ( ) ; setOverwrite ( true ) ; } protected void doFileOperations ( ) { if ( completeDirMap . size ( ) > 0 ) { Enumeration e = completeDirMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { File fromDir = ( File ) e . nextElement ( ) ; File toDir = ( File ) completeDirMap . get ( fromDir ) ; try { log ( "Attempting to rename dir: " + fromDir + " to " + toDir , verbosity ) ; renameFile ( fromDir , toDir , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename dir " + fromDir + " to " + toDir + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; File f = new File ( fromFile ) ; boolean selfMove = false ; if ( f . exists ( ) ) { String [ ] toFiles = ( String [ ] ) fileCopyMap . get ( fromFile ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String toFile = ( String ) toFiles [ i ] ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-move of " + fromFile , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toFile ) ; if ( ( i + 1 ) == toFiles . length && ! selfMove ) { moveFile ( f , d , filtering , forceOverwrite ) ; } else { copyFile ( f , d , filtering , forceOverwrite ) ; } } } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . keys ( ) ; int createCount = 0 ; while ( e . hasMoreElements ( ) ) { String fromDirName = ( String ) e . nextElement ( ) ; String [ ] toDirNames = ( String [ ] ) dirCopyMap . get ( fromDirName ) ; boolean selfMove = false ; for ( int i = 0 ; i < toDirNames . length ; i ++ ) { if ( fromDirName . equals ( toDirNames [ i ] ) ) { log ( "Skipping self-move of " + fromDirName , verbosity ) ; selfMove = true ; continue ; } File d = new File ( toDirNames [ i ] ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { createCount ++ ; } } } File fromDir = new File ( fromDirName ) ; if ( ! selfMove && okToDelete ( fromDir ) ) { deleteDir ( fromDir ) ; } } if ( createCount > 0 ) { log ( "Moved " + dirCopyMap . size ( ) + " empty director" + ( dirCopyMap . size ( ) == 1 ? "y" : "ies" ) + " to " + createCount + " empty director" + ( createCount == 1 ? "y" : "ies" ) + " under " + destDir . getAbsolutePath ( ) ) ; } } } private void moveFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { boolean moved = false ; try { log ( "Attempting to rename: " + fromFile + " to " + toFile , verbosity ) ; moved = renameFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to rename " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } if ( ! moved ) { copyFile ( fromFile , toFile , filtering , overwrite ) ; if ( ! fromFile . delete ( ) ) { throw new BuildException ( "Unable to delete " + "file " + fromFile . getAbsolutePath ( ) ) ; } } } private void copyFile ( File fromFile , File toFile , boolean filtering , boolean overwrite ) { try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; FilterSetCollection executionFilters = new FilterSetCollection ( ) ; if ( filtering ) { executionFilters . addFilterSet ( getProject ( ) . getGlobalFilterSet ( ) ) ; } for ( Enumeration filterEnum = getFilterSets ( ) . elements ( ) ; filterEnum . hasMoreElements ( ) ; ) { executionFilters . addFilterSet ( ( FilterSet ) filterEnum . nextElement ( ) ) ; } getFileUtils ( ) . copyFile ( fromFile , toFile , executionFilters , getFilterChains ( ) , forceOverwrite , getPreserveLastModified ( ) , getEncoding ( ) , getOutputEncoding ( ) , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return false ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) { return false ; } } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) { return ; } for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } protected boolean renameFile ( File sourceFile , File destFile , boolean filtering , boolean overwrite ) throws IOException , BuildException { boolean renamed = true ; if ( ( getFilterSets ( ) != null && getFilterSets ( ) . size ( ) > 0 ) || ( getFilterChains ( ) != null && getFilterChains ( ) . size ( ) > 0 ) ) { renamed = false ; } else { if ( ! filtering ) { String parentPath = destFile . getParent ( ) ; if ( parentPath != null ) { File parent = new File ( parentPath ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } } if ( destFile . exists ( ) && destFile . isFile ( ) ) { if ( ! destFile . delete ( ) ) { throw new BuildException ( "Unable to remove existing " + "file " + destFile ) ; } } renamed = sourceFile . renameTo ( destFile ) ; } else { renamed = false ; } } return renamed ; } } 	0	['7', '4', '0', '9', '50', '21', '0', '9', '1', '2', '686', '0', '0', '0.930232558', '0.714285714', '4', '4', '97', '21', '5.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { String FILE_PROTOCOL_PREFIX = "file://" ; void setStylesheet ( File stylesheet ) throws Exception ; void addParam ( String name , String expression ) throws Exception ; void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; public class EmailAddress { private String name ; private String address ; public EmailAddress ( ) { } public EmailAddress ( String email ) { final int minLen = 9 ; int len = email . length ( ) ; if ( len > minLen ) { if ( ( email . charAt ( 0 ) == '<' || email . charAt ( 1 ) == '<' ) && ( email . charAt ( len - 1 ) == '>' || email . charAt ( len - 2 ) == '>' ) ) { this . address = trim ( email , true ) ; return ; } } int paramDepth = 0 ; int start = 0 ; int end = 0 ; int nStart = 0 ; int nEnd = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = email . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; nStart = i + 1 ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; nEnd = i ; } } else if ( paramDepth == 0 && c == '<' ) { if ( start == 0 ) { nEnd = i ; } start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; if ( end != len - 1 ) { nStart = i + 1 ; } } } if ( end == 0 ) { end = len ; } if ( nEnd == 0 ) { nEnd = len ; } this . address = trim ( email . substring ( start , end ) , true ) ; this . name = trim ( email . substring ( nStart , nEnd ) , false ) ; if ( this . name . length ( ) + this . address . length ( ) > len ) { this . name = null ; } } private String trim ( String t , boolean trimAngleBrackets ) { int start = 0 ; int end = t . length ( ) ; boolean trim = false ; do { trim = false ; if ( t . charAt ( end - 1 ) == ')' || ( t . charAt ( end - 1 ) == '>' && trimAngleBrackets ) || ( t . charAt ( end - 1 ) == '"' && t . charAt ( end - 2 ) != '\\' ) || t . charAt ( end - 1 ) <= ' ' ) { trim = true ; end -- ; } if ( t . charAt ( start ) == '(' || ( t . charAt ( start ) == '<' && trimAngleBrackets ) || t . charAt ( start ) == '"' || t . charAt ( start ) <= ' ' ) { trim = true ; start ++ ; } } while ( trim ) ; return t . substring ( start , end ) ; } public void setName ( String name ) { this . name = name ; } public void setAddress ( String address ) { this . address = address ; } public String toString ( ) { if ( name == null ) { return address ; } else { return name + " <" + address + ">" ; } } public String getAddress ( ) { return address ; } public String getName ( ) { return name ; } } 	0	['8', '1', '0', '4', '15', '6', '4', '0', '7', '0.571428571', '286', '1', '0', '0', '0.541666667', '0', '0', '34.5', '13', '2.375', '0']
package org . apache . tools . ant . util ; public interface TimeoutObserver { void timeoutOccured ( Watchdog w ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class SunRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using SUN rmic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; LogOutputStream logstr = new LogOutputStream ( getRmic ( ) , Project . MSG_WARN ) ; try { Class c = Class . forName ( "sun.rmi.rmic.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { logstr , "rmic" } ) ; Method doRmic = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , ( new Object [ ] { cmd . getArguments ( ) } ) ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use SUN rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting SUN rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { try { logstr . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } } 	0	['3', '2', '0', '8', '22', '3', '1', '7', '2', '1', '152', '0', '0', '0.866666667', '0.5', '0', '0', '48.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; import java . util . zip . ZipException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . zip . ZipEntry ; import org . apache . tools . zip . ZipFile ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; private Resource lastScannedResource ; private Hashtable myentries ; private String encoding ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String [ ] getIncludedFiles ( ) { if ( srcFile != null ) { Vector myvector = new Vector ( ) ; scanme ( ) ; for ( Enumeration e = myentries . elements ( ) ; e . hasMoreElements ( ) ; ) { Resource myresource = ( Resource ) e . nextElement ( ) ; if ( ! myresource . isDirectory ( ) && match ( myresource . getName ( ) ) ) { myvector . addElement ( myresource . getName ( ) ) ; } } String [ ] files = new String [ myvector . size ( ) ] ; myvector . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } else { return super . getIncludedFiles ( ) ; } } public String [ ] getIncludedDirectories ( ) { if ( srcFile != null ) { Vector myvector = new Vector ( ) ; scanme ( ) ; for ( Enumeration e = myentries . elements ( ) ; e . hasMoreElements ( ) ; ) { Resource myresource = ( Resource ) e . nextElement ( ) ; if ( myresource . isDirectory ( ) && match ( myresource . getName ( ) ) ) { myvector . addElement ( myresource . getName ( ) ) ; } } String [ ] files = new String [ myvector . size ( ) ] ; myvector . copyInto ( files ) ; Arrays . sort ( files ) ; return files ; } else { return super . getIncludedDirectories ( ) ; } } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } public Resource getResource ( String name ) { if ( srcFile == null ) { return super . getResource ( name ) ; } else if ( name . equals ( "" ) ) { return new Resource ( "" , true , Long . MAX_VALUE , true ) ; } scanme ( ) ; if ( myentries . containsKey ( name ) ) { return ( Resource ) myentries . get ( name ) ; } else if ( myentries . containsKey ( name + "/" ) ) { return ( Resource ) myentries . get ( name + "/" ) ; } else { return new Resource ( name ) ; } } private void scanme ( ) { Resource thisresource = new Resource ( srcFile . getAbsolutePath ( ) , srcFile . exists ( ) , srcFile . lastModified ( ) ) ; if ( lastScannedResource != null && lastScannedResource . getName ( ) . equals ( thisresource . getName ( ) ) && lastScannedResource . getLastModified ( ) == thisresource . getLastModified ( ) ) { return ; } ZipEntry entry = null ; ZipFile zf = null ; myentries = new Hashtable ( ) ; try { try { zf = new ZipFile ( srcFile , encoding ) ; } catch ( ZipException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } Enumeration e = zf . getEntries ( ) ; while ( e . hasMoreElements ( ) ) { entry = ( ZipEntry ) e . nextElement ( ) ; myentries . put ( new String ( entry . getName ( ) ) , new Resource ( entry . getName ( ) , true , entry . getTime ( ) , entry . isDirectory ( ) ) ) ; } } finally { if ( zf != null ) { try { zf . close ( ) ; } catch ( IOException ex ) { } } } lastScannedResource = thisresource ; } } 	0	['9', '2', '0', '7', '50', '14', '2', '5', '8', '0.5625', '348', '1', '1', '0.884057971', '0.481481481', '2', '4', '37.22222222', '8', '3.4444', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public class DepthSelector extends BaseExtendSelector { public int min = - 1 ; public int max = - 1 ; public static final String MIN_KEY = "min" ; public static final String MAX_KEY = "max" ; public DepthSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{depthselector min: " ) ; buf . append ( min ) ; buf . append ( " max: " ) ; buf . append ( max ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMin ( int min ) { this . min = min ; } public void setMax ( int max ) { this . max = max ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MIN_KEY . equalsIgnoreCase ( paramname ) ) { try { setMin ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid minimum value " + parameters [ i ] . getValue ( ) ) ; } } else if ( MAX_KEY . equalsIgnoreCase ( paramname ) ) { try { setMax ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid maximum value " + parameters [ i ] . getValue ( ) ) ; } } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( min < 0 && max < 0 ) { setError ( "You must set at least one of the min or the " + "max levels." ) ; } if ( max < min && max > - 1 ) { setError ( "The maximum depth is lower than the minimum." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int depth = - 1 ; String absBase = basedir . getAbsolutePath ( ) ; String absFile = file . getAbsolutePath ( ) ; StringTokenizer tokBase = new StringTokenizer ( absBase , File . separator ) ; StringTokenizer tokFile = new StringTokenizer ( absFile , File . separator ) ; while ( tokFile . hasMoreTokens ( ) ) { String filetoken = tokFile . nextToken ( ) ; if ( tokBase . hasMoreTokens ( ) ) { String basetoken = tokBase . nextToken ( ) ; if ( ! basetoken . equals ( filetoken ) ) { throw new BuildException ( "File " + filename + " does not appear within " + absBase + "directory" ) ; } } else { depth += 1 ; if ( max > - 1 && depth > max ) { return false ; } } } if ( tokBase . hasMoreTokens ( ) ) { throw new BuildException ( "File " + filename + " is outside of " + absBase + "directory tree" ) ; } if ( min > - 1 && depth < min ) { return false ; } return true ; } } 	0	['7', '5', '0', '9', '26', '0', '5', '4', '7', '0.666666667', '263', '0', '0', '0.863636364', '0.342857143', '2', '5', '36', '8', '3', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Vector ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . AbstractCvsTask ; import org . apache . tools . ant . util . FileUtils ; public class CvsTagDiff extends AbstractCvsTask { static final String FILE_STRING = "File " ; static final String TO_STRING = " to " ; static final String FILE_IS_NEW = " is new;" ; static final String REVISION = "revision " ; static final String FILE_HAS_CHANGED = " changed from revision " ; static final String FILE_WAS_REMOVED = " is removed" ; private String mypackage ; private String mystartTag ; private String myendTag ; private String mystartDate ; private String myendDate ; private File mydestfile ; private FileUtils myfileUtils = FileUtils . newFileUtils ( ) ; public void setPackage ( String p ) { mypackage = p ; } public void setStartTag ( String s ) { mystartTag = s ; } public void setStartDate ( String s ) { mystartDate = s ; } public void setEndTag ( String s ) { myendTag = s ; } public void setEndDate ( String s ) { myendDate = s ; } public void setDestFile ( File f ) { mydestfile = f ; } public void execute ( ) throws BuildException { validate ( ) ; addCommandArgument ( "rdiff" ) ; addCommandArgument ( "-s" ) ; if ( mystartTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( mystartTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( mystartDate ) ; } if ( myendTag != null ) { addCommandArgument ( "-r" ) ; addCommandArgument ( myendTag ) ; } else { addCommandArgument ( "-D" ) ; addCommandArgument ( myendDate ) ; } StringTokenizer myTokenizer = new StringTokenizer ( mypackage ) ; while ( myTokenizer . hasMoreTokens ( ) ) { addCommandArgument ( myTokenizer . nextToken ( ) ) ; } setCommand ( "" ) ; File tmpFile = null ; try { tmpFile = myfileUtils . createTempFile ( "cvstagdiff" , ".log" , null ) ; tmpFile . deleteOnExit ( ) ; setOutput ( tmpFile ) ; super . execute ( ) ; CvsTagEntry [ ] entries = parseRDiff ( tmpFile ) ; writeTagDiff ( entries ) ; } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } private CvsTagEntry [ ] parseRDiff ( File tmpFile ) throws BuildException { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( tmpFile ) ) ; String toBeRemoved = FILE_STRING + mypackage + "/" ; int headerLength = toBeRemoved . length ( ) ; Vector entries = new Vector ( ) ; String line = reader . readLine ( ) ; int index ; CvsTagEntry entry = null ; while ( null != line ) { if ( line . length ( ) > headerLength ) { if ( line . startsWith ( toBeRemoved ) ) { line = line . substring ( headerLength ) ; } else { line = line . substring ( FILE_STRING . length ( ) ) ; } if ( ( index = line . indexOf ( FILE_IS_NEW ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_HAS_CHANGED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; int revSeparator = line . indexOf ( " to " , index ) ; String prevRevision = line . substring ( index + FILE_HAS_CHANGED . length ( ) , revSeparator ) ; String revision = line . substring ( revSeparator + TO_STRING . length ( ) ) ; entry = new CvsTagEntry ( filename , revision , prevRevision ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } else if ( ( index = line . indexOf ( FILE_WAS_REMOVED ) ) != - 1 ) { String filename = line . substring ( 0 , index ) ; String rev = null ; int indexrev = - 1 ; if ( ( indexrev = line . indexOf ( REVISION , index ) ) != - 1 ) { rev = line . substring ( indexrev + REVISION . length ( ) ) ; } entry = new CvsTagEntry ( filename , null , rev ) ; entries . addElement ( entry ) ; log ( entry . toString ( ) , Project . MSG_VERBOSE ) ; } } line = reader . readLine ( ) ; } CvsTagEntry [ ] array = new CvsTagEntry [ entries . size ( ) ] ; entries . copyInto ( array ) ; return array ; } catch ( IOException e ) { throw new BuildException ( "Error in parsing" , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagDiff ( CvsTagEntry [ ] entries ) throws BuildException { FileOutputStream output = null ; try { output = new FileOutputStream ( mydestfile ) ; PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( output , "UTF-8" ) ) ; writer . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; writer . print ( "<tagdiff " ) ; if ( mystartTag != null ) { writer . print ( "startTag=\"" + mystartTag + "\" " ) ; } else { writer . print ( "startDate=\"" + mystartDate + "\" " ) ; } if ( myendTag != null ) { writer . print ( "endTag=\"" + myendTag + "\" " ) ; } else { writer . print ( "endDate=\"" + myendDate + "\" " ) ; } writer . print ( "cvsroot=\"" + getCvsRoot ( ) + "\" " ) ; writer . print ( "package=\"" + mypackage + "\" " ) ; writer . println ( ">" ) ; for ( int i = 0 , c = entries . length ; i < c ; i ++ ) { writeTagEntry ( writer , entries [ i ] ) ; } writer . println ( "</tagdiff>" ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException uee ) { log ( uee . toString ( ) , Project . MSG_ERR ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException ioe ) { log ( ioe . toString ( ) , Project . MSG_ERR ) ; } } } } private void writeTagEntry ( PrintWriter writer , CvsTagEntry entry ) { writer . println ( "\t<entry>" ) ; writer . println ( "\t\t<file>" ) ; writer . println ( "\t\t\t<name>" + entry . getFile ( ) + "</name>" ) ; if ( entry . getRevision ( ) != null ) { writer . println ( "\t\t\t<revision>" + entry . getRevision ( ) + "</revision>" ) ; } if ( entry . getPreviousRevision ( ) != null ) { writer . println ( "\t\t\t<prevrevision>" + entry . getPreviousRevision ( ) + "</prevrevision>" ) ; } writer . println ( "\t\t</file>" ) ; writer . println ( "\t</entry>" ) ; } private void validate ( ) throws BuildException { if ( null == mypackage ) { throw new BuildException ( "Package/module must be set." ) ; } if ( null == mydestfile ) { throw new BuildException ( "Destfile must be set." ) ; } if ( null == mystartTag && null == mystartDate ) { throw new BuildException ( "Start tag or start date must be set." ) ; } if ( null != mystartTag && null != mystartDate ) { throw new BuildException ( "Only one of start tag and start date " + "must be set." ) ; } if ( null == myendTag && null == myendDate ) { throw new BuildException ( "End tag or end date must be set." ) ; } if ( null != myendTag && null != myendDate ) { throw new BuildException ( "Only one of end tag and end date must " + "be set." ) ; } } } 	0	['12', '4', '0', '5', '60', '16', '0', '5', '8', '0.902097902', '720', '0.538461538', '1', '0.876404494', '0.305555556', '1', '2', '57.91666667', '3', '1.0833', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . util . Date ; import java . util . Vector ; class CVSEntry { private Date m_date ; private String m_author ; private final String m_comment ; private final Vector m_files = new Vector ( ) ; public CVSEntry ( Date date , String author , String comment ) { m_date = date ; m_author = author ; m_comment = comment ; } public void addFile ( String file , String revision ) { m_files . addElement ( new RCSFile ( file , revision ) ) ; } public void addFile ( String file , String revision , String previousRevision ) { m_files . addElement ( new RCSFile ( file , revision , previousRevision ) ) ; } Date getDate ( ) { return m_date ; } void setAuthor ( final String author ) { m_author = author ; } String getAuthor ( ) { return m_author ; } String getComment ( ) { return m_comment ; } Vector getFiles ( ) { return m_files ; } public String toString ( ) { return getAuthor ( ) + "\n" + getDate ( ) + "\n" + getFiles ( ) + "\n" + getComment ( ) ; } } 	0	['9', '1', '0', '4', '18', '14', '3', '1', '4', '0.65625', '88', '1', '0', '0', '0.518518519', '0', '0', '8.333333333', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property = null ; private String value = "true" ; public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <condition>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<condition>" ) ; } if ( property == null ) { throw new BuildException ( "The property attribute is required." ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { log ( "Condition true; setting " + property + " to " + value , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { log ( "Condition false; not setting " + property , Project . MSG_DEBUG ) ; } } } 	0	['4', '3', '0', '5', '16', '0', '0', '5', '4', '0.333333333', '95', '1', '0', '0.914285714', '0.75', '0', '0', '22.25', '1', '0.75', '0']
package org . apache . tools . ant . types ; import java . security . UnresolvedPermission ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; public class Permissions { private List grantedPermissions = new LinkedList ( ) ; private List revokedPermissions = new LinkedList ( ) ; private java . security . Permissions granted = null ; private SecurityManager origSm = null ; private boolean active = false ; private boolean delegateToOldSM = false ; public Permissions ( ) { } public Permissions ( boolean delegateToOldSM ) { this . delegateToOldSM = delegateToOldSM ; } public void addConfiguredGrant ( Permissions . Permission perm ) { grantedPermissions . add ( perm ) ; } public void addConfiguredRevoke ( Permissions . Permission perm ) { revokedPermissions . add ( perm ) ; } public void setSecurityManager ( ) throws BuildException { origSm = System . getSecurityManager ( ) ; init ( ) ; System . setSecurityManager ( new MySM ( ) ) ; active = true ; } private void init ( ) throws BuildException { granted = new java . security . Permissions ( ) ; for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Revoked permission " + p + " does not contain a class." ) ; } } for ( Iterator i = grantedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Granted permission " + p + " does not contain a class." ) ; } else { java . security . Permission perm = new UnresolvedPermission ( p . getClassName ( ) , p . getName ( ) , p . getActions ( ) , null ) ; granted . add ( perm ) ; } } granted . add ( new java . net . SocketPermission ( "localhost:1024-" , "listen" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor.url" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.class.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.arch" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.encoding" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "path.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "line.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.name" , "read" ) ) ; } public void restoreSecurityManager ( ) { active = false ; System . setSecurityManager ( origSm ) ; } private class MySM extends SecurityManager { public void checkExit ( int status ) { java . security . Permission perm = new java . lang . RuntimePermission ( "exitVM" , null ) ; try { checkPermission ( perm ) ; } catch ( SecurityException e ) { throw new ExitException ( e . getMessage ( ) , status ) ; } } public void checkPermission ( java . security . Permission perm ) { if ( active ) { if ( delegateToOldSM && ! perm . getName ( ) . equals ( "exitVM" ) ) { boolean permOK = false ; if ( granted . implies ( perm ) ) { permOK = true ; } checkRevoked ( perm ) ; if ( ! permOK && origSm != null ) { origSm . checkPermission ( perm ) ; } } else { if ( ! granted . implies ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was not granted." ) ; } checkRevoked ( perm ) ; } } } private void checkRevoked ( java . security . Permission perm ) { for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { if ( ( ( Permissions . Permission ) i . next ( ) ) . matches ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was revoked." ) ; } } } } public static class Permission { private String className ; private String name ; private String actionString ; private Set actions ; public void setClass ( String aClass ) { className = aClass . trim ( ) ; } public String getClassName ( ) { return className ; } public void setName ( String aName ) { name = aName . trim ( ) ; } public String getName ( ) { return name ; } public void setActions ( String actions ) { actionString = actions ; if ( actions . length ( ) > 0 ) { this . actions = parseActions ( actions ) ; } } public String getActions ( ) { return actionString ; } boolean matches ( java . security . Permission perm ) { if ( ! className . equals ( perm . getClass ( ) . getName ( ) ) ) { return false ; } if ( name != null ) { if ( name . endsWith ( "*" ) ) { if ( ! perm . getName ( ) . startsWith ( name . substring ( 0 , name . length ( ) - 1 ) ) ) { return false ; } } else { if ( ! name . equals ( perm . getName ( ) ) ) { return false ; } } } if ( actions != null ) { Set as = parseActions ( perm . getActions ( ) ) ; int size = as . size ( ) ; as . removeAll ( actions ) ; if ( as . size ( ) == size ) { return false ; } } return true ; } private Set parseActions ( String actions ) { Set result = new HashSet ( ) ; StringTokenizer tk = new StringTokenizer ( actions , "," ) ; while ( tk . hasMoreTokens ( ) ) { String item = tk . nextToken ( ) . trim ( ) ; if ( ! item . equals ( "" ) ) { result . add ( item ) ; } } return result ; } public String toString ( ) { return ( "Permission: " + className + " (\"" + name + "\", \"" + actions + "\")" ) ; } } } 	0	['12', '1', '0', '6', '34', '4', '3', '4', '6', '0.651515152', '367', '1', '0', '0', '0.3125', '0', '0', '29.08333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Dirname extends Task { private File file ; private String property ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } else { String value = file . getParent ( ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['4', '3', '0', '5', '10', '2', '0', '5', '4', '0.666666667', '48', '1', '0', '0.925', '0.5', '0', '0', '10.5', '1', '0.75', '0']
package org . apache . tools . zip ; import java . util . Hashtable ; import java . util . Vector ; import java . util . zip . ZipException ; public class ExtraFieldUtils { private static Hashtable implementations ; static { implementations = new Hashtable ( ) ; register ( AsiExtraField . class ) ; } public static void register ( Class c ) { try { ZipExtraField ze = ( ZipExtraField ) c . newInstance ( ) ; implementations . put ( ze . getHeaderId ( ) , c ) ; } catch ( ClassCastException cc ) { throw new RuntimeException ( c + " doesn\'t implement ZipExtraField" ) ; } catch ( InstantiationException ie ) { throw new RuntimeException ( c + " is not a concrete class" ) ; } catch ( IllegalAccessException ie ) { throw new RuntimeException ( c + "\'s no-arg constructor is not public" ) ; } } public static ZipExtraField createExtraField ( ZipShort headerId ) throws InstantiationException , IllegalAccessException { Class c = ( Class ) implementations . get ( headerId ) ; if ( c != null ) { return ( ZipExtraField ) c . newInstance ( ) ; } UnrecognizedExtraField u = new UnrecognizedExtraField ( ) ; u . setHeaderId ( headerId ) ; return u ; } public static ZipExtraField [ ] parse ( byte [ ] data ) throws ZipException { Vector v = new Vector ( ) ; int start = 0 ; while ( start <= data . length - 4 ) { ZipShort headerId = new ZipShort ( data , start ) ; int length = ( new ZipShort ( data , start + 2 ) ) . getValue ( ) ; if ( start + 4 + length > data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } try { ZipExtraField ze = createExtraField ( headerId ) ; ze . parseFromLocalFileData ( data , start + 4 , length ) ; v . addElement ( ze ) ; } catch ( InstantiationException ie ) { throw new ZipException ( ie . getMessage ( ) ) ; } catch ( IllegalAccessException iae ) { throw new ZipException ( iae . getMessage ( ) ) ; } start += ( length + 4 ) ; } if ( start != data . length ) { throw new ZipException ( "data starting at " + start + " is in unknown format" ) ; } ZipExtraField [ ] result = new ZipExtraField [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public static byte [ ] mergeLocalFileDataData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getLocalFileDataLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getLocalFileDataLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getLocalFileDataData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } public static byte [ ] mergeCentralDirectoryData ( ZipExtraField [ ] data ) { int sum = 4 * data . length ; for ( int i = 0 ; i < data . length ; i ++ ) { sum += data [ i ] . getCentralDirectoryLength ( ) . getValue ( ) ; } byte [ ] result = new byte [ sum ] ; int start = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { System . arraycopy ( data [ i ] . getHeaderId ( ) . getBytes ( ) , 0 , result , start , 2 ) ; System . arraycopy ( data [ i ] . getCentralDirectoryLength ( ) . getBytes ( ) , 0 , result , start + 2 , 2 ) ; byte [ ] local = data [ i ] . getCentralDirectoryData ( ) ; System . arraycopy ( local , 0 , result , start + 4 , local . length ) ; start += ( local . length + 4 ) ; } return result ; } } 	0	['8', '1', '0', '4', '39', '22', '1', '3', '6', '0.785714286', '377', '0.5', '0', '0', '0.166666667', '0', '0', '45.875', '3', '1.25', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class BaseSelectorContainer extends BaseSelector implements SelectorContainer { private Vector selectorsList = new Vector ( ) ; public BaseSelectorContainer ( ) { } public boolean hasSelectors ( ) { return ! ( selectorsList . isEmpty ( ) ) ; } public int selectorCount ( ) { return selectorsList . size ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { FileSelector [ ] result = new FileSelector [ selectorsList . size ( ) ] ; selectorsList . copyInto ( result ) ; return result ; } public Enumeration selectorElements ( ) { return selectorsList . elements ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = selectorElements ( ) ; if ( e . hasMoreElements ( ) ) { while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) . toString ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } } return buf . toString ( ) ; } public void appendSelector ( FileSelector selector ) { selectorsList . addElement ( selector ) ; } public void validate ( ) { verifySettings ( ) ; String errmsg = getError ( ) ; if ( errmsg != null ) { throw new BuildException ( errmsg ) ; } Enumeration e = selectorElements ( ) ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof BaseSelector ) { ( ( BaseSelector ) o ) . validate ( ) ; } } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; public void addSelector ( SelectSelector selector ) { appendSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { appendSelector ( selector ) ; } public void addOr ( OrSelector selector ) { appendSelector ( selector ) ; } public void addNot ( NotSelector selector ) { appendSelector ( selector ) ; } public void addNone ( NoneSelector selector ) { appendSelector ( selector ) ; } public void addMajority ( MajoritySelector selector ) { appendSelector ( selector ) ; } public void addDate ( DateSelector selector ) { appendSelector ( selector ) ; } public void addSize ( SizeSelector selector ) { appendSelector ( selector ) ; } public void addFilename ( FilenameSelector selector ) { appendSelector ( selector ) ; } public void addCustom ( ExtendSelector selector ) { appendSelector ( selector ) ; } public void addContains ( ContainsSelector selector ) { appendSelector ( selector ) ; } public void addPresent ( PresentSelector selector ) { appendSelector ( selector ) ; } public void addDepth ( DepthSelector selector ) { appendSelector ( selector ) ; } public void addDepend ( DependSelector selector ) { appendSelector ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { appendSelector ( selector ) ; } public void addType ( TypeSelector selector ) { appendSelector ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { appendSelector ( selector ) ; } public void addModified ( ModifiedSelector selector ) { appendSelector ( selector ) ; } public void add ( FileSelector selector ) { appendSelector ( selector ) ; } } 	0	['28', '4', '5', '23', '45', '348', '6', '23', '28', '0.037037037', '204', '1', '0', '0.564516129', '0.079192547', '0', '0', '6.25', '4', '1.2143', '0']
package org . apache . tools . ant . util ; import java . util . Dictionary ; import java . util . Enumeration ; import java . util . NoSuchElementException ; import java . util . Vector ; public class CollectionUtils { public static boolean equals ( Vector v1 , Vector v2 ) { if ( v1 == v2 ) { return true ; } if ( v1 == null || v2 == null ) { return false ; } return v1 . equals ( v2 ) ; } public static boolean equals ( Dictionary d1 , Dictionary d2 ) { if ( d1 == d2 ) { return true ; } if ( d1 == null || d2 == null ) { return false ; } if ( d1 . size ( ) != d2 . size ( ) ) { return false ; } Enumeration e1 = d1 . keys ( ) ; while ( e1 . hasMoreElements ( ) ) { Object key = e1 . nextElement ( ) ; Object value1 = d1 . get ( key ) ; Object value2 = d2 . get ( key ) ; if ( value2 == null || ! value1 . equals ( value2 ) ) { return false ; } } return true ; } public static void putAll ( Dictionary m1 , Dictionary m2 ) { for ( Enumeration it = m2 . keys ( ) ; it . hasMoreElements ( ) ; ) { Object key = it . nextElement ( ) ; m1 . put ( key , m2 . get ( key ) ) ; } } public static final class EmptyEnumeration implements Enumeration { public EmptyEnumeration ( ) { } public boolean hasMoreElements ( ) { return false ; } public Object nextElement ( ) throws NoSuchElementException { throw new NoSuchElementException ( ) ; } } } 	0	['4', '1', '0', '3', '13', '6', '3', '0', '4', '2', '86', '0', '0', '0', '0.333333333', '1', '1', '20.5', '8', '3.5', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public interface RegexpMatcher { int MATCH_DEFAULT = 0x00000000 ; int MATCH_CASE_INSENSITIVE = 0x00000100 ; int MATCH_MULTILINE = 0x00001000 ; int MATCH_SINGLELINE = 0x00010000 ; void setPattern ( String pattern ) throws BuildException ; String getPattern ( ) throws BuildException ; boolean matches ( String argument ) throws BuildException ; Vector getGroups ( String argument ) throws BuildException ; boolean matches ( String input , int options ) throws BuildException ; Vector getGroups ( String input , int options ) throws BuildException ; } 	0	['6', '1', '0', '11', '6', '15', '10', '1', '6', '1.2', '10', '0', '0', '0', '0.722222222', '0', '0', '0', '1', '1', '0']
package org . apache . tools . bzip2 ; import java . io . InputStream ; import java . io . IOException ; public class CBZip2InputStream extends InputStream implements BZip2Constants { private static void cadvise ( ) { System . out . println ( "CRC Error" ) ; } private static void badBGLengths ( ) { cadvise ( ) ; } private static void bitStreamEOF ( ) { cadvise ( ) ; } private static void compressedStreamEOF ( ) { cadvise ( ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } private int last ; private int origPtr ; private int blockSize100k ; private boolean blockRandomised ; private int bsBuff ; private int bsLive ; private CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private int [ ] tt ; private char [ ] ll8 ; private int [ ] unzftab = new int [ 256 ] ; private int [ ] [ ] limit = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] [ ] base = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] [ ] perm = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; private int [ ] minLens = new int [ N_GROUPS ] ; private InputStream bsStream ; private boolean streamEnd = false ; private int currentChar = - 1 ; private static final int START_BLOCK_STATE = 1 ; private static final int RAND_PART_A_STATE = 2 ; private static final int RAND_PART_B_STATE = 3 ; private static final int RAND_PART_C_STATE = 4 ; private static final int NO_RAND_PART_A_STATE = 5 ; private static final int NO_RAND_PART_B_STATE = 6 ; private static final int NO_RAND_PART_C_STATE = 7 ; private int currentState = START_BLOCK_STATE ; private int storedBlockCRC , storedCombinedCRC ; private int computedBlockCRC , computedCombinedCRC ; int i2 , count , chPrev , ch2 ; int i , tPos ; int rNToGo = 0 ; int rTPos = 0 ; int j2 ; char z ; public CBZip2InputStream ( InputStream zStream ) { ll8 = null ; tt = null ; bsSetStream ( zStream ) ; initialize ( ) ; initBlock ( ) ; setupBlock ( ) ; } public int read ( ) { if ( streamEnd ) { return - 1 ; } else { int retChar = currentChar ; switch ( currentState ) { case START_BLOCK_STATE : break ; case RAND_PART_A_STATE : break ; case RAND_PART_B_STATE : setupRandPartB ( ) ; break ; case RAND_PART_C_STATE : setupRandPartC ( ) ; break ; case NO_RAND_PART_A_STATE : break ; case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; break ; case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; break ; default : break ; } return retChar ; } } private void initialize ( ) { char magic3 , magic4 ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; if ( magic3 != 'h' || magic4 < '1' || magic4 > '9' ) { bsFinishedWithStream ( ) ; streamEnd = true ; return ; } setDecompressStructureSizes ( magic4 - '0' ) ; computedCombinedCRC = 0 ; } private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90 ) { complete ( ) ; return ; } if ( magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; } private void endBlock ( ) { computedBlockCRC = mCrc . getFinalCRC ( ) ; if ( storedBlockCRC != computedBlockCRC ) { crcError ( ) ; } computedCombinedCRC = ( computedCombinedCRC << 1 ) | ( computedCombinedCRC > > > 31 ) ; computedCombinedCRC ^= computedBlockCRC ; } private void complete ( ) { storedCombinedCRC = bsGetInt32 ( ) ; if ( storedCombinedCRC != computedCombinedCRC ) { crcError ( ) ; } bsFinishedWithStream ( ) ; streamEnd = true ; } private static void blockOverrun ( ) { cadvise ( ) ; } private static void badBlockHeader ( ) { cadvise ( ) ; } private static void crcError ( ) { cadvise ( ) ; } private void bsFinishedWithStream ( ) { try { if ( this . bsStream != null ) { if ( this . bsStream != System . in ) { this . bsStream . close ( ) ; this . bsStream = null ; } } } catch ( IOException ioe ) { } } private void bsSetStream ( InputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; } private int bsR ( int n ) { int v ; while ( bsLive < n ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } v = ( bsBuff > > ( bsLive - n ) ) & ( ( 1 << n ) - 1 ) ; bsLive -= n ; return v ; } private char bsGetUChar ( ) { return ( char ) bsR ( 8 ) ; } private int bsGetint ( ) { int u = 0 ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; u = ( u << 8 ) | bsR ( 8 ) ; return u ; } private int bsGetIntVS ( int numBits ) { return ( int ) bsR ( numBits ) ; } private int bsGetInt32 ( ) { return ( int ) bsGetint ( ) ; } private void hbCreateDecodeTables ( int [ ] limit , int [ ] base , int [ ] perm , char [ ] length , int minLen , int maxLen , int alphaSize ) { int pp , i , j , vec ; pp = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { for ( j = 0 ; j < alphaSize ; j ++ ) { if ( length [ j ] == i ) { perm [ pp ] = j ; pp ++ ; } } } for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] = 0 ; } for ( i = 0 ; i < alphaSize ; i ++ ) { base [ length [ i ] + 1 ] ++ ; } for ( i = 1 ; i < MAX_CODE_LEN ; i ++ ) { base [ i ] += base [ i - 1 ] ; } for ( i = 0 ; i < MAX_CODE_LEN ; i ++ ) { limit [ i ] = 0 ; } vec = 0 ; for ( i = minLen ; i <= maxLen ; i ++ ) { vec += ( base [ i + 1 ] - base [ i ] ) ; limit [ i ] = vec - 1 ; vec <<= 1 ; } for ( i = minLen + 1 ; i <= maxLen ; i ++ ) { base [ i ] = ( ( limit [ i - 1 ] + 1 ) << 1 ) - base [ i ] ; } } private void recvDecodingTables ( ) { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int i , j , t , nGroups , nSelectors , alphaSize ; int minLen , maxLen ; boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { if ( bsR ( 1 ) == 1 ) { inUse16 [ i ] = true ; } else { inUse16 [ i ] = false ; } } for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( bsR ( 1 ) == 1 ) { inUse [ i * 16 + j ] = true ; } } } } makeMaps ( ) ; alphaSize = nInUse + 2 ; nGroups = bsR ( 3 ) ; nSelectors = bsR ( 15 ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { j = 0 ; while ( bsR ( 1 ) == 1 ) { j ++ ; } selectorMtf [ i ] = ( char ) j ; } { char [ ] pos = new char [ N_GROUPS ] ; char tmp , v ; for ( v = 0 ; v < nGroups ; v ++ ) { pos [ v ] = v ; } for ( i = 0 ; i < nSelectors ; i ++ ) { v = selectorMtf [ i ] ; tmp = pos [ v ] ; while ( v > 0 ) { pos [ v ] = pos [ v - 1 ] ; v -- ; } pos [ 0 ] = tmp ; selector [ i ] = tmp ; } } for ( t = 0 ; t < nGroups ; t ++ ) { int curr = bsR ( 5 ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( bsR ( 1 ) == 1 ) { if ( bsR ( 1 ) == 0 ) { curr ++ ; } else { curr -- ; } } len [ t ] [ i ] = ( char ) curr ; } } for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } hbCreateDecodeTables ( limit [ t ] , base [ t ] , perm [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; minLens [ t ] = minLen ; } } private void getAndMoveToFrontDecode ( ) { char [ ] yy = new char [ 256 ] ; int i , j , nextSym , limitLast ; int EOB , groupNo , groupPos ; limitLast = baseBlockSize * blockSize100k ; origPtr = bsGetIntVS ( 24 ) ; recvDecodingTables ( ) ; EOB = nInUse + 1 ; groupNo = - 1 ; groupPos = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { unzftab [ i ] = 0 ; } for ( i = 0 ; i <= 255 ; i ++ ) { yy [ i ] = ( char ) i ; } last = - 1 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } while ( true ) { if ( nextSym == EOB ) { break ; } if ( nextSym == RUNA || nextSym == RUNB ) { char ch ; int s = - 1 ; int N = 1 ; do { if ( nextSym == RUNA ) { s = s + ( 0 + 1 ) * N ; } else if ( nextSym == RUNB ) { s = s + ( 1 + 1 ) * N ; } N = N * 2 ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } if ( thech == - 1 ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } } while ( nextSym == RUNA || nextSym == RUNB ) ; s ++ ; ch = seqToUnseq [ yy [ 0 ] ] ; unzftab [ ch ] += s ; while ( s > 0 ) { last ++ ; ll8 [ last ] = ch ; s -- ; } if ( last >= limitLast ) { blockOverrun ( ) ; } continue ; } else { char tmp ; last ++ ; if ( last >= limitLast ) { blockOverrun ( ) ; } tmp = yy [ nextSym - 1 ] ; unzftab [ seqToUnseq [ tmp ] ] ++ ; ll8 [ last ] = seqToUnseq [ tmp ] ; j = nextSym - 1 ; for ( ; j > 3 ; j -= 4 ) { yy [ j ] = yy [ j - 1 ] ; yy [ j - 1 ] = yy [ j - 2 ] ; yy [ j - 2 ] = yy [ j - 3 ] ; yy [ j - 3 ] = yy [ j - 4 ] ; } for ( ; j > 0 ; j -- ) { yy [ j ] = yy [ j - 1 ] ; } yy [ 0 ] = tmp ; { int zt , zn , zvec , zj ; if ( groupPos == 0 ) { groupNo ++ ; groupPos = G_SIZE ; } groupPos -- ; zt = selector [ groupNo ] ; zn = minLens [ zt ] ; zvec = bsR ( zn ) ; while ( zvec > limit [ zt ] [ zn ] ) { zn ++ ; { { while ( bsLive < 1 ) { int zzi ; char thech = 0 ; try { thech = ( char ) bsStream . read ( ) ; } catch ( IOException e ) { compressedStreamEOF ( ) ; } zzi = thech ; bsBuff = ( bsBuff << 8 ) | ( zzi & 0xff ) ; bsLive += 8 ; } } zj = ( bsBuff > > ( bsLive - 1 ) ) & 1 ; bsLive -- ; } zvec = ( zvec << 1 ) | zj ; } nextSym = perm [ zt ] [ zvec - base [ zt ] [ zn ] ] ; } continue ; } } } private void setupBlock ( ) { int [ ] cftab = new int [ 257 ] ; char ch ; cftab [ 0 ] = 0 ; for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] = unzftab [ i - 1 ] ; } for ( i = 1 ; i <= 256 ; i ++ ) { cftab [ i ] += cftab [ i - 1 ] ; } for ( i = 0 ; i <= last ; i ++ ) { ch = ( char ) ll8 [ i ] ; tt [ cftab [ ch ] ] = i ; cftab [ ch ] ++ ; } cftab = null ; tPos = tt [ origPtr ] ; count = 0 ; i2 = 0 ; ch2 = 256 ; if ( blockRandomised ) { rNToGo = 0 ; rTPos = 0 ; setupRandPartA ( ) ; } else { setupNoRandPartA ( ) ; } } private void setupRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; ch2 ^= ( int ) ( ( rNToGo == 1 ) ? 1 : 0 ) ; i2 ++ ; currentChar = ch2 ; currentState = RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupNoRandPartA ( ) { if ( i2 <= last ) { chPrev = ch2 ; ch2 = ll8 [ tPos ] ; tPos = tt [ tPos ] ; i2 ++ ; currentChar = ch2 ; currentState = NO_RAND_PART_B_STATE ; mCrc . updateCRC ( ch2 ) ; } else { endBlock ( ) ; initBlock ( ) ; setupBlock ( ) ; } } private void setupRandPartB ( ) { if ( ch2 != chPrev ) { currentState = RAND_PART_A_STATE ; count = 1 ; setupRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; if ( rNToGo == 0 ) { rNToGo = rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; z ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; j2 = 0 ; currentState = RAND_PART_C_STATE ; setupRandPartC ( ) ; } else { currentState = RAND_PART_A_STATE ; setupRandPartA ( ) ; } } } private void setupRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupRandPartA ( ) ; } } private void setupNoRandPartB ( ) { if ( ch2 != chPrev ) { currentState = NO_RAND_PART_A_STATE ; count = 1 ; setupNoRandPartA ( ) ; } else { count ++ ; if ( count >= 4 ) { z = ll8 [ tPos ] ; tPos = tt [ tPos ] ; currentState = NO_RAND_PART_C_STATE ; j2 = 0 ; setupNoRandPartC ( ) ; } else { currentState = NO_RAND_PART_A_STATE ; setupNoRandPartA ( ) ; } } } private void setupNoRandPartC ( ) { if ( j2 < ( int ) z ) { currentChar = ch2 ; mCrc . updateCRC ( ch2 ) ; j2 ++ ; } else { currentState = NO_RAND_PART_A_STATE ; i2 ++ ; count = 0 ; setupNoRandPartA ( ) ; } } private void setDecompressStructureSizes ( int newSize100k ) { if ( ! ( 0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9 ) ) { } blockSize100k = newSize100k ; if ( newSize100k == 0 ) { return ; } int n = baseBlockSize * newSize100k ; ll8 = new char [ n ] ; tt = new int [ n ] ; } } 	0	['32', '2', '0', '4', '40', '330', '2', '2', '2', '0.772759857', '2011', '0.777777778', '1', '0.225', '0.20625', '1', '1', '60.4375', '26', '4.0938', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLiaison2 extends XSLTLiaison { void configure ( XSLTProcess xsltTask ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; public class UnrecognizedExtraField implements ZipExtraField { private ZipShort headerId ; public void setHeaderId ( ZipShort headerId ) { this . headerId = headerId ; } public ZipShort getHeaderId ( ) { return headerId ; } private byte [ ] localData ; public void setLocalFileDataData ( byte [ ] data ) { localData = data ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( localData . length ) ; } public byte [ ] getLocalFileDataData ( ) { return localData ; } private byte [ ] centralData ; public void setCentralDirectoryData ( byte [ ] data ) { centralData = data ; } public ZipShort getCentralDirectoryLength ( ) { if ( centralData != null ) { return new ZipShort ( centralData . length ) ; } return getLocalFileDataLength ( ) ; } public byte [ ] getCentralDirectoryData ( ) { if ( centralData != null ) { return centralData ; } return getLocalFileDataData ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) { byte [ ] tmp = new byte [ length ] ; System . arraycopy ( data , offset , tmp , 0 , length ) ; setLocalFileDataData ( tmp ) ; } } 	0	['10', '1', '0', '3', '13', '31', '1', '2', '10', '0.703703704', '76', '1', '1', '0', '0.375', '0', '0', '6.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . PrintWriter ; import org . apache . tools . ant . ProjectComponent ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; private String charset = null ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream ps ) throws IOException { PrintWriter out = charset != null ? new PrintWriter ( new OutputStreamWriter ( ps , charset ) ) : new PrintWriter ( ps ) ; if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . substring ( 0 ) ) ) ; } out . flush ( ) ; } public boolean isMimeTypeSpecified ( ) { return specified ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['11', '2', '0', '6', '26', '0', '4', '2', '11', '0.58', '181', '1', '0', '0.529411765', '0.409090909', '0', '0', '15', '1', '0.7273', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public class EscapeUnicode extends BaseParamFilterReader implements ChainableReader { private StringBuffer unicodeBuf ; public EscapeUnicode ( ) { super ( ) ; unicodeBuf = new StringBuffer ( ) ; } public EscapeUnicode ( final Reader in ) { super ( in ) ; unicodeBuf = new StringBuffer ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( unicodeBuf . length ( ) == 0 ) { ch = in . read ( ) ; if ( ch != - 1 ) { char achar = ( char ) ch ; if ( achar >= '' ) { unicodeBuf = new StringBuffer ( "u0000" ) ; String s = Integer . toHexString ( ch ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { unicodeBuf . setCharAt ( unicodeBuf . length ( ) - s . length ( ) + i , s . charAt ( i ) ) ; } ch = '\\' ; } } } else { ch = ( int ) unicodeBuf . charAt ( 0 ) ; unicodeBuf . deleteCharAt ( 0 ) ; } return ch ; } public final Reader chain ( final Reader rdr ) { EscapeUnicode newFilter = new EscapeUnicode ( rdr ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { } } 	0	['5', '5', '0', '4', '19', '4', '1', '3', '4', '0.25', '107', '1', '0', '0.903225806', '0.7', '2', '5', '20.2', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( getProject ( ) . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = getProject ( ) . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not " + "found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = getProject ( ) . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , getLocation ( ) ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , getLocation ( ) ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = getProject ( ) . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; public StreamPumper ( InputStream is , int messageLevel ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; } public void pumpStream ( ) throws IOException { if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '6', '44', '21', '1', '6', '7', '0.740740741', '367', '1', '0', '0.804347826', '0.45', '0', '0', '35.1', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Unpack extends Task { protected File source ; protected File dest ; public void setSrc ( String src ) { log ( "DEPRECATED - The setSrc(String) method has been deprecated." + " Use setSrc(File) instead." ) ; setSrc ( getProject ( ) . resolveFile ( src ) ) ; } public void setDest ( String dest ) { log ( "DEPRECATED - The setDest(String) method has been deprecated." + " Use setDest(File) instead." ) ; setDest ( getProject ( ) . resolveFile ( dest ) ) ; } public void setSrc ( File src ) { source = src ; } public void setDest ( File dest ) { this . dest = dest ; } private void validate ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No Src specified" , getLocation ( ) ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "Src doesn't exist" , getLocation ( ) ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , getLocation ( ) ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String defaultExtension = getDefaultExtension ( ) ; createDestFile ( defaultExtension ) ; } } private void createDestFile ( String defaultExtension ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( defaultExtension != null && len > defaultExtension . length ( ) && defaultExtension . equalsIgnoreCase ( sourceName . substring ( len - defaultExtension . length ( ) ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - defaultExtension . length ( ) ) ) ; } else { dest = new File ( dest , sourceName ) ; } } public void execute ( ) throws BuildException { File savedDest = dest ; try { validate ( ) ; extract ( ) ; } finally { dest = savedDest ; } } protected abstract String getDefaultExtension ( ) ; protected abstract void extract ( ) ; } 	0	['10', '3', '2', '7', '26', '29', '2', '5', '6', '0.555555556', '162', '1', '0', '0.804347826', '0.5', '0', '0', '15', '4', '1.2', '0']
package org . apache . tools . ant . types ; public class DirSet extends AbstractFileSet { public DirSet ( ) { super ( ) ; } protected DirSet ( DirSet dirset ) { super ( dirset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } } 	0	['3', '4', '0', '9', '9', '3', '5', '4', '2', '2', '23', '0', '0', '0.988636364', '0.666666667', '3', '4', '6.666666667', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Locale ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( getProject ( ) , d , getLocation ( ) ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; setProperty ( "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } private void setProperty ( String name , String value ) { getProject ( ) . setNewProperty ( prefix + name , value ) ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } Tstamp . this . setProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Hashtable calendarFields = new Hashtable ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['6', '3', '0', '6', '26', '3', '1', '6', '4', '0.4', '134', '1', '0', '0.880952381', '0.5', '0', '0', '21', '2', '1', '0']
package org . apache . tools . ant . input ; public class InputRequest { private String prompt ; private String input ; public InputRequest ( String prompt ) { if ( prompt == null ) { throw new IllegalArgumentException ( "prompt must not be null" ) ; } this . prompt = prompt ; } public String getPrompt ( ) { return prompt ; } public void setInput ( String input ) { this . input = input ; } public boolean isInputValid ( ) { return true ; } public String getInput ( ) { return input ; } } 	0	['5', '1', '1', '5', '7', '6', '5', '0', '5', '0.75', '32', '1', '0', '0', '0.7', '0', '0', '5', '1', '0.8', '0']
package org . apache . tools . ant . util ; import java . util . Enumeration ; import java . util . Vector ; public class Watchdog implements Runnable { private Vector observers = new Vector ( 1 ) ; private long timeout = - 1 ; private boolean stopped = false ; public Watchdog ( long timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public void addTimeoutObserver ( TimeoutObserver to ) { observers . addElement ( to ) ; } public void removeTimeoutObserver ( TimeoutObserver to ) { observers . removeElement ( to ) ; } protected final void fireTimeoutOccured ( ) { Enumeration e = observers . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( TimeoutObserver ) e . nextElement ( ) ) . timeoutOccured ( this ) ; } } public synchronized void start ( ) { stopped = false ; Thread t = new Thread ( this , "WATCHDOG" ) ; t . setDaemon ( true ) ; t . start ( ) ; } public synchronized void stop ( ) { stopped = true ; notifyAll ( ) ; } public synchronized void run ( ) { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( ! stopped && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } if ( ! stopped ) { fireTimeoutOccured ( ) ; } } } 	0	['7', '1', '0', '3', '22', '0', '3', '1', '6', '0.555555556', '112', '1', '0', '0', '0.476190476', '0', '0', '14.57142857', '4', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class ExecTask extends Task { private String os ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Long timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private String resultProperty ; private boolean failIfExecFails = true ; private String executable ; private boolean resolveExecutable = false ; private boolean spawn = false ; private boolean incompatibleWithSpawn = false ; private Redirector redirector = new Redirector ( this ) ; private boolean vmLauncher = true ; public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public void setTimeout ( Long value ) { timeout = value ; incompatibleWithSpawn = true ; } public void setTimeout ( Integer value ) { if ( value == null ) { timeout = null ; } else { setTimeout ( new Long ( value . intValue ( ) ) ) ; } incompatibleWithSpawn = true ; } public void setExecutable ( String value ) { this . executable = value ; cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { redirector . setOutput ( out ) ; incompatibleWithSpawn = true ; } public void setInput ( File input ) { redirector . setInput ( input ) ; incompatibleWithSpawn = true ; } public void setInputString ( String inputString ) { redirector . setInputString ( inputString ) ; incompatibleWithSpawn = true ; } public void setLogError ( boolean logError ) { redirector . setLogError ( logError ) ; incompatibleWithSpawn = true ; } public void setError ( File error ) { redirector . setError ( error ) ; incompatibleWithSpawn = true ; } public void setOutputproperty ( String outputProp ) { redirector . setOutputProperty ( outputProp ) ; incompatibleWithSpawn = true ; } public void setErrorProperty ( String errorProperty ) { redirector . setErrorProperty ( errorProperty ) ; incompatibleWithSpawn = true ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; incompatibleWithSpawn = true ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void setResolveExecutable ( boolean resolveExecutable ) { this . resolveExecutable = resolveExecutable ; } public boolean getResolveExecutable ( ) { return resolveExecutable ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setResultProperty ( String resultProperty ) { this . resultProperty = resultProperty ; incompatibleWithSpawn = true ; } protected void maybeSetResultPropertyValue ( int result ) { String res = Integer . toString ( result ) ; if ( resultProperty != null ) { getProject ( ) . setNewProperty ( resultProperty , res ) ; } } public void setFailIfExecutionFails ( boolean flag ) { failIfExecFails = flag ; incompatibleWithSpawn = true ; } public void setAppend ( boolean append ) { redirector . setAppend ( append ) ; incompatibleWithSpawn = true ; } protected String resolveExecutable ( String exec , boolean searchPath ) { if ( ! resolveExecutable ) { return exec ; } File executableFile = getProject ( ) . resolveFile ( exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } FileUtils fileUtils = FileUtils . newFileUtils ( ) ; if ( dir != null ) { executableFile = fileUtils . resolveFile ( dir , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } if ( searchPath ) { Vector env = Execute . getProcEnvironment ( ) ; Enumeration e = env . elements ( ) ; Path p = null ; while ( e . hasMoreElements ( ) ) { String line = ( String ) e . nextElement ( ) ; if ( line . startsWith ( "PATH=" ) || line . startsWith ( "Path=" ) ) { p = new Path ( getProject ( ) , line . substring ( 5 ) ) ; break ; } } if ( p != null ) { String [ ] dirs = p . list ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { executableFile = fileUtils . resolveFile ( new File ( dirs [ i ] ) , exec ) ; if ( executableFile . exists ( ) ) { return executableFile . getAbsolutePath ( ) ; } } } } return exec ; } public void execute ( ) throws BuildException { File savedDir = dir ; cmdl . setExecutable ( resolveExecutable ( executable , false ) ) ; checkConfiguration ( ) ; if ( isValidOs ( ) ) { try { runExec ( prepareExec ( ) ) ; } finally { dir = savedDir ; } } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , getLocation ( ) ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not " + "exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a " + "directory" ) ; } if ( spawn && incompatibleWithSpawn ) { getProject ( ) . log ( "spawn does not allow attributes related to input, " + "output, error, result" , Project . MSG_ERR ) ; getProject ( ) . log ( "spawn does not also not allow timeout" , Project . MSG_ERR ) ; throw new BuildException ( "You have used an attribute which is " + "not compatible with spawn" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Current OS is " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "This OS, " + myos + " was not found in the specified list of valid OSes: " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void setVMLauncher ( boolean vmLauncher ) { this . vmLauncher = vmLauncher ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( dir ) ; exe . setVMLauncher ( vmLauncher ) ; exe . setSpawn ( spawn ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected final void runExecute ( Execute exe ) throws IOException { int returnCode = - 1 ; if ( ! spawn ) { returnCode = exe . execute ( ) ; if ( exe . killedProcess ( ) ) { String msg = "Timeout: killed the sub-process" ; if ( failOnError ) { throw new BuildException ( msg ) ; } else { log ( msg , Project . MSG_WARN ) ; } } maybeSetResultPropertyValue ( returnCode ) ; if ( Execute . isFailure ( returnCode ) ) { if ( failOnError ) { throw new BuildException ( getTaskType ( ) + " returned: " + returnCode , getLocation ( ) ) ; } else { log ( "Result: " + returnCode , Project . MSG_ERR ) ; } } redirector . complete ( ) ; } else { exe . spawn ( ) ; } } protected void runExec ( Execute exe ) throws BuildException { log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( cmdl . getCommandline ( ) ) ; try { runExecute ( exe ) ; } catch ( IOException e ) { if ( failIfExecFails ) { throw new BuildException ( "Execute failed: " + e . toString ( ) , e , getLocation ( ) ) ; } else { log ( "Execute failed: " + e . toString ( ) , Project . MSG_ERR ) ; } } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { return redirector . createHandler ( ) ; } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) { return null ; } return new ExecuteWatchdog ( timeout . longValue ( ) ) ; } protected void logFlush ( ) { } } 	0	['36', '3', '1', '19', '106', '272', '4', '15', '26', '0.862857143', '712', '1', '3', '0.513888889', '0.175', '0', '0', '18.36111111', '12', '1.3889', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { void setJavac ( Javac attributes ) ; boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; public interface ResourceFactory { Resource getResource ( String name ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Random ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { String tempFileName = "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; tmpFile = new File ( tempFileName ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '30', '0', '0', '5', '0', '0', '189', '1', '2', '0', '0.6', '0', '0', '92', '10', '5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  " + "Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , getLocation ( ) ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , getLocation ( ) ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class FileList extends DataType { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof FileList ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a filelist" ; throw new BuildException ( msg ) ; } else { return ( FileList ) o ; } } } 	0	['8', '3', '0', '11', '33', '0', '6', '5', '6', '0.428571429', '181', '1', '0', '0.833333333', '0.3125', '1', '1', '21.375', '5', '2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Stack ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class Property extends Task { protected String name ; protected String value ; protected File file ; protected URL url ; protected String resource ; protected Path classpath ; protected String env ; protected Reference ref ; protected String prefix ; private Project fallback ; protected boolean userProperty ; public Property ( ) { this ( false ) ; } protected Property ( boolean userProperty ) { this ( userProperty , null ) ; } protected Property ( boolean userProperty , Project fallback ) { this . userProperty = userProperty ; this . fallback = fallback ; } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setLocation ( File location ) { setValue ( location . getAbsolutePath ( ) ) ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } public void setFile ( File file ) { this . file = file ; } public File getFile ( ) { return file ; } public void setUrl ( URL url ) { this . url = url ; } public URL getUrl ( ) { return url ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public String getPrefix ( ) { return prefix ; } public void setRefid ( Reference ref ) { this . ref = ref ; } public Reference getRefid ( ) { return ref ; } public void setResource ( String resource ) { this . resource = resource ; } public String getResource ( ) { return resource ; } public void setEnvironment ( String env ) { this . env = env ; } public String getEnvironment ( ) { return env ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setUserProperty ( boolean userProperty ) { log ( "DEPRECATED: Ignoring request to set user property in Property" + " task." , Project . MSG_WARN ) ; } public String toString ( ) { return value == null ? "" : value ; } public void execute ( ) throws BuildException { if ( getProject ( ) == null ) { throw new IllegalStateException ( "project has not been set" ) ; } if ( name != null ) { if ( value == null && ref == null ) { throw new BuildException ( "You must specify value, location or " + "refid with the name attribute" , getLocation ( ) ) ; } } else { if ( url == null && file == null && resource == null && env == null ) { throw new BuildException ( "You must specify url, file, resource or " + "environment when not using the " + "name attribute" , getLocation ( ) ) ; } } if ( url == null && file == null && resource == null && prefix != null ) { throw new BuildException ( "Prefix is only valid when loading from " + "a url, file or resource" , getLocation ( ) ) ; } if ( ( name != null ) && ( value != null ) ) { addProperty ( name , value ) ; } if ( file != null ) { loadFile ( file ) ; } if ( url != null ) { loadUrl ( url ) ; } if ( resource != null ) { loadResource ( resource ) ; } if ( env != null ) { loadEnvironment ( env ) ; } if ( ( name != null ) && ( ref != null ) ) { try { addProperty ( name , ref . getReferencedObject ( getProject ( ) ) . toString ( ) ) ; } catch ( BuildException be ) { if ( fallback != null ) { addProperty ( name , ref . getReferencedObject ( fallback ) . toString ( ) ) ; } else { throw be ; } } } } protected void loadUrl ( URL url ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + url , Project . MSG_VERBOSE ) ; try { InputStream is = url . openStream ( ) ; try { props . load ( is ) ; } finally { if ( is != null ) { is . close ( ) ; } } addProperties ( props ) ; } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadFile ( File file ) throws BuildException { Properties props = new Properties ( ) ; log ( "Loading " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; try { if ( file . exists ( ) ) { FileInputStream fis = new FileInputStream ( file ) ; try { props . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } addProperties ( props ) ; } else { log ( "Unable to find property file: " + file . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } protected void loadResource ( String name ) { Properties props = new Properties ( ) ; log ( "Resource Loading " + name , Project . MSG_VERBOSE ) ; InputStream is = null ; try { ClassLoader cL = null ; if ( classpath != null ) { cL = getProject ( ) . createClassLoader ( classpath ) ; } else { cL = this . getClass ( ) . getClassLoader ( ) ; } if ( cL == null ) { is = ClassLoader . getSystemResourceAsStream ( name ) ; } else { is = cL . getResourceAsStream ( name ) ; } if ( is != null ) { props . load ( is ) ; addProperties ( props ) ; } else { log ( "Unable to find resource " + name , Project . MSG_WARN ) ; } } catch ( IOException ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } protected void loadEnvironment ( String prefix ) { Properties props = new Properties ( ) ; if ( ! prefix . endsWith ( "." ) ) { prefix += "." ; } log ( "Loading Environment " + prefix , Project . MSG_VERBOSE ) ; Vector osEnv = Execute . getProcEnvironment ( ) ; for ( Enumeration e = osEnv . elements ( ) ; e . hasMoreElements ( ) ; ) { String entry = ( String ) e . nextElement ( ) ; int pos = entry . indexOf ( '=' ) ; if ( pos == - 1 ) { log ( "Ignoring: " + entry , Project . MSG_WARN ) ; } else { props . put ( prefix + entry . substring ( 0 , pos ) , entry . substring ( pos + 1 ) ) ; } } addProperties ( props ) ; } protected void addProperties ( Properties props ) { resolveAllProperties ( props ) ; Enumeration e = props . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = props . getProperty ( name ) ; String v = getProject ( ) . replaceProperties ( value ) ; if ( prefix != null ) { name = prefix + name ; } addProperty ( name , v ) ; } } protected void addProperty ( String n , String v ) { if ( userProperty ) { if ( getProject ( ) . getUserProperty ( n ) == null ) { getProject ( ) . setInheritedProperty ( n , v ) ; } else { log ( "Override ignored for " + n , Project . MSG_VERBOSE ) ; } } else { getProject ( ) . setNewProperty ( n , v ) ; } } private void resolveAllProperties ( Properties props ) throws BuildException { for ( Enumeration e = props . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; Stack referencesSeen = new Stack ( ) ; resolve ( props , name , referencesSeen ) ; } } private void resolve ( Properties props , String name , Stack referencesSeen ) throws BuildException { if ( referencesSeen . contains ( name ) ) { throw new BuildException ( "Property " + name + " was circularly " + "defined." ) ; } String value = props . getProperty ( name ) ; Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; if ( propertyRefs . size ( ) != 0 ) { referencesSeen . push ( name ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( props . containsKey ( propertyName ) ) { resolve ( props , propertyName , referencesSeen ) ; fragment = props . getProperty ( propertyName ) ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; props . put ( name , value ) ; referencesSeen . pop ( ) ; } } } 	0	['35', '3', '0', '14', '90', '519', '4', '10', '25', '0.909090909', '815', '1', '3', '0.536231884', '0.171428571', '0', '0', '21.97142857', '7', '1.4', '0']
package org . apache . tools . ant . types ; public class Resource implements Cloneable , Comparable { private String name = null ; private boolean exists = true ; private long lastmodified = 0 ; private boolean directory = false ; public Resource ( ) { } public Resource ( String name ) { this ( name , false , 0 , false ) ; } public Resource ( String name , boolean exists , long lastmodified ) { this ( name , exists , lastmodified , false ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory ) { this . name = name ; this . exists = exists ; this . lastmodified = lastmodified ; this . directory = directory ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public boolean isExists ( ) { return exists ; } public void setExists ( boolean exists ) { this . exists = exists ; } public long getLastModified ( ) { return ! exists || lastmodified < 0 ? 0 : lastmodified ; } public void setLastModified ( long lastmodified ) { this . lastmodified = lastmodified ; } public boolean isDirectory ( ) { return directory ; } public void setDirectory ( boolean directory ) { this . directory = directory ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new Error ( "CloneNotSupportedException for a " + "Clonable Resource caught?" ) ; } } public int compareTo ( Object other ) { if ( ! ( other instanceof Resource ) ) { throw new IllegalArgumentException ( "Can only be compared with " + "Resources" ) ; } Resource r = ( Resource ) other ; return getName ( ) . compareTo ( r . getName ( ) ) ; } } 	0	['14', '1', '0', '8', '19', '45', '8', '0', '14', '0.576923077', '138', '1', '0', '0', '0.371428571', '0', '0', '8.571428571', '3', '0.9286', '0']
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0	['1', '1', '0', '5', '1', '0', '4', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "sj" : exec ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '6', '11', '1', '1', '5', '2', '2', '41', '0', '0', '0.958333333', '1', '0', '0', '19.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or " + "only a filtersFile parameter is " + "required" , getLocation ( ) ) ; } if ( isSingleFilter ) { getProject ( ) . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; getProject ( ) . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '6', '18', '5', '0', '6', '5', '0.733333333', '95', '1', '0', '0.880952381', '0.5', '0', '0', '14.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; public interface BuildLogger extends BuildListener { void setMessageOutputLevel ( int level ) ; void setOutputPrintStream ( PrintStream output ) ; void setEmacsMode ( boolean emacsMode ) ; void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '7', '23', '0', '0', '7', '7', '0.625', '145', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.14285714', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public interface ExecuteStreamHandler { void setProcessInputStream ( OutputStream os ) throws IOException ; void setProcessErrorStream ( InputStream is ) throws IOException ; void setProcessOutputStream ( InputStream is ) throws IOException ; void start ( ) throws IOException ; void stop ( ) ; } 	0	['5', '1', '0', '13', '5', '10', '13', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '13', '1', '0', '12', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public final void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private final String getLineBreaks ( ) { return lineBreaks ; } public final Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0	['7', '5', '0', '5', '17', '0', '1', '4', '5', '0.777777778', '107', '1', '0', '0.848484848', '0.476190476', '2', '5', '13.85714286', '5', '1.2857', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ExtendSelector extends BaseSelector { private String classname = null ; private FileSelector dynselector = null ; private Vector paramVec = new Vector ( ) ; private Path classpath = null ; public ExtendSelector ( ) { } public void setClassname ( String classname ) { this . classname = classname ; } public void selectorCreate ( ) { if ( classname != null && classname . length ( ) > 0 ) { try { Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } dynselector = ( FileSelector ) c . newInstance ( ) ; final Project project = getProject ( ) ; if ( project != null ) { project . setProjectReference ( dynselector ) ; } } catch ( ClassNotFoundException cnfexcept ) { setError ( "Selector " + classname + " not initialized, no such class" ) ; } catch ( InstantiationException iexcept ) { setError ( "Selector " + classname + " not initialized, could not create class" ) ; } catch ( IllegalAccessException iaexcept ) { setError ( "Selector " + classname + " not initialized, class not accessible" ) ; } } else { setError ( "There is no classname specified" ) ; } } public void addParam ( Parameter p ) { paramVec . addElement ( p ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathref ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public void verifySettings ( ) { if ( dynselector == null ) { selectorCreate ( ) ; } if ( classname == null || classname . length ( ) < 1 ) { setError ( "The classname attribute is required" ) ; } else if ( dynselector == null ) { setError ( "Internal Error: The custom selector was not created" ) ; } else if ( ! ( dynselector instanceof ExtendFileSelector ) && ( paramVec . size ( ) > 0 ) ) { setError ( "Cannot set parameters on custom selector that does not " + "implement ExtendFileSelector" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) throws BuildException { validate ( ) ; if ( paramVec . size ( ) > 0 && dynselector instanceof ExtendFileSelector ) { Parameter [ ] paramArray = new Parameter [ paramVec . size ( ) ] ; paramVec . copyInto ( paramArray ) ; ( ( ExtendFileSelector ) dynselector ) . setParameters ( paramArray ) ; } return dynselector . isSelected ( basedir , filename , file ) ; } } 	0	['10', '4', '0', '17', '36', '3', '5', '12', '10', '0.583333333', '253', '1', '2', '0.795454545', '0.266666667', '1', '3', '23.9', '7', '2.3', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public interface Algorithm { boolean isValid ( ) ; String getValue ( File file ) ; } 	0	['2', '1', '0', '3', '2', '1', '3', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '2', '0', '7', '9', '1', '3', '4', '2', '2', '31', '0', '0', '0.923076923', '0.666666667', '0', '0', '14.5', '1', '0.5', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '271', '0', '0', '0', '0.45', '0', '0', '32.875', '7', '2.75', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . launch . AntMain ; public class Main implements AntMain { public static final String DEFAULT_BUILD_FILENAME = "build.xml" ; private int msgOutputLevel = Project . MSG_INFO ; private File buildFile ; private static PrintStream out = System . out ; private static PrintStream err = System . err ; private Vector targets = new Vector ( ) ; private Properties definedProps = new Properties ( ) ; private Vector listeners = new Vector ( 1 ) ; private Vector propertyFiles = new Vector ( 1 ) ; private boolean allowInput = true ; private boolean keepGoingMode = false ; private String loggerClassname = null ; private String inputHandlerClassname = null ; private boolean emacsMode = false ; private boolean readyToRun = false ; private boolean projectHelp = false ; private static boolean isLogFileUsed = false ; private static void printMessage ( Throwable t ) { String message = t . getMessage ( ) ; if ( message != null ) { System . err . println ( message ) ; } } public static void start ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { Main m = new Main ( ) ; m . startAnt ( args , additionalUserProperties , coreLoader ) ; } public void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) { try { Diagnostics . validateVersion ( ) ; processArgs ( args ) ; } catch ( Throwable exc ) { handleLogfile ( ) ; printMessage ( exc ) ; System . exit ( 1 ) ; } if ( additionalUserProperties != null ) { for ( Enumeration e = additionalUserProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String property = additionalUserProperties . getProperty ( key ) ; definedProps . put ( key , property ) ; } } int exitCode = 1 ; try { runBuild ( coreLoader ) ; exitCode = 0 ; } catch ( BuildException be ) { if ( err != System . err ) { printMessage ( be ) ; } } catch ( Throwable exc ) { exc . printStackTrace ( ) ; printMessage ( exc ) ; } finally { handleLogfile ( ) ; } System . exit ( exitCode ) ; } private static void handleLogfile ( ) { if ( isLogFileUsed ) { if ( out != null ) { try { out . close ( ) ; } catch ( final Exception e ) { } } if ( err != null ) { try { err . close ( ) ; } catch ( final Exception e ) { } } } } public static void main ( String [ ] args ) { start ( args , null , null ) ; } public Main ( ) { } protected Main ( String [ ] args ) throws BuildException { processArgs ( args ) ; } private void processArgs ( String [ ] args ) { String searchForThis = null ; PrintStream logTo = null ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( "-help" ) || arg . equals ( "-h" ) ) { printUsage ( ) ; return ; } else if ( arg . equals ( "-version" ) ) { printVersion ( ) ; return ; } else if ( arg . equals ( "-diagnostics" ) ) { Diagnostics . doReport ( System . out ) ; return ; } else if ( arg . equals ( "-quiet" ) || arg . equals ( "-q" ) ) { msgOutputLevel = Project . MSG_WARN ; } else if ( arg . equals ( "-verbose" ) || arg . equals ( "-v" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_VERBOSE ; } else if ( arg . equals ( "-debug" ) || arg . equals ( "-d" ) ) { printVersion ( ) ; msgOutputLevel = Project . MSG_DEBUG ; } else if ( arg . equals ( "-noinput" ) ) { allowInput = false ; } else if ( arg . equals ( "-logfile" ) || arg . equals ( "-l" ) ) { try { File logFile = new File ( args [ i + 1 ] ) ; i ++ ; logTo = new PrintStream ( new FileOutputStream ( logFile ) ) ; isLogFileUsed = true ; } catch ( IOException ioe ) { String msg = "Cannot write on the specified log file. " + "Make sure the path exists and you have write " + "permissions." ; throw new BuildException ( msg ) ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a log file when " + "using the -log argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-buildfile" ) || arg . equals ( "-file" ) || arg . equals ( "-f" ) ) { try { buildFile = new File ( args [ i + 1 ] . replace ( '/' , File . separatorChar ) ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a buildfile when " + "using the -buildfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-listener" ) ) { try { listeners . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a classname when " + "using the -listener argument" ; throw new BuildException ( msg ) ; } } else if ( arg . startsWith ( "-D" ) ) { String name = arg . substring ( 2 , arg . length ( ) ) ; String value = null ; int posEq = name . indexOf ( "=" ) ; if ( posEq > 0 ) { value = name . substring ( posEq + 1 ) ; name = name . substring ( 0 , posEq ) ; } else if ( i < args . length - 1 ) { value = args [ ++ i ] ; } else { throw new BuildException ( "Missing value for property " + name ) ; } definedProps . put ( name , value ) ; } else if ( arg . equals ( "-logger" ) ) { if ( loggerClassname != null ) { throw new BuildException ( "Only one logger class may " + " be specified." ) ; } try { loggerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -logger argument" ) ; } } else if ( arg . equals ( "-inputhandler" ) ) { if ( inputHandlerClassname != null ) { throw new BuildException ( "Only one input handler class may " + "be specified." ) ; } try { inputHandlerClassname = args [ ++ i ] ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { throw new BuildException ( "You must specify a classname when" + " using the -inputhandler" + " argument" ) ; } } else if ( arg . equals ( "-emacs" ) || arg . equals ( "-e" ) ) { emacsMode = true ; } else if ( arg . equals ( "-projecthelp" ) || arg . equals ( "-p" ) ) { projectHelp = true ; } else if ( arg . equals ( "-find" ) || arg . equals ( "-s" ) ) { if ( i < args . length - 1 ) { searchForThis = args [ ++ i ] ; } else { searchForThis = DEFAULT_BUILD_FILENAME ; } } else if ( arg . startsWith ( "-propertyfile" ) ) { try { propertyFiles . addElement ( args [ i + 1 ] ) ; i ++ ; } catch ( ArrayIndexOutOfBoundsException aioobe ) { String msg = "You must specify a property filename when " + "using the -propertyfile argument" ; throw new BuildException ( msg ) ; } } else if ( arg . equals ( "-k" ) || arg . equals ( "-keep-going" ) ) { keepGoingMode = true ; } else if ( arg . startsWith ( "-" ) ) { String msg = "Unknown argument: " + arg ; System . out . println ( msg ) ; printUsage ( ) ; throw new BuildException ( "" ) ; } else { targets . addElement ( arg ) ; } } if ( buildFile == null ) { if ( searchForThis != null ) { buildFile = findBuildFile ( System . getProperty ( "user.dir" ) , searchForThis ) ; } else { buildFile = new File ( DEFAULT_BUILD_FILENAME ) ; } } if ( ! buildFile . exists ( ) ) { System . out . println ( "Buildfile: " + buildFile + " does not exist!" ) ; throw new BuildException ( "Build failed" ) ; } if ( buildFile . isDirectory ( ) ) { System . out . println ( "What? Buildfile: " + buildFile + " is a dir!" ) ; throw new BuildException ( "Build failed" ) ; } for ( int propertyFileIndex = 0 ; propertyFileIndex < propertyFiles . size ( ) ; propertyFileIndex ++ ) { String filename = ( String ) propertyFiles . elementAt ( propertyFileIndex ) ; Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; props . load ( fis ) ; } catch ( IOException e ) { System . out . println ( "Could not load property file " + filename + ": " + e . getMessage ( ) ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { } } } Enumeration propertyNames = props . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String name = ( String ) propertyNames . nextElement ( ) ; if ( definedProps . getProperty ( name ) == null ) { definedProps . put ( name , props . getProperty ( name ) ) ; } } } if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Buildfile: " + buildFile ) ; } if ( logTo != null ) { out = logTo ; err = logTo ; System . setOut ( out ) ; System . setErr ( err ) ; } readyToRun = true ; } private File getParentFile ( File file ) { String filename = file . getAbsolutePath ( ) ; file = new File ( filename ) ; filename = file . getParent ( ) ; if ( filename != null && msgOutputLevel >= Project . MSG_VERBOSE ) { System . out . println ( "Searching in " + filename ) ; } return ( filename == null ) ? null : new File ( filename ) ; } private File findBuildFile ( String start , String suffix ) throws BuildException { if ( msgOutputLevel >= Project . MSG_INFO ) { System . out . println ( "Searching for " + suffix + " ..." ) ; } File parent = new File ( new File ( start ) . getAbsolutePath ( ) ) ; File file = new File ( parent , suffix ) ; while ( ! file . exists ( ) ) { parent = getParentFile ( parent ) ; if ( parent == null ) { throw new BuildException ( "Could not locate a build file!" ) ; } file = new File ( parent , suffix ) ; } return file ; } private void runBuild ( ClassLoader coreLoader ) throws BuildException { if ( ! readyToRun ) { return ; } final Project project = new Project ( ) ; project . setCoreLoader ( coreLoader ) ; Throwable error = null ; try { addBuildListeners ( project ) ; addInputHandler ( project ) ; PrintStream err = System . err ; PrintStream out = System . out ; InputStream in = System . in ; SecurityManager oldsm = null ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_0 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_1 ) ) { oldsm = System . getSecurityManager ( ) ; } try { if ( allowInput ) { project . setDefaultInputStream ( System . in ) ; } System . setIn ( new DemuxInputStream ( project ) ) ; System . setOut ( new PrintStream ( new DemuxOutputStream ( project , false ) ) ) ; System . setErr ( new PrintStream ( new DemuxOutputStream ( project , true ) ) ) ; if ( ! projectHelp ) { project . fireBuildStarted ( ) ; } project . init ( ) ; project . setUserProperty ( "ant.version" , getAntVersion ( ) ) ; Enumeration e = definedProps . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) definedProps . get ( arg ) ; project . setUserProperty ( arg , value ) ; } project . setUserProperty ( "ant.file" , buildFile . getAbsolutePath ( ) ) ; project . setKeepGoingMode ( keepGoingMode ) ; ProjectHelper . configureProject ( project , buildFile ) ; if ( projectHelp ) { printDescription ( project ) ; printTargets ( project , msgOutputLevel > Project . MSG_INFO ) ; return ; } if ( targets . size ( ) == 0 ) { if ( project . getDefaultTarget ( ) != null ) { targets . addElement ( project . getDefaultTarget ( ) ) ; } } project . executeTargets ( targets ) ; } finally { if ( oldsm != null ) { System . setSecurityManager ( oldsm ) ; } System . setOut ( out ) ; System . setErr ( err ) ; System . setIn ( in ) ; } } catch ( RuntimeException exc ) { error = exc ; throw exc ; } catch ( Error err ) { error = err ; throw err ; } finally { if ( ! projectHelp ) { project . fireBuildFinished ( error ) ; } } } protected void addBuildListeners ( Project project ) { project . addBuildListener ( createLogger ( ) ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { String className = ( String ) listeners . elementAt ( i ) ; try { BuildListener listener = ( BuildListener ) Class . forName ( className ) . newInstance ( ) ; if ( project != null ) { project . setProjectReference ( listener ) ; } project . addBuildListener ( listener ) ; } catch ( Throwable exc ) { throw new BuildException ( "Unable to instantiate listener " + className , exc ) ; } } } private void addInputHandler ( Project project ) throws BuildException { InputHandler handler = null ; if ( inputHandlerClassname == null ) { handler = new DefaultInputHandler ( ) ; } else { try { handler = ( InputHandler ) ( Class . forName ( inputHandlerClassname ) . newInstance ( ) ) ; if ( project != null ) { project . setProjectReference ( handler ) ; } } catch ( ClassCastException e ) { String msg = "The specified input handler class " + inputHandlerClassname + " does not implement the InputHandler interface" ; throw new BuildException ( msg ) ; } catch ( Exception e ) { String msg = "Unable to instantiate specified input handler " + "class " + inputHandlerClassname + " : " + e . getClass ( ) . getName ( ) ; throw new BuildException ( msg ) ; } } project . setInputHandler ( handler ) ; } private BuildLogger createLogger ( ) { BuildLogger logger = null ; if ( loggerClassname != null ) { try { Class loggerClass = Class . forName ( loggerClassname ) ; logger = ( BuildLogger ) ( loggerClass . newInstance ( ) ) ; } catch ( ClassCastException e ) { System . err . println ( "The specified logger class " + loggerClassname + " does not implement the BuildLogger interface" ) ; throw new RuntimeException ( ) ; } catch ( Exception e ) { System . err . println ( "Unable to instantiate specified logger " + "class " + loggerClassname + " : " + e . getClass ( ) . getName ( ) ) ; throw new RuntimeException ( ) ; } } else { logger = new DefaultLogger ( ) ; } logger . setMessageOutputLevel ( msgOutputLevel ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( err ) ; logger . setEmacsMode ( emacsMode ) ; return logger ; } private static void printUsage ( ) { String lSep = System . getProperty ( "line.separator" ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "ant [options] [target [target2 [target3] ...]]" + lSep ) ; msg . append ( "Options: " + lSep ) ; msg . append ( "  -help, -h              print this message" + lSep ) ; msg . append ( "  -projecthelp, -p       print project help information" + lSep ) ; msg . append ( "  -version               print the version information and exit" + lSep ) ; msg . append ( "  -diagnostics           print information that might be helpful to" + lSep ) ; msg . append ( "                         diagnose or report problems." + lSep ) ; msg . append ( "  -quiet, -q             be extra quiet" + lSep ) ; msg . append ( "  -verbose, -v           be extra verbose" + lSep ) ; msg . append ( "  -debug, -d             print debugging information" + lSep ) ; msg . append ( "  -emacs, -e             produce logging information without adornments" + lSep ) ; msg . append ( "  -lib <path>            specifies a path to search for jars and classes" + lSep ) ; msg . append ( "  -logfile <file>        use given file for log" + lSep ) ; msg . append ( "    -l     <file>                ''" + lSep ) ; msg . append ( "  -logger <classname>    the class which is to perform logging" + lSep ) ; msg . append ( "  -listener <classname>  add an instance of class as a project listener" + lSep ) ; msg . append ( "  -noinput               do not allow interactive input" + lSep ) ; msg . append ( "  -buildfile <file>      use given buildfile" + lSep ) ; msg . append ( "    -file    <file>              ''" + lSep ) ; msg . append ( "    -f       <file>              ''" + lSep ) ; msg . append ( "  -D<property>=<value>   use value for given property" + lSep ) ; msg . append ( "  -keep-going, -k        execute all targets that do not depend" + lSep ) ; msg . append ( "                         on failed target(s)" + lSep ) ; msg . append ( "  -propertyfile <name>   load all properties from file with -D" + lSep ) ; msg . append ( "                         properties taking precedence" + lSep ) ; msg . append ( "  -inputhandler <class>  the class which will handle input requests" + lSep ) ; msg . append ( "  -find <file>           (s)earch for buildfile towards the root of" + lSep ) ; msg . append ( "    -s  <file>           the filesystem and use it" + lSep ) ; System . out . println ( msg . toString ( ) ) ; } private static void printVersion ( ) throws BuildException { System . out . println ( getAntVersion ( ) ) ; } private static String antVersion = null ; public static synchronized String getAntVersion ( ) throws BuildException { if ( antVersion == null ) { try { Properties props = new Properties ( ) ; InputStream in = Main . class . getResourceAsStream ( "/org/apache/tools/ant/version.txt" ) ; props . load ( in ) ; in . close ( ) ; StringBuffer msg = new StringBuffer ( ) ; msg . append ( "Apache Ant version " ) ; msg . append ( props . getProperty ( "VERSION" ) ) ; msg . append ( " compiled on " ) ; msg . append ( props . getProperty ( "DATE" ) ) ; antVersion = msg . toString ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not load the version information:" + ioe . getMessage ( ) ) ; } catch ( NullPointerException npe ) { throw new BuildException ( "Could not load the version information." ) ; } } return antVersion ; } private static void printDescription ( Project project ) { if ( project . getDescription ( ) != null ) { project . log ( project . getDescription ( ) ) ; } } private static void printTargets ( Project project , boolean printSubTargets ) { int maxLength = 0 ; Enumeration ptargets = project . getTargets ( ) . elements ( ) ; String targetName ; String targetDescription ; Target currentTarget ; Vector topNames = new Vector ( ) ; Vector topDescriptions = new Vector ( ) ; Vector subNames = new Vector ( ) ; while ( ptargets . hasMoreElements ( ) ) { currentTarget = ( Target ) ptargets . nextElement ( ) ; targetName = currentTarget . getName ( ) ; if ( targetName . equals ( "" ) ) { continue ; } targetDescription = currentTarget . getDescription ( ) ; if ( targetDescription == null ) { int pos = findTargetPosition ( subNames , targetName ) ; subNames . insertElementAt ( targetName , pos ) ; } else { int pos = findTargetPosition ( topNames , targetName ) ; topNames . insertElementAt ( targetName , pos ) ; topDescriptions . insertElementAt ( targetDescription , pos ) ; if ( targetName . length ( ) > maxLength ) { maxLength = targetName . length ( ) ; } } } printTargets ( project , topNames , topDescriptions , "Main targets:" , maxLength ) ; if ( topNames . size ( ) == 0 ) { printSubTargets = true ; } if ( printSubTargets ) { printTargets ( project , subNames , null , "Other targets:" , 0 ) ; } String defaultTarget = project . getDefaultTarget ( ) ; if ( defaultTarget != null && ! "" . equals ( defaultTarget ) ) { project . log ( "Default target: " + defaultTarget ) ; } } private static int findTargetPosition ( Vector names , String name ) { int res = names . size ( ) ; for ( int i = 0 ; i < names . size ( ) && res == names . size ( ) ; i ++ ) { if ( name . compareTo ( ( String ) names . elementAt ( i ) ) < 0 ) { res = i ; } } return res ; } private static void printTargets ( Project project , Vector names , Vector descriptions , String heading , int maxlen ) { String lSep = System . getProperty ( "line.separator" ) ; String spaces = "    " ; while ( spaces . length ( ) <= maxlen ) { spaces += spaces ; } StringBuffer msg = new StringBuffer ( ) ; msg . append ( heading + lSep + lSep ) ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { msg . append ( " " ) ; msg . append ( names . elementAt ( i ) ) ; if ( descriptions != null ) { msg . append ( spaces . substring ( 0 , maxlen - ( ( String ) names . elementAt ( i ) ) . length ( ) + 2 ) ) ; msg . append ( descriptions . elementAt ( i ) ) ; } msg . append ( lSep ) ; } project . log ( msg . toString ( ) ) ; } } 	0	['23', '1', '0', '14', '113', '173', '1', '14', '5', '0.751196172', '1964', '0.894736842', '0', '0', '0.144628099', '0', '0', '83.56521739', '50', '4.3913', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public interface Regexp extends RegexpMatcher { int REPLACE_FIRST = 0x00000001 ; int REPLACE_ALL = 0x00000010 ; String substitute ( String input , String argument , int options ) throws BuildException ; } 	0	['1', '1', '0', '8', '1', '0', '6', '2', '1', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . facade ; import java . util . Enumeration ; import java . util . Vector ; public class FacadeTaskHelper { private Vector args = new Vector ( ) ; private String userChoice ; private String magicValue ; private String defaultValue ; public FacadeTaskHelper ( String defaultValue ) { this ( defaultValue , null ) ; } public FacadeTaskHelper ( String defaultValue , String magicValue ) { this . defaultValue = defaultValue ; this . magicValue = magicValue ; } public void setMagicValue ( String magicValue ) { this . magicValue = magicValue ; } public void setImplementation ( String userChoice ) { this . userChoice = userChoice ; } public String getImplementation ( ) { return userChoice != null ? userChoice : ( magicValue != null ? magicValue : defaultValue ) ; } public String getExplicitChoice ( ) { return userChoice ; } public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . addElement ( arg ) ; } public String [ ] getArgs ( ) { Vector tmp = new Vector ( args . size ( ) ) ; for ( Enumeration e = args . elements ( ) ; e . hasMoreElements ( ) ; ) { ImplementationSpecificArgument arg = ( ( ImplementationSpecificArgument ) e . nextElement ( ) ) ; String [ ] curr = arg . getParts ( getImplementation ( ) ) ; for ( int i = 0 ; i < curr . length ; i ++ ) { tmp . addElement ( curr [ i ] ) ; } } String [ ] res = new String [ tmp . size ( ) ] ; tmp . copyInto ( res ) ; return res ; } public boolean hasBeenSet ( ) { return userChoice != null || magicValue != null ; } } 	0	['9', '1', '0', '3', '19', '8', '2', '1', '9', '0.53125', '119', '1', '0', '0', '0.518518519', '0', '0', '11.77777778', '3', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Mkdir extends Task { private static final int MKDIR_RETRY_SLEEP_MILLIS = 10 ; private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , getLocation ( ) ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file " + "already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = mkdirs ( dir ) ; if ( ! result ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } } public void setDir ( File dir ) { this . dir = dir ; } private boolean mkdirs ( File f ) { if ( ! f . mkdirs ( ) ) { try { Thread . sleep ( MKDIR_RETRY_SLEEP_MILLIS ) ; return f . mkdirs ( ) ; } catch ( InterruptedException ex ) { return f . mkdirs ( ) ; } } return true ; } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '1', '99', '1', '0', '0.925', '0.75', '1', '1', '23.25', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . OutputStream ; import java . io . IOException ; public class TeeOutputStream extends OutputStream { private OutputStream left ; private OutputStream right ; public TeeOutputStream ( OutputStream left , OutputStream right ) { this . left = left ; this . right = right ; } public void close ( ) throws IOException { left . close ( ) ; right . close ( ) ; } public void flush ( ) throws IOException { left . flush ( ) ; right . flush ( ) ; } public void write ( byte [ ] b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } public void write ( byte [ ] b , int off , int len ) throws IOException { left . write ( b , off , len ) ; right . write ( b , off , len ) ; } public void write ( int b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } } 	0	['6', '2', '0', '1', '12', '0', '1', '0', '6', '0', '62', '1', '0', '0.5', '0.458333333', '1', '1', '9', '1', '0.8333', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '23', '3', '3', '23', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Http extends ProjectComponent implements Condition { private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = 400 ; public void setErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } else { return false ; } } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	0	['4', '2', '0', '4', '15', '0', '1', '3', '4', '0.333333333', '109', '1', '0', '0.75', '0.5', '0', '0', '25.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; public class Patch extends Task { private File originalFile ; private File directory ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setDestfile ( File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void setDir ( File directory ) { this . directory = directory ; } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , getLocation ( ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; if ( directory != null ) { if ( directory . exists ( ) && directory . isDirectory ( ) ) { exe . setWorkingDirectory ( directory ) ; } else if ( ! directory . isDirectory ( ) ) { throw new BuildException ( directory + " is not a directory." , getLocation ( ) ) ; } else { throw new BuildException ( "directory " + directory + " doesn\'t exist" , getLocation ( ) ) ; } } else { exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } } 	0	['11', '3', '0', '11', '38', '0', '0', '11', '11', '0.7', '250', '1', '1', '0.787234043', '0.454545455', '1', '1', '21.36363636', '2', '1.4545', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private static final RegexpFactory factory = new RegexpFactory ( ) ; private Regexp regexp ; public RegularExpression ( ) { this . regexp = factory . newRegexp ( ) ; } public void setPattern ( String pattern ) { this . regexp . setPattern ( pattern ) ; } public String getPattern ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } return this . regexp ; } public RegularExpression getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof RegularExpression ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a " + DATA_TYPE_NAME ; throw new BuildException ( msg ) ; } else { return ( RegularExpression ) o ; } } } 	0	['6', '3', '0', '11', '23', '1', '4', '7', '5', '0.8', '95', '0.666666667', '2', '0.882352941', '0.6', '0', '0', '14.33333333', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { ZipShort getHeaderId ( ) ; ZipShort getLocalFileDataLength ( ) ; ZipShort getCentralDirectoryLength ( ) ; byte [ ] getLocalFileDataData ( ) ; byte [ ] getCentralDirectoryData ( ) ; void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '5', '6', '15', '4', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; public class EqualComparator implements Comparator { public int compare ( Object o1 , Object o2 ) { if ( o1 == null ) { if ( o2 == null ) { return 1 ; } else { return 0 ; } } else { return ( o1 . equals ( o2 ) ) ? 0 : 1 ; } } public String toString ( ) { return "EqualComparator" ; } } 	0	['3', '1', '0', '1', '5', '3', '1', '0', '3', '2', '24', '0', '0', '0', '0.666666667', '0', '0', '7', '4', '1.6667', '0']
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0	['3', '3', '2', '6', '6', '1', '5', '1', '3', '0.5', '25', '1', '0', '0.882352941', '0.833333333', '1', '1', '7', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NoneSelector extends BaseSelectorContainer { public NoneSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{noneselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( ! replace && dest . exists ( ) ) { throw new BuildException ( dest + " already exists." ) ; } try { FileUtils . newFileUtils ( ) . rename ( src , dest ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename " + src + " to " + dest , e , getLocation ( ) ) ; } } } 	0	['5', '3', '0', '5', '19', '0', '0', '5', '5', '0.666666667', '100', '1', '0', '0.902439024', '0.533333333', '1', '1', '18.4', '1', '0.8', '0']
package org . apache . tools . ant . input ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . KeepAliveInputStream ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; DataInputStream in = null ; try { in = new DataInputStream ( new KeepAliveInputStream ( getInputStream ( ) ) ) ; do { System . err . println ( prompt ) ; try { String input = in . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from" + " Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to close input." , e ) ; } } } } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( "(" ) ; Enumeration e = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( e . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( "," ) ; } sb . append ( e . nextElement ( ) ) ; first = false ; } sb . append ( ")" ) ; prompt = sb . toString ( ) ; } return prompt ; } protected InputStream getInputStream ( ) { return System . in ; } } 	0	['4', '1', '0', '7', '22', '6', '2', '5', '2', '2', '121', '0', '0', '0', '0.75', '0', '0', '29.25', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilesMatch implements Condition { private File file1 , file2 ; private FileUtils fu = FileUtils . newFileUtils ( ) ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = fu . contentEquals ( file1 , file2 ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0	['4', '1', '0', '4', '13', '0', '1', '3', '4', '0.666666667', '60', '1', '1', '0', '0.75', '0', '0', '13.25', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class UnPackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( '.' , File . separatorChar ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; import java . util . zip . CRC32 ; import java . util . zip . ZipException ; public class AsiExtraField implements ZipExtraField , UnixStat , Cloneable { private static final ZipShort HEADER_ID = new ZipShort ( 0x756E ) ; private int mode = 0 ; private int uid = 0 ; private int gid = 0 ; private String link = "" ; private boolean dirFlag = false ; private CRC32 crc = new CRC32 ( ) ; public AsiExtraField ( ) { } public ZipShort getHeaderId ( ) { return HEADER_ID ; } public ZipShort getLocalFileDataLength ( ) { return new ZipShort ( 4 + 2 + 4 + 2 + 2 + getLinkedFile ( ) . getBytes ( ) . length ) ; } public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } public byte [ ] getLocalFileDataData ( ) { byte [ ] data = new byte [ getLocalFileDataLength ( ) . getValue ( ) - 4 ] ; System . arraycopy ( ( new ZipShort ( getMode ( ) ) ) . getBytes ( ) , 0 , data , 0 , 2 ) ; byte [ ] linkArray = getLinkedFile ( ) . getBytes ( ) ; System . arraycopy ( ( new ZipLong ( linkArray . length ) ) . getBytes ( ) , 0 , data , 2 , 4 ) ; System . arraycopy ( ( new ZipShort ( getUserId ( ) ) ) . getBytes ( ) , 0 , data , 6 , 2 ) ; System . arraycopy ( ( new ZipShort ( getGroupId ( ) ) ) . getBytes ( ) , 0 , data , 8 , 2 ) ; System . arraycopy ( linkArray , 0 , data , 10 , linkArray . length ) ; crc . reset ( ) ; crc . update ( data ) ; long checksum = crc . getValue ( ) ; byte [ ] result = new byte [ data . length + 4 ] ; System . arraycopy ( ( new ZipLong ( checksum ) ) . getBytes ( ) , 0 , result , 0 , 4 ) ; System . arraycopy ( data , 0 , result , 4 , data . length ) ; return result ; } public byte [ ] getCentralDirectoryData ( ) { return getLocalFileDataData ( ) ; } public void setUserId ( int uid ) { this . uid = uid ; } public int getUserId ( ) { return uid ; } public void setGroupId ( int gid ) { this . gid = gid ; } public int getGroupId ( ) { return gid ; } public void setLinkedFile ( String name ) { link = name ; mode = getMode ( mode ) ; } public String getLinkedFile ( ) { return link ; } public boolean isLink ( ) { return getLinkedFile ( ) . length ( ) != 0 ; } public void setMode ( int mode ) { this . mode = getMode ( mode ) ; } public int getMode ( ) { return mode ; } public void setDirectory ( boolean dirFlag ) { this . dirFlag = dirFlag ; mode = getMode ( mode ) ; } public boolean isDirectory ( ) { return dirFlag && ! isLink ( ) ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { long givenChecksum = ( new ZipLong ( data , offset ) ) . getValue ( ) ; byte [ ] tmp = new byte [ length - 4 ] ; System . arraycopy ( data , offset + 4 , tmp , 0 , length - 4 ) ; crc . reset ( ) ; crc . update ( tmp ) ; long realChecksum = crc . getValue ( ) ; if ( givenChecksum != realChecksum ) { throw new ZipException ( "bad CRC checksum " + Long . toHexString ( givenChecksum ) + " instead of " + Long . toHexString ( realChecksum ) ) ; } int newMode = ( new ZipShort ( tmp , 0 ) ) . getValue ( ) ; byte [ ] linkArray = new byte [ ( int ) ( new ZipLong ( tmp , 2 ) ) . getValue ( ) ] ; uid = ( new ZipShort ( tmp , 6 ) ) . getValue ( ) ; gid = ( new ZipShort ( tmp , 8 ) ) . getValue ( ) ; if ( linkArray . length == 0 ) { link = "" ; } else { System . arraycopy ( tmp , 10 , linkArray , 0 , linkArray . length ) ; link = new String ( linkArray ) ; } setDirectory ( ( newMode & DIR_FLAG ) != 0 ) ; setMode ( newMode ) ; } protected int getMode ( int mode ) { int type = FILE_FLAG ; if ( isLink ( ) ) { type = LINK_FLAG ; } else if ( isDirectory ( ) ) { type = DIR_FLAG ; } return type | ( mode & PERM_MASK ) ; } } 	0	['20', '1', '0', '4', '42', '130', '0', '4', '18', '0.736842105', '376', '1', '1', '0', '0.284210526', '0', '0', '17.45', '3', '1.15', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Substitution extends DataType { public static final String DATA_TYPE_NAME = "substitition" ; private String expression ; public Substitution ( ) { this . expression = null ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getExpression ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExpression ( p ) ; } return expression ; } public Substitution getRef ( Project p ) { if ( ! isChecked ( ) ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( ! ( o instanceof Substitution ) ) { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a substitution" ; throw new BuildException ( msg ) ; } else { return ( Substitution ) o ; } } } 	0	['4', '3', '0', '6', '17', '0', '2', '4', '4', '0.833333333', '70', '0.5', '0', '0.909090909', '0.583333333', '0', '0', '16', '3', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class JAXPUtils { private static final FileUtils fu = FileUtils . newFileUtils ( ) ; private static SAXParserFactory parserFactory = null ; private static SAXParserFactory nsParserFactory = null ; private static DocumentBuilderFactory builderFactory = null ; public static synchronized SAXParserFactory getParserFactory ( ) throws BuildException { if ( parserFactory == null ) { parserFactory = newParserFactory ( ) ; } return parserFactory ; } public static synchronized SAXParserFactory getNSParserFactory ( ) throws BuildException { if ( nsParserFactory == null ) { nsParserFactory = newParserFactory ( ) ; nsParserFactory . setNamespaceAware ( true ) ; } return nsParserFactory ; } public static SAXParserFactory newParserFactory ( ) throws BuildException { try { return SAXParserFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "XML parser factory has not been " + "configured correctly: " + e . getMessage ( ) , e ) ; } } public static Parser getParser ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getParser ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getXMLReader ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getNamespaceXMLReader ( ) throws BuildException { try { return newSAXParser ( getNSParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static String getSystemId ( File file ) { return fu . toURI ( file . getAbsolutePath ( ) ) ; } public static DocumentBuilder getDocumentBuilder ( ) throws BuildException { try { return getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( e ) ; } } private static SAXParser newSAXParser ( SAXParserFactory factory ) throws BuildException { try { return factory . newSAXParser ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( "Cannot create parser for the given " + "configuration: " + e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static BuildException convertToBuildException ( SAXException e ) { Exception nested = e . getException ( ) ; if ( nested != null ) { return new BuildException ( nested ) ; } else { return new BuildException ( e ) ; } } private static synchronized DocumentBuilderFactory getDocumentBuilderFactory ( ) throws BuildException { if ( builderFactory == null ) { try { builderFactory = DocumentBuilderFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "Document builder factory has not " + "been configured correctly: " + e . getMessage ( ) , e ) ; } } return builderFactory ; } } 	0	['13', '1', '0', '5', '32', '70', '3', '2', '9', '0.833333333', '158', '1', '1', '0', '0.083333333', '0', '0', '10.84615385', '2', '0.9231', '0']
package org . apache . tools . tar ; import java . io . File ; import java . util . Date ; import java . util . Locale ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; public static final int MAX_NAMELEN = 31 ; public static final int DEFAULT_DIR_MODE = 040755 ; public static final int DEFAULT_FILE_MODE = 0100644 ; public static final int MILLIS_PER_SECOND = 1000 ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > MAX_NAMELEN ) { user = user . substring ( 0 , MAX_NAMELEN ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / MILLIS_PER_SECOND ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; if ( osname != null ) { if ( osname . startsWith ( "windows" ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } else if ( osname . indexOf ( "netware" ) > - 1 ) { int colon = name . indexOf ( ':' ) ; if ( colon != - 1 ) { name = name . substring ( colon + 1 ) ; } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = DEFAULT_DIR_MODE ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = DEFAULT_FILE_MODE ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / MILLIS_PER_SECOND ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean equals ( Object it ) { if ( it == null || getClass ( ) != it . getClass ( ) ) { return false ; } return equals ( ( TarEntry ) it ) ; } public int hashCode ( ) { return getName ( ) . hashCode ( ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public String getLinkName ( ) { return this . linkName . toString ( ) ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / MILLIS_PER_SECOND ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / MILLIS_PER_SECOND ; } public Date getModTime ( ) { return new Date ( this . modTime * MILLIS_PER_SECOND ) ; } public File getFile ( ) { return this . file ; } public int getMode ( ) { return this . mode ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['35', '1', '0', '6', '73', '353', '4', '2', '34', '0.809597523', '790', '0.789473684', '0', '0', '0.16', '1', '1', '21.02857143', '4', '1.2', '0']
package org . apache . tools . ant ; public class MagicNames { public static final String SCRIPT_REPOSITORY = "org.apache.ant.scriptrepo" ; public static final String SYSTEM_LOADER_REF = "ant.coreLoader" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '6', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Method ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class WLRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using WebLogic rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( new String [ ] { "-noexit" } ) ; AntClassLoader loader = null ; try { Class c = null ; if ( getRmic ( ) . getClasspath ( ) == null ) { c = Class . forName ( "weblogic.rmic" ) ; } else { loader = getRmic ( ) . getProject ( ) . createClassLoader ( getRmic ( ) . getClasspath ( ) ) ; c = Class . forName ( "weblogic.rmic" , true , loader ) ; } Method doRmic = c . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; doRmic . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return true ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use WebLogic rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting WebLogic rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } finally { if ( loader != null ) { loader . cleanup ( ) ; } } } public String getStubClassSuffix ( ) { return "_WLStub" ; } public String getSkelClassSuffix ( ) { return "_WLSkel" ; } } 	0	['5', '2', '0', '11', '23', '10', '1', '10', '4', '1', '130', '0', '0', '0.764705882', '0.5', '0', '0', '24.8', '1', '0.8', '0']
package org . apache . tools . bzip2 ; import java . io . OutputStream ; import java . io . IOException ; public class CBZip2OutputStream extends OutputStream implements BZip2Constants { protected static final int SETMASK = ( 1 << 21 ) ; protected static final int CLEARMASK = ( ~ SETMASK ) ; protected static final int GREATER_ICOST = 15 ; protected static final int LESSER_ICOST = 0 ; protected static final int SMALL_THRESH = 20 ; protected static final int DEPTH_THRESH = 10 ; protected static final int QSORT_STACK_SIZE = 1000 ; private static void panic ( ) { System . out . println ( "panic" ) ; } private void makeMaps ( ) { int i ; nInUse = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { if ( inUse [ i ] ) { seqToUnseq [ nInUse ] = ( char ) i ; unseqToSeq [ i ] = ( char ) nInUse ; nInUse ++ ; } } } protected static void hbMakeCodeLengths ( char [ ] len , int [ ] freq , int alphaSize , int maxLen ) { int nNodes , nHeap , n1 , n2 , i , j , k ; boolean tooLong ; int [ ] heap = new int [ MAX_ALPHA_SIZE + 2 ] ; int [ ] weight = new int [ MAX_ALPHA_SIZE * 2 ] ; int [ ] parent = new int [ MAX_ALPHA_SIZE * 2 ] ; for ( i = 0 ; i < alphaSize ; i ++ ) { weight [ i + 1 ] = ( freq [ i ] == 0 ? 1 : freq [ i ] ) << 8 ; } while ( true ) { nNodes = alphaSize ; nHeap = 0 ; heap [ 0 ] = 0 ; weight [ 0 ] = 0 ; parent [ 0 ] = - 2 ; for ( i = 1 ; i <= alphaSize ; i ++ ) { parent [ i ] = - 1 ; nHeap ++ ; heap [ nHeap ] = i ; { int zz , tmp ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nHeap < ( MAX_ALPHA_SIZE + 2 ) ) ) { panic ( ) ; } while ( nHeap > 1 ) { n1 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } n2 = heap [ 1 ] ; heap [ 1 ] = heap [ nHeap ] ; nHeap -- ; { int zz = 0 , yy = 0 , tmp = 0 ; zz = 1 ; tmp = heap [ zz ] ; while ( true ) { yy = zz << 1 ; if ( yy > nHeap ) { break ; } if ( yy < nHeap && weight [ heap [ yy + 1 ] ] < weight [ heap [ yy ] ] ) { yy ++ ; } if ( weight [ tmp ] < weight [ heap [ yy ] ] ) { break ; } heap [ zz ] = heap [ yy ] ; zz = yy ; } heap [ zz ] = tmp ; } nNodes ++ ; parent [ n1 ] = parent [ n2 ] = nNodes ; weight [ nNodes ] = ( ( weight [ n1 ] & 0xffffff00 ) + ( weight [ n2 ] & 0xffffff00 ) ) | ( 1 + ( ( ( weight [ n1 ] & 0x000000ff ) > ( weight [ n2 ] & 0x000000ff ) ) ? ( weight [ n1 ] & 0x000000ff ) : ( weight [ n2 ] & 0x000000ff ) ) ) ; parent [ nNodes ] = - 1 ; nHeap ++ ; heap [ nHeap ] = nNodes ; { int zz = 0 , tmp = 0 ; zz = nHeap ; tmp = heap [ zz ] ; while ( weight [ tmp ] < weight [ heap [ zz > > 1 ] ] ) { heap [ zz ] = heap [ zz > > 1 ] ; zz >>= 1 ; } heap [ zz ] = tmp ; } } if ( ! ( nNodes < ( MAX_ALPHA_SIZE * 2 ) ) ) { panic ( ) ; } tooLong = false ; for ( i = 1 ; i <= alphaSize ; i ++ ) { j = 0 ; k = i ; while ( parent [ k ] >= 0 ) { k = parent [ k ] ; j ++ ; } len [ i - 1 ] = ( char ) j ; if ( j > maxLen ) { tooLong = true ; } } if ( ! tooLong ) { break ; } for ( i = 1 ; i < alphaSize ; i ++ ) { j = weight [ i ] > > 8 ; j = 1 + ( j / 2 ) ; weight [ i ] = j << 8 ; } } } int last ; int origPtr ; int blockSize100k ; boolean blockRandomised ; int bytesOut ; int bsBuff ; int bsLive ; CRC mCrc = new CRC ( ) ; private boolean [ ] inUse = new boolean [ 256 ] ; private int nInUse ; private char [ ] seqToUnseq = new char [ 256 ] ; private char [ ] unseqToSeq = new char [ 256 ] ; private char [ ] selector = new char [ MAX_SELECTORS ] ; private char [ ] selectorMtf = new char [ MAX_SELECTORS ] ; private char [ ] block ; private int [ ] quadrant ; private int [ ] zptr ; private short [ ] szptr ; private int [ ] ftab ; private int nMTF ; private int [ ] mtfFreq = new int [ MAX_ALPHA_SIZE ] ; private int workFactor ; private int workDone ; private int workLimit ; private boolean firstAttempt ; private int nBlocksRandomised ; private int currentChar = - 1 ; private int runLength = 0 ; public CBZip2OutputStream ( OutputStream inStream ) throws IOException { this ( inStream , 9 ) ; } public CBZip2OutputStream ( OutputStream inStream , int inBlockSize ) throws IOException { block = null ; quadrant = null ; zptr = null ; ftab = null ; bsSetStream ( inStream ) ; workFactor = 50 ; if ( inBlockSize > 9 ) { inBlockSize = 9 ; } if ( inBlockSize < 1 ) { inBlockSize = 1 ; } blockSize100k = inBlockSize ; allocateCompressStructures ( ) ; initialize ( ) ; initBlock ( ) ; } public void write ( int bv ) throws IOException { int b = ( 256 + bv ) % 256 ; if ( currentChar != - 1 ) { if ( currentChar == b ) { runLength ++ ; if ( runLength > 254 ) { writeRun ( ) ; currentChar = - 1 ; runLength = 0 ; } } else { writeRun ( ) ; runLength = 1 ; currentChar = b ; } } else { currentChar = b ; runLength ++ ; } } private void writeRun ( ) throws IOException { if ( last < allowableBlockSize ) { inUse [ currentChar ] = true ; for ( int i = 0 ; i < runLength ; i ++ ) { mCrc . updateCRC ( ( char ) currentChar ) ; } switch ( runLength ) { case 1 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 2 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; case 3 : last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; break ; default : inUse [ runLength - 4 ] = true ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) currentChar ; last ++ ; block [ last + 1 ] = ( char ) ( runLength - 4 ) ; break ; } } else { endBlock ( ) ; initBlock ( ) ; writeRun ( ) ; } } boolean closed = false ; protected void finalize ( ) throws Throwable { close ( ) ; super . finalize ( ) ; } public void close ( ) throws IOException { if ( closed ) { return ; } if ( runLength > 0 ) { writeRun ( ) ; } currentChar = - 1 ; endBlock ( ) ; endCompression ( ) ; closed = true ; super . close ( ) ; bsStream . close ( ) ; } public void flush ( ) throws IOException { super . flush ( ) ; bsStream . flush ( ) ; } private int blockCRC , combinedCRC ; private void initialize ( ) throws IOException { bytesOut = 0 ; nBlocksRandomised = 0 ; bsPutUChar ( 'h' ) ; bsPutUChar ( '0' + blockSize100k ) ; combinedCRC = 0 ; } private int allowableBlockSize ; private void initBlock ( ) { mCrc . initialiseCRC ( ) ; last = - 1 ; for ( int i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } allowableBlockSize = baseBlockSize * blockSize100k - 20 ; } private void endBlock ( ) throws IOException { blockCRC = mCrc . getFinalCRC ( ) ; combinedCRC = ( combinedCRC << 1 ) | ( combinedCRC > > > 31 ) ; combinedCRC ^= blockCRC ; doReversibleTransformation ( ) ; bsPutUChar ( 0x31 ) ; bsPutUChar ( 0x41 ) ; bsPutUChar ( 0x59 ) ; bsPutUChar ( 0x26 ) ; bsPutUChar ( 0x53 ) ; bsPutUChar ( 0x59 ) ; bsPutint ( blockCRC ) ; if ( blockRandomised ) { bsW ( 1 , 1 ) ; nBlocksRandomised ++ ; } else { bsW ( 1 , 0 ) ; } moveToFrontCodeAndSend ( ) ; } private void endCompression ( ) throws IOException { bsPutUChar ( 0x17 ) ; bsPutUChar ( 0x72 ) ; bsPutUChar ( 0x45 ) ; bsPutUChar ( 0x38 ) ; bsPutUChar ( 0x50 ) ; bsPutUChar ( 0x90 ) ; bsPutint ( combinedCRC ) ; bsFinishedWithStream ( ) ; } private void hbAssignCodes ( int [ ] code , char [ ] length , int minLen , int maxLen , int alphaSize ) { int n , vec , i ; vec = 0 ; for ( n = minLen ; n <= maxLen ; n ++ ) { for ( i = 0 ; i < alphaSize ; i ++ ) { if ( length [ i ] == n ) { code [ i ] = vec ; vec ++ ; } } ; vec <<= 1 ; } } private void bsSetStream ( OutputStream f ) { bsStream = f ; bsLive = 0 ; bsBuff = 0 ; bytesOut = 0 ; } private void bsFinishedWithStream ( ) throws IOException { while ( bsLive > 0 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } } private void bsW ( int n , int v ) throws IOException { while ( bsLive >= 8 ) { int ch = ( bsBuff > > 24 ) ; try { bsStream . write ( ch ) ; } catch ( IOException e ) { throw e ; } bsBuff <<= 8 ; bsLive -= 8 ; bytesOut ++ ; } bsBuff |= ( v << ( 32 - bsLive - n ) ) ; bsLive += n ; } private void bsPutUChar ( int c ) throws IOException { bsW ( 8 , c ) ; } private void bsPutint ( int u ) throws IOException { bsW ( 8 , ( u > > 24 ) & 0xff ) ; bsW ( 8 , ( u > > 16 ) & 0xff ) ; bsW ( 8 , ( u > > 8 ) & 0xff ) ; bsW ( 8 , u & 0xff ) ; } private void bsPutIntVS ( int numBits , int c ) throws IOException { bsW ( numBits , c ) ; } private void sendMTFValues ( ) throws IOException { char len [ ] [ ] = new char [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int v , t , i , j , gs , ge , totc , bt , bc , iter ; int nSelectors = 0 , alphaSize , minLen , maxLen , selCtr ; int nGroups , nBytes ; alphaSize = nInUse + 2 ; for ( t = 0 ; t < N_GROUPS ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { len [ t ] [ v ] = ( char ) GREATER_ICOST ; } } if ( nMTF <= 0 ) { panic ( ) ; } if ( nMTF < 200 ) { nGroups = 2 ; } else if ( nMTF < 600 ) { nGroups = 3 ; } else if ( nMTF < 1200 ) { nGroups = 4 ; } else if ( nMTF < 2400 ) { nGroups = 5 ; } else { nGroups = 6 ; } { int nPart , remF , tFreq , aFreq ; nPart = nGroups ; remF = nMTF ; gs = 0 ; while ( nPart > 0 ) { tFreq = remF / nPart ; ge = gs - 1 ; aFreq = 0 ; while ( aFreq < tFreq && ge < alphaSize - 1 ) { ge ++ ; aFreq += mtfFreq [ ge ] ; } if ( ge > gs && nPart != nGroups && nPart != 1 && ( ( nGroups - nPart ) % 2 == 1 ) ) { aFreq -= mtfFreq [ ge ] ; ge -- ; } for ( v = 0 ; v < alphaSize ; v ++ ) { if ( v >= gs && v <= ge ) { len [ nPart - 1 ] [ v ] = ( char ) LESSER_ICOST ; } else { len [ nPart - 1 ] [ v ] = ( char ) GREATER_ICOST ; } } nPart -- ; gs = ge + 1 ; remF -= aFreq ; } } int [ ] [ ] rfreq = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; int [ ] fave = new int [ N_GROUPS ] ; short [ ] cost = new short [ N_GROUPS ] ; for ( iter = 0 ; iter < N_ITERS ; iter ++ ) { for ( t = 0 ; t < nGroups ; t ++ ) { fave [ t ] = 0 ; } for ( t = 0 ; t < nGroups ; t ++ ) { for ( v = 0 ; v < alphaSize ; v ++ ) { rfreq [ t ] [ v ] = 0 ; } } nSelectors = 0 ; totc = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] = 0 ; } if ( nGroups == 6 ) { short cost0 , cost1 , cost2 , cost3 , cost4 , cost5 ; cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0 ; for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; cost0 += len [ 0 ] [ icv ] ; cost1 += len [ 1 ] [ icv ] ; cost2 += len [ 2 ] [ icv ] ; cost3 += len [ 3 ] [ icv ] ; cost4 += len [ 4 ] [ icv ] ; cost5 += len [ 5 ] [ icv ] ; } cost [ 0 ] = cost0 ; cost [ 1 ] = cost1 ; cost [ 2 ] = cost2 ; cost [ 3 ] = cost3 ; cost [ 4 ] = cost4 ; cost [ 5 ] = cost5 ; } else { for ( i = gs ; i <= ge ; i ++ ) { short icv = szptr [ i ] ; for ( t = 0 ; t < nGroups ; t ++ ) { cost [ t ] += len [ t ] [ icv ] ; } } } bc = 999999999 ; bt = - 1 ; for ( t = 0 ; t < nGroups ; t ++ ) { if ( cost [ t ] < bc ) { bc = cost [ t ] ; bt = t ; } } ; totc += bc ; fave [ bt ] ++ ; selector [ nSelectors ] = ( char ) bt ; nSelectors ++ ; for ( i = gs ; i <= ge ; i ++ ) { rfreq [ bt ] [ szptr [ i ] ] ++ ; } gs = ge + 1 ; } for ( t = 0 ; t < nGroups ; t ++ ) { hbMakeCodeLengths ( len [ t ] , rfreq [ t ] , alphaSize , 20 ) ; } } rfreq = null ; fave = null ; cost = null ; if ( ! ( nGroups < 8 ) ) { panic ( ) ; } if ( ! ( nSelectors < 32768 && nSelectors <= ( 2 + ( 900000 / G_SIZE ) ) ) ) { panic ( ) ; } { char [ ] pos = new char [ N_GROUPS ] ; char ll_i , tmp2 , tmp ; for ( i = 0 ; i < nGroups ; i ++ ) { pos [ i ] = ( char ) i ; } for ( i = 0 ; i < nSelectors ; i ++ ) { ll_i = selector [ i ] ; j = 0 ; tmp = pos [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = pos [ j ] ; pos [ j ] = tmp2 ; } pos [ 0 ] = tmp ; selectorMtf [ i ] = ( char ) j ; } } int [ ] [ ] code = new int [ N_GROUPS ] [ MAX_ALPHA_SIZE ] ; for ( t = 0 ; t < nGroups ; t ++ ) { minLen = 32 ; maxLen = 0 ; for ( i = 0 ; i < alphaSize ; i ++ ) { if ( len [ t ] [ i ] > maxLen ) { maxLen = len [ t ] [ i ] ; } if ( len [ t ] [ i ] < minLen ) { minLen = len [ t ] [ i ] ; } } if ( maxLen > 20 ) { panic ( ) ; } if ( minLen < 1 ) { panic ( ) ; } hbAssignCodes ( code [ t ] , len [ t ] , minLen , maxLen , alphaSize ) ; } { boolean [ ] inUse16 = new boolean [ 16 ] ; for ( i = 0 ; i < 16 ; i ++ ) { inUse16 [ i ] = false ; for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { inUse16 [ i ] = true ; } } } nBytes = bytesOut ; for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } for ( i = 0 ; i < 16 ; i ++ ) { if ( inUse16 [ i ] ) { for ( j = 0 ; j < 16 ; j ++ ) { if ( inUse [ i * 16 + j ] ) { bsW ( 1 , 1 ) ; } else { bsW ( 1 , 0 ) ; } } } } } nBytes = bytesOut ; bsW ( 3 , nGroups ) ; bsW ( 15 , nSelectors ) ; for ( i = 0 ; i < nSelectors ; i ++ ) { for ( j = 0 ; j < selectorMtf [ i ] ; j ++ ) { bsW ( 1 , 1 ) ; } bsW ( 1 , 0 ) ; } nBytes = bytesOut ; for ( t = 0 ; t < nGroups ; t ++ ) { int curr = len [ t ] [ 0 ] ; bsW ( 5 , curr ) ; for ( i = 0 ; i < alphaSize ; i ++ ) { while ( curr < len [ t ] [ i ] ) { bsW ( 2 , 2 ) ; curr ++ ; } while ( curr > len [ t ] [ i ] ) { bsW ( 2 , 3 ) ; curr -- ; } bsW ( 1 , 0 ) ; } } nBytes = bytesOut ; selCtr = 0 ; gs = 0 ; while ( true ) { if ( gs >= nMTF ) { break ; } ge = gs + G_SIZE - 1 ; if ( ge >= nMTF ) { ge = nMTF - 1 ; } for ( i = gs ; i <= ge ; i ++ ) { bsW ( len [ selector [ selCtr ] ] [ szptr [ i ] ] , code [ selector [ selCtr ] ] [ szptr [ i ] ] ) ; } gs = ge + 1 ; selCtr ++ ; } if ( ! ( selCtr == nSelectors ) ) { panic ( ) ; } } private void moveToFrontCodeAndSend ( ) throws IOException { bsPutIntVS ( 24 , origPtr ) ; generateMTFValues ( ) ; sendMTFValues ( ) ; } private OutputStream bsStream ; private void simpleSort ( int lo , int hi , int d ) { int i , j , h , bigN , hp ; int v ; bigN = hi - lo + 1 ; if ( bigN < 2 ) { return ; } hp = 0 ; while ( incs [ hp ] < bigN ) { hp ++ ; } hp -- ; for ( ; hp >= 0 ; hp -- ) { h = incs [ hp ] ; i = lo + h ; while ( true ) { if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( i > hi ) { break ; } v = zptr [ i ] ; j = i ; while ( fullGtU ( zptr [ j - h ] + d , v + d ) ) { zptr [ j ] = zptr [ j - h ] ; j = j - h ; if ( j <= ( lo + h - 1 ) ) { break ; } } zptr [ j ] = v ; i ++ ; if ( workDone > workLimit && firstAttempt ) { return ; } } } } private void vswap ( int p1 , int p2 , int n ) { int temp = 0 ; while ( n > 0 ) { temp = zptr [ p1 ] ; zptr [ p1 ] = zptr [ p2 ] ; zptr [ p2 ] = temp ; p1 ++ ; p2 ++ ; n -- ; } } private char med3 ( char a , char b , char c ) { char t ; if ( a > b ) { t = a ; a = b ; b = t ; } if ( b > c ) { t = b ; b = c ; c = t ; } if ( a > b ) { b = a ; } return b ; } private static class StackElem { int ll ; int hh ; int dd ; } private void qSort3 ( int loSt , int hiSt , int dSt ) { int unLo , unHi , ltLo , gtHi , med , n , m ; int sp , lo , hi , d ; StackElem [ ] stack = new StackElem [ QSORT_STACK_SIZE ] ; for ( int count = 0 ; count < QSORT_STACK_SIZE ; count ++ ) { stack [ count ] = new StackElem ( ) ; } sp = 0 ; stack [ sp ] . ll = loSt ; stack [ sp ] . hh = hiSt ; stack [ sp ] . dd = dSt ; sp ++ ; while ( sp > 0 ) { if ( sp >= QSORT_STACK_SIZE ) { panic ( ) ; } sp -- ; lo = stack [ sp ] . ll ; hi = stack [ sp ] . hh ; d = stack [ sp ] . dd ; if ( hi - lo < SMALL_THRESH || d > DEPTH_THRESH ) { simpleSort ( lo , hi , d ) ; if ( workDone > workLimit && firstAttempt ) { return ; } continue ; } med = med3 ( block [ zptr [ lo ] + d + 1 ] , block [ zptr [ hi ] + d + 1 ] , block [ zptr [ ( lo + hi ) > > 1 ] + d + 1 ] ) ; unLo = ltLo = lo ; unHi = gtHi = hi ; while ( true ) { while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unLo ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ ltLo ] ; zptr [ ltLo ] = temp ; ltLo ++ ; unLo ++ ; continue ; } ; if ( n > 0 ) { break ; } unLo ++ ; } while ( true ) { if ( unLo > unHi ) { break ; } n = ( ( int ) block [ zptr [ unHi ] + d + 1 ] ) - med ; if ( n == 0 ) { int temp = 0 ; temp = zptr [ unHi ] ; zptr [ unHi ] = zptr [ gtHi ] ; zptr [ gtHi ] = temp ; gtHi -- ; unHi -- ; continue ; } ; if ( n < 0 ) { break ; } unHi -- ; } if ( unLo > unHi ) { break ; } int temp = 0 ; temp = zptr [ unLo ] ; zptr [ unLo ] = zptr [ unHi ] ; zptr [ unHi ] = temp ; unLo ++ ; unHi -- ; } if ( gtHi < ltLo ) { stack [ sp ] . ll = lo ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d + 1 ; sp ++ ; continue ; } n = ( ( ltLo - lo ) < ( unLo - ltLo ) ) ? ( ltLo - lo ) : ( unLo - ltLo ) ; vswap ( lo , unLo - n , n ) ; m = ( ( hi - gtHi ) < ( gtHi - unHi ) ) ? ( hi - gtHi ) : ( gtHi - unHi ) ; vswap ( unLo , hi - m + 1 , m ) ; n = lo + unLo - ltLo - 1 ; m = hi - ( gtHi - unHi ) + 1 ; stack [ sp ] . ll = lo ; stack [ sp ] . hh = n ; stack [ sp ] . dd = d ; sp ++ ; stack [ sp ] . ll = n + 1 ; stack [ sp ] . hh = m - 1 ; stack [ sp ] . dd = d + 1 ; sp ++ ; stack [ sp ] . ll = m ; stack [ sp ] . hh = hi ; stack [ sp ] . dd = d ; sp ++ ; } } private void mainSort ( ) { int i , j , ss , sb ; int [ ] runningOrder = new int [ 256 ] ; int [ ] copy = new int [ 256 ] ; boolean [ ] bigDone = new boolean [ 256 ] ; int c1 , c2 ; int numQSorted ; for ( i = 0 ; i < NUM_OVERSHOOT_BYTES ; i ++ ) { block [ last + i + 2 ] = block [ ( i % ( last + 1 ) ) + 1 ] ; } for ( i = 0 ; i <= last + NUM_OVERSHOOT_BYTES ; i ++ ) { quadrant [ i ] = 0 ; } block [ 0 ] = ( char ) ( block [ last + 1 ] ) ; if ( last < 4000 ) { for ( i = 0 ; i <= last ; i ++ ) { zptr [ i ] = i ; } firstAttempt = false ; workDone = workLimit = 0 ; simpleSort ( 0 , last , 0 ) ; } else { numQSorted = 0 ; for ( i = 0 ; i <= 255 ; i ++ ) { bigDone [ i ] = false ; } for ( i = 0 ; i <= 65536 ; i ++ ) { ftab [ i ] = 0 ; } c1 = block [ 0 ] ; for ( i = 0 ; i <= last ; i ++ ) { c2 = block [ i + 1 ] ; ftab [ ( c1 << 8 ) + c2 ] ++ ; c1 = c2 ; } for ( i = 1 ; i <= 65536 ; i ++ ) { ftab [ i ] += ftab [ i - 1 ] ; } c1 = block [ 1 ] ; for ( i = 0 ; i < last ; i ++ ) { c2 = block [ i + 2 ] ; j = ( c1 << 8 ) + c2 ; c1 = c2 ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = i ; } j = ( ( block [ last + 1 ] ) << 8 ) + ( block [ 1 ] ) ; ftab [ j ] -- ; zptr [ ftab [ j ] ] = last ; for ( i = 0 ; i <= 255 ; i ++ ) { runningOrder [ i ] = i ; } { int vv ; int h = 1 ; do { h = 3 * h + 1 ; } while ( h <= 256 ) ; do { h = h / 3 ; for ( i = h ; i <= 255 ; i ++ ) { vv = runningOrder [ i ] ; j = i ; while ( ( ftab [ ( ( runningOrder [ j - h ] ) + 1 ) << 8 ] - ftab [ ( runningOrder [ j - h ] ) << 8 ] ) > ( ftab [ ( ( vv ) + 1 ) << 8 ] - ftab [ ( vv ) << 8 ] ) ) { runningOrder [ j ] = runningOrder [ j - h ] ; j = j - h ; if ( j <= ( h - 1 ) ) { break ; } } runningOrder [ j ] = vv ; } } while ( h != 1 ) ; } for ( i = 0 ; i <= 255 ; i ++ ) { ss = runningOrder [ i ] ; for ( j = 0 ; j <= 255 ; j ++ ) { sb = ( ss << 8 ) + j ; if ( ! ( ( ftab [ sb ] & SETMASK ) == SETMASK ) ) { int lo = ftab [ sb ] & CLEARMASK ; int hi = ( ftab [ sb + 1 ] & CLEARMASK ) - 1 ; if ( hi > lo ) { qSort3 ( lo , hi , 2 ) ; numQSorted += ( hi - lo + 1 ) ; if ( workDone > workLimit && firstAttempt ) { return ; } } ftab [ sb ] |= SETMASK ; } } bigDone [ ss ] = true ; if ( i < 255 ) { int bbStart = ftab [ ss << 8 ] & CLEARMASK ; int bbSize = ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) - bbStart ; int shifts = 0 ; while ( ( bbSize > > shifts ) > 65534 ) { shifts ++ ; } for ( j = 0 ; j < bbSize ; j ++ ) { int a2update = zptr [ bbStart + j ] ; int qVal = ( j > > shifts ) ; quadrant [ a2update ] = qVal ; if ( a2update < NUM_OVERSHOOT_BYTES ) { quadrant [ a2update + last + 1 ] = qVal ; } } if ( ! ( ( ( bbSize - 1 ) > > shifts ) <= 65535 ) ) { panic ( ) ; } } for ( j = 0 ; j <= 255 ; j ++ ) { copy [ j ] = ftab [ ( j << 8 ) + ss ] & CLEARMASK ; } for ( j = ftab [ ss << 8 ] & CLEARMASK ; j < ( ftab [ ( ss + 1 ) << 8 ] & CLEARMASK ) ; j ++ ) { c1 = block [ zptr [ j ] ] ; if ( ! bigDone [ c1 ] ) { zptr [ copy [ c1 ] ] = zptr [ j ] == 0 ? last : zptr [ j ] - 1 ; copy [ c1 ] ++ ; } } for ( j = 0 ; j <= 255 ; j ++ ) { ftab [ ( j << 8 ) + ss ] |= SETMASK ; } } } } private void randomiseBlock ( ) { int i ; int rNToGo = 0 ; int rTPos = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { inUse [ i ] = false ; } for ( i = 0 ; i <= last ; i ++ ) { if ( rNToGo == 0 ) { rNToGo = ( char ) rNums [ rTPos ] ; rTPos ++ ; if ( rTPos == 512 ) { rTPos = 0 ; } } rNToGo -- ; block [ i + 1 ] ^= ( ( rNToGo == 1 ) ? 1 : 0 ) ; block [ i + 1 ] &= 0xFF ; inUse [ block [ i + 1 ] ] = true ; } } private void doReversibleTransformation ( ) { int i ; workLimit = workFactor * last ; workDone = 0 ; blockRandomised = false ; firstAttempt = true ; mainSort ( ) ; if ( workDone > workLimit && firstAttempt ) { randomiseBlock ( ) ; workLimit = workDone = 0 ; blockRandomised = true ; firstAttempt = false ; mainSort ( ) ; } origPtr = - 1 ; for ( i = 0 ; i <= last ; i ++ ) { if ( zptr [ i ] == 0 ) { origPtr = i ; break ; } } ; if ( origPtr == - 1 ) { panic ( ) ; } } private boolean fullGtU ( int i1 , int i2 ) { int k ; char c1 , c2 ; int s1 , s2 ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } i1 ++ ; i2 ++ ; k = last + 1 ; do { c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; c1 = block [ i1 + 1 ] ; c2 = block [ i2 + 1 ] ; if ( c1 != c2 ) { return ( c1 > c2 ) ; } s1 = quadrant [ i1 ] ; s2 = quadrant [ i2 ] ; if ( s1 != s2 ) { return ( s1 > s2 ) ; } i1 ++ ; i2 ++ ; if ( i1 > last ) { i1 -= last ; i1 -- ; } ; if ( i2 > last ) { i2 -= last ; i2 -- ; } ; k -= 4 ; workDone ++ ; } while ( k >= 0 ) ; return false ; } private int [ ] incs = { 1 , 4 , 13 , 40 , 121 , 364 , 1093 , 3280 , 9841 , 29524 , 88573 , 265720 , 797161 , 2391484 } ; private void allocateCompressStructures ( ) { int n = baseBlockSize * blockSize100k ; block = new char [ ( n + 1 + NUM_OVERSHOOT_BYTES ) ] ; quadrant = new int [ ( n + NUM_OVERSHOOT_BYTES ) ] ; zptr = new int [ n ] ; ftab = new int [ 65537 ] ; if ( block == null || quadrant == null || zptr == null || ftab == null ) { } szptr = new short [ 2 * n ] ; } private void generateMTFValues ( ) { char [ ] yy = new char [ 256 ] ; int i , j ; char tmp ; char tmp2 ; int zPend ; int wr ; int EOB ; makeMaps ( ) ; EOB = nInUse + 1 ; for ( i = 0 ; i <= EOB ; i ++ ) { mtfFreq [ i ] = 0 ; } wr = 0 ; zPend = 0 ; for ( i = 0 ; i < nInUse ; i ++ ) { yy [ i ] = ( char ) i ; } for ( i = 0 ; i <= last ; i ++ ) { char ll_i ; ll_i = unseqToSeq [ block [ zptr [ i ] ] ] ; j = 0 ; tmp = yy [ j ] ; while ( ll_i != tmp ) { j ++ ; tmp2 = tmp ; tmp = yy [ j ] ; yy [ j ] = tmp2 ; } ; yy [ 0 ] = tmp ; if ( j == 0 ) { zPend ++ ; } else { if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } ; if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } ; zPend = 0 ; } szptr [ wr ] = ( short ) ( j + 1 ) ; wr ++ ; mtfFreq [ j + 1 ] ++ ; } } if ( zPend > 0 ) { zPend -- ; while ( true ) { switch ( zPend % 2 ) { case 0 : szptr [ wr ] = ( short ) RUNA ; wr ++ ; mtfFreq [ RUNA ] ++ ; break ; case 1 : szptr [ wr ] = ( short ) RUNB ; wr ++ ; mtfFreq [ RUNB ] ++ ; break ; } if ( zPend < 2 ) { break ; } zPend = ( zPend - 2 ) / 2 ; } } szptr [ wr ] = ( short ) EOB ; wr ++ ; mtfFreq [ EOB ] ++ ; nMTF = wr ; } } 	0	['33', '2', '0', '6', '44', '322', '2', '4', '5', '0.857469512', '4238', '0.780487805', '1', '0.138888889', '0.257575758', '1', '1', '126.1818182', '32', '5.6061', '0']
package org . apache . tools . ant . util ; import java . text . ChoiceFormat ; import java . text . DateFormat ; import java . text . MessageFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Locale ; import java . util . TimeZone ; public final class DateUtils { public static final String ISO8601_DATETIME_PATTERN = "yyyy-MM-dd'T'HH:mm:ss" ; public static final String ISO8601_DATE_PATTERN = "yyyy-MM-dd" ; public static final String ISO8601_TIME_PATTERN = "HH:mm:ss" ; public static final DateFormat DATE_HEADER_FORMAT = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss " , Locale . US ) ; private static final MessageFormat MINUTE_SECONDS = new MessageFormat ( "{0}{1}" ) ; private static final double [ ] LIMITS = { 0 , 1 , 2 } ; private static final String [ ] MINUTES_PART = { "" , "1 minute " , "{0,number} minutes " } ; private static final String [ ] SECONDS_PART = { "0 seconds" , "1 second" , "{1,number} seconds" } ; private static final ChoiceFormat MINUTES_FORMAT = new ChoiceFormat ( LIMITS , MINUTES_PART ) ; private static final ChoiceFormat SECONDS_FORMAT = new ChoiceFormat ( LIMITS , SECONDS_PART ) ; static { MINUTE_SECONDS . setFormat ( 0 , MINUTES_FORMAT ) ; MINUTE_SECONDS . setFormat ( 1 , SECONDS_FORMAT ) ; } private DateUtils ( ) { } public static String format ( long date , String pattern ) { return format ( new Date ( date ) , pattern ) ; } public static String format ( Date date , String pattern ) { DateFormat df = createDateFormat ( pattern ) ; return df . format ( date ) ; } public static String formatElapsedTime ( long millis ) { long seconds = millis / 1000 ; long minutes = seconds / 60 ; Object [ ] args = { new Long ( minutes ) , new Long ( seconds % 60 ) } ; return MINUTE_SECONDS . format ( args ) ; } private static DateFormat createDateFormat ( String pattern ) { SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; TimeZone gmt = TimeZone . getTimeZone ( "GMT" ) ; sdf . setTimeZone ( gmt ) ; sdf . setLenient ( true ) ; return sdf ; } public static int getPhaseOfMoon ( Calendar cal ) { int dayOfTheYear = cal . get ( Calendar . DAY_OF_YEAR ) ; int yearInMetonicCycle = ( ( cal . get ( Calendar . YEAR ) - 1900 ) % 19 ) + 1 ; int epact = ( 11 * yearInMetonicCycle + 18 ) % 30 ; if ( ( epact == 25 && yearInMetonicCycle > 11 ) || epact == 24 ) { epact ++ ; } return ( ( ( ( ( dayOfTheYear + epact ) * 6 ) + 11 ) % 177 ) / 22 ) & 7 ; } public static String getDateForHeader ( ) { Calendar cal = Calendar . getInstance ( ) ; TimeZone tz = cal . getTimeZone ( ) ; int offset = tz . getOffset ( cal . get ( Calendar . ERA ) , cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) , cal . get ( Calendar . DAY_OF_MONTH ) , cal . get ( Calendar . DAY_OF_WEEK ) , cal . get ( Calendar . MILLISECOND ) ) ; StringBuffer tzMarker = new StringBuffer ( offset < 0 ? "-" : "+" ) ; offset = Math . abs ( offset ) ; int hours = offset / ( 60 * 60 * 1000 ) ; int minutes = offset / ( 60 * 1000 ) - 60 * hours ; if ( hours < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( hours ) ; if ( minutes < 10 ) { tzMarker . append ( "0" ) ; } tzMarker . append ( minutes ) ; return DATE_HEADER_FORMAT . format ( cal . getTime ( ) ) + tzMarker . toString ( ) ; } public static Date parseIso8601DateTime ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATETIME_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601Date ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATE_PATTERN ) . parse ( datestr ) ; } public static Date parseIso8601DateTimeOrDate ( String datestr ) throws ParseException { try { return parseIso8601DateTime ( datestr ) ; } catch ( ParseException px ) { return parseIso8601Date ( datestr ) ; } } } 	0	['11', '1', '0', '3', '36', '51', '3', '0', '8', '1.01', '314', '0.6', '0', '0', '0.22', '0', '0', '26.63636364', '4', '1.3636', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private Vector contains = new Vector ( ) ; private String line = null ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int containsSize = contains . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; if ( line . indexOf ( containsStr ) == - 1 ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public final void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private final Vector getContains ( ) { return contains ; } public final Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '6', '26', '0', '1', '5', '5', '0.571428571', '173', '1', '0', '0.823529412', '0.375', '2', '5', '20.25', '4', '1.125', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . filters . ClassConstants ; import org . apache . tools . ant . filters . EscapeUnicode ; import org . apache . tools . ant . filters . ExpandProperties ; import org . apache . tools . ant . filters . HeadFilter ; import org . apache . tools . ant . filters . LineContains ; import org . apache . tools . ant . filters . LineContainsRegExp ; import org . apache . tools . ant . filters . PrefixLines ; import org . apache . tools . ant . filters . ReplaceTokens ; import org . apache . tools . ant . filters . StripJavaComments ; import org . apache . tools . ant . filters . StripLineBreaks ; import org . apache . tools . ant . filters . StripLineComments ; import org . apache . tools . ant . filters . TabsToSpaces ; import org . apache . tools . ant . filters . TailFilter ; import org . apache . tools . ant . filters . TokenFilter ; public final class FilterChain extends DataType implements Cloneable { private Vector filterReaders = new Vector ( ) ; public final void addFilterReader ( final AntFilterReader filterReader ) { filterReaders . addElement ( filterReader ) ; } public final Vector getFilterReaders ( ) { return filterReaders ; } public final void addClassConstants ( final ClassConstants classConstants ) { filterReaders . addElement ( classConstants ) ; } public final void addExpandProperties ( final ExpandProperties expandProperties ) { filterReaders . addElement ( expandProperties ) ; } public final void addHeadFilter ( final HeadFilter headFilter ) { filterReaders . addElement ( headFilter ) ; } public final void addLineContains ( final LineContains lineContains ) { filterReaders . addElement ( lineContains ) ; } public final void addLineContainsRegExp ( final LineContainsRegExp lineContainsRegExp ) { filterReaders . addElement ( lineContainsRegExp ) ; } public final void addPrefixLines ( final PrefixLines prefixLines ) { filterReaders . addElement ( prefixLines ) ; } public final void addReplaceTokens ( final ReplaceTokens replaceTokens ) { filterReaders . addElement ( replaceTokens ) ; } public final void addStripJavaComments ( final StripJavaComments stripJavaComments ) { filterReaders . addElement ( stripJavaComments ) ; } public final void addStripLineBreaks ( final StripLineBreaks stripLineBreaks ) { filterReaders . addElement ( stripLineBreaks ) ; } public final void addStripLineComments ( final StripLineComments stripLineComments ) { filterReaders . addElement ( stripLineComments ) ; } public final void addTabsToSpaces ( final TabsToSpaces tabsToSpaces ) { filterReaders . addElement ( tabsToSpaces ) ; } public final void addTailFilter ( final TailFilter tailFilter ) { filterReaders . addElement ( tailFilter ) ; } public final void addEscapeUnicode ( final EscapeUnicode escapeUnicode ) { filterReaders . addElement ( escapeUnicode ) ; } public final void addTokenFilter ( final TokenFilter tokenFilter ) { filterReaders . addElement ( tokenFilter ) ; } public void addDeleteCharacters ( TokenFilter . DeleteCharacters filter ) { filterReaders . addElement ( filter ) ; } public void addContainsRegex ( TokenFilter . ContainsRegex filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceRegex ( TokenFilter . ReplaceRegex filter ) { filterReaders . addElement ( filter ) ; } public void addTrim ( TokenFilter . Trim filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceString ( TokenFilter . ReplaceString filter ) { filterReaders . addElement ( filter ) ; } public void addIgnoreBlank ( TokenFilter . IgnoreBlank filter ) { filterReaders . addElement ( filter ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! filterReaders . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof FilterChain ) { FilterChain fc = ( FilterChain ) o ; filterReaders = fc . getFilterReaders ( ) ; } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterChain" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } public void add ( ChainableReader filter ) { filterReaders . addElement ( filter ) ; } } 	0	['25', '3', '0', '32', '38', '0', '5', '27', '25', '0', '189', '1', '0', '0.555555556', '0.08', '1', '1', '6.52', '1', '0.96', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '6', '5', '6', '5', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class DateSelector extends BaseExtendSelector { private long millis = - 1 ; private String dateTime = null ; private boolean includeDirs = false ; private int granularity = 0 ; private int cmp = 2 ; public static final String MILLIS_KEY = "millis" ; public static final String DATETIME_KEY = "datetime" ; public static final String CHECKDIRS_KEY = "checkdirs" ; public static final String GRANULARITY_KEY = "granularity" ; public static final String WHEN_KEY = "when" ; public DateSelector ( ) { if ( Os . isFamily ( "dos" ) ) { granularity = 2000 ; } } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dateselector date: " ) ; buf . append ( dateTime ) ; buf . append ( " compare: " ) ; if ( cmp == 0 ) { buf . append ( "before" ) ; } else if ( cmp == 1 ) { buf . append ( "after" ) ; } else { buf . append ( "equal" ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMillis ( long millis ) { this . millis = millis ; } public long getMillis ( ) { return millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value relative" + " to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { setError ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + " MM/DD/YYYY HH:MM AM_PM format." ) ; } } } public void setCheckdirs ( boolean includeDirs ) { this . includeDirs = includeDirs ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public void setWhen ( TimeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MILLIS_KEY . equalsIgnoreCase ( paramname ) ) { try { setMillis ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid millisecond setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( DATETIME_KEY . equalsIgnoreCase ( paramname ) ) { setDatetime ( parameters [ i ] . getValue ( ) ) ; } else if ( CHECKDIRS_KEY . equalsIgnoreCase ( paramname ) ) { setCheckdirs ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( GRANULARITY_KEY . equalsIgnoreCase ( paramname ) ) { try { setGranularity ( new Integer ( parameters [ i ] . getValue ( ) ) . intValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid granularity setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { TimeComparisons cmp = new TimeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( dateTime == null && millis < 0 ) { setError ( "You must provide a datetime or the number of " + "milliseconds." ) ; } else if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) && ( ! includeDirs ) ) { return true ; } if ( cmp == 0 ) { return ( ( file . lastModified ( ) - granularity ) < millis ) ; } else if ( cmp == 1 ) { return ( ( file . lastModified ( ) + granularity ) > millis ) ; } else { return ( Math . abs ( file . lastModified ( ) - millis ) <= granularity ) ; } } public static class TimeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "before" , "after" , "equal" } ; } } } 	0	['11', '5', '0', '12', '38', '1', '5', '7', '11', '0.84', '394', '0.5', '0', '0.791666667', '0.215909091', '1', '4', '33.90909091', '8', '2.7273', '0']
package org . apache . tools . ant . types ; public class FlexInteger { private Integer value ; public FlexInteger ( String value ) { this . value = Integer . decode ( value ) ; } public int intValue ( ) { return value . intValue ( ) ; } public String toString ( ) { return value . toString ( ) ; } } 	0	['3', '1', '0', '0', '7', '0', '0', '0', '3', '0', '19', '1', '0', '0', '0.666666667', '0', '0', '5', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '20', '21', '0', '2', '9', '0.6', '132', '1', '0', '0.804347826', '0.4', '1', '1', '11.7', '1', '0.9', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; class RedirectingStreamHandler extends PumpStreamHandler { RedirectingStreamHandler ( final ChangeLogParser parser ) { super ( new RedirectingOutputStream ( parser ) , new ByteArrayOutputStream ( ) ) ; } String getErrors ( ) { try { final ByteArrayOutputStream error = ( ByteArrayOutputStream ) getErr ( ) ; return error . toString ( "ASCII" ) ; } catch ( final Exception e ) { return null ; } } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( final IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '1', '2', '40', '0', '0', '0.857142857', '0.666666667', '0', '0', '12.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; try { Class c = Class . forName ( "at.dms.kjc.Main" ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( null , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use kjc compiler, as it is not " + "available. A common solution is to " + "set the environment variable CLASSPATH " + "to your kjc archive (kjc.jar)." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting kjc compiler: " , ex , location ) ; } } } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation == true ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; if ( bootclasspath != null ) { cp . append ( bootclasspath ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; if ( compileSourcepath != null ) { cp . append ( compileSourcepath ) ; } else { cp . append ( src ) ; } cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['4', '2', '0', '10', '26', '6', '1', '9', '2', '1', '195', '0', '0', '0.884615385', '0.5', '0', '0', '47.5', '10', '3', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_DIM = 2 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private final void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String err = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( err != null ) { errColor = PREFIX + err + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected final void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0	['3', '2', '0', '1', '18', '0', '0', '1', '1', '0.96875', '258', '1', '0', '0.888888889', '0.5', '1', '3', '79.66666667', '12', '5.6667', '0']
package org . apache . tools . ant . util ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; public final class StringUtils { public static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static Vector lineSplit ( String data ) { return split ( data , '\n' ) ; } public static Vector split ( String data , int ch ) { Vector elems = new Vector ( ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( ch , i ) ) != - 1 ) { String elem = data . substring ( i , pos ) ; elems . addElement ( elem ) ; i = pos + 1 ; } elems . addElement ( data . substring ( i ) ) ; return elems ; } public static String replace ( String data , String from , String to ) { StringBuffer buf = new StringBuffer ( data . length ( ) ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( from , i ) ) != - 1 ) { buf . append ( data . substring ( i , pos ) ) . append ( to ) ; i = pos + from . length ( ) ; } buf . append ( data . substring ( i ) ) ; return buf . toString ( ) ; } public static String getStackTrace ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; pw . close ( ) ; return sw . toString ( ) ; } } 	0	['6', '1', '0', '14', '24', '15', '14', '0', '5', '1', '116', '0', '0', '0', '0.3', '0', '0', '18.16666667', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class ContainsSelector extends BaseExtendSelector { private String contains = null ; private boolean casesensitive = true ; private boolean ignorewhitespace = false ; public static final String EXPRESSION_KEY = "expression" ; public static final String CONTAINS_KEY = "text" ; public static final String CASE_KEY = "casesensitive" ; public static final String WHITESPACE_KEY = "ignorewhitespace" ; public ContainsSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsselector text: " ) ; buf . append ( contains ) ; buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " ignorewhitespace: " ) ; if ( ignorewhitespace ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setText ( String contains ) { this . contains = contains ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setIgnorewhitespace ( boolean ignorewhitespace ) { this . ignorewhitespace = ignorewhitespace ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( CONTAINS_KEY . equalsIgnoreCase ( paramname ) ) { setText ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( WHITESPACE_KEY . equalsIgnoreCase ( paramname ) ) { setIgnorewhitespace ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( contains == null ) { setError ( "The text attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } String userstr = contains ; if ( ! casesensitive ) { userstr = contains . toLowerCase ( ) ; } if ( ignorewhitespace ) { userstr = SelectorUtils . removeWhitespace ( userstr ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! casesensitive ) { teststr = teststr . toLowerCase ( ) ; } if ( ignorewhitespace ) { teststr = SelectorUtils . removeWhitespace ( teststr ) ; } if ( teststr . indexOf ( userstr ) > - 1 ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read file " + filename ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close file " + filename ) ; } } } } } 	0	['8', '5', '0', '11', '30', '0', '5', '6', '8', '0.816326531', '299', '0.428571429', '0', '0.844444444', '0.35', '1', '4', '35.5', '11', '3.125', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class PrefixLines extends BaseParamFilterReader implements ChainableReader { private static final String PREFIX_KEY = "prefix" ; private String prefix = null ; private String queuedData = null ; public PrefixLines ( ) { super ( ) ; } public PrefixLines ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readLine ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { if ( prefix != null ) { queuedData = prefix + queuedData ; } return read ( ) ; } } return ch ; } public final void setPrefix ( final String prefix ) { this . prefix = prefix ; } private final String getPrefix ( ) { return prefix ; } public final Reader chain ( final Reader rdr ) { PrefixLines newFilter = new PrefixLines ( rdr ) ; newFilter . setPrefix ( getPrefix ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( PREFIX_KEY . equals ( params [ i ] . getName ( ) ) ) { prefix = params [ i ] . getValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '5', '22', '0', '1', '4', '5', '0.555555556', '150', '1', '0', '0.848484848', '0.476190476', '2', '5', '20', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '7', '13', '1', '1', '6', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . types . Parameter ; public final class HeadFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private long linesRead = 0 ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; public HeadFilter ( ) { super ( ) ; } public HeadFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } line = headFilter ( line ) ; linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final void setLines ( final long lines ) { this . lines = lines ; } private final long getLines ( ) { return lines ; } public final void setSkip ( final long skip ) { this . skip = skip ; } private final long getSkip ( ) { return skip ; } public final Reader chain ( final Reader rdr ) { HeadFilter newFilter = new HeadFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { lines = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String headFilter ( String line ) { linesRead ++ ; if ( skip > 0 ) { if ( ( linesRead - 1 ) < skip ) { return null ; } } if ( lines > 0 ) { if ( linesRead > ( lines + skip ) ) { return null ; } } return line ; } } 	0	['10', '5', '0', '6', '25', '0', '1', '5', '6', '0.703703704', '251', '1', '1', '0.777777778', '0.375', '2', '4', '23.2', '5', '1.6', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . util . StringUtils ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public NoBannerLogger ( ) { } public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( StringUtils . LINE_SEP + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '4', '16', '0', '0', '4', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsFalse extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for falsehood" ) ; } return ! value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '34', '1', '0', '0.818181818', '0.666666667', '0', '0', '10', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; public abstract class BaseParamFilterReader extends BaseFilterReader implements Parameterizable { private Parameter [ ] parameters ; public BaseParamFilterReader ( ) { super ( ) ; } public BaseParamFilterReader ( final Reader in ) { super ( in ) ; } public final void setParameters ( final Parameter [ ] parameters ) { this . parameters = parameters ; setInitialized ( false ) ; } protected final Parameter [ ] getParameters ( ) { return parameters ; } } 	0	['4', '4', '11', '14', '7', '4', '11', '3', '3', '0.666666667', '22', '1', '1', '0.928571429', '0.5', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class MajoritySelector extends BaseSelectorContainer { private boolean allowtie = true ; public MajoritySelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{majorityselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void setAllowtie ( boolean tiebreaker ) { allowtie = tiebreaker ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int yesvotes = 0 ; int novotes = 0 ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { yesvotes = yesvotes + 1 ; } else { novotes = novotes + 1 ; } } if ( yesvotes > novotes ) { return true ; } else if ( novotes > yesvotes ) { return false ; } return allowtie ; } } 	0	['4', '5', '0', '6', '15', '0', '5', '2', '4', '0.333333333', '83', '1', '0', '0.953846154', '0.4375', '1', '1', '19.5', '5', '2', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpFactory extends RegexpMatcherFactory { public RegexpFactory ( ) { } public Regexp newRegexp ( ) throws BuildException { return ( Regexp ) newRegexp ( null ) ; } public Regexp newRegexp ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createRegexpInstance ( systemDefault ) ; } try { testAvailability ( "java.util.regex.Matcher" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaOroRegexp" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.regexp.RE" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpRegexp" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected Regexp createRegexpInstance ( String classname ) throws BuildException { RegexpMatcher m = createInstance ( classname ) ; if ( m instanceof Regexp ) { return ( Regexp ) m ; } else { throw new BuildException ( classname + " doesn't implement the Regexp interface" ) ; } } } 	0	['4', '2', '0', '6', '13', '6', '1', '5', '3', '2', '83', '0', '0', '0.625', '0.5', '0', '0', '19.75', '1', '0.75', '0']
package org . apache . tools . zip ; public final class ZipShort implements Cloneable { private int value ; public ZipShort ( int value ) { this . value = value ; } public ZipShort ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipShort ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 2 ] ; result [ 0 ] = ( byte ) ( value & 0xFF ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; return result ; } public int getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipShort ) ) { return false ; } return value == ( ( ZipShort ) o ) . getValue ( ) ; } public int hashCode ( ) { return value ; } } 	0	['7', '1', '0', '7', '8', '0', '7', '0', '7', '0', '89', '1', '0', '0', '0.428571429', '1', '1', '11.57142857', '4', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0	['1', '1', '0', '20', '1', '0', '19', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . taskdefs . LogOutputStream ; class RedirectingOutputStream extends LogOutputStream { private final ChangeLogParser parser ; public RedirectingOutputStream ( final ChangeLogParser parser ) { super ( null , 0 ) ; this . parser = parser ; } protected void processLine ( final String line ) { parser . stdout ( line ) ; } } 	0	['2', '4', '0', '4', '4', '0', '1', '3', '1', '0', '16', '1', '1', '0.9375', '0.666666667', '1', '1', '6.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public abstract class Pack extends Task { protected File zipFile ; protected File source ; public void setZipfile ( File zipFile ) { this . zipFile = zipFile ; } public void setDestfile ( File zipFile ) { setZipfile ( zipFile ) ; } public void setSrc ( File src ) { source = src ; } private void validate ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , getLocation ( ) ) ; } if ( zipFile . isDirectory ( ) ) { throw new BuildException ( "zipfile attribute must not " + "represent a directory!" , getLocation ( ) ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Src attribute must not " + "represent a directory!" , getLocation ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( ! source . exists ( ) ) { log ( "Nothing to do: " + source . getAbsolutePath ( ) + " doesn't exist." ) ; } else if ( zipFile . lastModified ( ) < source . lastModified ( ) ) { log ( "Building: " + zipFile . getAbsolutePath ( ) ) ; pack ( ) ; } else { log ( "Nothing to do: " + zipFile . getAbsolutePath ( ) + " is up to date." ) ; } } private void zipFile ( InputStream in , OutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } protected void zipFile ( File file , OutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } protected abstract void pack ( ) ; } 	0	['9', '3', '2', '5', '24', '26', '2', '3', '5', '0.6875', '169', '1', '0', '0.822222222', '0.444444444', '1', '1', '17.55555556', '1', '0.8889', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public abstract class BaseExtendSelector extends BaseSelector implements ExtendFileSelector { protected Parameter [ ] parameters = null ; public BaseExtendSelector ( ) { } public void setParameters ( Parameter [ ] parameters ) { this . parameters = parameters ; } protected Parameter [ ] getParameters ( ) { return parameters ; } public abstract boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['4', '4', '8', '12', '5', '0', '8', '4', '3', '0.333333333', '18', '1', '1', '0.921052632', '0.4375', '0', '0', '3.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . ZipFileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipOutputStream ; public class Ear extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; private static final FileUtils fu = FileUtils . newFileUtils ( ) ; public Ear ( ) { super ( ) ; archiveType = "ear" ; emptyBehavior = "create" ; } public void setEarfile ( File earFile ) { setDestFile ( earFile ) ; } public void setAppxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) { throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; } ZipFileSet fs = new ZipFileSet ( ) ; fs . setFile ( deploymentDescriptor ) ; fs . setFullpath ( "META-INF/application.xml" ) ; super . addFileset ( fs ) ; } public void addArchives ( ZipFileSet fs ) { fs . setPrefix ( "/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null && ! isInUpdateMode ( ) ) { throw new BuildException ( "appxml attribute is required" , getLocation ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath , int mode ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/application.xml" ) ) { if ( deploymentDescriptor == null || ! fu . fileNameEquals ( deploymentDescriptor , file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/application.xml which will" + " be ignored (please use appxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath , mode ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath , mode ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['8', '6', '0', '10', '31', '18', '0', '10', '4', '0.80952381', '149', '1', '1', '0.9625', '0.357142857', '3', '9', '17.25', '2', '0.875', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskAdapter ; public class Taskdef extends Typedef { public Taskdef ( ) { setAdapterClass ( TaskAdapter . class ) ; setAdaptToClass ( Task . class ) ; } } 	0	['2', '7', '0', '2', '8', '1', '0', '2', '1', '1', '37', '0', '0', '0.987179487', '0.5', '0', '0', '16.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public final void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private final int getTablength ( ) { return tabLength ; } public final Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private final void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '5', '0.708333333', '126', '1', '0', '0.848484848', '0.476190476', '2', '5', '16.42857143', '5', '1.2857', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Hashtable ; import java . util . Vector ; import java . util . Properties ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . email . EmailAddress ; import org . apache . tools . ant . taskdefs . email . Message ; import org . apache . tools . ant . taskdefs . email . Mailer ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . mail . MailMessage ; public class MailLogger extends DefaultLogger { private StringBuffer buffer = new StringBuffer ( ) ; public void buildFinished ( BuildEvent event ) { super . buildFinished ( event ) ; Project project = event . getProject ( ) ; Hashtable properties = project . getProperties ( ) ; Properties fileProperties = new Properties ( ) ; String filename = ( String ) properties . get ( "MailLogger.properties.file" ) ; if ( filename != null ) { InputStream is = null ; try { is = new FileInputStream ( filename ) ; fileProperties . load ( is ) ; } catch ( IOException ioe ) { } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } for ( Enumeration e = fileProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = fileProperties . getProperty ( key ) ; properties . put ( key , project . replaceProperties ( value ) ) ; } boolean success = ( event . getException ( ) == null ) ; String prefix = success ? "success" : "failure" ; try { boolean notify = Project . toBoolean ( getValue ( properties , prefix + ".notify" , "on" ) ) ; if ( ! notify ) { return ; } String mailhost = getValue ( properties , "mailhost" , "localhost" ) ; int port = Integer . parseInt ( getValue ( properties , "port" , String . valueOf ( MailMessage . DEFAULT_PORT ) ) ) ; String user = getValue ( properties , "user" , "" ) ; String password = getValue ( properties , "password" , "" ) ; boolean ssl = Project . toBoolean ( getValue ( properties , "ssl" , "off" ) ) ; String from = getValue ( properties , "from" , null ) ; String replytoList = getValue ( properties , "replyto" , "" ) ; String toList = getValue ( properties , prefix + ".to" , null ) ; String subject = getValue ( properties , prefix + ".subject" , ( success ) ? "Build Success" : "Build Failure" ) ; if ( user . equals ( "" ) && password . equals ( "" ) && ! ssl ) { sendMail ( mailhost , port , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } else { sendMimeMail ( event . getProject ( ) , mailhost , port , user , password , ssl , from , replytoList , toList , subject , buffer . substring ( 0 ) ) ; } } catch ( Exception e ) { System . out . println ( "MailLogger failed to send e-mail!" ) ; e . printStackTrace ( System . err ) ; } } protected void log ( String message ) { buffer . append ( message ) . append ( StringUtils . LINE_SEP ) ; } private String getValue ( Hashtable properties , String name , String defaultValue ) throws Exception { String propertyName = "MailLogger." + name ; String value = ( String ) properties . get ( propertyName ) ; if ( value == null ) { value = defaultValue ; } if ( value == null ) { throw new Exception ( "Missing required parameter: " + propertyName ) ; } return value ; } private void sendMail ( String mailhost , int port , String from , String replyToList , String toList , String subject , String message ) throws IOException { MailMessage mailMessage = new MailMessage ( mailhost , port ) ; mailMessage . setHeader ( "Date" , DateUtils . getDateForHeader ( ) ) ; mailMessage . from ( from ) ; if ( ! replyToList . equals ( "" ) ) { StringTokenizer t = new StringTokenizer ( replyToList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . replyto ( t . nextToken ( ) ) ; } } StringTokenizer t = new StringTokenizer ( toList , ", " , false ) ; while ( t . hasMoreTokens ( ) ) { mailMessage . to ( t . nextToken ( ) ) ; } mailMessage . setSubject ( subject ) ; PrintStream ps = mailMessage . getPrintStream ( ) ; ps . println ( message ) ; mailMessage . sendAndClose ( ) ; } private void sendMimeMail ( Project project , String host , int port , String user , String password , boolean ssl , String from , String replyToString , String toString , String subject , String message ) { Mailer mailer = null ; try { mailer = ( Mailer ) Class . forName ( "org.apache.tools.ant.taskdefs.email.MimeMailer" ) . newInstance ( ) ; } catch ( Throwable e ) { log ( "Failed to initialise MIME mail: " + e . getMessage ( ) ) ; return ; } Vector replyToList = vectorizeEmailAddresses ( replyToString ) ; mailer . setHost ( host ) ; mailer . setPort ( port ) ; mailer . setUser ( user ) ; mailer . setPassword ( password ) ; mailer . setSSL ( ssl ) ; Message mymessage = new Message ( message ) ; mymessage . setProject ( project ) ; mailer . setMessage ( mymessage ) ; mailer . setFrom ( new EmailAddress ( from ) ) ; mailer . setReplyToList ( replyToList ) ; Vector toList = vectorizeEmailAddresses ( toString ) ; mailer . setToList ( toList ) ; mailer . setCcList ( new Vector ( ) ) ; mailer . setBccList ( new Vector ( ) ) ; mailer . setFiles ( new Vector ( ) ) ; mailer . setSubject ( subject ) ; mailer . send ( ) ; } private Vector vectorizeEmailAddresses ( String listString ) { Vector emailList = new Vector ( ) ; StringTokenizer tokens = new StringTokenizer ( listString , "," ) ; while ( tokens . hasMoreTokens ( ) ) { emailList . addElement ( new EmailAddress ( tokens . nextToken ( ) ) ) ; } return emailList ; } } 	0	['7', '2', '0', '10', '69', '15', '0', '10', '2', '0.5', '453', '1', '0', '0.727272727', '0.367346939', '2', '4', '63.57142857', '14', '2.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . StringReader ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class Concat extends Task { private static final int BUFFER_SIZE = 8192 ; private File destinationFile = null ; private boolean append = false ; private String encoding = null ; private String outputEncoding = null ; private StringBuffer textBuffer ; private Vector sources = new Vector ( ) ; private Vector filterChains = null ; private boolean forceOverwrite = true ; private TextElement footer ; private TextElement header ; private boolean fixLastLine = false ; private String eolString = System . getProperty ( "line.separator" ) ; private Writer outputWriter = null ; private Vector sourceFiles = new Vector ( ) ; private static FileUtils fileUtils = FileUtils . newFileUtils ( ) ; public void setDestfile ( File destinationFile ) { this . destinationFile = destinationFile ; } public void setAppend ( boolean append ) { this . append = append ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; if ( outputEncoding == null ) { outputEncoding = encoding ; } } public void setOutputEncoding ( String outputEncoding ) { this . outputEncoding = outputEncoding ; } public void setForce ( boolean force ) { this . forceOverwrite = force ; } public Path createPath ( ) { Path path = new Path ( getProject ( ) ) ; sources . addElement ( path ) ; return path ; } public void addFileset ( FileSet set ) { sources . addElement ( set ) ; } public void addFilelist ( FileList list ) { sources . addElement ( list ) ; } public void addFilterChain ( FilterChain filterChain ) { if ( filterChains == null ) { filterChains = new Vector ( ) ; } filterChains . addElement ( filterChain ) ; } public void addText ( String text ) { if ( textBuffer == null ) { textBuffer = new StringBuffer ( text . length ( ) ) ; } textBuffer . append ( text ) ; } public void addHeader ( TextElement header ) { this . header = header ; } public void addFooter ( TextElement footer ) { this . footer = footer ; } public void setFixLastLine ( boolean fixLastLine ) { this . fixLastLine = fixLastLine ; } public void setEol ( FixCRLF . CrLf crlf ) { String s = crlf . getValue ( ) ; if ( s . equals ( "cr" ) || s . equals ( "mac" ) ) { eolString = "\r" ; } else if ( s . equals ( "lf" ) || s . equals ( "unix" ) ) { eolString = "\n" ; } else if ( s . equals ( "crlf" ) || s . equals ( "dos" ) ) { eolString = "\r\n" ; } } public void setWriter ( Writer outputWriter ) { this . outputWriter = outputWriter ; } public void execute ( ) { sanitizeText ( ) ; if ( destinationFile != null && outputWriter != null ) { throw new BuildException ( "Cannot specify both a destination file and an output writer" ) ; } if ( sources . size ( ) == 0 && textBuffer == null ) { throw new BuildException ( "At least one file must be provided, or some text." ) ; } if ( sources . size ( ) > 0 && textBuffer != null ) { throw new BuildException ( "Cannot include inline text when using filesets." ) ; } for ( Enumeration e = sources . elements ( ) ; e . hasMoreElements ( ) ; ) { Object o = e . nextElement ( ) ; if ( o instanceof Path ) { Path path = ( Path ) o ; checkAddFiles ( null , path . list ( ) ) ; } else if ( o instanceof FileSet ) { FileSet fileSet = ( FileSet ) o ; DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; checkAddFiles ( fileSet . getDir ( getProject ( ) ) , scanner . getIncludedFiles ( ) ) ; } else if ( o instanceof FileList ) { FileList fileList = ( FileList ) o ; checkAddFiles ( fileList . getDir ( getProject ( ) ) , fileList . getFiles ( getProject ( ) ) ) ; } } if ( destinationFile != null && ! forceOverwrite && ( sourceFiles . size ( ) > 0 ) && destinationFile . exists ( ) ) { boolean outofdate = false ; for ( int i = 0 ; i < sourceFiles . size ( ) ; ++ i ) { File file = ( File ) sourceFiles . elementAt ( i ) ; if ( file . lastModified ( ) > destinationFile . lastModified ( ) ) { outofdate = true ; break ; } } if ( ! outofdate ) { log ( destinationFile + " is up-to-date." , Project . MSG_VERBOSE ) ; return ; } } if ( textBuffer == null && sourceFiles . size ( ) == 0 && header == null && footer == null ) { log ( "No existing files and no nested text, doing nothing" , Project . MSG_INFO ) ; return ; } cat ( ) ; } public void reset ( ) { append = false ; forceOverwrite = true ; destinationFile = null ; encoding = null ; outputEncoding = null ; fixLastLine = false ; sources . removeAllElements ( ) ; sourceFiles . removeAllElements ( ) ; filterChains = null ; footer = null ; header = null ; } private void checkAddFiles ( File base , String [ ] filenames ) { for ( int i = 0 ; i < filenames . length ; ++ i ) { File file = new File ( base , filenames [ i ] ) ; if ( ! file . exists ( ) ) { log ( "File " + file + " does not exist." , Project . MSG_ERR ) ; continue ; } if ( destinationFile != null && fileUtils . fileNameEquals ( destinationFile , file ) ) { throw new BuildException ( "Input file \"" + file + "\" " + "is the same as the output file." ) ; } sourceFiles . addElement ( file ) ; } } private void cat ( ) { OutputStream os = null ; Reader reader = null ; char [ ] buffer = new char [ BUFFER_SIZE ] ; try { PrintWriter writer = null ; if ( outputWriter != null ) { writer = new PrintWriter ( outputWriter ) ; } else { if ( destinationFile == null ) { os = new LogOutputStream ( this , Project . MSG_WARN ) ; } else { File parent = fileUtils . getParentFile ( destinationFile ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } os = new FileOutputStream ( destinationFile . getAbsolutePath ( ) , append ) ; } if ( outputEncoding == null ) { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os ) ) ) ; } else { writer = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( os , outputEncoding ) ) ) ; } } if ( header != null ) { if ( header . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( header . getValue ( ) ) ) ; } else { writer . print ( header . getValue ( ) ) ; } } if ( textBuffer != null ) { reader = new StringReader ( getProject ( ) . replaceProperties ( textBuffer . substring ( 0 ) ) ) ; } else { reader = new MultiReader ( ) ; } concatenate ( buffer , writer , reader ) ; if ( footer != null ) { if ( footer . getFiltering ( ) ) { concatenate ( buffer , writer , new StringReader ( footer . getValue ( ) ) ) ; } else { writer . print ( footer . getValue ( ) ) ; } } writer . flush ( ) ; if ( os != null ) { os . flush ( ) ; } } catch ( IOException ioex ) { throw new BuildException ( "Error while concatenating: " + ioex . getMessage ( ) , ioex ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException ignore ) { } } if ( os != null ) { try { os . close ( ) ; } catch ( IOException ignore ) { } } } } private void concatenate ( char [ ] buffer , Writer writer , Reader in ) throws IOException { if ( filterChains != null ) { ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( BUFFER_SIZE ) ; helper . setPrimaryReader ( in ) ; helper . setFilterChains ( filterChains ) ; helper . setProject ( getProject ( ) ) ; in = new BufferedReader ( helper . getAssembledReader ( ) ) ; } while ( true ) { int nRead = in . read ( buffer , 0 , buffer . length ) ; if ( nRead == - 1 ) { break ; } writer . write ( buffer , 0 , nRead ) ; } writer . flush ( ) ; } private void sanitizeText ( ) { if ( textBuffer != null ) { if ( textBuffer . substring ( 0 ) . trim ( ) . length ( ) == 0 ) { textBuffer = null ; } } } public static class TextElement extends ProjectComponent { private String value = "" ; private boolean trimLeading = false ; private boolean trim = false ; private boolean filtering = true ; private String encoding = null ; public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } private boolean getFiltering ( ) { return filtering ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public void setFile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "File " + file + " does not exist." ) ; } BufferedReader reader = null ; try { if ( this . encoding == null ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , this . encoding ) ) ; } value = fileUtils . readFully ( reader ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( Throwable t ) { } } } } public void addText ( String value ) { this . value += getProject ( ) . replaceProperties ( value ) ; } public void setTrimLeading ( boolean strip ) { this . trimLeading = strip ; } public void setTrim ( boolean trim ) { this . trim = trim ; } public String getValue ( ) { if ( value == null ) { value = "" ; } if ( value . trim ( ) . length ( ) == 0 ) { value = "" ; } if ( trimLeading ) { char [ ] current = value . toCharArray ( ) ; StringBuffer b = new StringBuffer ( current . length ) ; boolean startOfLine = true ; int pos = 0 ; while ( pos < current . length ) { char ch = current [ pos ++ ] ; if ( startOfLine ) { if ( ch == ' ' || ch == '\t' ) { continue ; } startOfLine = false ; } b . append ( ch ) ; if ( ch == '\n' || ch == '\r' ) { startOfLine = true ; } } value = b . toString ( ) ; } if ( trim ) { value = value . trim ( ) ; } return value ; } } private class MultiReader extends Reader { private int pos = 0 ; private Reader reader = null ; private int lastPos = 0 ; private char [ ] lastChars = new char [ eolString . length ( ) ] ; private boolean needAddSeparator = false ; private Reader getReader ( ) throws IOException { if ( reader == null ) { if ( encoding == null ) { reader = new BufferedReader ( new FileReader ( ( File ) sourceFiles . elementAt ( pos ) ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( ( File ) sourceFiles . elementAt ( pos ) ) , encoding ) ) ; } for ( int i = 0 ; i < lastChars . length ; ++ i ) { lastChars [ i ] = 0 ; } } return reader ; } public int read ( ) throws IOException { if ( needAddSeparator ) { int ret = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; } return ret ; } while ( pos < sourceFiles . size ( ) ) { int ch = getReader ( ) . read ( ) ; if ( ch == - 1 ) { reader . close ( ) ; reader = null ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } } else { addLastChar ( ( char ) ch ) ; return ch ; } pos ++ ; } return - 1 ; } public int read ( char [ ] cbuf , int off , int len ) throws IOException { int amountRead = 0 ; while ( pos < sourceFiles . size ( ) || ( needAddSeparator ) ) { if ( needAddSeparator ) { cbuf [ off ] = eolString . charAt ( lastPos ++ ) ; if ( lastPos >= eolString . length ( ) ) { lastPos = 0 ; needAddSeparator = false ; pos ++ ; } len -- ; off ++ ; amountRead ++ ; if ( len == 0 ) { return amountRead ; } continue ; } int nRead = getReader ( ) . read ( cbuf , off , len ) ; if ( nRead == - 1 || nRead == 0 ) { reader . close ( ) ; reader = null ; if ( fixLastLine && isMissingEndOfLine ( ) ) { needAddSeparator = true ; lastPos = 0 ; } else { pos ++ ; } } else { if ( fixLastLine ) { for ( int i = nRead ; i > ( nRead - lastChars . length ) ; -- i ) { if ( i < 0 ) { break ; } addLastChar ( cbuf [ off + i - 1 ] ) ; } } len -= nRead ; off += nRead ; amountRead += nRead ; if ( len == 0 ) { return amountRead ; } } } if ( amountRead == 0 ) { return - 1 ; } else { return amountRead ; } } public void close ( ) throws IOException { if ( reader != null ) { reader . close ( ) ; } } private void addLastChar ( char ch ) { for ( int i = lastChars . length - 2 ; i >= 0 ; -- i ) { lastChars [ i ] = lastChars [ i + 1 ] ; } lastChars [ lastChars . length - 1 ] = ch ; } private boolean isMissingEndOfLine ( ) { for ( int i = 0 ; i < lastChars . length ; ++ i ) { if ( lastChars [ i ] != eolString . charAt ( i ) ) { return true ; } } return false ; } } } 	0	['28', '3', '0', '18', '94', '220', '2', '18', '18', '0.877314815', '769', '1', '3', '0.587301587', '0.119047619', '1', '1', '25.89285714', '22', '2.7143', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '12', '15', '13', '9', '4', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import java . net . URL ; public class WhichResource extends Task { private Path classpath ; private String classname ; private String resource ; private String property ; public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } private void validate ( ) { int setcount = 0 ; if ( classname != null ) { setcount ++ ; } if ( resource != null ) { setcount ++ ; } if ( setcount == 0 ) { throw new BuildException ( "One of classname or resource must be specified" ) ; } if ( setcount > 1 ) { throw new BuildException ( "Only one of classname or resource can be specified" ) ; } if ( property == null ) { throw new BuildException ( "No property defined" ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( classpath != null ) { getProject ( ) . log ( "using user supplied classpath: " + classpath , Project . MSG_DEBUG ) ; classpath = classpath . concatSystemClasspath ( "ignore" ) ; } else { classpath = new Path ( getProject ( ) ) ; classpath = classpath . concatSystemClasspath ( "only" ) ; getProject ( ) . log ( "using system classpath: " + classpath , Project . MSG_DEBUG ) ; } AntClassLoader loader ; loader = new AntClassLoader ( getProject ( ) . getCoreLoader ( ) , getProject ( ) , classpath , false ) ; String location = null ; if ( classname != null ) { classname = classname . replace ( '.' , '/' ) ; resource = "/" + classname + ".class" ; } else { if ( ! resource . startsWith ( "/" ) ) { resource = "/" + resource ; } } log ( "Searching for " + resource , Project . MSG_VERBOSE ) ; URL url ; url = loader . getResource ( resource ) ; if ( url != null ) { location = url . toExternalForm ( ) ; getProject ( ) . setNewProperty ( property , location ) ; } } public void setResource ( String resource ) { this . resource = resource ; } public void setClass ( String classname ) { this . classname = classname ; } public void setProperty ( String property ) { this . property = property ; } } 	0	['8', '3', '0', '6', '28', '8', '0', '6', '7', '0.714285714', '221', '1', '1', '0.840909091', '0.5', '2', '2', '26.125', '6', '1.75', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . mail . MailMessage ; class PlainMailer extends Mailer { public void send ( ) { try { MailMessage mailMessage = new MailMessage ( host , port ) ; mailMessage . from ( from . toString ( ) ) ; Enumeration e ; e = replyToList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . replyto ( e . nextElement ( ) . toString ( ) ) ; } e = toList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . to ( e . nextElement ( ) . toString ( ) ) ; } e = ccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . cc ( e . nextElement ( ) . toString ( ) ) ; } e = bccList . elements ( ) ; while ( e . hasMoreElements ( ) ) { mailMessage . bcc ( e . nextElement ( ) . toString ( ) ) ; } if ( subject != null ) { mailMessage . setSubject ( subject ) ; } mailMessage . setHeader ( "Date" , getDate ( ) ) ; if ( message . getCharset ( ) != null ) { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) + "; charset=\"" + message . getCharset ( ) + "\"" ) ; } else { mailMessage . setHeader ( "Content-Type" , message . getMimeType ( ) ) ; } PrintStream out = mailMessage . getPrintStream ( ) ; message . print ( out ) ; e = files . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; attach ( file , out ) ; } mailMessage . sendAndClose ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "IO error sending mail" , ioe ) ; } } protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } if ( includeFileNames ) { out . println ( ) ; String filename = file . getName ( ) ; int filenamelength = filename . length ( ) ; out . println ( filename ) ; for ( int star = 0 ; star < filenamelength ; star ++ ) { out . print ( '=' ) ; } out . println ( ) ; } int length ; final int maxBuf = 1024 ; byte [ ] buf = new byte [ maxBuf ] ; FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr , buf . length ) ; while ( ( length = in . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , length ) ; } } finally { finstr . close ( ) ; } } } 	0	['3', '2', '1', '7', '40', '3', '2', '5', '1', '2', '237', '0', '0', '0.9', '0.555555556', '1', '1', '78', '8', '3', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; import java . io . PrintWriter ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String message ) { super ( message ) ; } public BuildException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String message , Location location ) { super ( message ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public Throwable getCause ( ) { return getException ( ) ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['15', '4', '0', '243', '27', '0', '242', '1', '15', '0.392857143', '157', '1', '1', '0.619047619', '0.322222222', '1', '3', '9.333333333', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . StringUtils ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '3', '30', '0', '0', '3', '5', '0.6', '1270', '1', '0', '0.880952381', '0.555555556', '1', '1', '210', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; public class GZip extends Pack { protected void pack ( ) { GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; zipFile ( source , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['2', '4', '0', '4', '13', '1', '0', '4', '1', '2', '56', '0', '0', '0.980392157', '1', '1', '2', '27', '4', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . Checksum ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase extends ProjectComponent { private Vector conditions = new Vector ( ) ; protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return conditions . elements ( ) ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addChecksum ( Checksum c ) { conditions . addElement ( c ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } public void addIsSet ( IsSet i ) { conditions . addElement ( i ) ; } public void addHttp ( Http h ) { conditions . addElement ( h ) ; } public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } public void addFilesMatch ( FilesMatch test ) { conditions . addElement ( test ) ; } public void addContains ( Contains test ) { conditions . addElement ( test ) ; } public void addIsTrue ( IsTrue test ) { conditions . addElement ( test ) ; } public void addIsFalse ( IsFalse test ) { conditions . addElement ( test ) ; } public void addIsReference ( IsReference i ) { conditions . addElement ( i ) ; } public void add ( Condition c ) { conditions . addElement ( c ) ; } } 	0	['20', '2', '5', '20', '25', '0', '5', '18', '18', '0', '122', '1', '0', '0.321428571', '0.102777778', '0', '0', '5.05', '1', '0.95', '0']
package org . apache . tools . ant . util ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . substring ( 0 ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '145', '1', '1', '0', '0.9', '0', '0', '27.4', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0	['6', '1', '0', '3', '11', '1', '1', '2', '6', '0.7', '74', '1', '0', '0', '0.555555556', '0', '0', '10.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class LogOutputStream extends OutputStream { private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } public void flush ( ) { processBuffer ( ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } public int getMessageLevel ( ) { return level ; } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['9', '2', '2', '10', '18', '8', '9', '1', '6', '0.821428571', '160', '1', '1', '0.384615385', '0.377777778', '1', '1', '16', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class WaitFor extends ConditionBase { private long maxWaitMillis = 1000L * 60L * 3L ; private long maxWaitMultiplier = 1L ; private long checkEveryMillis = 500L ; private long checkEveryMultiplier = 1L ; private String timeoutProperty ; public void setMaxWait ( long time ) { maxWaitMillis = time ; } public void setMaxWaitUnit ( Unit unit ) { maxWaitMultiplier = unit . getMultiplier ( ) ; } public void setCheckEvery ( long time ) { checkEveryMillis = time ; } public void setCheckEveryUnit ( Unit unit ) { checkEveryMultiplier = unit . getMultiplier ( ) ; } public void setTimeoutProperty ( String p ) { timeoutProperty = p ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <waitfor>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into " + "<waitfor>" ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; long savedMaxWaitMillis = maxWaitMillis ; long savedCheckEveryMillis = checkEveryMillis ; try { maxWaitMillis *= maxWaitMultiplier ; checkEveryMillis *= checkEveryMultiplier ; long start = System . currentTimeMillis ( ) ; long end = start + maxWaitMillis ; while ( System . currentTimeMillis ( ) < end ) { if ( c . eval ( ) ) { return ; } try { Thread . sleep ( checkEveryMillis ) ; } catch ( InterruptedException e ) { } } if ( timeoutProperty != null ) { getProject ( ) . setNewProperty ( timeoutProperty , "true" ) ; } } finally { maxWaitMillis = savedMaxWaitMillis ; checkEveryMillis = savedCheckEveryMillis ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String [ ] units = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK } ; private Hashtable timeTable = new Hashtable ( ) ; public Unit ( ) { timeTable . put ( MILLISECOND , new Long ( 1L ) ) ; timeTable . put ( SECOND , new Long ( 1000L ) ) ; timeTable . put ( MINUTE , new Long ( 1000L * 60L ) ) ; timeTable . put ( HOUR , new Long ( 1000L * 60L * 60L ) ) ; timeTable . put ( DAY , new Long ( 1000L * 60L * 60L * 24L ) ) ; timeTable . put ( WEEK , new Long ( 1000L * 60L * 60L * 24L * 7L ) ) ; } public long getMultiplier ( ) { String key = getValue ( ) . toLowerCase ( ) ; Long l = ( Long ) timeTable . get ( key ) ; return l . longValue ( ) ; } public String [ ] getValues ( ) { return units ; } } } 	0	['7', '3', '0', '6', '18', '1', '0', '6', '7', '0.7', '139', '1', '0', '0.842105263', '0.428571429', '0', '0', '18.14285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ClasspathUtils ; public abstract class DefBase extends AntlibDefinition { private ClassLoader createdLoader ; private ClasspathUtils . Delegate cpDelegate ; public void setReverseLoader ( boolean reverseLoader ) { this . cpDelegate . setReverseLoader ( reverseLoader ) ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public Path getClasspath ( ) { return cpDelegate . getClasspath ( ) ; } public boolean isReverseLoader ( ) { return cpDelegate . isReverseLoader ( ) ; } public String getLoaderId ( ) { return cpDelegate . getClassLoadId ( ) ; } public String getClasspathId ( ) { return cpDelegate . getClassLoadId ( ) ; } public void setClasspath ( Path classpath ) { this . cpDelegate . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return this . cpDelegate . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { this . cpDelegate . setClasspathref ( r ) ; } public void setLoaderRef ( Reference r ) { this . cpDelegate . setLoaderRef ( r ) ; } protected ClassLoader createLoader ( ) { if ( getAntlibClassLoader ( ) != null ) { return getAntlibClassLoader ( ) ; } if ( createdLoader == null ) { createdLoader = this . cpDelegate . getClassLoader ( ) ; ( ( AntClassLoader ) createdLoader ) . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } return createdLoader ; } public void init ( ) throws BuildException { this . cpDelegate = ClasspathUtils . getDelegate ( this ) ; super . init ( ) ; } } 	0	['12', '4', '1', '11', '27', '0', '2', '9', '11', '0.545454545', '90', '1', '1', '0.788461538', '0.333333333', '0', '0', '6.333333333', '3', '1.0833', '0']
package org . apache . tools . zip ; public final class ZipLong implements Cloneable { private long value ; public ZipLong ( long value ) { this . value = value ; } public ZipLong ( byte [ ] bytes ) { this ( bytes , 0 ) ; } public ZipLong ( byte [ ] bytes , int offset ) { value = ( bytes [ offset + 3 ] << 24 ) & 0xFF000000L ; value += ( bytes [ offset + 2 ] << 16 ) & 0xFF0000 ; value += ( bytes [ offset + 1 ] << 8 ) & 0xFF00 ; value += ( bytes [ offset ] & 0xFF ) ; } public byte [ ] getBytes ( ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( ( value & 0xFF ) ) ; result [ 1 ] = ( byte ) ( ( value & 0xFF00 ) > > 8 ) ; result [ 2 ] = ( byte ) ( ( value & 0xFF0000 ) > > 16 ) ; result [ 3 ] = ( byte ) ( ( value & 0xFF000000l ) > > 24 ) ; return result ; } public long getValue ( ) { return value ; } public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof ZipLong ) ) { return false ; } return value == ( ( ZipLong ) o ) . getValue ( ) ; } public int hashCode ( ) { return ( int ) value ; } } 	0	['7', '1', '0', '3', '8', '0', '3', '0', '7', '0', '147', '1', '0', '0', '0.342857143', '1', '1', '19.85714286', '4', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; public interface ChainableReader { Reader chain ( Reader rdr ) ; } 	0	['1', '1', '0', '19', '1', '0', '19', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; java . net . Socket s = null ; try { s = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } finally { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ioe ) { } } } return true ; } } 	0	['4', '2', '0', '4', '13', '0', '1', '3', '4', '0.333333333', '89', '1', '0', '0.75', '0.5', '0', '0', '20.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . email ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . DateUtils ; public abstract class Mailer { protected String host = null ; protected int port = - 1 ; protected String user = null ; protected String password = null ; protected boolean SSL = false ; protected Message message ; protected EmailAddress from ; protected Vector replyToList = null ; protected Vector toList = null ; protected Vector ccList = null ; protected Vector bccList = null ; protected Vector files = null ; protected String subject = null ; protected Task task ; protected boolean includeFileNames = false ; public void setHost ( String host ) { this . host = host ; } public void setPort ( int port ) { this . port = port ; } public void setUser ( String user ) { this . user = user ; } public void setPassword ( String password ) { this . password = password ; } public void setSSL ( boolean SSL ) { this . SSL = SSL ; } public void setMessage ( Message m ) { this . message = m ; } public void setFrom ( EmailAddress from ) { this . from = from ; } public void setReplyToList ( Vector list ) { this . replyToList = list ; } public void setToList ( Vector list ) { this . toList = list ; } public void setCcList ( Vector list ) { this . ccList = list ; } public void setBccList ( Vector list ) { this . bccList = list ; } public void setFiles ( Vector files ) { this . files = files ; } public void setSubject ( String subject ) { this . subject = subject ; } public void setTask ( Task task ) { this . task = task ; } public void setIncludeFileNames ( boolean b ) { this . includeFileNames = b ; } public abstract void send ( ) throws BuildException ; protected final String getDate ( ) { return DateUtils . getDateForHeader ( ) ; } } 	0	['18', '1', '1', '8', '20', '129', '3', '5', '17', '0.952941176', '134', '1', '3', '0', '0.229166667', '0', '0', '5.611111111', '1', '0.9444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . MergingMapper ; import org . apache . tools . ant . util . SourceFileScanner ; public class UpToDate extends Task implements Condition { private String _property ; private String _value ; private File _sourceFile ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setValue ( String value ) { _value = value ; } private String getValue ( ) { return ( _value != null ) ? _value : "true" ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void setSrcfile ( File file ) { _sourceFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public boolean eval ( ) { if ( sourceFileSets . size ( ) == 0 && _sourceFile == null ) { throw new BuildException ( "At least one srcfile or a nested " + "<srcfiles> element must be set." ) ; } if ( sourceFileSets . size ( ) > 0 && _sourceFile != null ) { throw new BuildException ( "Cannot specify both the srcfile " + "attribute and a nested <srcfiles> " + "element." ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested " + "mapper element must be set." ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) { log ( "The targetfile \"" + _targetFile . getAbsolutePath ( ) + "\" does not exist." , Project . MSG_VERBOSE ) ; return false ; } if ( _sourceFile != null && ! _sourceFile . exists ( ) ) { throw new BuildException ( _sourceFile . getAbsolutePath ( ) + " not found." ) ; } Enumeration e = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; upToDate = upToDate && scanDir ( fs . getDir ( getProject ( ) ) , ds . getIncludedFiles ( ) ) ; } if ( _sourceFile != null ) { if ( mapperElement == null ) { upToDate = upToDate && ( _targetFile . lastModified ( ) >= _sourceFile . lastModified ( ) ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; upToDate = upToDate && ( sfs . restrict ( new String [ ] { _sourceFile . getAbsolutePath ( ) } , null , null , mapperElement . getImplementation ( ) ) . length == 0 ) ; } } return upToDate ; } public void execute ( ) throws BuildException { if ( _property == null ) { throw new BuildException ( "property attribute is required." , getLocation ( ) ) ; } boolean upToDate = eval ( ) ; if ( upToDate ) { this . getProject ( ) . setNewProperty ( _property , getValue ( ) ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up-to-date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files are up-to-date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; File dir = srcDir ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; dir = null ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , dir , mapper ) . length == 0 ; } } 	0	['11', '3', '0', '14', '39', '19', '1', '13', '9', '0.75', '332', '1', '1', '0.787234043', '0.327272727', '1', '1', '28.63636364', '21', '3', '0']
package org . apache . tools . ant . util ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; public class KeepAliveInputStream extends FilterInputStream { public KeepAliveInputStream ( InputStream in ) { super ( in ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '1', '3', '1', '1', '0', '2', '2', '7', '0', '0', '0.947368421', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public abstract class MappingSelector extends BaseSelector { protected File targetdir = null ; protected Mapper mapperElement = null ; protected FileNameMapper map = null ; protected int granularity = 0 ; public MappingSelector ( ) { granularity = ( int ) FileUtils . newFileUtils ( ) . getFileTimestampGranularity ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir . getName ( ) + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; boolean selected = selectionTest ( file , destfile ) ; return selected ; } protected abstract boolean selectionTest ( File srcfile , File destfile ) ; public void setGranularity ( int granularity ) { this . granularity = granularity ; } } 	0	['7', '4', '2', '10', '23', '3', '2', '8', '6', '0.666666667', '139', '1', '2', '0.853658537', '0.428571429', '1', '3', '18.28571429', '4', '1.7143', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class CvsTagEntry { String m_filename ; String m_prevRevision ; String m_revision ; public CvsTagEntry ( String filename ) { this ( filename , null , null ) ; } public CvsTagEntry ( String filename , String revision ) { this ( filename , revision , null ) ; } public CvsTagEntry ( String filename , String revision , String prevRevision ) { m_filename = filename ; m_revision = revision ; m_prevRevision = prevRevision ; } public String getFile ( ) { return m_filename ; } public String getRevision ( ) { return m_revision ; } public String getPreviousRevision ( ) { return m_prevRevision ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( m_filename ) ; if ( ( m_revision == null ) ) { buffer . append ( " was removed" ) ; if ( m_prevRevision != null ) { buffer . append ( "; previous revision was " ) . append ( m_prevRevision ) ; } } else if ( m_revision != null && m_prevRevision == null ) { buffer . append ( " is new; current revision is " ) . append ( m_revision ) ; } else if ( m_revision != null && m_prevRevision != null ) { buffer . append ( " has changed from " ) . append ( m_prevRevision ) . append ( " to " ) . append ( m_revision ) ; } return buffer . toString ( ) ; } } 	0	['7', '1', '0', '1', '11', '7', '1', '0', '7', '0.333333333', '105', '0', '0', '0', '0.714285714', '0', '0', '13.57142857', '7', '1.4286', '0']
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static final StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0	['3', '1', '0', '5', '19', '1', '0', '5', '2', '0.5', '89', '1', '0', '0', '0.5', '0', '0', '28.33333333', '1', '0.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public abstract class BaseSelector extends DataType implements FileSelector { private String errmsg = null ; public BaseSelector ( ) { } public void setError ( String msg ) { if ( errmsg == null ) { errmsg = msg ; } } public String getError ( ) { return errmsg ; } public void verifySettings ( ) { } public void validate ( ) { if ( getError ( ) == null ) { verifySettings ( ) ; } if ( getError ( ) != null ) { throw new BuildException ( errmsg ) ; } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; } 	0	['6', '3', '5', '18', '8', '3', '15', '3', '6', '0.4', '39', '1', '0', '0.857142857', '0.5', '0', '0', '5.333333333', '3', '1.3333', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class AndSelector extends BaseSelectorContainer { public AndSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{andselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; } } 	0	['3', '5', '0', '6', '14', '3', '5', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant ; import java . io . IOException ; import java . io . InputStream ; public class DemuxInputStream extends InputStream { private Project project ; public DemuxInputStream ( Project project ) { this . project = project ; } public int read ( ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; if ( project . demuxInput ( buffer , 0 , 1 ) == - 1 ) { return - 1 ; } return buffer [ 0 ] ; } public int read ( byte [ ] buffer , int offset , int length ) throws IOException { return project . demuxInput ( buffer , offset , length ) ; } } 	0	['3', '2', '0', '2', '5', '0', '1', '1', '3', '0', '34', '1', '1', '0.818181818', '0.5', '1', '2', '10', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; private int index = - 1 ; public abstract String [ ] getValues ( ) ; protected EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { int index = indexOfValue ( value ) ; if ( index == - 1 ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . index = index ; this . value = value ; } public final boolean containsValue ( String value ) { return ( indexOfValue ( value ) != - 1 ) ; } public final int indexOfValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return - 1 ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return i ; } } return - 1 ; } public final String getValue ( ) { return value ; } public final int getIndex ( ) { return index ; } public String toString ( ) { return getValue ( ) ; } } 	0	['8', '1', '33', '59', '14', '20', '58', '1', '7', '0.714285714', '87', '1', '0', '0', '0.6875', '0', '0', '9.625', '5', '1.5', '0']
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '2064', '0', '0', '0', '0', '0', '0', '2052', '0', '0', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public abstract class DataType extends ProjectComponent { protected String description ; protected Reference ref ; protected boolean checked = true ; public void setDescription ( final String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( final Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( final Stack stack , final Project project ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( project ) ; if ( o instanceof DataType ) { if ( stack . contains ( o ) ) { throw circularReference ( ) ; } else { stack . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stack , project ) ; stack . pop ( ) ; } } checked = true ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , getProject ( ) ) ; } Object o = ref . getReferencedObject ( getProject ( ) ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } else { return o ; } } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one " + "attribute when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements " + "when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular " + "reference." ) ; } protected boolean isChecked ( ) { return checked ; } protected void setChecked ( final boolean checked ) { this . checked = checked ; } protected Reference getRefid ( ) { return ref ; } protected void checkAttributesAllowed ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } protected void checkChildrenAllowed ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } } } 	0	['15', '2', '15', '24', '29', '59', '20', '4', '5', '0.714285714', '169', '1', '1', '0.391304348', '0.20952381', '0', '0', '10.06666667', '3', '1.2667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class PreSetDef extends AntlibDefinition implements TaskContainer { private UnknownElement nestedTask ; private String name ; public void setName ( String name ) { this . name = name ; } public void addTask ( Task nestedTask ) { if ( this . nestedTask != null ) { throw new BuildException ( "Only one nested element allowed" ) ; } if ( ! ( nestedTask instanceof UnknownElement ) ) { throw new BuildException ( "addTask called with a task that is not an unknown element" ) ; } this . nestedTask = ( UnknownElement ) nestedTask ; } public void execute ( ) { if ( nestedTask == null ) { throw new BuildException ( "Missing nested element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( nestedTask . getNamespace ( ) , nestedTask . getTag ( ) ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { throw new BuildException ( "Unable to find typedef " + componentName ) ; } PreSetDefinition newDef = new PreSetDefinition ( def , nestedTask ) ; newDef . setName ( name ) ; helper . addDataTypeDefinition ( newDef ) ; } public static class PreSetDefinition extends AntTypeDefinition { private AntTypeDefinition parent ; private UnknownElement element ; public PreSetDefinition ( AntTypeDefinition parent , UnknownElement el ) { if ( parent instanceof PreSetDefinition ) { PreSetDefinition p = ( PreSetDefinition ) parent ; el . applyPreSet ( p . element ) ; parent = p . parent ; } this . parent = parent ; this . element = el ; } public void setClass ( Class clazz ) { throw new BuildException ( "Not supported" ) ; } public void setClassName ( String className ) { throw new BuildException ( "Not supported" ) ; } public String getClassName ( ) { return parent . getClassName ( ) ; } public void setAdapterClass ( Class adapterClass ) { throw new BuildException ( "Not supported" ) ; } public void setAdaptToClass ( Class adaptToClass ) { throw new BuildException ( "Not supported" ) ; } public void setClassLoader ( ClassLoader classLoader ) { throw new BuildException ( "Not supported" ) ; } public ClassLoader getClassLoader ( ) { return parent . getClassLoader ( ) ; } public Class getExposedClass ( Project project ) { return parent . getExposedClass ( project ) ; } public Class getTypeClass ( Project project ) { return parent . getTypeClass ( project ) ; } public void checkClass ( Project project ) { parent . checkClass ( project ) ; } public Object createObject ( Project project ) { Object o = parent . create ( project ) ; if ( o == null ) { return null ; } return o ; } public UnknownElement getPreSets ( ) { return element ; } public Object create ( Project project ) { return this ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( other . getClass ( ) != getClass ( ) ) { return false ; } PreSetDefinition otherDef = ( PreSetDefinition ) other ; if ( ! parent . sameDefinition ( otherDef . parent , project ) ) { return false ; } if ( ! element . similar ( otherDef . element ) ) { return false ; } return true ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( ! other . getClass ( ) . getName ( ) . equals ( getClass ( ) . getName ( ) ) ) { return false ; } PreSetDefinition otherDef = ( PreSetDefinition ) other ; if ( ! parent . similarDefinition ( otherDef . parent , project ) ) { return false ; } if ( ! element . similar ( otherDef . element ) ) { return false ; } return true ; } } } 	0	['4', '4', '0', '11', '19', '2', '0', '11', '4', '0.666666667', '102', '1', '1', '0.931818182', '0.5', '0', '0', '24', '4', '2', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . TimeZone ; class ChangeLogParser { private static final int GET_FILE = 1 ; private static final int GET_DATE = 2 ; private static final int GET_COMMENT = 3 ; private static final int GET_REVISION = 4 ; private static final int GET_PREVIOUS_REV = 5 ; private static final SimpleDateFormat c_inputDate = new SimpleDateFormat ( "yyyy/MM/dd HH:mm:ss" ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; c_inputDate . setTimeZone ( utc ) ; } private String m_file ; private String m_date ; private String m_author ; private String m_comment ; private String m_revision ; private String m_previousRevision ; private int m_status = GET_FILE ; private final Hashtable m_entries = new Hashtable ( ) ; CVSEntry [ ] getEntrySetAsArray ( ) { final CVSEntry [ ] array = new CVSEntry [ m_entries . size ( ) ] ; Enumeration e = m_entries . elements ( ) ; int i = 0 ; while ( e . hasMoreElements ( ) ) { array [ i ++ ] = ( CVSEntry ) e . nextElement ( ) ; } return array ; } public void stdout ( final String line ) { switch ( m_status ) { case GET_FILE : reset ( ) ; processFile ( line ) ; break ; case GET_REVISION : processRevision ( line ) ; break ; case GET_DATE : processDate ( line ) ; break ; case GET_COMMENT : processComment ( line ) ; break ; case GET_PREVIOUS_REV : processGetPreviousRevision ( line ) ; break ; } } private void processComment ( final String line ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; if ( line . startsWith ( "======" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; saveEntry ( ) ; m_status = GET_FILE ; } else if ( line . startsWith ( "----------------------------" ) ) { final int end = m_comment . length ( ) - lineSeparator . length ( ) ; m_comment = m_comment . substring ( 0 , end ) ; m_status = GET_PREVIOUS_REV ; } else { m_comment += line + lineSeparator ; } } private void processFile ( final String line ) { if ( line . startsWith ( "Working file:" ) ) { m_file = line . substring ( 14 , line . length ( ) ) ; m_status = GET_REVISION ; } } private void processRevision ( final String line ) { if ( line . startsWith ( "revision" ) ) { m_revision = line . substring ( 9 ) ; m_status = GET_DATE ; } else if ( line . startsWith ( "======" ) ) { m_status = GET_FILE ; } } private void processDate ( final String line ) { if ( line . startsWith ( "date:" ) ) { m_date = line . substring ( 6 , 25 ) ; String lineData = line . substring ( line . indexOf ( ";" ) + 1 ) ; m_author = lineData . substring ( 10 , lineData . indexOf ( ";" ) ) ; m_status = GET_COMMENT ; m_comment = "" ; } } private void processGetPreviousRevision ( final String line ) { if ( ! line . startsWith ( "revision" ) ) { throw new IllegalStateException ( "Unexpected line from CVS: " + line ) ; } m_previousRevision = line . substring ( 9 ) ; saveEntry ( ) ; m_revision = m_previousRevision ; m_status = GET_DATE ; } private void saveEntry ( ) { final String entryKey = m_date + m_author + m_comment ; CVSEntry entry ; if ( ! m_entries . containsKey ( entryKey ) ) { entry = new CVSEntry ( parseDate ( m_date ) , m_author , m_comment ) ; m_entries . put ( entryKey , entry ) ; } else { entry = ( CVSEntry ) m_entries . get ( entryKey ) ; } entry . addFile ( m_file , m_revision , m_previousRevision ) ; } private Date parseDate ( final String date ) { try { return c_inputDate . parse ( date ) ; } catch ( ParseException e ) { return null ; } } private void reset ( ) { m_file = null ; m_date = null ; m_author = null ; m_comment = null ; m_revision = null ; m_previousRevision = null ; } } 	0	['12', '1', '0', '4', '37', '0', '3', '1', '1', '0.766233766', '340', '1', '0', '0', '0.818181818', '0', '0', '26.16666667', '3', '1.6667', '0']
package org . apache . tools . ant . util . regexp ; public class RegexpUtil { public static final boolean hasFlag ( int options , int flag ) { return ( ( options & flag ) > 0 ) ; } public static final int removeFlag ( int options , int flag ) { return ( options & ( 0xFFFFFFFF - flag ) ) ; } } 	0	['3', '1', '0', '0', '4', '3', '0', '0', '3', '2', '20', '0', '0', '0', '0.5', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . tools . ant . types . resolver ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . ResourceLocation ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogManager ; import org . apache . xml . resolver . tools . CatalogResolver ; public class ApacheCatalogResolver extends CatalogResolver { private XMLCatalog xmlCatalog = null ; static { CatalogManager . getStaticManager ( ) . setIgnoreMissingProperties ( true ) ; System . getProperties ( ) . put ( "xml.catalog.className" , ApacheCatalog . class . getName ( ) ) ; CatalogManager . getStaticManager ( ) . setUseStaticCatalog ( false ) ; } public void setXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog = xmlCatalog ; } public void parseCatalog ( String file ) { Catalog _catalog = getCatalog ( ) ; if ( ! ( _catalog instanceof ApacheCatalog ) ) { throw new BuildException ( "Wrong catalog type found: " + _catalog . getClass ( ) . getName ( ) ) ; } ApacheCatalog catalog = ( ApacheCatalog ) _catalog ; catalog . setResolver ( this ) ; try { catalog . parseCatalog ( file ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( ex ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } public void addPublicEntry ( String publicid , String systemid , URL base ) { ResourceLocation dtd = new ResourceLocation ( ) ; dtd . setBase ( base ) ; dtd . setPublicId ( publicid ) ; dtd . setLocation ( systemid ) ; xmlCatalog . addDTD ( dtd ) ; } public void addURIEntry ( String uri , String altURI , URL base ) { ResourceLocation entity = new ResourceLocation ( ) ; entity . setBase ( base ) ; entity . setPublicId ( uri ) ; entity . setLocation ( altURI ) ; xmlCatalog . addEntity ( entity ) ; } } 	0	['7', '2', '0', '7', '32', '9', '1', '7', '5', '0.75', '128', '0.5', '1', '0.545454545', '0.5', '0', '0', '17', '2', '0.8571', '0']
package org . apache . tools . ant . filters ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public abstract class BaseFilterReader extends FilterReader { private static final int BUFFER_SIZE = 8192 ; private boolean initialized = false ; private Project project = null ; public BaseFilterReader ( ) { super ( new StringReader ( new String ( ) ) ) ; try { close ( ) ; } catch ( IOException ioe ) { } } public BaseFilterReader ( final Reader in ) { super ( in ) ; } public final int read ( final char [ ] cbuf , final int off , final int len ) throws IOException { for ( int i = 0 ; i < len ; i ++ ) { final int ch = read ( ) ; if ( ch == - 1 ) { if ( i == 0 ) { return - 1 ; } else { return i ; } } cbuf [ off + i ] = ( char ) ch ; } return len ; } public final long skip ( final long n ) throws IOException , IllegalArgumentException { if ( n < 0L ) { throw new IllegalArgumentException ( "skip value is negative" ) ; } for ( long i = 0 ; i < n ; i ++ ) { if ( read ( ) == - 1 ) { return i ; } } return n ; } protected final void setInitialized ( final boolean initialized ) { this . initialized = initialized ; } protected final boolean getInitialized ( ) { return initialized ; } public final void setProject ( final Project project ) { this . project = project ; } protected final Project getProject ( ) { return project ; } protected final String readLine ( ) throws IOException { int ch = in . read ( ) ; if ( ch == - 1 ) { return null ; } StringBuffer line = new StringBuffer ( ) ; while ( ch != - 1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n' ) { break ; } ch = in . read ( ) ; } return line . toString ( ) ; } protected final String readFully ( ) throws IOException { return FileUtils . readFully ( in , BUFFER_SIZE ) ; } } 	0	['10', '3', '6', '20', '21', '23', '18', '2', '5', '0.814814815', '151', '1', '1', '0.692307692', '0.228571429', '1', '2', '13.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . rmi . Remote ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapter ; import org . apache . tools . ant . taskdefs . rmic . RmicAdapterFactory ; import org . apache . tools . ant . types . FilterSetCollection ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; public class Rmic extends MatchingTask { private static final String FAIL_MSG = "Rmic failed; see the compiler error output for details." ; private File baseDir ; private String classname ; private File sourceBase ; private String stubVersion ; private Path compileClasspath ; private Path extdirs ; private boolean verify = false ; private boolean filtering = false ; private boolean iiop = false ; private String iiopopts ; private boolean idl = false ; private String idlopts ; private boolean debug = false ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; private Vector compileList = new Vector ( ) ; private ClassLoader loader = null ; private FileUtils fileUtils = FileUtils . newFileUtils ( ) ; private FacadeTaskHelper facade ; public Rmic ( ) { try { Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; facade = new FacadeTaskHelper ( "kaffe" ) ; } catch ( ClassNotFoundException cnfe ) { facade = new FacadeTaskHelper ( "sun" ) ; } } public void setBase ( File base ) { this . baseDir = base ; } public File getBase ( ) { return this . baseDir ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setSourceBase ( File sourceBase ) { this . sourceBase = sourceBase ; } public File getSourceBase ( ) { return sourceBase ; } public void setStubVersion ( String stubVersion ) { this . stubVersion = stubVersion ; } public String getStubVersion ( ) { return stubVersion ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public boolean getFiltering ( ) { return filtering ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return compileClasspath ; } public void setVerify ( boolean verify ) { this . verify = verify ; } public boolean getVerify ( ) { return verify ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public boolean getIiop ( ) { return iiop ; } public void setIiopopts ( String iiopopts ) { this . iiopopts = iiopopts ; } public String getIiopopts ( ) { return iiopopts ; } public void setIdl ( boolean idl ) { this . idl = idl ; } public boolean getIdl ( ) { return idl ; } public void setIdlopts ( String idlopts ) { this . idlopts = idlopts ; } public String getIdlopts ( ) { return idlopts ; } public Vector getFileList ( ) { return compileList ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( getProject ( ) ) ; } return extdirs . createPath ( ) ; } public Path getExtdirs ( ) { return extdirs ; } public Vector getCompileList ( ) { return compileList ; } public void setCompiler ( String compiler ) { facade . setImplementation ( compiler ) ; } public String getCompiler ( ) { facade . setMagicValue ( getProject ( ) . getProperty ( "build.rmic" ) ) ; return facade . getImplementation ( ) ; } public ImplementationSpecificArgument createCompilerArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentCompilerArgs ( ) { getCompiler ( ) ; return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( baseDir == null ) { throw new BuildException ( "base attribute must be set!" , getLocation ( ) ) ; } if ( ! baseDir . exists ( ) ) { throw new BuildException ( "base does not exist!" , getLocation ( ) ) ; } if ( verify ) { log ( "Verify has been turned on." , Project . MSG_VERBOSE ) ; } RmicAdapter adapter = RmicAdapterFactory . getRmic ( getCompiler ( ) , this ) ; adapter . setRmic ( this ) ; Path classpath = adapter . getClasspath ( ) ; loader = getProject ( ) . createClassLoader ( classpath ) ; try { if ( classname == null ) { DirectoryScanner ds = this . getDirectoryScanner ( baseDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( baseDir , files , adapter . getMapper ( ) ) ; } else { scanDir ( baseDir , new String [ ] { classname . replace ( '.' , File . separatorChar ) + ".class" } , adapter . getMapper ( ) ) ; } int fileCount = compileList . size ( ) ; if ( fileCount > 0 ) { log ( "RMI Compiling " + fileCount + " class" + ( fileCount > 1 ? "es" : "" ) + " to " + baseDir , Project . MSG_INFO ) ; if ( ! adapter . execute ( ) ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } } if ( null != sourceBase && ! baseDir . equals ( sourceBase ) && fileCount > 0 ) { if ( idl ) { log ( "Cannot determine sourcefiles in idl mode, " , Project . MSG_WARN ) ; log ( "sourcebase attribute will be ignored." , Project . MSG_WARN ) ; } else { for ( int j = 0 ; j < fileCount ; j ++ ) { moveGeneratedFile ( baseDir , sourceBase , ( String ) compileList . elementAt ( j ) , adapter ) ; } } } } finally { compileList . removeAllElements ( ) ; } } private void moveGeneratedFile ( File baseDir , File sourceBaseFile , String classname , RmicAdapter adapter ) throws BuildException { String classFileName = classname . replace ( '.' , File . separatorChar ) + ".class" ; String [ ] generatedFiles = adapter . getMapper ( ) . mapFileName ( classFileName ) ; for ( int i = 0 ; i < generatedFiles . length ; i ++ ) { final String generatedFile = generatedFiles [ i ] ; if ( ! generatedFile . endsWith ( ".class" ) ) { continue ; } final int pos = generatedFile . length ( ) - ".class" . length ( ) ; String sourceFileName = generatedFile . substring ( 0 , pos ) + ".java" ; File oldFile = new File ( baseDir , sourceFileName ) ; if ( ! oldFile . exists ( ) ) { continue ; } File newFile = new File ( sourceBaseFile , sourceFileName ) ; try { if ( filtering ) { fileUtils . copyFile ( oldFile , newFile , new FilterSetCollection ( getProject ( ) . getGlobalFilterSet ( ) ) ) ; } else { fileUtils . copyFile ( oldFile , newFile ) ; } oldFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + oldFile + " to " + newFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } protected void scanDir ( File baseDir , String [ ] files , FileNameMapper mapper ) { String [ ] newFiles = files ; if ( idl ) { log ( "will leave uptodate test to rmic implementation in idl mode." , Project . MSG_VERBOSE ) ; } else if ( iiop && iiopopts != null && iiopopts . indexOf ( "-always" ) > - 1 ) { log ( "no uptodate test as -always option has been specified" , Project . MSG_VERBOSE ) ; } else { SourceFileScanner sfs = new SourceFileScanner ( this ) ; newFiles = sfs . restrict ( files , baseDir , baseDir , mapper ) ; } for ( int i = 0 ; i < newFiles . length ; i ++ ) { String classname = newFiles [ i ] . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; compileList . addElement ( classname ) ; } } public boolean isValidRmiRemote ( String classname ) { try { Class testClass = loader . loadClass ( classname ) ; if ( testClass . isInterface ( ) && ! iiop && ! idl ) { return false ; } return isValidRmiRemote ( testClass ) ; } catch ( ClassNotFoundException e ) { log ( "Unable to verify class " + classname + ". It could not be found." , Project . MSG_WARN ) ; } catch ( NoClassDefFoundError e ) { log ( "Unable to verify class " + classname + ". It is not defined." , Project . MSG_WARN ) ; } catch ( Throwable t ) { log ( "Unable to verify class " + classname + ". Loading caused Exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } return false ; } public Class getRemoteInterface ( Class testClass ) { if ( Remote . class . isAssignableFrom ( testClass ) ) { Class [ ] interfaces = testClass . getInterfaces ( ) ; if ( interfaces != null ) { for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( Remote . class . isAssignableFrom ( interfaces [ i ] ) ) { return interfaces [ i ] ; } } } } return null ; } private boolean isValidRmiRemote ( Class testClass ) { return getRemoteInterface ( testClass ) != null ; } public ClassLoader getLoader ( ) { return loader ; } public class ImplementationSpecificArgument extends org . apache . tools . ant . util . facade . ImplementationSpecificArgument { public void setCompiler ( String impl ) { super . setImplementation ( impl ) ; } } } 	0	['48', '4', '0', '25', '109', '964', '7', '20', '44', '0.946301925', '819', '0.952380952', '4', '0.624', '0.154166667', '3', '3', '15.625', '7', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Task ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { System . err . println ( "As of Ant 1.2 released in October 2000, the " + "TaskOutputStream class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '10', '0', '0', '1', '1', '0', '67', '1', '1', '0.714285714', '0.666666667', '1', '1', '20.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . util . StringUtils ; public abstract class AbstractCvsTask extends Task { public static final int DEFAULT_COMPRESSION_LEVEL = 3 ; private static final int MAXIMUM_COMRESSION_LEVEL = 9 ; private Commandline cmd = new Commandline ( ) ; private Vector vecCommandlines = new Vector ( ) ; private String cvsRoot ; private String cvsRsh ; private String cvsPackage ; private static final String DEFAULT_COMMAND = "checkout" ; private String command = null ; private boolean quiet = false ; private boolean reallyquiet = false ; private int compression = 0 ; private boolean noexec = false ; private int port = 0 ; private File passFile = null ; private File dest ; private boolean append = false ; private File output ; private File error ; private boolean failOnError = false ; private ExecuteStreamHandler executeStreamHandler ; private OutputStream outputStream ; private OutputStream errorStream ; public AbstractCvsTask ( ) { super ( ) ; } public void setExecuteStreamHandler ( ExecuteStreamHandler handler ) { this . executeStreamHandler = handler ; } protected ExecuteStreamHandler getExecuteStreamHandler ( ) { if ( this . executeStreamHandler == null ) { setExecuteStreamHandler ( new PumpStreamHandler ( getOutputStream ( ) , getErrorStream ( ) ) ) ; } return this . executeStreamHandler ; } protected void setOutputStream ( OutputStream outputStream ) { this . outputStream = outputStream ; } protected OutputStream getOutputStream ( ) { if ( this . outputStream == null ) { if ( output != null ) { try { setOutputStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setOutputStream ( new LogOutputStream ( this , Project . MSG_INFO ) ) ; } } return this . outputStream ; } protected void setErrorStream ( OutputStream errorStream ) { this . errorStream = errorStream ; } protected OutputStream getErrorStream ( ) { if ( this . errorStream == null ) { if ( error != null ) { try { setErrorStream ( new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error . getPath ( ) , append ) ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } else { setErrorStream ( new LogOutputStream ( this , Project . MSG_WARN ) ) ; } } return this . errorStream ; } protected void runCommand ( Commandline toExecute ) throws BuildException { Environment env = new Environment ( ) ; if ( port > 0 ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_CLIENT_PORT" ) ; var . setValue ( String . valueOf ( port ) ) ; env . addVariable ( var ) ; } if ( passFile == null ) { File defaultPassFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; if ( defaultPassFile . exists ( ) ) { this . setPassfile ( defaultPassFile ) ; } } if ( passFile != null ) { if ( passFile . isFile ( ) && passFile . canRead ( ) ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_PASSFILE" ) ; var . setValue ( String . valueOf ( passFile ) ) ; env . addVariable ( var ) ; log ( "Using cvs passfile: " + String . valueOf ( passFile ) , Project . MSG_INFO ) ; } else if ( ! passFile . canRead ( ) ) { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not readable" , Project . MSG_WARN ) ; } else { log ( "cvs passfile: " + String . valueOf ( passFile ) + " ignored as it is not a file" , Project . MSG_WARN ) ; } } if ( cvsRsh != null ) { Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "CVS_RSH" ) ; var . setValue ( String . valueOf ( cvsRsh ) ) ; env . addVariable ( var ) ; } Execute exe = new Execute ( getExecuteStreamHandler ( ) , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( dest == null ) { dest = getProject ( ) . getBaseDir ( ) ; } if ( ! dest . exists ( ) ) { dest . mkdirs ( ) ; } exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; exe . setEnvironment ( env . getVariables ( ) ) ; try { String actualCommandLine = executeToString ( exe ) ; log ( actualCommandLine , Project . MSG_VERBOSE ) ; int retCode = exe . execute ( ) ; log ( "retCode=" + retCode , Project . MSG_DEBUG ) ; if ( failOnError && Execute . isFailure ( retCode ) ) { throw new BuildException ( "cvs exited with error code " + retCode + StringUtils . LINE_SEP + "Command line was [" + actualCommandLine + "]" , getLocation ( ) ) ; } } catch ( IOException e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( BuildException e ) { if ( failOnError ) { throw ( e ) ; } else { Throwable t = e . getException ( ) ; if ( t == null ) { t = e ; } log ( "Caught exception: " + t . getMessage ( ) , Project . MSG_WARN ) ; } } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e , getLocation ( ) ) ; } else { log ( "Caught exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { } } if ( errorStream != null ) { try { errorStream . close ( ) ; } catch ( IOException e ) { } } } } public void execute ( ) throws BuildException { String savedCommand = getCommand ( ) ; if ( this . getCommand ( ) == null && vecCommandlines . size ( ) == 0 ) { this . setCommand ( AbstractCvsTask . DEFAULT_COMMAND ) ; } String c = this . getCommand ( ) ; Commandline cloned = null ; if ( c != null ) { cloned = ( Commandline ) cmd . clone ( ) ; cloned . createArgument ( true ) . setLine ( c ) ; this . addConfiguredCommandline ( cloned , true ) ; } try { for ( int i = 0 ; i < vecCommandlines . size ( ) ; i ++ ) { this . runCommand ( ( Commandline ) vecCommandlines . elementAt ( i ) ) ; } } finally { if ( cloned != null ) { removeCommandline ( cloned ) ; } setCommand ( savedCommand ) ; } } private String executeToString ( Execute execute ) { StringBuffer stringBuffer = new StringBuffer ( Commandline . describeCommand ( execute . getCommandline ( ) ) ) ; String newLine = StringUtils . LINE_SEP ; String [ ] variableArray = execute . getEnvironment ( ) ; if ( variableArray != null ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( newLine ) ; stringBuffer . append ( "environment:" ) ; stringBuffer . append ( newLine ) ; for ( int z = 0 ; z < variableArray . length ; z ++ ) { stringBuffer . append ( newLine ) ; stringBuffer . append ( "\t" ) ; stringBuffer . append ( variableArray [ z ] ) ; } } return stringBuffer . toString ( ) ; } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) { root = null ; } } this . cvsRoot = root ; } public String getCvsRoot ( ) { return this . cvsRoot ; } public void setCvsRsh ( String rsh ) { if ( rsh != null ) { if ( rsh . trim ( ) . equals ( "" ) ) { rsh = null ; } } this . cvsRsh = rsh ; } public String getCvsRsh ( ) { return this . cvsRsh ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return this . port ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public File getPassFile ( ) { return this . passFile ; } public void setDest ( File dest ) { this . dest = dest ; } public File getDest ( ) { return this . dest ; } public void setPackage ( String p ) { this . cvsPackage = p ; } public String getPackage ( ) { return this . cvsPackage ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-r" ) ; addCommandArgument ( p ) ; } } public void addCommandArgument ( String arg ) { this . addCommandArgument ( cmd , arg ) ; } public void addCommandArgument ( Commandline c , String arg ) { c . createArgument ( ) . setValue ( arg ) ; } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { addCommandArgument ( "-D" ) ; addCommandArgument ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public String getCommand ( ) { return this . command ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setReallyquiet ( boolean q ) { reallyquiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } public void setAppend ( boolean value ) { this . append = value ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } protected void configureCommandline ( Commandline c ) { if ( c == null ) { return ; } c . setExecutable ( "cvs" ) ; if ( cvsPackage != null ) { c . createArgument ( ) . setLine ( cvsPackage ) ; } if ( this . compression > 0 && this . compression <= MAXIMUM_COMRESSION_LEVEL ) { c . createArgument ( true ) . setValue ( "-z" + this . compression ) ; } if ( quiet && ! reallyquiet ) { c . createArgument ( true ) . setValue ( "-q" ) ; } if ( reallyquiet ) { c . createArgument ( true ) . setValue ( "-Q" ) ; } if ( noexec ) { c . createArgument ( true ) . setValue ( "-n" ) ; } if ( cvsRoot != null ) { c . createArgument ( true ) . setLine ( "-d" + cvsRoot ) ; } } protected void removeCommandline ( Commandline c ) { vecCommandlines . removeElement ( c ) ; } public void addConfiguredCommandline ( Commandline c ) { this . addConfiguredCommandline ( c , false ) ; } public void addConfiguredCommandline ( Commandline c , boolean insertAtStart ) { if ( c == null ) { return ; } this . configureCommandline ( c ) ; if ( insertAtStart ) { vecCommandlines . insertElementAt ( c , 0 ) ; } else { vecCommandlines . addElement ( c ) ; } } public void setCompressionLevel ( int level ) { this . compression = level ; } public void setCompression ( boolean usecomp ) { setCompressionLevel ( usecomp ? AbstractCvsTask . DEFAULT_COMPRESSION_LEVEL : 0 ) ; } } 	0	['41', '3', '2', '17', '105', '700', '2', '15', '32', '0.925', '988', '0.956521739', '2', '0.480519481', '0.195121951', '0', '0', '22.53658537', '10', '1.6341', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; public interface Tokenizer { String getToken ( Reader in ) throws IOException ; String getPostToken ( ) ; } 	0	['2', '1', '0', '5', '2', '1', '5', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public class AntTypeDefinition { private String name ; private Class clazz ; private Class adapterClass ; private Class adaptToClass ; private String className ; private ClassLoader classLoader ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setClass ( Class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } if ( classLoader == null ) { this . classLoader = clazz . getClassLoader ( ) ; } if ( className == null ) { this . className = clazz . getName ( ) ; } } public void setClassName ( String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public Class getExposedClass ( Project project ) { if ( adaptToClass != null ) { Class z = getTypeClass ( project ) ; if ( z == null ) { return null ; } if ( adaptToClass . isAssignableFrom ( z ) ) { return z ; } } if ( adapterClass != null ) { return adapterClass ; } return getTypeClass ( project ) ; } public Class getTypeClass ( Project project ) { if ( clazz != null ) { return clazz ; } try { if ( classLoader == null ) { clazz = Class . forName ( className ) ; } else { clazz = classLoader . loadClass ( className ) ; } } catch ( NoClassDefFoundError ncdfe ) { project . log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for type " + name , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { project . log ( "Could not load class (" + className + ") for type " + name , Project . MSG_DEBUG ) ; } return clazz ; } public Object create ( Project project ) { return icreate ( project ) ; } private Object icreate ( Project project ) { Class c = getTypeClass ( project ) ; if ( c == null ) { return null ; } Object o = createAndSet ( project , c ) ; if ( o == null || adapterClass == null ) { return o ; } if ( adaptToClass != null ) { if ( adaptToClass . isAssignableFrom ( o . getClass ( ) ) ) { return o ; } } TypeAdapter adapterObject = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapterObject == null ) { return null ; } adapterObject . setProxy ( o ) ; return adapterObject ; } public void checkClass ( Project project ) { if ( clazz == null ) { clazz = getTypeClass ( project ) ; if ( clazz == null ) { throw new BuildException ( "Unable to create class for " + getName ( ) ) ; } } if ( adapterClass != null ) { boolean needToCheck = true ; if ( adaptToClass != null && adaptToClass . isAssignableFrom ( clazz ) ) { needToCheck = false ; } if ( needToCheck ) { TypeAdapter adapter = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapter == null ) { throw new BuildException ( "Unable to create adapter object" ) ; } adapter . checkProxyClass ( clazz ) ; } } } private Object createAndSet ( Project project , Class c ) { try { java . lang . reflect . Constructor ctor = null ; boolean noArg = false ; try { ctor = c . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = c . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = null ; if ( noArg ) { o = ctor . newInstance ( new Object [ 0 ] ) ; } else { o = ctor . newInstance ( new Object [ ] { project } ) ; } project . setProjectReference ( o ) ; return o ; } catch ( java . lang . reflect . InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "Type " + name + ": A class needed by class " + c + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe ) ; } catch ( Throwable t ) { throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( other . getClass ( ) != this . getClass ( ) ) { return false ; } if ( ! ( other . getTypeClass ( project ) . equals ( getTypeClass ( project ) ) ) ) { return false ; } if ( ! other . getExposedClass ( project ) . equals ( getExposedClass ( project ) ) ) { return false ; } if ( other . adapterClass != adapterClass ) { return false ; } if ( other . adaptToClass != adaptToClass ) { return false ; } return true ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null ) { return false ; } if ( getClass ( ) != other . getClass ( ) ) { return false ; } if ( ! getClassName ( ) . equals ( other . getClassName ( ) ) ) { return false ; } if ( ! extractClassname ( adapterClass ) . equals ( extractClassname ( other . adapterClass ) ) ) { return false ; } if ( ! extractClassname ( adaptToClass ) . equals ( extractClassname ( other . adaptToClass ) ) ) { return false ; } ClassLoader oldLoader = other . getClassLoader ( ) ; ClassLoader newLoader = this . getClassLoader ( ) ; if ( oldLoader != null && newLoader != null && oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) { return true ; } else { return false ; } } private String extractClassname ( Class c ) { if ( c == null ) { return "<null>" ; } else { return c . getClass ( ) . getName ( ) ; } } } 	0	['20', '1', '2', '11', '45', '112', '7', '4', '16', '0.684210526', '543', '0.857142857', '0', '0', '0.316666667', '0', '0', '25.8', '11', '3', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; write ( root , wri , 0 , "  " ) ; wri . flush ( ) ; } public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( "]]>" ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( "&#x5d;&#x5d;&gt;" ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( "]]>" ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } } 	0	['8', '1', '0', '1', '42', '24', '1', '0', '7', '0.714285714', '485', '1', '0', '0', '0.346938776', '0', '0', '59.375', '11', '4', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { return newRegexpMatcher ( null ) ; } public RegexpMatcher newRegexpMatcher ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { testAvailability ( "java.util.regex.Matcher" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { testAvailability ( "org.apache.regexp.RE" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } protected void testAvailability ( String className ) throws BuildException { try { Class . forName ( className ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['5', '1', '1', '6', '12', '10', '3', '3', '3', '2', '86', '0', '0', '0', '0.533333333', '0', '0', '16.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { private String validargs = null ; private String message = "" ; private String addproperty = null ; private String defaultvalue = null ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; } public void setDefaultvalue ( String defaultvalue ) { this . defaultvalue = defaultvalue ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { if ( addproperty != null && getProject ( ) . getProperty ( addproperty ) != null ) { log ( "skipping " + getTaskName ( ) + " as property " + addproperty + " has already been set." ) ; return ; } InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } getProject ( ) . getInputHandler ( ) . handleInput ( request ) ; String value = request . getInput ( ) ; if ( ( value == null || value . trim ( ) . length ( ) == 0 ) && defaultvalue != null ) { value = defaultvalue ; } if ( addproperty != null && value != null ) { getProject ( ) . setNewProperty ( addproperty , value ) ; } } } 	0	['7', '3', '0', '8', '25', '0', '0', '8', '7', '0.625', '141', '1', '0', '0.860465116', '0.857142857', '1', '1', '18.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public class ContainsRegexpSelector extends BaseExtendSelector { private String userProvidedExpression = null ; private RegularExpression myRegExp = null ; private Regexp myExpression = null ; public static final String EXPRESSION_KEY = "expression" ; public ContainsRegexpSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsregexpselector expression: " ) ; buf . append ( userProvidedExpression ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setExpression ( String theexpression ) { this . userProvidedExpression = theexpression ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( EXPRESSION_KEY . equalsIgnoreCase ( paramname ) ) { setExpression ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( userProvidedExpression == null ) { setError ( "The expression attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { String teststr = null ; BufferedReader in = null ; validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } if ( myRegExp == null ) { myRegExp = new RegularExpression ( ) ; myRegExp . setPattern ( userProvidedExpression ) ; myExpression = myRegExp . getRegexp ( getProject ( ) ) ; } try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; teststr = in . readLine ( ) ; while ( teststr != null ) { if ( myExpression . matches ( teststr ) ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read file " + filename ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close file " + filename ) ; } } } } } 	0	['6', '5', '0', '14', '29', '0', '5', '9', '6', '0.7', '224', '0.75', '2', '0.88372093', '0.416666667', '1', '4', '35.66666667', '8', '2.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; public class Os implements Condition { private static final String OS_NAME = System . getProperty ( "os.name" ) . toLowerCase ( Locale . US ) ; private static final String OS_ARCH = System . getProperty ( "os.arch" ) . toLowerCase ( Locale . US ) ; private static final String OS_VERSION = System . getProperty ( "os.version" ) . toLowerCase ( Locale . US ) ; private static final String PATH_SEP = System . getProperty ( "path.separator" ) ; private String family ; private String name ; private String version ; private String arch ; public Os ( ) { } public Os ( String family ) { setFamily ( family ) ; } public void setFamily ( String f ) { family = f . toLowerCase ( Locale . US ) ; } public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setArch ( String arch ) { this . arch = arch . toLowerCase ( Locale . US ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( Locale . US ) ; } public boolean eval ( ) throws BuildException { return isOs ( family , name , arch , version ) ; } public static boolean isFamily ( String family ) { return isOs ( family , null , null , null ) ; } public static boolean isName ( String name ) { return isOs ( null , name , null , null ) ; } public static boolean isArch ( String arch ) { return isOs ( null , null , arch , null ) ; } public static boolean isVersion ( String version ) { return isOs ( null , null , null , version ) ; } public static boolean isOs ( String family , String name , String arch , String version ) { boolean retValue = false ; if ( family != null || name != null || arch != null || version != null ) { boolean isFamily = true ; boolean isName = true ; boolean isArch = true ; boolean isVersion = true ; if ( family != null ) { if ( family . equals ( "windows" ) ) { isFamily = OS_NAME . indexOf ( "windows" ) > - 1 ; } else if ( family . equals ( "os/2" ) ) { isFamily = OS_NAME . indexOf ( "os/2" ) > - 1 ; } else if ( family . equals ( "netware" ) ) { isFamily = OS_NAME . indexOf ( "netware" ) > - 1 ; } else if ( family . equals ( "dos" ) ) { isFamily = PATH_SEP . equals ( ";" ) && ! isFamily ( "netware" ) ; } else if ( family . equals ( "mac" ) ) { isFamily = OS_NAME . indexOf ( "mac" ) > - 1 ; } else if ( family . equals ( "tandem" ) ) { isFamily = OS_NAME . indexOf ( "nonstop_kernel" ) > - 1 ; } else if ( family . equals ( "unix" ) ) { isFamily = PATH_SEP . equals ( ":" ) && ! isFamily ( "openvms" ) && ( ! isFamily ( "mac" ) || OS_NAME . endsWith ( "x" ) ) ; } else if ( family . equals ( "win9x" ) ) { isFamily = isFamily ( "windows" ) && ( OS_NAME . indexOf ( "95" ) >= 0 || OS_NAME . indexOf ( "98" ) >= 0 || OS_NAME . indexOf ( "me" ) >= 0 || OS_NAME . indexOf ( "ce" ) >= 0 ) ; } else if ( family . equals ( "z/os" ) ) { isFamily = OS_NAME . indexOf ( "z/os" ) > - 1 || OS_NAME . indexOf ( "os/390" ) > - 1 ; } else if ( family . equals ( "os/400" ) ) { isFamily = OS_NAME . indexOf ( "os/400" ) > - 1 ; } else if ( family . equals ( "openvms" ) ) { isFamily = OS_NAME . indexOf ( "openvms" ) > - 1 ; } else { throw new BuildException ( "Don\'t know how to detect os family \"" + family + "\"" ) ; } } if ( name != null ) { isName = name . equals ( OS_NAME ) ; } if ( arch != null ) { isArch = arch . equals ( OS_ARCH ) ; } if ( version != null ) { isVersion = version . equals ( OS_VERSION ) ; } retValue = isFamily && isName && isArch && isVersion ; } return retValue ; } } 	0	['13', '1', '0', '14', '23', '68', '12', '2', '12', '0.697916667', '357', '1', '0', '0', '0.708333333', '0', '0', '25.84615385', '44', '4.0769', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public final class AntFilterReader extends DataType implements Cloneable { private String className ; private final Vector parameters = new Vector ( ) ; private Path classpath ; public final void setClassName ( final String className ) { this . className = className ; } public final String getClassName ( ) { return className ; } public final void addParam ( final Parameter param ) { parameters . addElement ( param ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public final Parameter [ ] getParams ( ) { Parameter [ ] params = new Parameter [ parameters . size ( ) ] ; parameters . copyInto ( params ) ; return params ; } public void setRefid ( Reference r ) throws BuildException { if ( ! parameters . isEmpty ( ) || className != null || classpath != null ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof AntFilterReader ) { AntFilterReader afr = ( AntFilterReader ) o ; setClassName ( afr . getClassName ( ) ) ; setClasspath ( afr . getClasspath ( ) ) ; Parameter [ ] p = afr . getParams ( ) ; if ( p != null ) { for ( int i = 0 ; i < p . length ; i ++ ) { addParam ( p [ i ] ) ; } } } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterReader" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['10', '3', '0', '9', '31', '15', '2', '7', '10', '0.666666667', '166', '1', '1', '0.769230769', '0.3', '1', '1', '15.3', '3', '1.4', '0']
package org . apache . tools . ant . taskdefs . rmic ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class KaffeRmic extends DefaultRmicAdapter { public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; try { Class c = Class . forName ( "kaffe.rmi.rmic.RMIC" ) ; Constructor cons = c . getConstructor ( new Class [ ] { String [ ] . class } ) ; Object rmic = cons . newInstance ( new Object [ ] { cmd . getArguments ( ) } ) ; Method doRmic = c . getMethod ( "run" , null ) ; Boolean ok = ( Boolean ) doRmic . invoke ( rmic , null ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use Kaffe rmic, as it is not " + "available.  A common solution is to " + "set the environment variable " + "JAVA_HOME or CLASSPATH." , getRmic ( ) . getLocation ( ) ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting Kaffe rmic: " , ex , getRmic ( ) . getLocation ( ) ) ; } } } } 	0	['3', '2', '0', '7', '19', '3', '1', '6', '2', '1', '93', '0', '0', '0.866666667', '0.5', '0', '0', '29.66666667', '1', '0.6667', '0']
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class SendEmail extends EmailTask { public void setMailport ( Integer value ) { setMailport ( value . intValue ( ) ) ; } } 	0	['2', '4', '0', '1', '5', '1', '0', '1', '2', '2', '10', '0', '0', '0.985507246', '0.75', '1', '1', '4', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . DirSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileList ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class PathConvert extends Task { private Path path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean onWindows = false ; private boolean setonempty = true ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; public PathConvert ( ) { onWindows = Os . isFamily ( "dos" ) ; } public class MapEntry { public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set " + "in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) : from ; if ( cmpElem . startsWith ( cmpFrom ) ) { int len = from . length ( ) ; if ( len >= elem . length ( ) ) { elem = to ; } else { elem = to + elem . substring ( len ) ; } } return elem ; } private String from = null ; private String to = null ; } public static class TargetOs extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "windows" , "unix" , "netware" , "os/2" , "tandem" } ; } } public Path createPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { TargetOs to = new TargetOs ( ) ; to . setValue ( target ) ; setTargetos ( to ) ; } public void setTargetos ( TargetOs target ) { targetOS = target . getValue ( ) ; targetWindows = ! targetOS . equals ( "unix" ) && ! targetOS . equals ( "tandem" ) ; } public void setSetonempty ( boolean setonempty ) { this . setonempty = setonempty ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) { throw noChildrenAllowed ( ) ; } refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { Path savedPath = path ; String savedPathSep = pathSep ; String savedDirSep = dirSep ; try { if ( isReference ( ) ) { path = new Path ( getProject ( ) ) . createPath ( ) ; Object obj = refid . getReferencedObject ( getProject ( ) ) ; if ( obj instanceof Path ) { path . setRefid ( refid ) ; } else if ( obj instanceof FileSet ) { FileSet fs = ( FileSet ) obj ; path . addFileset ( fs ) ; } else if ( obj instanceof DirSet ) { DirSet ds = ( DirSet ) obj ; path . addDirset ( ds ) ; } else if ( obj instanceof FileList ) { FileList fl = ( FileList ) obj ; path . addFilelist ( fl ) ; } else { throw new BuildException ( "'refid' does not refer to a " + "path, fileset, dirset, or " + "filelist." ) ; } } validateSetup ( ) ; String fromDirSep = onWindows ? "\\" : "/" ; StringBuffer rslt = new StringBuffer ( 100 ) ; String [ ] elems = path . list ( ) ; for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = elems [ i ] ; elem = mapElement ( elem ) ; if ( i != 0 ) { rslt . append ( pathSep ) ; } StringTokenizer stDirectory = new StringTokenizer ( elem , fromDirSep , true ) ; String token = null ; while ( stDirectory . hasMoreTokens ( ) ) { token = stDirectory . nextToken ( ) ; if ( fromDirSep . equals ( token ) ) { rslt . append ( dirSep ) ; } else { rslt . append ( token ) ; } } } String value = rslt . toString ( ) ; if ( setonempty ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } else { if ( rslt . length ( ) > 0 ) { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } finally { path = savedPath ; dirSep = savedDirSep ; pathSep = savedPathSep ; } } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } private void validateSetup ( ) throws BuildException { if ( path == null ) { throw new BuildException ( "You must specify a path to convert" ) ; } if ( property == null ) { throw new BuildException ( "You must specify a property" ) ; } if ( targetOS == null && pathSep == null && dirSep == null ) { throw new BuildException ( "You must specify at least one of " + "targetOS, dirSep, or pathSep" ) ; } String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested <path> " + "elements when using the refid attribute." ) ; } } 	0	['16', '3', '0', '13', '48', '58', '1', '13', '12', '0.786666667', '485', '1', '2', '0.711538462', '0.25', '2', '2', '28.6875', '4', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class LazyFileOutputStream extends OutputStream { private FileOutputStream fos ; private File file ; private boolean append ; private boolean opened = false ; private boolean closed = false ; public LazyFileOutputStream ( String name ) { this ( name , false ) ; } public LazyFileOutputStream ( String name , boolean append ) { this ( new File ( name ) , append ) ; } public LazyFileOutputStream ( File f ) { this ( f , false ) ; } public LazyFileOutputStream ( File file , boolean append ) { this . file = file ; this . append = append ; } public void open ( ) throws IOException { ensureOpened ( ) ; } public synchronized void close ( ) throws IOException { if ( opened ) { fos . close ( ) ; } closed = true ; } public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } public synchronized void write ( byte [ ] b , int offset , int len ) throws IOException { ensureOpened ( ) ; fos . write ( b , offset , len ) ; } public synchronized void write ( int b ) throws IOException { ensureOpened ( ) ; fos . write ( b ) ; } private synchronized void ensureOpened ( ) throws IOException { if ( closed ) { throw new IOException ( file + " has already been closed." ) ; } if ( ! opened ) { fos = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; opened = true ; } } } 	0	['10', '2', '0', '1', '22', '29', '1', '0', '9', '0.311111111', '117', '1', '0', '0.454545455', '0.333333333', '1', '1', '10.2', '1', '0.6', '0']
package org . apache . tools . ant ; public interface DynamicConfigurator { void setDynamicAttribute ( String name , String value ) throws BuildException ; Object createDynamicElement ( String name ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . types . Resource ; public final class SelectorUtils { private static SelectorUtils instance = new SelectorUtils ( ) ; private SelectorUtils ( ) { } public static SelectorUtils getInstance ( ) { return instance ; } public static boolean matchPatternStart ( String pattern , String str ) { return matchPatternStart ( pattern , str , true ) ; } public static boolean matchPatternStart ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } public static boolean matchPath ( String pattern , String str ) { return matchPath ( pattern , str , true ) ; } public static boolean matchPath ( String pattern , String str , boolean isCaseSensitive ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } String [ ] patDirs = tokenizePathAsArray ( pattern ) ; String [ ] strDirs = tokenizePathAsArray ( str ) ; int patIdxStart = 0 ; int patIdxEnd = patDirs . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . length - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxStart ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxStart ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { patDirs = null ; strDirs = null ; return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = patDirs [ patIdxEnd ] ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , strDirs [ strIdxEnd ] , isCaseSensitive ) ) { patDirs = null ; strDirs = null ; return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs [ i ] . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = patDirs [ patIdxStart + j + 1 ] ; String subStr = strDirs [ strIdxStart + i + j ] ; if ( ! match ( subPat , subStr , isCaseSensitive ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { patDirs = null ; strDirs = null ; return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs [ i ] . equals ( "**" ) ) { patDirs = null ; strDirs = null ; return false ; } } return true ; } public static boolean match ( String pattern , String str ) { return match ( pattern , str , true ) ; } public static boolean match ( String pattern , String str , boolean isCaseSensitive ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ i ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ i ] ) ) { return false ; } } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart ] ) ) { return false ; } } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxEnd ] ) { return false ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxEnd ] ) ) { return false ; } } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' ) { if ( isCaseSensitive && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } if ( ! isCaseSensitive && Character . toUpperCase ( ch ) != Character . toUpperCase ( strArr [ strIdxStart + i + j ] ) ) { continue strLoop ; } } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public static Vector tokenizePath ( String path ) { return tokenizePath ( path , File . separator ) ; } public static Vector tokenizePath ( String path , String separator ) { Vector ret = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( path , separator ) ; while ( st . hasMoreTokens ( ) ) { ret . addElement ( st . nextToken ( ) ) ; } return ret ; } private static String [ ] tokenizePathAsArray ( String path ) { char sep = File . separatorChar ; int start = 0 ; int len = path . length ( ) ; int count = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { count ++ ; } start = pos + 1 ; } } if ( len != start ) { count ++ ; } String [ ] l = new String [ count ] ; count = 0 ; start = 0 ; for ( int pos = 0 ; pos < len ; pos ++ ) { if ( path . charAt ( pos ) == sep ) { if ( pos != start ) { String tok = path . substring ( start , pos ) ; l [ count ++ ] = tok ; } start = pos + 1 ; } } if ( len != start ) { String tok = path . substring ( start ) ; l [ count ] = tok ; } return l ; } public static boolean isOutOfDate ( File src , File target , int granularity ) { if ( ! src . exists ( ) ) { return false ; } if ( ! target . exists ( ) ) { return true ; } if ( ( src . lastModified ( ) - granularity ) > target . lastModified ( ) ) { return true ; } return false ; } public static boolean isOutOfDate ( Resource src , Resource target , int granularity ) { if ( ! src . isExists ( ) ) { return false ; } if ( ! target . isExists ( ) ) { return true ; } if ( ( src . getLastModified ( ) - granularity ) > target . getLastModified ( ) ) { return true ; } return false ; } public static String removeWhitespace ( String input ) { StringBuffer result = new StringBuffer ( ) ; if ( input != null ) { StringTokenizer st = new StringTokenizer ( input ) ; while ( st . hasMoreTokens ( ) ) { result . append ( st . nextToken ( ) ) ; } } return result . toString ( ) ; } public static boolean hasWildcards ( String input ) { return ( input . indexOf ( '*' ) != - 1 || input . indexOf ( '?' ) != - 1 ) ; } public static String rtrimWildcardTokens ( String input ) { Vector v = tokenizePath ( input , File . separator ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int counter = 0 ; counter < v . size ( ) ; counter ++ ) { if ( hasWildcards ( ( String ) v . elementAt ( counter ) ) ) { break ; } if ( counter > 0 ) { sb . append ( File . separator ) ; } sb . append ( ( String ) v . elementAt ( counter ) ) ; } return sb . toString ( ) ; } } 	0	['17', '1', '0', '6', '42', '134', '5', '1', '14', '0.9375', '936', '1', '1', '0', '0.208333333', '0', '0', '54', '47', '6.8824', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class SizeSelector extends BaseExtendSelector { private long size = - 1 ; private long multiplier = 1 ; private long sizelimit = - 1 ; private int cmp = 2 ; public static final String SIZE_KEY = "value" ; public static final String UNITS_KEY = "units" ; public static final String WHEN_KEY = "when" ; public SizeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{sizeselector value: " ) ; buf . append ( sizelimit ) ; buf . append ( "compare: " ) ; if ( cmp == 0 ) { buf . append ( "less" ) ; } else if ( cmp == 1 ) { buf . append ( "more" ) ; } else { buf . append ( "equal" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setValue ( long size ) { this . size = size ; if ( ( multiplier != 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setUnits ( ByteUnits units ) { int i = units . getIndex ( ) ; multiplier = 0 ; if ( ( i > - 1 ) && ( i < 4 ) ) { multiplier = 1000 ; } else if ( ( i > 3 ) && ( i < 9 ) ) { multiplier = 1024 ; } else if ( ( i > 8 ) && ( i < 13 ) ) { multiplier = 1000000 ; } else if ( ( i > 12 ) && ( i < 18 ) ) { multiplier = 1048576 ; } else if ( ( i > 17 ) && ( i < 22 ) ) { multiplier = 1000000000L ; } else if ( ( i > 21 ) && ( i < 27 ) ) { multiplier = 1073741824L ; } else if ( ( i > 26 ) && ( i < 31 ) ) { multiplier = 1000000000000L ; } else if ( ( i > 30 ) && ( i < 36 ) ) { multiplier = 1099511627776L ; } if ( ( multiplier > 0 ) && ( size > - 1 ) ) { sizelimit = size * multiplier ; } } public void setWhen ( SizeComparisons cmp ) { this . cmp = cmp . getIndex ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( SIZE_KEY . equalsIgnoreCase ( paramname ) ) { try { setValue ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid size setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( UNITS_KEY . equalsIgnoreCase ( paramname ) ) { ByteUnits units = new ByteUnits ( ) ; units . setValue ( parameters [ i ] . getValue ( ) ) ; setUnits ( units ) ; } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { SizeComparisons cmp = new SizeComparisons ( ) ; cmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( cmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( size < 0 ) { setError ( "The value attribute is required, and must be positive" ) ; } else if ( multiplier < 1 ) { setError ( "Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti" ) ; } else if ( sizelimit < 0 ) { setError ( "Internal error: Code is not setting sizelimit correctly" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } if ( cmp == 0 ) { return ( file . length ( ) < sizelimit ) ; } else if ( cmp == 1 ) { return ( file . length ( ) > sizelimit ) ; } else { return ( file . length ( ) == sizelimit ) ; } } public static class ByteUnits extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "K" , "k" , "kilo" , "KILO" , "Ki" , "KI" , "ki" , "kibi" , "KIBI" , "M" , "m" , "mega" , "MEGA" , "Mi" , "MI" , "mi" , "mebi" , "MEBI" , "G" , "g" , "giga" , "GIGA" , "Gi" , "GI" , "gi" , "gibi" , "GIBI" , "T" , "t" , "tera" , "TERA" , "Ti" , "TI" , "ti" , "tebi" , "TEBI" } ; } } public static class SizeComparisons extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "less" , "more" , "equal" } ; } } } 	0	['8', '5', '0', '11', '28', '0', '5', '6', '8', '0.693877551', '366', '0.571428571', '0', '0.844444444', '0.25', '1', '4', '43.875', '19', '5.375', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; public class DefaultExcludes extends Task { private String add = "" ; private String remove = "" ; private boolean defaultrequested = false ; private boolean echo = false ; private int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( ! defaultrequested && add . equals ( "" ) && remove . equals ( "" ) && ! echo ) { throw new BuildException ( "<defaultexcludes> task must set " + "at least one attribute (echo=\"false\"" + " doesn't count since that is the default" ) ; } if ( defaultrequested ) { DirectoryScanner . resetDefaultExcludes ( ) ; } if ( ! add . equals ( "" ) ) { DirectoryScanner . addDefaultExclude ( add ) ; } if ( ! remove . equals ( "" ) ) { DirectoryScanner . removeDefaultExclude ( remove ) ; } if ( echo ) { StringBuffer message = new StringBuffer ( "Current Default Excludes:\n" ) ; String [ ] excludes = DirectoryScanner . getDefaultExcludes ( ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { message . append ( "  " + excludes [ i ] + "\n" ) ; } log ( message . toString ( ) , logLevel ) ; } } public void setDefault ( boolean def ) { defaultrequested = def ; } public void setAdd ( String add ) { this . add = add ; } public void setRemove ( String remove ) { this . remove = remove ; } public void setEcho ( boolean echo ) { this . echo = echo ; } } 	0	['6', '3', '0', '3', '18', '0', '0', '3', '6', '0.64', '128', '1', '0', '0.880952381', '0.555555556', '2', '2', '19.5', '1', '0.8333', '0']
package org . apache . tools . ant . util ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; public class LoaderUtils { public static void setContextClassLoader ( ClassLoader loader ) { Thread currentThread = Thread . currentThread ( ) ; currentThread . setContextClassLoader ( loader ) ; } public static ClassLoader getContextClassLoader ( ) { Thread currentThread = Thread . currentThread ( ) ; return currentThread . getContextClassLoader ( ) ; } public static boolean isContextLoaderAvailable ( ) { return true ; } private static File normalizeSource ( File source ) { if ( source != null ) { FileUtils fileUtils = FileUtils . newFileUtils ( ) ; try { source = fileUtils . normalize ( source . getAbsolutePath ( ) ) ; } catch ( BuildException e ) { } } return source ; } public static File getClassSource ( Class c ) { return normalizeSource ( Locator . getClassSource ( c ) ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = LoaderUtils . class . getClassLoader ( ) ; } return normalizeSource ( Locator . getResourceSource ( c , resource ) ) ; } } 	0	['8', '1', '0', '6', '21', '28', '3', '3', '6', '1', '70', '0', '0', '0', '0.175', '0', '0', '7.625', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ClasspathUtils ; import java . util . Locale ; public final class RmicAdapterFactory { public static final String ERROR_UNKNOWN_COMPILER = "Class not found: " ; public static final String ERROR_NOT_RMIC_ADAPTER = "Class of unexpected Type: " ; public static final String DEFAULT_COMPILER = "default" ; private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { String compiler = rmicType . toLowerCase ( Locale . ENGLISH ) ; if ( DEFAULT_COMPILER . equals ( compiler ) || compiler . length ( ) == 0 ) { compiler = KaffeRmic . isAvailable ( ) ? KaffeRmic . COMPILER_NAME : SunRmic . COMPILER_NAME ; } if ( SunRmic . COMPILER_NAME . equals ( compiler ) ) { return new SunRmic ( ) ; } else if ( KaffeRmic . COMPILER_NAME . equals ( compiler ) ) { return new KaffeRmic ( ) ; } else if ( WLRmic . COMPILER_NAME . equals ( compiler ) ) { return new WLRmic ( ) ; } else if ( ForkingSunRmic . COMPILER_NAME . equals ( compiler ) ) { return new ForkingSunRmic ( ) ; } else if ( XNewRmic . COMPILER_NAME . equals ( compiler ) ) { return new XNewRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { return ( RmicAdapter ) ClasspathUtils . newInstance ( className , RmicAdapterFactory . class . getClassLoader ( ) , RmicAdapter . class ) ; } } 	0	['3', '1', '0', '10', '18', '3', '1', '9', '1', '1.1', '106', '0', '0', '0', '0.444444444', '0', '0', '32.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . oro . text . perl . Perl5Util ; import java . util . ArrayList ; class FStatP4OutputHandler extends P4HandlerAdapter { private P4Fstat parent ; private ArrayList existing = new ArrayList ( ) ; private ArrayList nonExisting = new ArrayList ( ) ; private static Perl5Util util = new Perl5Util ( ) ; public FStatP4OutputHandler ( P4Fstat parent ) { this . parent = parent ; } public void process ( String line ) throws BuildException { if ( util . match ( "/^... clientFile (.+)$/" , line ) ) { String f = util . group ( 1 ) ; existing . add ( f ) ; } else if ( util . match ( "/^(.+) - no such file/" , line ) ) { String f = util . group ( 1 ) ; nonExisting . add ( f ) ; } parent . log ( parent . util . substitute ( "s/^.*: //" , line ) , Project . MSG_VERBOSE ) ; } public ArrayList getExisting ( ) { return existing ; } public ArrayList getNonExisting ( ) { return nonExisting ; } } 	0	['5', '2', '0', '4', '13', '0', '1', '4', '4', '0.625', '76', '1', '1', '0.7', '0.5', '0', '0', '13.4', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; public class OutErrSummaryJUnitResultFormatter extends SummaryJUnitResultFormatter { public OutErrSummaryJUnitResultFormatter ( ) { super ( ) ; setWithOutAndErr ( true ) ; } } 	0	['1', '2', '0', '1', '3', '0', '0', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; public abstract class P4HandlerAdapter implements P4Handler { String p4input = "" ; private PumpStreamHandler myHandler = null ; public void setOutput ( String p4Input ) { this . p4input = p4Input ; } public abstract void process ( String line ) ; public void start ( ) throws BuildException { if ( p4input != null && p4input . length ( ) > 0 ) { myHandler = new PumpStreamHandler ( new P4OutputStream ( this ) , new P4OutputStream ( this ) , new ByteArrayInputStream ( p4input . getBytes ( ) ) ) ; } else { myHandler = new PumpStreamHandler ( new P4OutputStream ( this ) , new P4OutputStream ( this ) ) ; } myHandler . setProcessInputStream ( os ) ; myHandler . setProcessErrorStream ( es ) ; myHandler . setProcessOutputStream ( is ) ; myHandler . start ( ) ; } public void stop ( ) { myHandler . stop ( ) ; } OutputStream os ; InputStream is ; InputStream es ; public void setProcessInputStream ( OutputStream os ) throws IOException { this . os = os ; } public void setProcessErrorStream ( InputStream is ) throws IOException { this . es = is ; } public void setProcessOutputStream ( InputStream is ) throws IOException { this . is = is ; } } 	0	['8', '1', '9', '13', '20', '12', '9', '4', '8', '0.8', '101', '0.2', '1', '0', '0.40625', '0', '0', '11', '1', '0.875', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; public abstract class ConstantCPInfo extends ConstantPoolEntry { private Object value ; protected ConstantCPInfo ( int tagValue , int entries ) { super ( tagValue , entries ) ; } public Object getValue ( ) { return value ; } public void setValue ( Object newValue ) { value = newValue ; } } 	0	['3', '2', '5', '7', '4', '1', '6', '1', '2', '0.5', '16', '1', '0', '0.75', '0.555555556', '0', '0', '4', '1', '0.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . util . FileUtils ; public class Date implements ResourceSelector { private static final String MILLIS_OR_DATETIME = "Either the millis or the datetime attribute must be set." ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Long millis = null ; private String dateTime = null ; private String pattern = null ; private TimeComparison when = TimeComparison . EQUAL ; private long granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; public synchronized void setMillis ( long m ) { millis = new Long ( m ) ; } public synchronized long getMillis ( ) { return millis == null ? - 1L : millis . longValue ( ) ; } public synchronized void setDateTime ( String s ) { dateTime = s ; millis = null ; } public synchronized String getDatetime ( ) { return dateTime ; } public synchronized void setGranularity ( long g ) { granularity = g ; } public synchronized long getGranularity ( ) { return granularity ; } public synchronized void setPattern ( String p ) { pattern = p ; } public synchronized String getPattern ( ) { return pattern ; } public synchronized void setWhen ( TimeComparison c ) { when = c ; } public synchronized TimeComparison getWhen ( ) { return when ; } public synchronized boolean isSelected ( Resource r ) { if ( dateTime == null && millis == null ) { throw new BuildException ( MILLIS_OR_DATETIME ) ; } if ( millis == null ) { DateFormat df = ( ( pattern == null ) ? DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) : new SimpleDateFormat ( pattern ) ) ; try { long m = df . parse ( dateTime ) . getTime ( ) ; if ( m < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } setMillis ( m ) ; } catch ( ParseException pe ) { throw new BuildException ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + ( pattern == null ? " MM/DD/YYYY HH:MM AM_PM" : pattern ) + " format." ) ; } } return when . evaluate ( r . getLastModified ( ) , millis . longValue ( ) , granularity ) ; } } 	0	['13', '1', '0', '7', '28', '20', '2', '5', '12', '0.80952381', '183', '1', '2', '0', '0.3', '0', '0', '12.53846154', '7', '1.3846', '0']
package org . apache . tools . ant . util . facade ; import java . util . Enumeration ; import java . util . Vector ; public class FacadeTaskHelper { private Vector args = new Vector ( ) ; private String userChoice ; private String magicValue ; private String defaultValue ; public FacadeTaskHelper ( String defaultValue ) { this ( defaultValue , null ) ; } public FacadeTaskHelper ( String defaultValue , String magicValue ) { this . defaultValue = defaultValue ; this . magicValue = magicValue ; } public void setMagicValue ( String magicValue ) { this . magicValue = magicValue ; } public void setImplementation ( String userChoice ) { this . userChoice = userChoice ; } public String getImplementation ( ) { return userChoice != null ? userChoice : ( magicValue != null ? magicValue : defaultValue ) ; } public String getExplicitChoice ( ) { return userChoice ; } public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . addElement ( arg ) ; } public String [ ] getArgs ( ) { Vector tmp = new Vector ( args . size ( ) ) ; for ( Enumeration e = args . elements ( ) ; e . hasMoreElements ( ) ; ) { ImplementationSpecificArgument arg = ( ( ImplementationSpecificArgument ) e . nextElement ( ) ) ; String [ ] curr = arg . getParts ( getImplementation ( ) ) ; for ( int i = 0 ; i < curr . length ; i ++ ) { tmp . addElement ( curr [ i ] ) ; } } String [ ] res = new String [ tmp . size ( ) ] ; tmp . copyInto ( res ) ; return res ; } public boolean hasBeenSet ( ) { return userChoice != null || magicValue != null ; } } 	0	['9', '1', '0', '5', '19', '8', '4', '1', '9', '0.53125', '119', '1', '0', '0', '0.518518519', '0', '0', '11.77777778', '3', '1.4444', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public class DepthSelector extends BaseExtendSelector { public int min = - 1 ; public int max = - 1 ; public static final String MIN_KEY = "min" ; public static final String MAX_KEY = "max" ; public DepthSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{depthselector min: " ) ; buf . append ( min ) ; buf . append ( " max: " ) ; buf . append ( max ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMin ( int min ) { this . min = min ; } public void setMax ( int max ) { this . max = max ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MIN_KEY . equalsIgnoreCase ( paramname ) ) { try { setMin ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid minimum value " + parameters [ i ] . getValue ( ) ) ; } } else if ( MAX_KEY . equalsIgnoreCase ( paramname ) ) { try { setMax ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid maximum value " + parameters [ i ] . getValue ( ) ) ; } } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( min < 0 && max < 0 ) { setError ( "You must set at least one of the min or the " + "max levels." ) ; } if ( max < min && max > - 1 ) { setError ( "The maximum depth is lower than the minimum." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int depth = - 1 ; String absBase = basedir . getAbsolutePath ( ) ; String absFile = file . getAbsolutePath ( ) ; StringTokenizer tokBase = new StringTokenizer ( absBase , File . separator ) ; StringTokenizer tokFile = new StringTokenizer ( absFile , File . separator ) ; while ( tokFile . hasMoreTokens ( ) ) { String filetoken = tokFile . nextToken ( ) ; if ( tokBase . hasMoreTokens ( ) ) { String basetoken = tokBase . nextToken ( ) ; if ( ! basetoken . equals ( filetoken ) ) { throw new BuildException ( "File " + filename + " does not appear within " + absBase + "directory" ) ; } } else { depth += 1 ; if ( max > - 1 && depth > max ) { return false ; } } } if ( tokBase . hasMoreTokens ( ) ) { throw new BuildException ( "File " + filename + " is outside of " + absBase + "directory tree" ) ; } if ( min > - 1 && depth < min ) { return false ; } return true ; } } 	0	['7', '5', '0', '9', '25', '0', '6', '3', '7', '0.666666667', '255', '0', '0', '0.863636364', '0.342857143', '2', '5', '34.85714286', '9', '3.1429', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; public class JSharp extends DotnetCompile { String baseAddress ; boolean pureJava = true ; boolean secureScoping = false ; public JSharp ( ) { setExecutable ( "vjc" ) ; } public void setBaseAddress ( String baseAddress ) { this . baseAddress = baseAddress ; } public void setPureJava ( boolean pureJava ) { this . pureJava = pureJava ; } public void setSecureScoping ( boolean secureScoping ) { this . secureScoping = secureScoping ; } public String getReferenceDelimiter ( ) { return ";" ; } public String getFileExtension ( ) { return ".java" ; } protected void addCompilerSpecificOptions ( NetCommand command ) { if ( pureJava ) { command . addArgument ( "/x:all" ) ; } if ( secureScoping ) { command . addArgument ( "/securescoping" ) ; } } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , true ) ; } protected void validate ( ) throws BuildException { super . validate ( ) ; if ( getDestFile ( ) == null ) { throw new BuildException ( "DestFile was not specified" ) ; } } } 	0	['9', '6', '0', '5', '17', '26', '0', '5', '6', '0.833333333', '71', '0', '0', '0.949367089', '0.333333333', '1', '4', '6.555555556', '3', '1.1111', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { this ( ( ProjectComponent ) task , outlevel , errlevel ) ; } public LogStreamHandler ( ProjectComponent pc , int outlevel , int errlevel ) { super ( new LogOutputStream ( pc , outlevel ) , new LogOutputStream ( pc , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '19', '10', '3', '14', '5', '3', '2', '38', '0', '0', '0.923076923', '0.583333333', '0', '0', '11.66666667', '1', '0.3333', '0']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '10', '1', '0', '8', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public final class JarMarker implements ZipExtraField { private static final ZipShort ID = new ZipShort ( 0xCAFE ) ; private static final ZipShort NULL = new ZipShort ( 0 ) ; private static final byte [ ] NO_BYTES = new byte [ 0 ] ; private static final JarMarker DEFAULT = new JarMarker ( ) ; public JarMarker ( ) { } public static JarMarker getInstance ( ) { return DEFAULT ; } public ZipShort getHeaderId ( ) { return ID ; } public ZipShort getLocalFileDataLength ( ) { return NULL ; } public ZipShort getCentralDirectoryLength ( ) { return NULL ; } public byte [ ] getLocalFileDataData ( ) { return NO_BYTES ; } public byte [ ] getCentralDirectoryData ( ) { return NO_BYTES ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { if ( length != 0 ) { throw new ZipException ( "JarMarker doesn't expect any data" ) ; } } } 	0	['9', '1', '0', '3', '12', '20', '1', '2', '8', '0.8125', '54', '1', '3', '0', '0.375', '0', '0', '4.555555556', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkbl extends ClearCase { private String mComment = null ; private String mCfile = null ; private String mBaselineRootName = null ; private boolean mNwarn = false ; private boolean mIdentical = true ; private boolean mFull = false ; private boolean mNlabel = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKBL ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getBaselineRootName ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getIdentical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IDENTICAL ) ; } if ( getFull ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_FULL ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_INCREMENTAL ) ; } if ( getNlabel ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NLABEL ) ; } cmd . createArgument ( ) . setValue ( getBaselineRootName ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setBaselineRootName ( String baselineRootName ) { mBaselineRootName = baselineRootName ; } public String getBaselineRootName ( ) { return mBaselineRootName ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setIdentical ( boolean identical ) { mIdentical = identical ; } public boolean getIdentical ( ) { return mIdentical ; } public void setFull ( boolean full ) { mFull = full ; } public boolean getFull ( ) { return mFull ; } public void setNlabel ( boolean nlabel ) { mNlabel = nlabel ; } public boolean getNlabel ( ) { return mNlabel ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_IDENTICAL = "-identical" ; public static final String FLAG_INCREMENTAL = "-incremental" ; public static final String FLAG_FULL = "-full" ; public static final String FLAG_NLABEL = "-nlabel" ; } 	0	['19', '4', '0', '7', '40', '129', '0', '7', '16', '0.936507937', '252', '0.5', '0', '0.727272727', '0.381578947', '2', '3', '11.52631579', '6', '1.3158', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . resources . selectors . ResourceSelectorContainer ; public class Restrict extends ResourceSelectorContainer implements ResourceCollection { private BaseResourceCollectionWrapper w = new BaseResourceCollectionWrapper ( ) { protected Collection getCollection ( ) { ArrayList result = new ArrayList ( ) ; outer : for ( Iterator ri = w . getResourceCollection ( ) . iterator ( ) ; ri . hasNext ( ) ; ) { Resource r = ( Resource ) ri . next ( ) ; for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ! ( ( ResourceSelector ) ( i . next ( ) ) ) . isSelected ( r ) ) { continue outer ; } } result . add ( r ) ; } return result ; } } ; public synchronized void add ( ResourceCollection c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } w . add ( c ) ; } public synchronized void setCache ( boolean b ) { w . setCache ( b ) ; } public synchronized boolean isCache ( ) { return w . isCache ( ) ; } public synchronized void add ( ResourceSelector s ) { if ( s == null ) { return ; } super . add ( s ) ; FailFast . invalidate ( this ) ; } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return w . iterator ( ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return w . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; return w . isFilesystemOnly ( ) ; } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } dieOnCircularReference ( ) ; return w . toString ( ) ; } } 	0	['10', '4', '2', '13', '26', '0', '7', '7', '9', '0.111111111', '110', '1', '1', '0.795454545', '0.26', '1', '1', '9.9', '3', '1.6', '0']
package org . apache . tools . ant ; import java . io . IOException ; import java . io . InputStream ; public class DemuxInputStream extends InputStream { private Project project ; public DemuxInputStream ( Project project ) { this . project = project ; } public int read ( ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; if ( project . demuxInput ( buffer , 0 , 1 ) == - 1 ) { return - 1 ; } return buffer [ 0 ] ; } public int read ( byte [ ] buffer , int offset , int length ) throws IOException { return project . demuxInput ( buffer , offset , length ) ; } } 	0	['3', '2', '0', '2', '5', '0', '1', '1', '3', '0', '34', '1', '1', '0.818181818', '0.5', '1', '2', '10', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . AttributeList ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class IPlanetEjbc { private static final int MIN_NUM_ARGS = 2 ; private static final int MAX_NUM_ARGS = 8 ; private static final int NUM_CLASSES_WITH_IIOP = 15 ; private static final int NUM_CLASSES_WITHOUT_IIOP = 9 ; private static final String ENTITY_BEAN = "entity" ; private static final String STATELESS_SESSION = "stateless" ; private static final String STATEFUL_SESSION = "stateful" ; private File stdDescriptor ; private File iasDescriptor ; private File destDirectory ; private String classpath ; private String [ ] classpathElements ; private boolean retainSource = false ; private boolean debugOutput = false ; private File iasHomeDir ; private SAXParser parser ; private EjbcHandler handler = new EjbcHandler ( ) ; private Hashtable ejbFiles = new Hashtable ( ) ; private String displayName ; public IPlanetEjbc ( File stdDescriptor , File iasDescriptor , File destDirectory , String classpath , SAXParser parser ) { this . stdDescriptor = stdDescriptor ; this . iasDescriptor = iasDescriptor ; this . destDirectory = destDirectory ; this . classpath = classpath ; this . parser = parser ; List elements = new ArrayList ( ) ; if ( classpath != null ) { StringTokenizer st = new StringTokenizer ( classpath , File . pathSeparator ) ; while ( st . hasMoreTokens ( ) ) { elements . add ( st . nextToken ( ) ) ; } classpathElements = ( String [ ] ) elements . toArray ( new String [ elements . size ( ) ] ) ; } } public void setRetainSource ( boolean retainSource ) { this . retainSource = retainSource ; } public void setDebugOutput ( boolean debugOutput ) { this . debugOutput = debugOutput ; } public void registerDTD ( String publicID , String location ) { handler . registerDTD ( publicID , location ) ; } public void setIasHomeDir ( File iasHomeDir ) { this . iasHomeDir = iasHomeDir ; } public Hashtable getEjbFiles ( ) { return ejbFiles ; } public String getDisplayName ( ) { return displayName ; } public String [ ] getCmpDescriptors ( ) { List returnList = new ArrayList ( ) ; EjbInfo [ ] ejbs = handler . getEjbs ( ) ; for ( int i = 0 ; i < ejbs . length ; i ++ ) { List descriptors = ( List ) ejbs [ i ] . getCmpDescriptors ( ) ; returnList . addAll ( descriptors ) ; } return ( String [ ] ) returnList . toArray ( new String [ returnList . size ( ) ] ) ; } public static void main ( String [ ] args ) { File stdDescriptor ; File iasDescriptor ; File destDirectory = null ; String classpath = null ; SAXParser parser = null ; boolean debug = false ; boolean retainSource = false ; IPlanetEjbc ejbc ; if ( ( args . length < MIN_NUM_ARGS ) || ( args . length > MAX_NUM_ARGS ) ) { usage ( ) ; return ; } stdDescriptor = new File ( args [ args . length - 2 ] ) ; iasDescriptor = new File ( args [ args . length - 1 ] ) ; for ( int i = 0 ; i < args . length - 2 ; i ++ ) { if ( args [ i ] . equals ( "-classpath" ) ) { classpath = args [ ++ i ] ; } else if ( args [ i ] . equals ( "-d" ) ) { destDirectory = new File ( args [ ++ i ] ) ; } else if ( args [ i ] . equals ( "-debug" ) ) { debug = true ; } else if ( args [ i ] . equals ( "-keepsource" ) ) { retainSource = true ; } else { usage ( ) ; return ; } } if ( classpath == null ) { Properties props = System . getProperties ( ) ; classpath = props . getProperty ( "java.class.path" ) ; } if ( destDirectory == null ) { Properties props = System . getProperties ( ) ; destDirectory = new File ( props . getProperty ( "user.dir" ) ) ; } SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; parserFactory . setValidating ( true ) ; try { parser = parserFactory . newSAXParser ( ) ; } catch ( Exception e ) { System . out . println ( "An exception was generated while trying to " ) ; System . out . println ( "create a new SAXParser." ) ; e . printStackTrace ( ) ; return ; } ejbc = new IPlanetEjbc ( stdDescriptor , iasDescriptor , destDirectory , classpath , parser ) ; ejbc . setDebugOutput ( debug ) ; ejbc . setRetainSource ( retainSource ) ; try { ejbc . execute ( ) ; } catch ( IOException e ) { System . out . println ( "An IOException has occurred while reading the " + "XML descriptors (" + e . getMessage ( ) + ")." ) ; return ; } catch ( SAXException e ) { System . out . println ( "A SAXException has occurred while reading the " + "XML descriptors (" + e . getMessage ( ) + ")." ) ; return ; } catch ( IPlanetEjbc . EjbcException e ) { System . out . println ( "An error has occurred while executing the ejbc " + "utility (" + e . getMessage ( ) + ")." ) ; return ; } } private static void usage ( ) { System . out . println ( "java org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbc \\" ) ; System . out . println ( "  [OPTIONS] [EJB 1.1 descriptor] [iAS EJB descriptor]" ) ; System . out . println ( "" ) ; System . out . println ( "Where OPTIONS are:" ) ; System . out . println ( "  -debug -- for additional debugging output" ) ; System . out . println ( "  -keepsource -- to retain Java source files generated" ) ; System . out . println ( "  -classpath [classpath] -- classpath used for compilation" ) ; System . out . println ( "  -d [destination directory] -- directory for compiled classes" ) ; System . out . println ( "" ) ; System . out . println ( "If a classpath is not specified, the system classpath" ) ; System . out . println ( "will be used.  If a destination directory is not specified," ) ; System . out . println ( "the current working directory will be used (classes will" ) ; System . out . println ( "still be placed in subfolders which correspond to their" ) ; System . out . println ( "package name)." ) ; System . out . println ( "" ) ; System . out . println ( "The EJB home interface, remote interface, and implementation" ) ; System . out . println ( "class must be found in the destination directory.  In" ) ; System . out . println ( "addition, the destination will look for the stubs and skeletons" ) ; System . out . println ( "in the destination directory to ensure they are up to date." ) ; } public void execute ( ) throws EjbcException , IOException , SAXException { checkConfiguration ( ) ; EjbInfo [ ] ejbs = getEjbs ( ) ; for ( int i = 0 ; i < ejbs . length ; i ++ ) { log ( "EJBInfo..." ) ; log ( ejbs [ i ] . toString ( ) ) ; } for ( int i = 0 ; i < ejbs . length ; i ++ ) { EjbInfo ejb = ejbs [ i ] ; ejb . checkConfiguration ( destDirectory ) ; if ( ejb . mustBeRecompiled ( destDirectory ) ) { log ( ejb . getName ( ) + " must be recompiled using ejbc." ) ; String [ ] arguments = buildArgumentList ( ejb ) ; callEjbc ( arguments ) ; } else { log ( ejb . getName ( ) + " is up to date." ) ; } } } private void callEjbc ( String [ ] arguments ) { StringBuffer args = new StringBuffer ( ) ; for ( int i = 0 ; i < arguments . length ; i ++ ) { args . append ( arguments [ i ] ) . append ( " " ) ; } String command ; if ( iasHomeDir == null ) { command = "" ; } else { command = iasHomeDir . toString ( ) + File . separator + "bin" + File . separator ; } command += "ejbc " ; log ( command + args ) ; try { Process p = Runtime . getRuntime ( ) . exec ( command + args ) ; RedirectOutput output = new RedirectOutput ( p . getInputStream ( ) ) ; RedirectOutput error = new RedirectOutput ( p . getErrorStream ( ) ) ; output . start ( ) ; error . start ( ) ; p . waitFor ( ) ; p . destroy ( ) ; } catch ( IOException e ) { log ( "An IOException has occurred while trying to execute ejbc." ) ; e . printStackTrace ( ) ; } catch ( InterruptedException e ) { } } protected void checkConfiguration ( ) throws EjbcException { String msg = "" ; if ( stdDescriptor == null ) { msg += "A standard XML descriptor file must be specified.  " ; } if ( iasDescriptor == null ) { msg += "An iAS-specific XML descriptor file must be specified.  " ; } if ( classpath == null ) { msg += "A classpath must be specified.    " ; } if ( parser == null ) { msg += "An XML parser must be specified.    " ; } if ( destDirectory == null ) { msg += "A destination directory must be specified.  " ; } else if ( ! destDirectory . exists ( ) ) { msg += "The destination directory specified does not exist.  " ; } else if ( ! destDirectory . isDirectory ( ) ) { msg += "The destination specified is not a directory.  " ; } if ( msg . length ( ) > 0 ) { throw new EjbcException ( msg ) ; } } private EjbInfo [ ] getEjbs ( ) throws IOException , SAXException { EjbInfo [ ] ejbs = null ; parser . parse ( stdDescriptor , handler ) ; parser . parse ( iasDescriptor , handler ) ; ejbs = handler . getEjbs ( ) ; return ejbs ; } private String [ ] buildArgumentList ( EjbInfo ejb ) { List arguments = new ArrayList ( ) ; if ( debugOutput ) { arguments . add ( "-debug" ) ; } if ( ejb . getBeantype ( ) . equals ( STATELESS_SESSION ) ) { arguments . add ( "-sl" ) ; } else if ( ejb . getBeantype ( ) . equals ( STATEFUL_SESSION ) ) { arguments . add ( "-sf" ) ; } if ( ejb . getIiop ( ) ) { arguments . add ( "-iiop" ) ; } if ( ejb . getCmp ( ) ) { arguments . add ( "-cmp" ) ; } if ( retainSource ) { arguments . add ( "-gs" ) ; } if ( ejb . getHasession ( ) ) { arguments . add ( "-fo" ) ; } arguments . add ( "-classpath" ) ; arguments . add ( classpath ) ; arguments . add ( "-d" ) ; arguments . add ( destDirectory . toString ( ) ) ; arguments . add ( ejb . getHome ( ) . getQualifiedClassName ( ) ) ; arguments . add ( ejb . getRemote ( ) . getQualifiedClassName ( ) ) ; arguments . add ( ejb . getImplementation ( ) . getQualifiedClassName ( ) ) ; return ( String [ ] ) arguments . toArray ( new String [ arguments . size ( ) ] ) ; } private void log ( String msg ) { if ( debugOutput ) { System . out . println ( msg ) ; } } public class EjbcException extends Exception { public EjbcException ( String msg ) { super ( msg ) ; } } private class EjbcHandler extends HandlerBase { private static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; private static final String PUBLICID_IPLANET_EJB_60 = "-//Sun Microsystems, Inc.//DTD iAS Enterprise JavaBeans 1.0//EN" ; private static final String DEFAULT_IAS60_EJB11_DTD_LOCATION = "ejb-jar_1_1.dtd" ; private static final String DEFAULT_IAS60_DTD_LOCATION = "IASEjb_jar_1_0.dtd" ; private Map resourceDtds = new HashMap ( ) ; private Map fileDtds = new HashMap ( ) ; private Map ejbs = new HashMap ( ) ; private EjbInfo currentEjb ; private boolean iasDescriptor = false ; private String currentLoc = "" ; private String currentText ; private String ejbType ; public EjbcHandler ( ) { registerDTD ( PUBLICID_EJB11 , DEFAULT_IAS60_EJB11_DTD_LOCATION ) ; registerDTD ( PUBLICID_IPLANET_EJB_60 , DEFAULT_IAS60_DTD_LOCATION ) ; } public EjbInfo [ ] getEjbs ( ) { return ( EjbInfo [ ] ) ejbs . values ( ) . toArray ( new EjbInfo [ ejbs . size ( ) ] ) ; } public String getDisplayName ( ) { return displayName ; } public void registerDTD ( String publicID , String location ) { log ( "Registering: " + location ) ; if ( ( publicID == null ) || ( location == null ) ) { return ; } if ( ClassLoader . getSystemResource ( location ) != null ) { log ( "Found resource: " + location ) ; resourceDtds . put ( publicID , location ) ; } else { File dtdFile = new File ( location ) ; if ( dtdFile . exists ( ) && dtdFile . isFile ( ) ) { log ( "Found file: " + location ) ; fileDtds . put ( publicID , location ) ; } } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { InputStream inputStream = null ; try { String location = ( String ) resourceDtds . get ( publicId ) ; if ( location != null ) { inputStream = ClassLoader . getSystemResource ( location ) . openStream ( ) ; } else { location = ( String ) fileDtds . get ( publicId ) ; if ( location != null ) { inputStream = new FileInputStream ( location ) ; } } } catch ( IOException e ) { return super . resolveEntity ( publicId , systemId ) ; } if ( inputStream == null ) { return super . resolveEntity ( publicId , systemId ) ; } else { return new InputSource ( inputStream ) ; } } public void startElement ( String name , AttributeList atts ) throws SAXException { currentLoc += "\\" + name ; currentText = "" ; if ( currentLoc . equals ( "\\ejb-jar" ) ) { iasDescriptor = false ; } else if ( currentLoc . equals ( "\\ias-ejb-jar" ) ) { iasDescriptor = true ; } if ( ( name . equals ( "session" ) ) || ( name . equals ( "entity" ) ) ) { ejbType = name ; } } public void characters ( char [ ] ch , int start , int len ) throws SAXException { currentText += new String ( ch ) . substring ( start , start + len ) ; } public void endElement ( String name ) throws SAXException { if ( iasDescriptor ) { iasCharacters ( currentText ) ; } else { stdCharacters ( currentText ) ; } int nameLength = name . length ( ) + 1 ; int locLength = currentLoc . length ( ) ; currentLoc = currentLoc . substring ( 0 , locLength - nameLength ) ; } private void stdCharacters ( String value ) { if ( currentLoc . equals ( "\\ejb-jar\\display-name" ) ) { displayName = value ; return ; } String base = "\\ejb-jar\\enterprise-beans\\" + ejbType ; if ( currentLoc . equals ( base + "\\ejb-name" ) ) { currentEjb = ( EjbInfo ) ejbs . get ( value ) ; if ( currentEjb == null ) { currentEjb = new EjbInfo ( value ) ; ejbs . put ( value , currentEjb ) ; } } else if ( currentLoc . equals ( base + "\\home" ) ) { currentEjb . setHome ( value ) ; } else if ( currentLoc . equals ( base + "\\remote" ) ) { currentEjb . setRemote ( value ) ; } else if ( currentLoc . equals ( base + "\\ejb-class" ) ) { currentEjb . setImplementation ( value ) ; } else if ( currentLoc . equals ( base + "\\prim-key-class" ) ) { currentEjb . setPrimaryKey ( value ) ; } else if ( currentLoc . equals ( base + "\\session-type" ) ) { currentEjb . setBeantype ( value ) ; } else if ( currentLoc . equals ( base + "\\persistence-type" ) ) { currentEjb . setCmp ( value ) ; } } private void iasCharacters ( String value ) { String base = "\\ias-ejb-jar\\enterprise-beans\\" + ejbType ; if ( currentLoc . equals ( base + "\\ejb-name" ) ) { currentEjb = ( EjbInfo ) ejbs . get ( value ) ; if ( currentEjb == null ) { currentEjb = new EjbInfo ( value ) ; ejbs . put ( value , currentEjb ) ; } } else if ( currentLoc . equals ( base + "\\iiop" ) ) { currentEjb . setIiop ( value ) ; } else if ( currentLoc . equals ( base + "\\failover-required" ) ) { currentEjb . setHasession ( value ) ; } else if ( currentLoc . equals ( base + "\\persistence-manager" + "\\properties-file-location" ) ) { currentEjb . addCmpDescriptor ( value ) ; } } } private class EjbInfo { private String name ; private Classname home ; private Classname remote ; private Classname implementation ; private Classname primaryKey ; private String beantype = "entity" ; private boolean cmp = false ; private boolean iiop = false ; private boolean hasession = false ; private List cmpDescriptors = new ArrayList ( ) ; public EjbInfo ( String name ) { this . name = name ; } public String getName ( ) { if ( name == null ) { if ( implementation == null ) { return "[unnamed]" ; } else { return implementation . getClassName ( ) ; } } return name ; } public void setHome ( String home ) { setHome ( new Classname ( home ) ) ; } public void setHome ( Classname home ) { this . home = home ; } public Classname getHome ( ) { return home ; } public void setRemote ( String remote ) { setRemote ( new Classname ( remote ) ) ; } public void setRemote ( Classname remote ) { this . remote = remote ; } public Classname getRemote ( ) { return remote ; } public void setImplementation ( String implementation ) { setImplementation ( new Classname ( implementation ) ) ; } public void setImplementation ( Classname implementation ) { this . implementation = implementation ; } public Classname getImplementation ( ) { return implementation ; } public void setPrimaryKey ( String primaryKey ) { setPrimaryKey ( new Classname ( primaryKey ) ) ; } public void setPrimaryKey ( Classname primaryKey ) { this . primaryKey = primaryKey ; } public Classname getPrimaryKey ( ) { return primaryKey ; } public void setBeantype ( String beantype ) { this . beantype = beantype . toLowerCase ( ) ; } public String getBeantype ( ) { return beantype ; } public void setCmp ( boolean cmp ) { this . cmp = cmp ; } public void setCmp ( String cmp ) { setCmp ( cmp . equals ( "Container" ) ) ; } public boolean getCmp ( ) { return cmp ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public void setIiop ( String iiop ) { setIiop ( iiop . equals ( "true" ) ) ; } public boolean getIiop ( ) { return iiop ; } public void setHasession ( boolean hasession ) { this . hasession = hasession ; } public void setHasession ( String hasession ) { setHasession ( hasession . equals ( "true" ) ) ; } public boolean getHasession ( ) { return hasession ; } public void addCmpDescriptor ( String descriptor ) { cmpDescriptors . add ( descriptor ) ; } public List getCmpDescriptors ( ) { return cmpDescriptors ; } private void checkConfiguration ( File buildDir ) throws EjbcException { if ( home == null ) { throw new EjbcException ( "A home interface was not found " + "for the " + name + " EJB." ) ; } if ( remote == null ) { throw new EjbcException ( "A remote interface was not found " + "for the " + name + " EJB." ) ; } if ( implementation == null ) { throw new EjbcException ( "An EJB implementation class was not " + "found for the " + name + " EJB." ) ; } if ( ( ! beantype . equals ( ENTITY_BEAN ) ) && ( ! beantype . equals ( STATELESS_SESSION ) ) && ( ! beantype . equals ( STATEFUL_SESSION ) ) ) { throw new EjbcException ( "The beantype found (" + beantype + ") " + "isn't valid in the " + name + " EJB." ) ; } if ( cmp && ( ! beantype . equals ( ENTITY_BEAN ) ) ) { System . out . println ( "CMP stubs and skeletons may not be generated" + " for a Session Bean -- the \"cmp\" attribute will be" + " ignoredfor the " + name + " EJB." ) ; } if ( hasession && ( ! beantype . equals ( STATEFUL_SESSION ) ) ) { System . out . println ( "Highly available stubs and skeletons may " + "only be generated for a Stateful Session Bean -- the " + "\"hasession\" attribute will be ignored for the " + name + " EJB." ) ; } if ( ! remote . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The remote interface " + remote . getQualifiedClassName ( ) + " could not be " + "found." ) ; } if ( ! home . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The home interface " + home . getQualifiedClassName ( ) + " could not be " + "found." ) ; } if ( ! implementation . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The EJB implementation class " + implementation . getQualifiedClassName ( ) + " could " + "not be found." ) ; } } public boolean mustBeRecompiled ( File destDir ) { long sourceModified = sourceClassesModified ( destDir ) ; long destModified = destClassesModified ( destDir ) ; return ( destModified < sourceModified ) ; } private long sourceClassesModified ( File buildDir ) { long latestModified ; long modified ; File remoteFile ; File homeFile ; File implFile ; File pkFile ; remoteFile = remote . getClassFile ( buildDir ) ; modified = remoteFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + remote . getQualifiedClassName ( ) + " couldn't " + "be found on the classpath" ) ; return - 1 ; } latestModified = modified ; homeFile = home . getClassFile ( buildDir ) ; modified = homeFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + home . getQualifiedClassName ( ) + " couldn't be " + "found on the classpath" ) ; return - 1 ; } latestModified = Math . max ( latestModified , modified ) ; if ( primaryKey != null ) { pkFile = primaryKey . getClassFile ( buildDir ) ; modified = pkFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + primaryKey . getQualifiedClassName ( ) + "couldn't be " + "found on the classpath" ) ; return - 1 ; } latestModified = Math . max ( latestModified , modified ) ; } else { pkFile = null ; } implFile = implementation . getClassFile ( buildDir ) ; modified = implFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + implementation . getQualifiedClassName ( ) + " couldn't be found on the classpath" ) ; return - 1 ; } String pathToFile = remote . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , remoteFile ) ; pathToFile = home . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , homeFile ) ; pathToFile = implementation . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , implFile ) ; if ( pkFile != null ) { pathToFile = primaryKey . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , pkFile ) ; } return latestModified ; } private long destClassesModified ( File destDir ) { String [ ] classnames = classesToGenerate ( ) ; long destClassesModified = new Date ( ) . getTime ( ) ; boolean allClassesFound = true ; for ( int i = 0 ; i < classnames . length ; i ++ ) { String pathToClass = classnames [ i ] . replace ( '.' , File . separatorChar ) + ".class" ; File classFile = new File ( destDir , pathToClass ) ; ejbFiles . put ( pathToClass , classFile ) ; allClassesFound = allClassesFound && classFile . exists ( ) ; if ( allClassesFound ) { long fileMod = classFile . lastModified ( ) ; destClassesModified = Math . min ( destClassesModified , fileMod ) ; } } return ( allClassesFound ) ? destClassesModified : - 1 ; } private String [ ] classesToGenerate ( ) { String [ ] classnames = ( iiop ) ? new String [ NUM_CLASSES_WITH_IIOP ] : new String [ NUM_CLASSES_WITHOUT_IIOP ] ; final String remotePkg = remote . getPackageName ( ) + "." ; final String remoteClass = remote . getClassName ( ) ; final String homePkg = home . getPackageName ( ) + "." ; final String homeClass = home . getClassName ( ) ; final String implPkg = implementation . getPackageName ( ) + "." ; final String implFullClass = implementation . getQualifiedWithUnderscores ( ) ; int index = 0 ; classnames [ index ++ ] = implPkg + "ejb_fac_" + implFullClass ; classnames [ index ++ ] = implPkg + "ejb_home_" + implFullClass ; classnames [ index ++ ] = implPkg + "ejb_skel_" + implFullClass ; classnames [ index ++ ] = remotePkg + "ejb_kcp_skel_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_kcp_skel_" + homeClass ; classnames [ index ++ ] = remotePkg + "ejb_kcp_stub_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_kcp_stub_" + homeClass ; classnames [ index ++ ] = remotePkg + "ejb_stub_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_stub_" + homeClass ; if ( ! iiop ) { return classnames ; } classnames [ index ++ ] = "org.omg.stub." + remotePkg + "_" + remoteClass + "_Stub" ; classnames [ index ++ ] = "org.omg.stub." + homePkg + "_" + homeClass + "_Stub" ; classnames [ index ++ ] = "org.omg.stub." + remotePkg + "_ejb_RmiCorbaBridge_" + remoteClass + "_Tie" ; classnames [ index ++ ] = "org.omg.stub." + homePkg + "_ejb_RmiCorbaBridge_" + homeClass + "_Tie" ; classnames [ index ++ ] = remotePkg + "ejb_RmiCorbaBridge_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_RmiCorbaBridge_" + homeClass ; return classnames ; } public String toString ( ) { String s = "EJB name: " + name + "\n\r              home:      " + home + "\n\r              remote:    " + remote + "\n\r              impl:      " + implementation + "\n\r              primaryKey: " + primaryKey + "\n\r              beantype:  " + beantype + "\n\r              cmp:       " + cmp + "\n\r              iiop:      " + iiop + "\n\r              hasession: " + hasession ; Iterator i = cmpDescriptors . iterator ( ) ; while ( i . hasNext ( ) ) { s += "\n\r              CMP Descriptor: " + i . next ( ) ; } return s ; } } private static class Classname { private String qualifiedName ; private String packageName ; private String className ; public Classname ( String qualifiedName ) { if ( qualifiedName == null ) { return ; } this . qualifiedName = qualifiedName ; int index = qualifiedName . lastIndexOf ( '.' ) ; if ( index == - 1 ) { className = qualifiedName ; packageName = "" ; } else { packageName = qualifiedName . substring ( 0 , index ) ; className = qualifiedName . substring ( index + 1 ) ; } } public String getQualifiedClassName ( ) { return qualifiedName ; } public String getPackageName ( ) { return packageName ; } public String getClassName ( ) { return className ; } public String getQualifiedWithUnderscores ( ) { return qualifiedName . replace ( '.' , '_' ) ; } public File getClassFile ( File directory ) { String pathToFile = qualifiedName . replace ( '.' , File . separatorChar ) + ".class" ; return new File ( directory , pathToFile ) ; } public String toString ( ) { return getQualifiedClassName ( ) ; } } private static class RedirectOutput extends Thread { private InputStream stream ; public RedirectOutput ( InputStream stream ) { this . stream = stream ; } public void run ( ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; String text ; try { while ( ( text = reader . readLine ( ) ) != null ) { System . out . println ( text ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { reader . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['20', '1', '0', '7', '79', '136', '5', '5', '10', '0.897506925', '835', '1', '1', '0', '0.19375', '0', '0', '39.8', '10', '1.95', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { ZipShort getHeaderId ( ) ; ZipShort getLocalFileDataLength ( ) ; ZipShort getCentralDirectoryLength ( ) ; byte [ ] getLocalFileDataData ( ) ; byte [ ] getCentralDirectoryData ( ) ; void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '8', '6', '15', '7', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . Project ; public class TypeFound extends ProjectComponent implements Condition { private String name ; private String uri ; public void setName ( String name ) { this . name = name ; } public void setURI ( String uri ) { this . uri = uri ; } protected boolean doesTypeExist ( String typename ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( uri , typename ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { return false ; } boolean found = def . getExposedClass ( getProject ( ) ) != null ; if ( ! found ) { String text = helper . diagnoseCreationFailure ( componentName , "type" ) ; log ( text , Project . MSG_VERBOSE ) ; } return found ; } public boolean eval ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "No type specified" ) ; } return doesTypeExist ( name ) ; } } 	0	['5', '2', '0', '7', '14', '6', '0', '7', '4', '0.625', '70', '1', '0', '0.692307692', '0.8', '0', '0', '12.6', '4', '1.4', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public interface P4OutputHandler { void process ( String line ) throws BuildException ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . PrintWriter ; import org . apache . tools . ant . ProjectComponent ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; private String charset = null ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream ps ) throws IOException { PrintWriter out = charset != null ? new PrintWriter ( new OutputStreamWriter ( ps , charset ) ) : new PrintWriter ( ps ) ; if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . substring ( 0 ) ) ) ; } out . flush ( ) ; } public boolean isMimeTypeSpecified ( ) { return specified ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['11', '2', '0', '7', '26', '0', '5', '2', '11', '0.58', '181', '1', '0', '0.529411765', '0.409090909', '0', '0', '15', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSCP extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CP ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['3', '4', '0', '5', '15', '3', '0', '5', '2', '2', '51', '0', '0', '0.978494624', '0.666666667', '1', '1', '16', '2', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public abstract class BaseExtendSelector extends BaseSelector implements ExtendFileSelector { protected Parameter [ ] parameters = null ; public BaseExtendSelector ( ) { } public void setParameters ( Parameter [ ] parameters ) { this . parameters = parameters ; } protected Parameter [ ] getParameters ( ) { return parameters ; } public abstract boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['4', '4', '8', '12', '5', '0', '8', '4', '3', '0.333333333', '18', '1', '1', '0.921052632', '0.4375', '0', '0', '3.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Date ; import java . net . InetAddress ; import java . net . UnknownHostException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XMLJUnitResultFormatter implements JUnitResultFormatter , XMLConstants { private static final String UNKNOWN = "unknown" ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private Document doc ; private Element rootElement ; private Hashtable testElements = new Hashtable ( ) ; private Hashtable failedTests = new Hashtable ( ) ; private Hashtable testStarts = new Hashtable ( ) ; private OutputStream out ; public XMLJUnitResultFormatter ( ) { } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { formatOutput ( SYSTEM_OUT , out ) ; } public void setSystemError ( String out ) { formatOutput ( SYSTEM_ERR , out ) ; } public void startTestSuite ( JUnitTest suite ) { doc = getDocumentBuilder ( ) . newDocument ( ) ; rootElement = doc . createElement ( TESTSUITE ) ; String n = suite . getName ( ) ; rootElement . setAttribute ( ATTR_NAME , n == null ? UNKNOWN : n ) ; final String timestamp = DateUtils . format ( new Date ( ) , DateUtils . ISO8601_DATETIME_PATTERN ) ; rootElement . setAttribute ( TIMESTAMP , timestamp ) ; rootElement . setAttribute ( HOSTNAME , getHostname ( ) ) ; Element propsElement = doc . createElement ( PROPERTIES ) ; rootElement . appendChild ( propsElement ) ; Properties props = suite . getProperties ( ) ; if ( props != null ) { Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , name ) ; propElement . setAttribute ( ATTR_VALUE , props . getProperty ( name ) ) ; propsElement . appendChild ( propElement ) ; } } } private String getHostname ( ) { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { return "localhost" ; } } public void endTestSuite ( JUnitTest suite ) throws BuildException { rootElement . setAttribute ( ATTR_TESTS , "" + suite . runCount ( ) ) ; rootElement . setAttribute ( ATTR_FAILURES , "" + suite . failureCount ( ) ) ; rootElement . setAttribute ( ATTR_ERRORS , "" + suite . errorCount ( ) ) ; rootElement . setAttribute ( ATTR_TIME , "" + ( suite . getRunTime ( ) / 1000.0 ) ) ; if ( out != null ) { Writer wri = null ; try { wri = new BufferedWriter ( new OutputStreamWriter ( out , "UTF8" ) ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , 0 , "  " ) ; wri . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( wri ) ; } } } } public void startTest ( Test t ) { testStarts . put ( t , new Long ( System . currentTimeMillis ( ) ) ) ; } public void endTest ( Test test ) { if ( ! testStarts . containsKey ( test ) ) { startTest ( test ) ; } Element currentTest = null ; if ( ! failedTests . containsKey ( test ) ) { currentTest = doc . createElement ( TESTCASE ) ; String n = JUnitVersionHelper . getTestCaseName ( test ) ; currentTest . setAttribute ( ATTR_NAME , n == null ? UNKNOWN : n ) ; currentTest . setAttribute ( ATTR_CLASSNAME , JUnitVersionHelper . getTestCaseClassName ( test ) ) ; rootElement . appendChild ( currentTest ) ; testElements . put ( test , currentTest ) ; } else { currentTest = ( Element ) testElements . get ( test ) ; } Long l = ( Long ) testStarts . get ( test ) ; currentTest . setAttribute ( ATTR_TIME , "" + ( ( System . currentTimeMillis ( ) - l . longValue ( ) ) / 1000.0 ) ) ; } public void addFailure ( Test test , Throwable t ) { formatError ( FAILURE , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { formatError ( ERROR , test , t ) ; } private void formatError ( String type , Test test , Throwable t ) { if ( test != null ) { endTest ( test ) ; failedTests . put ( test , test ) ; } Element nested = doc . createElement ( type ) ; Element currentTest = null ; if ( test != null ) { currentTest = ( Element ) testElements . get ( test ) ; } else { currentTest = rootElement ; } currentTest . appendChild ( nested ) ; String message = t . getMessage ( ) ; if ( message != null && message . length ( ) > 0 ) { nested . setAttribute ( ATTR_MESSAGE , t . getMessage ( ) ) ; } nested . setAttribute ( ATTR_TYPE , t . getClass ( ) . getName ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( t ) ; Text trace = doc . createTextNode ( strace ) ; nested . appendChild ( trace ) ; } private void formatOutput ( String type , String output ) { Element nested = doc . createElement ( type ) ; rootElement . appendChild ( nested ) ; nested . appendChild ( doc . createCDATASection ( output ) ) ; } } 	0	['15', '1', '0', '11', '65', '75', '0', '11', '11', '0.693877551', '443', '1', '0', '0', '0.295238095', '0', '0', '28.06666667', '5', '1.6', '0']
package org . apache . tools . ant . taskdefs . optional . net ; import java . net . Authenticator ; import java . net . PasswordAuthentication ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ProxySetup ; public class SetProxy extends Task { protected String proxyHost = null ; protected int proxyPort = 80 ; private String socksProxyHost = null ; private int socksProxyPort = 1080 ; private String nonProxyHosts = null ; private String proxyUser = null ; private String proxyPassword = null ; public void setProxyHost ( String hostname ) { proxyHost = hostname ; } public void setProxyPort ( int port ) { proxyPort = port ; } public void setSocksProxyHost ( String host ) { this . socksProxyHost = host ; } public void setSocksProxyPort ( int port ) { this . socksProxyPort = port ; } public void setNonProxyHosts ( String nonProxyHosts ) { this . nonProxyHosts = nonProxyHosts ; } public void setProxyUser ( String proxyUser ) { this . proxyUser = proxyUser ; } public void setProxyPassword ( String proxyPassword ) { this . proxyPassword = proxyPassword ; } public void applyWebProxySettings ( ) { boolean settingsChanged = false ; boolean enablingProxy = false ; Properties sysprops = System . getProperties ( ) ; if ( proxyHost != null ) { settingsChanged = true ; if ( proxyHost . length ( ) != 0 ) { traceSettingInfo ( ) ; enablingProxy = true ; sysprops . put ( ProxySetup . HTTP_PROXY_HOST , proxyHost ) ; String portString = Integer . toString ( proxyPort ) ; sysprops . put ( ProxySetup . HTTP_PROXY_PORT , portString ) ; sysprops . put ( ProxySetup . HTTPS_PROXY_HOST , proxyHost ) ; sysprops . put ( ProxySetup . HTTPS_PROXY_PORT , portString ) ; sysprops . put ( ProxySetup . FTP_PROXY_HOST , proxyHost ) ; sysprops . put ( ProxySetup . FTP_PROXY_PORT , portString ) ; if ( nonProxyHosts != null ) { sysprops . put ( ProxySetup . HTTP_NON_PROXY_HOSTS , nonProxyHosts ) ; sysprops . put ( ProxySetup . HTTPS_NON_PROXY_HOSTS , nonProxyHosts ) ; sysprops . put ( ProxySetup . FTP_NON_PROXY_HOSTS , nonProxyHosts ) ; } if ( proxyUser != null ) { sysprops . put ( ProxySetup . HTTP_PROXY_USERNAME , proxyUser ) ; sysprops . put ( ProxySetup . HTTP_PROXY_PASSWORD , proxyPassword ) ; } } else { log ( "resetting http proxy" , Project . MSG_VERBOSE ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_HOST ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_PORT ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_USERNAME ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_PASSWORD ) ; sysprops . remove ( ProxySetup . HTTPS_PROXY_HOST ) ; sysprops . remove ( ProxySetup . HTTPS_PROXY_PORT ) ; sysprops . remove ( ProxySetup . FTP_PROXY_HOST ) ; sysprops . remove ( ProxySetup . FTP_PROXY_PORT ) ; } } if ( socksProxyHost != null ) { settingsChanged = true ; if ( socksProxyHost . length ( ) != 0 ) { enablingProxy = true ; sysprops . put ( ProxySetup . SOCKS_PROXY_HOST , socksProxyHost ) ; sysprops . put ( ProxySetup . SOCKS_PROXY_PORT , Integer . toString ( socksProxyPort ) ) ; if ( proxyUser != null ) { sysprops . put ( ProxySetup . SOCKS_PROXY_USERNAME , proxyUser ) ; sysprops . put ( ProxySetup . SOCKS_PROXY_PASSWORD , proxyPassword ) ; } } else { log ( "resetting socks proxy" , Project . MSG_VERBOSE ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_HOST ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_PORT ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_USERNAME ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_PASSWORD ) ; } } if ( proxyUser != null ) { if ( enablingProxy ) { Authenticator . setDefault ( new ProxyAuth ( proxyUser , proxyPassword ) ) ; } else if ( settingsChanged ) { Authenticator . setDefault ( new ProxyAuth ( "" , "" ) ) ; } } } private void traceSettingInfo ( ) { log ( "Setting proxy to " + ( proxyHost != null ? proxyHost : "''" ) + ":" + proxyPort , Project . MSG_VERBOSE ) ; } public void execute ( ) throws BuildException { applyWebProxySettings ( ) ; } private static final class ProxyAuth extends Authenticator { private PasswordAuthentication auth ; private ProxyAuth ( String user , String pass ) { auth = new PasswordAuthentication ( user , pass . toCharArray ( ) ) ; } protected PasswordAuthentication getPasswordAuthentication ( ) { return auth ; } } } 	0	['11', '3', '0', '3', '24', '17', '0', '3', '10', '0.671428571', '309', '1', '0', '0.787234043', '0.545454545', '0', '0', '26.45454545', '11', '1.9091', '0']
package org . apache . tools . ant . util ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; public class KeepAliveInputStream extends FilterInputStream { public KeepAliveInputStream ( InputStream in ) { super ( in ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '1', '3', '1', '1', '0', '2', '2', '7', '0', '0', '0.947368421', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . PropertySet ; public class CallTarget extends Task { private Ant callee ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private boolean targetSet = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = new Ant ( this ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( ! targetSet ) { throw new BuildException ( "Attribute target or at least one nested target is required." , getLocation ( ) ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void addPropertyset ( PropertySet ps ) { if ( callee == null ) { init ( ) ; } callee . addPropertyset ( ps ) ; } public void setTarget ( String target ) { if ( callee == null ) { init ( ) ; } callee . setTarget ( target ) ; targetSet = true ; } public void addConfiguredTarget ( Ant . TargetElement t ) { if ( callee == null ) { init ( ) ; } callee . addConfiguredTarget ( t ) ; targetSet = true ; } public void handleOutput ( String output ) { if ( callee != null ) { callee . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( callee != null ) { return callee . handleInput ( buffer , offset , length ) ; } return super . handleInput ( buffer , offset , length ) ; } public void handleFlush ( String output ) { if ( callee != null ) { callee . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( callee != null ) { callee . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( callee != null ) { callee . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } } 	0	['15', '3', '0', '9', '41', '0', '0', '9', '15', '0.678571429', '204', '1', '1', '0.725490196', '0.225', '1', '2', '12.33333333', '2', '1.5333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ClasspathUtils ; public abstract class DefBase extends AntlibDefinition { private ClassLoader createdLoader ; private ClasspathUtils . Delegate cpDelegate ; protected boolean hasCpDelegate ( ) { return cpDelegate != null ; } public void setReverseLoader ( boolean reverseLoader ) { getDelegate ( ) . setReverseLoader ( reverseLoader ) ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public Path getClasspath ( ) { return getDelegate ( ) . getClasspath ( ) ; } public boolean isReverseLoader ( ) { return getDelegate ( ) . isReverseLoader ( ) ; } public String getLoaderId ( ) { return getDelegate ( ) . getClassLoadId ( ) ; } public String getClasspathId ( ) { return getDelegate ( ) . getClassLoadId ( ) ; } public void setClasspath ( Path classpath ) { getDelegate ( ) . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return getDelegate ( ) . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { getDelegate ( ) . setClasspathref ( r ) ; } public void setLoaderRef ( Reference r ) { getDelegate ( ) . setLoaderRef ( r ) ; } protected ClassLoader createLoader ( ) { if ( getAntlibClassLoader ( ) != null && cpDelegate == null ) { return getAntlibClassLoader ( ) ; } if ( createdLoader == null ) { createdLoader = getDelegate ( ) . getClassLoader ( ) ; ( ( AntClassLoader ) createdLoader ) . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } return createdLoader ; } public void init ( ) throws BuildException { super . init ( ) ; } private ClasspathUtils . Delegate getDelegate ( ) { if ( cpDelegate == null ) { cpDelegate = ClasspathUtils . getDelegate ( this ) ; } return cpDelegate ; } } 	0	['14', '4', '3', '11', '29', '85', '3', '8', '11', '0.576923077', '108', '1', '1', '0.759259259', '0.321428571', '0', '0', '6.571428571', '4', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class P4Label extends P4Base { protected String name ; protected String desc ; protected String lock ; public void setName ( String name ) { this . name = name ; } public void setDesc ( String desc ) { this . desc = desc ; } public void setLock ( String lock ) { this . lock = lock ; } public void execute ( ) throws BuildException { log ( "P4Label exec:" , Project . MSG_INFO ) ; if ( P4View == null || P4View . length ( ) < 1 ) { log ( "View not set, assuming //depot/..." , Project . MSG_WARN ) ; P4View = "//depot/..." ; } else { P4View = StringUtils . replace ( P4View , ":" , "\n\t" ) ; P4View = StringUtils . replace ( P4View , ";" , "\n\t" ) ; } if ( desc == null || desc . length ( ) < 1 ) { log ( "Label Description not set, assuming 'AntLabel'" , Project . MSG_WARN ) ; desc = "AntLabel" ; } if ( lock != null && ! lock . equalsIgnoreCase ( "locked" ) ) { log ( "lock attribute invalid - ignoring" , Project . MSG_WARN ) ; } if ( name == null || name . length ( ) < 1 ) { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy.MM.dd-hh:mm" ) ; Date now = new Date ( ) ; name = "AntLabel-" + formatter . format ( now ) ; log ( "name not set, assuming '" + name + "'" , Project . MSG_WARN ) ; } String newLabel = "Label: " + name + "\nDescription: " + desc + "\nOptions: unlocked" + "\nView: \n\t" + P4View ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ; handler . setOutput ( newLabel ) ; execP4Command ( "label -i" , handler ) ; execP4Command ( "labelsync -l " + name , new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ) ; log ( "Created Label " + name + " (" + desc + ") with view:\n" + P4View , Project . MSG_INFO ) ; if ( lock != null && lock . equalsIgnoreCase ( "locked" ) ) { log ( "Modifying lock status to 'locked'" , Project . MSG_INFO ) ; final StringBuffer labelSpec = new StringBuffer ( ) ; handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; if ( util . match ( "/^Options:/" , line ) ) { line = "Options: " + lock ; } labelSpec . append ( line + "\n" ) ; } } ; execP4Command ( "label -o " + name , handler ) ; log ( labelSpec . toString ( ) , Project . MSG_DEBUG ) ; log ( "Now locking label..." , Project . MSG_VERBOSE ) ; handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ; handler . setOutput ( labelSpec . toString ( ) ) ; execP4Command ( "label -i" , handler ) ; } } } 	0	['5', '4', '0', '8', '23', '4', '4', '8', '5', '0.75', '249', '1', '0', '0.927272727', '0.8', '2', '2', '48.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { String FILE_PROTOCOL_PREFIX = "file://" ; void setStylesheet ( File stylesheet ) throws Exception ; void addParam ( String name , String expression ) throws Exception ; void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import org . apache . tools . ant . types . FileSet ; public class BCFileSet extends FileSet { public BCFileSet ( ) { } public BCFileSet ( FileSet fs ) { super ( fs ) ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } FileResourceIterator result = new FileResourceIterator ( getDir ( ) ) ; result . addFiles ( getDirectoryScanner ( ) . getIncludedFiles ( ) ) ; result . addFiles ( getDirectoryScanner ( ) . getIncludedDirectories ( ) ) ; return result ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( ) . getIncludedFilesCount ( ) + getDirectoryScanner ( ) . getIncludedDirsCount ( ) ; } } 	0	['4', '5', '0', '5', '19', '6', '0', '5', '4', '2', '57', '0', '0', '0.978494624', '0.625', '2', '4', '13.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . BuildException ; public class ExtraAttribute { private String name ; private String value ; public void setName ( final String name ) { this . name = name ; } public void setValue ( final String value ) { this . value = value ; } String getName ( ) { return name ; } String getValue ( ) { return value ; } public void validate ( ) throws BuildException { if ( null == name ) { final String message = "Missing name from parameter." ; throw new BuildException ( message ) ; } else if ( null == value ) { final String message = "Missing value from parameter " + name + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '4', '0.6', '53', '1', '0', '0', '0.666666667', '0', '0', '7.5', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class MSVSS extends Task implements MSVSSConstants { private String ssDir = null ; private String vssLogin = null ; private String vssPath = null ; private String serverPath = null ; private String version = null ; private String date = null ; private String label = null ; private String autoResponse = null ; private String localPath = null ; private String comment = null ; private String fromLabel = null ; private String toLabel = null ; private String outputFileName = null ; private String user = null ; private String fromDate = null ; private String toDate = null ; private String style = null ; private boolean quiet = false ; private boolean recursive = false ; private boolean writable = false ; private boolean failOnError = true ; private boolean getLocalCopy = true ; private int numDays = Integer . MIN_VALUE ; private DateFormat dateFormat = DateFormat . getDateInstance ( DateFormat . SHORT ) ; private CurrentModUpdated timestamp = null ; private WritableFiles writableFiles = null ; abstract Commandline buildCmdLine ( ) ; public final void setSsdir ( String dir ) { this . ssDir = FileUtils . translatePath ( dir ) ; } public final void setLogin ( final String vssLogin ) { this . vssLogin = vssLogin ; } public final void setVsspath ( final String vssPath ) { String projectPath ; if ( vssPath . startsWith ( "vss://" ) ) { projectPath = vssPath . substring ( 5 ) ; } else { projectPath = vssPath ; } if ( projectPath . startsWith ( PROJECT_PREFIX ) ) { this . vssPath = projectPath ; } else { this . vssPath = PROJECT_PREFIX + projectPath ; } } public final void setServerpath ( final String serverPath ) { this . serverPath = serverPath ; } public final void setFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } public void execute ( ) throws BuildException { int result = 0 ; Commandline commandLine = buildCmdLine ( ) ; result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnError ( ) ) { String msg = "Failed executing: " + formatCommandLine ( commandLine ) + " With a return code of " + result ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected void setInternalComment ( final String comment ) { this . comment = comment ; } protected void setInternalAutoResponse ( final String autoResponse ) { this . autoResponse = autoResponse ; } protected void setInternalDate ( final String date ) { this . date = date ; } protected void setInternalDateFormat ( final DateFormat dateFormat ) { this . dateFormat = dateFormat ; } protected void setInternalFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } protected void setInternalFromDate ( final String fromDate ) { this . fromDate = fromDate ; } protected void setInternalFromLabel ( final String fromLabel ) { this . fromLabel = fromLabel ; } protected void setInternalLabel ( final String label ) { this . label = label ; } protected void setInternalLocalPath ( final String localPath ) { this . localPath = localPath ; } protected void setInternalNumDays ( final int numDays ) { this . numDays = numDays ; } protected void setInternalOutputFilename ( final String outputFileName ) { this . outputFileName = outputFileName ; } protected void setInternalQuiet ( final boolean quiet ) { this . quiet = quiet ; } protected void setInternalRecursive ( final boolean recursive ) { this . recursive = recursive ; } protected void setInternalStyle ( final String style ) { this . style = style ; } protected void setInternalToDate ( final String toDate ) { this . toDate = toDate ; } protected void setInternalToLabel ( final String toLabel ) { this . toLabel = toLabel ; } protected void setInternalUser ( final String user ) { this . user = user ; } protected void setInternalVersion ( final String version ) { this . version = version ; } protected void setInternalWritable ( final boolean writable ) { this . writable = writable ; } protected void setInternalFileTimeStamp ( final CurrentModUpdated timestamp ) { this . timestamp = timestamp ; } protected void setInternalWritableFiles ( final WritableFiles writableFiles ) { this . writableFiles = writableFiles ; } protected void setInternalGetLocalCopy ( final boolean getLocalCopy ) { this . getLocalCopy = getLocalCopy ; } protected String getSSCommand ( ) { if ( ssDir == null ) { return SS_EXE ; } return ssDir . endsWith ( File . separator ) ? ssDir + SS_EXE : ssDir + File . separator + SS_EXE ; } protected String getVsspath ( ) { return vssPath ; } protected String getQuiet ( ) { return quiet ? FLAG_QUIET : "" ; } protected String getRecursive ( ) { return recursive ? FLAG_RECURSION : "" ; } protected String getWritable ( ) { return writable ? FLAG_WRITABLE : "" ; } protected String getLabel ( ) { String shortLabel = "" ; if ( label != null && label . length ( ) > 0 ) { shortLabel = FLAG_LABEL + getShortLabel ( ) ; } return shortLabel ; } private String getShortLabel ( ) { String shortLabel ; if ( label != null && label . length ( ) > 31 ) { shortLabel = this . label . substring ( 0 , 30 ) ; log ( "Label is longer than 31 characters, truncated to: " + shortLabel , Project . MSG_WARN ) ; } else { shortLabel = label ; } return shortLabel ; } protected String getStyle ( ) { return style != null ? style : "" ; } protected String getVersionDateLabel ( ) { String versionDateLabel = "" ; if ( version != null ) { versionDateLabel = FLAG_VERSION + version ; } else if ( date != null ) { versionDateLabel = FLAG_VERSION_DATE + date ; } else { String shortLabel = getShortLabel ( ) ; if ( shortLabel != null && ! shortLabel . equals ( "" ) ) { versionDateLabel = FLAG_VERSION_LABEL + shortLabel ; } } return versionDateLabel ; } protected String getVersion ( ) { return version != null ? FLAG_VERSION + version : "" ; } protected String getLocalpath ( ) { String lclPath = "" ; if ( localPath != null ) { File dir = getProject ( ) . resolveFile ( localPath ) ; if ( ! dir . exists ( ) ) { boolean done = dir . mkdirs ( ) ; if ( ! done ) { String msg = "Directory " + localPath + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } getProject ( ) . log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath ; } return lclPath ; } protected String getComment ( ) { return comment != null ? FLAG_COMMENT + comment : FLAG_COMMENT + "-" ; } protected String getAutoresponse ( ) { if ( autoResponse == null ) { return FLAG_AUTORESPONSE_DEF ; } else if ( autoResponse . equalsIgnoreCase ( "Y" ) ) { return FLAG_AUTORESPONSE_YES ; } else if ( autoResponse . equalsIgnoreCase ( "N" ) ) { return FLAG_AUTORESPONSE_NO ; } else { return FLAG_AUTORESPONSE_DEF ; } } protected String getLogin ( ) { return vssLogin != null ? FLAG_LOGIN + vssLogin : "" ; } protected String getOutput ( ) { return outputFileName != null ? FLAG_OUTPUT + outputFileName : "" ; } protected String getUser ( ) { return user != null ? FLAG_USER + user : "" ; } protected String getVersionLabel ( ) { if ( fromLabel == null && toLabel == null ) { return "" ; } if ( fromLabel != null && toLabel != null ) { if ( fromLabel . length ( ) > 31 ) { fromLabel = fromLabel . substring ( 0 , 30 ) ; log ( "FromLabel is longer than 31 characters, truncated to: " + fromLabel , Project . MSG_WARN ) ; } if ( toLabel . length ( ) > 31 ) { toLabel = toLabel . substring ( 0 , 30 ) ; log ( "ToLabel is longer than 31 characters, truncated to: " + toLabel , Project . MSG_WARN ) ; } return FLAG_VERSION_LABEL + toLabel + VALUE_FROMLABEL + fromLabel ; } else if ( fromLabel != null ) { if ( fromLabel . length ( ) > 31 ) { fromLabel = fromLabel . substring ( 0 , 30 ) ; log ( "FromLabel is longer than 31 characters, truncated to: " + fromLabel , Project . MSG_WARN ) ; } return FLAG_VERSION + VALUE_FROMLABEL + fromLabel ; } else { if ( toLabel . length ( ) > 31 ) { toLabel = toLabel . substring ( 0 , 30 ) ; log ( "ToLabel is longer than 31 characters, truncated to: " + toLabel , Project . MSG_WARN ) ; } return FLAG_VERSION_LABEL + toLabel ; } } protected String getVersionDate ( ) throws BuildException { if ( fromDate == null && toDate == null && numDays == Integer . MIN_VALUE ) { return "" ; } if ( fromDate != null && toDate != null ) { return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE + fromDate ; } else if ( toDate != null && numDays != Integer . MIN_VALUE ) { try { return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE + calcDate ( toDate , numDays ) ; } catch ( ParseException ex ) { String msg = "Error parsing date: " + toDate ; throw new BuildException ( msg , getLocation ( ) ) ; } } else if ( fromDate != null && numDays != Integer . MIN_VALUE ) { try { return FLAG_VERSION_DATE + calcDate ( fromDate , numDays ) + VALUE_FROMDATE + fromDate ; } catch ( ParseException ex ) { String msg = "Error parsing date: " + fromDate ; throw new BuildException ( msg , getLocation ( ) ) ; } } else { return fromDate != null ? FLAG_VERSION + VALUE_FROMDATE + fromDate : FLAG_VERSION_DATE + toDate ; } } protected String getGetLocalCopy ( ) { return ( ! getLocalCopy ) ? FLAG_NO_GET : "" ; } private boolean getFailOnError ( ) { return getWritableFiles ( ) . equals ( WRITABLE_SKIP ) ? false : failOnError ; } public String getFileTimeStamp ( ) { if ( timestamp == null ) { return "" ; } else if ( timestamp . getValue ( ) . equals ( TIME_MODIFIED ) ) { return FLAG_FILETIME_MODIFIED ; } else if ( timestamp . getValue ( ) . equals ( TIME_UPDATED ) ) { return FLAG_FILETIME_UPDATED ; } else { return FLAG_FILETIME_DEF ; } } public String getWritableFiles ( ) { if ( writableFiles == null ) { return "" ; } else if ( writableFiles . getValue ( ) . equals ( WRITABLE_REPLACE ) ) { return FLAG_REPLACE_WRITABLE ; } else if ( writableFiles . getValue ( ) . equals ( WRITABLE_SKIP ) ) { failOnError = false ; return FLAG_SKIP_WRITABLE ; } else { return "" ; } } private int run ( Commandline cmd ) { try { Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; if ( serverPath != null ) { String [ ] env = exe . getEnvironment ( ) ; if ( env == null ) { env = new String [ 0 ] ; } String [ ] newEnv = new String [ env . length + 1 ] ; System . arraycopy ( env , 0 , newEnv , 0 , env . length ) ; newEnv [ env . length ] = "SSDIR=" + serverPath ; exe . setEnvironment ( newEnv ) ; } exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; exe . setVMLauncher ( false ) ; return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private String calcDate ( String startDate , int daysToAdd ) throws ParseException { Calendar calendar = new GregorianCalendar ( ) ; Date currentDate = dateFormat . parse ( startDate ) ; calendar . setTime ( currentDate ) ; calendar . add ( Calendar . DATE , daysToAdd ) ; return dateFormat . format ( calendar . getTime ( ) ) ; } private String formatCommandLine ( Commandline cmd ) { StringBuffer sBuff = new StringBuffer ( cmd . toString ( ) ) ; int indexUser = sBuff . substring ( 0 ) . indexOf ( FLAG_LOGIN ) ; if ( indexUser > 0 ) { int indexPass = sBuff . substring ( 0 ) . indexOf ( "," , indexUser ) ; int indexAfterPass = sBuff . substring ( 0 ) . indexOf ( " " , indexPass ) ; for ( int i = indexPass + 1 ; i < indexAfterPass ; i ++ ) { sBuff . setCharAt ( i , '*' ) ; } } return sBuff . toString ( ) ; } public static class CurrentModUpdated extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { TIME_CURRENT , TIME_MODIFIED , TIME_UPDATED } ; } } public static class WritableFiles extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { WRITABLE_REPLACE , WRITABLE_SKIP , WRITABLE_FAIL } ; } } } 	0	['55', '3', '8', '20', '106', '1313', '8', '12', '9', '0.956552707', '1133', '1', '2', '0.406593407', '0.195454545', '0', '0', '19.12727273', '10', '1.8545', '0']
package org . apache . tools . ant . util . regexp ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . tools . ant . BuildException ; public class Jdk14RegexpRegexp extends Jdk14RegexpMatcher implements Regexp { public Jdk14RegexpRegexp ( ) { super ( ) ; } protected int getSubsOptions ( int options ) { int subsOptions = REPLACE_FIRST ; if ( RegexpUtil . hasFlag ( options , REPLACE_ALL ) ) { subsOptions = REPLACE_ALL ; } return subsOptions ; } public String substitute ( String input , String argument , int options ) throws BuildException { StringBuffer subst = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '$' ) { subst . append ( '\\' ) ; subst . append ( '$' ) ; } else if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { subst . append ( "$" ) . append ( value ) ; } else { subst . append ( c ) ; } } else { subst . append ( '\\' ) ; } } else { subst . append ( c ) ; } } argument = subst . toString ( ) ; int sOptions = getSubsOptions ( options ) ; Pattern p = getCompiledPattern ( options ) ; StringBuffer sb = new StringBuffer ( ) ; Matcher m = p . matcher ( input ) ; if ( RegexpUtil . hasFlag ( sOptions , REPLACE_ALL ) ) { sb . append ( m . replaceAll ( argument ) ) ; } else { boolean res = m . find ( ) ; if ( res ) { m . appendReplacement ( sb , argument ) ; m . appendTail ( sb ) ; } else { sb . append ( input ) ; } } return sb . toString ( ) ; } } 	0	['3', '2', '0', '4', '19', '3', '0', '4', '2', '2', '136', '0', '0', '0.8', '0.666666667', '0', '0', '44.33333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . DeweyDecimal ; public class AntVersion implements Condition { private String atLeast = null ; private String exactly = null ; public boolean eval ( ) throws BuildException { validate ( ) ; DeweyDecimal actual = getVersion ( ) ; if ( null != atLeast ) { return actual . isGreaterThanOrEqual ( new DeweyDecimal ( atLeast ) ) ; } if ( null != exactly ) { return actual . isEqual ( new DeweyDecimal ( exactly ) ) ; } return false ; } private void validate ( ) throws BuildException { if ( atLeast != null && exactly != null ) { throw new BuildException ( "Only one of atleast or exactly may be set." ) ; } if ( null == atLeast && null == exactly ) { throw new BuildException ( "One of atleast or exactly must be set." ) ; } try { if ( atLeast != null ) { new DeweyDecimal ( atLeast ) ; } else { new DeweyDecimal ( exactly ) ; } } catch ( NumberFormatException e ) { throw new BuildException ( "The argument is not a Dewey Decimal eg 1.1.0" ) ; } } private DeweyDecimal getVersion ( ) { Project p = new Project ( ) ; p . init ( ) ; char [ ] versionString = p . getProperty ( "ant.version" ) . toCharArray ( ) ; StringBuffer sb = new StringBuffer ( ) ; boolean foundFirstDigit = false ; for ( int i = 0 ; i < versionString . length ; i ++ ) { if ( Character . isDigit ( versionString [ i ] ) ) { sb . append ( versionString [ i ] ) ; foundFirstDigit = true ; } if ( versionString [ i ] == '.' && foundFirstDigit ) { sb . append ( versionString [ i ] ) ; } if ( Character . isLetter ( versionString [ i ] ) && foundFirstDigit ) { break ; } } return new DeweyDecimal ( sb . toString ( ) ) ; } public String getAtLeast ( ) { return atLeast ; } public void setAtLeast ( String atLeast ) { this . atLeast = atLeast ; } public String getExactly ( ) { return exactly ; } public void setExactly ( String exactly ) { this . exactly = exactly ; } } 	0	['8', '1', '0', '4', '22', '0', '0', '4', '6', '0.428571429', '169', '1', '0', '0', '0.625', '0', '0', '19.875', '7', '1.625', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class LazyFileOutputStream extends OutputStream { private FileOutputStream fos ; private File file ; private boolean append ; private boolean alwaysCreate ; private boolean opened = false ; private boolean closed = false ; public LazyFileOutputStream ( String name ) { this ( name , false ) ; } public LazyFileOutputStream ( String name , boolean append ) { this ( new File ( name ) , append ) ; } public LazyFileOutputStream ( File f ) { this ( f , false ) ; } public LazyFileOutputStream ( File file , boolean append ) { this ( file , append , false ) ; } public LazyFileOutputStream ( File file , boolean append , boolean alwaysCreate ) { this . file = file ; this . append = append ; this . alwaysCreate = alwaysCreate ; } public void open ( ) throws IOException { ensureOpened ( ) ; } public synchronized void close ( ) throws IOException { if ( alwaysCreate && ! closed ) { ensureOpened ( ) ; } if ( opened ) { fos . close ( ) ; } closed = true ; } public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } public synchronized void write ( byte [ ] b , int offset , int len ) throws IOException { ensureOpened ( ) ; fos . write ( b , offset , len ) ; } public synchronized void write ( int b ) throws IOException { ensureOpened ( ) ; fos . write ( b ) ; } private synchronized void ensureOpened ( ) throws IOException { if ( closed ) { throw new IOException ( file + " has already been closed." ) ; } if ( ! opened ) { fos = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; opened = true ; } } } 	0	['11', '2', '0', '1', '23', '39', '1', '0', '10', '0.483333333', '136', '1', '0', '0.454545455', '0.348484848', '1', '1', '10.81818182', '1', '0.5455', '0']
package org . apache . tools . ant . util ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; public class LoaderUtils { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public static void setContextClassLoader ( ClassLoader loader ) { Thread currentThread = Thread . currentThread ( ) ; currentThread . setContextClassLoader ( loader ) ; } public static ClassLoader getContextClassLoader ( ) { Thread currentThread = Thread . currentThread ( ) ; return currentThread . getContextClassLoader ( ) ; } public static boolean isContextLoaderAvailable ( ) { return true ; } private static File normalizeSource ( File source ) { if ( source != null ) { try { source = FILE_UTILS . normalize ( source . getAbsolutePath ( ) ) ; } catch ( BuildException e ) { } } return source ; } public static File getClassSource ( Class c ) { return normalizeSource ( Locator . getClassSource ( c ) ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = LoaderUtils . class . getClassLoader ( ) ; } return normalizeSource ( Locator . getResourceSource ( c , resource ) ) ; } public static String classNameToResource ( String className ) { return className . replace ( '.' , '/' ) + ".class" ; } public static boolean classExists ( ClassLoader loader , String className ) { return loader . getResource ( classNameToResource ( className ) ) != null ; } } 	0	['10', '1', '0', '10', '29', '43', '7', '3', '8', '0.833333333', '91', '0.5', '1', '0', '0.2', '0', '0', '7.9', '3', '1.2', '0']
package org . apache . tools . ant . loader ; import org . apache . tools . ant . AntClassLoader ; public class AntClassLoader2 extends AntClassLoader { public AntClassLoader2 ( ) { } } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import java . io . IOException ; public class ForkingSunRmic extends DefaultRmicAdapter { public static final String COMPILER_NAME = "forking" ; public boolean execute ( ) throws BuildException { Rmic owner = getRmic ( ) ; Commandline cmd = setupRmicCommand ( ) ; Project project = owner . getProject ( ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( getExecutableName ( ) ) ) ; String [ ] args = cmd . getCommandline ( ) ; try { Execute exe = new Execute ( new LogStreamHandler ( owner , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( args ) ; exe . execute ( ) ; return ! exe . isFailure ( ) ; } catch ( IOException exception ) { throw new BuildException ( "Error running " + getExecutableName ( ) + " -maybe it is not on the path" , exception ) ; } } protected String getExecutableName ( ) { return SunRmic . RMIC_EXECUTABLE ; } } 	0	['3', '2', '1', '12', '22', '3', '2', '10', '2', '1.5', '72', '0', '0', '0.866666667', '1', '0', '0', '22.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . util ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; public final class StringUtils { private StringUtils ( ) { } public static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static Vector lineSplit ( String data ) { return split ( data , '\n' ) ; } public static Vector split ( String data , int ch ) { Vector elems = new Vector ( ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( ch , i ) ) != - 1 ) { String elem = data . substring ( i , pos ) ; elems . addElement ( elem ) ; i = pos + 1 ; } elems . addElement ( data . substring ( i ) ) ; return elems ; } public static String replace ( String data , String from , String to ) { StringBuffer buf = new StringBuffer ( data . length ( ) ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( from , i ) ) != - 1 ) { buf . append ( data . substring ( i , pos ) ) . append ( to ) ; i = pos + from . length ( ) ; } buf . append ( data . substring ( i ) ) ; return buf . toString ( ) ; } public static String getStackTrace ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; pw . close ( ) ; return sw . toString ( ) ; } public static boolean endsWith ( StringBuffer buffer , String suffix ) { if ( suffix . length ( ) > buffer . length ( ) ) { return false ; } int endIndex = suffix . length ( ) - 1 ; int bufferIndex = buffer . length ( ) - 1 ; while ( endIndex >= 0 ) { if ( buffer . charAt ( bufferIndex ) != suffix . charAt ( endIndex ) ) { return false ; } bufferIndex -- ; endIndex -- ; } return true ; } public static String resolveBackSlash ( String input ) { StringBuffer b = new StringBuffer ( ) ; boolean backSlashSeen = false ; for ( int i = 0 ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; if ( ! backSlashSeen ) { if ( c == '\\' ) { backSlashSeen = true ; } else { b . append ( c ) ; } } else { switch ( c ) { case '\\' : b . append ( ( char ) '\\' ) ; break ; case 'n' : b . append ( ( char ) '\n' ) ; break ; case 'r' : b . append ( ( char ) '\r' ) ; break ; case 't' : b . append ( ( char ) '\t' ) ; break ; case 'f' : b . append ( ( char ) '\f' ) ; break ; case 's' : b . append ( " \t\n\r\f" ) ; break ; default : b . append ( c ) ; } backSlashSeen = false ; } } return b . toString ( ) ; } public static long parseHumanSizes ( String humanSize ) throws Exception { final long KILOBYTE = 1024 ; final long MEGABYTE = KILOBYTE * 1024 ; final long GIGABYTE = MEGABYTE * 1024 ; final long TERABYTE = GIGABYTE * 1024 ; final long PETABYTE = TERABYTE * 1024 ; if ( ! Character . isDigit ( humanSize . charAt ( humanSize . length ( ) - 1 ) ) ) { char c = humanSize . charAt ( humanSize . length ( ) - 1 ) ; long value = Long . valueOf ( humanSize . substring ( 0 , humanSize . length ( ) - 1 ) ) . longValue ( ) ; switch ( c ) { case 'K' : return value * KILOBYTE ; case 'M' : return value * MEGABYTE ; case 'G' : return value * GIGABYTE ; case 'T' : return value * TERABYTE ; case 'P' : return value * PETABYTE ; default : return value ; } } else { return Long . parseLong ( humanSize ) ; } } } 	0	['9', '1', '0', '32', '36', '36', '32', '0', '7', '1.104166667', '281', '0.833333333', '0', '0', '0.25', '0', '0', '29.55555556', '11', '3', '0']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public void setName ( final String name ) { this . name = name ; } public void setType ( final String type ) { this . type = type ; } public void setValue ( final String value ) { this . value = value ; } public String getName ( ) { return name ; } public String getType ( ) { return type ; } public String getValue ( ) { return value ; } } 	0	['7', '1', '0', '24', '8', '3', '24', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import org . apache . tools . ant . BuildException ; public class Jdk14RegexpMatcher implements RegexpMatcher { private String pattern ; public Jdk14RegexpMatcher ( ) { } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return pattern ; } protected Pattern getCompiledPattern ( int options ) throws BuildException { int cOptions = getCompilerOptions ( options ) ; try { Pattern p = Pattern . compile ( this . pattern , cOptions ) ; return p ; } catch ( PatternSyntaxException e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { try { Pattern p = getCompiledPattern ( options ) ; return p . matcher ( input ) . find ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { Pattern p = getCompiledPattern ( options ) ; Matcher matcher = p . matcher ( input ) ; if ( ! matcher . find ( ) ) { return null ; } Vector v = new Vector ( ) ; int cnt = matcher . groupCount ( ) ; for ( int i = 0 ; i <= cnt ; i ++ ) { String match = matcher . group ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = Pattern . UNIX_LINES ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= Pattern . CASE_INSENSITIVE ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= Pattern . MULTILINE ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= Pattern . DOTALL ; } return cOptions ; } } 	0	['9', '1', '1', '4', '19', '30', '1', '3', '7', '0.5', '130', '1', '0', '0', '0.666666667', '0', '0', '13.33333333', '4', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . LineOrientedOutputStream ; public class LogOutputStream extends LineOrientedOutputStream { private ProjectComponent pc ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this ( ( ProjectComponent ) task , level ) ; } public LogOutputStream ( ProjectComponent pc , int level ) { this . pc = pc ; this . level = level ; } protected void processBuffer ( ) { try { super . processBuffer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( "Impossible IOException caught: " + e ) ; } } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { pc . log ( line , level ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['6', '3', '2', '20', '13', '7', '17', '3', '3', '0.4', '56', '1', '1', '0.733333333', '0.433333333', '1', '4', '8', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public interface JspMangler { String mapJspToJavaName ( File jspFile ) ; String mapPath ( String path ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public class Ildasm extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File sourceFile ; private File destFile ; private boolean progressBar = false ; private String encoding ; private boolean bytes = false ; private boolean linenumbers = false ; private boolean rawExceptionHandling = false ; private boolean showSource = false ; private boolean quoteallnames = false ; private boolean header = false ; private boolean assembler = true ; private boolean metadata = false ; private String visibility ; private String item ; private String executable = "ildasm" ; private File resourceDir ; public void setResourceDir ( File resourceDir ) { this . resourceDir = resourceDir ; } public void setExecutable ( String executable ) { this . executable = executable ; } public void setEncoding ( EncodingTypes encoding ) { this . encoding = encoding . getValue ( ) ; } public void setAssembler ( boolean assembler ) { this . assembler = assembler ; } public void setBytes ( boolean bytes ) { this . bytes = bytes ; } public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setHeader ( boolean header ) { this . header = header ; } public void setItem ( String item ) { this . item = item ; } public void setLinenumbers ( boolean linenumbers ) { this . linenumbers = linenumbers ; } public void setMetadata ( boolean metadata ) { this . metadata = metadata ; } public void setProgressBar ( boolean progressBar ) { this . progressBar = progressBar ; } public void setQuoteallnames ( boolean quoteallnames ) { this . quoteallnames = quoteallnames ; } public void setRawExceptionHandling ( boolean rawExceptionHandling ) { this . rawExceptionHandling = rawExceptionHandling ; } public void setShowSource ( boolean showSource ) { this . showSource = showSource ; } public void setSourceFile ( File sourceFile ) { this . sourceFile = sourceFile ; } public void setSrcFile ( File sourceFile ) { setSourceFile ( sourceFile ) ; } public void setVisibility ( String visibility ) { this . visibility = visibility ; } private void validate ( ) { if ( sourceFile == null || ! sourceFile . exists ( ) || ! sourceFile . isFile ( ) ) { throw new BuildException ( "invalid source" ) ; } if ( destFile == null || destFile . isDirectory ( ) ) { throw new BuildException ( "invalid dest" ) ; } if ( resourceDir != null && ( ! resourceDir . exists ( ) || ! resourceDir . isDirectory ( ) ) ) { throw new BuildException ( "invalid resource directory" ) ; } } private boolean isDisassemblyNeeded ( ) { if ( ! destFile . exists ( ) ) { log ( "Destination file does not exist: a build is required" , Project . MSG_VERBOSE ) ; return true ; } long sourceTime = sourceFile . lastModified ( ) ; long destTime = destFile . lastModified ( ) ; if ( sourceTime > ( destTime + FILE_UTILS . getFileTimestampGranularity ( ) ) ) { log ( "Source file is newer than the dest file: a rebuild is required" , Project . MSG_VERBOSE ) ; return true ; } else { log ( "The .il file is up to date" , Project . MSG_VERBOSE ) ; return false ; } } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; if ( ! isDisassemblyNeeded ( ) ) { return ; } NetCommand command = new NetCommand ( this , "ildasm" , executable ) ; command . setFailOnError ( true ) ; command . addArgument ( "/text" ) ; command . addArgument ( "/out=" + destFile . toString ( ) ) ; if ( ! progressBar ) { command . addArgument ( "/nobar" ) ; } if ( linenumbers ) { command . addArgument ( "/linenum" ) ; } if ( showSource ) { command . addArgument ( "/source" ) ; } if ( quoteallnames ) { command . addArgument ( "/quoteallnames" ) ; } if ( header ) { command . addArgument ( "/header" ) ; } if ( ! assembler ) { command . addArgument ( "/noil" ) ; } if ( metadata ) { command . addArgument ( "/tokens" ) ; } command . addArgument ( "/item:" , item ) ; if ( rawExceptionHandling ) { command . addArgument ( "/raweh" ) ; } command . addArgument ( EncodingTypes . getEncodingOption ( encoding ) ) ; if ( bytes ) { command . addArgument ( "/bytes" ) ; } command . addArgument ( "/vis:" , visibility ) ; command . addArgument ( sourceFile . getAbsolutePath ( ) ) ; File execDir = resourceDir ; if ( execDir == null ) { execDir = destFile . getParentFile ( ) ; } command . setDirectory ( execDir ) ; try { command . runCommand ( ) ; } catch ( BuildException e ) { if ( destFile . exists ( ) ) { log ( "Deleting destination file as it may be corrupt" ) ; destFile . delete ( ) ; } throw e ; } } public static class EncodingTypes extends EnumeratedAttribute { public static final String UNICODE = "unicode" ; public static final String UTF8 = "utf8" ; public static final String ASCII = "ascii" ; public String [ ] getValues ( ) { return new String [ ] { ASCII , UTF8 , UNICODE , } ; } public static String getEncodingOption ( String enumValue ) { if ( UNICODE . equals ( enumValue ) ) { return "/unicode" ; } if ( UTF8 . equals ( enumValue ) ) { return "/utf8" ; } return null ; } } public static class VisibilityOptions extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "pub" , "pri" , "fam" , "asm" , "faa" , "foa" , "psc" , } ; } } } 	0	['22', '3', '0', '5', '47', '159', '0', '5', '19', '0.904761905', '365', '1', '1', '0.649122807', '0.361904762', '2', '2', '14.81818182', '9', '1.3636', '0']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . WeakHashMap ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean crSeen = false ; } private static final int MAX_SIZE = 1024 ; private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private WeakHashMap buffers = new WeakHashMap ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; bufferInfo . crSeen = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . crSeen = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( c == '\n' ) { bufferInfo . buffer . write ( cc ) ; processBuffer ( bufferInfo . buffer ) ; } else { if ( bufferInfo . crSeen ) { processBuffer ( bufferInfo . buffer ) ; } bufferInfo . buffer . write ( cc ) ; } bufferInfo . crSeen = ( c == '\r' ) ; if ( ! bufferInfo . crSeen && bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } protected void processFlush ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxFlush ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processFlush ( bufferInfo . buffer ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; BufferInfo bufferInfo = getBufferInfo ( ) ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { bufferInfo . buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['10', '2', '0', '3', '30', '27', '1', '2', '5', '0.761904762', '245', '1', '1', '0.357142857', '0.283333333', '1', '1', '22.8', '2', '1', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . IdentityStack ; public abstract class DataType extends ProjectComponent implements Cloneable { protected Reference ref ; protected boolean checked = true ; public boolean isReference ( ) { return ref != null ; } public void setRefid ( final Reference ref ) { this . ref = ref ; checked = false ; } protected String getDataTypeName ( ) { return ComponentHelper . getElementName ( getProject ( ) , this , true ) ; } protected void dieOnCircularReference ( ) { dieOnCircularReference ( getProject ( ) ) ; } protected void dieOnCircularReference ( Project p ) { if ( checked || ! isReference ( ) ) { return ; } dieOnCircularReference ( new IdentityStack ( this ) , p ) ; } protected void dieOnCircularReference ( final Stack stack , final Project project ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( project ) ; if ( o instanceof DataType ) { IdentityStack id = IdentityStack . getInstance ( stack ) ; if ( id . contains ( o ) ) { throw circularReference ( ) ; } else { id . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( id , project ) ; id . pop ( ) ; } } checked = true ; } public static void invokeCircularReferenceCheck ( DataType dt , Stack stk , Project p ) { dt . dieOnCircularReference ( stk , p ) ; } protected Object getCheckedRef ( ) { return getCheckedRef ( getProject ( ) ) ; } protected Object getCheckedRef ( Project p ) { return getCheckedRef ( getClass ( ) , getDataTypeName ( ) , p ) ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName ) { return getCheckedRef ( requiredClass , dataTypeName , getProject ( ) ) ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName , final Project project ) { if ( project == null ) { throw new BuildException ( "No Project specified" ) ; } dieOnCircularReference ( project ) ; Object o = ref . getReferencedObject ( project ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { log ( "Class " + o . getClass ( ) + " is not a subclass of " + requiredClass , Project . MSG_VERBOSE ) ; String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } return o ; } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one " + "attribute when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements " + "when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular " + "reference." ) ; } protected boolean isChecked ( ) { return checked ; } protected void setChecked ( final boolean checked ) { this . checked = checked ; } public Reference getRefid ( ) { return ref ; } protected void checkAttributesAllowed ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } protected void checkChildrenAllowed ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } } public String toString ( ) { String d = getDescription ( ) ; return d == null ? getDataTypeName ( ) : getDataTypeName ( ) + " " + d ; } public Object clone ( ) throws CloneNotSupportedException { DataType dt = ( DataType ) super . clone ( ) ; dt . setDescription ( getDescription ( ) ) ; if ( getRefid ( ) != null ) { dt . setRefid ( getRefid ( ) ) ; } dt . setChecked ( isChecked ( ) ) ; return dt ; } } 	0	['22', '2', '28', '37', '44', '183', '31', '6', '7', '0.523809524', '271', '1', '1', '0.3', '0.198863636', '1', '2', '11.22727273', '3', '1.3182', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . types . Commandline ; public class XNewRmic extends ForkingSunRmic { public static final String COMPILER_NAME = "xnew" ; public XNewRmic ( ) { } protected Commandline setupRmicCommand ( ) { String [ ] options = new String [ ] { "-Xnew" } ; Commandline commandline = super . setupRmicCommand ( options ) ; return commandline ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '2', '1', '2', '19', '0', '0', '0.9375', '1', '2', '2', '8', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public final class Enumerations { private Enumerations ( ) { } public static Enumeration fromArray ( Object [ ] array ) { return new ArrayEnumeration ( array ) ; } public static Enumeration fromCompound ( Enumeration [ ] enums ) { return new CompoundEnumeration ( enums ) ; } } class ArrayEnumeration implements Enumeration { private Object [ ] array ; private int pos ; public ArrayEnumeration ( Object [ ] array ) { this . array = array ; this . pos = 0 ; } public boolean hasMoreElements ( ) { return ( pos < array . length ) ; } public Object nextElement ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { Object o = array [ pos ] ; pos ++ ; return o ; } throw new NoSuchElementException ( ) ; } } class CompoundEnumeration implements Enumeration { private Enumeration [ ] enumArray ; private int index = 0 ; public CompoundEnumeration ( Enumeration [ ] enumarray ) { this . enumArray = enumarray ; } public boolean hasMoreElements ( ) { while ( index < enumArray . length ) { if ( enumArray [ index ] != null && enumArray [ index ] . hasMoreElements ( ) ) { return true ; } index ++ ; } return false ; } public Object nextElement ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { return enumArray [ index ] . nextElement ( ) ; } throw new NoSuchElementException ( ) ; } } 	0	['3', '1', '0', '3', '6', '3', '1', '2', '2', '2', '16', '0', '0', '0', '0.333333333', '0', '0', '4.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Nice extends Task { private Integer newPriority ; private String currentPriority ; public void execute ( ) throws BuildException { Thread self = Thread . currentThread ( ) ; int priority = self . getPriority ( ) ; if ( currentPriority != null ) { String current = Integer . toString ( priority ) ; getProject ( ) . setNewProperty ( currentPriority , current ) ; } if ( newPriority != null && priority != newPriority . intValue ( ) ) { try { self . setPriority ( newPriority . intValue ( ) ) ; } catch ( SecurityException e ) { log ( "Unable to set new priority -a security manager is in the way" , Project . MSG_WARN ) ; } catch ( IllegalArgumentException iae ) { throw new BuildException ( "Priority out of range" , iae ) ; } } } public void setCurrentPriority ( String currentPriority ) { this . currentPriority = currentPriority ; } public void setNewPriority ( int newPriority ) { if ( newPriority < Thread . MIN_PRIORITY || newPriority > Thread . MAX_PRIORITY ) { throw new BuildException ( "The thread priority is out of the range 1-10" ) ; } this . newPriority = new Integer ( newPriority ) ; } } 	0	['4', '3', '0', '3', '16', '2', '0', '3', '4', '0.666666667', '76', '1', '0', '0.925', '0.5', '1', '1', '17.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ScriptRunnerHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class Script extends Task { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public void execute ( ) throws BuildException { helper . getScriptRunner ( ) . executeScript ( "ANT" ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } public void setSrc ( String fileName ) { helper . setSrc ( new File ( fileName ) ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } public void setSetBeans ( boolean setBeans ) { helper . setSetBeans ( setBeans ) ; } } 	0	['11', '3', '0', '8', '26', '0', '0', '8', '11', '0', '76', '1', '1', '0.787234043', '0.287878788', '2', '2', '5.818181818', '1', '0.9091', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class DifferentSelector extends MappingSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean ignoreFileTimes = true ; private boolean ignoreContents = false ; public void setIgnoreFileTimes ( boolean ignoreFileTimes ) { this . ignoreFileTimes = ignoreFileTimes ; } public void setIgnoreContents ( boolean ignoreContents ) { this . ignoreContents = ignoreContents ; } protected boolean selectionTest ( File srcfile , File destfile ) { if ( srcfile . exists ( ) != destfile . exists ( ) ) { return true ; } if ( srcfile . length ( ) != destfile . length ( ) ) { return true ; } if ( ! ignoreFileTimes ) { boolean sameDate ; sameDate = destfile . lastModified ( ) >= srcfile . lastModified ( ) - granularity && destfile . lastModified ( ) <= srcfile . lastModified ( ) + granularity ; if ( ! sameDate ) { return true ; } } if ( ! ignoreContents ) { try { return ! FILE_UTILS . contentEquals ( srcfile , destfile ) ; } catch ( IOException e ) { throw new BuildException ( "while comparing " + srcfile + " and " + destfile , e ) ; } } else { return false ; } } } 	0	['5', '5', '0', '8', '16', '0', '5', '3', '3', '0.583333333', '105', '1', '1', '0.931818182', '0.583333333', '1', '1', '19.4', '9', '2.2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . util . Vector ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public final class DOMUtil { private DOMUtil ( ) { } public interface NodeFilter { boolean accept ( Node node ) ; } public static NodeList listChildNodes ( Node parent , NodeFilter filter , boolean recurse ) { NodeListImpl matches = new NodeListImpl ( ) ; NodeList children = parent . getChildNodes ( ) ; if ( children != null ) { final int len = children . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Node child = children . item ( i ) ; if ( filter . accept ( child ) ) { matches . addElement ( child ) ; } if ( recurse ) { NodeList recmatches = listChildNodes ( child , filter , recurse ) ; final int reclength = recmatches . getLength ( ) ; for ( int j = 0 ; j < reclength ; j ++ ) { matches . addElement ( recmatches . item ( i ) ) ; } } } } return matches ; } public static class NodeListImpl extends Vector implements NodeList { public int getLength ( ) { return size ( ) ; } public Node item ( int i ) { try { return ( Node ) elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } } public static String getNodeAttribute ( Node node , String name ) { if ( node instanceof Element ) { Element element = ( Element ) node ; return element . getAttribute ( name ) ; } return null ; } public static Element getChildByTagName ( Node parent , String tagname ) { if ( parent == null ) { return null ; } NodeList childList = parent . getChildNodes ( ) ; final int len = childList . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Node child = childList . item ( i ) ; if ( child != null && child . getNodeType ( ) == Node . ELEMENT_NODE && child . getNodeName ( ) . equals ( tagname ) ) { return ( Element ) child ; } } return null ; } public static Node importNode ( Node parent , Node child ) { Node copy = null ; final Document doc = parent . getOwnerDocument ( ) ; switch ( child . getNodeType ( ) ) { case Node . CDATA_SECTION_NODE : copy = doc . createCDATASection ( ( ( CDATASection ) child ) . getData ( ) ) ; break ; case Node . COMMENT_NODE : copy = doc . createComment ( ( ( Comment ) child ) . getData ( ) ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : copy = doc . createDocumentFragment ( ) ; break ; case Node . ELEMENT_NODE : final Element elem = doc . createElement ( ( ( Element ) child ) . getTagName ( ) ) ; copy = elem ; final NamedNodeMap attributes = child . getAttributes ( ) ; if ( attributes != null ) { final int size = attributes . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Attr attr = ( Attr ) attributes . item ( i ) ; elem . setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : copy = doc . createEntityReference ( child . getNodeName ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : final ProcessingInstruction pi = ( ProcessingInstruction ) child ; copy = doc . createProcessingInstruction ( pi . getTarget ( ) , pi . getData ( ) ) ; break ; case Node . TEXT_NODE : copy = doc . createTextNode ( ( ( Text ) child ) . getData ( ) ) ; break ; default : throw new IllegalStateException ( "Invalid node type: " + child . getNodeType ( ) ) ; } try { final NodeList children = child . getChildNodes ( ) ; if ( children != null ) { final int size = children . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Node newChild = children . item ( i ) ; if ( newChild != null ) { importNode ( copy , newChild ) ; } } } } catch ( DOMException ignored ) { } parent . appendChild ( copy ) ; return copy ; } } 	0	['5', '1', '0', '3', '41', '10', '1', '2', '4', '2', '241', '0', '0', '0', '0.36', '0', '0', '47.2', '7', '4.2', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; import java . io . FileInputStream ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import org . apache . tools . ant . BuildException ; public class DigestAlgorithm implements Algorithm { private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = 8 * 1024 ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void initMessageDigest ( ) { if ( messageDigest != null ) { return ; } if ( ( provider != null ) && ! "" . equals ( provider ) && ! "null" . equals ( provider ) ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } } } public boolean isValid ( ) { return "SHA" . equalsIgnoreCase ( algorithm ) || "MD5" . equalsIgnoreCase ( algorithm ) ; } public String getValue ( File file ) { initMessageDigest ( ) ; String checksum = null ; try { if ( ! file . canRead ( ) ) { return null ; } FileInputStream fis = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { messageDigest . reset ( ) ; fis = new FileInputStream ( file ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } checksum = checksumSb . toString ( ) ; } catch ( Exception e ) { return null ; } } catch ( Exception e ) { return null ; } return checksum ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['7', '1', '0', '3', '26', '0', '1', '2', '7', '0.5', '218', '1', '0', '0', '0.476190476', '0', '0', '29.57142857', '5', '2.2857', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; import java . util . TimeZone ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DOMUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class ChangeLogWriter { private static final SimpleDateFormat OUTPUT_DATE = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat OUTPUT_TIME = new SimpleDateFormat ( "HH:mm" ) ; private static final DOMElementWriter DOM_WRITER = new DOMElementWriter ( ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; OUTPUT_DATE . setTimeZone ( utc ) ; OUTPUT_TIME . setTimeZone ( utc ) ; } public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { try { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; Document doc = DOMUtils . newDocument ( ) ; Element root = doc . createElement ( "changelog" ) ; DOM_WRITER . openElement ( root , output , 0 , "\t" ) ; output . println ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( doc , output , entry ) ; } DOM_WRITER . closeElement ( root , output , 0 , "\t" , true ) ; output . flush ( ) ; output . close ( ) ; } catch ( IOException e ) { throw new org . apache . tools . ant . BuildException ( e ) ; } } private void printEntry ( Document doc , final PrintWriter output , final CVSEntry entry ) throws IOException { Element ent = doc . createElement ( "entry" ) ; DOMUtils . appendTextElement ( ent , "date" , OUTPUT_DATE . format ( entry . getDate ( ) ) ) ; DOMUtils . appendTextElement ( ent , "time" , OUTPUT_TIME . format ( entry . getDate ( ) ) ) ; DOMUtils . appendCDATAElement ( ent , "author" , entry . getAuthor ( ) ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; Element f = DOMUtils . createChildElement ( ent , "file" ) ; DOMUtils . appendCDATAElement ( f , "name" , file . getName ( ) ) ; DOMUtils . appendTextElement ( f , "revision" , file . getRevision ( ) ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { DOMUtils . appendTextElement ( f , "prevrevision" , previousRevision ) ; } } DOMUtils . appendCDATAElement ( ent , "msg" , entry . getComment ( ) ) ; DOM_WRITER . write ( ent , output , 1 , "\t" ) ; } } 	0	['4', '1', '0', '6', '33', '0', '1', '5', '2', '0.333333333', '157', '1', '1', '0', '0.533333333', '0', '0', '37.5', '2', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; public class JarLibDisplayTask extends Task { private File libraryFile ; private final Vector libraryFileSets = new Vector ( ) ; public void setFile ( final File file ) { this . libraryFile = file ; } public void addFileset ( final FileSet fileSet ) { libraryFileSets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { validate ( ) ; final LibraryDisplayer displayer = new LibraryDisplayer ( ) ; if ( ! libraryFileSets . isEmpty ( ) ) { final Iterator iterator = libraryFileSets . iterator ( ) ; while ( iterator . hasNext ( ) ) { final FileSet fileSet = ( FileSet ) iterator . next ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final File basedir = scanner . getBasedir ( ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { final File file = new File ( basedir , files [ i ] ) ; displayer . displayLibrary ( file ) ; } } } else { displayer . displayLibrary ( libraryFile ) ; } } private void validate ( ) throws BuildException { if ( null == libraryFile && libraryFileSets . isEmpty ( ) ) { final String message = "File attribute not specified." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . exists ( ) ) { final String message = "File '" + libraryFile + "' does not exist." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . isFile ( ) ) { final String message = "\'" + libraryFile + "\' is not a file." ; throw new BuildException ( message ) ; } } } 	0	['5', '3', '0', '6', '26', '0', '0', '6', '4', '0.375', '141', '1', '0', '0.902439024', '0.466666667', '0', '0', '26.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Task ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { System . err . println ( "As of Ant 1.2 released in October 2000, the " + "TaskOutputStream class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '10', '0', '0', '1', '1', '0', '67', '1', '1', '0.714285714', '0.666666667', '1', '1', '20.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Comparison ; public class Size implements ResourceSelector { private long size = - 1 ; private Comparison when = Comparison . EQUAL ; public void setSize ( long l ) { size = l ; } public long getSize ( ) { return size ; } public void setWhen ( Comparison c ) { when = c ; } public Comparison getWhen ( ) { return when ; } public boolean isSelected ( Resource r ) { long diff = r . getSize ( ) - size ; return when . evaluate ( diff == 0 ? 0 : ( int ) ( diff / Math . abs ( diff ) ) ) ; } } 	0	['6', '1', '0', '3', '10', '0', '0', '3', '6', '0.4', '52', '1', '1', '0', '0.375', '0', '0', '7.333333333', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class MajoritySelector extends BaseSelectorContainer { private boolean allowtie = true ; public MajoritySelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{majorityselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void setAllowtie ( boolean tiebreaker ) { allowtie = tiebreaker ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int yesvotes = 0 ; int novotes = 0 ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { yesvotes = yesvotes + 1 ; } else { novotes = novotes + 1 ; } } if ( yesvotes > novotes ) { return true ; } else if ( novotes > yesvotes ) { return false ; } return allowtie ; } } 	0	['4', '5', '0', '7', '15', '0', '6', '2', '4', '0.333333333', '77', '1', '0', '0.953846154', '0.4375', '1', '1', '18', '5', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . taskdefs . Execute ; public class IsFailure implements Condition { private int code ; public void setCode ( int c ) { code = c ; } public int getCode ( ) { return code ; } public boolean eval ( ) { return Execute . isFailure ( code ) ; } } 	0	['4', '1', '0', '2', '6', '0', '0', '2', '4', '0.333333333', '19', '1', '0', '0', '0.625', '0', '0', '3.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Field ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; abstract class XalanExecutor { private static final String PACKAGE = "org.apache.tools.ant.taskdefs.optional.junit." ; protected AggregateTransformer caller ; private void setCaller ( AggregateTransformer caller ) { this . caller = caller ; } protected final OutputStream getOutputStream ( ) throws IOException { if ( AggregateTransformer . FRAMES . equals ( caller . format ) ) { return new ByteArrayOutputStream ( ) ; } else { return new BufferedOutputStream ( new FileOutputStream ( new File ( caller . toDir , "junit-noframes.html" ) ) ) ; } } abstract void execute ( ) throws Exception ; static XalanExecutor newInstance ( AggregateTransformer caller ) throws BuildException { XalanExecutor executor = null ; try { Class clazz = Class . forName ( PACKAGE + "Xalan2Executor" ) ; executor = ( XalanExecutor ) clazz . newInstance ( ) ; } catch ( Exception xsltcApacheMissing ) { caller . task . log ( xsltcApacheMissing . toString ( ) ) ; throw new BuildException ( "Could not find xstlc nor xalan2 " + "in the classpath. Check " + "http://xml.apache.org/xalan-j" ) ; } String classNameImpl = executor . getImplementation ( ) ; String version = executor . getProcVersion ( classNameImpl ) ; caller . task . log ( "Using " + version , Project . MSG_VERBOSE ) ; executor . setCaller ( caller ) ; return executor ; } protected abstract String getImplementation ( ) ; protected abstract String getProcVersion ( String classNameImpl ) throws BuildException ; protected final String getXSLTCVersion ( String procVersionClassName ) throws ClassNotFoundException { Class procVersion = Class . forName ( procVersionClassName ) ; Package pkg = procVersion . getPackage ( ) ; return pkg . getName ( ) + " " + pkg . getImplementationTitle ( ) + " " + pkg . getImplementationVersion ( ) ; } protected final String getXalanVersion ( String procVersionClassName ) throws ClassNotFoundException { Class procVersion = Class . forName ( procVersionClassName ) ; String pkg = procVersion . getPackage ( ) . getName ( ) ; try { Field f = procVersion . getField ( "S_VERSION" ) ; return pkg + " " + f . get ( null ) . toString ( ) ; } catch ( Exception e ) { return pkg + " ?.?" ; } } } 	0	['9', '1', '1', '4', '32', '34', '1', '3', '0', '0.9375', '145', '1', '1', '0', '0.481481481', '0', '0', '14.88888889', '1', '0.8889', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class SizeSelector extends BaseExtendSelector { public static final String SIZE_KEY = "value" ; public static final String UNITS_KEY = "units" ; public static final String WHEN_KEY = "when" ; private long size = - 1 ; private long multiplier = 1 ; private long sizelimit = - 1 ; private Comparison when = Comparison . EQUAL ; public SizeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{sizeselector value: " ) ; buf . append ( sizelimit ) ; buf . append ( "compare: " ) . append ( when . getValue ( ) ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setValue ( long size ) { this . size = size ; if ( multiplier != 0 && size > - 1 ) { sizelimit = size * multiplier ; } } public void setUnits ( ByteUnits units ) { int i = units . getIndex ( ) ; multiplier = 0 ; if ( i > - 1 && i < 4 ) { multiplier = 1000 ; } else if ( i > 3 && i < 9 ) { multiplier = 1024 ; } else if ( i > 8 && i < 13 ) { multiplier = 1000000 ; } else if ( i > 12 && i < 18 ) { multiplier = 1048576 ; } else if ( i > 17 && i < 22 ) { multiplier = 1000000000L ; } else if ( i > 21 && i < 27 ) { multiplier = 1073741824L ; } else if ( i > 26 && i < 31 ) { multiplier = 1000000000000L ; } else if ( i > 30 && i < 36 ) { multiplier = 1099511627776L ; } if ( multiplier > 0 && size > - 1 ) { sizelimit = size * multiplier ; } } public void setWhen ( SizeComparisons when ) { this . when = when ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( SIZE_KEY . equalsIgnoreCase ( paramname ) ) { try { setValue ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid size setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( UNITS_KEY . equalsIgnoreCase ( paramname ) ) { ByteUnits units = new ByteUnits ( ) ; units . setValue ( parameters [ i ] . getValue ( ) ) ; setUnits ( units ) ; } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { SizeComparisons scmp = new SizeComparisons ( ) ; scmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( scmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( size < 0 ) { setError ( "The value attribute is required, and must be positive" ) ; } else if ( multiplier < 1 ) { setError ( "Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti" ) ; } else if ( sizelimit < 0 ) { setError ( "Internal error: Code is not setting sizelimit correctly" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } long diff = file . length ( ) - sizelimit ; return when . evaluate ( diff == 0 ? 0 : ( int ) ( diff / Math . abs ( diff ) ) ) ; } public static class ByteUnits extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "K" , "k" , "kilo" , "KILO" , "Ki" , "KI" , "ki" , "kibi" , "KIBI" , "M" , "m" , "mega" , "MEGA" , "Mi" , "MI" , "mi" , "mebi" , "MEBI" , "G" , "g" , "giga" , "GIGA" , "Gi" , "GI" , "gi" , "gibi" , "GIBI" , "T" , "t" , "tera" , "TERA" , "Ti" , "TI" , "ti" , "tebi" , "TEBI" } ; } } public static class SizeComparisons extends Comparison { } } 	0	['8', '5', '0', '11', '31', '0', '6', '5', '8', '0.693877551', '329', '0.571428571', '1', '0.844444444', '0.25', '1', '4', '39.25', '19', '4.625', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . StreamPumper ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; public class Cab extends MatchingTask { private File cabFile ; private File baseDir ; private Vector filesets = new Vector ( ) ; private boolean doCompress = true ; private boolean doVerbose = false ; private String cmdOptions ; protected String archiveType = "cab" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setCabfile ( File cabFile ) { this . cabFile = cabFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean compress ) { doCompress = compress ; } public void setVerbose ( boolean verbose ) { doVerbose = verbose ; } public void setOptions ( String options ) { cmdOptions = options ; } public void addFileset ( FileSet set ) { if ( filesets . size ( ) > 0 ) { throw new BuildException ( "Only one nested fileset allowed" ) ; } filesets . addElement ( set ) ; } protected void checkConfiguration ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "basedir attribute or one " + "nested fileset is required!" , getLocation ( ) ) ; } if ( baseDir != null && ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } if ( baseDir != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Both basedir attribute and a nested fileset is not allowed" ) ; } if ( cabFile == null ) { throw new BuildException ( "cabfile attribute must be set!" , getLocation ( ) ) ; } } protected ExecTask createExec ( ) throws BuildException { ExecTask exec = new ExecTask ( this ) ; return exec ; } protected boolean isUpToDate ( Vector files ) { boolean upToDate = true ; for ( int i = 0 ; i < files . size ( ) && upToDate ; i ++ ) { String file = files . elementAt ( i ) . toString ( ) ; if ( FILE_UTILS . resolveFile ( baseDir , file ) . lastModified ( ) > cabFile . lastModified ( ) ) { upToDate = false ; } } return upToDate ; } protected File createListFile ( Vector files ) throws IOException { File listFile = FILE_UTILS . createTempFile ( "ant" , "" , null ) ; listFile . deleteOnExit ( ) ; PrintWriter writer = new PrintWriter ( new FileOutputStream ( listFile ) ) ; int size = files . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { writer . println ( '\"' + files . elementAt ( i ) . toString ( ) + '\"' ) ; } writer . close ( ) ; return listFile ; } protected void appendFiles ( Vector files , DirectoryScanner ds ) { String [ ] dsfiles = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < dsfiles . length ; i ++ ) { files . addElement ( dsfiles [ i ] ) ; } } protected Vector getFileList ( ) throws BuildException { Vector files = new Vector ( ) ; if ( baseDir != null ) { appendFiles ( files , super . getDirectoryScanner ( baseDir ) ) ; } else { FileSet fs = ( FileSet ) filesets . elementAt ( 0 ) ; baseDir = fs . getDir ( ) ; appendFiles ( files , fs . getDirectoryScanner ( getProject ( ) ) ) ; } return files ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; Vector files = getFileList ( ) ; if ( isUpToDate ( files ) ) { return ; } log ( "Building " + archiveType + ": " + cabFile . getAbsolutePath ( ) ) ; if ( ! Os . isFamily ( "windows" ) ) { log ( "Using listcab/libcabinet" , Project . MSG_VERBOSE ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration fileEnum = files . elements ( ) ; while ( fileEnum . hasMoreElements ( ) ) { sb . append ( fileEnum . nextElement ( ) ) . append ( "\n" ) ; } sb . append ( "\n" ) . append ( cabFile . getAbsolutePath ( ) ) . append ( "\n" ) ; try { Process p = Execute . launch ( getProject ( ) , new String [ ] { "listcab" } , null , baseDir != null ? baseDir : getProject ( ) . getBaseDir ( ) , true ) ; OutputStream out = p . getOutputStream ( ) ; LogOutputStream outLog = new LogOutputStream ( this , Project . MSG_VERBOSE ) ; LogOutputStream errLog = new LogOutputStream ( this , Project . MSG_ERR ) ; StreamPumper outPump = new StreamPumper ( p . getInputStream ( ) , outLog ) ; StreamPumper errPump = new StreamPumper ( p . getErrorStream ( ) , errLog ) ; ( new Thread ( outPump ) ) . start ( ) ; ( new Thread ( errPump ) ) . start ( ) ; out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; int result = - 99 ; try { result = p . waitFor ( ) ; outPump . waitFor ( ) ; outLog . close ( ) ; errPump . waitFor ( ) ; errLog . close ( ) ; } catch ( InterruptedException ie ) { log ( "Thread interrupted: " + ie ) ; } if ( Execute . isFailure ( result ) ) { log ( "Error executing listcab; error code: " + result ) ; } } catch ( IOException ex ) { String msg = "Problem creating " + cabFile + " " + ex . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } else { try { File listFile = createListFile ( files ) ; ExecTask exec = createExec ( ) ; File outFile = null ; exec . setFailonerror ( true ) ; exec . setDir ( baseDir ) ; if ( ! doVerbose ) { outFile = FILE_UTILS . createTempFile ( "ant" , "" , null ) ; outFile . deleteOnExit ( ) ; exec . setOutput ( outFile ) ; } exec . setExecutable ( "cabarc" ) ; exec . createArg ( ) . setValue ( "-r" ) ; exec . createArg ( ) . setValue ( "-p" ) ; if ( ! doCompress ) { exec . createArg ( ) . setValue ( "-m" ) ; exec . createArg ( ) . setValue ( "none" ) ; } if ( cmdOptions != null ) { exec . createArg ( ) . setLine ( cmdOptions ) ; } exec . createArg ( ) . setValue ( "n" ) ; exec . createArg ( ) . setFile ( cabFile ) ; exec . createArg ( ) . setValue ( "@" + listFile . getAbsolutePath ( ) ) ; exec . execute ( ) ; if ( outFile != null ) { outFile . delete ( ) ; } listFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Problem creating " + cabFile + " " + ioe . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } } 	0	['15', '4', '0', '14', '83', '47', '0', '14', '8', '0.821428571', '566', '1', '1', '0.857142857', '0.244897959', '2', '2', '36.2', '4', '1.2', '0']
package org . apache . tools . ant . util ; public interface TimeoutObserver { void timeoutOccured ( Watchdog w ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class DOMElementWriter { private static final String NS = "ns" ; private boolean xmlDeclaration = true ; private XmlNamespacePolicy namespacePolicy = XmlNamespacePolicy . IGNORE ; private HashMap nsPrefixMap = new HashMap ( ) ; private int nextPrefix = 0 ; private HashMap nsURIByElement = new HashMap ( ) ; public static class XmlNamespacePolicy { private boolean qualifyElements ; private boolean qualifyAttributes ; public static final XmlNamespacePolicy IGNORE = new XmlNamespacePolicy ( false , false ) ; public static final XmlNamespacePolicy ONLY_QUALIFY_ELEMENTS = new XmlNamespacePolicy ( true , false ) ; public static final XmlNamespacePolicy QUALIFY_ALL = new XmlNamespacePolicy ( true , true ) ; public XmlNamespacePolicy ( boolean qualifyElements , boolean qualifyAttributes ) { this . qualifyElements = qualifyElements ; this . qualifyAttributes = qualifyAttributes ; } } public DOMElementWriter ( ) { } public DOMElementWriter ( boolean xmlDeclaration ) { this ( xmlDeclaration , XmlNamespacePolicy . IGNORE ) ; } public DOMElementWriter ( boolean xmlDeclaration , XmlNamespacePolicy namespacePolicy ) { this . xmlDeclaration = xmlDeclaration ; this . namespacePolicy = namespacePolicy ; } private static String lSep = System . getProperty ( "line.separator" ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , "UTF8" ) ; writeXMLDeclaration ( wri ) ; write ( root , wri , 0 , "  " ) ; wri . flush ( ) ; } public void writeXMLDeclaration ( Writer wri ) throws IOException { if ( xmlDeclaration ) { wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; } } public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { NodeList children = element . getChildNodes ( ) ; boolean hasChildren = ( children . getLength ( ) > 0 ) ; boolean hasChildElements = false ; openElement ( element , out , indent , indentWith , hasChildren ) ; if ( hasChildren ) { for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : hasChildElements = true ; if ( i == 0 ) { out . write ( lSep ) ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . COMMENT_NODE : out . write ( "<!--" ) ; out . write ( encode ( child . getNodeValue ( ) ) ) ; out . write ( "-->" ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; default : } } closeElement ( element , out , indent , indentWith , hasChildElements ) ; } } public void openElement ( Element element , Writer out , int indent , String indentWith ) throws IOException { openElement ( element , out , indent , indentWith , true ) ; } public void openElement ( Element element , Writer out , int indent , String indentWith , boolean hasChildren ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; if ( namespacePolicy . qualifyElements ) { String uri = getNamespaceURI ( element ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix == null ) { if ( nsPrefixMap . isEmpty ( ) ) { prefix = "" ; } else { prefix = NS + ( nextPrefix ++ ) ; } nsPrefixMap . put ( uri , prefix ) ; addNSDefinition ( element , uri ) ; } if ( ! "" . equals ( prefix ) ) { out . write ( prefix ) ; out . write ( ":" ) ; } } out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; if ( namespacePolicy . qualifyAttributes ) { String uri = getNamespaceURI ( attr ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix == null ) { prefix = NS + ( nextPrefix ++ ) ; nsPrefixMap . put ( uri , prefix ) ; addNSDefinition ( element , uri ) ; } out . write ( prefix ) ; out . write ( ":" ) ; } out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al != null ) { Iterator iter = al . iterator ( ) ; while ( iter . hasNext ( ) ) { String uri = ( String ) iter . next ( ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; out . write ( " xmlns" ) ; if ( ! "" . equals ( prefix ) ) { out . write ( ":" ) ; out . write ( prefix ) ; } out . write ( "=\"" ) ; out . write ( uri ) ; out . write ( "\"" ) ; } } if ( hasChildren ) { out . write ( ">" ) ; } else { removeNSDefinitions ( element ) ; out . write ( " />" ) ; out . write ( lSep ) ; out . flush ( ) ; } } public void closeElement ( Element element , Writer out , int indent , String indentWith , boolean hasChildren ) throws IOException { if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; if ( namespacePolicy . qualifyElements ) { String uri = getNamespaceURI ( element ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix != null && ! "" . equals ( prefix ) ) { out . write ( prefix ) ; out . write ( ":" ) ; } removeNSDefinitions ( element ) ; } out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( "]]>" ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( "&#x5d;&#x5d;&gt;" ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( "]]>" ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } private void removeNSDefinitions ( Element element ) { ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al != null ) { Iterator iter = al . iterator ( ) ; while ( iter . hasNext ( ) ) { nsPrefixMap . remove ( iter . next ( ) ) ; } nsURIByElement . remove ( element ) ; } } private void addNSDefinition ( Element element , String uri ) { ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al == null ) { al = new ArrayList ( ) ; nsURIByElement . put ( element , al ) ; } al . add ( uri ) ; } private static String getNamespaceURI ( Node n ) { String uri = n . getNamespaceURI ( ) ; if ( uri == null ) { uri = "" ; } return uri ; } } 	0	['17', '1', '0', '8', '67', '90', '7', '1', '13', '0.703125', '878', '1', '1', '0', '0.29375', '0', '0', '50.17647059', '11', '2.5294', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . util . FileUtils ; public abstract class CompressedResource extends Resource { private Resource resource ; public CompressedResource ( ) { } public CompressedResource ( ResourceCollection other ) { addConfigured ( other ) ; } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( resource != null ) { throw new BuildException ( "you must not specify more than one" + " resource" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported" ) ; } resource = ( Resource ) a . iterator ( ) . next ( ) ; } public String getName ( ) { return getResource ( ) . getName ( ) ; } public void setName ( String name ) throws BuildException { throw new BuildException ( "you can't change the name of a compressed" + " resource" ) ; } public boolean isExists ( ) { return getResource ( ) . isExists ( ) ; } public void setExists ( boolean exists ) { throw new BuildException ( "you can't change the exists state of a " + " compressed resource" ) ; } public long getLastModified ( ) { return getResource ( ) . getLastModified ( ) ; } public void setLastModified ( long lastmodified ) throws BuildException { throw new BuildException ( "you can't change the timestamp of a " + " compressed resource" ) ; } public boolean isDirectory ( ) { return getResource ( ) . isDirectory ( ) ; } public void setDirectory ( boolean directory ) throws BuildException { throw new BuildException ( "you can't change the directory state of a " + " compressed resource" ) ; } public long getSize ( ) { if ( isExists ( ) ) { InputStream in = null ; try { in = getInputStream ( ) ; byte [ ] buf = new byte [ 8192 ] ; int size = 0 ; int readNow ; while ( ( readNow = in . read ( buf , 0 , buf . length ) ) > 0 ) { size += readNow ; } return size ; } catch ( IOException ex ) { throw new BuildException ( "caught exception while reading " + getName ( ) , ex ) ; } finally { FileUtils . close ( in ) ; } } else { return 0 ; } } public void setSize ( long size ) throws BuildException { throw new BuildException ( "you can't change the size of a " + " compressed resource" ) ; } public int compareTo ( Object other ) { if ( other == this ) { return 0 ; } if ( other instanceof CompressedResource ) { return getResource ( ) . compareTo ( ( ( CompressedResource ) other ) . getResource ( ) ) ; } return getResource ( ) . compareTo ( other ) ; } public int hashCode ( ) { return getResource ( ) . hashCode ( ) ; } public InputStream getInputStream ( ) throws IOException { InputStream in = getResource ( ) . getInputStream ( ) ; if ( in != null ) { in = wrapStream ( in ) ; } return in ; } public OutputStream getOutputStream ( ) throws IOException { OutputStream out = getResource ( ) . getOutputStream ( ) ; if ( out != null ) { out = wrapStream ( out ) ; } return out ; } public boolean isFilesystemOnly ( ) { return false ; } public String toString ( ) { return getCompressionName ( ) + " compressed " + getResource ( ) . toString ( ) ; } public void setRefid ( Reference r ) { if ( resource != null ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } protected abstract InputStream wrapStream ( InputStream in ) throws IOException ; protected abstract OutputStream wrapStream ( OutputStream out ) throws IOException ; protected abstract String getCompressionName ( ) ; private Resource getResource ( ) { if ( isReference ( ) ) { return ( Resource ) getCheckedRef ( ) ; } else if ( resource == null ) { throw new BuildException ( "no resource specified" ) ; } return resource ; } } 	0	['24', '4', '2', '7', '50', '270', '2', '5', '20', '0.434782609', '250', '1', '1', '0.706666667', '0.162037037', '2', '15', '9.375', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ClassCPInfo ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ConstantPool ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ConstantPoolEntry ; public class ClassFile { private static final int CLASS_MAGIC = 0xCAFEBABE ; private ConstantPool constantPool ; private String className ; public void read ( InputStream stream ) throws IOException , ClassFormatError { DataInputStream classStream = new DataInputStream ( stream ) ; if ( classStream . readInt ( ) != CLASS_MAGIC ) { throw new ClassFormatError ( "No Magic Code Found " + "- probably not a Java class file." ) ; } classStream . readUnsignedShort ( ) ; classStream . readUnsignedShort ( ) ; constantPool = new ConstantPool ( ) ; constantPool . read ( classStream ) ; constantPool . resolve ( ) ; classStream . readUnsignedShort ( ) ; int thisClassIndex = classStream . readUnsignedShort ( ) ; classStream . readUnsignedShort ( ) ; ClassCPInfo classInfo = ( ClassCPInfo ) constantPool . getEntry ( thisClassIndex ) ; className = classInfo . getClassName ( ) ; } public Vector getClassRefs ( ) { Vector classRefs = new Vector ( ) ; for ( int i = 0 ; i < constantPool . size ( ) ; ++ i ) { ConstantPoolEntry entry = constantPool . getEntry ( i ) ; if ( entry != null && entry . getTag ( ) == ConstantPoolEntry . CONSTANT_CLASS ) { ClassCPInfo classEntry = ( ClassCPInfo ) entry ; if ( ! classEntry . getClassName ( ) . equals ( className ) ) { classRefs . addElement ( ClassFileUtils . convertSlashName ( classEntry . getClassName ( ) ) ) ; } } } return classRefs ; } public String getFullClassName ( ) { return ClassFileUtils . convertSlashName ( className ) ; } } 	0	['4', '1', '0', '8', '20', '0', '4', '4', '4', '0.777777778', '106', '1', '1', '0', '0.625', '0', '0', '24.75', '5', '1.75', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public final class AntFilterReader extends DataType implements Cloneable { private String className ; private final Vector parameters = new Vector ( ) ; private Path classpath ; public void setClassName ( final String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void addParam ( final Parameter param ) { parameters . addElement ( param ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public Parameter [ ] getParams ( ) { Parameter [ ] params = new Parameter [ parameters . size ( ) ] ; parameters . copyInto ( params ) ; return params ; } public void setRefid ( Reference r ) throws BuildException { if ( ! parameters . isEmpty ( ) || className != null || classpath != null ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof AntFilterReader ) { AntFilterReader afr = ( AntFilterReader ) o ; setClassName ( afr . getClassName ( ) ) ; setClasspath ( afr . getClasspath ( ) ) ; Parameter [ ] p = afr . getParams ( ) ; if ( p != null ) { for ( int i = 0 ; i < p . length ; i ++ ) { addParam ( p [ i ] ) ; } } } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterReader" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['10', '3', '0', '8', '32', '15', '2', '6', '10', '0.666666667', '166', '1', '1', '0.769230769', '0.3', '1', '1', '15.3', '3', '1.4', '0']
package org . apache . tools . ant ; public interface DynamicAttribute { void setDynamicAttribute ( String name , String value ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ExtendSelector extends BaseSelector { private String classname = null ; private FileSelector dynselector = null ; private Vector paramVec = new Vector ( ) ; private Path classpath = null ; public ExtendSelector ( ) { } public void setClassname ( String classname ) { this . classname = classname ; } public void selectorCreate ( ) { if ( classname != null && classname . length ( ) > 0 ) { try { Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } dynselector = ( FileSelector ) c . newInstance ( ) ; final Project p = getProject ( ) ; if ( p != null ) { p . setProjectReference ( dynselector ) ; } } catch ( ClassNotFoundException cnfexcept ) { setError ( "Selector " + classname + " not initialized, no such class" ) ; } catch ( InstantiationException iexcept ) { setError ( "Selector " + classname + " not initialized, could not create class" ) ; } catch ( IllegalAccessException iaexcept ) { setError ( "Selector " + classname + " not initialized, class not accessible" ) ; } } else { setError ( "There is no classname specified" ) ; } } public void addParam ( Parameter p ) { paramVec . addElement ( p ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathref ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public void verifySettings ( ) { if ( dynselector == null ) { selectorCreate ( ) ; } if ( classname == null || classname . length ( ) < 1 ) { setError ( "The classname attribute is required" ) ; } else if ( dynselector == null ) { setError ( "Internal Error: The custom selector was not created" ) ; } else if ( ! ( dynselector instanceof ExtendFileSelector ) && ( paramVec . size ( ) > 0 ) ) { setError ( "Cannot set parameters on custom selector that does not " + "implement ExtendFileSelector" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) throws BuildException { validate ( ) ; if ( paramVec . size ( ) > 0 && dynselector instanceof ExtendFileSelector ) { Parameter [ ] paramArray = new Parameter [ paramVec . size ( ) ] ; paramVec . copyInto ( paramArray ) ; ( ( ExtendFileSelector ) dynselector ) . setParameters ( paramArray ) ; } return dynselector . isSelected ( basedir , filename , file ) ; } } 	0	['10', '4', '0', '15', '36', '3', '6', '9', '10', '0.583333333', '249', '1', '2', '0.795454545', '0.266666667', '1', '3', '23.5', '7', '2.4', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class CCMCheck extends Continuus { private File file = null ; private String comment = null ; private String task = null ; protected Vector filesets = new Vector ( ) ; public CCMCheck ( ) { super ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File v ) { log ( "working file " + v , Project . MSG_VERBOSE ) ; this . file = v ; } public String getComment ( ) { return comment ; } public void setComment ( String v ) { this . comment = v ; } public String getTask ( ) { return task ; } public void setTask ( String v ) { this . task = v ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "CCMCheck cannot be generated for directories" ) ; } if ( file != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Choose between file and fileset !" ) ; } if ( getFile ( ) != null ) { doit ( ) ; return ; } int sizeofFileSet = filesets . size ( ) ; for ( int i = 0 ; i < sizeofFileSet ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File src = new File ( fs . getDir ( getProject ( ) ) , srcFiles [ j ] ) ; setFile ( src ) ; doit ( ) ; } } } private void doit ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; int result = run ( commandLine ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } if ( getTask ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_TASK ) ; cmd . createArgument ( ) . setValue ( getTask ( ) ) ; } if ( getFile ( ) != null ) { cmd . createArgument ( ) . setValue ( file . getAbsolutePath ( ) ) ; } } public static final String FLAG_COMMENT = "/comment" ; public static final String FLAG_TASK = "/task" ; } 	0	['11', '4', '3', '12', '41', '19', '3', '9', '9', '0.816666667', '240', '0.666666667', '0', '0.811320755', '0.290909091', '0', '0', '20.27272727', '4', '1.2727', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File myFile ; public void setFile ( final File file ) { myFile = file ; } public void execute ( ) throws BuildException { File savedFile = myFile ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( myFile ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . store ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + myFile ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { log ( "error closing output stream " + ioe , Project . MSG_ERR ) ; } } myFile = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = myFile + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( myFile ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { log ( "error closing input stream " + ioe , Project . MSG_ERR ) ; } } } } private void validate ( ) throws BuildException { if ( null == myFile ) { myFile = FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , DEFAULT_FILENAME ) ; } if ( ! myFile . exists ( ) ) { try { FILE_UTILS . createNewFile ( myFile ) ; } catch ( final IOException ioe ) { final String message = myFile + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! myFile . canRead ( ) ) { final String message = "Unable to read from " + myFile + "." ; throw new BuildException ( message ) ; } if ( ! myFile . canWrite ( ) ) { final String message = "Unable to write to " + myFile + "." ; throw new BuildException ( message ) ; } } } 	0	['7', '3', '0', '4', '38', '0', '0', '4', '3', '0.833333333', '258', '1', '1', '0.880952381', '0.444444444', '1', '1', '35.28571429', '1', '0.7143', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; public interface BuildLogger extends BuildListener { void setMessageOutputLevel ( int level ) ; void setOutputPrintStream ( PrintStream output ) ; void setEmacsMode ( boolean emacsMode ) ; void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '6', '4', '6', '5', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; public class Reverse extends ResourceComparator { private static final String ONE_NESTED = "You must not nest more than one ResourceComparator for reversal." ; private ResourceComparator nested ; public Reverse ( ) { } public Reverse ( ResourceComparator c ) { add ( c ) ; } public void add ( ResourceComparator c ) { if ( nested != null ) { throw new BuildException ( ONE_NESTED ) ; } nested = c ; } protected int resourceCompare ( Resource foo , Resource bar ) { return - 1 * ( nested == null ? foo . compareTo ( bar ) : nested . compare ( foo , bar ) ) ; } } 	0	['4', '4', '0', '5', '8', '4', '2', '3', '3', '0.833333333', '42', '1', '1', '0.944444444', '0.583333333', '1', '1', '9', '2', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . Reference ; public abstract class ArchiveResource extends Resource { private static final int NULL_ARCHIVE = Resource . getMagicNumber ( "null archive" . getBytes ( ) ) ; private Resource archive ; private boolean haveEntry = false ; private boolean modeSet = false ; private int mode = 0 ; public ArchiveResource ( ) { } public ArchiveResource ( File a ) { this ( a , false ) ; } public ArchiveResource ( File a , boolean withEntry ) { setArchive ( a ) ; haveEntry = withEntry ; } public ArchiveResource ( Resource a , boolean withEntry ) { addConfigured ( a ) ; haveEntry = withEntry ; } public void setArchive ( File a ) { checkAttributesAllowed ( ) ; archive = new FileResource ( a ) ; } public void setMode ( int mode ) { checkAttributesAllowed ( ) ; this . mode = mode ; modeSet = true ; } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( archive != null ) { throw new BuildException ( "you must not specify more than one" + " archive" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } archive = ( Resource ) a . iterator ( ) . next ( ) ; } public Resource getArchive ( ) { return isReference ( ) ? ( ( ArchiveResource ) getCheckedRef ( ) ) . getArchive ( ) : archive ; } public long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } checkEntry ( ) ; return super . getLastModified ( ) ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } checkEntry ( ) ; return super . getSize ( ) ; } public boolean isDirectory ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) ; } checkEntry ( ) ; return super . isDirectory ( ) ; } public boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } checkEntry ( ) ; return super . isExists ( ) ; } public int getMode ( ) { if ( isReference ( ) ) { return ( ( ArchiveResource ) getCheckedRef ( ) ) . getMode ( ) ; } checkEntry ( ) ; return mode ; } public void setRefid ( Reference r ) { if ( archive != null || modeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public int compareTo ( Object another ) { return this . equals ( another ) ? 0 : super . compareTo ( another ) ; } public boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } ArchiveResource r = ( ArchiveResource ) another ; return getArchive ( ) . equals ( r . getArchive ( ) ) && getName ( ) . equals ( r . getName ( ) ) ; } public int hashCode ( ) { return super . hashCode ( ) * ( getArchive ( ) == null ? NULL_ARCHIVE : getArchive ( ) . hashCode ( ) ) ; } public String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : getArchive ( ) . toString ( ) + ':' + getName ( ) ; } private synchronized void checkEntry ( ) throws BuildException { if ( haveEntry ) { return ; } String name = getName ( ) ; if ( name == null ) { throw new BuildException ( "entry name not set" ) ; } Resource r = getArchive ( ) ; if ( r == null ) { throw new BuildException ( "archive attribute not set" ) ; } if ( ! r . isExists ( ) ) { throw new BuildException ( r . toString ( ) + " does not exist." ) ; } if ( r . isDirectory ( ) ) { throw new BuildException ( r + " denotes a directory." ) ; } fetchEntry ( ) ; haveEntry = true ; } protected abstract void fetchEntry ( ) ; } 	0	['21', '4', '2', '9', '55', '162', '4', '5', '18', '0.71', '361', '1', '1', '0.768115942', '0.19375', '2', '9', '15.95238095', '6', '1.619', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; public class First extends BaseResourceCollectionWrapper { private static final String BAD_COUNT = "count of first resources should be set to an int >= 0" ; private int count = 1 ; public synchronized void setCount ( int i ) { count = i ; } public synchronized int getCount ( ) { return count ; } protected Collection getCollection ( ) { int ct = getCount ( ) ; if ( ct < 0 ) { throw new BuildException ( BAD_COUNT ) ; } Iterator iter = getResourceCollection ( ) . iterator ( ) ; ArrayList al = new ArrayList ( ct ) ; for ( int i = 0 ; i < ct && iter . hasNext ( ) ; i ++ ) { al . add ( iter . next ( ) ) ; } return al ; } } 	0	['4', '4', '0', '3', '12', '0', '0', '3', '3', '0.666666667', '55', '1', '0', '0.933333333', '0.625', '1', '1', '12.25', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class XMLResultAggregator extends Task implements XMLConstants { protected Vector filesets = new Vector ( ) ; protected String toFile ; protected File toDir ; protected Vector transformers = new Vector ( ) ; public static final String DEFAULT_DIR = "." ; public static final String DEFAULT_FILENAME = "TESTS-TestSuites.xml" ; protected int generatedId = 0 ; static final String WARNING_IS_POSSIBLY_CORRUPTED = " is not a valid XML document. It is possibly corrupted." ; static final String WARNING_INVALID_ROOT_ELEMENT = " is not a valid testsuite XML document" ; static final String WARNING_EMPTY_FILE = " is empty.\nThis can be caused by the test JVM exiting unexpectedly" ; public AggregateTransformer createReport ( ) { AggregateTransformer transformer = new AggregateTransformer ( this ) ; transformers . addElement ( transformer ) ; return transformer ; } public void setTofile ( String value ) { toFile = value ; } public void setTodir ( File value ) { toDir = value ; } public void addFileSet ( FileSet fs ) { filesets . addElement ( fs ) ; } public void execute ( ) throws BuildException { Element rootElement = createDocument ( ) ; File destFile = getDestinationFile ( ) ; try { writeDOMTree ( rootElement . getOwnerDocument ( ) , destFile ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to write test aggregate to '" + destFile + "'" , e ) ; } Enumeration e = transformers . elements ( ) ; while ( e . hasMoreElements ( ) ) { AggregateTransformer transformer = ( AggregateTransformer ) e . nextElement ( ) ; transformer . setXmlDocument ( rootElement . getOwnerDocument ( ) ) ; transformer . transform ( ) ; } } public File getDestinationFile ( ) { if ( toFile == null ) { toFile = DEFAULT_FILENAME ; } if ( toDir == null ) { toDir = getProject ( ) . resolveFile ( DEFAULT_DIR ) ; } return new File ( toDir , toFile ) ; } protected File [ ] getFiles ( ) { Vector v = new Vector ( ) ; final int size = filesets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; ds . scan ( ) ; String [ ] f = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < f . length ; j ++ ) { String pathname = f [ j ] ; if ( pathname . endsWith ( ".xml" ) ) { File file = new File ( ds . getBasedir ( ) , pathname ) ; file = getProject ( ) . resolveFile ( file . getPath ( ) ) ; v . addElement ( file ) ; } } } File [ ] files = new File [ v . size ( ) ] ; v . copyInto ( files ) ; return files ; } protected void writeDOMTree ( Document doc , File file ) throws IOException { OutputStream out = null ; PrintWriter wri = null ; try { out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; wri = new PrintWriter ( new OutputStreamWriter ( out , "UTF8" ) ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; ( new DOMElementWriter ( ) ) . write ( doc . getDocumentElement ( ) , wri , 0 , "  " ) ; wri . flush ( ) ; if ( wri . checkError ( ) ) { throw new IOException ( "Error while writing DOM content" ) ; } } finally { FileUtils . close ( wri ) ; FileUtils . close ( out ) ; } } protected Element createDocument ( ) { DocumentBuilder builder = getDocumentBuilder ( ) ; Document doc = builder . newDocument ( ) ; Element rootElement = doc . createElement ( TESTSUITES ) ; doc . appendChild ( rootElement ) ; generatedId = 0 ; File [ ] files = getFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; try { log ( "Parsing file: '" + file + "'" , Project . MSG_VERBOSE ) ; if ( file . length ( ) > 0 ) { Document testsuiteDoc = builder . parse ( FileUtils . getFileUtils ( ) . toURI ( files [ i ] . getAbsolutePath ( ) ) ) ; Element elem = testsuiteDoc . getDocumentElement ( ) ; if ( TESTSUITE . equals ( elem . getNodeName ( ) ) ) { addTestSuite ( rootElement , elem ) ; generatedId ++ ; } else { log ( "the file " + file + WARNING_INVALID_ROOT_ELEMENT , Project . MSG_WARN ) ; } } else { log ( "the file " + file + WARNING_EMPTY_FILE , Project . MSG_WARN ) ; } } catch ( SAXException e ) { log ( "The file " + file + WARNING_IS_POSSIBLY_CORRUPTED , Project . MSG_WARN ) ; log ( StringUtils . getStackTrace ( e ) , Project . MSG_DEBUG ) ; } catch ( IOException e ) { log ( "Error while accessing file " + file + ": " + e . getMessage ( ) , Project . MSG_ERR ) ; } } return rootElement ; } protected void addTestSuite ( Element root , Element testsuite ) { String fullclassname = testsuite . getAttribute ( ATTR_NAME ) ; int pos = fullclassname . lastIndexOf ( '.' ) ; String pkgName = ( pos == - 1 ) ? "" : fullclassname . substring ( 0 , pos ) ; String classname = ( pos == - 1 ) ? fullclassname : fullclassname . substring ( pos + 1 ) ; Element copy = ( Element ) DOMUtil . importNode ( root , testsuite ) ; copy . setAttribute ( ATTR_NAME , classname ) ; copy . setAttribute ( ATTR_PACKAGE , pkgName ) ; copy . setAttribute ( ATTR_ID , Integer . toString ( generatedId ) ) ; } private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } } 	0	['12', '3', '0', '11', '75', '44', '1', '11', '7', '0.936363636', '455', '0.5', '0', '0.770833333', '0.236111111', '0', '0', '36.08333333', '4', '1.75', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public interface RegexpMatcher { int MATCH_DEFAULT = 0x00000000 ; int MATCH_CASE_INSENSITIVE = 0x00000100 ; int MATCH_MULTILINE = 0x00001000 ; int MATCH_SINGLELINE = 0x00010000 ; void setPattern ( String pattern ) throws BuildException ; String getPattern ( ) throws BuildException ; boolean matches ( String argument ) throws BuildException ; Vector getGroups ( String argument ) throws BuildException ; boolean matches ( String input , int options ) throws BuildException ; Vector getGroups ( String input , int options ) throws BuildException ; } 	0	['6', '1', '0', '9', '6', '15', '8', '1', '6', '1.2', '10', '0', '0', '0', '0.722222222', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . types . spi ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildException ; public class Service extends ProjectComponent { private List providerList = new ArrayList ( ) ; private String type ; public void setProvider ( String className ) { Provider provider = new Provider ( ) ; provider . setClassName ( className ) ; providerList . add ( provider ) ; } public void addConfiguredProvider ( Provider provider ) { provider . check ( ) ; providerList . add ( provider ) ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public InputStream getAsStream ( ) throws IOException { ByteArrayOutputStream arrayOut ; Writer writer ; Iterator providerIterator ; Provider provider ; arrayOut = new ByteArrayOutputStream ( ) ; writer = new OutputStreamWriter ( arrayOut , "UTF-8" ) ; providerIterator = providerList . iterator ( ) ; while ( providerIterator . hasNext ( ) ) { provider = ( Provider ) providerIterator . next ( ) ; writer . write ( provider . getClassName ( ) ) ; writer . write ( "\n" ) ; } writer . close ( ) ; return new ByteArrayInputStream ( arrayOut . toByteArray ( ) ) ; } public void check ( ) { if ( type == null ) { throw new BuildException ( "type attribute must be set for service element" , getLocation ( ) ) ; } if ( type . length ( ) == 0 ) { throw new BuildException ( "Invalid empty type classname" , getLocation ( ) ) ; } if ( providerList . size ( ) == 0 ) { throw new BuildException ( "provider attribute or nested provider element must be set!" , getLocation ( ) ) ; } } } 	0	['7', '2', '0', '5', '27', '0', '1', '4', '7', '0.5', '115', '1', '0', '0.6', '0.476190476', '0', '0', '15.14285714', '4', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Hashtable ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . xml . sax . AttributeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class DescriptorHandler extends org . xml . sax . HandlerBase { private static final int DEFAULT_HASH_TABLE_SIZE = 10 ; private static final int STATE_LOOKING_EJBJAR = 1 ; private static final int STATE_IN_EJBJAR = 2 ; private static final int STATE_IN_BEANS = 3 ; private static final int STATE_IN_SESSION = 4 ; private static final int STATE_IN_ENTITY = 5 ; private static final int STATE_IN_MESSAGE = 6 ; private Task owningTask ; private String publicId = null ; private static final String EJB_REF = "ejb-ref" ; private static final String EJB_LOCAL_REF = "ejb-local-ref" ; private static final String HOME_INTERFACE = "home" ; private static final String REMOTE_INTERFACE = "remote" ; private static final String LOCAL_HOME_INTERFACE = "local-home" ; private static final String LOCAL_INTERFACE = "local" ; private static final String BEAN_CLASS = "ejb-class" ; private static final String PK_CLASS = "prim-key-class" ; private static final String EJB_NAME = "ejb-name" ; private static final String EJB_JAR = "ejb-jar" ; private static final String ENTERPRISE_BEANS = "enterprise-beans" ; private static final String ENTITY_BEAN = "entity" ; private static final String SESSION_BEAN = "session" ; private static final String MESSAGE_BEAN = "message-driven" ; private int parseState = STATE_LOOKING_EJBJAR ; protected String currentElement = null ; protected String currentText = null ; protected Hashtable ejbFiles = null ; protected String ejbName = null ; private Hashtable fileDTDs = new Hashtable ( ) ; private Hashtable resourceDTDs = new Hashtable ( ) ; private boolean inEJBRef = false ; private Hashtable urlDTDs = new Hashtable ( ) ; private File srcDir ; public DescriptorHandler ( Task task , File srcDir ) { this . owningTask = task ; this . srcDir = srcDir ; } public void registerDTD ( String publicId , String location ) { if ( location == null ) { return ; } File fileDTD = new File ( location ) ; if ( ! fileDTD . exists ( ) ) { fileDTD = owningTask . getProject ( ) . resolveFile ( location ) ; } if ( fileDTD . exists ( ) ) { if ( publicId != null ) { fileDTDs . put ( publicId , fileDTD ) ; owningTask . log ( "Mapped publicId " + publicId + " to file " + fileDTD , Project . MSG_VERBOSE ) ; } return ; } if ( getClass ( ) . getResource ( location ) != null ) { if ( publicId != null ) { resourceDTDs . put ( publicId , location ) ; owningTask . log ( "Mapped publicId " + publicId + " to resource " + location , Project . MSG_VERBOSE ) ; } } try { if ( publicId != null ) { URL urldtd = new URL ( location ) ; urlDTDs . put ( publicId , urldtd ) ; } } catch ( java . net . MalformedURLException e ) { } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { this . publicId = publicId ; File dtdFile = ( File ) fileDTDs . get ( publicId ) ; if ( dtdFile != null ) { try { owningTask . log ( "Resolved " + publicId + " to local file " + dtdFile , Project . MSG_VERBOSE ) ; return new InputSource ( new FileInputStream ( dtdFile ) ) ; } catch ( FileNotFoundException ex ) { } } String dtdResourceName = ( String ) resourceDTDs . get ( publicId ) ; if ( dtdResourceName != null ) { InputStream is = this . getClass ( ) . getResourceAsStream ( dtdResourceName ) ; if ( is != null ) { owningTask . log ( "Resolved " + publicId + " to local resource " + dtdResourceName , Project . MSG_VERBOSE ) ; return new InputSource ( is ) ; } } URL dtdUrl = ( URL ) urlDTDs . get ( publicId ) ; if ( dtdUrl != null ) { try { InputStream is = dtdUrl . openStream ( ) ; owningTask . log ( "Resolved " + publicId + " to url " + dtdUrl , Project . MSG_VERBOSE ) ; return new InputSource ( is ) ; } catch ( IOException ioe ) { } } owningTask . log ( "Could not resolve ( publicId: " + publicId + ", systemId: " + systemId + ") to a local entity" , Project . MSG_INFO ) ; return null ; } public Hashtable getFiles ( ) { return ( ejbFiles == null ) ? new Hashtable ( ) : ejbFiles ; } public String getPublicId ( ) { return publicId ; } public String getEjbName ( ) { return ejbName ; } public void startDocument ( ) throws SAXException { this . ejbFiles = new Hashtable ( DEFAULT_HASH_TABLE_SIZE , 1 ) ; this . currentElement = null ; inEJBRef = false ; } public void startElement ( String name , AttributeList attrs ) throws SAXException { this . currentElement = name ; currentText = "" ; if ( name . equals ( EJB_REF ) || name . equals ( EJB_LOCAL_REF ) ) { inEJBRef = true ; } else if ( parseState == STATE_LOOKING_EJBJAR && name . equals ( EJB_JAR ) ) { parseState = STATE_IN_EJBJAR ; } else if ( parseState == STATE_IN_EJBJAR && name . equals ( ENTERPRISE_BEANS ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_BEANS && name . equals ( SESSION_BEAN ) ) { parseState = STATE_IN_SESSION ; } else if ( parseState == STATE_IN_BEANS && name . equals ( ENTITY_BEAN ) ) { parseState = STATE_IN_ENTITY ; } else if ( parseState == STATE_IN_BEANS && name . equals ( MESSAGE_BEAN ) ) { parseState = STATE_IN_MESSAGE ; } } public void endElement ( String name ) throws SAXException { processElement ( ) ; currentText = "" ; this . currentElement = "" ; if ( name . equals ( EJB_REF ) || name . equals ( EJB_LOCAL_REF ) ) { inEJBRef = false ; } else if ( parseState == STATE_IN_ENTITY && name . equals ( ENTITY_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_SESSION && name . equals ( SESSION_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_MESSAGE && name . equals ( MESSAGE_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_BEANS && name . equals ( ENTERPRISE_BEANS ) ) { parseState = STATE_IN_EJBJAR ; } else if ( parseState == STATE_IN_EJBJAR && name . equals ( EJB_JAR ) ) { parseState = STATE_LOOKING_EJBJAR ; } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentText += new String ( ch , start , length ) ; } protected void processElement ( ) { if ( inEJBRef || ( parseState != STATE_IN_ENTITY && parseState != STATE_IN_SESSION && parseState != STATE_IN_MESSAGE ) ) { return ; } if ( currentElement . equals ( HOME_INTERFACE ) || currentElement . equals ( REMOTE_INTERFACE ) || currentElement . equals ( LOCAL_INTERFACE ) || currentElement . equals ( LOCAL_HOME_INTERFACE ) || currentElement . equals ( BEAN_CLASS ) || currentElement . equals ( PK_CLASS ) ) { File classFile = null ; String className = currentText . trim ( ) ; if ( ! className . startsWith ( "java." ) && ! className . startsWith ( "javax." ) ) { className = className . replace ( '.' , File . separatorChar ) ; className += ".class" ; classFile = new File ( srcDir , className ) ; ejbFiles . put ( className , classFile ) ; } } if ( currentElement . equals ( EJB_NAME ) ) { if ( ejbName == null ) { ejbName = currentText . trim ( ) ; } } } } 	0	['11', '2', '3', '11', '39', '7', '9', '2', '10', '0.960606061', '605', '1', '1', '0.583333333', '0.25974026', '0', '0', '51', '15', '2.9091', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipEntry ; import java . util . zip . ZipException ; import java . util . zip . ZipFile ; import java . util . zip . ZipOutputStream ; public class jlink { private String outfile = null ; private Vector mergefiles = new Vector ( 10 ) ; private Vector addfiles = new Vector ( 10 ) ; private boolean compression = false ; byte [ ] buffer = new byte [ 8192 ] ; public void setOutfile ( String outfile ) { if ( outfile == null ) { return ; } this . outfile = outfile ; } public void addMergeFile ( String fileToMerge ) { if ( fileToMerge == null ) { return ; } mergefiles . addElement ( fileToMerge ) ; } public void addAddFile ( String fileToAdd ) { if ( fileToAdd == null ) { return ; } addfiles . addElement ( fileToAdd ) ; } public void addMergeFiles ( String [ ] filesToMerge ) { if ( filesToMerge == null ) { return ; } for ( int i = 0 ; i < filesToMerge . length ; i ++ ) { addMergeFile ( filesToMerge [ i ] ) ; } } public void addAddFiles ( String [ ] filesToAdd ) { if ( filesToAdd == null ) { return ; } for ( int i = 0 ; i < filesToAdd . length ; i ++ ) { addAddFile ( filesToAdd [ i ] ) ; } } public void setCompression ( boolean compress ) { this . compression = compress ; } public void link ( ) throws Exception { ZipOutputStream output = new ZipOutputStream ( new FileOutputStream ( outfile ) ) ; if ( compression ) { output . setMethod ( ZipOutputStream . DEFLATED ) ; output . setLevel ( Deflater . DEFAULT_COMPRESSION ) ; } else { output . setMethod ( ZipOutputStream . STORED ) ; } Enumeration merges = mergefiles . elements ( ) ; while ( merges . hasMoreElements ( ) ) { String path = ( String ) merges . nextElement ( ) ; File f = new File ( path ) ; if ( f . getName ( ) . endsWith ( ".jar" ) || f . getName ( ) . endsWith ( ".zip" ) ) { mergeZipJarContents ( output , f ) ; } else { addAddFile ( path ) ; } } Enumeration adds = addfiles . elements ( ) ; while ( adds . hasMoreElements ( ) ) { String name = ( String ) adds . nextElement ( ) ; File f = new File ( name ) ; if ( f . isDirectory ( ) ) { addDirContents ( output , f , f . getName ( ) + '/' , compression ) ; } else { addFile ( output , f , "" , compression ) ; } } if ( output != null ) { try { output . close ( ) ; } catch ( IOException ioe ) { } } } public static void main ( String [ ] args ) { if ( args . length < 2 ) { System . out . println ( "usage: jlink output input1 ... inputN" ) ; System . exit ( 1 ) ; } jlink linker = new jlink ( ) ; linker . setOutfile ( args [ 0 ] ) ; for ( int i = 1 ; i < args . length ; i ++ ) { linker . addMergeFile ( args [ i ] ) ; } try { linker . link ( ) ; } catch ( Exception ex ) { System . err . print ( ex . getMessage ( ) ) ; } } private void mergeZipJarContents ( ZipOutputStream output , File f ) throws IOException { if ( ! f . exists ( ) ) { return ; } ZipFile zipf = new ZipFile ( f ) ; Enumeration entries = zipf . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry inputEntry = ( ZipEntry ) entries . nextElement ( ) ; String inputEntryName = inputEntry . getName ( ) ; int index = inputEntryName . indexOf ( "META-INF" ) ; if ( index < 0 ) { try { output . putNextEntry ( processEntry ( zipf , inputEntry ) ) ; } catch ( ZipException ex ) { String mess = ex . getMessage ( ) ; if ( mess . indexOf ( "duplicate" ) >= 0 ) { continue ; } else { throw ex ; } } InputStream in = zipf . getInputStream ( inputEntry ) ; int len = buffer . length ; int count = - 1 ; while ( ( count = in . read ( buffer , 0 , len ) ) > 0 ) { output . write ( buffer , 0 , count ) ; } in . close ( ) ; output . closeEntry ( ) ; } } zipf . close ( ) ; } private void addDirContents ( ZipOutputStream output , File dir , String prefix , boolean compress ) throws IOException { String [ ] contents = dir . list ( ) ; for ( int i = 0 ; i < contents . length ; ++ i ) { String name = contents [ i ] ; File file = new File ( dir , name ) ; if ( file . isDirectory ( ) ) { addDirContents ( output , file , prefix + name + '/' , compress ) ; } else { addFile ( output , file , prefix , compress ) ; } } } private String getEntryName ( File file , String prefix ) { String name = file . getName ( ) ; if ( ! name . endsWith ( ".class" ) ) { InputStream input = null ; try { input = new FileInputStream ( file ) ; String className = ClassNameReader . getClassName ( input ) ; if ( className != null ) { return className . replace ( '.' , '/' ) + ".class" ; } } catch ( IOException ioe ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IOException e ) { } } } } System . out . println ( "From " + file . getPath ( ) + " and prefix " + prefix + ", creating entry " + prefix + name ) ; return ( prefix + name ) ; } private void addFile ( ZipOutputStream output , File file , String prefix , boolean compress ) throws IOException { if ( ! file . exists ( ) ) { return ; } ZipEntry entry = new ZipEntry ( getEntryName ( file , prefix ) ) ; entry . setTime ( file . lastModified ( ) ) ; entry . setSize ( file . length ( ) ) ; if ( ! compress ) { entry . setCrc ( calcChecksum ( file ) ) ; } FileInputStream input = new FileInputStream ( file ) ; addToOutputStream ( output , input , entry ) ; } private void addToOutputStream ( ZipOutputStream output , InputStream input , ZipEntry ze ) throws IOException { try { output . putNextEntry ( ze ) ; } catch ( ZipException zipEx ) { input . close ( ) ; return ; } int numBytes = - 1 ; while ( ( numBytes = input . read ( buffer ) ) > 0 ) { output . write ( buffer , 0 , numBytes ) ; } output . closeEntry ( ) ; input . close ( ) ; } private ZipEntry processEntry ( ZipFile zip , ZipEntry inputEntry ) { String name = inputEntry . getName ( ) ; if ( ! ( inputEntry . isDirectory ( ) || name . endsWith ( ".class" ) ) ) { try { InputStream input = zip . getInputStream ( zip . getEntry ( name ) ) ; String className = ClassNameReader . getClassName ( input ) ; input . close ( ) ; if ( className != null ) { name = className . replace ( '.' , '/' ) + ".class" ; } } catch ( IOException ioe ) { } } ZipEntry outputEntry = new ZipEntry ( name ) ; outputEntry . setTime ( inputEntry . getTime ( ) ) ; outputEntry . setExtra ( inputEntry . getExtra ( ) ) ; outputEntry . setComment ( inputEntry . getComment ( ) ) ; outputEntry . setTime ( inputEntry . getTime ( ) ) ; if ( compression ) { outputEntry . setMethod ( ZipEntry . DEFLATED ) ; } else { outputEntry . setMethod ( ZipEntry . STORED ) ; outputEntry . setCrc ( inputEntry . getCrc ( ) ) ; outputEntry . setSize ( inputEntry . getSize ( ) ) ; } return outputEntry ; } private long calcChecksum ( File f ) throws IOException { BufferedInputStream in = new BufferedInputStream ( new FileInputStream ( f ) ) ; return calcChecksum ( in ) ; } private long calcChecksum ( InputStream in ) throws IOException { CRC32 crc = new CRC32 ( ) ; int len = buffer . length ; int count = - 1 ; int haveRead = 0 ; while ( ( count = in . read ( buffer , 0 , len ) ) > 0 ) { haveRead += count ; crc . update ( buffer , 0 , count ) ; } in . close ( ) ; return crc . getValue ( ) ; } } 	0	['17', '1', '0', '2', '81', '100', '1', '1', '9', '0.7125', '654', '0.8', '0', '0', '0.274509804', '0', '0', '37.17647059', '7', '2.0588', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class SimpleP4OutputHandler extends P4HandlerAdapter { P4Base parent ; public SimpleP4OutputHandler ( P4Base parent ) { this . parent = parent ; } public void process ( String line ) throws BuildException { if ( parent . util . match ( "/^exit/" , line ) ) { return ; } if ( parent . util . match ( "/^error:/" , line ) || parent . util . match ( "/^Perforce client error:/" , line ) ) { if ( ! parent . util . match ( "/label in sync/" , line ) && ! parent . util . match ( "/up-to-date/" , line ) ) { parent . setInError ( true ) ; } else { line = parent . util . substitute ( "s/^[^:]*: //" , line ) ; } } else if ( parent . util . match ( "/^info.*?:/" , line ) ) { line = parent . util . substitute ( "s/^[^:]*: //" , line ) ; } parent . log ( line , parent . getInError ( ) ? Project . MSG_ERR : Project . MSG_INFO ) ; if ( parent . getInError ( ) ) { parent . setErrorMessage ( parent . getErrorMessage ( ) + line + StringUtils . LINE_SEP ) ; } } } 	0	['2', '2', '1', '17', '14', '0', '13', '5', '2', '0', '103', '0', '1', '0.875', '0.666666667', '0', '0', '50', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . CompositeMapper ; import org . apache . tools . ant . util . ContainerMapper ; public class Mapper extends DataType implements Cloneable { protected MapperType type = null ; protected String classname = null ; protected Path classpath = null ; protected String from = null ; protected String to = null ; private ContainerMapper container = null ; public Mapper ( Project p ) { setProject ( p ) ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } public void addConfigured ( FileNameMapper fileNameMapper ) { add ( fileNameMapper ) ; } public void add ( FileNameMapper fileNameMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( container == null ) { if ( type == null && classname == null ) { container = new CompositeMapper ( ) ; } else { FileNameMapper m = getImplementation ( ) ; if ( m instanceof ContainerMapper ) { container = ( ContainerMapper ) m ; } else { throw new BuildException ( String . valueOf ( m ) + " mapper implementation does not support nested mappers!" ) ; } } } container . add ( fileNameMapper ) ; } public void addConfiguredMapper ( Mapper mapper ) { add ( mapper . getImplementation ( ) ) ; } public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference ref ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( ref ) ; } public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null && container == null ) { throw new BuildException ( "nested mapper or " + "one of the attributes type or classname is required" ) ; } if ( container != null ) { return container ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { FileNameMapper m = ( FileNameMapper ) ( getImplementationClass ( ) . newInstance ( ) ) ; final Project p = getProject ( ) ; if ( p != null ) { p . setProjectReference ( m ) ; } m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } protected Class getImplementationClass ( ) throws ClassNotFoundException { String cName = this . classname ; if ( type != null ) { cName = type . getImplementation ( ) ; } ClassLoader loader = ( classpath == null ) ? getClass ( ) . getClassLoader ( ) : getProject ( ) . createClassLoader ( classpath ) ; return Class . forName ( cName , true , loader ) ; } protected Mapper getRef ( ) { return ( Mapper ) getCheckedRef ( ) ; } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; implementations . put ( "package" , "org.apache.tools.ant.util.PackageNameMapper" ) ; implementations . put ( "unpackage" , "org.apache.tools.ant.util.UnPackageNameMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" , "package" , "unpackage" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['15', '3', '0', '25', '44', '45', '16', '10', '13', '0.619047619', '311', '1', '3', '0.681818182', '0.216666667', '1', '1', '19.33333333', '6', '1.8667', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . dispatch . DispatchUtils ; import java . util . Enumeration ; import java . io . IOException ; public abstract class Task extends ProjectComponent { protected Target target ; protected String taskName ; protected String taskType ; protected RuntimeConfigurable wrapper ; private boolean invalid ; public Task ( ) { } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void setTaskType ( String type ) { this . taskType = type ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } public void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( ! invalid ) { if ( wrapper != null ) { wrapper . maybeConfigure ( getProject ( ) ) ; } } else { getReplacement ( ) ; } } public void reconfigure ( ) { if ( wrapper != null ) { wrapper . reconfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { log ( output , Project . MSG_INFO ) ; } protected void handleFlush ( String output ) { handleOutput ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return getProject ( ) . defaultInput ( buffer , offset , length ) ; } protected void handleErrorOutput ( String output ) { log ( output , Project . MSG_WARN ) ; } protected void handleErrorFlush ( String output ) { handleErrorOutput ( output ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( this , msg , msgLevel ) ; } else { super . log ( msg , msgLevel ) ; } } public void log ( Throwable t , int msgLevel ) { if ( t != null ) { log ( t . getMessage ( ) , t , msgLevel ) ; } } public void log ( String msg , Throwable t , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( this , msg , t , msgLevel ) ; } else { super . log ( msg , msgLevel ) ; } } public final void perform ( ) { if ( ! invalid ) { getProject ( ) . fireTaskStarted ( this ) ; Throwable reason = null ; try { maybeConfigure ( ) ; DispatchUtils . execute ( this ) ; } catch ( BuildException ex ) { if ( ex . getLocation ( ) == Location . UNKNOWN_LOCATION ) { ex . setLocation ( getLocation ( ) ) ; } reason = ex ; throw ex ; } catch ( Exception ex ) { reason = ex ; BuildException be = new BuildException ( ex ) ; be . setLocation ( getLocation ( ) ) ; throw be ; } catch ( Error ex ) { reason = ex ; throw ex ; } finally { getProject ( ) . fireTaskFinished ( this , reason ) ; } } else { UnknownElement ue = getReplacement ( ) ; Task task = ue . getTask ( ) ; task . perform ( ) ; } } final void markInvalid ( ) { invalid = true ; } protected final boolean isInvalid ( ) { return invalid ; } private UnknownElement replacement ; private UnknownElement getReplacement ( ) { if ( replacement == null ) { replacement = new UnknownElement ( taskType ) ; replacement . setProject ( getProject ( ) ) ; replacement . setTaskType ( taskType ) ; replacement . setTaskName ( taskName ) ; replacement . setLocation ( location ) ; replacement . setOwningTarget ( target ) ; replacement . setRuntimeConfigurableWrapper ( wrapper ) ; wrapper . setProxy ( replacement ) ; replaceChildren ( wrapper , replacement ) ; target . replaceChild ( this , replacement ) ; replacement . maybeConfigure ( ) ; } return replacement ; } private void replaceChildren ( RuntimeConfigurable wrapper , UnknownElement parentElement ) { Enumeration e = wrapper . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable childWrapper = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement childElement = new UnknownElement ( childWrapper . getElementTag ( ) ) ; parentElement . addChild ( childElement ) ; childElement . setProject ( getProject ( ) ) ; childElement . setRuntimeConfigurableWrapper ( childWrapper ) ; childWrapper . setProxy ( childElement ) ; replaceChildren ( childWrapper , childElement ) ; } } public String getTaskType ( ) { return taskType ; } protected RuntimeConfigurable getWrapper ( ) { return wrapper ; } public final void bindToOwner ( Task owner ) { setProject ( owner . getProject ( ) ) ; setOwningTarget ( owner . getOwningTarget ( ) ) ; setTaskName ( owner . getTaskName ( ) ) ; setDescription ( owner . getDescription ( ) ) ; setLocation ( owner . getLocation ( ) ) ; setTaskType ( owner . getTaskType ( ) ) ; } } 	0	['29', '2', '102', '184', '66', '346', '181', '8', '19', '0.839285714', '375', '1', '3', '0.243243243', '0.191570881', '1', '1', '11.72413793', '5', '1.3448', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public class HashvalueAlgorithm implements Algorithm { public boolean isValid ( ) { return true ; } public String getValue ( File file ) { try { if ( ! file . canRead ( ) ) { return null ; } java . io . FileInputStream fis = new java . io . FileInputStream ( file ) ; byte [ ] content = new byte [ fis . available ( ) ] ; fis . read ( content ) ; fis . close ( ) ; String s = new String ( content ) ; int hash = s . hashCode ( ) ; return Integer . toString ( hash ) ; } catch ( Exception e ) { return null ; } } public String toString ( ) { return "HashvalueAlgorithm" ; } } 	0	['4', '1', '0', '2', '13', '6', '1', '1', '4', '2', '45', '0', '0', '0', '0.625', '0', '0', '10.25', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; public class SourceFileScanner implements ResourceFactory { protected Task task ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destDir ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { return restrict ( files , srcDir , destDir , mapper , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper , long granularity ) { this . destDir = destDir ; Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File src = FILE_UTILS . resolveFile ( srcDir , files [ i ] ) ; v . addElement ( new Resource ( files [ i ] , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ) ; } Resource [ ] sourceresources = new Resource [ v . size ( ) ] ; v . copyInto ( sourceresources ) ; Resource [ ] outofdate = ResourceUtils . selectOutOfDateSources ( task , sourceresources , mapper , this , granularity ) ; String [ ] result = new String [ outofdate . length ] ; for ( int counter = 0 ; counter < outofdate . length ; counter ++ ) { result [ counter ] = outofdate [ counter ] . getName ( ) ; } return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { return restrictAsFiles ( files , srcDir , destDir , mapper , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper , long granularity ) { String [ ] res = restrict ( files , srcDir , destDir , mapper , granularity ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } public Resource getResource ( String name ) { return new FileResource ( destDir , name ) ; } } 	0	['7', '1', '0', '15', '23', '5', '7', '8', '6', '0.444444444', '148', '1', '2', '0', '0.523809524', '0', '0', '19.71428571', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . i18n ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LineTokenizer ; public class Translate extends MatchingTask { private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0 ; private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1 ; private static final int BUNDLE_SPECIFIED_LANGUAGE = 2 ; private static final int BUNDLE_NOMATCH = 3 ; private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4 ; private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5 ; private static final int BUNDLE_DEFAULT_LANGUAGE = 6 ; private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1 ; private String bundle ; private String bundleLanguage ; private String bundleCountry ; private String bundleVariant ; private File toDir ; private String srcEncoding ; private String destEncoding ; private String bundleEncoding ; private String startToken ; private String endToken ; private boolean forceOverwrite ; private Vector filesets = new Vector ( ) ; private Hashtable resourceMap = new Hashtable ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private long [ ] bundleLastModified = new long [ BUNDLE_MAX_ALTERNATIVES ] ; private long srcLastModified ; private long destLastModified ; private boolean loaded = false ; public void setBundle ( String bundle ) { this . bundle = bundle ; } public void setBundleLanguage ( String bundleLanguage ) { this . bundleLanguage = bundleLanguage ; } public void setBundleCountry ( String bundleCountry ) { this . bundleCountry = bundleCountry ; } public void setBundleVariant ( String bundleVariant ) { this . bundleVariant = bundleVariant ; } public void setToDir ( File toDir ) { this . toDir = toDir ; } public void setStartToken ( String startToken ) { this . startToken = startToken ; } public void setEndToken ( String endToken ) { this . endToken = endToken ; } public void setSrcEncoding ( String srcEncoding ) { this . srcEncoding = srcEncoding ; } public void setDestEncoding ( String destEncoding ) { this . destEncoding = destEncoding ; } public void setBundleEncoding ( String bundleEncoding ) { this . bundleEncoding = bundleEncoding ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( bundle == null ) { throw new BuildException ( "The bundle attribute must be set." , getLocation ( ) ) ; } if ( startToken == null ) { throw new BuildException ( "The starttoken attribute must be set." , getLocation ( ) ) ; } if ( endToken == null ) { throw new BuildException ( "The endtoken attribute must be set." , getLocation ( ) ) ; } if ( bundleLanguage == null ) { Locale l = Locale . getDefault ( ) ; bundleLanguage = l . getLanguage ( ) ; } if ( bundleCountry == null ) { bundleCountry = Locale . getDefault ( ) . getCountry ( ) ; } if ( bundleVariant == null ) { Locale l = new Locale ( bundleLanguage , bundleCountry ) ; bundleVariant = l . getVariant ( ) ; } if ( toDir == null ) { throw new BuildException ( "The todir attribute must be set." , getLocation ( ) ) ; } if ( ! toDir . exists ( ) ) { toDir . mkdirs ( ) ; } else if ( toDir . isFile ( ) ) { throw new BuildException ( toDir + " is not a directory" ) ; } if ( srcEncoding == null ) { srcEncoding = System . getProperty ( "file.encoding" ) ; } if ( destEncoding == null ) { destEncoding = srcEncoding ; } if ( bundleEncoding == null ) { bundleEncoding = srcEncoding ; } loadResourceMaps ( ) ; translate ( ) ; } private void loadResourceMaps ( ) throws BuildException { Locale locale = new Locale ( bundleLanguage , bundleCountry , bundleVariant ) ; String language = locale . getLanguage ( ) . length ( ) > 0 ? "_" + locale . getLanguage ( ) : "" ; String country = locale . getCountry ( ) . length ( ) > 0 ? "_" + locale . getCountry ( ) : "" ; String variant = locale . getVariant ( ) . length ( ) > 0 ? "_" + locale . getVariant ( ) : "" ; String bundleFile = bundle + language + country + variant ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT , false ) ; bundleFile = bundle + language + country ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE_COUNTRY , false ) ; bundleFile = bundle + language ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE , false ) ; bundleFile = bundle ; processBundle ( bundleFile , BUNDLE_NOMATCH , false ) ; locale = Locale . getDefault ( ) ; language = locale . getLanguage ( ) . length ( ) > 0 ? "_" + locale . getLanguage ( ) : "" ; country = locale . getCountry ( ) . length ( ) > 0 ? "_" + locale . getCountry ( ) : "" ; variant = locale . getVariant ( ) . length ( ) > 0 ? "_" + locale . getVariant ( ) : "" ; bundleEncoding = System . getProperty ( "file.encoding" ) ; bundleFile = bundle + language + country + variant ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT , false ) ; bundleFile = bundle + language + country ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE_COUNTRY , false ) ; bundleFile = bundle + language ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE , true ) ; } private void processBundle ( final String bundleFile , final int i , final boolean checkLoaded ) throws BuildException { final File propsFile = getProject ( ) . resolveFile ( bundleFile + ".properties" ) ; FileInputStream ins = null ; try { ins = new FileInputStream ( propsFile ) ; loaded = true ; bundleLastModified [ i ] = propsFile . lastModified ( ) ; log ( "Using " + propsFile , Project . MSG_DEBUG ) ; loadResourceMap ( ins ) ; } catch ( IOException ioe ) { log ( propsFile + " not found." , Project . MSG_DEBUG ) ; if ( ! loaded && checkLoaded ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } } private void loadResourceMap ( FileInputStream ins ) throws BuildException { try { BufferedReader in = null ; InputStreamReader isr = new InputStreamReader ( ins , bundleEncoding ) ; in = new BufferedReader ( isr ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . trim ( ) . length ( ) > 1 && '#' != line . charAt ( 0 ) && '!' != line . charAt ( 0 ) ) { int sepIndex = line . indexOf ( '=' ) ; if ( - 1 == sepIndex ) { sepIndex = line . indexOf ( ':' ) ; } if ( - 1 == sepIndex ) { for ( int k = 0 ; k < line . length ( ) ; k ++ ) { if ( Character . isSpaceChar ( line . charAt ( k ) ) ) { sepIndex = k ; break ; } } } if ( - 1 != sepIndex ) { String key = line . substring ( 0 , sepIndex ) . trim ( ) ; String value = line . substring ( sepIndex + 1 ) . trim ( ) ; while ( value . endsWith ( "\\" ) ) { value = value . substring ( 0 , value . length ( ) - 1 ) ; if ( ( line = in . readLine ( ) ) != null ) { value = value + line . trim ( ) ; } else { break ; } } if ( key . length ( ) > 0 ) { if ( resourceMap . get ( key ) == null ) { resourceMap . put ( key , value ) ; } } } } } if ( in != null ) { in . close ( ) ; } } catch ( IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } private void translate ( ) throws BuildException { int filesProcessed = 0 ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { try { File dest = FILE_UTILS . resolveFile ( toDir , srcFiles [ j ] ) ; try { File destDir = new File ( dest . getParent ( ) ) ; if ( ! destDir . exists ( ) ) { destDir . mkdirs ( ) ; } } catch ( Exception e ) { log ( "Exception occurred while trying to check/create " + " parent directory.  " + e . getMessage ( ) , Project . MSG_DEBUG ) ; } destLastModified = dest . lastModified ( ) ; File src = FILE_UTILS . resolveFile ( ds . getBasedir ( ) , srcFiles [ j ] ) ; srcLastModified = src . lastModified ( ) ; boolean needsWork = forceOverwrite || destLastModified < srcLastModified ; if ( ! needsWork ) { for ( int icounter = 0 ; icounter < BUNDLE_MAX_ALTERNATIVES ; icounter ++ ) { needsWork = ( destLastModified < bundleLastModified [ icounter ] ) ; if ( needsWork ) { break ; } } } if ( needsWork ) { log ( "Processing " + srcFiles [ j ] , Project . MSG_DEBUG ) ; FileOutputStream fos = new FileOutputStream ( dest ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( fos , destEncoding ) ) ; FileInputStream fis = new FileInputStream ( src ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( fis , srcEncoding ) ) ; String line ; LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; line = lineTokenizer . getToken ( in ) ; while ( ( line ) != null ) { int startIndex = line . indexOf ( startToken ) ; while ( startIndex >= 0 && ( startIndex + startToken . length ( ) ) <= line . length ( ) ) { String replace = null ; int endIndex = line . indexOf ( endToken , startIndex + startToken . length ( ) ) ; if ( endIndex < 0 ) { startIndex += 1 ; } else { String token = line . substring ( startIndex + startToken . length ( ) , endIndex ) ; boolean validToken = true ; for ( int k = 0 ; k < token . length ( ) && validToken ; k ++ ) { char c = token . charAt ( k ) ; if ( c == ':' || c == '=' || Character . isSpaceChar ( c ) ) { validToken = false ; } } if ( ! validToken ) { startIndex += 1 ; } else { if ( resourceMap . containsKey ( token ) ) { replace = ( String ) resourceMap . get ( token ) ; } else { log ( "Replacement string missing for: " + token , Project . MSG_VERBOSE ) ; replace = startToken + token + endToken ; } line = line . substring ( 0 , startIndex ) + replace + line . substring ( endIndex + endToken . length ( ) ) ; startIndex += replace . length ( ) ; } } startIndex = line . indexOf ( startToken , startIndex ) ; } out . write ( line ) ; line = lineTokenizer . getToken ( in ) ; } if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } ++ filesProcessed ; } else { log ( "Skipping " + srcFiles [ j ] + " as destination file is up to date" , Project . MSG_VERBOSE ) ; } } catch ( IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } } log ( "Translation performed on " + filesProcessed + " file(s)." , Project . MSG_DEBUG ) ; } } 	0	['19', '4', '0', '8', '84', '103', '0', '8', '14', '0.929487179', '1034', '1', '1', '0.821052632', '0.26984127', '0', '0', '52.05263158', '1', '0.8947', '0']
package org . apache . tools . ant . util . optional ; import org . apache . tools . ant . util . WeakishReference ; public class WeakishReference12 extends WeakishReference . HardReference { public WeakishReference12 ( Object reference ) { super ( reference ) ; } } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public static final String NAME_KEY = "name" ; public static final String CASE_KEY = "casesensitive" ; public static final String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '10', '23', '0', '6', '4', '8', '0.761904762', '197', '0.5', '0', '0.844444444', '0.35', '1', '4', '22.875', '6', '2.25', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . io . BufferedOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class FormatterElement { private String classname ; private String extension ; private OutputStream out = System . out ; private File outFile ; private boolean useFile = true ; private String ifProperty ; private String unlessProperty ; public static final String XML_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter" ; public static final String BRIEF_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter" ; public static final String PLAIN_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter" ; public void setType ( TypeAttribute type ) { if ( "xml" . equals ( type . getValue ( ) ) ) { setClassname ( XML_FORMATTER_CLASS_NAME ) ; } else { if ( "brief" . equals ( type . getValue ( ) ) ) { setClassname ( BRIEF_FORMATTER_CLASS_NAME ) ; } else { setClassname ( PLAIN_FORMATTER_CLASS_NAME ) ; } } } public void setClassname ( String classname ) { this . classname = classname ; if ( XML_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".xml" ) ; } else if ( PLAIN_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".txt" ) ; } else if ( BRIEF_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".txt" ) ; } } public String getClassname ( ) { return classname ; } public void setExtension ( String ext ) { this . extension = ext ; } public String getExtension ( ) { return extension ; } void setOutfile ( File out ) { this . outFile = out ; } public void setOutput ( OutputStream out ) { this . out = out ; } public void setUseFile ( boolean useFile ) { this . useFile = useFile ; } boolean getUseFile ( ) { return useFile ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( Task t ) { if ( ifProperty != null && t . getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && t . getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } JUnitTaskMirror . JUnitResultFormatterMirror createFormatter ( ) throws BuildException { return createFormatter ( null ) ; } JUnitTaskMirror . JUnitResultFormatterMirror createFormatter ( ClassLoader loader ) throws BuildException { if ( classname == null ) { throw new BuildException ( "you must specify type or classname" ) ; } Class f = null ; try { if ( loader == null ) { f = Class . forName ( classname ) ; } else { f = Class . forName ( classname , true , loader ) ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Using loader " + loader + " on class " + classname + ": " + e , e ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Using loader " + loader + " on class " + classname + ": " + e , e ) ; } Object o = null ; try { o = f . newInstance ( ) ; } catch ( InstantiationException e ) { throw new BuildException ( e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( e ) ; } if ( ! ( o instanceof JUnitTaskMirror . JUnitResultFormatterMirror ) ) { throw new BuildException ( classname + " is not a JUnitResultFormatter" ) ; } JUnitTaskMirror . JUnitResultFormatterMirror r = ( JUnitTaskMirror . JUnitResultFormatterMirror ) o ; if ( useFile && outFile != null ) { try { out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; } catch ( java . io . IOException e ) { throw new BuildException ( "Unable to open file " + outFile , e ) ; } } r . setOutput ( out ) ; return r ; } public static class TypeAttribute extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "plain" , "xml" , "brief" } ; } } } 	0	['15', '1', '0', '7', '34', '75', '2', '5', '11', '0.9', '286', '0.7', '0', '0', '0.208333333', '0', '0', '17.4', '5', '1.5333', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { return newRegexpMatcher ( null ) ; } public RegexpMatcher newRegexpMatcher ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( MagicNames . REGEXP_IMPL ) ; } else { systemDefault = p . getProperty ( MagicNames . REGEXP_IMPL ) ; } if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } Throwable cause = null ; try { testAvailability ( "java.util.regex.Matcher" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , JavaEnvUtils . getJavaVersionNumber ( ) < 14 ) ; } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } try { testAvailability ( "org.apache.regexp.RE" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } throw new BuildException ( "No supported regular expression matcher found" + ( cause != null ? ": " + cause : "" ) , cause ) ; } static Throwable orCause ( Throwable deflt , BuildException be , boolean ignoreCnfe ) { if ( deflt != null ) { return deflt ; } Throwable t = be . getException ( ) ; return ignoreCnfe && t instanceof ClassNotFoundException ? null : t ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { return ( RegexpMatcher ) ClasspathUtils . newInstance ( className , RegexpMatcherFactory . class . getClassLoader ( ) , RegexpMatcher . class ) ; } protected void testAvailability ( String className ) throws BuildException { try { Class . forName ( className ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['6', '1', '1', '8', '22', '15', '3', '5', '3', '0.8', '163', '0', '0', '0', '0.305555556', '0', '0', '25.83333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class Mkdir extends Task { private static final int MKDIR_RETRY_SLEEP_MILLIS = 10 ; private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , getLocation ( ) ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file " + "already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = mkdirs ( dir ) ; if ( ! result ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } else { log ( "Skipping " + dir . getAbsolutePath ( ) + " because it already exists." , Project . MSG_VERBOSE ) ; } } public void setDir ( File dir ) { this . dir = dir ; } private boolean mkdirs ( File f ) { if ( ! f . mkdirs ( ) ) { try { Thread . sleep ( MKDIR_RETRY_SLEEP_MILLIS ) ; return f . mkdirs ( ) ; } catch ( InterruptedException ex ) { return f . mkdirs ( ) ; } } return true ; } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '1', '111', '1', '0', '0.925', '0.75', '2', '2', '26.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; class ConstantPool { static final byte UTF8 = 1 , UNUSED = 2 , INTEGER = 3 , FLOAT = 4 , LONG = 5 , DOUBLE = 6 , CLASS = 7 , STRING = 8 , FIELDREF = 9 , METHODREF = 10 , INTERFACEMETHODREF = 11 , NAMEANDTYPE = 12 ; byte [ ] types ; Object [ ] values ; ConstantPool ( DataInput data ) throws IOException { super ( ) ; int count = data . readUnsignedShort ( ) ; types = new byte [ count ] ; values = new Object [ count ] ; for ( int i = 1 ; i < count ; i ++ ) { byte type = data . readByte ( ) ; types [ i ] = type ; switch ( type ) { case UTF8 : values [ i ] = data . readUTF ( ) ; break ; case UNUSED : break ; case INTEGER : values [ i ] = new Integer ( data . readInt ( ) ) ; break ; case FLOAT : values [ i ] = new Float ( data . readFloat ( ) ) ; break ; case LONG : values [ i ] = new Long ( data . readLong ( ) ) ; ++ i ; break ; case DOUBLE : values [ i ] = new Double ( data . readDouble ( ) ) ; ++ i ; break ; case CLASS : case STRING : values [ i ] = new Integer ( data . readUnsignedShort ( ) ) ; break ; case FIELDREF : case METHODREF : case INTERFACEMETHODREF : case NAMEANDTYPE : values [ i ] = new Integer ( data . readInt ( ) ) ; break ; default : } } } } public class ClassNameReader extends Object { public static String getClassName ( InputStream input ) throws IOException { DataInputStream data = new DataInputStream ( input ) ; int cookie = data . readInt ( ) ; if ( cookie != 0xCAFEBABE ) { return null ; } data . readInt ( ) ; ConstantPool constants = new ConstantPool ( data ) ; Object [ ] values = constants . values ; data . readUnsignedShort ( ) ; int classIndex = data . readUnsignedShort ( ) ; Integer stringIndex = ( Integer ) values [ classIndex ] ; String className = ( String ) values [ stringIndex . intValue ( ) ] ; return className ; } } 	0	['2', '1', '0', '2', '8', '1', '1', '1', '2', '2', '48', '0', '0', '0', '0.5', '0', '0', '23', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; public interface MSVSSConstants { String SS_EXE = "ss" ; String PROJECT_PREFIX = "$" ; String COMMAND_CP = "CP" ; String COMMAND_ADD = "Add" ; String COMMAND_GET = "Get" ; String COMMAND_CHECKOUT = "Checkout" ; String COMMAND_CHECKIN = "Checkin" ; String COMMAND_LABEL = "Label" ; String COMMAND_HISTORY = "History" ; String COMMAND_CREATE = "Create" ; String STYLE_BRIEF = "brief" ; String STYLE_CODEDIFF = "codediff" ; String STYLE_NOFILE = "nofile" ; String STYLE_DEFAULT = "default" ; String TIME_CURRENT = "current" ; String TIME_MODIFIED = "modified" ; String TIME_UPDATED = "updated" ; String WRITABLE_REPLACE = "replace" ; String WRITABLE_SKIP = "skip" ; String WRITABLE_FAIL = "fail" ; String FLAG_LOGIN = "-Y" ; String FLAG_OVERRIDE_WORKING_DIR = "-GL" ; String FLAG_AUTORESPONSE_DEF = "-I-" ; String FLAG_AUTORESPONSE_YES = "-I-Y" ; String FLAG_AUTORESPONSE_NO = "-I-N" ; String FLAG_RECURSION = "-R" ; String FLAG_VERSION = "-V" ; String FLAG_VERSION_DATE = "-Vd" ; String FLAG_VERSION_LABEL = "-VL" ; String FLAG_WRITABLE = "-W" ; String VALUE_NO = "-N" ; String VALUE_YES = "-Y" ; String FLAG_QUIET = "-O-" ; String FLAG_COMMENT = "-C" ; String FLAG_LABEL = "-L" ; String VALUE_FROMDATE = "~d" ; String VALUE_FROMLABEL = "~L" ; String FLAG_OUTPUT = "-O" ; String FLAG_USER = "-U" ; String FLAG_NO_FILE = "-F-" ; String FLAG_BRIEF = "-B" ; String FLAG_CODEDIFF = "-D" ; String FLAG_FILETIME_DEF = "-GTC" ; String FLAG_FILETIME_MODIFIED = "-GTM" ; String FLAG_FILETIME_UPDATED = "-GTU" ; String FLAG_REPLACE_WRITABLE = "-GWR" ; String FLAG_SKIP_WRITABLE = "-GWS" ; String FLAG_NO_GET = "-G-" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '48', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMklbtype extends ClearCase { private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; private boolean mReplace = false ; private boolean mGlobal = false ; private boolean mOrdinary = true ; private boolean mPbranch = false ; private boolean mShared = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKLBTYPE ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getTypeSpecifier ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getOrdinary ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_ORDINARY ) ; } else { if ( getGlobal ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_GLOBAL ) ; } } if ( getPbranch ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PBRANCH ) ; } if ( getShared ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_SHARED ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getTypeSpecifier ( ) ) ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } public void setReplace ( boolean repl ) { mReplace = repl ; } public boolean getReplace ( ) { return mReplace ; } public void setGlobal ( boolean glob ) { mGlobal = glob ; } public boolean getGlobal ( ) { return mGlobal ; } public void setOrdinary ( boolean ordinary ) { mOrdinary = ordinary ; } public boolean getOrdinary ( ) { return mOrdinary ; } public void setPbranch ( boolean pbranch ) { mPbranch = pbranch ; } public boolean getPbranch ( ) { return mPbranch ; } public void setShared ( boolean shared ) { mShared = shared ; } public boolean getShared ( ) { return mShared ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private String getTypeSpecifier ( ) { String typenm = null ; typenm = getTypeName ( ) ; if ( getVOB ( ) != null ) { typenm += "@" + getVOB ( ) ; } return typenm ; } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_GLOBAL = "-global" ; public static final String FLAG_ORDINARY = "-ordinary" ; public static final String FLAG_PBRANCH = "-pbranch" ; public static final String FLAG_SHARED = "-shared" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['24', '4', '0', '7', '43', '222', '0', '7', '20', '0.943734015', '309', '0.529411765', '0', '0.676056338', '0.375', '2', '2', '11.16666667', '8', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . pvcs ; public class PvcsProject { private String name ; public PvcsProject ( ) { super ( ) ; } public void setName ( String name ) { PvcsProject . this . name = name ; } public String getName ( ) { return name ; } } 	0	['3', '1', '0', '1', '4', '1', '1', '0', '3', '0.5', '14', '1', '0', '0', '0.666666667', '0', '0', '3.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public final class StripJavaComments extends BaseFilterReader implements ChainableReader { private int readAheadCh = - 1 ; private boolean inString = false ; private boolean quoted = false ; public StripJavaComments ( ) { super ( ) ; } public StripJavaComments ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( readAheadCh != - 1 ) { ch = readAheadCh ; readAheadCh = - 1 ; } else { ch = in . read ( ) ; if ( ch == '"' && ! quoted ) { inString = ! inString ; quoted = false ; } else if ( ch == '\\' ) { quoted = ! quoted ; } else { quoted = false ; if ( ! inString ) { if ( ch == '/' ) { ch = in . read ( ) ; if ( ch == '/' ) { while ( ch != '\n' && ch != - 1 && ch != '\r' ) { ch = in . read ( ) ; } } else if ( ch == '*' ) { while ( ch != - 1 ) { ch = in . read ( ) ; if ( ch == '*' ) { ch = in . read ( ) ; while ( ch == '*' && ch != - 1 ) { ch = in . read ( ) ; } if ( ch == '/' ) { ch = read ( ) ; break ; } } } } else { readAheadCh = ch ; ch = '/' ; } } } } } return ch ; } public Reader chain ( final Reader rdr ) { StripJavaComments newFilter = new StripJavaComments ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '3', '7', '0', '1', '2', '4', '0', '161', '1', '0', '0.928571429', '0.75', '2', '4', '38.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskAdapter ; public class Taskdef extends Typedef { public Taskdef ( ) { setAdapterClass ( TaskAdapter . class ) ; setAdaptToClass ( Task . class ) ; } } 	0	['1', '7', '0', '1', '7', '0', '0', '1', '1', '2', '40', '0', '0', '1', '1', '0', '0', '37', '0', '0', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; import org . apache . tools . ant . ProjectComponent ; public class LineTokenizer extends ProjectComponent implements Tokenizer { private String lineEnd = "" ; private int pushed = - 2 ; private boolean includeDelims = false ; public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } lineEnd = "" ; StringBuffer line = new StringBuffer ( ) ; int state = 0 ; while ( ch != - 1 ) { if ( state == 0 ) { if ( ch == '\r' ) { state = 1 ; } else if ( ch == '\n' ) { lineEnd = "\n" ; break ; } else { line . append ( ( char ) ch ) ; } } else { state = 0 ; if ( ch == '\n' ) { lineEnd = "\r\n" ; } else { pushed = ch ; lineEnd = "\r" ; } break ; } ch = in . read ( ) ; } if ( ch == - 1 && state == 1 ) { lineEnd = "\r" ; } if ( includeDelims ) { line . append ( lineEnd ) ; } return line . toString ( ) ; } public String getPostToken ( ) { if ( includeDelims ) { return "" ; } return lineEnd ; } } 	0	['4', '2', '0', '8', '10', '0', '6', '2', '4', '0.333333333', '125', '1', '0', '0.75', '0.5', '0', '0', '29.5', '2', '1', '0']
package org . apache . tools . ant ; import java . io . File ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . apache . tools . ant . taskdefs . condition . Os ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) && ! token . startsWith ( "." ) && ! token . startsWith ( ".." ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '18', '0', '2', '1', '3', '0.25', '204', '1', '0', '0', '0.666666667', '0', '0', '65.66666667', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; public abstract class BaseParamFilterReader extends BaseFilterReader implements Parameterizable { private Parameter [ ] parameters ; public BaseParamFilterReader ( ) { super ( ) ; } public BaseParamFilterReader ( final Reader in ) { super ( in ) ; } public final void setParameters ( final Parameter [ ] parameters ) { this . parameters = parameters ; setInitialized ( false ) ; } protected final Parameter [ ] getParameters ( ) { return parameters ; } } 	0	['4', '4', '12', '15', '7', '4', '12', '3', '3', '0.666666667', '22', '1', '1', '0.928571429', '0.5', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public abstract class MappingSelector extends BaseSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected File targetdir = null ; protected Mapper mapperElement = null ; protected FileNameMapper map = null ; protected int granularity = 0 ; public MappingSelector ( ) { granularity = ( int ) FILE_UTILS . getFileTimestampGranularity ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir . getName ( ) + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; boolean selected = selectionTest ( file , destfile ) ; return selected ; } protected abstract boolean selectionTest ( File srcfile , File destfile ) ; public void setGranularity ( int granularity ) { this . granularity = granularity ; } } 	0	['8', '4', '2', '9', '24', '8', '2', '7', '6', '0.742857143', '143', '1', '3', '0.853658537', '0.428571429', '1', '3', '16.25', '4', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . FileInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; public class ConcatFileInputStream extends InputStream { private static final int EOF = - 1 ; private int currentIndex = - 1 ; private boolean eof = false ; private File [ ] file ; private InputStream currentStream ; private ProjectComponent managingPc ; public ConcatFileInputStream ( File [ ] file ) throws IOException { this . file = file ; } public void close ( ) throws IOException { closeCurrent ( ) ; eof = true ; } public int read ( ) throws IOException { int result = readCurrent ( ) ; if ( result == EOF && ! eof ) { openFile ( ++ currentIndex ) ; result = readCurrent ( ) ; } return result ; } public void setManagingTask ( Task task ) { setManagingComponent ( task ) ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { if ( loglevel > Project . MSG_WARN ) { System . out . println ( message ) ; } else { System . err . println ( message ) ; } } } private int readCurrent ( ) throws IOException { return ( eof || currentStream == null ) ? EOF : currentStream . read ( ) ; } private void openFile ( int index ) throws IOException { closeCurrent ( ) ; if ( file != null && index < file . length ) { log ( "Opening " + file [ index ] , Project . MSG_VERBOSE ) ; try { currentStream = new BufferedInputStream ( new FileInputStream ( file [ index ] ) ) ; } catch ( IOException eyeOhEx ) { log ( "Failed to open " + file [ index ] , Project . MSG_ERR ) ; throw eyeOhEx ; } } else { eof = true ; } } private void closeCurrent ( ) { FileUtils . close ( currentStream ) ; currentStream = null ; } } 	0	['9', '2', '0', '4', '19', '10', '1', '3', '6', '0.729166667', '159', '1', '1', '0.529411765', '0.277777778', '1', '1', '16', '3', '1.1111', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class And extends ResourceSelectorContainer implements ResourceSelector { public And ( ) { } public And ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ! ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { return false ; } } return true ; } } 	0	['3', '4', '0', '4', '9', '3', '1', '3', '3', '2', '27', '0', '0', '0.972222222', '0.555555556', '0', '0', '8', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JJTree extends Task { private static final String OUTPUT_FILE = "OUTPUT_FILE" ; private static final String BUILD_NODE_FILES = "BUILD_NODE_FILES" ; private static final String MULTI = "MULTI" ; private static final String NODE_DEFAULT_VOID = "NODE_DEFAULT_VOID" ; private static final String NODE_FACTORY = "NODE_FACTORY" ; private static final String NODE_SCOPE_HOOK = "NODE_SCOPE_HOOK" ; private static final String NODE_USES_PARSER = "NODE_USES_PARSER" ; private static final String STATIC = "STATIC" ; private static final String VISITOR = "VISITOR" ; private static final String NODE_PACKAGE = "NODE_PACKAGE" ; private static final String VISITOR_EXCEPTION = "VISITOR_EXCEPTION" ; private static final String NODE_PREFIX = "NODE_PREFIX" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private String outputFile = null ; private static final String DEFAULT_SUFFIX = ".jj" ; private File outputDirectory = null ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; public void setBuildnodefiles ( boolean buildNodeFiles ) { optionalAttrs . put ( BUILD_NODE_FILES , buildNodeFiles ? Boolean . TRUE : Boolean . FALSE ) ; } public void setMulti ( boolean multi ) { optionalAttrs . put ( MULTI , multi ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodedefaultvoid ( boolean nodeDefaultVoid ) { optionalAttrs . put ( NODE_DEFAULT_VOID , nodeDefaultVoid ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodefactory ( boolean nodeFactory ) { optionalAttrs . put ( NODE_FACTORY , nodeFactory ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodescopehook ( boolean nodeScopeHook ) { optionalAttrs . put ( NODE_SCOPE_HOOK , nodeScopeHook ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodeusesparser ( boolean nodeUsesParser ) { optionalAttrs . put ( NODE_USES_PARSER , nodeUsesParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setStatic ( boolean staticParser ) { optionalAttrs . put ( STATIC , staticParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setVisitor ( boolean visitor ) { optionalAttrs . put ( VISITOR , visitor ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodepackage ( String nodePackage ) { optionalAttrs . put ( NODE_PACKAGE , nodePackage ) ; } public void setVisitorException ( String visitorException ) { optionalAttrs . put ( VISITOR_EXCEPTION , visitorException ) ; } public void setNodeprefix ( String nodePrefix ) { optionalAttrs . put ( NODE_PREFIX , nodePrefix ) ; } public void setOutputdirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public void setOutputfile ( String outputFile ) { this . outputFile = outputFile ; } public void setTarget ( File targetFile ) { this . targetFile = targetFile ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JJTree ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } File javaFile = null ; if ( outputDirectory == null ) { cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + getDefaultOutputDirectory ( ) ) ; javaFile = new File ( createOutputFileName ( targetFile , outputFile , null ) ) ; } else { if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "'outputdirectory' " + outputDirectory + " is not a directory." ) ; } cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + outputDirectory . getAbsolutePath ( ) . replace ( '\\' , '/' ) ) ; javaFile = new File ( createOutputFileName ( targetFile , outputFile , outputDirectory . getPath ( ) ) ) ; } if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } if ( outputFile != null ) { cmdl . createArgument ( ) . setValue ( "-" + OUTPUT_FILE + ":" + outputFile . replace ( '\\' , '/' ) ) ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JJTREE ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; final Execute process = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_INFO ) , null ) ; log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; process . setCommandline ( cmdl . getCommandline ( ) ) ; try { if ( process . execute ( ) != 0 ) { throw new BuildException ( "JJTree failed." ) ; } } catch ( IOException e ) { throw new BuildException ( "Failed to launch JJTree" , e ) ; } } private String createOutputFileName ( File destFile , String optionalOutputFile , String outputDir ) { optionalOutputFile = validateOutputFile ( optionalOutputFile , outputDir ) ; String jjtreeFile = destFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( ( optionalOutputFile == null ) || optionalOutputFile . equals ( "" ) ) { int filePos = jjtreeFile . lastIndexOf ( "/" ) ; if ( filePos >= 0 ) { jjtreeFile = jjtreeFile . substring ( filePos + 1 ) ; } int suffixPos = jjtreeFile . lastIndexOf ( '.' ) ; if ( suffixPos == - 1 ) { optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX ; } else { String currentSuffix = jjtreeFile . substring ( suffixPos ) ; if ( currentSuffix . equals ( DEFAULT_SUFFIX ) ) { optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX ; } else { optionalOutputFile = jjtreeFile . substring ( 0 , suffixPos ) + DEFAULT_SUFFIX ; } } } if ( ( outputDir == null ) || outputDir . equals ( "" ) ) { outputDir = getDefaultOutputDirectory ( ) ; } return ( outputDir + "/" + optionalOutputFile ) . replace ( '\\' , '/' ) ; } private String validateOutputFile ( String destFile , String outputDir ) throws BuildException { if ( destFile == null ) { return null ; } if ( ( outputDir == null ) && ( destFile . startsWith ( "/" ) || destFile . startsWith ( "\\" ) ) ) { String relativeOutputFile = makeOutputFileRelative ( destFile ) ; setOutputfile ( relativeOutputFile ) ; return relativeOutputFile ; } String root = getRoot ( new File ( destFile ) ) . getAbsolutePath ( ) ; if ( ( root . length ( ) > 1 ) && destFile . startsWith ( root . substring ( 0 , root . length ( ) - 1 ) ) ) { throw new BuildException ( "Drive letter in 'outputfile' not " + "supported: " + destFile ) ; } return destFile ; } private String makeOutputFileRelative ( String destFile ) { StringBuffer relativePath = new StringBuffer ( ) ; String defaultOutputDirectory = getDefaultOutputDirectory ( ) ; int nextPos = defaultOutputDirectory . indexOf ( '/' ) ; int startPos = nextPos + 1 ; while ( startPos > - 1 && startPos < defaultOutputDirectory . length ( ) ) { relativePath . append ( "/.." ) ; nextPos = defaultOutputDirectory . indexOf ( '/' , startPos ) ; if ( nextPos == - 1 ) { startPos = nextPos ; } else { startPos = nextPos + 1 ; } } relativePath . append ( destFile ) ; return relativePath . toString ( ) ; } private String getDefaultOutputDirectory ( ) { return getProject ( ) . getBaseDir ( ) . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; } private File getRoot ( File file ) { File root = file . getAbsoluteFile ( ) ; while ( root . getParent ( ) != null ) { root = root . getParentFile ( ) ; } return root ; } } 	0	['22', '3', '0', '13', '80', '59', '0', '13', '17', '0.977443609', '678', '1', '1', '0.637931034', '0.477272727', '1', '1', '28.95454545', '8', '1.8182', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class DotnetBaseMatchingTask extends MatchingTask { protected File outputFile ; protected Vector filesets = new Vector ( ) ; protected File srcDir ; protected static final boolean isWindows = Os . isFamily ( "windows" ) ; public File getSrcDir ( ) { return this . srcDir ; } public void setSrcDir ( File srcDirName ) { this . srcDir = srcDirName ; } public void setDestFile ( File file ) { outputFile = file ; } public void addSrc ( FileSet src ) { filesets . add ( src ) ; } public File getDestFile ( ) { return outputFile ; } protected int buildFileList ( NetCommand command , Hashtable filesToBuild , long outputTimestamp ) { int filesOutOfDate = 0 ; boolean scanImplicitFileset = getSrcDir ( ) != null || filesets . size ( ) == 0 ; if ( scanImplicitFileset ) { if ( getSrcDir ( ) == null ) { setSrcDir ( getProject ( ) . resolveFile ( "." ) ) ; } log ( "working from source directory " + getSrcDir ( ) , Project . MSG_VERBOSE ) ; DirectoryScanner scanner = getDirectoryScanner ( getSrcDir ( ) ) ; filesOutOfDate = command . scanOneFileset ( scanner , filesToBuild , outputTimestamp ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; filesOutOfDate += command . scanOneFileset ( fs . getDirectoryScanner ( getProject ( ) ) , filesToBuild , outputTimestamp ) ; } return filesOutOfDate ; } protected void addFilesToCommand ( Hashtable filesToBuild , NetCommand command ) { int count = filesToBuild . size ( ) ; log ( "compiling " + count + " file" + ( ( count == 1 ) ? "" : "s" ) , Project . MSG_VERBOSE ) ; Enumeration files = filesToBuild . elements ( ) ; while ( files . hasMoreElements ( ) ) { File file = ( File ) files . nextElement ( ) ; command . addArgument ( file . toString ( ) ) ; } } protected long getOutputFileTimestamp ( ) { long outputTimestamp ; if ( getDestFile ( ) != null && getDestFile ( ) . exists ( ) ) { outputTimestamp = getDestFile ( ) . lastModified ( ) ; } else { outputTimestamp = 0 ; } return outputTimestamp ; } protected void addFilesAndExecute ( NetCommand command , boolean ignoreTimestamps ) { long outputTimestamp = getOutputFileTimestamp ( ) ; Hashtable filesToBuild = new Hashtable ( ) ; int filesOutOfDate = buildFileList ( command , filesToBuild , outputTimestamp ) ; if ( filesOutOfDate > 0 ) { addFilesToCommand ( filesToBuild , command ) ; command . runCommand ( ) ; } else { log ( "output file is up to date" , Project . MSG_VERBOSE ) ; } } } 	0	['11', '4', '2', '8', '38', '45', '2', '6', '6', '0.775', '202', '1', '0', '0.896551724', '0.285714286', '0', '0', '17', '6', '1.7273', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; public class PropertiesfileCache implements Cache { private File cachefile = null ; private Properties cache = new Properties ( ) ; private boolean cacheLoaded = false ; private boolean cacheDirty = true ; public PropertiesfileCache ( ) { } public PropertiesfileCache ( File cachefile ) { this . cachefile = cachefile ; } public void setCachefile ( File file ) { cachefile = file ; } public File getCachefile ( ) { return cachefile ; } public boolean isValid ( ) { return ( cachefile != null ) ; } public void load ( ) { if ( ( cachefile != null ) && cachefile . isFile ( ) && cachefile . canRead ( ) ) { try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( cachefile ) ) ; cache . load ( bis ) ; bis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheLoaded = true ; cacheDirty = false ; } public void save ( ) { if ( ! cacheDirty ) { return ; } if ( ( cachefile != null ) && cache . propertyNames ( ) . hasMoreElements ( ) ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( cachefile ) ) ; cache . store ( bos , null ) ; bos . flush ( ) ; bos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheDirty = false ; } public void delete ( ) { cache = new Properties ( ) ; cachefile . delete ( ) ; cacheLoaded = true ; cacheDirty = false ; } public Object get ( Object key ) { if ( ! cacheLoaded ) { load ( ) ; } try { return cache . getProperty ( String . valueOf ( key ) ) ; } catch ( ClassCastException e ) { return null ; } } public void put ( Object key , Object value ) { cache . put ( String . valueOf ( key ) , String . valueOf ( value ) ) ; cacheDirty = true ; } public Iterator iterator ( ) { Vector v = new java . util . Vector ( ) ; Enumeration en = cache . propertyNames ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( en . nextElement ( ) ) ; } return v . iterator ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<PropertiesfileCache:" ) ; buf . append ( "cachefile=" ) . append ( cachefile ) ; buf . append ( ";noOfEntries=" ) . append ( cache . size ( ) ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['12', '1', '0', '2', '42', '0', '1', '1', '12', '0.386363636', '234', '1', '0', '0', '0.444444444', '0', '0', '18.16666667', '4', '1.5833', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String name ; private String revision ; private String previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { this . name = name ; this . revision = revision ; if ( ! revision . equals ( previousRevision ) ) { this . previousRevision = previousRevision ; } } String getName ( ) { return name ; } String getRevision ( ) { return revision ; } String getPreviousRevision ( ) { return previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . io . FilterInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipEntry ; public class ZipResource extends ArchiveResource { private String encoding ; public ZipResource ( ) { } public ZipResource ( File z , String enc , ZipEntry e ) { super ( z , true ) ; setEncoding ( enc ) ; setEntry ( e ) ; } public void setZipfile ( File z ) { setArchive ( z ) ; } public File getZipfile ( ) { FileResource r = ( FileResource ) getArchive ( ) ; return r . getFile ( ) ; } public void addConfigured ( ResourceCollection a ) { super . addConfigured ( a ) ; if ( ! a . isFilesystemOnly ( ) ) { throw new BuildException ( "only filesystem resources are supported" ) ; } } public void setEncoding ( String enc ) { checkAttributesAllowed ( ) ; encoding = enc ; } public String getEncoding ( ) { return isReference ( ) ? ( ( ZipResource ) getCheckedRef ( ) ) . getEncoding ( ) : encoding ; } public void setRefid ( Reference r ) { if ( encoding != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } final ZipFile z = new ZipFile ( getZipfile ( ) , getEncoding ( ) ) ; ZipEntry ze = z . getEntry ( getName ( ) ) ; if ( ze == null ) { z . close ( ) ; throw new BuildException ( "no entry " + getName ( ) + " in " + getArchive ( ) ) ; } return new FilterInputStream ( z . getInputStream ( ze ) ) { public void close ( ) throws IOException { FileUtils . close ( in ) ; z . close ( ) ; } protected void finalize ( ) throws Throwable { try { close ( ) ; } finally { super . finalize ( ) ; } } } ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( "Use the zip task for zip output." ) ; } protected void fetchEntry ( ) { ZipFile z = null ; try { z = new ZipFile ( getZipfile ( ) , getEncoding ( ) ) ; setEntry ( z . getEntry ( getName ( ) ) ) ; } catch ( IOException e ) { log ( e . getMessage ( ) , Project . MSG_DEBUG ) ; throw new BuildException ( e ) ; } finally { if ( z != null ) { try { z . close ( ) ; } catch ( IOException e ) { } } } } private void setEntry ( ZipEntry e ) { if ( e == null ) { setExists ( false ) ; return ; } setName ( e . getName ( ) ) ; setExists ( true ) ; setLastModified ( e . getTime ( ) ) ; setDirectory ( e . isDirectory ( ) ) ; setSize ( e . getSize ( ) ) ; setMode ( e . getUnixMode ( ) ) ; } } 	0	['12', '5', '0', '10', '52', '60', '2', '9', '10', '0.545454545', '213', '1', '0', '0.873417722', '0.277777778', '3', '6', '16.66666667', '4', '1.4167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public interface ExecuteStreamHandler { void setProcessInputStream ( OutputStream os ) throws IOException ; void setProcessErrorStream ( InputStream is ) throws IOException ; void setProcessOutputStream ( InputStream is ) throws IOException ; void start ( ) throws IOException ; void stop ( ) ; } 	0	['5', '1', '0', '31', '5', '10', '31', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . io . IOException ; import java . io . FileOutputStream ; import java . io . PrintWriter ; import java . io . BufferedOutputStream ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class NetCommand { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected Task owner ; protected Execute executable ; protected Commandline commandLine ; protected String title ; protected String program ; protected boolean traceCommandLine = false ; protected boolean failOnError ; private File directory ; private boolean useResponseFile = false ; private File temporaryCommandFile ; private int automaticResponseFileThreshold = 64 ; public NetCommand ( Task owner , String title , String program ) { this . owner = owner ; this . title = title ; this . program = program ; commandLine = new Commandline ( ) ; commandLine . setExecutable ( program ) ; } public void setTraceCommandLine ( boolean b ) { traceCommandLine = b ; } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailFailOnError ( ) { return failOnError ; } public void setDirectory ( File directory ) { this . directory = directory ; } protected void logVerbose ( String msg ) { owner . getProject ( ) . log ( msg , Project . MSG_VERBOSE ) ; } protected void logError ( String msg ) { owner . getProject ( ) . log ( msg , Project . MSG_ERR ) ; } public void addArgument ( String argument ) { if ( argument != null && argument . length ( ) != 0 ) { commandLine . createArgument ( ) . setValue ( argument ) ; } } public void addArguments ( String [ ] arguments ) { if ( arguments != null && arguments . length != 0 ) { for ( int i = 0 ; i < arguments . length ; i ++ ) { addArgument ( arguments [ i ] ) ; } } } public void addArgument ( String argument1 , String argument2 ) { if ( argument2 != null && argument2 . length ( ) != 0 ) { commandLine . createArgument ( ) . setValue ( argument1 + argument2 ) ; } } public boolean isUseResponseFile ( ) { return useResponseFile ; } public void setUseResponseFile ( boolean useResponseFile ) { this . useResponseFile = useResponseFile ; } public int getAutomaticResponseFileThreshold ( ) { return automaticResponseFileThreshold ; } public void setAutomaticResponseFileThreshold ( int automaticResponseFileThreshold ) { this . automaticResponseFileThreshold = automaticResponseFileThreshold ; } protected void prepareExecutor ( ) { if ( owner == null ) { throw new RuntimeException ( "no owner" ) ; } if ( owner . getProject ( ) == null ) { throw new RuntimeException ( "Owner has no project" ) ; } File dir = owner . getProject ( ) . getBaseDir ( ) ; if ( directory != null ) { dir = directory ; } ExecuteStreamHandler handler = new LogStreamHandler ( owner , Project . MSG_INFO , Project . MSG_WARN ) ; executable = new Execute ( handler , null ) ; executable . setAntRun ( owner . getProject ( ) ) ; executable . setWorkingDirectory ( dir ) ; } public void runCommand ( ) throws BuildException { prepareExecutor ( ) ; int err = - 1 ; try { if ( traceCommandLine ) { owner . log ( "In directory " + executable . getWorkingDirectory ( ) ) ; owner . log ( commandLine . describeCommand ( ) ) ; } else { logVerbose ( "In directory " + executable . getWorkingDirectory ( ) ) ; logVerbose ( commandLine . describeCommand ( ) ) ; } setExecutableCommandLine ( ) ; err = executable . execute ( ) ; if ( Execute . isFailure ( err ) ) { if ( failOnError ) { throw new BuildException ( title + " returned: " + err , owner . getLocation ( ) ) ; } else { owner . log ( title + "  Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( title + " failed: " + e , e , owner . getLocation ( ) ) ; } finally { if ( temporaryCommandFile != null ) { temporaryCommandFile . delete ( ) ; } } } private void setExecutableCommandLine ( ) { String [ ] commands = commandLine . getCommandline ( ) ; if ( automaticResponseFileThreshold > 0 && commands . length > automaticResponseFileThreshold ) { useResponseFile = true ; } if ( ! useResponseFile || commands . length <= 1 ) { executable . setCommandline ( commands ) ; } else { FileOutputStream fos = null ; temporaryCommandFile = FILE_UTILS . createTempFile ( "cmd" , ".txt" , null ) ; owner . log ( "Using response file " + temporaryCommandFile , Project . MSG_VERBOSE ) ; try { fos = new FileOutputStream ( temporaryCommandFile ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( fos ) ) ; for ( int i = 1 ; i < commands . length ; ++ i ) { out . println ( commands [ i ] ) ; } out . flush ( ) ; out . close ( ) ; } catch ( IOException ex ) { throw new BuildException ( "saving command stream to " + temporaryCommandFile , ex ) ; } String [ ] newCommandLine = new String [ 2 ] ; newCommandLine [ 0 ] = commands [ 0 ] ; newCommandLine [ 1 ] = "@" + temporaryCommandFile . getAbsolutePath ( ) ; logVerbose ( Commandline . describeCommand ( newCommandLine ) ) ; executable . setCommandline ( newCommandLine ) ; } } public int scanOneFileset ( DirectoryScanner scanner , Hashtable filesToBuild , long outputTimestamp ) { int filesOutOfDate = 0 ; String [ ] dependencies = scanner . getIncludedFiles ( ) ; File base = scanner . getBasedir ( ) ; for ( int i = 0 ; i < dependencies . length ; i ++ ) { File targetFile = new File ( base , dependencies [ i ] ) ; if ( filesToBuild . get ( targetFile ) == null ) { filesToBuild . put ( targetFile , targetFile ) ; if ( targetFile . lastModified ( ) > outputTimestamp ) { filesOutOfDate ++ ; owner . log ( targetFile . toString ( ) + " is out of date" , Project . MSG_VERBOSE ) ; } else { owner . log ( targetFile . toString ( ) , Project . MSG_VERBOSE ) ; } } } return filesOutOfDate ; } } 	0	['19', '1', '0', '23', '69', '81', '11', '12', '14', '0.856481481', '517', '1', '4', '0', '0.183333333', '0', '0', '25.57894737', '6', '1.8421', '0']
package org . apache . tools . ant . listener ; import org . apache . tools . ant . DefaultLogger ; import java . util . Date ; import java . text . DateFormat ; public class TimestampedLogger extends DefaultLogger { private static final String SPACER = " - at " ; protected String getBuildFailedMessage ( ) { return super . getBuildFailedMessage ( ) + SPACER + getTimestamp ( ) ; } protected String getBuildSuccessfulMessage ( ) { return super . getBuildSuccessfulMessage ( ) + SPACER + getTimestamp ( ) ; } protected String getTimestamp ( ) { Date date = new Date ( System . currentTimeMillis ( ) ) ; DateFormat formatter = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT ) ; String finishTime = formatter . format ( date ) ; return finishTime ; } } 	0	['4', '2', '0', '1', '15', '6', '0', '1', '1', '1.333333333', '49', '1', '0', '0.842105263', '1', '1', '1', '11', '1', '0.75', '0']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Exists extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { boolean f = foo . isExists ( ) ; if ( f == bar . isExists ( ) ) { return 0 ; } return f ? 1 : - 1 ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '20', '0', '0', '0.971428571', '0.75', '1', '1', '9', '3', '1.5', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; public class ProxySetup { private Project owner ; public static final String USE_SYSTEM_PROXIES = "java.net.useSystemProxies" ; public static final String HTTP_PROXY_HOST = "http.proxyHost" ; public static final String HTTP_PROXY_PORT = "http.proxyPort" ; public static final String HTTPS_PROXY_HOST = "https.proxyHost" ; public static final String HTTPS_PROXY_PORT = "https.proxyPort" ; public static final String FTP_PROXY_HOST = "ftp.proxyHost" ; public static final String FTP_PROXY_PORT = "ftp.proxyPort" ; public static final String HTTP_NON_PROXY_HOSTS = "http.nonProxyHosts" ; public static final String HTTPS_NON_PROXY_HOSTS = "https.nonProxyHosts" ; public static final String FTP_NON_PROXY_HOSTS = "ftp.nonProxyHosts" ; public static final String HTTP_PROXY_USERNAME = "http.proxyUser" ; public static final String HTTP_PROXY_PASSWORD = "http.proxyPassword" ; public static final String SOCKS_PROXY_HOST = "socksProxyHost" ; public static final String SOCKS_PROXY_PORT = "socksProxyPort" ; public static final String SOCKS_PROXY_USERNAME = "java.net.socks.username" ; public static final String SOCKS_PROXY_PASSWORD = "java.net.socks.password" ; public ProxySetup ( Project owner ) { this . owner = owner ; } public static String getSystemProxySetting ( ) { try { return System . getProperty ( USE_SYSTEM_PROXIES ) ; } catch ( SecurityException e ) { return null ; } } public void enableProxies ( ) { if ( ! ( getSystemProxySetting ( ) != null ) ) { String proxies = owner . getProperty ( USE_SYSTEM_PROXIES ) ; if ( proxies == null || Project . toBoolean ( proxies ) ) { proxies = "true" ; } String message = "setting " + USE_SYSTEM_PROXIES + " to " + proxies ; try { owner . log ( message , Project . MSG_DEBUG ) ; System . setProperty ( USE_SYSTEM_PROXIES , proxies ) ; } catch ( SecurityException e ) { owner . log ( "Security Exception when " + message ) ; } } } } 	0	['3', '1', '0', '2', '13', '1', '1', '1', '3', '1.441176471', '76', '0.058823529', '1', '0', '0.5', '0', '0', '18.66666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class Continuus extends Task { private String ccmDir = "" ; private String ccmAction = "" ; public String getCcmAction ( ) { return ccmAction ; } public void setCcmAction ( String v ) { this . ccmAction = v ; } public final void setCcmDir ( String dir ) { ccmDir = FileUtils . translatePath ( dir ) ; } protected final String getCcmCommand ( ) { String toReturn = ccmDir ; if ( ! toReturn . equals ( "" ) && ! toReturn . endsWith ( "/" ) ) { toReturn += "/" ; } toReturn += CCM_EXE ; return toReturn ; } protected int run ( Commandline cmd , ExecuteStreamHandler handler ) { try { Execute exe = new Execute ( handler ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected int run ( Commandline cmd ) { return run ( cmd , new LogStreamHandler ( this , Project . MSG_VERBOSE , Project . MSG_WARN ) ) ; } private static final String CCM_EXE = "ccm" ; public static final String COMMAND_CREATE_TASK = "create_task" ; public static final String COMMAND_CHECKOUT = "co" ; public static final String COMMAND_CHECKIN = "ci" ; public static final String COMMAND_RECONFIGURE = "reconfigure" ; public static final String COMMAND_DEFAULT_TASK = "default_task" ; } 	0	['7', '3', '3', '12', '26', '9', '3', '9', '4', '1.041666667', '106', '0.375', '0', '0.860465116', '0.428571429', '0', '0', '13', '3', '1.1429', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; public interface Retryable { int RETRY_FOREVER = - 1 ; void execute ( ) throws IOException ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . Move ; import org . apache . tools . ant . types . Mapper ; public class RenameExtensions extends MatchingTask { private String fromExtension = "" ; private String toExtension = "" ; private boolean replace = false ; private File srcDir ; private Mapper . MapperType globType ; public RenameExtensions ( ) { super ( ) ; globType = new Mapper . MapperType ( ) ; globType . setValue ( "glob" ) ; } public void setFromExtension ( String from ) { fromExtension = from ; } public void setToExtension ( String to ) { toExtension = to ; } public void setReplace ( boolean replace ) { this . replace = replace ; } public void setSrcDir ( File srcDir ) { this . srcDir = srcDir ; } public void execute ( ) throws BuildException { if ( fromExtension == null || toExtension == null || srcDir == null ) { throw new BuildException ( "srcDir, fromExtension and toExtension " + "attributes must be set!" ) ; } log ( "DEPRECATED - The renameext task is deprecated.  Use move instead." , Project . MSG_WARN ) ; log ( "Replace this with:" , Project . MSG_INFO ) ; log ( "<move todir=\"" + srcDir + "\" overwrite=\"" + replace + "\">" , Project . MSG_INFO ) ; log ( "  <fileset dir=\"" + srcDir + "\" />" , Project . MSG_INFO ) ; log ( "  <mapper type=\"glob\"" , Project . MSG_INFO ) ; log ( "          from=\"*" + fromExtension + "\"" , Project . MSG_INFO ) ; log ( "          to=\"*" + toExtension + "\" />" , Project . MSG_INFO ) ; log ( "</move>" , Project . MSG_INFO ) ; log ( "using the same patterns on <fileset> as you\'ve used here" , Project . MSG_INFO ) ; Move move = new Move ( ) ; move . bindToOwner ( this ) ; move . setOwningTarget ( getOwningTarget ( ) ) ; move . setTaskName ( getTaskName ( ) ) ; move . setLocation ( getLocation ( ) ) ; move . setTodir ( srcDir ) ; move . setOverwrite ( replace ) ; fileset . setDir ( srcDir ) ; move . addFileset ( fileset ) ; Mapper me = move . createMapper ( ) ; me . setType ( globType ) ; me . setFrom ( "*" + fromExtension ) ; me . setTo ( "*" + toExtension ) ; move . execute ( ) ; } } 	0	['6', '4', '0', '9', '33', '0', '0', '9', '6', '0.68', '205', '1', '1', '0.939759036', '0.416666667', '2', '4', '32.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '17', '15', '13', '15', '3', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . util ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; public class CompositeMapper extends ContainerMapper { public String [ ] mapFileName ( String sourceFileName ) { HashSet results = new HashSet ( ) ; FileNameMapper mapper = null ; for ( Iterator mIter = getMappers ( ) . iterator ( ) ; mIter . hasNext ( ) ; ) { mapper = ( FileNameMapper ) ( mIter . next ( ) ) ; if ( mapper != null ) { String [ ] mapped = mapper . mapFileName ( sourceFileName ) ; if ( mapped != null ) { results . addAll ( Arrays . asList ( mapped ) ) ; } } } return ( results . size ( ) == 0 ) ? null : ( String [ ] ) results . toArray ( new String [ results . size ( ) ] ) ; } } 	0	['2', '2', '0', '3', '13', '1', '1', '2', '2', '2', '48', '0', '0', '0.875', '0.75', '0', '0', '23', '5', '2.5', '0']
package org . apache . tools . ant . util ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Project ; import java . util . Map ; import java . util . HashMap ; import java . util . Iterator ; public abstract class ScriptRunnerBase { private boolean keepEngine = false ; private String language ; private String script = "" ; private Project project ; private ClassLoader scriptLoader ; private Map beans = new HashMap ( ) ; public void addBeans ( Map dictionary ) { for ( Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; try { Object val = dictionary . get ( key ) ; addBean ( key , val ) ; } catch ( BuildException ex ) { } } } public void addBean ( String key , Object bean ) { boolean isValid = key . length ( ) > 0 && Character . isJavaIdentifierStart ( key . charAt ( 0 ) ) ; for ( int i = 1 ; isValid && i < key . length ( ) ; i ++ ) { isValid = Character . isJavaIdentifierPart ( key . charAt ( i ) ) ; } if ( isValid ) { beans . put ( key , bean ) ; } } protected Map getBeans ( ) { return beans ; } public abstract void executeScript ( String execName ) ; public abstract Object evaluateScript ( String execName ) ; public abstract boolean supportsLanguage ( ) ; public abstract String getManagerName ( ) ; public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setScriptClassLoader ( ClassLoader classLoader ) { this . scriptLoader = classLoader ; } protected ClassLoader getScriptClassLoader ( ) { return scriptLoader ; } public void setKeepEngine ( boolean keepEngine ) { this . keepEngine = keepEngine ; } public boolean getKeepEngine ( ) { return keepEngine ; } public void setSrc ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "file " + file . getPath ( ) + " not found." ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; script += FileUtils . readFully ( in ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { FileUtils . close ( in ) ; } } public void addText ( String text ) { this . script += text ; } public String getScript ( ) { return script ; } public void clearScript ( ) { this . script = "" ; } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void bindToComponent ( ProjectComponent component ) { project = component . getProject ( ) ; addBeans ( project . getProperties ( ) ) ; addBeans ( project . getUserProperties ( ) ) ; addBeans ( project . getTargets ( ) ) ; addBeans ( project . getReferences ( ) ) ; addBean ( "project" , project ) ; addBean ( "self" , component ) ; } public void bindToComponentMinimum ( ProjectComponent component ) { project = component . getProject ( ) ; addBean ( "project" , project ) ; addBean ( "self" , component ) ; } protected void checkLanguage ( ) { if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } } protected ClassLoader replaceContextLoader ( ) { ClassLoader origContextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( getScriptClassLoader ( ) == null ) { setScriptClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } Thread . currentThread ( ) . setContextClassLoader ( getScriptClassLoader ( ) ) ; return origContextClassLoader ; } protected void restoreContextLoader ( ClassLoader origLoader ) { Thread . currentThread ( ) . setContextClassLoader ( origLoader ) ; } } 	0	['25', '1', '1', '13', '59', '248', '9', '4', '20', '0.875', '290', '1', '1', '0', '0.173333333', '0', '0', '10.36', '6', '1.4', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; class RedirectingStreamHandler extends PumpStreamHandler { RedirectingStreamHandler ( final ChangeLogParser parser ) { super ( new RedirectingOutputStream ( parser ) , new ByteArrayOutputStream ( ) ) ; } String getErrors ( ) { try { final ByteArrayOutputStream error = ( ByteArrayOutputStream ) getErr ( ) ; return error . toString ( "ASCII" ) ; } catch ( final Exception e ) { return null ; } } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( final IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '1', '2', '40', '0', '0', '0.857142857', '0.666666667', '0', '0', '12.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '30', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.666666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . util . ArrayList ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Reference ; public class ExtensionSet extends DataType { private final ArrayList extensions = new ArrayList ( ) ; private final ArrayList extensionsFilesets = new ArrayList ( ) ; public void addExtension ( final ExtensionAdapter extensionAdapter ) { extensions . add ( extensionAdapter ) ; } public void addLibfileset ( final LibFileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public void addFileset ( final FileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public Extension [ ] toExtensions ( final Project proj ) throws BuildException { final ArrayList extensionsList = ExtensionUtil . toExtensions ( extensions ) ; ExtensionUtil . extractExtensions ( proj , extensionsList , extensionsFilesets ) ; return ( Extension [ ] ) extensionsList . toArray ( new Extension [ extensionsList . size ( ) ] ) ; } public void setRefid ( final Reference reference ) throws BuildException { if ( ! extensions . isEmpty ( ) || ! extensionsFilesets . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } final Object object = reference . getReferencedObject ( getProject ( ) ) ; if ( object instanceof ExtensionSet ) { final ExtensionSet other = ( ExtensionSet ) object ; extensions . addAll ( other . extensions ) ; extensionsFilesets . addAll ( other . extensionsFilesets ) ; } else { final String message = reference . getRefId ( ) + " doesn\'t refer to a ExtensionSet" ; throw new BuildException ( message ) ; } super . setRefid ( reference ) ; } public String toString ( ) { return "ExtensionSet" + Arrays . asList ( toExtensions ( getProject ( ) ) ) ; } } 	0	['7', '3', '0', '11', '28', '0', '2', '9', '7', '0.25', '122', '1', '0', '0.833333333', '0.285714286', '1', '1', '16.14285714', '1', '0.8571', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Or extends ResourceSelectorContainer implements ResourceSelector { public Or ( ) { } public Or ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { return true ; } } return false ; } } 	0	['3', '4', '0', '4', '9', '3', '1', '3', '3', '2', '27', '0', '0', '0.972222222', '0.555555556', '0', '0', '8', '3', '1', '0']
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '2064', '0', '0', '0', '0', '0', '0', '2052', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSADD extends MSVSS { private String localPath = null ; protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getLocalpath ( ) == null ) { String msg = "localPath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_ADD ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; return commandLine ; } protected String getLocalpath ( ) { return localPath ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setLocalpath ( Path localPath ) { this . localPath = localPath . toString ( ) ; } } 	0	['8', '4', '0', '6', '26', '22', '0', '6', '6', '0.571428571', '95', '1', '0', '0.928571429', '0.40625', '1', '1', '10.75', '2', '1', '0']
package org . apache . tools . ant . types ; import java . security . UnresolvedPermission ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; public class Permissions { private List grantedPermissions = new LinkedList ( ) ; private List revokedPermissions = new LinkedList ( ) ; private java . security . Permissions granted = null ; private SecurityManager origSm = null ; private boolean active = false ; private boolean delegateToOldSM ; public Permissions ( ) { this ( false ) ; } public Permissions ( boolean delegateToOldSM ) { this . delegateToOldSM = delegateToOldSM ; } public void addConfiguredGrant ( Permissions . Permission perm ) { grantedPermissions . add ( perm ) ; } public void addConfiguredRevoke ( Permissions . Permission perm ) { revokedPermissions . add ( perm ) ; } public synchronized void setSecurityManager ( ) throws BuildException { origSm = System . getSecurityManager ( ) ; init ( ) ; System . setSecurityManager ( new MySM ( ) ) ; active = true ; } private void init ( ) throws BuildException { granted = new java . security . Permissions ( ) ; for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Revoked permission " + p + " does not contain a class." ) ; } } for ( Iterator i = grantedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Granted permission " + p + " does not contain a class." ) ; } else { java . security . Permission perm = new UnresolvedPermission ( p . getClassName ( ) , p . getName ( ) , p . getActions ( ) , null ) ; granted . add ( perm ) ; } } granted . add ( new java . net . SocketPermission ( "localhost:1024-" , "listen" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor.url" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.class.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.arch" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.encoding" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "path.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "line.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.name" , "read" ) ) ; } public synchronized void restoreSecurityManager ( ) { active = false ; System . setSecurityManager ( origSm ) ; } private class MySM extends SecurityManager { public void checkExit ( int status ) { java . security . Permission perm = new java . lang . RuntimePermission ( "exitVM" , null ) ; try { checkPermission ( perm ) ; } catch ( SecurityException e ) { throw new ExitException ( e . getMessage ( ) , status ) ; } } public void checkPermission ( java . security . Permission perm ) { if ( active ) { if ( delegateToOldSM && ! perm . getName ( ) . equals ( "exitVM" ) ) { boolean permOK = false ; if ( granted . implies ( perm ) ) { permOK = true ; } checkRevoked ( perm ) ; if ( ! permOK && origSm != null ) { origSm . checkPermission ( perm ) ; } } else { if ( ! granted . implies ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was not granted." ) ; } checkRevoked ( perm ) ; } } } private void checkRevoked ( java . security . Permission perm ) { for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { if ( ( ( Permissions . Permission ) i . next ( ) ) . matches ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was revoked." ) ; } } } } public static class Permission { private String className ; private String name ; private String actionString ; private Set actions ; public void setClass ( String aClass ) { className = aClass . trim ( ) ; } public String getClassName ( ) { return className ; } public void setName ( String aName ) { name = aName . trim ( ) ; } public String getName ( ) { return name ; } public void setActions ( String actions ) { actionString = actions ; if ( actions . length ( ) > 0 ) { this . actions = parseActions ( actions ) ; } } public String getActions ( ) { return actionString ; } boolean matches ( java . security . Permission perm ) { if ( ! className . equals ( perm . getClass ( ) . getName ( ) ) ) { return false ; } if ( name != null ) { if ( name . endsWith ( "*" ) ) { if ( ! perm . getName ( ) . startsWith ( name . substring ( 0 , name . length ( ) - 1 ) ) ) { return false ; } } else { if ( ! name . equals ( perm . getName ( ) ) ) { return false ; } } } if ( actions != null ) { Set as = parseActions ( perm . getActions ( ) ) ; int size = as . size ( ) ; as . removeAll ( actions ) ; if ( as . size ( ) == size ) { return false ; } } return true ; } private Set parseActions ( String actions ) { Set result = new HashSet ( ) ; StringTokenizer tk = new StringTokenizer ( actions , "," ) ; while ( tk . hasMoreTokens ( ) ) { String item = tk . nextToken ( ) . trim ( ) ; if ( ! item . equals ( "" ) ) { result . add ( item ) ; } } return result ; } public String toString ( ) { return ( "Permission: " + className + " (\"" + name + "\", \"" + actions + "\")" ) ; } } } 	0	['12', '1', '0', '8', '34', '26', '6', '3', '6', '0.651515152', '341', '1', '0', '0', '0.3125', '0', '0', '26.91666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . ReflectWrapper ; import org . apache . tools . ant . util . StringUtils ; public class HasFreeSpace implements Condition { private String partition ; private String needed ; public boolean eval ( ) throws BuildException { validate ( ) ; try { if ( JavaEnvUtils . isAtLeastJavaVersion ( "1.6" ) ) { File fs = new File ( partition ) ; ReflectWrapper w = new ReflectWrapper ( fs ) ; long free = ( ( Long ) w . invoke ( "getFreeSpace" ) ) . longValue ( ) ; return free >= StringUtils . parseHumanSizes ( needed ) ; } else { throw new BuildException ( "HasFreeSpace condition not supported on Java5 or less." ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } private void validate ( ) throws BuildException { if ( null == partition ) { throw new BuildException ( "Please set the partition attribute." ) ; } if ( null == needed ) { throw new BuildException ( "Please set the needed attribute." ) ; } } public String getPartition ( ) { return partition ; } public void setPartition ( String partition ) { this . partition = partition ; } public String getNeeded ( ) { return needed ; } public void setNeeded ( String needed ) { this . needed = needed ; } } 	0	['7', '1', '0', '5', '16', '0', '0', '5', '6', '0.5', '86', '1', '0', '0', '0.642857143', '0', '0', '11', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0	['2', '3', '0', '3', '15', '1', '0', '3', '0', '2', '58', '0', '0', '0.952380952', '0.666666667', '1', '1', '28', '1', '0.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public interface ResourceSelector { boolean isSelected ( Resource r ) ; } 	0	['1', '1', '0', '26', '1', '0', '25', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Constructor ; public class AntTypeDefinition { private String name ; private Class clazz ; private Class adapterClass ; private Class adaptToClass ; private String className ; private ClassLoader classLoader ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setClass ( Class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . classLoader = ( classLoader == null ) ? clazz . getClassLoader ( ) : classLoader ; this . className = ( className == null ) ? clazz . getName ( ) : className ; } public void setClassName ( String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public Class getExposedClass ( Project project ) { if ( adaptToClass != null ) { Class z = getTypeClass ( project ) ; if ( z == null || adaptToClass . isAssignableFrom ( z ) ) { return z ; } } return ( adapterClass == null ) ? getTypeClass ( project ) : adapterClass ; } public Class getTypeClass ( Project project ) { try { return innerGetTypeClass ( ) ; } catch ( NoClassDefFoundError ncdfe ) { project . log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for type " + name , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { project . log ( "Could not load class (" + className + ") for type " + name , Project . MSG_DEBUG ) ; } return null ; } public Class innerGetTypeClass ( ) throws ClassNotFoundException { if ( clazz != null ) { return clazz ; } if ( classLoader == null ) { clazz = Class . forName ( className ) ; } else { clazz = classLoader . loadClass ( className ) ; } return clazz ; } public Object create ( Project project ) { return icreate ( project ) ; } private Object icreate ( Project project ) { Class c = getTypeClass ( project ) ; if ( c == null ) { return null ; } Object o = createAndSet ( project , c ) ; if ( o == null || adapterClass == null ) { return o ; } if ( adaptToClass != null ) { if ( adaptToClass . isAssignableFrom ( o . getClass ( ) ) ) { return o ; } } TypeAdapter adapterObject = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapterObject == null ) { return null ; } adapterObject . setProxy ( o ) ; return adapterObject ; } public void checkClass ( Project project ) { if ( clazz == null ) { clazz = getTypeClass ( project ) ; if ( clazz == null ) { throw new BuildException ( "Unable to create class for " + getName ( ) ) ; } } if ( adapterClass != null && ( adaptToClass == null || ! adaptToClass . isAssignableFrom ( clazz ) ) ) { TypeAdapter adapter = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapter == null ) { throw new BuildException ( "Unable to create adapter object" ) ; } adapter . checkProxyClass ( clazz ) ; } } private Object createAndSet ( Project project , Class c ) { try { Object o = innerCreateAndSet ( c , project ) ; return o ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "Type " + name + ": A class needed by class " + c + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe ) ; } catch ( NoSuchMethodException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " has no compatible constructor" ) ; } catch ( InstantiationException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " is abstract" ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not create type " + name + " as the constructor " + c + " is not accessible" ) ; } catch ( Throwable t ) { throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } } public Object innerCreateAndSet ( Class newclass , Project project ) throws NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { Constructor ctor = null ; boolean noArg = false ; try { ctor = newclass . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = newclass . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = ctor . newInstance ( ( ( noArg ) ? new Object [ 0 ] : new Object [ ] { project } ) ) ; project . setProjectReference ( o ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) == getClass ( ) && other . getTypeClass ( project ) . equals ( getTypeClass ( project ) ) && other . getExposedClass ( project ) . equals ( getExposedClass ( project ) ) && other . adapterClass == adapterClass && other . adaptToClass == adaptToClass ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null || getClass ( ) != other . getClass ( ) || ! getClassName ( ) . equals ( other . getClassName ( ) ) || ! extractClassname ( adapterClass ) . equals ( extractClassname ( other . adapterClass ) ) || ! extractClassname ( adaptToClass ) . equals ( extractClassname ( other . adaptToClass ) ) ) { return false ; } ClassLoader oldLoader = other . getClassLoader ( ) ; ClassLoader newLoader = getClassLoader ( ) ; return oldLoader == newLoader || ( oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) ; } private String extractClassname ( Class c ) { return ( c == null ) ? "<null>" : c . getClass ( ) . getName ( ) ; } } 	0	['21', '1', '2', '14', '47', '124', '10', '4', '18', '0.7', '575', '0.857142857', '0', '0', '0.325396825', '0', '0', '26.04761905', '10', '2.619', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0	['5', '3', '3', '6', '12', '2', '4', '2', '5', '0.625', '48', '1', '0', '0.902439024', '0.466666667', '0', '0', '8.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool implements HotDeploymentTool { private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy" ; private static final String [ ] VALID_ACTIONS = { ACTION_DELETE , ACTION_DEPLOY , ACTION_LIST , ACTION_UNDEPLOY , ACTION_UPDATE } ; private boolean debug ; private String application ; private String component ; public void deploy ( ) { Java java = new Java ( getTask ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . setClasspath ( getClasspath ( ) ) ; java . setClassname ( WEBLOGIC_DEPLOY_CLASS_NAME ) ; java . createArg ( ) . setLine ( getArguments ( ) ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; String action = getTask ( ) . getAction ( ) ; if ( ( getPassword ( ) == null ) ) { throw new BuildException ( "The password attribute must be set." ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && application == null ) { throw new BuildException ( "The application attribute must be set " + "if action = " + action ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && getTask ( ) . getSource ( ) == null ) { throw new BuildException ( "The source attribute must be set if " + "action = " + action ) ; } if ( ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) && application == null ) { throw new BuildException ( "The application attribute must be set if " + "action = " + action ) ; } } public String getArguments ( ) throws BuildException { String action = getTask ( ) . getAction ( ) ; String args = null ; if ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) { args = buildDeployArgs ( ) ; } else if ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) { args = buildUndeployArgs ( ) ; } else if ( action . equals ( ACTION_LIST ) ) { args = buildListArgs ( ) ; } return args ; } protected boolean isActionValid ( ) { boolean valid = false ; String action = getTask ( ) . getAction ( ) ; for ( int i = 0 ; i < VALID_ACTIONS . length ; i ++ ) { if ( action . equals ( VALID_ACTIONS [ i ] ) ) { valid = true ; break ; } } return valid ; } protected StringBuffer buildArgsPrefix ( ) { ServerDeploy task = getTask ( ) ; return new StringBuffer ( 1024 ) . append ( ( getServer ( ) != null ) ? "-url " + getServer ( ) : "" ) . append ( " " ) . append ( debug ? "-debug " : "" ) . append ( ( getUserName ( ) != null ) ? "-username " + getUserName ( ) : "" ) . append ( " " ) . append ( task . getAction ( ) ) . append ( " " ) . append ( getPassword ( ) ) . append ( " " ) ; } protected String buildDeployArgs ( ) { String args = buildArgsPrefix ( ) . append ( application ) . append ( " " ) . append ( getTask ( ) . getSource ( ) ) . toString ( ) ; if ( component != null ) { args = "-component " + component + " " + args ; } return args ; } protected String buildUndeployArgs ( ) { return buildArgsPrefix ( ) . append ( application ) . append ( " " ) . toString ( ) ; } protected String buildListArgs ( ) { return buildArgsPrefix ( ) . toString ( ) ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setApplication ( String application ) { this . application = application ; } public void setComponent ( String component ) { this . component = component ; } } 	0	['13', '2', '0', '8', '37', '60', '1', '8', '7', '0.833333333', '331', '1', '0', '0.56', '0.416666667', '2', '3', '24.07692308', '4', '1.3077', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSLABEL extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { throw new BuildException ( "vsspath attribute must be set!" , getLocation ( ) ) ; } String label = getLabel ( ) ; if ( label . equals ( "" ) ) { String msg = "label attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LABEL ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( label ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['6', '4', '0', '5', '25', '15', '0', '5', '5', '2', '94', '0', '0', '0.947916667', '0.833333333', '1', '1', '14.66666667', '3', '1.1667', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Change extends P4Base { protected String emptyChangeList = null ; protected String description = "AutoSubmit By Ant" ; public void execute ( ) throws BuildException { if ( emptyChangeList == null ) { emptyChangeList = getEmptyChangeList ( ) ; } final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { if ( util . match ( "/Change/" , line ) ) { line = util . substitute ( "s/[^0-9]//g" , line ) ; int changenumber = Integer . parseInt ( line ) ; log ( "Change Number is " + changenumber , Project . MSG_INFO ) ; myProj . setProperty ( "p4.change" , "" + changenumber ) ; } else if ( util . match ( "/error/" , line ) ) { throw new BuildException ( "Perforce Error, check client settings and/or server" ) ; } } } ; handler . setOutput ( emptyChangeList ) ; execP4Command ( "change -i" , handler ) ; } public String getEmptyChangeList ( ) throws BuildException { final StringBuffer stringbuf = new StringBuffer ( ) ; execP4Command ( "change -o" , new P4HandlerAdapter ( ) { public void process ( String line ) { if ( ! util . match ( "/^#/" , line ) ) { if ( util . match ( "/error/" , line ) ) { log ( "Client Error" , Project . MSG_VERBOSE ) ; throw new BuildException ( "Perforce Error, " + "check client settings and/or server" ) ; } else if ( util . match ( "/<enter description here>/" , line ) ) { description = backslash ( description ) ; line = util . substitute ( "s/<enter description here>/" + description + "/" , line ) ; } else if ( util . match ( "/\\/\\//" , line ) ) { return ; } stringbuf . append ( line ) ; stringbuf . append ( "\n" ) ; } } } ) ; return stringbuf . toString ( ) ; } public static final String backslash ( String value ) { final StringBuffer buf = new StringBuffer ( value . length ( ) ) ; final int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == '/' ) { buf . append ( '\\' ) ; } buf . append ( c ) ; } return buf . toString ( ) ; } public void setDescription ( String desc ) { this . description = desc ; } } 	0	['5', '4', '0', '6', '17', '6', '2', '6', '5', '0.75', '94', '1', '0', '0.927272727', '0.6', '2', '2', '17.4', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class SunJavah implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "sun" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupJavahCommand ( javah ) ; ExecuteJava ej = new ExecuteJava ( ) ; Class c = null ; try { try { c = Class . forName ( "com.sun.tools.javah.oldjavah.Main" ) ; } catch ( ClassNotFoundException cnfe ) { c = Class . forName ( "com.sun.tools.javah.Main" ) ; } } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Can't load javah" , ex , javah . getLocation ( ) ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; File f = Locator . getClassSource ( c ) ; if ( f != null ) { ej . setClasspath ( new Path ( javah . getProject ( ) , f . getPath ( ) ) ) ; } return ej . fork ( javah ) == 0 ; } private Commandline setupJavahCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } if ( javah . getClasspath ( ) != null ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( javah . getClasspath ( ) ) ; } if ( javah . getVerbose ( ) ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-old" ) ; } if ( javah . getForce ( ) ) { cmd . createArgument ( ) . setValue ( "-force" ) ; } if ( javah . getStubs ( ) && ! javah . getOld ( ) ) { throw new BuildException ( "stubs only available in old mode." , javah . getLocation ( ) ) ; } if ( javah . getStubs ( ) ) { cmd . createArgument ( ) . setValue ( "-stubs" ) ; } Path bcp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { bcp . append ( javah . getBootclasspath ( ) ) ; } bcp = bcp . concatSystemBootClasspath ( "ignore" ) ; if ( bcp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bcp ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0	['3', '1', '0', '12', '38', '3', '1', '11', '2', '1.5', '182', '0', '0', '0', '0.833333333', '0', '0', '59.33333333', '12', '4.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . util . Enumeration ; import java . util . LinkedList ; import java . util . List ; import java . util . ListIterator ; import java . util . Properties ; import java . util . Vector ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private Path bootclasspath = null ; private String vmVersion ; private String maxMemory = null ; private Assertions assertions = null ; private boolean executeJar = false ; private boolean cloneVm = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; private Vector propertySets = new Vector ( ) ; public String [ ] getVariables ( ) throws BuildException { List definitions = new LinkedList ( ) ; ListIterator list = definitions . listIterator ( ) ; addDefinitionsToList ( list ) ; if ( definitions . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) definitions . toArray ( new String [ definitions . size ( ) ] ) ; } } public void addDefinitionsToList ( ListIterator listIt ) { String [ ] props = super . getVariables ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { listIt . add ( "-D" + props [ i ] ) ; } } Properties propertySetProperties = mergePropertySets ( ) ; for ( Enumeration e = propertySetProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = propertySetProperties . getProperty ( key ) ; listIt . add ( "-D" + key + "=" + value ) ; } } public int size ( ) { Properties p = mergePropertySets ( ) ; return variables . size ( ) + p . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; p . put ( name , sys . getProperty ( name ) ) ; } p . putAll ( mergePropertySets ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; v . validate ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) throws CloneNotSupportedException { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; c . propertySets = ( Vector ) propertySets . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } public void addSyspropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addSysproperties ( SysProperties ps ) { variables . addAll ( ps . variables ) ; propertySets . addAll ( ps . propertySets ) ; } private Properties mergePropertySets ( ) { Properties p = new Properties ( ) ; for ( Enumeration e = propertySets . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; p . putAll ( ps . getProperties ( ) ) ; } return p ; } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { sysProperties . addSyspropertyset ( sysp ) ; } public void addSysproperties ( SysProperties sysp ) { sysProperties . addSysproperties ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setCloneVm ( boolean cloneVm ) { this . cloneVm = cloneVm ; } public Assertions getAssertions ( ) { return assertions ; } public void setAssertions ( Assertions assertions ) { this . assertions = assertions ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public Path createBootclasspath ( Project p ) { if ( bootclasspath == null ) { bootclasspath = new Path ( p ) ; } return bootclasspath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; final ListIterator listIterator = commands . listIterator ( ) ; addCommandsToList ( listIterator ) ; return ( String [ ] ) commands . toArray ( new String [ commands . size ( ) ] ) ; } private void addCommandsToList ( final ListIterator listIterator ) { getActualVMCommand ( ) . addCommandToList ( listIterator ) ; sysProperties . addDefinitionsToList ( listIterator ) ; if ( isCloneVm ( ) ) { SysProperties clonedSysProperties = new SysProperties ( ) ; PropertySet ps = new PropertySet ( ) ; PropertySet . BuiltinPropertySetName sys = new PropertySet . BuiltinPropertySetName ( ) ; sys . setValue ( "system" ) ; ps . appendBuiltin ( sys ) ; clonedSysProperties . addSyspropertyset ( ps ) ; clonedSysProperties . addDefinitionsToList ( listIterator ) ; } Path bcp = calculateBootclasspath ( true ) ; if ( bcp . size ( ) > 0 ) { listIterator . add ( "-Xbootclasspath:" + bcp . toString ( ) ) ; } if ( haveClasspath ( ) ) { listIterator . add ( "-classpath" ) ; listIterator . add ( classpath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ; } if ( getAssertions ( ) != null ) { getAssertions ( ) . applyAssertions ( listIterator ) ; } if ( executeJar ) { listIterator . add ( "-jar" ) ; } javaCommand . addCommandToList ( listIterator ) ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } protected Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( isCloneVm ( ) ) { size += System . getProperties ( ) . size ( ) ; } if ( haveClasspath ( ) ) { size += 2 ; } if ( calculateBootclasspath ( true ) . size ( ) > 0 ) { size ++ ; } if ( executeJar ) { size ++ ; } if ( getAssertions ( ) != null ) { size += getAssertions ( ) . size ( ) ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) throws CloneNotSupportedException { try { CommandlineJava c = ( CommandlineJava ) super . clone ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } if ( bootclasspath != null ) { c . bootclasspath = ( Path ) bootclasspath . clone ( ) ; } if ( assertions != null ) { c . assertions = ( Assertions ) assertions . clone ( ) ; } return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } protected boolean haveClasspath ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; return fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ; } protected boolean haveBootclasspath ( boolean log ) { return calculateBootclasspath ( log ) . size ( ) > 0 ; } private Path calculateBootclasspath ( boolean log ) { if ( vmVersion . startsWith ( "1.1" ) ) { if ( bootclasspath != null && log ) { bootclasspath . log ( "Ignoring bootclasspath as " + "the target VM doesn't support it." ) ; } } else { if ( bootclasspath != null ) { return bootclasspath . concatSystemBootClasspath ( isCloneVm ( ) ? "last" : "ignore" ) ; } else if ( isCloneVm ( ) ) { return Path . systemBootClasspath ; } } return new Path ( null ) ; } private boolean isCloneVm ( ) { return cloneVm || "true" . equals ( System . getProperty ( "ant.build.clonevm" ) ) ; } } 	0	['39', '1', '0', '21', '94', '461', '11', '11', '33', '0.786842105', '559', '1', '6', '0', '0.153846154', '0', '0', '13.07692308', '7', '1.6923', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( "ISO-8859-1" ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class [ ] params = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( NoClassDefFoundError ex ) { throw ex ; } catch ( RuntimeException ex ) { throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } throw new BuildException ( t ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } return ch ; } public Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '20', '0', '1', '3', '4', '0.777777778', '162', '0.666666667', '0', '0.928571429', '0.75', '2', '4', '38.75', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCLock extends ClearCase { private boolean mReplace = false ; private boolean mObsolete = false ; private String mComment = null ; private String mNusers = null ; private String mPname = null ; private String mObjselect = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getObsolete ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OBSOLETE ) ; } else { getNusersCommand ( cmd ) ; } getCommentCommand ( cmd ) ; if ( getObjselect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjselect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjselect ( ) ) ; } } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setObsolete ( boolean obsolete ) { mObsolete = obsolete ; } public boolean getObsolete ( ) { return mObsolete ; } public void setNusers ( String nusers ) { mNusers = nusers ; } public String getNusers ( ) { return mNusers ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjSel ( String objsel ) { mObjselect = objsel ; } public void setObjselect ( String objselect ) { mObjselect = objselect ; } public String getObjselect ( ) { return mObjselect ; } private void getNusersCommand ( Commandline cmd ) { if ( getNusers ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_NUSERS ) ; cmd . createArgument ( ) . setValue ( getNusers ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjselect ( ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_NUSERS = "-nusers" ; public static final String FLAG_OBSOLETE = "-obsolete" ; public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0	['20', '4', '0', '7', '42', '148', '0', '7', '15', '0.918660287', '263', '0.545454545', '0', '0.71641791', '0.3875', '2', '3', '11.6', '6', '1.4', '0']
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; private Project project ; public Reference ( ) { } public Reference ( String id ) { setRefId ( id ) ; } public Reference ( Project p , String id ) { setRefId ( id ) ; setProject ( p ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public Object getReferencedObject ( Project fallback ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project == null ? fallback . getReference ( refid ) : project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } public Object getReferencedObject ( ) throws BuildException { if ( project == null ) { throw new BuildException ( "No project set on reference to " + refid ) ; } return getReferencedObject ( project ) ; } } 	0	['9', '1', '1', '63', '15', '14', '61', '2', '9', '0.4375', '103', '1', '1', '0', '0.555555556', '0', '0', '10.22222222', '1', '0.6667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private static final String NEGATE_KEY = "negate" ; private Vector contains = new Vector ( ) ; private String line = null ; private boolean negate = false ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { final int containsSize = contains . size ( ) ; for ( line = readLine ( ) ; line != null ; line = readLine ( ) ) { boolean matches = true ; for ( int i = 0 ; matches && i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; matches = line . indexOf ( containsStr ) >= 0 ; } if ( matches ^ isNegated ( ) ) { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } public void setNegate ( boolean b ) { negate = b ; } public boolean isNegated ( ) { return negate ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private Vector getContains ( ) { return contains ; } public Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setNegate ( isNegated ( ) ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } else if ( NEGATE_KEY . equals ( params [ i ] . getType ( ) ) ) { setNegate ( Project . toBoolean ( params [ i ] . getValue ( ) ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0	['10', '5', '0', '6', '29', '0', '1', '5', '7', '0.688888889', '212', '1', '0', '0.777777778', '0.3', '2', '5', '19.7', '5', '1.2', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType t = new FileType ( ) ; t . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( t ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0	['6', '5', '0', '8', '21', '0', '5', '3', '6', '0.6', '104', '0.5', '0', '0.88372093', '0.333333333', '2', '5', '16', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '20', '21', '0', '2', '9', '0.6', '129', '1', '0', '0.804347826', '0.4', '1', '1', '11.4', '1', '0.9', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . util . Comparator ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; public abstract class ResourceComparator extends DataType implements Comparator { public final int compare ( Object foo , Object bar ) { dieOnCircularReference ( ) ; ResourceComparator c = isReference ( ) ? ( ResourceComparator ) getCheckedRef ( ) : this ; return c . resourceCompare ( ( Resource ) foo , ( Resource ) bar ) ; } public boolean equals ( Object o ) { if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( o ) ; } if ( o == null ) { return false ; } return o == this || o . getClass ( ) . equals ( getClass ( ) ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return getClass ( ) . hashCode ( ) ; } protected abstract int resourceCompare ( Resource foo , Resource bar ) ; } 	0	['5', '3', '9', '18', '12', '10', '16', '2', '4', '2', '62', '0', '0', '0.882352941', '0.533333333', '1', '1', '11.4', '5', '2', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Type extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { boolean f = foo . isDirectory ( ) ; if ( f == bar . isDirectory ( ) ) { return 0 ; } return f ? 1 : - 1 ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '20', '0', '0', '0.971428571', '0.75', '1', '1', '9', '3', '1.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private int getTablength ( ) { return tabLength ; } public Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0	['7', '5', '0', '4', '18', '0', '1', '3', '5', '0.708333333', '126', '1', '0', '0.848484848', '0.476190476', '2', '5', '16.42857143', '5', '1.2857', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } Path classpath = new Path ( project ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jikes" : exec ) ; if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; String source = attributes . getSource ( ) ; if ( source . equals ( "1.1" ) || source . equals ( "1.2" ) ) { attributes . log ( "Jikes doesn't support '-source " + source + "', will use '-source 1.3' instead" ) ; cmd . createArgument ( ) . setValue ( "1.3" ) ; } else { cmd . createArgument ( ) . setValue ( source ) ; } } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; Path boot = getBootClassPath ( ) ; if ( boot . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( boot ) ; } logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '8', '34', '1', '1', '7', '2', '2', '346', '0', '0', '0.958333333', '1', '1', '1', '172', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; public interface ResourceCollection { Iterator iterator ( ) ; int size ( ) ; boolean isFilesystemOnly ( ) ; } 	0	['3', '1', '0', '69', '3', '3', '69', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . util . Stack ; public class IdentityStack extends Stack { public static IdentityStack getInstance ( Stack s ) { if ( s instanceof IdentityStack ) { return ( IdentityStack ) s ; } IdentityStack result = new IdentityStack ( ) ; if ( s != null ) { result . addAll ( s ) ; } return result ; } public IdentityStack ( ) { } public IdentityStack ( Object o ) { super ( ) ; push ( o ) ; } public synchronized boolean contains ( Object o ) { return indexOf ( o ) >= 0 ; } public synchronized int indexOf ( Object o , int pos ) { for ( int i = pos ; i < size ( ) ; i ++ ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } public synchronized int lastIndexOf ( Object o , int pos ) { for ( int i = pos ; i >= 0 ; i -- ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } } 	0	['6', '5', '0', '1', '12', '15', '1', '0', '6', '2', '74', '0', '0', '0.954545455', '0.5', '2', '7', '11.33333333', '3', '1.8333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class WebsphereDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String SCHEMA_DIR = "Schema/" ; protected static final String WAS_EXT = "ibm-ejb-jar-ext.xmi" ; protected static final String WAS_BND = "ibm-ejb-jar-bnd.xmi" ; protected static final String WAS_CMP_MAP = "Map.mapxmi" ; protected static final String WAS_CMP_SCHEMA = "Schema.dbxmi" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String jarSuffix = ".jar" ; private String ejb11DTD ; private boolean keepGeneric = false ; private boolean alwaysRebuild = true ; private boolean ejbdeploy = true ; private boolean newCMP = false ; private Path wasClasspath = null ; private String dbVendor ; private String dbName ; private String dbSchema ; private boolean codegen ; private boolean quiet = true ; private boolean novalidate ; private boolean nowarn ; private boolean noinform ; private boolean trace ; private String rmicOptions ; private boolean use35MappingRules ; private String tempdir = "_ejbdeploy_temp" ; private File websphereHome ; public Path createWASClasspath ( ) { if ( wasClasspath == null ) { wasClasspath = new Path ( getTask ( ) . getProject ( ) ) ; } return wasClasspath . createPath ( ) ; } public void setWASClasspath ( Path wasClasspath ) { this . wasClasspath = wasClasspath ; } public void setDbvendor ( String dbvendor ) { this . dbVendor = dbvendor ; } public void setDbname ( String dbName ) { this . dbName = dbName ; } public void setDbschema ( String dbSchema ) { this . dbSchema = dbSchema ; } public void setCodegen ( boolean codegen ) { this . codegen = codegen ; } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; } public void setNovalidate ( boolean novalidate ) { this . novalidate = novalidate ; } public void setNowarn ( boolean nowarn ) { this . nowarn = nowarn ; } public void setNoinform ( boolean noinform ) { this . noinform = noinform ; } public void setTrace ( boolean trace ) { this . trace = trace ; } public void setRmicoptions ( String options ) { this . rmicOptions = options ; } public void setUse35 ( boolean attr ) { use35MappingRules = attr ; } public void setRebuild ( boolean rebuild ) { this . alwaysRebuild = rebuild ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setKeepgeneric ( boolean inValue ) { this . keepGeneric = inValue ; } public void setEjbdeploy ( boolean ejbdeploy ) { this . ejbdeploy = ejbdeploy ; } public void setEJBdtd ( String inString ) { this . ejb11DTD = inString ; } public void setOldCMP ( boolean oldCMP ) { this . newCMP = ! oldCMP ; } public void setNewCMP ( boolean newCMP ) { this . newCMP = newCMP ; } public void setTempdir ( String tempdir ) { this . tempdir = tempdir ; } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) ; handler . registerDTD ( PUBLICID_EJB11 , ejb11DTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected DescriptorHandler getWebsphereDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { } } ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String baseName ) { String ddPrefix = ( usingBaseJarName ( ) ? "" : baseName ) ; String dbPrefix = ( dbVendor == null ) ? "" : dbVendor + "-" ; File websphereEXT = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_EXT ) ; if ( websphereEXT . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_EXT , websphereEXT ) ; } else { log ( "Unable to locate websphere extensions. " + "It was expected to be in " + websphereEXT . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereBND = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_BND ) ; if ( websphereBND . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_BND , websphereBND ) ; } else { log ( "Unable to locate websphere bindings. " + "It was expected to be in " + websphereBND . getPath ( ) , Project . MSG_VERBOSE ) ; } if ( ! newCMP ) { log ( "The old method for locating CMP files has been DEPRECATED." , Project . MSG_VERBOSE ) ; log ( "Please adjust your websphere descriptor and set " + "newCMP=\"true\" to use the new CMP descriptor " + "inclusion mechanism. " , Project . MSG_VERBOSE ) ; } else { try { File websphereMAP = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_MAP ) ; if ( websphereMAP . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_CMP_MAP , websphereMAP ) ; } else { log ( "Unable to locate the websphere Map: " + websphereMAP . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereSchema = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_SCHEMA ) ; if ( websphereSchema . exists ( ) ) { ejbFiles . put ( META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA , websphereSchema ) ; } else { log ( "Unable to locate the websphere Schema: " + websphereSchema . getPath ( ) , Project . MSG_VERBOSE ) ; } } catch ( Exception e ) { String msg = "Exception while adding Vendor specific files: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } protected String getOptions ( ) { StringBuffer options = new StringBuffer ( ) ; if ( dbVendor != null ) { options . append ( " -dbvendor " ) . append ( dbVendor ) ; } if ( dbName != null ) { options . append ( " -dbname \"" ) . append ( dbName ) . append ( "\"" ) ; } if ( dbSchema != null ) { options . append ( " -dbschema \"" ) . append ( dbSchema ) . append ( "\"" ) ; } if ( codegen ) { options . append ( " -codegen" ) ; } if ( quiet ) { options . append ( " -quiet" ) ; } if ( novalidate ) { options . append ( " -novalidate" ) ; } if ( nowarn ) { options . append ( " -nowarn" ) ; } if ( noinform ) { options . append ( " -noinform" ) ; } if ( trace ) { options . append ( " -trace" ) ; } if ( use35MappingRules ) { options . append ( " -35" ) ; } if ( rmicOptions != null ) { options . append ( " -rmic \"" ) . append ( rmicOptions ) . append ( "\"" ) ; } return options . toString ( ) ; } private void buildWebsphereJar ( File sourceJar , File destJar ) { try { if ( ejbdeploy ) { Java javaTask = new Java ( getTask ( ) ) ; javaTask . createJvmarg ( ) . setValue ( "-Xms64m" ) ; javaTask . createJvmarg ( ) . setValue ( "-Xmx128m" ) ; Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "websphere.lib.dir" ) ; File libdir = new File ( websphereHome , "lib" ) ; var . setValue ( libdir . getAbsolutePath ( ) ) ; javaTask . addSysproperty ( var ) ; javaTask . setDir ( websphereHome ) ; javaTask . setTaskName ( "ejbdeploy" ) ; javaTask . setClassname ( "com.ibm.etools.ejbdeploy.EJBDeploy" ) ; javaTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; javaTask . createArg ( ) . setValue ( tempdir ) ; javaTask . createArg ( ) . setValue ( destJar . getPath ( ) ) ; javaTask . createArg ( ) . setLine ( getOptions ( ) ) ; if ( getCombinedClasspath ( ) != null && getCombinedClasspath ( ) . toString ( ) . length ( ) > 0 ) { javaTask . createArg ( ) . setValue ( "-cp" ) ; javaTask . createArg ( ) . setValue ( getCombinedClasspath ( ) . toString ( ) ) ; } Path classpath = wasClasspath ; if ( classpath == null ) { classpath = getCombinedClasspath ( ) ; } if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; javaTask . setFork ( true ) ; } else { javaTask . setFork ( true ) ; } log ( "Calling websphere.ejbdeploy for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; javaTask . execute ( ) ; } } catch ( Exception e ) { String msg = "Exception while calling ejbdeploy. Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { if ( ejbdeploy ) { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , files , publicId ) ; if ( alwaysRebuild || isRebuildRequired ( genericJarFile , jarFile ) ) { buildWebsphereJar ( genericJarFile , jarFile ) ; } if ( ! keepGeneric ) { log ( "deleting generic jar " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } else { super . writeJar ( baseName , jarFile , files , publicId ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; if ( ejbdeploy ) { String home = getTask ( ) . getProject ( ) . getProperty ( "websphere.home" ) ; if ( home == null ) { throw new BuildException ( "The 'websphere.home' property must " + "be set when 'ejbdeploy=true'" ) ; } websphereHome = getTask ( ) . getProject ( ) . resolveFile ( home ) ; } } protected boolean isRebuildRequired ( File genericJarFile , File websphereJarFile ) { boolean rebuild = false ; JarFile genericJar = null ; JarFile wasJar = null ; File newwasJarFile = null ; JarOutputStream newJarStream = null ; try { log ( "Checking if websphere Jar needs to be rebuilt for jar " + websphereJarFile . getName ( ) , Project . MSG_VERBOSE ) ; if ( genericJarFile . exists ( ) && genericJarFile . isFile ( ) && websphereJarFile . exists ( ) && websphereJarFile . isFile ( ) ) { genericJar = new JarFile ( genericJarFile ) ; wasJar = new JarFile ( websphereJarFile ) ; Hashtable genericEntries = new Hashtable ( ) ; Hashtable wasEntries = new Hashtable ( ) ; Hashtable replaceEntries = new Hashtable ( ) ; for ( Enumeration e = genericJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; genericEntries . put ( je . getName ( ) . replace ( '\\' , '/' ) , je ) ; } for ( Enumeration e = wasJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; wasEntries . put ( je . getName ( ) , je ) ; } ClassLoader genericLoader = getClassLoaderFromJar ( genericJarFile ) ; for ( Enumeration e = genericEntries . keys ( ) ; e . hasMoreElements ( ) ; ) { String filepath = ( String ) e . nextElement ( ) ; if ( wasEntries . containsKey ( filepath ) ) { JarEntry genericEntry = ( JarEntry ) genericEntries . get ( filepath ) ; JarEntry wasEntry = ( JarEntry ) wasEntries . get ( filepath ) ; if ( ( genericEntry . getCrc ( ) != wasEntry . getCrc ( ) ) || ( genericEntry . getSize ( ) != wasEntry . getSize ( ) ) ) { if ( genericEntry . getName ( ) . endsWith ( ".class" ) ) { String classname = genericEntry . getName ( ) . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; Class genclass = genericLoader . loadClass ( classname ) ; if ( genclass . isInterface ( ) ) { log ( "Interface " + genclass . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } else { replaceEntries . put ( filepath , genericEntry ) ; } } else { if ( ! genericEntry . getName ( ) . equals ( "META-INF/MANIFEST.MF" ) ) { log ( "Non class file " + genericEntry . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; } break ; } } } else { log ( "File " + filepath + " not present in websphere jar" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } } if ( ! rebuild ) { log ( "No rebuild needed - updating jar" , Project . MSG_VERBOSE ) ; newwasJarFile = new File ( websphereJarFile . getAbsolutePath ( ) + ".temp" ) ; if ( newwasJarFile . exists ( ) ) { newwasJarFile . delete ( ) ; } newJarStream = new JarOutputStream ( new FileOutputStream ( newwasJarFile ) ) ; newJarStream . setLevel ( 0 ) ; for ( Enumeration e = wasEntries . elements ( ) ; e . hasMoreElements ( ) ; ) { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; int bytesRead ; InputStream is ; JarEntry je = ( JarEntry ) e . nextElement ( ) ; if ( je . getCompressedSize ( ) == - 1 || je . getCompressedSize ( ) == je . getSize ( ) ) { newJarStream . setLevel ( 0 ) ; } else { newJarStream . setLevel ( JAR_COMPRESS_LEVEL ) ; } if ( replaceEntries . containsKey ( je . getName ( ) ) ) { log ( "Updating Bean class from generic Jar " + je . getName ( ) , Project . MSG_VERBOSE ) ; je = ( JarEntry ) replaceEntries . get ( je . getName ( ) ) ; is = genericJar . getInputStream ( je ) ; } else { is = wasJar . getInputStream ( je ) ; } newJarStream . putNextEntry ( new JarEntry ( je . getName ( ) ) ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { newJarStream . write ( buffer , 0 , bytesRead ) ; } is . close ( ) ; } } else { log ( "websphere Jar rebuild needed due to changed " + "interface or XML" , Project . MSG_VERBOSE ) ; } } else { rebuild = true ; } } catch ( ClassNotFoundException cnfe ) { String cnfmsg = "ClassNotFoundException while processing ejb-jar file" + ". Details: " + cnfe . getMessage ( ) ; throw new BuildException ( cnfmsg , cnfe ) ; } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file " + ". Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( genericJar != null ) { try { genericJar . close ( ) ; } catch ( IOException closeException ) { } } if ( wasJar != null ) { try { wasJar . close ( ) ; } catch ( IOException closeException ) { } } if ( newJarStream != null ) { try { newJarStream . close ( ) ; } catch ( IOException closeException ) { } try { FILE_UTILS . rename ( newwasJarFile , websphereJarFile ) ; } catch ( IOException renameException ) { log ( renameException . getMessage ( ) , Project . MSG_WARN ) ; rebuild = true ; } } } return rebuild ; } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } return getTask ( ) . getProject ( ) . createClassLoader ( lookupPath ) ; } } 	0	['33', '2', '0', '15', '130', '434', '2', '14', '23', '0.940848214', '1220', '0.928571429', '2', '0.507936508', '0.328125', '1', '5', '35.12121212', '26', '2.5152', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0	['5', '3', '0', '4', '15', '4', '0', '4', '5', '0.75', '90', '1', '0', '0.902439024', '0.533333333', '0', '0', '16.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Kaffeh implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "kaffeh" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupKaffehCommand ( javah ) ; try { Execute . runCommand ( javah , cmd . getCommandline ( ) ) ; return true ; } catch ( BuildException e ) { if ( e . getMessage ( ) . indexOf ( "failed with return code" ) == - 1 ) { throw e ; } } return false ; } private Commandline setupKaffehCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "kaffeh" ) ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } Path cp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { cp . append ( javah . getBootclasspath ( ) ) ; } cp = cp . concatSystemBootClasspath ( "ignore" ) ; if ( javah . getClasspath ( ) != null ) { cp . append ( javah . getClasspath ( ) ) ; } if ( cp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( cp ) ; } if ( ! javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-jni" ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0	['3', '1', '0', '11', '28', '3', '1', '10', '2', '1.5', '111', '0', '0', '0', '0.833333333', '0', '0', '35.66666667', '7', '2.6667', '0']
package org . apache . tools . ant . util ; import java . util . List ; import java . util . Arrays ; import java . util . Iterator ; import java . util . ArrayList ; public class ChainedMapper extends ContainerMapper { public String [ ] mapFileName ( String sourceFileName ) { List inputs = new ArrayList ( ) ; List results = new ArrayList ( ) ; results . add ( sourceFileName ) ; FileNameMapper mapper = null ; for ( Iterator mIter = getMappers ( ) . iterator ( ) ; mIter . hasNext ( ) ; ) { mapper = ( FileNameMapper ) ( mIter . next ( ) ) ; if ( mapper != null ) { inputs . clear ( ) ; inputs . addAll ( results ) ; results . clear ( ) ; for ( Iterator it = inputs . iterator ( ) ; it . hasNext ( ) ; ) { String [ ] mapped = mapper . mapFileName ( ( String ) ( it . next ( ) ) ) ; if ( mapped != null ) { results . addAll ( Arrays . asList ( mapped ) ) ; } } } } return ( results . size ( ) == 0 ) ? null : ( String [ ] ) results . toArray ( new String [ results . size ( ) ] ) ; } } 	0	['2', '2', '0', '2', '15', '1', '0', '2', '2', '2', '73', '0', '0', '0.875', '0.75', '0', '0', '35.5', '6', '3', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckout extends CCMCheck { public CCMCheckout ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKOUT ) ; } } 	0	['1', '5', '0', '1', '3', '0', '0', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; InputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = srcResource . getInputStream ( ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bis ) ; FileUtils . close ( fis ) ; FileUtils . close ( out ) ; FileUtils . close ( zIn ) ; } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( BUnzip2 . class ) ; } } 	0	['4', '4', '0', '6', '29', '6', '0', '6', '1', '1.166666667', '164', '0.5', '0', '0.942307692', '1', '3', '5', '39.5', '7', '2.5', '0']
package org . apache . tools . ant . util ; public class Base64Converter { private static final char [ ] ALPHABET = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public static final char [ ] alphabet = ALPHABET ; public String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } public String encode ( byte [ ] octetString ) { int bits24 ; int bits6 ; char [ ] out = new char [ ( ( octetString . length - 1 ) / 3 + 1 ) * 4 ] ; int outIndex = 0 ; int i = 0 ; while ( ( i + 3 ) <= octetString . length ) { bits24 = ( octetString [ i ++ ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i ++ ] & 0xFF ) << 8 ; bits24 |= octetString [ i ++ ] ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0000003F ) ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; } if ( octetString . length - i == 2 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i + 1 ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; } else if ( octetString . length - i == 1 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; out [ outIndex ++ ] = '=' ; } return new String ( out ) ; } } 	0	['4', '1', '1', '2', '7', '4', '2', '0', '3', '0.666666667', '502', '0.5', '0', '0', '0.555555556', '0', '0', '124', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Channel ; import com . jcraft . jsch . ChannelExec ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpProgressMonitor ; import java . io . IOException ; import java . io . OutputStream ; import java . io . InputStream ; import java . text . NumberFormat ; import org . apache . tools . ant . BuildException ; public abstract class AbstractSshMessage { private Session session ; private boolean verbose ; private LogListener listener = new LogListener ( ) { public void log ( String message ) { } } ; public AbstractSshMessage ( Session session ) { this ( false , session ) ; } public AbstractSshMessage ( boolean verbose , Session session ) { this . verbose = verbose ; this . session = session ; } protected Channel openExecChannel ( String command ) throws JSchException { ChannelExec channel = ( ChannelExec ) session . openChannel ( "exec" ) ; channel . setCommand ( command ) ; return channel ; } protected ChannelSftp openSftpChannel ( ) throws JSchException { ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; return channel ; } protected void sendAck ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; out . write ( buf ) ; out . flush ( ) ; } protected void waitForAck ( InputStream in ) throws IOException , BuildException { int b = in . read ( ) ; if ( b == - 1 ) { throw new BuildException ( "No response from server" ) ; } else if ( b != 0 ) { StringBuffer sb = new StringBuffer ( ) ; int c = in . read ( ) ; while ( c > 0 && c != '\n' ) { sb . append ( ( char ) c ) ; c = in . read ( ) ; } if ( b == 1 ) { throw new BuildException ( "server indicated an error: " + sb . toString ( ) ) ; } else if ( b == 2 ) { throw new BuildException ( "server indicated a fatal error: " + sb . toString ( ) ) ; } else { throw new BuildException ( "unknown response, code " + b + " message: " + sb . toString ( ) ) ; } } } public abstract void execute ( ) throws IOException , JSchException ; public void setLogListener ( LogListener aListener ) { listener = aListener ; } protected void log ( String message ) { listener . log ( message ) ; } protected void logStats ( long timeStarted , long timeEnded , long totalLength ) { double duration = ( timeEnded - timeStarted ) / 1000.0 ; NumberFormat format = NumberFormat . getNumberInstance ( ) ; format . setMaximumFractionDigits ( 2 ) ; format . setMinimumFractionDigits ( 1 ) ; listener . log ( "File transfer time: " + format . format ( duration ) + " Average Rate: " + format . format ( totalLength / duration ) + " B/s" ) ; } protected final boolean getVerbose ( ) { return verbose ; } protected final int trackProgress ( long filesize , long totalLength , int percentTransmitted ) { int percent = ( int ) Math . round ( Math . floor ( ( totalLength / ( double ) filesize ) * 100 ) ) ; if ( percent > percentTransmitted ) { if ( filesize < 1048576 ) { if ( percent % 10 == 0 ) { if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "*" ) ; } } } else { if ( percent == 50 ) { System . out . println ( " 50%" ) ; } else if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "." ) ; } } } return percent ; } private ProgressMonitor monitor = null ; protected SftpProgressMonitor getProgressMonitor ( ) { if ( monitor == null ) { monitor = new ProgressMonitor ( ) ; } return monitor ; } private class ProgressMonitor implements SftpProgressMonitor { private long initFileSize = 0 ; private long totalLength = 0 ; private int percentTransmitted = 0 ; public void init ( int op , String src , String dest , long max ) { initFileSize = max ; totalLength = 0 ; percentTransmitted = 0 ; } public boolean count ( long len ) { totalLength += len ; percentTransmitted = trackProgress ( initFileSize , totalLength , percentTransmitted ) ; return true ; } public void end ( ) { } public long getTotalLength ( ) { return totalLength ; } } } 	0	['13', '1', '2', '12', '37', '56', '4', '10', '4', '0.770833333', '269', '1', '2', '0', '0.205128205', '0', '0', '19.38461538', '7', '1.3846', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Majority extends ResourceSelectorContainer implements ResourceSelector { private boolean tie = true ; public Majority ( ) { } public Majority ( ResourceSelector [ ] r ) { super ( r ) ; } public synchronized void setAllowtie ( boolean b ) { tie = b ; } public synchronized boolean isSelected ( Resource r ) { int passed = 0 ; int failed = 0 ; int count = selectorCount ( ) ; boolean even = count % 2 == 0 ; int threshold = count / 2 ; for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { ++ passed ; if ( passed > threshold || ( even && tie && passed == threshold ) ) { return true ; } } else { ++ failed ; if ( failed > threshold || ( even && ! tie && failed == threshold ) ) { return false ; } } } return false ; } } 	0	['4', '4', '0', '3', '11', '0', '0', '3', '4', '0', '84', '1', '0', '0.945945946', '0.4375', '0', '0', '19.75', '12', '3.25', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; public interface HotDeploymentTool { String ACTION_DELETE = "delete" ; String ACTION_DEPLOY = "deploy" ; String ACTION_LIST = "list" ; String ACTION_UNDEPLOY = "undeploy" ; String ACTION_UPDATE = "update" ; void validateAttributes ( ) throws BuildException ; void deploy ( ) throws BuildException ; void setTask ( ServerDeploy task ) ; } 	0	['3', '1', '0', '5', '3', '3', '4', '2', '3', '1.5', '8', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Intersect extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rcs = getResourceCollections ( ) ; int size = rcs . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The intersection of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } ArrayList al = new ArrayList ( ) ; Iterator rc = rcs . iterator ( ) ; al . addAll ( collect ( rc . next ( ) ) ) ; while ( rc . hasNext ( ) ) { al . retainAll ( collect ( rc . next ( ) ) ) ; } return al ; } private ArrayList collect ( Object o ) { ArrayList result = new ArrayList ( ) ; for ( Iterator i = ( ( ResourceCollection ) o ) . iterator ( ) ; i . hasNext ( ) ; ) { result . add ( i . next ( ) ) ; } return result ; } } 	0	['3', '4', '0', '3', '19', '3', '0', '3', '1', '2', '83', '0', '0', '0.956521739', '0.666666667', '1', '1', '26.66666667', '4', '2', '0']
package org . apache . tools . ant . types . resources ; public interface Touchable { void touch ( long modTime ) ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class LocationResolver implements ExtensionResolver { private String location ; public void setLocation ( final String location ) { this . location = location ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { if ( null == location ) { final String message = "No location specified for resolver" ; throw new BuildException ( message ) ; } return project . resolveFile ( location ) ; } public String toString ( ) { return "Location[" + location + "]" ; } } 	0	['4', '1', '0', '5', '10', '0', '1', '4', '4', '0.333333333', '36', '1', '0', '0', '0.4375', '0', '0', '7.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSGet extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; if ( getVersion ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_VERSION ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; } } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; if ( getLabel ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_LABEL ) ; commandLine . createArgument ( ) . setValue ( getLabel ( ) ) ; } } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; return commandLine ; } } 	0	['6', '4', '0', '3', '20', '15', '0', '3', '5', '2', '106', '0', '0', '0.936708861', '0.555555556', '1', '2', '16.66666667', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class Utf8CPInfo extends ConstantPoolEntry { private String value ; public Utf8CPInfo ( ) { super ( CONSTANT_UTF8 , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { value = cpStream . readUTF ( ) ; } public String toString ( ) { return "UTF8 Value = " + value ; } public String getValue ( ) { return value ; } } 	0	['4', '2', '0', '5', '9', '0', '5', '1', '4', '0.333333333', '27', '1', '0', '0.666666667', '0.625', '1', '1', '5.5', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0	['24', '1', '0', '24', '24', '276', '4', '20', '24', '2', '24', '0', '0', '0', '0.089285714', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . io . File ; public class Directory { private File directory ; private ArrayList childDirectories ; private ArrayList files ; private Directory parent ; public Directory ( File directory ) { this ( directory , null ) ; } public Directory ( File directory , Directory parent ) { this . parent = parent ; this . childDirectories = new ArrayList ( ) ; this . files = new ArrayList ( ) ; this . directory = directory ; } public void addDirectory ( Directory directory ) { if ( ! childDirectories . contains ( directory ) ) { childDirectories . add ( directory ) ; } } public void addFile ( File file ) { files . add ( file ) ; } public Iterator directoryIterator ( ) { return childDirectories . iterator ( ) ; } public Iterator filesIterator ( ) { return files . iterator ( ) ; } public Directory getParent ( ) { return parent ; } public boolean isRoot ( ) { return parent == null ; } public File getDirectory ( ) { return directory ; } public Directory getChild ( File dir ) { for ( int i = 0 ; i < childDirectories . size ( ) ; i ++ ) { Directory current = ( Directory ) childDirectories . get ( i ) ; if ( current . getDirectory ( ) . equals ( dir ) ) { return current ; } } return null ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Directory ) ) { return false ; } Directory d = ( Directory ) obj ; return this . directory . equals ( d . directory ) ; } public int hashCode ( ) { return directory . hashCode ( ) ; } public String [ ] getPath ( ) { return getPath ( directory . getAbsolutePath ( ) ) ; } public static String [ ] getPath ( String thePath ) { StringTokenizer tokenizer = new StringTokenizer ( thePath , File . separator ) ; String [ ] path = new String [ tokenizer . countTokens ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { path [ i ] = tokenizer . nextToken ( ) ; i ++ ; } return path ; } public int fileSize ( ) { return files . size ( ) ; } } 	0	['15', '1', '0', '3', '29', '55', '3', '0', '15', '0.696428571', '161', '1', '1', '0', '0.293333333', '1', '1', '9.466666667', '3', '1.3333', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '9', '13', '0', '8', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public class DirectoryIterator implements ClassFileIterator { private Stack enumStack ; private Enumeration currentEnum ; public DirectoryIterator ( File rootDirectory , boolean changeInto ) throws IOException { super ( ) ; enumStack = new Stack ( ) ; Vector filesInRoot = getDirectoryEntries ( rootDirectory ) ; currentEnum = filesInRoot . elements ( ) ; } private Vector getDirectoryEntries ( File directory ) { Vector files = new Vector ( ) ; String [ ] filesInDir = directory . list ( ) ; if ( filesInDir != null ) { int length = filesInDir . length ; for ( int i = 0 ; i < length ; ++ i ) { files . addElement ( new File ( directory , filesInDir [ i ] ) ) ; } } return files ; } public ClassFile getNextClassFile ( ) { ClassFile nextElement = null ; try { while ( nextElement == null ) { if ( currentEnum . hasMoreElements ( ) ) { File element = ( File ) currentEnum . nextElement ( ) ; if ( element . isDirectory ( ) ) { enumStack . push ( currentEnum ) ; Vector files = getDirectoryEntries ( element ) ; currentEnum = files . elements ( ) ; } else { FileInputStream inFileStream = new FileInputStream ( element ) ; if ( element . getName ( ) . endsWith ( ".class" ) ) { ClassFile javaClass = new ClassFile ( ) ; javaClass . read ( inFileStream ) ; nextElement = javaClass ; } } } else { if ( enumStack . empty ( ) ) { break ; } else { currentEnum = ( Enumeration ) enumStack . pop ( ) ; } } } } catch ( IOException e ) { nextElement = null ; } return nextElement ; } } 	0	['3', '1', '0', '2', '21', '1', '0', '2', '2', '0.5', '120', '1', '0', '0', '0.666666667', '0', '0', '38.33333333', '6', '3', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class ConstantPool { private Vector entries ; private Hashtable utf8Indexes ; public ConstantPool ( ) { entries = new Vector ( ) ; entries . addElement ( null ) ; utf8Indexes = new Hashtable ( ) ; } public void read ( DataInputStream classStream ) throws IOException { int numEntries = classStream . readUnsignedShort ( ) ; for ( int i = 1 ; i < numEntries ; ) { ConstantPoolEntry nextEntry = ConstantPoolEntry . readEntry ( classStream ) ; i += nextEntry . getNumEntries ( ) ; addEntry ( nextEntry ) ; } } public int size ( ) { return entries . size ( ) ; } public int addEntry ( ConstantPoolEntry entry ) { int index = entries . size ( ) ; entries . addElement ( entry ) ; int numSlots = entry . getNumEntries ( ) ; for ( int j = 0 ; j < numSlots - 1 ; ++ j ) { entries . addElement ( null ) ; } if ( entry instanceof Utf8CPInfo ) { Utf8CPInfo utf8Info = ( Utf8CPInfo ) entry ; utf8Indexes . put ( utf8Info . getValue ( ) , new Integer ( index ) ) ; } return index ; } public void resolve ( ) { for ( Enumeration i = entries . elements ( ) ; i . hasMoreElements ( ) ; ) { ConstantPoolEntry poolInfo = ( ConstantPoolEntry ) i . nextElement ( ) ; if ( poolInfo != null && ! poolInfo . isResolved ( ) ) { poolInfo . resolve ( this ) ; } } } public ConstantPoolEntry getEntry ( int index ) { return ( ConstantPoolEntry ) entries . elementAt ( index ) ; } public int getUTF8Entry ( String value ) { int index = - 1 ; Integer indexInteger = ( Integer ) utf8Indexes . get ( value ) ; if ( indexInteger != null ) { index = indexInteger . intValue ( ) ; } return index ; } public int getClassEntry ( String className ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ClassCPInfo ) { ClassCPInfo classinfo = ( ClassCPInfo ) element ; if ( classinfo . getClassName ( ) . equals ( className ) ) { index = i ; } } } return index ; } public int getConstantEntry ( Object constantValue ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ConstantCPInfo ) { ConstantCPInfo constantEntry = ( ConstantCPInfo ) element ; if ( constantEntry . getValue ( ) . equals ( constantValue ) ) { index = i ; } } } return index ; } public int getMethodRefEntry ( String methodClassName , String methodName , String methodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof MethodRefCPInfo ) { MethodRefCPInfo methodRefEntry = ( MethodRefCPInfo ) element ; if ( methodRefEntry . getMethodClassName ( ) . equals ( methodClassName ) && methodRefEntry . getMethodName ( ) . equals ( methodName ) && methodRefEntry . getMethodType ( ) . equals ( methodType ) ) { index = i ; } } } return index ; } public int getInterfaceMethodRefEntry ( String interfaceMethodClassName , String interfaceMethodName , String interfaceMethodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof InterfaceMethodRefCPInfo ) { InterfaceMethodRefCPInfo interfaceMethodRefEntry = ( InterfaceMethodRefCPInfo ) element ; if ( interfaceMethodRefEntry . getInterfaceMethodClassName ( ) . equals ( interfaceMethodClassName ) && interfaceMethodRefEntry . getInterfaceMethodName ( ) . equals ( interfaceMethodName ) && interfaceMethodRefEntry . getInterfaceMethodType ( ) . equals ( interfaceMethodType ) ) { index = i ; } } } return index ; } public int getFieldRefEntry ( String fieldClassName , String fieldName , String fieldType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof FieldRefCPInfo ) { FieldRefCPInfo fieldRefEntry = ( FieldRefCPInfo ) element ; if ( fieldRefEntry . getFieldClassName ( ) . equals ( fieldClassName ) && fieldRefEntry . getFieldName ( ) . equals ( fieldName ) && fieldRefEntry . getFieldType ( ) . equals ( fieldType ) ) { index = i ; } } } return index ; } public int getNameAndTypeEntry ( String name , String type ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof NameAndTypeCPInfo ) { NameAndTypeCPInfo nameAndTypeEntry = ( NameAndTypeCPInfo ) element ; if ( nameAndTypeEntry . getName ( ) . equals ( name ) && nameAndTypeEntry . getType ( ) . equals ( type ) ) { index = i ; } } } return index ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( "\n" ) ; int size = entries . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { sb . append ( "[" + i + "] = " + getEntry ( i ) + "\n" ) ; } return sb . toString ( ) ; } } 	0	['14', '1', '0', '10', '53', '0', '8', '8', '14', '0.423076923', '419', '1', '0', '0', '0.285714286', '0', '0', '28.78571429', '7', '3.6429', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckout extends ClearCase { private boolean mReserved = true ; private String mOut = null ; private boolean mNdata = false ; private String mBranch = null ; private boolean mVersion = false ; private boolean mNwarn = false ; private String mComment = null ; private String mCfile = null ; private boolean mNotco = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKOUT ) ; checkOptions ( commandLine ) ; if ( ! getNotco ( ) && lsCheckout ( ) ) { getProject ( ) . log ( "Already checked out in this view: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; return ; } if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private boolean lsCheckout ( ) { Commandline cmdl = new Commandline ( ) ; String result ; cmdl . setExecutable ( getClearToolCommand ( ) ) ; cmdl . createArgument ( ) . setValue ( COMMAND_LSCO ) ; cmdl . createArgument ( ) . setValue ( "-cview" ) ; cmdl . createArgument ( ) . setValue ( "-short" ) ; cmdl . createArgument ( ) . setValue ( "-d" ) ; cmdl . createArgument ( ) . setValue ( getViewPath ( ) ) ; result = runS ( cmdl ) ; return ( result != null && result . length ( ) > 0 ) ? true : false ; } private void checkOptions ( Commandline cmd ) { if ( getReserved ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RESERVED ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_UNRESERVED ) ; } if ( getOut ( ) != null ) { getOutCommand ( cmd ) ; } else { if ( getNoData ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NODATA ) ; } } if ( getBranch ( ) != null ) { getBranchCommand ( cmd ) ; } else { if ( getVersion ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReserved ( boolean reserved ) { mReserved = reserved ; } public boolean getReserved ( ) { return mReserved ; } public void setNotco ( boolean notco ) { mNotco = notco ; } public boolean getNotco ( ) { return mNotco ; } public void setOut ( String outf ) { mOut = outf ; } public String getOut ( ) { return mOut ; } public void setNoData ( boolean ndata ) { mNdata = ndata ; } public boolean getNoData ( ) { return mNdata ; } public void setBranch ( String branch ) { mBranch = branch ; } public String getBranch ( ) { return mBranch ; } public void setVersion ( boolean version ) { mVersion = version ; } public boolean getVersion ( ) { return mVersion ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } private void getOutCommand ( Commandline cmd ) { if ( getOut ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_OUT ) ; cmd . createArgument ( ) . setValue ( getOut ( ) ) ; } } private void getBranchCommand ( Commandline cmd ) { if ( getBranch ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_BRANCH ) ; cmd . createArgument ( ) . setValue ( getBranch ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_RESERVED = "-reserved" ; public static final String FLAG_UNRESERVED = "-unreserved" ; public static final String FLAG_OUT = "-out" ; public static final String FLAG_NODATA = "-ndata" ; public static final String FLAG_BRANCH = "-branch" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['26', '4', '0', '7', '50', '271', '0', '7', '20', '0.955789474', '392', '0.473684211', '0', '0.657534247', '0.384615385', '2', '3', '13.34615385', '9', '1.5', '0']
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0	['5', '1', '0', '7', '5', '10', '6', '1', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckin extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mKeep = false ; private boolean mIdentical = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKIN ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } if ( getKeepCopy ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_KEEPCOPY ) ; } if ( getIdentical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IDENTICAL ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setKeepCopy ( boolean keep ) { mKeep = keep ; } public boolean getKeepCopy ( ) { return mKeep ; } public void setIdentical ( boolean identical ) { mIdentical = identical ; } public boolean getIdentical ( ) { return mIdentical ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_KEEPCOPY = "-keep" ; public static final String FLAG_IDENTICAL = "-identical" ; } 	0	['17', '4', '0', '7', '39', '100', '0', '7', '14', '0.9375', '241', '0.461538462', '0', '0.75', '0.382352941', '2', '3', '12.41176471', '7', '1.4118', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public class ImportTypelib extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File srcFile ; private File destFile ; private String namespace ; private boolean useSysArray = false ; private boolean unsafe = false ; private String extraOptions = null ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setSrcFile ( File srcFile ) { this . srcFile = srcFile ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public void setUseSysArray ( boolean useSysArray ) { this . useSysArray = useSysArray ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( "destination file must be specified" ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( "destination file is a directory" ) ; } if ( srcFile == null || ! srcFile . exists ( ) ) { throw new BuildException ( "source file does not exist" ) ; } if ( srcFile . isDirectory ( ) ) { throw new BuildException ( "source file is a directory" ) ; } if ( namespace == null ) { throw new BuildException ( "No namespace" ) ; } } private boolean isExecuteNeeded ( ) { if ( ! destFile . exists ( ) ) { log ( "Destination file does not exist: a build is required" , Project . MSG_VERBOSE ) ; return true ; } long sourceTime = srcFile . lastModified ( ) ; long destTime = destFile . lastModified ( ) ; if ( sourceTime > ( destTime + FILE_UTILS . getFileTimestampGranularity ( ) ) ) { log ( "Source file is newer than the dest file: a rebuild is required" , Project . MSG_VERBOSE ) ; return true ; } else { log ( "The output file is up to date" , Project . MSG_VERBOSE ) ; return false ; } } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; log ( "Importing typelib " + srcFile + " to assembly " + destFile + " in namespace " + namespace , Project . MSG_VERBOSE ) ; if ( ! isExecuteNeeded ( ) ) { return ; } NetCommand command = new NetCommand ( this , "ImportTypelib" , "tlbimp" ) ; command . setFailOnError ( true ) ; command . addArgument ( srcFile . toString ( ) ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/namespace:" , namespace ) ; if ( useSysArray ) { command . addArgument ( "/sysarray" ) ; } if ( unsafe ) { command . addArgument ( "/unsafe" ) ; } command . addArgument ( extraOptions ) ; command . runCommand ( ) ; } } 	0	['11', '3', '0', '4', '29', '17', '0', '4', '8', '0.771428571', '224', '1', '1', '0.804347826', '0.4', '1', '1', '18.72727273', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Get ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class URLResolver implements ExtensionResolver { private File destfile ; private File destdir ; private URL url ; public void setUrl ( final URL url ) { this . url = url ; } public void setDestfile ( final File destfile ) { this . destfile = destfile ; } public void setDestdir ( final File destdir ) { this . destdir = destdir ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { validate ( ) ; final File file = getDest ( ) ; final Get get = new Get ( ) ; get . setProject ( project ) ; get . setDest ( file ) ; get . setSrc ( url ) ; get . execute ( ) ; return file ; } private File getDest ( ) { File result ; if ( null != destfile ) { result = destfile ; } else { final String file = url . getFile ( ) ; String filename ; if ( null == file || file . length ( ) <= 1 ) { filename = "default.file" ; } else { int index = file . lastIndexOf ( '/' ) ; if ( - 1 == index ) { index = 0 ; } filename = file . substring ( index ) ; } result = new File ( destdir , filename ) ; } return result ; } private void validate ( ) { if ( null == url ) { final String message = "Must specify URL" ; throw new BuildException ( message ) ; } if ( null == destdir && null == destfile ) { final String message = "Must specify destination file or directory" ; throw new BuildException ( message ) ; } else if ( null != destdir && null != destfile ) { final String message = "Must not specify both destination file or directory" ; throw new BuildException ( message ) ; } } public String toString ( ) { return "URL[" + url + "]" ; } } 	0	['8', '1', '0', '6', '24', '0', '1', '5', '6', '0.523809524', '133', '1', '0', '0', '0.325', '0', '0', '15.25', '6', '2', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public final class KaffeNative2Ascii extends DefaultNative2Ascii { private static final String [ ] N2A_CLASSNAMES = new String [ ] { "gnu.classpath.tools.native2ascii.Native2Ascii" , "kaffe.tools.native2ascii.Native2Ascii" , } ; public static final String IMPLEMENTATION_NAME = "kaffe" ; protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getReverse ( ) ) { throw new BuildException ( "-reverse is not supported by Kaffe" ) ; } super . setup ( cmd , args ) ; } protected boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException { ExecuteJava ej = new ExecuteJava ( ) ; Class c = getN2aClass ( ) ; if ( c == null ) { throw new BuildException ( "Couldn't load Kaffe's Native2Ascii" + " class" ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; ej . execute ( log . getProject ( ) ) ; return true ; } private static Class getN2aClass ( ) { for ( int i = 0 ; i < N2A_CLASSNAMES . length ; i ++ ) { try { return Class . forName ( N2A_CLASSNAMES [ i ] ) ; } catch ( ClassNotFoundException cnfe ) { } } return null ; } } 	0	['5', '2', '0', '8', '16', '8', '1', '7', '1', '0.875', '77', '0.5', '0', '0.571428571', '0.4375', '1', '2', '14', '2', '0.8', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String userID ; private String displayName ; public void setDisplayname ( final String displayName ) { this . displayName = displayName ; } public void setUserid ( final String userID ) { this . userID = userID ; } public String getUserID ( ) { return userID ; } public String getDisplayname ( ) { return displayName ; } public void validate ( ) throws BuildException { if ( null == userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == displayName ) { final String message = "Displayname attribute must be set for userID " + userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '6', '0.6', '51', '1', '0', '0', '0.666666667', '0', '0', '7.166666667', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public void setLines ( final long lines ) { this . lines = lines ; } private long getLines ( ) { return lines ; } public void setSkip ( final long skip ) { this . skip = skip ; } private long getSkip ( ) { return skip ; } public Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0	['10', '5', '0', '5', '30', '0', '1', '4', '6', '0.688888889', '328', '1', '1', '0.777777778', '0.375', '2', '5', '30.8', '12', '2.3', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . tools . ant . BuildException ; public class Xalan2Executor extends XalanExecutor { private static final String APAC = "org.apache.xalan." ; private static final String SPAC = "com.sun.org.apache.xalan." ; private TransformerFactory tfactory = TransformerFactory . newInstance ( ) ; protected String getImplementation ( ) throws BuildException { return tfactory . getClass ( ) . getName ( ) ; } protected String getProcVersion ( String classNameImpl ) throws BuildException { try { if ( classNameImpl . equals ( APAC + "processor.TransformerFactoryImpl" ) || classNameImpl . equals ( APAC + "xslt.XSLTProcessorFactory" ) ) { return getXalanVersion ( APAC + "processor.XSLProcessorVersion" ) ; } if ( classNameImpl . equals ( APAC + "xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( APAC + "xsltc.ProcessorVersion" ) ; } if ( classNameImpl . equals ( SPAC + "internal.xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( SPAC + "internal.xsltc.ProcessorVersion" ) ; } throw new BuildException ( "Could not find a valid processor version" + " implementation from " + classNameImpl ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find processor version " + "implementation" , e ) ; } } void execute ( ) throws Exception { String systemId = caller . getStylesheetSystemId ( ) ; Source xslSrc = new StreamSource ( systemId ) ; Transformer tformer = tfactory . newTransformer ( xslSrc ) ; Source xmlSrc = new DOMSource ( caller . document ) ; OutputStream os = getOutputStream ( ) ; try { tformer . setParameter ( "output.dir" , caller . toDir . getAbsolutePath ( ) ) ; Result result = new StreamResult ( os ) ; tformer . transform ( xmlSrc , result ) ; } finally { os . close ( ) ; } } } 	0	['4', '2', '0', '3', '26', '0', '0', '3', '1', '1', '115', '1', '0', '0.727272727', '0.625', '2', '3', '27', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0	['13', '5', '0', '9', '34', '68', '6', '4', '12', '0.75', '199', '1', '0', '0.837837838', '0.292307692', '2', '8', '14.15384615', '5', '2.1538', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_DIM = 2 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String errC = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( errC != null ) { errColor = PREFIX + errC + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : default : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0	['3', '2', '0', '1', '17', '0', '0', '1', '1', '0.96875', '251', '1', '0', '0.888888889', '0.5', '1', '3', '77.33333333', '11', '5.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public class Quantifier extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "all" , "each" , "every" , "any" , "some" , "one" , "majority" , "most" , "none" } ; public static final Quantifier ALL = new Quantifier ( "all" ) ; public static final Quantifier ANY = new Quantifier ( "any" ) ; public static final Quantifier ONE = new Quantifier ( "one" ) ; public static final Quantifier MAJORITY = new Quantifier ( "majority" ) ; public static final Quantifier NONE = new Quantifier ( "none" ) ; private abstract static class Predicate { abstract boolean eval ( int t , int f ) ; } private static final Predicate ALL_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return f == 0 ; } } ; private static final Predicate ANY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > 0 ; } } ; private static final Predicate ONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 1 ; } } ; private static final Predicate MAJORITY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > f ; } } ; private static final Predicate NONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 0 ; } } ; private static final Predicate [ ] PREDS = new Predicate [ VALUES . length ] ; static { PREDS [ 0 ] = ALL_PRED ; PREDS [ 1 ] = ALL_PRED ; PREDS [ 2 ] = ALL_PRED ; PREDS [ 3 ] = ANY_PRED ; PREDS [ 4 ] = ANY_PRED ; PREDS [ 5 ] = ONE_PRED ; PREDS [ 6 ] = MAJORITY_PRED ; PREDS [ 7 ] = MAJORITY_PRED ; PREDS [ 8 ] = NONE_PRED ; } public Quantifier ( ) { } public Quantifier ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( boolean [ ] b ) { int t = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] ) { t ++ ; } } return evaluate ( t , b . length - t ) ; } public boolean evaluate ( int t , int f ) { int index = getIndex ( ) ; if ( index == - 1 ) { throw new BuildException ( "Quantifier value not set." ) ; } return PREDS [ index ] . eval ( t , f ) ; } } 	0	['6', '2', '0', '9', '16', '11', '1', '8', '5', '0.95', '195', '0.583333333', '11', '0.727272727', '0.4', '1', '1', '29.5', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class ClearCase extends Task { private String mClearToolDir = "" ; private String mviewPath = null ; private String mobjSelect = null ; private static int pcnt = 0 ; private boolean mFailonerr = true ; public final void setClearToolDir ( String dir ) { mClearToolDir = FileUtils . translatePath ( dir ) ; } protected final String getClearToolCommand ( ) { String toReturn = mClearToolDir ; if ( ! toReturn . equals ( "" ) && ! toReturn . endsWith ( "/" ) ) { toReturn += "/" ; } toReturn += CLEARTOOL_EXE ; return toReturn ; } public final void setViewPath ( String viewPath ) { mviewPath = viewPath ; } public String getViewPath ( ) { return mviewPath ; } public String getViewPathBasename ( ) { return ( new File ( mviewPath ) ) . getName ( ) ; } public final void setObjSelect ( String objSelect ) { mobjSelect = objSelect ; } public String getObjSelect ( ) { return mobjSelect ; } protected int run ( Commandline cmd ) { try { Project aProj = getProject ( ) ; Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( aProj ) ; exe . setWorkingDirectory ( aProj . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected String runS ( Commandline cmdline ) { String outV = "opts.cc.runS.output" + pcnt ++ ; ExecTask exe = new ExecTask ( this ) ; Commandline . Argument arg = exe . createArg ( ) ; exe . setExecutable ( cmdline . getExecutable ( ) ) ; arg . setLine ( Commandline . toString ( cmdline . getArguments ( ) ) ) ; exe . setOutputproperty ( outV ) ; exe . execute ( ) ; return getProject ( ) . getProperty ( outV ) ; } public void setFailOnErr ( boolean failonerr ) { mFailonerr = failonerr ; } public boolean getFailOnErr ( ) { return mFailonerr ; } private static final String CLEARTOOL_EXE = "cleartool" ; public static final String COMMAND_UPDATE = "update" ; public static final String COMMAND_CHECKOUT = "checkout" ; public static final String COMMAND_CHECKIN = "checkin" ; public static final String COMMAND_UNCHECKOUT = "uncheckout" ; public static final String COMMAND_LOCK = "lock" ; public static final String COMMAND_UNLOCK = "unlock" ; public static final String COMMAND_MKBL = "mkbl" ; public static final String COMMAND_MKLABEL = "mklabel" ; public static final String COMMAND_MKLBTYPE = "mklbtype" ; public static final String COMMAND_RMTYPE = "rmtype" ; public static final String COMMAND_LSCO = "lsco" ; public static final String COMMAND_MKELEM = "mkelem" ; public static final String COMMAND_MKATTR = "mkattr" ; public static final String COMMAND_MKDIR = "mkdir" ; } 	0	['13', '3', '13', '24', '45', '46', '13', '11', '9', '1.020833333', '189', '0.3', '0', '0.770833333', '0.375', '0', '0', '12', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUnlock extends ClearCase { private String mComment = null ; private String mPname = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UNLOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { getCommentCommand ( cmd ) ; if ( getObjSelect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjSelect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjSelect ( ) ) ; } } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjselect ( String objselect ) { setObjSelect ( objselect ) ; } public void setObjSel ( String objsel ) { setObjSelect ( objsel ) ; } public String getObjselect ( ) { return getObjSelect ( ) ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjSelect ( ) ; } } public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0	['13', '4', '0', '7', '37', '66', '0', '7', '9', '0.875', '184', '0.5', '0', '0.8', '0.512820513', '2', '3', '12.84615385', '4', '1.3846', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; public class ResourceCount extends Task implements Condition { private static final String ONE_NESTED_MESSAGE = "ResourceCount can count resources from exactly one nested ResourceCollection." ; private static final String COUNT_REQUIRED = "Use of the ResourceCount condition requires that the count attribute be set." ; private ResourceCollection rc ; private Comparison when = Comparison . EQUAL ; private Integer count ; private String property ; public void add ( ResourceCollection r ) { if ( rc != null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } rc = r ; } public void setRefid ( Reference r ) { Object o = r . getReferencedObject ( ) ; if ( ! ( o instanceof ResourceCollection ) ) { throw new BuildException ( r . getRefId ( ) + " doesn\'t denote a ResourceCollection" ) ; } add ( ( ResourceCollection ) o ) ; } public void execute ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( property == null ) { log ( "resource count = " + rc . size ( ) ) ; } else { getProject ( ) . setNewProperty ( property , Integer . toString ( rc . size ( ) ) ) ; } } public boolean eval ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( count == null ) { throw new BuildException ( COUNT_REQUIRED ) ; } return when . evaluate ( new Integer ( rc . size ( ) ) . compareTo ( count ) ) ; } public void setCount ( int c ) { count = new Integer ( c ) ; } public void setWhen ( Comparison c ) { when = c ; } public void setProperty ( String p ) { property = p ; } } 	0	['8', '3', '0', '7', '25', '12', '0', '7', '8', '0.880952381', '133', '1', '2', '0.840909091', '0.270833333', '1', '1', '14.875', '3', '1.625', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class ScriptRunnerCreator { private static final String AUTO = "auto" ; private static final String OATAU = "org.apache.tools.ant.util" ; private static final String UTIL_OPT = OATAU + ".optional" ; private static final String BSF = "bsf" ; private static final String BSF_PACK = "org.apache.bsf" ; private static final String BSF_MANAGER = BSF_PACK + ".BSFManager" ; private static final String BSF_RUNNER = UTIL_OPT + ".ScriptRunner" ; private static final String JAVAX = "javax" ; private static final String JAVAX_MANAGER = "javax.script.ScriptEngineManager" ; private static final String JAVAX_RUNNER = UTIL_OPT + ".JavaxScriptRunner" ; private Project project ; private String manager ; private String language ; private ClassLoader scriptLoader = null ; public ScriptRunnerCreator ( Project project ) { this . project = project ; } public ScriptRunnerBase createRunner ( String manager , String language , ClassLoader classLoader ) { this . manager = manager ; this . language = language ; this . scriptLoader = classLoader ; if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } if ( ! manager . equals ( AUTO ) && ! manager . equals ( JAVAX ) && ! manager . equals ( BSF ) ) { throw new BuildException ( "Unsupported language prefix " + manager ) ; } ScriptRunnerBase ret = null ; ret = createRunner ( BSF , BSF_MANAGER , BSF_RUNNER ) ; if ( ret == null ) { ret = createRunner ( JAVAX , JAVAX_MANAGER , JAVAX_RUNNER ) ; } if ( ret != null ) { return ret ; } if ( JAVAX . equals ( manager ) ) { throw new BuildException ( "Unable to load the script engine manager " + "(" + JAVAX_MANAGER + ")" ) ; } else if ( BSF . equals ( manager ) ) { throw new BuildException ( "Unable to load the BSF script engine manager " + "(" + BSF_MANAGER + ")" ) ; } else { throw new BuildException ( "Unable to load a script engine manager " + "(" + BSF_MANAGER + " or " + JAVAX_MANAGER + ")" ) ; } } private ScriptRunnerBase createRunner ( String checkManager , String managerClass , String runnerClass ) { ScriptRunnerBase runner = null ; if ( ! manager . equals ( AUTO ) && ! manager . equals ( checkManager ) ) { return null ; } if ( scriptLoader . getResource ( LoaderUtils . classNameToResource ( managerClass ) ) == null ) { return null ; } try { runner = ( ScriptRunnerBase ) Class . forName ( runnerClass , true , scriptLoader ) . newInstance ( ) ; runner . setProject ( project ) ; } catch ( Exception ex ) { ReflectUtil . throwBuildException ( ex ) ; } runner . setLanguage ( language ) ; runner . setScriptClassLoader ( scriptLoader ) ; return runner ; } } 	0	['3', '1', '0', '6', '17', '0', '1', '5', '2', '1.142857143', '156', '1', '1', '0', '0.583333333', '0', '0', '46.33333333', '9', '4.3333', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . ResourceUtils ; public class Content extends ResourceComparator { private boolean binary = true ; public void setBinary ( boolean b ) { binary = b ; } public boolean isBinary ( ) { return binary ; } protected int resourceCompare ( Resource foo , Resource bar ) { try { return ResourceUtils . compareContent ( foo , bar , ! binary ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['4', '4', '0', '4', '7', '0', '0', '4', '3', '0', '34', '1', '0', '0.918918919', '0.5', '1', '1', '7.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . UserInfo ; import com . jcraft . jsch . UIKeyboardInteractive ; public class SSHUserInfo implements UserInfo , UIKeyboardInteractive { private String name ; private String password = null ; private String keyfile ; private String passphrase = null ; private boolean trustAllCertificates ; public SSHUserInfo ( ) { super ( ) ; this . trustAllCertificates = false ; } public SSHUserInfo ( String password , boolean trustAllCertificates ) { super ( ) ; this . password = password ; this . trustAllCertificates = trustAllCertificates ; } public String getName ( ) { return name ; } public String getPassphrase ( String message ) { return passphrase ; } public String getPassword ( ) { return password ; } public boolean prompt ( String str ) { return false ; } public boolean retry ( ) { return false ; } public void setName ( String name ) { this . name = name ; } public void setPassphrase ( String passphrase ) { this . passphrase = passphrase ; } public void setPassword ( String password ) { this . password = password ; } public void setTrust ( boolean trust ) { this . trustAllCertificates = trust ; } public boolean getTrust ( ) { return this . trustAllCertificates ; } public String getPassphrase ( ) { return passphrase ; } public String getKeyfile ( ) { return keyfile ; } public void setKeyfile ( String keyfile ) { this . keyfile = keyfile ; } public boolean promptPassphrase ( String message ) { return true ; } public boolean promptPassword ( String passwordPrompt ) { return true ; } public boolean promptYesNo ( String message ) { return trustAllCertificates ; } public void showMessage ( String message ) { } public String [ ] promptKeyboardInteractive ( String destination , String name , String instruction , String [ ] prompt , boolean [ ] echo ) { if ( prompt . length != 1 || echo [ 0 ] || this . password == null ) { return null ; } String [ ] response = new String [ 1 ] ; response [ 0 ] = this . password ; return response ; } } 	0	['20', '1', '0', '5', '21', '130', '3', '2', '20', '0.852631579', '125', '1', '0', '0', '0.36', '0', '0', '5', '4', '1.05', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . BufferedWriter ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; public final class JavaEnvUtils { private JavaEnvUtils ( ) { } private static final boolean IS_DOS = Os . isFamily ( "dos" ) ; private static final boolean IS_NETWARE = Os . isName ( "netware" ) ; private static final boolean IS_AIX = Os . isName ( "aix" ) ; private static final String JAVA_HOME = System . getProperty ( "java.home" ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; public static final String JAVA_1_5 = "1.5" ; public static final String JAVA_1_6 = "1.6" ; private static boolean kaffeDetected ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; Class . forName ( "java.net.Proxy" ) ; javaVersion = JAVA_1_5 ; javaVersionNumber ++ ; Class . forName ( "java.util.ServiceLoader" ) ; javaVersion = JAVA_1_6 ; javaVersionNumber ++ ; } catch ( Throwable t ) { } kaffeDetected = false ; try { Class . forName ( "kaffe.util.NotImplemented" ) ; kaffeDetected = true ; } catch ( Throwable t ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static int getJavaVersionNumber ( ) { return javaVersionNumber ; } public static boolean isJavaVersion ( String version ) { return javaVersion . equals ( version ) ; } public static boolean isAtLeastJavaVersion ( String version ) { return javaVersion . compareTo ( version ) >= 0 ; } public static boolean isKaffe ( ) { return kaffeDetected ; } public static String getJreExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( IS_DOS ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = FILE_UTILS . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 16 : case 15 : jrePackages . addElement ( "com.sun.org.apache" ) ; case 14 : if ( javaVersionNumber == 14 ) { jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; } jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun" ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 16 : case 15 : tests . addElement ( "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl " ) ; case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; if ( javaVersionNumber == 14 ) { tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; } tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } public static File createVmsJavaOptionFile ( String [ ] cmd ) throws IOException { File script = FILE_UTILS . createTempFile ( "ANT" , ".JAVA_OPTS" , null ) ; PrintWriter out = null ; try { out = new PrintWriter ( new BufferedWriter ( new FileWriter ( script ) ) ) ; for ( int i = 0 ; i < cmd . length ; i ++ ) { out . println ( cmd [ i ] ) ; } } finally { FileUtils . close ( out ) ; } return script ; } public static String getJavaHome ( ) { return JAVA_HOME ; } } 	0	['16', '1', '0', '29', '40', '72', '27', '2', '11', '0.929166667', '463', '0.5625', '1', '0', '0.177777778', '0', '0', '26.9375', '5', '1.9375', '0']
package org . apache . tools . ant . util ; public class XmlConstants { public static final String PROPERTY_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-schemaLocation" ; public static final String PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation" ; public static final String FEATURE_XSD_FULL_VALIDATION = "http://apache.org/xml/features/validation/schema-full-checking" ; public static final String FEATURE_XSD = "http://apache.org/xml/features/validation/schema" ; public static final String FEATURE_VALIDATION = "http://xml.org/sax/features/validation" ; public static final String FEATURE_NAMESPACES = "http://xml.org/sax/features/namespaces" ; public static final String FEATURE_JAXP12_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage" ; public static final String FEATURE_JAXP12_SCHEMA_SOURCE = "http://java.sun.com/xml/jaxp/properties/schemaSource" ; public static final String URI_XSD = "http://www.w3.org/2001/XMLSchema" ; public static final String FEATURE_EXTERNAL_ENTITIES = "http://xml.org/sax/features/external-general-entities" ; public static final String FEATURE_DISALLOW_DTD = "http://apache.org/xml/features/disallow-doctype-decl" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '15', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public interface ExtensionResolver { File resolve ( Extension extension , Project project ) throws BuildException ; } 	0	['1', '1', '0', '7', '1', '0', '4', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '271', '0', '0', '0', '0.45', '0', '0', '32.875', '7', '2.875', '0']
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Type implements ResourceSelector { private static final String FILE_ATTR = "file" ; private static final String DIR_ATTR = "dir" ; public static final Type FILE = new Type ( new FileDir ( FILE_ATTR ) ) ; public static final Type DIR = new Type ( new FileDir ( DIR_ATTR ) ) ; public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { FILE_ATTR , DIR_ATTR } ; public FileDir ( ) { } public FileDir ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } } private FileDir type = null ; public Type ( ) { } public Type ( FileDir fd ) { setType ( fd ) ; } public void setType ( FileDir fd ) { type = fd ; } public boolean isSelected ( Resource r ) { if ( type == null ) { throw new BuildException ( "The type attribute is required." ) ; } int i = type . getIndex ( ) ; return r . isDirectory ( ) ? i == 1 : i == 0 ; } } 	0	['5', '1', '0', '6', '10', '0', '2', '4', '4', '0.9', '74', '0.6', '3', '0', '0.583333333', '0', '0', '12.8', '5', '1.2', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class FileList extends DataType implements ResourceCollection { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { checkAttributesAllowed ( ) ; this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { checkAttributesAllowed ( ) ; if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { return ( FileList ) getCheckedRef ( p ) ; } public static class FileName { private String name ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public void addConfiguredFile ( FileName name ) { if ( name . getName ( ) == null ) { throw new BuildException ( "No name specified in nested file element" ) ; } filenames . addElement ( name . getName ( ) ) ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( dir , ( String [ ] ) ( filenames . toArray ( new String [ filenames . size ( ) ] ) ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . size ( ) ; } return filenames . size ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } 	0	['12', '3', '0', '13', '32', '0', '6', '7', '10', '0.454545455', '192', '1', '0', '0.75', '0.238095238', '1', '1', '14.83333333', '4', '1.6667', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public ExitException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['3', '5', '0', '3', '7', '0', '3', '0', '3', '0', '27', '1', '0', '0.928571429', '0.666666667', '0', '0', '7.666666667', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . net ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class MimeMail extends EmailTask { public void execute ( ) throws BuildException { log ( "DEPRECATED - The " + getTaskName ( ) + " task is deprecated. " + "Use the mail task instead." ) ; super . execute ( ) ; } } 	0	['2', '4', '0', '2', '9', '1', '0', '2', '2', '2', '22', '0', '0', '0.985507246', '1', '1', '1', '10', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class IntegerCPInfo extends ConstantCPInfo { public IntegerCPInfo ( ) { super ( CONSTANT_INTEGER , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Integer ( cpStream . readInt ( ) ) ) ; } public String toString ( ) { return "Integer Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class P4Labelsync extends P4Base { protected String name ; private boolean add ; private boolean delete ; private boolean simulationmode ; public boolean isAdd ( ) { return add ; } public void setAdd ( boolean add ) { this . add = add ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public void setName ( String name ) { this . name = name ; } public boolean isSimulationmode ( ) { return simulationmode ; } public void setSimulationmode ( boolean simulationmode ) { this . simulationmode = simulationmode ; } public void execute ( ) throws BuildException { log ( "P4Labelsync exec:" , Project . MSG_INFO ) ; if ( P4View != null && P4View . length ( ) >= 1 ) { P4View = StringUtils . replace ( P4View , ":" , "\n\t" ) ; P4View = StringUtils . replace ( P4View , ";" , "\n\t" ) ; } if ( P4View == null ) { P4View = "" ; } if ( name == null || name . length ( ) < 1 ) { throw new BuildException ( "name attribute is compulsory for labelsync" ) ; } if ( this . isSimulationmode ( ) ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . isDelete ( ) ) { P4CmdOpts = P4CmdOpts + " -d" ; } if ( this . isAdd ( ) ) { P4CmdOpts = P4CmdOpts + " -a" ; } execP4Command ( "-s labelsync -l " + name + " " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['9', '4', '0', '5', '20', '28', '0', '5', '9', '0.78125', '156', '1', '0', '0.86440678', '0.481481481', '2', '2', '15.88888889', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; public class VisualBasicCompile extends DotnetCompile { private boolean removeIntChecks = false ; private boolean optionExplicit = false ; private boolean optionStrict = false ; private String optionCompare ; private String rootNamespace ; private String imports ; public VisualBasicCompile ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; imports = null ; rootNamespace = null ; optionCompare = null ; optionExplicit = false ; optionStrict = false ; removeIntChecks = false ; setExecutable ( "vbc" ) ; } protected String getWin32ResParameter ( ) { if ( getWin32Res ( ) != null ) { return "/win32resource:" + getWin32Res ( ) . toString ( ) ; } else { return null ; } } public void setRemoveIntChecks ( boolean flag ) { removeIntChecks = flag ; } public boolean getRemoveIntChecks ( ) { return removeIntChecks ; } public String getRemoveIntChecksParameter ( ) { return "/removeintchecks" + ( removeIntChecks ? "+" : "-" ) ; } public void setOptionExplicit ( boolean flag ) { optionExplicit = flag ; } public boolean getOptionExplicit ( ) { return optionExplicit ; } public String getOptionExplicitParameter ( ) { return "/optionexplicit" + ( optionExplicit ? "+" : "-" ) ; } public void setOptionStrict ( boolean flag ) { optionStrict = flag ; } public boolean getOptionStrict ( ) { return optionStrict ; } public String getOptionStrictParameter ( ) { return "/optionstrict" + ( optionStrict ? "+" : "-" ) ; } public void setRootNamespace ( String rootNamespace ) { this . rootNamespace = rootNamespace ; } public String getRootNamespace ( ) { return this . rootNamespace ; } protected String getRootNamespaceParameter ( ) { if ( rootNamespace != null && rootNamespace . length ( ) != 0 ) { return "/rootnamespace:" + rootNamespace ; } else { return null ; } } public void setImports ( String imports ) { this . imports = imports ; } public String getImports ( ) { return this . imports ; } protected String getImportsParameter ( ) { if ( imports != null && imports . length ( ) != 0 ) { return "/imports:" + imports ; } else { return null ; } } public void setOptionCompare ( String optionCompare ) { if ( "text" . equalsIgnoreCase ( optionCompare ) ) { this . optionCompare = "text" ; } else { this . optionCompare = "binary" ; } } public String getOptionCompare ( ) { return this . optionCompare ; } protected String getOptionCompareParameter ( ) { if ( optionCompare != null && "text" . equalsIgnoreCase ( optionCompare ) ) { return "/optioncompare:text" ; } else { return "/optioncompare:binary" ; } } protected void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getRemoveIntChecksParameter ( ) ) ; command . addArgument ( getImportsParameter ( ) ) ; command . addArgument ( getOptionExplicitParameter ( ) ) ; command . addArgument ( getOptionStrictParameter ( ) ) ; command . addArgument ( getRootNamespaceParameter ( ) ) ; command . addArgument ( getOptionCompareParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return "," ; } public String getFileExtension ( ) { return "vb" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , false ) ; } protected void validate ( ) throws BuildException { super . validate ( ) ; if ( getDestFile ( ) == null ) { throw new BuildException ( "DestFile was not specified" ) ; } } } 	0	['26', '6', '0', '5', '42', '233', '0', '5', '19', '0.8', '269', '1', '0', '0.857142857', '0.269230769', '1', '7', '9.115384615', '3', '1.3846', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . Iterator ; import java . util . Vector ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class JarLibAvailableTask extends Task { private File libraryFile ; private final Vector extensionFileSets = new Vector ( ) ; private String propertyName ; private ExtensionAdapter requiredExtension ; public void setProperty ( final String property ) { this . propertyName = property ; } public void setFile ( final File file ) { this . libraryFile = file ; } public void addConfiguredExtension ( final ExtensionAdapter extension ) { if ( null != requiredExtension ) { final String message = "Can not specify extension to " + "search for multiple times." ; throw new BuildException ( message ) ; } requiredExtension = extension ; } public void addConfiguredExtensionSet ( final ExtensionSet extensionSet ) { extensionFileSets . addElement ( extensionSet ) ; } public void execute ( ) throws BuildException { validate ( ) ; final Extension test = requiredExtension . toExtension ( ) ; if ( ! extensionFileSets . isEmpty ( ) ) { final Iterator iterator = extensionFileSets . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ExtensionSet extensionSet = ( ExtensionSet ) iterator . next ( ) ; final Extension [ ] extensions = extensionSet . toExtensions ( getProject ( ) ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } else { final Manifest manifest = ExtensionUtil . getManifest ( libraryFile ) ; final Extension [ ] extensions = Extension . getAvailable ( manifest ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } private void validate ( ) throws BuildException { if ( null == requiredExtension ) { final String message = "Extension element must be specified." ; throw new BuildException ( message ) ; } if ( null == libraryFile && extensionFileSets . isEmpty ( ) ) { final String message = "File attribute not specified." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . exists ( ) ) { final String message = "File '" + libraryFile + "' does not exist." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . isFile ( ) ) { final String message = "\'" + libraryFile + "\' is not a file." ; throw new BuildException ( message ) ; } } } 	0	['7', '3', '0', '7', '28', '0', '0', '7', '6', '0.666666667', '191', '1', '1', '0.860465116', '0.314285714', '0', '0', '25.71428571', '2', '1', '0']
package org . apache . tools . ant ; public interface DynamicElement { Object createDynamicElement ( String name ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; public class Header { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } 	0	['5', '1', '0', '3', '6', '6', '3', '0', '5', '0.75', '24', '1', '0', '0', '0.7', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( getProject ( ) , d , getLocation ( ) ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; setProperty ( "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } private void setProperty ( String name , String value ) { getProject ( ) . setNewProperty ( prefix + name , value ) ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } Tstamp . this . setProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Map calendarFields = new HashMap ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	0	['6', '3', '0', '5', '27', '3', '1', '5', '4', '0.4', '135', '1', '0', '0.880952381', '0.5', '0', '0', '21.16666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class SoundTask extends Task { private BuildAlert success = null ; private BuildAlert fail = null ; public BuildAlert createSuccess ( ) { success = new BuildAlert ( ) ; return success ; } public BuildAlert createFail ( ) { fail = new BuildAlert ( ) ; return fail ; } public SoundTask ( ) { } public void init ( ) { } public void execute ( ) { AntSoundPlayer soundPlayer = new AntSoundPlayer ( ) ; if ( success == null ) { log ( "No nested success element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildSuccessfulSound ( success . getSource ( ) , success . getLoops ( ) , success . getDuration ( ) ) ; } if ( fail == null ) { log ( "No nested failure element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildFailedSound ( fail . getSource ( ) , fail . getLoops ( ) , fail . getDuration ( ) ) ; } getProject ( ) . addBuildListener ( soundPlayer ) ; } public class BuildAlert { private File source = null ; private int loops = 0 ; private Long duration = null ; public void setDuration ( Long duration ) { this . duration = duration ; } public void setSource ( File source ) { this . source = source ; } public void setLoops ( int loops ) { this . loops = loops ; } public File getSource ( ) { File nofile = null ; if ( source . exists ( ) ) { if ( source . isDirectory ( ) ) { String [ ] entries = source . list ( ) ; Vector files = new Vector ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { File f = new File ( source , entries [ i ] ) ; if ( f . isFile ( ) ) { files . addElement ( f ) ; } } if ( files . size ( ) < 1 ) { throw new BuildException ( "No files found in directory " + source ) ; } int numfiles = files . size ( ) ; Random rn = new Random ( ) ; int x = rn . nextInt ( numfiles ) ; this . source = ( File ) files . elementAt ( x ) ; } } else { log ( source + ": invalid path." , Project . MSG_WARN ) ; this . source = nofile ; } return this . source ; } public int getLoops ( ) { return this . loops ; } public Long getDuration ( ) { return this . duration ; } } } 	0	['5', '3', '0', '5', '16', '0', '1', '5', '5', '0.5', '82', '1', '2', '0.902439024', '1', '1', '1', '15', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JJDoc extends Task { private static final String OUTPUT_FILE = "OUTPUT_FILE" ; private static final String TEXT = "TEXT" ; private static final String ONE_TABLE = "ONE_TABLE" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private String outputFile = null ; private boolean plainText = false ; private static final String DEFAULT_SUFFIX_HTML = ".html" ; private static final String DEFAULT_SUFFIX_TEXT = ".txt" ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; public void setText ( boolean plainText ) { optionalAttrs . put ( TEXT , plainText ? Boolean . TRUE : Boolean . FALSE ) ; this . plainText = plainText ; } public void setOnetable ( boolean oneTable ) { optionalAttrs . put ( ONE_TABLE , oneTable ? Boolean . TRUE : Boolean . FALSE ) ; } public void setOutputfile ( String outputFile ) { this . outputFile = outputFile ; } public void setTarget ( File target ) { this . targetFile = target ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JJDoc ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputFile != null ) { cmdl . createArgument ( ) . setValue ( "-" + OUTPUT_FILE + ":" + outputFile . replace ( '\\' , '/' ) ) ; } File javaFile = new File ( createOutputFileName ( targetFile , outputFile , plainText ) ) ; if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JJDOC ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; final Execute process = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_INFO ) , null ) ; log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; process . setCommandline ( cmdl . getCommandline ( ) ) ; try { if ( process . execute ( ) != 0 ) { throw new BuildException ( "JJDoc failed." ) ; } } catch ( IOException e ) { throw new BuildException ( "Failed to launch JJDoc" , e ) ; } } private String createOutputFileName ( File destFile , String optionalOutputFile , boolean plain ) { String suffix = DEFAULT_SUFFIX_HTML ; String javaccFile = destFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( plain ) { suffix = DEFAULT_SUFFIX_TEXT ; } if ( ( optionalOutputFile == null ) || optionalOutputFile . equals ( "" ) ) { int filePos = javaccFile . lastIndexOf ( "/" ) ; if ( filePos >= 0 ) { javaccFile = javaccFile . substring ( filePos + 1 ) ; } int suffixPos = javaccFile . lastIndexOf ( '.' ) ; if ( suffixPos == - 1 ) { optionalOutputFile = javaccFile + suffix ; } else { String currentSuffix = javaccFile . substring ( suffixPos ) ; if ( currentSuffix . equals ( suffix ) ) { optionalOutputFile = javaccFile + suffix ; } else { optionalOutputFile = javaccFile . substring ( 0 , suffixPos ) + suffix ; } } } else { optionalOutputFile = optionalOutputFile . replace ( '\\' , '/' ) ; } return ( getProject ( ) . getBaseDir ( ) + "/" + optionalOutputFile ) . replace ( '\\' , '/' ) ; } } 	0	['8', '3', '0', '13', '57', '4', '0', '13', '7', '0.909090909', '377', '1', '1', '0.840909091', '0.5', '1', '1', '44.75', '7', '1.875', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0	['7', '1', '0', '2', '7', '21', '2', '0', '7', '2', '7', '0', '0', '0', '0.642857143', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class TarFileSet extends ArchiveFileSet { private boolean userNameSet ; private boolean groupNameSet ; private boolean userIdSet ; private boolean groupIdSet ; private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarFileSet ( ) { super ( ) ; } protected TarFileSet ( FileSet fileset ) { super ( fileset ) ; } protected TarFileSet ( TarFileSet fileset ) { super ( fileset ) ; } public void setUserName ( String userName ) { checkTarFileSetAttributesAllowed ( ) ; userNameSet = true ; this . userName = userName ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public boolean hasUserNameBeenSet ( ) { return userNameSet ; } public void setUid ( int uid ) { checkTarFileSetAttributesAllowed ( ) ; userIdSet = true ; this . uid = uid ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public boolean hasUserIdBeenSet ( ) { return userIdSet ; } public void setGroup ( String groupName ) { checkTarFileSetAttributesAllowed ( ) ; groupNameSet = true ; this . groupName = groupName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public boolean hasGroupBeenSet ( ) { return groupNameSet ; } public void setGid ( int gid ) { checkTarFileSetAttributesAllowed ( ) ; groupIdSet = true ; this . gid = gid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGid ( ) ; } return gid ; } public boolean hasGroupIdBeenSet ( ) { return groupIdSet ; } protected ArchiveScanner newArchiveScanner ( ) { TarScanner zs = new TarScanner ( ) ; return zs ; } public void setRefid ( Reference r ) throws BuildException { if ( userNameSet || userIdSet || groupNameSet || groupIdSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected AbstractFileSet getRef ( Project p ) { dieOnCircularReference ( p ) ; Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof TarFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { TarFileSet zfs = new TarFileSet ( ( FileSet ) o ) ; configureFileSet ( zfs ) ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a tarfileset or a fileset" ; throw new BuildException ( msg ) ; } } protected void configureFileSet ( ArchiveFileSet zfs ) { super . configureFileSet ( zfs ) ; if ( zfs instanceof TarFileSet ) { TarFileSet tfs = ( TarFileSet ) zfs ; tfs . setUserName ( userName ) ; tfs . setGroup ( groupName ) ; tfs . setUid ( uid ) ; tfs . setGid ( gid ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } private void checkTarFileSetAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof TarFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	0	['21', '6', '1', '10', '42', '126', '2', '8', '15', '0.7875', '274', '1', '0', '0.871428571', '0.178571429', '5', '19', '11.66666667', '4', '1.381', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; public class JonasDeploymentTool extends GenericDeploymentTool { protected static final String EJB_JAR_1_1_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; protected static final String EJB_JAR_2_0_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String JONAS_EJB_JAR_2_4_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.4//EN" ; protected static final String JONAS_EJB_JAR_2_5_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.5//EN" ; protected static final String RMI_ORB = "RMI" ; protected static final String JEREMIE_ORB = "JEREMIE" ; protected static final String DAVID_ORB = "DAVID" ; protected static final String EJB_JAR_1_1_DTD = "ejb-jar_1_1.dtd" ; protected static final String EJB_JAR_2_0_DTD = "ejb-jar_2_0.dtd" ; protected static final String JONAS_EJB_JAR_2_4_DTD = "jonas-ejb-jar_2_4.dtd" ; protected static final String JONAS_EJB_JAR_2_5_DTD = "jonas-ejb-jar_2_5.dtd" ; protected static final String JONAS_DD = "jonas-ejb-jar.xml" ; protected static final String GENIC_CLASS = "org.objectweb.jonas_ejb.genic.GenIC" ; protected static final String OLD_GENIC_CLASS_1 = "org.objectweb.jonas_ejb.tools.GenWholeIC" ; protected static final String OLD_GENIC_CLASS_2 = "org.objectweb.jonas_ejb.tools.GenIC" ; private String descriptorName ; private String jonasDescriptorName ; private File outputdir ; private boolean keepgenerated = false ; private boolean nocompil = false ; private boolean novalidation = false ; private String javac ; private String javacopts ; private String rmicopts ; private boolean secpropag = false ; private boolean verbose = false ; private String additionalargs ; private File jonasroot ; private boolean keepgeneric = false ; private String suffix = ".jar" ; private String orb ; private boolean nogenic = false ; public void setKeepgenerated ( boolean aBoolean ) { keepgenerated = aBoolean ; } public void setAdditionalargs ( String aString ) { additionalargs = aString ; } public void setNocompil ( boolean aBoolean ) { nocompil = aBoolean ; } public void setNovalidation ( boolean aBoolean ) { novalidation = aBoolean ; } public void setJavac ( String aString ) { javac = aString ; } public void setJavacopts ( String aString ) { javacopts = aString ; } public void setRmicopts ( String aString ) { rmicopts = aString ; } public void setSecpropag ( boolean aBoolean ) { secpropag = aBoolean ; } public void setVerbose ( boolean aBoolean ) { verbose = aBoolean ; } public void setJonasroot ( File aFile ) { jonasroot = aFile ; } public void setKeepgeneric ( boolean aBoolean ) { keepgeneric = aBoolean ; } public void setJarsuffix ( String aString ) { suffix = aString ; } public void setOrb ( String aString ) { orb = aString ; } public void setNogenic ( boolean aBoolean ) { nogenic = aBoolean ; } public void processDescriptor ( String aDescriptorName , SAXParser saxParser ) { descriptorName = aDescriptorName ; log ( "JOnAS Deployment Tool processing: " + descriptorName , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; if ( outputdir != null ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; } } protected void writeJar ( String baseName , File jarfile , Hashtable ejbFiles , String publicId ) throws BuildException { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , ejbFiles , publicId ) ; addGenICGeneratedFiles ( genericJarFile , ejbFiles ) ; super . writeJar ( baseName , getVendorOutputJarFile ( baseName ) , ejbFiles , publicId ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { jonasDescriptorName = getJonasDescriptorName ( ) ; File jonasDD = new File ( getConfig ( ) . descriptorDir , jonasDescriptorName ) ; if ( jonasDD . exists ( ) ) { ejbFiles . put ( META_DIR + JONAS_DD , jonasDD ) ; } else { log ( "Unable to locate the JOnAS deployment descriptor. It was expected to be in: " + jonasDD . getPath ( ) + "." , Project . MSG_WARN ) ; } } protected File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + suffix ) ; } private String getJonasDescriptorName ( ) { String jonasDN ; boolean jonasConvention = false ; String path ; String fileName ; String baseName ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; fileName = descriptorName . substring ( startOfFileName + 1 ) ; } else { path = "" ; fileName = descriptorName ; } if ( fileName . startsWith ( EJB_DD ) ) { return path + JONAS_DD ; } int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } jonasConvention = true ; } baseName = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; if ( jonasConvention ) { jonasDN = path + "jonas-" + baseName + ".xml" ; } else { jonasDN = path + baseName + "jonas-" + remainder ; } log ( "Standard EJB descriptor name: " + descriptorName , Project . MSG_VERBOSE ) ; log ( "JOnAS-specific descriptor name: " + jonasDN , Project . MSG_VERBOSE ) ; return jonasDN ; } protected String getJarBaseName ( String descriptorFileName ) { String baseName = null ; if ( getConfig ( ) . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { if ( descriptorFileName . indexOf ( getConfig ( ) . baseNameTerminator ) == - 1 ) { String aCanonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int lastSeparatorIndex = aCanonicalDescriptor . lastIndexOf ( '/' ) ; int endOfBaseName ; if ( lastSeparatorIndex != - 1 ) { endOfBaseName = descriptorFileName . indexOf ( ".xml" , lastSeparatorIndex ) ; } else { endOfBaseName = descriptorFileName . indexOf ( ".xml" ) ; } if ( endOfBaseName != - 1 ) { baseName = descriptorFileName . substring ( 0 , endOfBaseName ) ; } } } if ( baseName == null ) { baseName = super . getJarBaseName ( descriptorFileName ) ; } log ( "JAR base name: " + baseName , Project . MSG_VERBOSE ) ; return baseName ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { handler . registerDTD ( EJB_JAR_1_1_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_1_1_DTD ) ; handler . registerDTD ( EJB_JAR_2_0_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_2_0_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_4_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_4_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_5_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_5_DTD ) ; } private void addGenICGeneratedFiles ( File genericJarFile , Hashtable ejbFiles ) { Java genicTask = null ; String genicClass = null ; if ( nogenic ) { return ; } genicTask = new Java ( getTask ( ) ) ; genicTask . setTaskName ( "genic" ) ; genicTask . setFork ( true ) ; genicTask . createJvmarg ( ) . setValue ( "-Dinstall.root=" + jonasroot ) ; String jonasConfigDir = jonasroot + File . separator + "config" ; File javaPolicyFile = new File ( jonasConfigDir , "java.policy" ) ; if ( javaPolicyFile . exists ( ) ) { genicTask . createJvmarg ( ) . setValue ( "-Djava.security.policy=" + javaPolicyFile . toString ( ) ) ; } try { outputdir = createTempDir ( ) ; } catch ( IOException aIOException ) { String msg = "Cannot create temp dir: " + aIOException . getMessage ( ) ; throw new BuildException ( msg , aIOException ) ; } log ( "Using temporary output directory: " + outputdir , Project . MSG_VERBOSE ) ; genicTask . createArg ( ) . setValue ( "-d" ) ; genicTask . createArg ( ) . setFile ( outputdir ) ; String key ; File f ; Enumeration keys = ejbFiles . keys ( ) ; while ( keys . hasMoreElements ( ) ) { key = ( String ) keys . nextElement ( ) ; f = new File ( outputdir + File . separator + key ) ; f . getParentFile ( ) . mkdirs ( ) ; } log ( "Worked around a bug of GenIC 2.5." , Project . MSG_VERBOSE ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath == null ) { classpath = new Path ( getTask ( ) . getProject ( ) ) ; } classpath . append ( new Path ( classpath . getProject ( ) , jonasConfigDir ) ) ; classpath . append ( new Path ( classpath . getProject ( ) , outputdir . toString ( ) ) ) ; if ( orb != null ) { String orbJar = jonasroot + File . separator + "lib" + File . separator + orb + "_jonas.jar" ; classpath . append ( new Path ( classpath . getProject ( ) , orbJar ) ) ; } log ( "Using classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; genicTask . setClasspath ( classpath ) ; genicClass = getGenicClassName ( classpath ) ; if ( genicClass == null ) { log ( "Cannot find GenIC class in classpath." , Project . MSG_ERR ) ; throw new BuildException ( "GenIC class not found, please check the classpath." ) ; } else { log ( "Using '" + genicClass + "' GenIC class." , Project . MSG_VERBOSE ) ; genicTask . setClassname ( genicClass ) ; } if ( keepgenerated ) { genicTask . createArg ( ) . setValue ( "-keepgenerated" ) ; } if ( nocompil ) { genicTask . createArg ( ) . setValue ( "-nocompil" ) ; } if ( novalidation ) { genicTask . createArg ( ) . setValue ( "-novalidation" ) ; } if ( javac != null ) { genicTask . createArg ( ) . setValue ( "-javac" ) ; genicTask . createArg ( ) . setLine ( javac ) ; } if ( javacopts != null && ! javacopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-javacopts" ) ; genicTask . createArg ( ) . setLine ( javacopts ) ; } if ( rmicopts != null && ! rmicopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-rmicopts" ) ; genicTask . createArg ( ) . setLine ( rmicopts ) ; } if ( secpropag ) { genicTask . createArg ( ) . setValue ( "-secpropag" ) ; } if ( verbose ) { genicTask . createArg ( ) . setValue ( "-verbose" ) ; } if ( additionalargs != null ) { genicTask . createArg ( ) . setValue ( additionalargs ) ; } genicTask . createArg ( ) . setValue ( "-noaddinjar" ) ; genicTask . createArg ( ) . setValue ( genericJarFile . getPath ( ) ) ; log ( "Calling " + genicClass + " for " + getConfig ( ) . descriptorDir + File . separator + descriptorName + "." , Project . MSG_VERBOSE ) ; if ( genicTask . executeJava ( ) != 0 ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } throw new BuildException ( "GenIC reported an error." ) ; } addAllFiles ( outputdir , "" , ejbFiles ) ; } String getGenicClassName ( Path classpath ) { log ( "Looking for GenIC class in classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; AntClassLoader cl = classpath . getProject ( ) . createClassLoader ( classpath ) ; try { cl . loadClass ( JonasDeploymentTool . GENIC_CLASS ) ; log ( "Found GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . GENIC_CLASS ; } catch ( ClassNotFoundException cnf1 ) { log ( "GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_1 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_1 ; } catch ( ClassNotFoundException cnf2 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_2 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_2 ; } catch ( ClassNotFoundException cnf3 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } return null ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { if ( jonasroot == null ) { throw new BuildException ( "The jonasroot attribut is not set." ) ; } else if ( ! jonasroot . isDirectory ( ) ) { throw new BuildException ( "The jonasroot attribut '" + jonasroot + "' is not a valid directory." ) ; } if ( orb != null && ! orb . equals ( RMI_ORB ) && ! orb . equals ( JEREMIE_ORB ) && ! orb . equals ( DAVID_ORB ) ) { throw new BuildException ( "The orb attribut '" + orb + "' is not valid (must be either " + RMI_ORB + ", " + JEREMIE_ORB + " or " + DAVID_ORB + ")." ) ; } if ( additionalargs != null && additionalargs . equals ( "" ) ) { throw new BuildException ( "Empty additionalargs attribut." ) ; } if ( javac != null && javac . equals ( "" ) ) { throw new BuildException ( "Empty javac attribut." ) ; } } private File createTempDir ( ) throws IOException { File tmpDir = File . createTempFile ( "genic" , null , null ) ; tmpDir . delete ( ) ; if ( ! tmpDir . mkdir ( ) ) { throw new IOException ( "Cannot create the temporary directory '" + tmpDir + "'." ) ; } return tmpDir ; } private void deleteAllFiles ( File aFile ) { if ( aFile . isDirectory ( ) ) { File [ ] someFiles = aFile . listFiles ( ) ; for ( int i = 0 ; i < someFiles . length ; i ++ ) { deleteAllFiles ( someFiles [ i ] ) ; } } aFile . delete ( ) ; } private void addAllFiles ( File file , String rootDir , Hashtable hashtable ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( ) ; } String newRootDir ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( rootDir . length ( ) > 0 ) { newRootDir = rootDir + File . separator + files [ i ] . getName ( ) ; } else { newRootDir = files [ i ] . getName ( ) ; } addAllFiles ( files [ i ] , newRootDir , hashtable ) ; } } else { hashtable . put ( rootDir , file ) ; } } } 	0	['28', '2', '0', '12', '97', '302', '1', '11', '16', '0.962962963', '1230', '1', '0', '0.542372881', '0.272321429', '2', '8', '41.78571429', '20', '2.2857', '0']
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; long MAXSIZE = 077777777777L ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '25', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "sj" : exec ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected String getNoDebugArgument ( ) { return null ; } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '2', '2', '44', '0', '0', '0.92', '1', '1', '1', '13.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Delete extends P4Base { public String change = null ; public void setChange ( String change ) { this . change = change ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( P4View == null ) { throw new BuildException ( "No view specified to delete" ) ; } execP4Command ( "-s delete " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '10', '0', '0', '4', '3', '0', '55', '0', '0', '0.962264151', '0.666666667', '1', '1', '17', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import java . util . Collections ; import java . util . Iterator ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . CollectionUtils ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class EchoProperties extends Task { private static final String PROPERTIES = "properties" ; private static final String PROPERTY = "property" ; private static final String ATTR_NAME = "name" ; private static final String ATTR_VALUE = "value" ; private File inFile = null ; private File destfile = null ; private boolean failonerror = true ; private Vector propertySets = new Vector ( ) ; private String format = "text" ; private String prefix ; private String regex ; public void setSrcfile ( File file ) { inFile = file ; } public void setDestfile ( File destfile ) { this . destfile = destfile ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setPrefix ( String prefix ) { if ( prefix != null && prefix . length ( ) != 0 ) { this . prefix = prefix ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendPrefix ( prefix ) ; addPropertyset ( ps ) ; } } public void setRegex ( String regex ) { if ( regex != null && regex . length ( ) != 0 ) { this . regex = regex ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendRegex ( regex ) ; addPropertyset ( ps ) ; } } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void setFormat ( FormatAttribute ea ) { format = ea . getValue ( ) ; } public static class FormatAttribute extends EnumeratedAttribute { private String [ ] formats = new String [ ] { "xml" , "text" } ; public String [ ] getValues ( ) { return formats ; } } public void execute ( ) throws BuildException { if ( prefix != null && regex != null ) { throw new BuildException ( "Please specify either prefix" + " or regex, but not both" , getLocation ( ) ) ; } Hashtable allProps = new Hashtable ( ) ; if ( inFile == null && propertySets . size ( ) == 0 ) { allProps . putAll ( getProject ( ) . getProperties ( ) ) ; } else if ( inFile != null ) { if ( inFile . exists ( ) && inFile . isDirectory ( ) ) { String message = "srcfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( inFile . exists ( ) && ! inFile . canRead ( ) ) { String message = "Can not read from the specified srcfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } FileInputStream in = null ; try { in = new FileInputStream ( inFile ) ; Properties props = new Properties ( ) ; props . load ( in ) ; allProps . putAll ( props ) ; } catch ( FileNotFoundException fnfe ) { String message = "Could not find file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , fnfe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } catch ( IOException ioe ) { String message = "Could not read file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } finally { FileUtils . close ( in ) ; } } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; allProps . putAll ( ps . getProperties ( ) ) ; } OutputStream os = null ; try { if ( destfile == null ) { os = new ByteArrayOutputStream ( ) ; saveProperties ( allProps , os ) ; log ( os . toString ( ) , Project . MSG_INFO ) ; } else { if ( destfile . exists ( ) && destfile . isDirectory ( ) ) { String message = "destfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( destfile . exists ( ) && ! destfile . canWrite ( ) ) { String message = "Can not write to the specified destfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } os = new FileOutputStream ( this . destfile ) ; saveProperties ( allProps , os ) ; } } catch ( IOException ioe ) { if ( failonerror ) { throw new BuildException ( ioe , getLocation ( ) ) ; } else { log ( ioe . getMessage ( ) , Project . MSG_INFO ) ; } } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ex ) { } } } } protected void saveProperties ( Hashtable allProps , OutputStream os ) throws IOException , BuildException { final List keyList = new ArrayList ( allProps . keySet ( ) ) ; Collections . sort ( keyList ) ; Properties props = new Properties ( ) { public Enumeration keys ( ) { return CollectionUtils . asEnumeration ( keyList . iterator ( ) ) ; } public Set entrySet ( ) { Set result = super . entrySet ( ) ; if ( JavaEnvUtils . isKaffe ( ) ) { TreeSet t = new TreeSet ( new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { String key1 = ( String ) ( ( Map . Entry ) o1 ) . getKey ( ) ; String key2 = ( String ) ( ( Map . Entry ) o2 ) . getKey ( ) ; return key1 . compareTo ( key2 ) ; } } ) ; t . addAll ( result ) ; result = t ; } return result ; } } ; for ( int i = 0 ; i < keyList . size ( ) ; i ++ ) { String name = keyList . get ( i ) . toString ( ) ; String value = allProps . get ( name ) . toString ( ) ; props . setProperty ( name , value ) ; } if ( "text" . equals ( format ) ) { jdkSaveProperties ( props , os , "Ant properties" ) ; } else if ( "xml" . equals ( format ) ) { xmlSaveProperties ( props , os ) ; } } private static class Tuple implements Comparable { private String key ; private String value ; private Tuple ( String key , String value ) { this . key = key ; this . value = value ; } public int compareTo ( Object o ) { Tuple that = ( Tuple ) o ; return key . compareTo ( that . key ) ; } } private List sortProperties ( Properties props ) { List sorted = new ArrayList ( props . size ( ) ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; sorted . add ( new Tuple ( name , props . getProperty ( name ) ) ) ; } Collections . sort ( sorted ) ; return sorted ; } protected void xmlSaveProperties ( Properties props , OutputStream os ) throws IOException { Document doc = getDocumentBuilder ( ) . newDocument ( ) ; Element rootElement = doc . createElement ( PROPERTIES ) ; List sorted = sortProperties ( props ) ; Iterator iten = sorted . iterator ( ) ; while ( iten . hasNext ( ) ) { Tuple tuple = ( Tuple ) iten . next ( ) ; Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , tuple . key ) ; propElement . setAttribute ( ATTR_VALUE , tuple . value ) ; rootElement . appendChild ( propElement ) ; } Writer wri = null ; try { wri = new OutputStreamWriter ( os , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , 0 , "\t" ) ; wri . flush ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Unable to write XML file" , ioe ) ; } finally { FileUtils . close ( wri ) ; } } protected void jdkSaveProperties ( Properties props , OutputStream os , String header ) throws IOException { try { props . store ( os , header ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ioex ) { log ( "Failed to close output stream" ) ; } } } } private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception e ) { throw new ExceptionInInitializerError ( e ) ; } } } 	0	['14', '3', '0', '10', '90', '63', '1', '10', '9', '0.923076923', '615', '1', '0', '0.74', '0.222222222', '1', '1', '42.14285714', '3', '1.2857', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Http extends ProjectComponent implements Condition { private static final int ERROR_BEGINS = 400 ; private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = ERROR_BEGINS ; public void setErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } return false ; } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	0	['4', '2', '0', '4', '15', '0', '1', '3', '4', '0.666666667', '105', '1', '0', '0.75', '0.5', '0', '0', '24.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class Rename extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( ! replace && dest . exists ( ) ) { throw new BuildException ( dest + " already exists." ) ; } try { FILE_UTILS . rename ( src , dest ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename " + src + " to " + dest , e , getLocation ( ) ) ; } } } 	0	['6', '3', '0', '5', '21', '3', '0', '5', '5', '0.75', '104', '1', '1', '0.902439024', '0.533333333', '1', '1', '15.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; public interface ClassFileIterator { ClassFile getNextClassFile ( ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Random ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { String tempFileName = "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; tmpFile = new File ( tempFileName ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { FileUtils . close ( out ) ; } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '6', '30', '0', '0', '6', '0', '0', '182', '1', '2', '0', '0.6', '0', '0', '88.5', '9', '4.5', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public abstract class ConstantPoolEntry { public static final int CONSTANT_UTF8 = 1 ; public static final int CONSTANT_INTEGER = 3 ; public static final int CONSTANT_FLOAT = 4 ; public static final int CONSTANT_LONG = 5 ; public static final int CONSTANT_DOUBLE = 6 ; public static final int CONSTANT_CLASS = 7 ; public static final int CONSTANT_STRING = 8 ; public static final int CONSTANT_FIELDREF = 9 ; public static final int CONSTANT_METHODREF = 10 ; public static final int CONSTANT_INTERFACEMETHODREF = 11 ; public static final int CONSTANT_NAMEANDTYPE = 12 ; private int tag ; private int numEntries ; private boolean resolved ; public ConstantPoolEntry ( int tagValue , int entries ) { tag = tagValue ; numEntries = entries ; resolved = false ; } public static ConstantPoolEntry readEntry ( DataInputStream cpStream ) throws IOException { ConstantPoolEntry cpInfo = null ; int cpTag = cpStream . readUnsignedByte ( ) ; switch ( cpTag ) { case CONSTANT_UTF8 : cpInfo = new Utf8CPInfo ( ) ; break ; case CONSTANT_INTEGER : cpInfo = new IntegerCPInfo ( ) ; break ; case CONSTANT_FLOAT : cpInfo = new FloatCPInfo ( ) ; break ; case CONSTANT_LONG : cpInfo = new LongCPInfo ( ) ; break ; case CONSTANT_DOUBLE : cpInfo = new DoubleCPInfo ( ) ; break ; case CONSTANT_CLASS : cpInfo = new ClassCPInfo ( ) ; break ; case CONSTANT_STRING : cpInfo = new StringCPInfo ( ) ; break ; case CONSTANT_FIELDREF : cpInfo = new FieldRefCPInfo ( ) ; break ; case CONSTANT_METHODREF : cpInfo = new MethodRefCPInfo ( ) ; break ; case CONSTANT_INTERFACEMETHODREF : cpInfo = new InterfaceMethodRefCPInfo ( ) ; break ; case CONSTANT_NAMEANDTYPE : cpInfo = new NameAndTypeCPInfo ( ) ; break ; default : throw new ClassFormatError ( "Invalid Constant Pool entry Type " + cpTag ) ; } cpInfo . read ( cpStream ) ; return cpInfo ; } public boolean isResolved ( ) { return resolved ; } public void resolve ( ConstantPool constantPool ) { resolved = true ; } public abstract void read ( DataInputStream cpStream ) throws IOException ; public int getTag ( ) { return tag ; } public final int getNumEntries ( ) { return numEntries ; } } 	0	['7', '1', '7', '14', '24', '11', '10', '12', '7', '1.083333333', '124', '0.214285714', '0', '0', '0.357142857', '0', '0', '14.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; public class P4OutputStream extends OutputStream { private P4Handler handler ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; public P4OutputStream ( P4Handler handler ) { this . handler = handler ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { handler . process ( buffer . toString ( ) ) ; buffer . reset ( ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } } 	0	['4', '2', '0', '2', '12', '0', '1', '1', '3', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; public class Matches extends ProjectComponent implements Condition { private String string ; private boolean caseSensitive = true ; private boolean multiLine = false ; private boolean singleLine = false ; private RegularExpression regularExpression ; public void setString ( String string ) { this . string = string ; } public void setPattern ( String pattern ) { if ( regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( pattern ) ; } public void addRegexp ( RegularExpression regularExpression ) { if ( this . regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } this . regularExpression = regularExpression ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public void setMultiline ( boolean b ) { multiLine = b ; } public void setSingleLine ( boolean b ) { singleLine = b ; } public boolean eval ( ) throws BuildException { if ( string == null ) { throw new BuildException ( "Parameter string is required in matches." ) ; } if ( regularExpression == null ) { throw new BuildException ( "Missing pattern in matches." ) ; } int options = RegexpMatcher . MATCH_DEFAULT ; if ( ! caseSensitive ) { options = options | RegexpMatcher . MATCH_CASE_INSENSITIVE ; } if ( multiLine ) { options = options | RegexpMatcher . MATCH_MULTILINE ; } if ( singleLine ) { options = options | RegexpMatcher . MATCH_SINGLELINE ; } Regexp regexp = regularExpression . getRegexp ( getProject ( ) ) ; return regexp . matches ( string , options ) ; } } 	0	['8', '2', '0', '6', '15', '6', '0', '6', '8', '0.742857143', '122', '1', '1', '0.5625', '0.4375', '0', '0', '13.625', '2', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( getProject ( ) . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not " + "found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , getLocation ( ) ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , getLocation ( ) ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = getProject ( ) . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private static final int SLEEP_TIME = 5 ; public StreamPumper ( InputStream is , int messageLevel ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; } public void pumpStream ( ) throws IOException { if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '5', '45', '21', '1', '5', '7', '0.740740741', '359', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . taskdefs . optional . jsp . JspMangler ; public interface JspCompilerAdapter { void setJspc ( JspC attributes ) ; boolean execute ( ) throws BuildException ; JspMangler createMangler ( ) ; boolean implementsOwnDependencyChecking ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '3', '3', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task task ; public TaskLogger ( final Task task ) { this . task = task ; } public void info ( final String message ) { task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . NumberFormat ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class BriefJUnitResultFormatter implements JUnitResultFormatter { private OutputStream out ; private PrintWriter output ; private StringWriter results ; private PrintWriter resultWriter ; private NumberFormat numberFormat = NumberFormat . getInstance ( ) ; private String systemOutput = null ; private String systemError = null ; public BriefJUnitResultFormatter ( ) { results = new StringWriter ( ) ; resultWriter = new PrintWriter ( results ) ; } public void setOutput ( OutputStream out ) { this . out = out ; output = new PrintWriter ( out ) ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void startTestSuite ( JUnitTest suite ) { if ( output == null ) { return ; } StringBuffer sb = new StringBuffer ( "Testsuite: " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( StringUtils . LINE_SEP ) ; output . write ( sb . toString ( ) ) ; output . flush ( ) ; } public void endTestSuite ( JUnitTest suite ) { StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( numberFormat . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( StringUtils . LINE_SEP ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "------------- Standard Output ---------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemOutput ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "------------- Standard Error -----------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemError ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( output != null ) { try { output . write ( sb . toString ( ) ) ; resultWriter . close ( ) ; output . write ( results . toString ( ) ) ; output . flush ( ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( out ) ; } } } } public void startTest ( Test test ) { } public void endTest ( Test test ) { } public void addFailure ( Test test , Throwable t ) { formatError ( "\tFAILED" , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable error ) { formatError ( "\tCaused an ERROR" , test , error ) ; } protected String formatTest ( Test test ) { if ( test == null ) { return "Null Test: " ; } else { return "Testcase: " + test . toString ( ) + ":" ; } } protected synchronized void formatError ( String type , Test test , Throwable error ) { if ( test != null ) { endTest ( test ) ; } resultWriter . println ( formatTest ( test ) + type ) ; resultWriter . println ( error . getMessage ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( error ) ; resultWriter . println ( strace ) ; resultWriter . println ( ) ; } } 	0	['13', '1', '0', '7', '40', '58', '0', '7', '11', '0.833333333', '292', '1', '0', '0', '0.32967033', '0', '0', '20.92307692', '10', '1.8462', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilesMatch implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file1 , file2 ; private boolean textfile = false ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public void setTextfile ( boolean textfile ) { this . textfile = textfile ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = FILE_UTILS . contentEquals ( file1 , file2 , textfile ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0	['6', '1', '0', '4', '15', '3', '1', '3', '5', '0.75', '70', '1', '1', '0', '0.533333333', '0', '0', '10', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCRmtype extends ClearCase { private String mTypeKind = null ; private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; private boolean mRmall = false ; private boolean mIgnore = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; if ( getTypeKind ( ) == null ) { throw new BuildException ( "Required attribute TypeKind not specified" ) ; } if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_RMTYPE ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getTypeSpecifier ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getIgnore ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IGNORE ) ; } if ( getRmAll ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RMALL ) ; cmd . createArgument ( ) . setValue ( FLAG_FORCE ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getTypeSpecifier ( ) ) ; } public void setIgnore ( boolean ignore ) { mIgnore = ignore ; } public boolean getIgnore ( ) { return mIgnore ; } public void setRmAll ( boolean rmall ) { mRmall = rmall ; } public boolean getRmAll ( ) { return mRmall ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeKind ( String tk ) { mTypeKind = tk ; } public String getTypeKind ( ) { return mTypeKind ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } private String getTypeSpecifier ( ) { String tkind = getTypeKind ( ) ; String tname = getTypeName ( ) ; String typeSpec = null ; typeSpec = tkind + ":" + tname ; if ( getVOB ( ) != null ) { typeSpec += "@" + getVOB ( ) ; } return typeSpec ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_IGNORE = "-ignore" ; public static final String FLAG_RMALL = "-rmall" ; public static final String FLAG_FORCE = "-force" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['20', '4', '0', '7', '39', '148', '0', '7', '16', '0.923076923', '285', '0.538461538', '0', '0.71641791', '0.375', '2', '2', '12.6', '5', '1.3', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapter ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapterFactory ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . util . facade . ImplementationSpecificArgument ; public class Javah extends Task { private Vector classes = new Vector ( 2 ) ; private String cls ; private File destDir ; private Path classpath = null ; private File outputFile = null ; private boolean verbose = false ; private boolean force = false ; private boolean old = false ; private boolean stubs = false ; private Path bootclasspath ; private static String lSep = System . getProperty ( "line.separator" ) ; private FacadeTaskHelper facade = null ; public Javah ( ) { facade = new FacadeTaskHelper ( JavahAdapterFactory . getDefault ( ) ) ; } public void setClass ( String cls ) { this . cls = cls ; } public ClassArgument createClass ( ) { ClassArgument ga = new ClassArgument ( ) ; classes . addElement ( ga ) ; return ga ; } public class ClassArgument { private String name ; public ClassArgument ( ) { } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public String [ ] getClasses ( ) { ArrayList al = new ArrayList ( ) ; if ( cls != null ) { StringTokenizer tok = new StringTokenizer ( cls , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { al . add ( tok . nextToken ( ) . trim ( ) ) ; } } Enumeration e = classes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ClassArgument arg = ( ClassArgument ) e . nextElement ( ) ; al . add ( arg . getName ( ) ) ; } return ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } public File getOutputfile ( ) { return outputFile ; } public void setForce ( boolean force ) { this . force = force ; } public boolean getForce ( ) { return force ; } public void setOld ( boolean old ) { this . old = old ; } public boolean getOld ( ) { return old ; } public void setStubs ( boolean stubs ) { this . stubs = stubs ; } public boolean getStubs ( ) { return stubs ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setImplementation ( String impl ) { if ( "default" . equals ( impl ) ) { facade . setImplementation ( JavahAdapterFactory . getDefault ( ) ) ; } else { facade . setImplementation ( impl ) ; } } public ImplementationSpecificArgument createArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentArgs ( ) { return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( ( cls == null ) && ( classes . size ( ) == 0 ) ) { throw new BuildException ( "class attribute must be set!" , getLocation ( ) ) ; } if ( ( cls != null ) && ( classes . size ( ) > 0 ) ) { throw new BuildException ( "set class attribute or class element, " + "not both." , getLocation ( ) ) ; } if ( destDir != null ) { if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , getLocation ( ) ) ; } if ( outputFile != null ) { throw new BuildException ( "destdir and outputFile are mutually " + "exclusive" , getLocation ( ) ) ; } } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } JavahAdapter ad = JavahAdapterFactory . getAdapter ( facade . getImplementation ( ) , this ) ; if ( ! ad . compile ( this ) ) { throw new BuildException ( "compilation failed" ) ; } } public void logAndAddFiles ( Commandline cmd ) { logAndAddFilesToCompile ( cmd ) ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceClassList = new StringBuffer ( ) ; String [ ] c = getClasses ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { cmd . createArgument ( ) . setValue ( c [ i ] ) ; niceClassList . append ( "    " ) ; niceClassList . append ( c [ i ] ) ; niceClassList . append ( lSep ) ; } StringBuffer prefix = new StringBuffer ( "Class" ) ; if ( c . length > 1 ) { prefix . append ( "es" ) ; } prefix . append ( " to be compiled:" ) ; prefix . append ( lSep ) ; log ( prefix . toString ( ) + niceClassList . toString ( ) , Project . MSG_VERBOSE ) ; } } 	0	['31', '3', '0', '16', '79', '365', '4', '14', '29', '0.905555556', '466', '1', '3', '0.560606061', '0.20952381', '0', '0', '13.64516129', '4', '1.2581', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . types . resources . FileResource ; public class LoadFile extends LoadResource { public final void setSrcFile ( final File srcFile ) { addConfigured ( new FileResource ( srcFile ) ) ; } } 	0	['2', '4', '0', '3', '5', '1', '0', '3', '2', '2', '12', '0', '0', '0.977777778', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . Method ; import java . lang . reflect . Field ; public class HasMethod extends ProjectComponent implements Condition { private String classname ; private String method ; private String field ; private Path classpath ; private AntClassLoader loader ; private boolean ignoreSystemClasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setMethod ( String method ) { this . method = method ; } public void setField ( String field ) { this . field = field ; } public void setIgnoreSystemClasses ( boolean ignoreSystemClasses ) { this . ignoreSystemClasses = ignoreSystemClasses ; } private Class loadClass ( String classname ) { try { if ( ignoreSystemClasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { return loader . findClass ( classname ) ; } catch ( SecurityException se ) { return null ; } } else { return null ; } } else if ( loader != null ) { return loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { return Class . forName ( classname , true , l ) ; } else { return Class . forName ( classname ) ; } } } catch ( ClassNotFoundException e ) { throw new BuildException ( "class \"" + classname + "\" was not found" ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" ) ; } } public boolean eval ( ) throws BuildException { if ( classname == null ) { throw new BuildException ( "No classname defined" ) ; } Class clazz = loadClass ( classname ) ; if ( method != null ) { return isMethodFound ( clazz ) ; } if ( field != null ) { return isFieldFound ( clazz ) ; } throw new BuildException ( "Neither method nor field defined" ) ; } private boolean isFieldFound ( Class clazz ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field fieldEntry = fields [ i ] ; if ( fieldEntry . getName ( ) . equals ( field ) ) { return true ; } } return false ; } private boolean isMethodFound ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method methodEntry = methods [ i ] ; if ( methodEntry . getName ( ) . equals ( method ) ) { return true ; } } return false ; } } 	0	['12', '2', '0', '7', '37', '44', '0', '7', '9', '0.803030303', '231', '1', '2', '0.45', '0.291666667', '0', '0', '17.75', '5', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import java . net . URL ; public class WhichResource extends Task { private Path classpath ; private String classname ; private String resource ; private String property ; public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } private void validate ( ) { int setcount = 0 ; if ( classname != null ) { setcount ++ ; } if ( resource != null ) { setcount ++ ; } if ( setcount == 0 ) { throw new BuildException ( "One of classname or resource must be specified" ) ; } if ( setcount > 1 ) { throw new BuildException ( "Only one of classname or resource can be specified" ) ; } if ( property == null ) { throw new BuildException ( "No property defined" ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( classpath != null ) { getProject ( ) . log ( "using user supplied classpath: " + classpath , Project . MSG_DEBUG ) ; classpath = classpath . concatSystemClasspath ( "ignore" ) ; } else { classpath = new Path ( getProject ( ) ) ; classpath = classpath . concatSystemClasspath ( "only" ) ; getProject ( ) . log ( "using system classpath: " + classpath , Project . MSG_DEBUG ) ; } AntClassLoader loader ; loader = new AntClassLoader ( getProject ( ) . getCoreLoader ( ) , getProject ( ) , classpath , false ) ; String loc = null ; if ( classname != null ) { resource = classname . replace ( '.' , '/' ) + ".class" ; } if ( resource == null ) { throw new BuildException ( "One of class or resource is required" ) ; } if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } log ( "Searching for " + resource , Project . MSG_VERBOSE ) ; URL url ; url = loader . getResource ( resource ) ; if ( url != null ) { loc = url . toExternalForm ( ) ; getProject ( ) . setNewProperty ( property , loc ) ; } } public void setResource ( String resource ) { this . resource = resource ; } public void setClass ( String classname ) { this . classname = classname ; } public void setProperty ( String property ) { this . property = property ; } } 	0	['8', '3', '0', '5', '30', '8', '0', '5', '7', '0.714285714', '214', '1', '1', '0.840909091', '0.5', '2', '2', '25.25', '6', '1.75', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . HashSet ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Difference extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rc = getResourceCollections ( ) ; int size = rc . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The difference of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } HashSet hs = new HashSet ( ) ; ArrayList al = new ArrayList ( ) ; for ( Iterator rcIter = rc . iterator ( ) ; rcIter . hasNext ( ) ; ) { for ( Iterator r = nextRC ( rcIter ) . iterator ( ) ; r . hasNext ( ) ; ) { Object next = r . next ( ) ; if ( hs . add ( next ) ) { al . add ( next ) ; } else { al . remove ( next ) ; } } } return al ; } private static ResourceCollection nextRC ( Iterator i ) { return ( ResourceCollection ) i . next ( ) ; } } 	0	['3', '4', '0', '3', '20', '3', '0', '3', '1', '2', '82', '0', '0', '0.956521739', '0.5', '1', '1', '26.33333333', '6', '2.3333', '0']
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . io . IOException ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . Clip ; import javax . sound . sampled . DataLine ; import javax . sound . sampled . Line ; import javax . sound . sampled . LineEvent ; import javax . sound . sampled . LineListener ; import javax . sound . sampled . LineUnavailableException ; import javax . sound . sampled . UnsupportedAudioFileException ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . Project ; public class AntSoundPlayer implements LineListener , BuildListener { private File fileSuccess = null ; private int loopsSuccess = 0 ; private Long durationSuccess = null ; private File fileFail = null ; private int loopsFail = 0 ; private Long durationFail = null ; public AntSoundPlayer ( ) { } public void addBuildSuccessfulSound ( File file , int loops , Long duration ) { this . fileSuccess = file ; this . loopsSuccess = loops ; this . durationSuccess = duration ; } public void addBuildFailedSound ( File fileFail , int loopsFail , Long durationFail ) { this . fileFail = fileFail ; this . loopsFail = loopsFail ; this . durationFail = durationFail ; } private void play ( Project project , File file , int loops , Long duration ) { Clip audioClip = null ; AudioInputStream audioInputStream = null ; try { audioInputStream = AudioSystem . getAudioInputStream ( file ) ; } catch ( UnsupportedAudioFileException uafe ) { project . log ( "Audio format is not yet supported: " + uafe . getMessage ( ) ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } if ( audioInputStream != null ) { AudioFormat format = audioInputStream . getFormat ( ) ; DataLine . Info info = new DataLine . Info ( Clip . class , format , AudioSystem . NOT_SPECIFIED ) ; try { audioClip = ( Clip ) AudioSystem . getLine ( info ) ; audioClip . addLineListener ( this ) ; audioClip . open ( audioInputStream ) ; } catch ( LineUnavailableException e ) { project . log ( "The sound device is currently unavailable" ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( duration != null ) { playClip ( audioClip , duration . longValue ( ) ) ; } else { playClip ( audioClip , loops ) ; } audioClip . drain ( ) ; audioClip . close ( ) ; } else { project . log ( "Can't get data from file " + file . getName ( ) ) ; } } private void playClip ( Clip clip , int loops ) { clip . loop ( loops ) ; while ( clip . isRunning ( ) ) { } } private void playClip ( Clip clip , long duration ) { clip . loop ( Clip . LOOP_CONTINUOUSLY ) ; try { Thread . sleep ( duration ) ; } catch ( InterruptedException e ) { } } public void update ( LineEvent event ) { if ( event . getType ( ) . equals ( LineEvent . Type . STOP ) ) { Line line = event . getLine ( ) ; line . close ( ) ; } else if ( event . getType ( ) . equals ( LineEvent . Type . CLOSE ) ) { } } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { if ( event . getException ( ) == null && fileSuccess != null ) { play ( event . getProject ( ) , fileSuccess , loopsSuccess , durationSuccess ) ; } else if ( event . getException ( ) != null && fileFail != null ) { play ( event . getProject ( ) , fileFail , loopsFail , durationFail ) ; } } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['14', '1', '0', '4', '43', '81', '1', '3', '11', '0.857142857', '230', '0.857142857', '0', '0', '0.285714286', '0', '0', '14.92857143', '5', '1.5714', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Commandline ; public class GenericHotDeploymentTool extends AbstractHotDeploymentTool { private Java java ; private String className ; private static final String [ ] VALID_ACTIONS = { ACTION_DEPLOY } ; public Commandline . Argument createArg ( ) { return java . createArg ( ) ; } public Commandline . Argument createJvmarg ( ) { return java . createJvmarg ( ) ; } protected boolean isActionValid ( ) { return ( getTask ( ) . getAction ( ) . equals ( VALID_ACTIONS [ 0 ] ) ) ; } public void setTask ( ServerDeploy task ) { super . setTask ( task ) ; java = new Java ( task ) ; } public void deploy ( ) throws BuildException { java . setClassname ( className ) ; java . setClasspath ( getClasspath ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; if ( className == null ) { throw new BuildException ( "The classname attribute must be set" ) ; } } public void setClassName ( String className ) { this . className = className ; } public Java getJava ( ) { return java ; } public String getClassName ( ) { return className ; } } 	0	['11', '2', '1', '8', '27', '21', '2', '7', '9', '0.733333333', '94', '1', '1', '0.608695652', '0.4', '2', '3', '7.272727273', '1', '0.8182', '0']
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0	['3', '3', '2', '8', '6', '1', '7', '1', '3', '0.5', '25', '1', '0', '0.882352941', '0.833333333', '1', '1', '7', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0	['6', '1', '0', '3', '11', '1', '1', '2', '6', '0.7', '74', '1', '0', '0', '0.555555556', '0', '0', '10.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . types ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; public class Comparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "equal" , "greater" , "less" , "ne" , "ge" , "le" , "eq" , "gt" , "lt" , "more" } ; public static final Comparison EQUAL = new Comparison ( "equal" ) ; public static final Comparison NOT_EQUAL = new Comparison ( "ne" ) ; public static final Comparison GREATER = new Comparison ( "greater" ) ; public static final Comparison LESS = new Comparison ( "less" ) ; public static final Comparison GREATER_EQUAL = new Comparison ( "ge" ) ; public static final Comparison LESS_EQUAL = new Comparison ( "le" ) ; private static final int [ ] EQUAL_INDEX = { 0 , 4 , 5 , 6 } ; private static final int [ ] LESS_INDEX = { 2 , 3 , 5 , 8 } ; private static final int [ ] GREATER_INDEX = { 1 , 3 , 4 , 7 , 9 } ; public Comparison ( ) { } public Comparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( int comparisonResult ) { if ( getIndex ( ) == - 1 ) { throw new BuildException ( "Comparison value not set." ) ; } int [ ] i = comparisonResult < 0 ? LESS_INDEX : comparisonResult > 0 ? GREATER_INDEX : EQUAL_INDEX ; return Arrays . binarySearch ( i , getIndex ( ) ) >= 0 ; } } 	0	['5', '2', '2', '9', '10', '6', '7', '2', '4', '0.9', '185', '0.4', '6', '0.8', '0.5', '1', '1', '34', '5', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import junit . framework . TestResult ; import org . apache . tools . ant . AntClassLoader ; public final class JUnitTaskMirrorImpl implements JUnitTaskMirror { private final JUnitTask task ; public JUnitTaskMirrorImpl ( JUnitTask task ) { this . task = task ; } public void addVmExit ( JUnitTest test , JUnitTaskMirror . JUnitResultFormatterMirror aFormatter , OutputStream out , String message , String testCase ) { JUnitResultFormatter formatter = ( JUnitResultFormatter ) aFormatter ; formatter . setOutput ( out ) ; formatter . startTestSuite ( test ) ; TestCase t = new VmExitErrorTest ( message , test , testCase ) ; formatter . startTest ( t ) ; formatter . addError ( t , new AssertionFailedError ( message ) ) ; formatter . endTestSuite ( test ) ; } public JUnitTaskMirror . JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) { return new JUnitTestRunner ( test , haltOnError , filterTrace , haltOnFailure , showOutput , logTestListenerEvents , classLoader ) ; } public JUnitTaskMirror . SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) { return new SummaryJUnitResultFormatter ( ) ; } static class VmExitErrorTest extends TestCase { private String message ; private JUnitTest test ; private String testCase ; VmExitErrorTest ( String aMessage , JUnitTest anOriginalTest , String aTestCase ) { message = aMessage ; test = anOriginalTest ; testCase = aTestCase ; } public int countTestCases ( ) { return 1 ; } public void run ( TestResult r ) { throw new AssertionFailedError ( message ) ; } public String getName ( ) { return testCase ; } String getClassName ( ) { return test . getName ( ) ; } public String toString ( ) { return test . getName ( ) + ":" + testCase ; } } } 	0	['4', '1', '0', '13', '14', '6', '0', '13', '4', '1', '56', '1', '1', '0', '0.375', '0', '0', '12.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FieldRefCPInfo extends ConstantPoolEntry { private String fieldClassName ; private String fieldName ; private String fieldType ; private int classIndex ; private int nameAndTypeIndex ; public FieldRefCPInfo ( ) { super ( CONSTANT_FIELDREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo fieldClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; fieldClass . resolve ( constantPool ) ; fieldClassName = fieldClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; fieldName = nt . getName ( ) ; fieldType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Field : Class = " + fieldClassName + ", name = " + fieldName + ", type = " + fieldType ; } else { value = "Field : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public String getFieldClassName ( ) { return fieldClassName ; } public String getFieldName ( ) { return fieldName ; } public String getFieldType ( ) { return fieldType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant . dispatch ; public interface Dispatchable { String getActionParameterName ( ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import java . io . File ; import org . apache . tools . ant . types . Reference ; public class ScriptRunnerHelper { private ClasspathUtils . Delegate cpDelegate = null ; private File srcFile ; private String manager = "auto" ; private String language ; private String text ; private boolean setBeans = true ; private ProjectComponent projectComponent ; private ClassLoader scriptLoader = null ; public void setProjectComponent ( ProjectComponent component ) { this . projectComponent = component ; } public ScriptRunnerBase getScriptRunner ( ) { ScriptRunnerBase runner = getRunner ( ) ; if ( srcFile != null ) { runner . setSrc ( srcFile ) ; } if ( text != null ) { runner . addText ( text ) ; } if ( setBeans ) { runner . bindToComponent ( projectComponent ) ; } else { runner . bindToComponentMinimum ( projectComponent ) ; } return runner ; } public Path createClasspath ( ) { return getClassPathDelegate ( ) . createClasspath ( ) ; } public void setClasspath ( Path classpath ) { getClassPathDelegate ( ) . setClasspath ( classpath ) ; } public void setClasspathRef ( Reference r ) { getClassPathDelegate ( ) . setClasspathref ( r ) ; } public void setSrc ( File file ) { this . srcFile = file ; } public void addText ( String text ) { this . text = text ; } public void setManager ( String manager ) { this . manager = manager ; } public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setSetBeans ( boolean setBeans ) { this . setBeans = setBeans ; } public void setClassLoader ( ClassLoader loader ) { scriptLoader = loader ; } private ClassLoader generateClassLoader ( ) { if ( scriptLoader != null ) { return scriptLoader ; } if ( cpDelegate == null ) { scriptLoader = getClass ( ) . getClassLoader ( ) ; return scriptLoader ; } scriptLoader = cpDelegate . getClassLoader ( ) ; return scriptLoader ; } private ClasspathUtils . Delegate getClassPathDelegate ( ) { if ( cpDelegate == null ) { cpDelegate = ClasspathUtils . getDelegate ( projectComponent ) ; } return cpDelegate ; } private ScriptRunnerBase getRunner ( ) { return new ScriptRunnerCreator ( projectComponent . getProject ( ) ) . createRunner ( manager , language , generateClassLoader ( ) ) ; } } 	0	['16', '1', '0', '13', '31', '76', '5', '8', '13', '0.791666667', '165', '1', '2', '0', '0.1953125', '0', '0', '8.8125', '4', '1.3125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitStatusException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class Exit extends Task { private static class NestedCondition extends ConditionBase implements Condition { public boolean eval ( ) { if ( countConditions ( ) != 1 ) { throw new BuildException ( "A single nested condition is required." ) ; } return ( ( Condition ) ( getConditions ( ) . nextElement ( ) ) ) . eval ( ) ; } } private String message ; private String ifCondition , unlessCondition ; private NestedCondition nestedCondition ; private Integer status ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void setStatus ( int i ) { status = new Integer ( i ) ; } public void execute ( ) throws BuildException { boolean fail = ( nestedConditionPresent ( ) ) ? testNestedCondition ( ) : ( testIfCondition ( ) && testUnlessCondition ( ) ) ; if ( fail ) { String text = null ; if ( message != null && message . trim ( ) . length ( ) > 0 ) { text = message . trim ( ) ; } else { if ( ifCondition != null && ifCondition . length ( ) > 0 && getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } if ( nestedConditionPresent ( ) ) { text = "condition satisfied" ; } else { if ( text == null ) { text = "No message" ; } } } log ( "failing due to " + text , Project . MSG_DEBUG ) ; throw ( ( status == null ) ? new BuildException ( text ) : new ExitStatusException ( text , status . intValue ( ) ) ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } public ConditionBase createCondition ( ) { if ( nestedCondition != null ) { throw new BuildException ( "Only one nested condition is allowed." ) ; } nestedCondition = new NestedCondition ( ) ; return nestedCondition ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } private boolean testNestedCondition ( ) { boolean result = nestedConditionPresent ( ) ; if ( result && ifCondition != null || unlessCondition != null ) { throw new BuildException ( "Nested conditions " + "not permitted in conjunction with if/unless attributes" ) ; } return result && nestedCondition . eval ( ) ; } private boolean nestedConditionPresent ( ) { return ( nestedCondition != null ) ; } } 	0	['12', '3', '0', '6', '30', '30', '0', '6', '8', '0.781818182', '282', '1', '1', '0.770833333', '0.472222222', '1', '1', '22.08333333', '6', '2.0833', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . ListIterator ; public class MakeUrl extends Task { private String property ; private File file ; private String separator = " " ; private List filesets = new LinkedList ( ) ; private List paths = new LinkedList ( ) ; private boolean validate = true ; public static final String ERROR_MISSING_FILE = "A source file is missing :" ; public static final String ERROR_NO_PROPERTY = "No property defined" ; public static final String ERROR_NO_FILES = "No files defined" ; public void setProperty ( String property ) { this . property = property ; } public void setFile ( File file ) { this . file = file ; } public void addFileSet ( FileSet fileset ) { filesets . add ( fileset ) ; } public void setSeparator ( String separator ) { this . separator = separator ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void addPath ( Path path ) { paths . add ( path ) ; } private String filesetsToURL ( ) { if ( filesets . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = filesets . listIterator ( ) ; while ( list . hasNext ( ) ) { FileSet set = ( FileSet ) list . next ( ) ; DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( scanner . getBasedir ( ) , files [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private String stripTrailingSeparator ( StringBuffer urls , int count ) { if ( count > 0 ) { urls . delete ( urls . length ( ) - separator . length ( ) , urls . length ( ) ) ; return new String ( urls ) ; } else { return "" ; } } private String pathsToURL ( ) { if ( paths . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = paths . listIterator ( ) ; while ( list . hasNext ( ) ) { Path path = ( Path ) list . next ( ) ; String [ ] elements = path . list ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { File f = new File ( elements [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private void validateFile ( File fileToCheck ) { if ( validate && ! fileToCheck . exists ( ) ) { throw new BuildException ( ERROR_MISSING_FILE + fileToCheck . toString ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( getProject ( ) . getProperty ( property ) != null ) { return ; } String url ; String filesetURL = filesetsToURL ( ) ; if ( file != null ) { validateFile ( file ) ; url = toURL ( file ) ; if ( filesetURL . length ( ) > 0 ) { url = url + separator + filesetURL ; } } else { url = filesetURL ; } String pathURL = pathsToURL ( ) ; if ( pathURL . length ( ) > 0 ) { if ( url . length ( ) > 0 ) { url = url + separator + pathURL ; } else { url = pathURL ; } } log ( "Setting " + property + " to URL " + url , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , url ) ; } private void validate ( ) { if ( property == null ) { throw new BuildException ( ERROR_NO_PROPERTY ) ; } if ( file == null && filesets . isEmpty ( ) && paths . isEmpty ( ) ) { throw new BuildException ( ERROR_NO_FILES ) ; } } private String toURL ( File fileToConvert ) { String url ; url = FileUtils . getFileUtils ( ) . toURI ( fileToConvert . getAbsolutePath ( ) ) ; return url ; } } 	0	['14', '3', '0', '7', '46', '27', '0', '7', '8', '0.837606838', '372', '0.666666667', '0', '0.74', '0.214285714', '1', '1', '24.92857143', '5', '1.8571', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; public interface SOSCmd { String COMMAND_SOS_EXE = "soscmd" ; String COMMAND_GET_FILE = "GetFile" ; String COMMAND_GET_PROJECT = "GetProject" ; String COMMAND_CHECKOUT_FILE = "CheckOutFile" ; String COMMAND_CHECKOUT_PROJECT = "CheckOutProject" ; String COMMAND_CHECKIN_FILE = "CheckInFile" ; String COMMAND_CHECKIN_PROJECT = "CheckInProject" ; String COMMAND_HISTORY = "GetFileHistory" ; String COMMAND_LABEL = "AddLabel" ; String PROJECT_PREFIX = "$" ; String FLAG_COMMAND = "-command" ; String FLAG_VSS_SERVER = "-database" ; String FLAG_USERNAME = "-name" ; String FLAG_PASSWORD = "-password" ; String FLAG_COMMENT = "-log" ; String FLAG_WORKING_DIR = "-workdir" ; String FLAG_RECURSION = "-recursive" ; String FLAG_VERSION = "-revision" ; String FLAG_LABEL = "-label" ; String FLAG_NO_COMPRESSION = "-nocompress" ; String FLAG_NO_CACHE = "-nocache" ; String FLAG_SOS_SERVER = "-server" ; String FLAG_SOS_HOME = "-soshome" ; String FLAG_PROJECT = "-project" ; String FLAG_FILE = "-file" ; String FLAG_VERBOSE = "-verbose" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '26', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . UnknownHostException ; public class IsReachable extends ProjectComponent implements Condition { private static final int SECOND = 1000 ; private String host ; private String url ; public static final int DEFAULT_TIMEOUT = 30 ; private int timeout = DEFAULT_TIMEOUT ; public static final String ERROR_NO_HOSTNAME = "No hostname defined" ; public static final String ERROR_BAD_TIMEOUT = "Invalid timeout value" ; private static final String WARN_UNKNOWN_HOST = "Unknown host: " ; public static final String ERROR_ON_NETWORK = "network error to " ; public static final String ERROR_BOTH_TARGETS = "Both url and host have been specified" ; public static final String MSG_NO_REACHABLE_TEST = "cannot do a proper reachability test on this Java version" ; public static final String ERROR_BAD_URL = "Bad URL " ; public static final String ERROR_NO_HOST_IN_URL = "No hostname in URL " ; public static final String METHOD_NAME = "isReachable" ; public void setHost ( String host ) { this . host = host ; } public void setUrl ( String url ) { this . url = url ; } public void setTimeout ( int timeout ) { this . timeout = timeout ; } private boolean empty ( String string ) { return string == null || string . length ( ) == 0 ; } private static Class [ ] parameterTypes = { Integer . TYPE } ; public boolean eval ( ) throws BuildException { if ( empty ( host ) && empty ( url ) ) { throw new BuildException ( ERROR_NO_HOSTNAME ) ; } if ( timeout < 0 ) { throw new BuildException ( ERROR_BAD_TIMEOUT ) ; } String target = host ; if ( ! empty ( url ) ) { if ( ! empty ( host ) ) { throw new BuildException ( ERROR_BOTH_TARGETS ) ; } try { URL realURL = new URL ( url ) ; target = realURL . getHost ( ) ; if ( empty ( target ) ) { throw new BuildException ( ERROR_NO_HOST_IN_URL + url ) ; } } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_BAD_URL + url , e ) ; } } log ( "Probing host " + target , Project . MSG_VERBOSE ) ; InetAddress address ; try { address = InetAddress . getByName ( target ) ; } catch ( UnknownHostException e1 ) { log ( WARN_UNKNOWN_HOST + target ) ; return false ; } log ( "Host address = " + address . getHostAddress ( ) , Project . MSG_VERBOSE ) ; boolean reachable ; Method reachableMethod = null ; try { reachableMethod = InetAddress . class . getMethod ( METHOD_NAME , parameterTypes ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = new Integer ( timeout * SECOND ) ; try { reachable = ( ( Boolean ) reachableMethod . invoke ( address , params ) ) . booleanValue ( ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "When calling " + reachableMethod ) ; } catch ( InvocationTargetException e ) { Throwable nested = e . getTargetException ( ) ; log ( ERROR_ON_NETWORK + target + ": " + nested . toString ( ) ) ; reachable = false ; } } catch ( NoSuchMethodException e ) { log ( "Not found: InetAddress." + METHOD_NAME , Project . MSG_VERBOSE ) ; log ( MSG_NO_REACHABLE_TEST ) ; reachable = true ; } log ( "host is" + ( reachable ? "" : " not" ) + " reachable" , Project . MSG_VERBOSE ) ; return reachable ; } } 	0	['7', '2', '0', '3', '30', '9', '0', '3', '5', '1.0625', '278', '0.375', '0', '0.642857143', '0.555555556', '0', '0', '36.42857143', '3', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . StringUtils ; public class DefaultExcludes extends Task { private String add = "" ; private String remove = "" ; private boolean defaultrequested = false ; private boolean echo = false ; private int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( ! defaultrequested && add . equals ( "" ) && remove . equals ( "" ) && ! echo ) { throw new BuildException ( "<defaultexcludes> task must set " + "at least one attribute (echo=\"false\"" + " doesn't count since that is the default" ) ; } if ( defaultrequested ) { DirectoryScanner . resetDefaultExcludes ( ) ; } if ( ! add . equals ( "" ) ) { DirectoryScanner . addDefaultExclude ( add ) ; } if ( ! remove . equals ( "" ) ) { DirectoryScanner . removeDefaultExclude ( remove ) ; } if ( echo ) { StringBuffer message = new StringBuffer ( "Current Default Excludes:" ) ; message . append ( StringUtils . LINE_SEP ) ; String [ ] excludes = DirectoryScanner . getDefaultExcludes ( ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { message . append ( "  " ) ; message . append ( excludes [ i ] ) ; message . append ( StringUtils . LINE_SEP ) ; } log ( message . toString ( ) , logLevel ) ; } } public void setDefault ( boolean def ) { defaultrequested = def ; } public void setAdd ( String add ) { this . add = add ; } public void setRemove ( String remove ) { this . remove = remove ; } public void setEcho ( boolean echo ) { this . echo = echo ; } } 	0	['6', '3', '0', '4', '17', '0', '0', '4', '6', '0.64', '131', '1', '0', '0.880952381', '0.555555556', '2', '2', '20', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private String getLineBreaks ( ) { return lineBreaks ; } public Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0	['7', '5', '0', '4', '17', '0', '1', '3', '5', '0.777777778', '107', '1', '0', '0.848484848', '0.476190476', '2', '5', '13.85714286', '5', '1.2857', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ClasspathUtils { public static final String REUSE_LOADER_REF = MagicNames . REFID_CLASSPATH_REUSE_LOADER ; public static ClassLoader getClassLoaderForPath ( Project p , Reference ref ) { return getClassLoaderForPath ( p , ref , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Reference ref , boolean reverseLoader ) { String pathId = ref . getRefId ( ) ; Object path = p . getReference ( pathId ) ; if ( ! ( path instanceof Path ) ) { throw new BuildException ( "The specified classpathref " + pathId + " does not reference a Path." ) ; } String loaderId = MagicNames . REFID_CLASSPATH_LOADER_PREFIX + pathId ; return getClassLoaderForPath ( p , ( Path ) path , loaderId , reverseLoader ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId ) { return getClassLoaderForPath ( p , path , loaderId , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader ) { return getClassLoaderForPath ( p , path , loaderId , reverseLoader , isMagicPropertySet ( p ) ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader , boolean reuseLoader ) { ClassLoader cl = null ; if ( loaderId != null && reuseLoader ) { Object reusedLoader = p . getReference ( loaderId ) ; if ( reusedLoader != null && ! ( reusedLoader instanceof ClassLoader ) ) { throw new BuildException ( "The specified loader id " + loaderId + " does not reference a class loader" ) ; } cl = ( ClassLoader ) reusedLoader ; } if ( cl == null ) { cl = getUniqueClassLoaderForPath ( p , path , reverseLoader ) ; if ( loaderId != null && reuseLoader ) { p . addReference ( loaderId , cl ) ; } } return cl ; } public static ClassLoader getUniqueClassLoaderForPath ( Project p , Path path , boolean reverseLoader ) { AntClassLoader acl = p . createClassLoader ( path ) ; if ( reverseLoader ) { acl . setParentFirst ( false ) ; acl . addJavaLibraries ( ) ; } return acl ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader ) { return newInstance ( className , userDefinedLoader , Object . class ) ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader , Class expectedType ) { try { Class clazz = Class . forName ( className , true , userDefinedLoader ) ; Object o = clazz . newInstance ( ) ; if ( ! expectedType . isInstance ( o ) ) { throw new BuildException ( "Class of unexpected Type: " + className + " expected :" + expectedType ) ; } return o ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class not found: " + className , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a no " + "argument constructor." , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a " + "public constructor." , e ) ; } catch ( LinkageError e ) { throw new BuildException ( "Class " + className + " could not be loaded because of an invalid dependency." , e ) ; } } public static Delegate getDelegate ( ProjectComponent component ) { return new Delegate ( component ) ; } private static boolean isMagicPropertySet ( Project p ) { return p . getProperty ( REUSE_LOADER_REF ) != null ; } public static class Delegate { private final ProjectComponent component ; private Path classpath ; private String classpathId ; private String className ; private String loaderId ; private boolean reverseLoader = false ; Delegate ( ProjectComponent component ) { this . component = component ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( component . getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClassname ( String fcqn ) { this . className = fcqn ; } public void setClasspathref ( Reference r ) { this . classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; } public void setLoaderRef ( Reference r ) { this . loaderId = r . getRefId ( ) ; } public ClassLoader getClassLoader ( ) { return getClassLoaderForPath ( getContextProject ( ) , this . classpath , getClassLoadId ( ) , this . reverseLoader , loaderId != null || isMagicPropertySet ( getContextProject ( ) ) ) ; } private Project getContextProject ( ) { return this . component . getProject ( ) ; } public String getClassLoadId ( ) { return this . loaderId == null && this . classpathId != null ? MagicNames . REFID_CLASSPATH_LOADER_PREFIX + this . classpathId : this . loaderId ; } public Object newInstance ( ) { return ClasspathUtils . newInstance ( this . className , getClassLoader ( ) ) ; } public Path getClasspath ( ) { return classpath ; } public boolean isReverseLoader ( ) { return reverseLoader ; } } } 	0	['12', '1', '0', '19', '33', '66', '13', '7', '10', '1.045454545', '261', '0', '0', '0', '0.259259259', '0', '0', '20.58333333', '8', '1.9167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '5', '39', '4', '0', '5', '7', '0.714285714', '274', '1', '0', '0.917647059', '0.46875', '4', '4', '32.5', '5', '1.375', '0']
package org . apache . tools . ant . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class PatternSet extends DataType implements Cloneable { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( name == null ) { buf . append ( "noname" ) ; } else { buf . append ( name ) ; } if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occurred while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } public boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { return ( PatternSet ) getCheckedRef ( p ) ; } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } public Object clone ( ) { try { PatternSet ps = ( PatternSet ) super . clone ( ) ; ps . includeList = ( Vector ) includeList . clone ( ) ; ps . excludeList = ( Vector ) excludeList . clone ( ) ; ps . includesFileList = ( Vector ) includesFileList . clone ( ) ; ps . excludesFileList = ( Vector ) excludesFileList . clone ( ) ; return ps ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } 	0	['22', '3', '0', '14', '62', '133', '10', '5', '17', '0.571428571', '625', '1', '0', '0.588235294', '0.266233766', '2', '3', '27.22727273', '9', '2.8182', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { validate ( ) ; StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } public void validate ( ) { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified " + "for environment variables." ) ; } } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } public Vector getVariablesVector ( ) { return variables ; } } 	0	['4', '1', '1', '8', '10', '0', '6', '2', '4', '0', '51', '1', '0', '0', '0.625', '0', '0', '11.5', '1', '0.75', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TypeAdapter ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . XMLReaderAdapter ; public class ProjectHelperImpl extends ProjectHelper { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; private Target implicitTarget = new Target ( ) ; public ProjectHelperImpl ( ) { implicitTarget . setName ( "" ) ; } public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by " + "default plugin" ) ; } File bFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( bFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = FILE_UTILS . toURI ( bFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( bFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + bFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { FileUtils . close ( inputStream ) ; } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } public void endElement ( String name ) throws SAXException { helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = FILE_UTILS . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , path ) ; helperImpl . project . log ( "Warning: '" + systemId + "' in " + helperImpl . buildFile + " should be expressed simply as '" + path . replace ( '\\' , '/' ) + "' for compliance with other XML tools" , Project . MSG_WARN ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected " + "XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def != null && ! def . equals ( "" ) ) { helperImpl . project . setDefaultTarget ( def ) ; } else { throw new BuildException ( "The default attribute is required" ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { File resolvedBaseDir = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , baseDir ) ; helperImpl . project . setBaseDir ( resolvedBaseDir ) ; } } } helperImpl . project . addTarget ( "" , helperImpl . implicitTarget ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else { handleElement ( helperImpl , this , helperImpl . implicitTarget , name , attrs ) ; } } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( "name attribute must not" + " be empty" , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { handleElement ( helperImpl , this , target , name , attrs ) ; } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { if ( elementName . equals ( "description" ) ) { new DescriptionHandler ( helperImpl , parent ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( elementName ) != null ) { new DataTypeHandler ( helperImpl , parent , target ) . init ( elementName , attrs ) ; } else { new TaskHandler ( helperImpl , parent , target , null , target ) . init ( elementName , attrs ) ; } } static class DescriptionHandler extends AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void characters ( char [ ] buf , int start , int count ) { String text = new String ( buf , start , count ) ; String currentDescription = helperImpl . project . getDescription ( ) ; if ( currentDescription == null ) { helperImpl . project . setDescription ( text ) ; } else { helperImpl . project . setDescription ( currentDescription + text ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TypeAdapter ) { this . parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( helperImpl . project , parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { childWrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['15', '2', '0', '18', '66', '77', '9', '13', '2', '0.87755102', '315', '1', '3', '0.566666667', '0.222222222', '1', '1', '19.53333333', '2', '0.9333', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . Javah ; public interface JavahAdapter { boolean compile ( Javah javah ) throws BuildException ; } 	0	['1', '1', '0', '5', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '13', '26', '0', '6', '7', '7', '0.458333333', '198', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.71428571', '5', '2.5714', '0']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) || ( "" . equals ( getInput ( ) ) && getDefaultValue ( ) != null ) ; } } 	0	['3', '2', '0', '3', '10', '0', '2', '1', '3', '0', '44', '1', '0', '0.75', '0.555555556', '1', '1', '13.33333333', '4', '1.6667', '0']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['31', '1', '0', '5', '70', '407', '2', '3', '13', '0.904761905', '615', '0.904761905', '2', '0', '0.316129032', '0', '0', '18.16129032', '11', '1.4516', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class DoubleCPInfo extends ConstantCPInfo { public DoubleCPInfo ( ) { super ( CONSTANT_DOUBLE , 2 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Double ( cpStream . readDouble ( ) ) ) ; } public String toString ( ) { return "Double Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; java . net . Socket s = null ; try { s = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } finally { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ioe ) { } } } return true ; } } 	0	['4', '2', '0', '4', '13', '0', '1', '3', '4', '0.333333333', '85', '1', '0', '0.75', '0.5', '0', '0', '19.75', '1', '0.75', '0']
package org . apache . tools . ant ; public class ExitStatusException extends BuildException { private int status ; public ExitStatusException ( int status ) { super ( ) ; this . status = status ; } public ExitStatusException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public ExitStatusException ( String message , int status , Location location ) { super ( message , location ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['4', '5', '0', '5', '7', '0', '3', '2', '4', '0', '29', '1', '0', '0.954545455', '0.625', '0', '0', '6', '1', '0.25', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class Name implements ResourceSelector { private String pattern ; private boolean cs = true ; public void setName ( String n ) { pattern = n ; } public String getName ( ) { return pattern ; } public void setCaseSensitive ( boolean b ) { cs = b ; } public boolean isCaseSensitive ( ) { return cs ; } public boolean isSelected ( Resource r ) { String n = r . getName ( ) ; if ( SelectorUtils . match ( pattern , n , cs ) ) { return true ; } String s = r . toString ( ) ; return s . equals ( n ) ? false : SelectorUtils . match ( pattern , s , cs ) ; } } 	0	['6', '1', '0', '3', '11', '0', '0', '3', '6', '0.5', '56', '1', '0', '0', '0.375', '0', '0', '8', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Permissions ; public interface JUnitTaskMirror { void addVmExit ( JUnitTest test , JUnitResultFormatterMirror formatter , OutputStream out , String message , String testCase ) ; JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) ; SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) ; public interface JUnitResultFormatterMirror { void setOutput ( OutputStream outputStream ) ; } public interface SummaryJUnitResultFormatterMirror extends JUnitResultFormatterMirror { void setWithOutAndErr ( boolean value ) ; } public interface JUnitTestRunnerMirror { String IGNORED_FILE_NAME = "IGNORETHIS" ; int SUCCESS = 0 ; int FAILURES = 1 ; int ERRORS = 2 ; void setPermissions ( Permissions perm ) ; void run ( ) ; void addFormatter ( JUnitResultFormatterMirror formatter ) ; int getRetCode ( ) ; void handleErrorFlush ( String output ) ; void handleErrorOutput ( String output ) ; void handleOutput ( String output ) ; int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException ; void handleFlush ( String output ) ; } } 	0	['3', '1', '0', '7', '3', '3', '2', '5', '3', '2', '3', '0', '0', '0', '0.476190476', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent implements Cloneable { protected Project project ; protected Location location = Location . UNKNOWN_LOCATION ; protected String description ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( msg , msgLevel ) ; } else { if ( msgLevel <= Project . MSG_INFO ) { System . err . println ( msg ) ; } } } public Object clone ( ) throws CloneNotSupportedException { ProjectComponent pc = ( ProjectComponent ) super . clone ( ) ; pc . setLocation ( getLocation ( ) ) ; pc . setProject ( getProject ( ) ) ; return pc ; } } 	0	['10', '1', '28', '67', '14', '35', '66', '2', '10', '0.740740741', '75', '1', '2', '0', '0.32', '0', '0', '6.2', '3', '1.1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private Vector getComments ( ) { return comments ; } public Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '5', '26', '0', '1', '4', '5', '0.571428571', '172', '1', '0', '0.823529412', '0.375', '2', '5', '20.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; public class CSharp extends DotnetCompile { String definitions ; private File docFile ; private int fileAlign = 0 ; private boolean fullpaths = false ; private boolean incremental ; protected boolean unsafe ; private boolean noconfig = false ; public CSharp ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; docFile = null ; fileAlign = 0 ; fullpaths = true ; incremental = false ; unsafe = false ; noconfig = false ; definitions = null ; setExecutable ( isWindows ? "csc" : "mcs" ) ; } public void setDocFile ( File f ) { docFile = f ; } protected String getDocFileParameter ( ) { if ( docFile != null ) { return "/doc:" + docFile . toString ( ) ; } else { return null ; } } public void setFileAlign ( int fileAlign ) { this . fileAlign = fileAlign ; } protected String getFileAlignParameter ( ) { if ( fileAlign != 0 && ! "mcs" . equals ( getExecutable ( ) ) ) { return "/filealign:" + fileAlign ; } else { return null ; } } public void setFullPaths ( boolean enabled ) { fullpaths = enabled ; } protected String getFullPathsParameter ( ) { return fullpaths ? "/fullpaths" : null ; } public void setIncremental ( boolean incremental ) { this . incremental = incremental ; } public boolean getIncremental ( ) { return incremental ; } protected String getIncrementalParameter ( ) { return "/incremental" + ( incremental ? "+" : "-" ) ; } public void setOutputFile ( File params ) { setDestFile ( params ) ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public boolean getUnsafe ( ) { return this . unsafe ; } protected String getUnsafeParameter ( ) { return unsafe ? "/unsafe" : null ; } public void setNoConfig ( boolean enabled ) { noconfig = enabled ; } protected String getNoConfigParameter ( ) { return noconfig ? "/noconfig" : null ; } public void setDefinitions ( String params ) { definitions = params ; } protected String getDefinitionsParameter ( ) { String predecessors = super . getDefinitionsParameter ( ) ; if ( notEmpty ( definitions ) ) { if ( predecessors == null ) { predecessors = "/define:" ; } return predecessors + definitions ; } else { return predecessors ; } } public void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getIncludeDefaultReferencesParameter ( ) ) ; command . addArgument ( getWarnLevelParameter ( ) ) ; command . addArgument ( getDocFileParameter ( ) ) ; command . addArgument ( getFullPathsParameter ( ) ) ; command . addArgument ( getFileAlignParameter ( ) ) ; command . addArgument ( getIncrementalParameter ( ) ) ; command . addArgument ( getNoConfigParameter ( ) ) ; command . addArgument ( getUnsafeParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return ";" ; } public String getFileExtension ( ) { return "cs" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , true ) ; } } 	0	['23', '6', '0', '4', '42', '185', '0', '4', '15', '0.811688312', '249', '0.857142857', '0', '0.872093023', '0.211180124', '1', '7', '9.52173913', '3', '1.3913', '0']
package org . apache . tools . ant . types ; public interface ResourceFactory { Resource getResource ( String name ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public interface DynamicConfiguratorNS extends DynamicAttributeNS , DynamicElementNS { } 	0	['0', '1', '0', '3', '0', '0', '1', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class TimeComparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "before" , "after" , "equal" } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public static final TimeComparison BEFORE = new TimeComparison ( "before" ) ; public static final TimeComparison AFTER = new TimeComparison ( "after" ) ; public static final TimeComparison EQUAL = new TimeComparison ( "equal" ) ; public TimeComparison ( ) { } public TimeComparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( long t1 , long t2 ) { return evaluate ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public boolean evaluate ( long t1 , long t2 , long g ) { int cmp = getIndex ( ) ; if ( cmp == - 1 ) { throw new BuildException ( "TimeComparison value not set." ) ; } if ( cmp == 0 ) { return t1 - g < t2 ; } if ( cmp == 1 ) { return t1 + g > t2 ; } return Math . abs ( t1 - t2 ) <= g ; } public static int compare ( long t1 , long t2 ) { return compare ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static int compare ( long t1 , long t2 , long g ) { long diff = t1 - t2 ; long abs = Math . abs ( diff ) ; return abs > Math . abs ( g ) ? ( int ) ( diff / abs ) : 0 ; } } 	0	['8', '2', '1', '8', '15', '20', '5', '3', '7', '0.914285714', '136', '0.4', '4', '0.615384615', '0.476190476', '1', '1', '15.375', '7', '1.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSCREATE extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CREATE ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getQuiet ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public final void setQuiet ( boolean quiet ) { super . setInternalQuiet ( quiet ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['5', '4', '0', '5', '21', '10', '0', '5', '4', '2', '71', '0', '0', '0.957894737', '0.533333333', '1', '1', '13.2', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public NotSelector ( FileSelector other ) { this ( ) ; appendSelector ( other ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['4', '6', '0', '8', '13', '6', '6', '2', '4', '2', '44', '0', '0', '0.96969697', '0.625', '2', '3', '10', '2', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . JavaClass ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class AncestorAnalyzer extends AbstractAnalyzer { public AncestorAnalyzer ( ) { try { new ClassParser ( "force" ) ; } catch ( IOException e ) { } } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; Hashtable nextAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 2 ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { nextAnalyze . clear ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ClassParser parser = null ; if ( container . getName ( ) . endsWith ( ".class" ) ) { parser = new ClassParser ( container . getPath ( ) ) ; } else { parser = new ClassParser ( container . getPath ( ) , classname . replace ( '.' , '/' ) + ".class" ) ; } JavaClass javaClass = parser . parse ( ) ; String [ ] interfaces = javaClass . getInterfaceNames ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { String interfaceName = interfaces [ i ] ; if ( ! dependencies . containsKey ( interfaceName ) ) { nextAnalyze . put ( interfaceName , interfaceName ) ; } } if ( javaClass . isClass ( ) ) { String superClass = javaClass . getSuperclassName ( ) ; if ( ! dependencies . containsKey ( superClass ) ) { nextAnalyze . put ( superClass , superClass ) ; } } } catch ( IOException ioe ) { } } Hashtable temp = toAnalyze ; toAnalyze = nextAnalyze ; nextAnalyze = temp ; } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	0	['3', '2', '0', '3', '31', '3', '0', '3', '1', '2', '202', '0', '0', '0.882352941', '0.666666667', '1', '2', '66.33333333', '14', '5', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class Ilasm extends DotnetBaseMatchingTask { protected static final String exe_name = "ilasm" ; protected static final String file_ext = "il" ; protected static final String file_pattern = "**/*." + file_ext ; protected static final String exe_title = "ilasm" ; protected String targetType ; protected boolean verbose ; protected boolean listing ; protected File resourceFile ; protected boolean failOnError ; protected boolean debug ; private File keyfile ; protected String extraOptions ; protected Vector referenceFilesets = new Vector ( ) ; private boolean isMono = ! Os . isFamily ( "windows" ) ; public Ilasm ( ) { Clear ( ) ; setIncludes ( file_pattern ) ; } public void Clear ( ) { targetType = null ; srcDir = null ; listing = false ; verbose = false ; debug = true ; outputFile = null ; failOnError = true ; resourceFile = null ; extraOptions = null ; } public void setTargetType ( String targetType ) throws BuildException { this . targetType = targetType . toLowerCase ( ) ; if ( ! targetType . equals ( "exe" ) && ! targetType . equals ( "library" ) ) { throw new BuildException ( "targetType " + targetType + " is not a valid type" ) ; } } public String getTargetType ( ) { return targetType ; } protected String getTargetTypeParameter ( ) { if ( ! notEmpty ( targetType ) ) { return null ; } if ( targetType . equals ( "exe" ) ) { return "/exe" ; } else if ( targetType . equals ( "library" ) ) { return "/dll" ; } else { return null ; } } public void setOwner ( String s ) { log ( "This option is not supported by ILASM as of Beta-2, " + "and will be ignored" , Project . MSG_WARN ) ; } protected boolean notEmpty ( String s ) { return s != null && s . length ( ) != 0 ; } public void setVerbose ( boolean b ) { verbose = b ; } protected String getVerboseParameter ( ) { return verbose ? null : "/quiet" ; } public void setListing ( boolean b ) { listing = b ; } protected String getListingParameter ( ) { if ( ! isMono ) { return listing ? "/listing" : "/nolisting" ; } return null ; } public void setOutputFile ( File params ) { outputFile = params ; } protected String getOutputFileParameter ( ) { if ( outputFile == null ) { return null ; } return "/output=" + outputFile . toString ( ) ; } public void setResourceFile ( File fileName ) { resourceFile = fileName ; } protected String getResourceFileParameter ( ) { if ( resourceFile != null ) { return "/resource=" + resourceFile . toString ( ) ; } else { return null ; } } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailOnError ( ) { return failOnError ; } public void setDebug ( boolean f ) { debug = f ; } public boolean getDebug ( ) { return debug ; } protected String getDebugParameter ( ) { return debug ? "/debug" : null ; } public void setKeyfile ( File keyfile ) { this . keyfile = keyfile ; } protected String getKeyfileParameter ( ) { if ( keyfile != null ) { return "/keyfile:" + keyfile . toString ( ) ; } else { return null ; } } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public String getExtraOptions ( ) { return this . extraOptions ; } protected String getExtraOptionsParameter ( ) { if ( extraOptions != null && extraOptions . length ( ) != 0 ) { return extraOptions ; } else { return null ; } } public void setTargetType ( TargetTypes targetType ) { this . targetType = targetType . getValue ( ) ; } public void setMono ( boolean b ) { isMono = b ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; NetCommand command = buildIlasmCommand ( ) ; addFilesAndExecute ( command , false ) ; } private NetCommand buildIlasmCommand ( ) { NetCommand command = new NetCommand ( this , exe_title , exe_name ) ; command . setFailOnError ( getFailOnError ( ) ) ; command . addArgument ( getDebugParameter ( ) ) ; command . addArgument ( getTargetTypeParameter ( ) ) ; command . addArgument ( getListingParameter ( ) ) ; command . addArgument ( getOutputFileParameter ( ) ) ; command . addArgument ( getResourceFileParameter ( ) ) ; command . addArgument ( getVerboseParameter ( ) ) ; command . addArgument ( getKeyfileParameter ( ) ) ; command . addArgument ( getExtraOptionsParameter ( ) ) ; return command ; } public void addReference ( FileSet reference ) { referenceFilesets . add ( reference ) ; } protected static boolean isFileManagedBinary ( File file ) { String filename = file . toString ( ) . toLowerCase ( ) ; return filename . endsWith ( ".exe" ) || filename . endsWith ( ".dll" ) || filename . endsWith ( ".netmodule" ) ; } public static class TargetTypes extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "exe" , "library" , } ; } } } 	0	['31', '5', '0', '7', '51', '381', '0', '7', '20', '0.919047619', '376', '1', '0', '0.743589744', '0.241935484', '2', '4', '10.67741935', '4', '1.5161', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0	['3', '5', '0', '10', '12', '1', '6', '4', '3', '2', '76', '0', '0', '0.953488372', '0.666666667', '1', '1', '24.33333333', '4', '1.6667', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class TarResource extends ArchiveResource { private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarResource ( ) { } public TarResource ( File a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public TarResource ( Resource a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } Resource archive = getArchive ( ) ; final TarInputStream i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { return i ; } } FileUtils . close ( i ) ; throw new BuildException ( "no entry " + getName ( ) + " in " + getArchive ( ) ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( "Use the tar task for tar output." ) ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGid ( ) ; } return uid ; } protected void fetchEntry ( ) { Resource archive = getArchive ( ) ; TarInputStream i = null ; try { i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { setEntry ( te ) ; return ; } } } catch ( IOException e ) { log ( e . getMessage ( ) , Project . MSG_DEBUG ) ; throw new BuildException ( e ) ; } finally { if ( i != null ) { FileUtils . close ( i ) ; } } setEntry ( null ) ; } private void setEntry ( TarEntry e ) { if ( e == null ) { setExists ( false ) ; return ; } setName ( e . getName ( ) ) ; setExists ( true ) ; setLastModified ( e . getModTime ( ) . getTime ( ) ) ; setDirectory ( e . isDirectory ( ) ) ; setSize ( e . getSize ( ) ) ; setMode ( e . getMode ( ) ) ; userName = e . getUserName ( ) ; groupName = e . getGroupName ( ) ; uid = e . getUserId ( ) ; gid = e . getGroupId ( ) ; } } 	0	['11', '5', '0', '8', '49', '21', '2', '6', '9', '0.55', '265', '1', '0', '0.896103896', '0.363636364', '2', '4', '22.72727273', '7', '1.7273', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . Vector ; public class P4Submit extends P4Base { public String change ; private String changeProperty ; private String needsResolveProperty ; public void setChange ( String change ) { this . change = change ; } public void setChangeProperty ( String changeProperty ) { this . changeProperty = changeProperty ; } public void setNeedsResolveProperty ( String needsResolveProperty ) { this . needsResolveProperty = needsResolveProperty ; } public void execute ( ) throws BuildException { if ( change != null ) { execP4Command ( "submit -c " + change , ( P4HandlerAdapter ) new P4SubmitAdapter ( this ) ) ; } else { throw new BuildException ( "No change specified (no support for default change yet...." ) ; } } public class P4SubmitAdapter extends SimpleP4OutputHandler { public P4SubmitAdapter ( P4Base parent ) { super ( parent ) ; } public void process ( String line ) { super . process ( line ) ; getProject ( ) . setProperty ( "p4.needsresolve" , "0" ) ; if ( util . match ( "/renamed/" , line ) ) { try { Vector myarray = new Vector ( ) ; util . split ( myarray , line ) ; boolean found = false ; for ( int counter = 0 ; counter < myarray . size ( ) ; counter ++ ) { if ( found ) { String chnum = ( String ) myarray . elementAt ( counter + 1 ) ; int changenumber = Integer . parseInt ( chnum ) ; log ( "Perforce change renamed " + changenumber , Project . MSG_INFO ) ; getProject ( ) . setProperty ( "p4.change" , "" + changenumber ) ; if ( changeProperty != null ) { getProject ( ) . setNewProperty ( changeProperty , chnum ) ; } found = false ; } if ( ( ( myarray . elementAt ( counter ) ) ) . equals ( "renamed" ) ) { found = true ; } } } catch ( Exception e ) { String msg = "Failed to parse " + line + "\n" + " due to " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } } if ( util . match ( "/p4 submit -c/" , line ) ) { getProject ( ) . setProperty ( "p4.needsresolve" , "1" ) ; if ( needsResolveProperty != null ) { getProject ( ) . setNewProperty ( needsResolveProperty , "true" ) ; } } } } } 	0	['7', '4', '0', '4', '14', '15', '1', '4', '5', '0.833333333', '56', '0.666666667', '0', '0.894736842', '0.476190476', '1', '1', '6.571428571', '1', '0.8571', '0']
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . lang . ref . WeakReference ; public class WeakishReference { private WeakReference weakref ; WeakishReference ( Object reference ) { this . weakref = new WeakReference ( reference ) ; } public Object get ( ) { return weakref . get ( ) ; } public static WeakishReference createReference ( Object object ) { return new WeakishReference ( object ) ; } public static class HardReference extends WeakishReference { public HardReference ( Object object ) { super ( object ) ; } } } 	0	['3', '1', '1', '1', '6', '1', '1', '0', '2', '0', '22', '1', '0', '0', '0.666666667', '0', '0', '6', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . StringUtils ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '3', '32', '0', '0', '3', '5', '0.6', '1254', '1', '0', '0.880952381', '0.555555556', '1', '1', '207.3333333', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class LogLevel extends EnumeratedAttribute { public static final LogLevel ERR = new LogLevel ( "error" ) ; public static final LogLevel WARN = new LogLevel ( "warn" ) ; public static final LogLevel INFO = new LogLevel ( "info" ) ; public static final LogLevel VERBOSE = new LogLevel ( "verbose" ) ; public static final LogLevel DEBUG = new LogLevel ( "debug" ) ; public LogLevel ( ) { } private LogLevel ( String value ) { this ( ) ; setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { "error" , "warn" , "warning" , "info" , "verbose" , "debug" } ; } private static int [ ] levels = { Project . MSG_ERR , Project . MSG_WARN , Project . MSG_WARN , Project . MSG_INFO , Project . MSG_VERBOSE , Project . MSG_DEBUG } ; public int getLevel ( ) { return levels [ getIndex ( ) ] ; } } 	0	['5', '2', '2', '3', '8', '8', '2', '1', '3', '0.958333333', '101', '0.166666667', '5', '0.8', '0.625', '1', '1', '18', '1', '0.4', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import java . util . Iterator ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . FileUtils ; public class WsdlToDotnet extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destFile = null ; private String language = "CS" ; private boolean server = false ; private String namespace = null ; private boolean failOnError = true ; protected String extraOptions = null ; private String protocol = null ; private boolean ideErrors = false ; private Vector schemas = new Vector ( ) ; private Schema wsdl = new Schema ( ) ; private Compiler compiler = null ; public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory" ; public static final String ERROR_NO_DEST_FILE = "destination file must be specified" ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setUrl ( String url ) { wsdl . setUrl ( url ) ; } public void setSrcFile ( File srcFile ) { wsdl . setFile ( srcFile ) ; } public void setLanguage ( String language ) { this . language = language ; } public void setServer ( boolean server ) { this . server = server ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public void setIdeErrors ( boolean ideErrors ) { this . ideErrors = ideErrors ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public void addSchema ( Schema source ) { schemas . add ( source ) ; } public void setMakeURL ( boolean b ) { wsdl . setMakeURL ( b ) ; } public void setCompiler ( Compiler compiler ) { this . compiler = compiler ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( ERROR_NO_DEST_FILE ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( ERROR_DEST_FILE_IS_DIR ) ; } wsdl . validate ( ) ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; if ( compiler == null ) { compiler = Compiler . createDefaultCompiler ( ) ; } validate ( ) ; NetCommand command = new NetCommand ( this , "WSDL" , compiler . getCommand ( ) ) ; command . setFailOnError ( failOnError ) ; compiler . applyExtraArgs ( command ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/language:" , language ) ; if ( server ) { command . addArgument ( "/server" ) ; } command . addArgument ( "/namespace:" , namespace ) ; if ( protocol != null ) { command . addArgument ( "/protocol:" + protocol ) ; } if ( ideErrors ) { command . addArgument ( "/parsableErrors" ) ; } command . addArgument ( extraOptions ) ; boolean rebuild = true ; long destLastModified = - 1 ; if ( destFile . exists ( ) ) { destLastModified = destFile . lastModified ( ) ; rebuild = isRebuildNeeded ( wsdl , destLastModified ) ; } String path ; path = wsdl . evaluate ( ) ; if ( ! compiler . supportsAbsoluteFiles ( ) && wsdl . getFile ( ) != null ) { File f = wsdl . getFile ( ) ; command . setDirectory ( f . getParentFile ( ) ) ; path = f . getName ( ) ; } command . addArgument ( path ) ; Iterator it = schemas . iterator ( ) ; while ( it . hasNext ( ) ) { Schema schema = ( Schema ) it . next ( ) ; rebuild |= isRebuildNeeded ( schema , destLastModified ) ; command . addArgument ( schema . evaluate ( ) ) ; } if ( rebuild ) { command . runCommand ( ) ; } } private boolean isRebuildNeeded ( Schema schema , long destLastModified ) { if ( destLastModified == - 1 ) { return true ; } return ! FILE_UTILS . isUpToDate ( schema . getTimestamp ( ) , destLastModified ) ; } public static class Schema { private File file ; private String url ; private boolean makeURL = false ; public static final String ERROR_NONE_DECLARED = "One of file and url must be set" ; public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set" ; public static final String ERROR_FILE_NOT_FOUND = "Not found: " ; public static final String ERROR_FILE_IS_DIR = "File is a directory: " ; public static final String ERROR_NO_URL_CONVERT = "Could not URL convert " ; public void validate ( ) { if ( file != null ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_FILE_NOT_FOUND + file . toString ( ) ) ; } if ( file . isDirectory ( ) ) { throw new BuildException ( ERROR_FILE_IS_DIR + file . toString ( ) ) ; } } if ( file != null && url != null ) { throw new BuildException ( ERROR_BOTH_DECLARED ) ; } if ( file == null && url == null ) { throw new BuildException ( ERROR_NONE_DECLARED ) ; } } public String evaluate ( ) { validate ( ) ; if ( url != null ) { return getUrl ( ) ; } if ( makeURL ) { try { return file . toURL ( ) . toExternalForm ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_CONVERT + file ) ; } } return file . toString ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public boolean isMakeURL ( ) { return makeURL ; } public void setMakeURL ( boolean makeURL ) { this . makeURL = makeURL ; } public long getTimestamp ( ) { if ( file != null ) { return file . lastModified ( ) ; } else { return - 1 ; } } } public static class Compiler extends EnumeratedAttribute { public static final String COMPILER_MS = "microsoft" ; public static final String COMPILER_MONO = "mono" ; public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono" ; String [ ] compilers = { COMPILER_MS , COMPILER_MONO , COMPILER_MS_ON_MONO } ; public static final String EXE_WSDL = "wsdl" ; public static final String EXE_MONO = "mono" ; String [ ] compilerExecutables = { EXE_WSDL , EXE_WSDL , EXE_MONO } ; String [ ] [ ] extraCompilerArgs = { { } , { } , { EXE_WSDL + ".exe" } } ; boolean [ ] absoluteFiles = { true , false , true } ; public String [ ] getValues ( ) { return compilers ; } public static Compiler createDefaultCompiler ( ) { Compiler c = new Compiler ( ) ; String compilerName ; compilerName = Os . isFamily ( "windows" ) ? COMPILER_MS : COMPILER_MONO ; c . setValue ( compilerName ) ; return c ; } public String getCommand ( ) { return compilerExecutables [ getIndex ( ) ] ; } public String [ ] getExtraArgs ( ) { return extraCompilerArgs [ getIndex ( ) ] ; } public boolean supportsAbsoluteFiles ( ) { return absoluteFiles [ getIndex ( ) ] ; } public void applyExtraArgs ( NetCommand command ) { String [ ] args = getExtraArgs ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { command . addArgument ( args [ i ] ) ; } } } } 	0	['18', '3', '0', '6', '55', '79', '0', '6', '15', '0.890756303', '322', '0.857142857', '3', '0.698113208', '0.268907563', '1', '1', '16.11111111', '3', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Size extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return ( int ) ( foo . getSize ( ) - bar . getSize ( ) ) ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '12', '0', '0', '0.971428571', '0.75', '1', '1', '5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Map ; import java . util . HashSet ; import java . util . Set ; import java . util . TreeMap ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . PropertyResource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class PropertySet extends DataType implements ResourceCollection { private boolean dynamic = true ; private boolean negate = false ; private Set cachedNames ; private Vector ptyRefs = new Vector ( ) ; private Vector setRefs = new Vector ( ) ; private Mapper mapper ; public static class PropertyRef { private int count ; private String name ; private String regex ; private String prefix ; private String builtin ; public void setName ( String name ) { assertValid ( "name" , name ) ; this . name = name ; } public void setRegex ( String regex ) { assertValid ( "regex" , regex ) ; this . regex = regex ; } public void setPrefix ( String prefix ) { assertValid ( "prefix" , prefix ) ; this . prefix = prefix ; } public void setBuiltin ( BuiltinPropertySetName b ) { String pBuiltIn = b . getValue ( ) ; assertValid ( "builtin" , pBuiltIn ) ; this . builtin = pBuiltIn ; } private void assertValid ( String attr , String value ) { if ( value == null || value . length ( ) < 1 ) { throw new BuildException ( "Invalid attribute: " + attr ) ; } if ( ++ count != 1 ) { throw new BuildException ( "Attributes name, regex, and " + "prefix are mutually exclusive" ) ; } } public String toString ( ) { return "name=" + name + ", regex=" + regex + ", prefix=" + prefix + ", builtin=" + builtin ; } } public void appendName ( String name ) { PropertyRef r = new PropertyRef ( ) ; r . setName ( name ) ; addPropertyref ( r ) ; } public void appendRegex ( String regex ) { PropertyRef r = new PropertyRef ( ) ; r . setRegex ( regex ) ; addPropertyref ( r ) ; } public void appendPrefix ( String prefix ) { PropertyRef r = new PropertyRef ( ) ; r . setPrefix ( prefix ) ; addPropertyref ( r ) ; } public void appendBuiltin ( BuiltinPropertySetName b ) { PropertyRef r = new PropertyRef ( ) ; r . setBuiltin ( b ) ; addPropertyref ( r ) ; } public void setMapper ( String type , String from , String to ) { Mapper m = createMapper ( ) ; Mapper . MapperType mapperType = new Mapper . MapperType ( ) ; mapperType . setValue ( type ) ; m . setType ( mapperType ) ; m . setFrom ( from ) ; m . setTo ( to ) ; } public void addPropertyref ( PropertyRef ref ) { assertNotReference ( ) ; ptyRefs . addElement ( ref ) ; } public void addPropertyset ( PropertySet ref ) { assertNotReference ( ) ; setRefs . addElement ( ref ) ; } public Mapper createMapper ( ) { assertNotReference ( ) ; if ( mapper != null ) { throw new BuildException ( "Too many <mapper>s!" ) ; } mapper = new Mapper ( getProject ( ) ) ; return mapper ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setDynamic ( boolean dynamic ) { assertNotReference ( ) ; this . dynamic = dynamic ; } public void setNegate ( boolean negate ) { assertNotReference ( ) ; this . negate = negate ; } public boolean getDynamic ( ) { return isReference ( ) ? getRef ( ) . dynamic : dynamic ; } public Mapper getMapper ( ) { return isReference ( ) ? getRef ( ) . mapper : mapper ; } private Hashtable getAllSystemProperties ( ) { Hashtable ret = new Hashtable ( ) ; for ( Enumeration e = System . getProperties ( ) . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; ret . put ( name , System . getProperties ( ) . getProperty ( name ) ) ; } return ret ; } public Properties getProperties ( ) { if ( isReference ( ) ) { return getRef ( ) . getProperties ( ) ; } Set names = null ; Project prj = getProject ( ) ; Hashtable props = prj == null ? getAllSystemProperties ( ) : prj . getProperties ( ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; props . putAll ( set . getProperties ( ) ) ; } if ( getDynamic ( ) || cachedNames == null ) { names = new HashSet ( ) ; addPropertyNames ( names , props ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; names . addAll ( set . getProperties ( ) . keySet ( ) ) ; } if ( negate ) { HashSet complement = new HashSet ( props . keySet ( ) ) ; complement . removeAll ( names ) ; names = complement ; } if ( ! getDynamic ( ) ) { cachedNames = names ; } } else { names = cachedNames ; } FileNameMapper m = null ; Mapper myMapper = getMapper ( ) ; if ( myMapper != null ) { m = myMapper . getImplementation ( ) ; } Properties properties = new Properties ( ) ; for ( Iterator iter = names . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; String value = ( String ) props . get ( name ) ; if ( value != null ) { if ( m != null ) { String [ ] newname = m . mapFileName ( name ) ; if ( newname != null ) { name = newname [ 0 ] ; } } properties . setProperty ( name , value ) ; } } return properties ; } private void addPropertyNames ( Set names , Hashtable properties ) { for ( Enumeration e = ptyRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertyRef r = ( PropertyRef ) e . nextElement ( ) ; if ( r . name != null ) { if ( properties . get ( r . name ) != null ) { names . add ( r . name ) ; } } else if ( r . prefix != null ) { for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( name . startsWith ( r . prefix ) ) { names . add ( name ) ; } } } else if ( r . regex != null ) { RegexpMatcherFactory matchMaker = new RegexpMatcherFactory ( ) ; RegexpMatcher matcher = matchMaker . newRegexpMatcher ( ) ; matcher . setPattern ( r . regex ) ; for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( matcher . matches ( name ) ) { names . add ( name ) ; } } } else if ( r . builtin != null ) { if ( r . builtin . equals ( BuiltinPropertySetName . ALL ) ) { names . addAll ( properties . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . SYSTEM ) ) { names . addAll ( System . getProperties ( ) . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . COMMANDLINE ) ) { names . addAll ( getProject ( ) . getUserProperties ( ) . keySet ( ) ) ; } else { throw new BuildException ( "Impossible: Invalid builtin " + "attribute!" ) ; } } else { throw new BuildException ( "Impossible: Invalid PropertyRef!" ) ; } } } protected PropertySet getRef ( ) { return ( PropertySet ) getCheckedRef ( PropertySet . class , "propertyset" ) ; } public final void setRefid ( Reference r ) { if ( ! noAttributeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected final void assertNotReference ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } noAttributeSet = false ; } private boolean noAttributeSet = true ; public static class BuiltinPropertySetName extends EnumeratedAttribute { static final String ALL = "all" ; static final String SYSTEM = "system" ; static final String COMMANDLINE = "commandline" ; public String [ ] getValues ( ) { return new String [ ] { ALL , SYSTEM , COMMANDLINE } ; } } public String toString ( ) { StringBuffer b = new StringBuffer ( ) ; TreeMap sorted = new TreeMap ( getProperties ( ) ) ; for ( Iterator i = sorted . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; if ( b . length ( ) != 0 ) { b . append ( ", " ) ; } b . append ( e . getKey ( ) . toString ( ) ) ; b . append ( "=" ) ; b . append ( e . getValue ( ) . toString ( ) ) ; } return b . toString ( ) ; } public Iterator iterator ( ) { final Enumeration e = getProperties ( ) . propertyNames ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return new PropertyResource ( getProject ( ) , ( String ) e . nextElement ( ) ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public int size ( ) { return isReference ( ) ? getRef ( ) . size ( ) : getProperties ( ) . size ( ) ; } public boolean isFilesystemOnly ( ) { return isReference ( ) && getRef ( ) . isFilesystemOnly ( ) ; } } 	0	['24', '3', '0', '21', '96', '246', '9', '13', '20', '0.722826087', '610', '0.875', '1', '0.566037736', '0.154166667', '1', '1', '24.08333333', '14', '2.5417', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class ServerDeploy extends Task { private String action ; private File source ; private Vector vendorTools = new Vector ( ) ; public void addGeneric ( GenericHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addWeblogic ( WebLogicHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addJonas ( JonasHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = vendorTools . elements ( ) ; e . hasMoreElements ( ) ; ) { HotDeploymentTool tool = ( HotDeploymentTool ) e . nextElement ( ) ; tool . validateAttributes ( ) ; tool . deploy ( ) ; } } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } public File getSource ( ) { return source ; } public void setSource ( File source ) { this . source = source ; } } 	0	['9', '3', '0', '7', '20', '12', '5', '6', '9', '0.75', '75', '1', '0', '0.822222222', '0.259259259', '0', '0', '7', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public class JspNameMangler implements JspMangler { public static final String [ ] keywords = { "assert" , "abstract" , "boolean" , "break" , "byte" , "case" , "catch" , "char" , "class" , "const" , "continue" , "default" , "do" , "double" , "else" , "extends" , "final" , "finally" , "float" , "for" , "goto" , "if" , "implements" , "import" , "instanceof" , "int" , "interface" , "long" , "native" , "new" , "package" , "private" , "protected" , "public" , "return" , "short" , "static" , "super" , "switch" , "synchronized" , "this" , "throw" , "throws" , "transient" , "try" , "void" , "volatile" , "while" } ; public String mapJspToJavaName ( File jspFile ) { return mapJspToBaseName ( jspFile ) + ".java" ; } private String mapJspToBaseName ( File jspFile ) { String className ; className = stripExtension ( jspFile ) ; for ( int i = 0 ; i < keywords . length ; ++ i ) { if ( className . equals ( keywords [ i ] ) ) { className += "%" ; break ; } } StringBuffer modifiedClassName = new StringBuffer ( className . length ( ) ) ; char firstChar = className . charAt ( 0 ) ; if ( Character . isJavaIdentifierStart ( firstChar ) ) { modifiedClassName . append ( firstChar ) ; } else { modifiedClassName . append ( mangleChar ( firstChar ) ) ; } for ( int i = 1 ; i < className . length ( ) ; i ++ ) { char subChar = className . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( subChar ) ) { modifiedClassName . append ( subChar ) ; } else { modifiedClassName . append ( mangleChar ( subChar ) ) ; } } return modifiedClassName . toString ( ) ; } private String stripExtension ( File jspFile ) { String className ; String filename = jspFile . getName ( ) ; if ( filename . endsWith ( ".jsp" ) ) { className = filename . substring ( 0 , filename . length ( ) - 4 ) ; } else { className = filename ; } return className ; } private static String mangleChar ( char ch ) { if ( ch == File . separatorChar ) { ch = '/' ; } String s = Integer . toHexString ( ch ) ; int nzeros = 5 - s . length ( ) ; char [ ] result = new char [ 6 ] ; result [ 0 ] = '_' ; for ( int i = 1 ; i <= nzeros ; ++ i ) { result [ i ] = '0' ; } int resultIndex = 0 ; for ( int i = nzeros + 1 ; i < 6 ; ++ i ) { result [ i ] = s . charAt ( resultIndex ++ ) ; } return new String ( result ) ; } public String mapPath ( String path ) { return null ; } } 	0	['7', '1', '0', '2', '24', '19', '1', '1', '3', '0.666666667', '373', '0', '0', '0', '0.416666667', '0', '0', '52.14285714', '6', '2', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkdir extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNoco = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKDIR ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOCHECKOUT = "-nco" ; } 	0	['11', '4', '0', '7', '33', '37', '0', '7', '8', '0.9', '178', '0.428571429', '0', '0.827586207', '0.386363636', '2', '3', '14.54545455', '4', '1.3636', '0']
package org . apache . tools . ant . taskdefs . optional ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . XmlConstants ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . ParserConfigurationException ; import java . util . Iterator ; import java . util . HashMap ; import java . io . File ; import java . net . MalformedURLException ; public class SchemaValidate extends XMLValidateTask { private HashMap schemaLocations = new HashMap ( ) ; private boolean fullChecking = true ; private boolean disableDTD = false ; private SchemaLocation anonymousSchema ; public static final String ERROR_SAX_1 = "SAX1 parsers are not supported" ; public static final String ERROR_NO_XSD_SUPPORT = "Parser does not support Xerces or JAXP schema features" ; public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS = "Only one of defaultSchemaFile and defaultSchemaURL allowed" ; public static final String ERROR_PARSER_CREATION_FAILURE = "Could not create parser" ; public static final String MESSAGE_ADDING_SCHEMA = "Adding schema " ; public static final String ERROR_DUPLICATE_SCHEMA = "Duplicate declaration of schema " ; public void init ( ) throws BuildException { super . init ( ) ; setLenient ( false ) ; } public boolean enableXercesSchemaValidation ( ) { try { setFeature ( XmlConstants . FEATURE_XSD , true ) ; setNoNamespaceSchemaProperty ( XmlConstants . PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } private void setNoNamespaceSchemaProperty ( String property ) { String anonSchema = getNoNamespaceSchemaURL ( ) ; if ( anonSchema != null ) { setProperty ( property , anonSchema ) ; } } public boolean enableJAXP12SchemaValidation ( ) { try { setProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_LANGUAGE , XmlConstants . URI_XSD ) ; setNoNamespaceSchemaProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_SOURCE ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void addConfiguredSchema ( SchemaLocation location ) { log ( "adding schema " + location , Project . MSG_DEBUG ) ; location . validateNamespace ( ) ; SchemaLocation old = ( SchemaLocation ) schemaLocations . get ( location . getNamespace ( ) ) ; if ( old != null && ! old . equals ( location ) ) { throw new BuildException ( ERROR_DUPLICATE_SCHEMA + location ) ; } schemaLocations . put ( location . getNamespace ( ) , location ) ; } public void setFullChecking ( boolean fullChecking ) { this . fullChecking = fullChecking ; } protected void createAnonymousSchema ( ) { if ( anonymousSchema == null ) { anonymousSchema = new SchemaLocation ( ) ; } anonymousSchema . setNamespace ( "(no namespace)" ) ; } public void setNoNamespaceURL ( String defaultSchemaURL ) { createAnonymousSchema ( ) ; this . anonymousSchema . setUrl ( defaultSchemaURL ) ; } public void setNoNamespaceFile ( File defaultSchemaFile ) { createAnonymousSchema ( ) ; this . anonymousSchema . setFile ( defaultSchemaFile ) ; } public void setDisableDTD ( boolean disableDTD ) { this . disableDTD = disableDTD ; } protected void initValidator ( ) { super . initValidator ( ) ; if ( isSax1Parser ( ) ) { throw new BuildException ( ERROR_SAX_1 ) ; } setFeature ( XmlConstants . FEATURE_NAMESPACES , true ) ; if ( ! enableXercesSchemaValidation ( ) && ! enableJAXP12SchemaValidation ( ) ) { throw new BuildException ( ERROR_NO_XSD_SUPPORT ) ; } setFeature ( XmlConstants . FEATURE_XSD_FULL_VALIDATION , fullChecking ) ; setFeatureIfSupported ( XmlConstants . FEATURE_DISALLOW_DTD , disableDTD ) ; addSchemaLocations ( ) ; } protected XMLReader createDefaultReader ( ) { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setValidating ( true ) ; factory . setNamespaceAware ( true ) ; XMLReader reader = null ; try { SAXParser saxParser = factory . newSAXParser ( ) ; reader = saxParser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } catch ( SAXException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } return reader ; } protected void addSchemaLocations ( ) { Iterator it = schemaLocations . values ( ) . iterator ( ) ; StringBuffer buffer = new StringBuffer ( ) ; int count = 0 ; while ( it . hasNext ( ) ) { if ( count > 0 ) { buffer . append ( ' ' ) ; } SchemaLocation schemaLocation = ( SchemaLocation ) it . next ( ) ; String tuple = schemaLocation . getURIandLocation ( ) ; buffer . append ( tuple ) ; log ( "Adding schema " + tuple , Project . MSG_VERBOSE ) ; count ++ ; } if ( count > 0 ) { setProperty ( XmlConstants . PROPERTY_SCHEMA_LOCATION , buffer . toString ( ) ) ; } } protected String getNoNamespaceSchemaURL ( ) { if ( anonymousSchema == null ) { return null ; } else { return anonymousSchema . getSchemaLocationURL ( ) ; } } protected void setFeatureIfSupported ( String feature , boolean value ) { try { getXmlReader ( ) . setFeature ( feature , value ) ; } catch ( SAXNotRecognizedException e ) { log ( "Not recognizied: " + feature , Project . MSG_VERBOSE ) ; } catch ( SAXNotSupportedException e ) { log ( "Not supported: " + feature , Project . MSG_VERBOSE ) ; } } protected void onSuccessfulValidation ( int fileProcessed ) { log ( fileProcessed + MESSAGE_FILES_VALIDATED , Project . MSG_VERBOSE ) ; } public static class SchemaLocation { private String namespace ; private File file ; private String url ; public static final String ERROR_NO_URI = "No namespace URI" ; public static final String ERROR_TWO_LOCATIONS = "Both URL and File were given for schema " ; public static final String ERROR_NO_FILE = "File not found: " ; public static final String ERROR_NO_URL_REPRESENTATION = "Cannot make a URL of " ; public static final String ERROR_NO_LOCATION = "No file or URL supplied for the schema " ; public SchemaLocation ( ) { } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public String getSchemaLocationURL ( ) { boolean hasFile = file != null ; boolean hasURL = isSet ( url ) ; if ( ! hasFile && ! hasURL ) { throw new BuildException ( ERROR_NO_LOCATION + namespace ) ; } if ( hasFile && hasURL ) { throw new BuildException ( ERROR_TWO_LOCATIONS + namespace ) ; } String schema = url ; if ( hasFile ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_NO_FILE + file ) ; } try { schema = FileUtils . getFileUtils ( ) . getFileURL ( file ) . toString ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_REPRESENTATION + file , e ) ; } } return schema ; } public String getURIandLocation ( ) throws BuildException { validateNamespace ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace ) ; buffer . append ( ' ' ) ; buffer . append ( getSchemaLocationURL ( ) ) ; return new String ( buffer ) ; } public void validateNamespace ( ) { if ( ! isSet ( getNamespace ( ) ) ) { throw new BuildException ( ERROR_NO_URI ) ; } } private boolean isSet ( String property ) { return property != null && property . length ( ) != 0 ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof SchemaLocation ) ) { return false ; } final SchemaLocation schemaLocation = ( SchemaLocation ) o ; if ( file != null ? ! file . equals ( schemaLocation . file ) : schemaLocation . file != null ) { return false ; } if ( namespace != null ? ! namespace . equals ( schemaLocation . namespace ) : schemaLocation . namespace != null ) { return false ; } if ( url != null ? ! url . equals ( schemaLocation . url ) : schemaLocation . url != null ) { return false ; } return true ; } public int hashCode ( ) { int result ; result = ( namespace != null ? namespace . hashCode ( ) : 0 ) ; result = 29 * result + ( file != null ? file . hashCode ( ) : 0 ) ; result = 29 * result + ( url != null ? url . hashCode ( ) : 0 ) ; return result ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace != null ? namespace : "(anonymous)" ) ; buffer . append ( ' ' ) ; buffer . append ( url != null ? ( url + " " ) : "" ) ; buffer . append ( file != null ? file . getAbsolutePath ( ) : "" ) ; return buffer . toString ( ) ; } } } 	0	['17', '4', '0', '3', '58', '108', '0', '3', '9', '0.95625', '345', '0.4', '1', '0.8', '0.254901961', '2', '6', '18.70588235', '4', '1.5882', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkelem extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mNoco = false ; private boolean mCheckin = false ; private boolean mMaster = false ; private String mEltype = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKELEM ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getNoCheckout ( ) && getCheckin ( ) ) { throw new BuildException ( "Should choose either [nocheckout | checkin]" ) ; } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } if ( getCheckin ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CHECKIN ) ; if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } if ( getMaster ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_MASTER ) ; } if ( getEltype ( ) != null ) { getEltypeCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } public void setCheckin ( boolean ci ) { mCheckin = ci ; } public boolean getCheckin ( ) { return mCheckin ; } public void setMaster ( boolean master ) { mMaster = master ; } public boolean getMaster ( ) { return mMaster ; } public void setEltype ( String eltype ) { mEltype = eltype ; } public String getEltype ( ) { return mEltype ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getEltypeCommand ( Commandline cmd ) { if ( getEltype ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_ELTYPE ) ; cmd . createArgument ( ) . setValue ( getEltype ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_NOCHECKOUT = "-nco" ; public static final String FLAG_CHECKIN = "-ci" ; public static final String FLAG_MASTER = "-master" ; public static final String FLAG_ELTYPE = "-eltype" ; } 	0	['22', '4', '0', '7', '45', '183', '0', '7', '18', '0.949579832', '307', '0.470588235', '0', '0.695652174', '0.386363636', '2', '3', '12.18181818', '11', '1.5455', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private boolean alreadyInit = false ; private static final RegexpFactory FACTORY = new RegexpFactory ( ) ; private Regexp regexp = null ; private String myPattern ; private boolean setPatternPending = false ; public RegularExpression ( ) { } private void init ( Project p ) { if ( ! alreadyInit ) { this . regexp = FACTORY . newRegexp ( p ) ; alreadyInit = true ; } } private void setPattern ( ) { if ( setPatternPending ) { regexp . setPattern ( myPattern ) ; setPatternPending = false ; } } public void setPattern ( String pattern ) { if ( regexp == null ) { myPattern = pattern ; setPatternPending = true ; } else { regexp . setPattern ( pattern ) ; } } public String getPattern ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } setPattern ( ) ; return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } setPattern ( ) ; return this . regexp ; } public RegularExpression getRef ( Project p ) { return ( RegularExpression ) getCheckedRef ( p ) ; } } 	0	['8', '3', '0', '10', '15', '0', '6', '4', '5', '0.595238095', '110', '0.833333333', '2', '0.833333333', '0.571428571', '0', '0', '12', '2', '1.375', '0']
package org . apache . tools . ant . types . resources ; import java . util . Set ; import java . util . HashSet ; import java . util . Iterator ; import java . util . WeakHashMap ; import java . util . NoSuchElementException ; import java . util . ConcurrentModificationException ; class FailFast implements Iterator { private static final WeakHashMap MAP = new WeakHashMap ( ) ; static synchronized void invalidate ( Object o ) { Set s = ( Set ) ( MAP . get ( o ) ) ; if ( s != null ) { s . clear ( ) ; } } private static synchronized void add ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s == null ) { s = new HashSet ( ) ; MAP . put ( f . parent , s ) ; } s . add ( f ) ; } private static synchronized void remove ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s != null ) { s . remove ( f ) ; } } private static synchronized void failFast ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( ! s . contains ( f ) ) { throw new ConcurrentModificationException ( ) ; } } private Object parent ; private Iterator wrapped ; FailFast ( Object o , Iterator i ) { if ( o == null ) { throw new IllegalArgumentException ( "parent object is null" ) ; } if ( i == null ) { throw new IllegalArgumentException ( "cannot wrap null iterator" ) ; } parent = o ; if ( i . hasNext ( ) ) { wrapped = i ; add ( this ) ; } } public boolean hasNext ( ) { if ( wrapped == null ) { return false ; } failFast ( this ) ; return wrapped . hasNext ( ) ; } public Object next ( ) { if ( wrapped == null || ! wrapped . hasNext ( ) ) { throw new NoSuchElementException ( ) ; } failFast ( this ) ; try { return wrapped . next ( ) ; } finally { if ( ! wrapped . hasNext ( ) ) { wrapped = null ; remove ( this ) ; } } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	0	['9', '1', '0', '5', '24', '4', '5', '0', '3', '0.416666667', '156', '1', '0', '0', '0.3125', '0', '0', '16', '6', '1.8889', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . io . IOException ; public class CopyPath extends Task { public static final String ERROR_NO_DESTDIR = "No destDir specified" ; public static final String ERROR_NO_PATH = "No path specified" ; public static final String ERROR_NO_MAPPER = "No mapper specified" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private FileNameMapper mapper ; private Path path ; private File destDir ; private long granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; private boolean preserveLastModified = false ; public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void add ( FileNameMapper newmapper ) { if ( mapper != null ) { throw new BuildException ( "Only one mapper allowed" ) ; } mapper = newmapper ; } public void setPath ( Path s ) { createPath ( ) . append ( s ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void setPreserveLastModified ( boolean preserveLastModified ) { this . preserveLastModified = preserveLastModified ; } protected void validateAttributes ( ) throws BuildException { if ( destDir == null ) { throw new BuildException ( ERROR_NO_DESTDIR ) ; } if ( mapper == null ) { throw new BuildException ( ERROR_NO_MAPPER ) ; } if ( path == null ) { throw new BuildException ( ERROR_NO_PATH ) ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; String [ ] sourceFiles = path . list ( ) ; if ( sourceFiles . length == 0 ) { log ( "Path is empty" , Project . MSG_VERBOSE ) ; return ; } for ( int sources = 0 ; sources < sourceFiles . length ; sources ++ ) { String sourceFileName = sourceFiles [ sources ] ; File sourceFile = new File ( sourceFileName ) ; String [ ] toFiles = ( String [ ] ) mapper . mapFileName ( sourceFileName ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String destFileName = toFiles [ i ] ; File destFile = new File ( destDir , destFileName ) ; if ( sourceFile . equals ( destFile ) ) { log ( "Skipping self-copy of " + sourceFileName , Project . MSG_VERBOSE ) ; continue ; } if ( sourceFile . isDirectory ( ) ) { log ( "Skipping directory " + sourceFileName ) ; continue ; } try { log ( "Copying " + sourceFile + " to " + destFile , Project . MSG_VERBOSE ) ; FILE_UTILS . copyFile ( sourceFile , destFile , null , null , false , preserveLastModified , null , null , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + sourceFile + " to " + destFile + " due to " + ioe . getMessage ( ) ; if ( destFile . exists ( ) && ! destFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + destFile ; } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } } 	0	['11', '3', '0', '9', '38', '29', '0', '9', '9', '0.888888889', '260', '0.666666667', '3', '0.804347826', '0.228571429', '3', '3', '21.81818182', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { classpath . append ( p ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '8', '26', '1', '1', '7', '2', '2', '149', '0', '0', '0.958333333', '1', '0', '0', '73.5', '1', '0.5', '0']
package org . apache . tools . ant . types . resolver ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . ResourceLocation ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogManager ; import org . apache . xml . resolver . tools . CatalogResolver ; public class ApacheCatalogResolver extends CatalogResolver { private XMLCatalog xmlCatalog = null ; static { CatalogManager . getStaticManager ( ) . setIgnoreMissingProperties ( true ) ; System . getProperties ( ) . put ( "xml.catalog.className" , ApacheCatalog . class . getName ( ) ) ; CatalogManager . getStaticManager ( ) . setUseStaticCatalog ( false ) ; } public void setXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog = xmlCatalog ; } public void parseCatalog ( String file ) { Catalog catalog = getCatalog ( ) ; if ( ! ( catalog instanceof ApacheCatalog ) ) { throw new BuildException ( "Wrong catalog type found: " + catalog . getClass ( ) . getName ( ) ) ; } ApacheCatalog apacheCatalog = ( ApacheCatalog ) catalog ; apacheCatalog . setResolver ( this ) ; try { apacheCatalog . parseCatalog ( file ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( ex ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } public void addPublicEntry ( String publicid , String systemid , URL base ) { ResourceLocation dtd = new ResourceLocation ( ) ; dtd . setBase ( base ) ; dtd . setPublicId ( publicid ) ; dtd . setLocation ( systemid ) ; xmlCatalog . addDTD ( dtd ) ; } public void addURIEntry ( String uri , String altURI , URL base ) { ResourceLocation entity = new ResourceLocation ( ) ; entity . setBase ( base ) ; entity . setPublicId ( uri ) ; entity . setLocation ( altURI ) ; xmlCatalog . addEntity ( entity ) ; } } 	0	['6', '2', '0', '7', '31', '3', '1', '7', '5', '0.7', '123', '0.5', '1', '0.6', '0.55', '0', '0', '19.16666667', '2', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . util . StringUtils ; public final class Specification { private static final String MISSING = "Missing " ; public static final Attributes . Name SPECIFICATION_TITLE = Attributes . Name . SPECIFICATION_TITLE ; public static final Attributes . Name SPECIFICATION_VERSION = Attributes . Name . SPECIFICATION_VERSION ; public static final Attributes . Name SPECIFICATION_VENDOR = Attributes . Name . SPECIFICATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_TITLE = Attributes . Name . IMPLEMENTATION_TITLE ; public static final Attributes . Name IMPLEMENTATION_VERSION = Attributes . Name . IMPLEMENTATION_VERSION ; public static final Attributes . Name IMPLEMENTATION_VENDOR = Attributes . Name . IMPLEMENTATION_VENDOR ; public static final Compatibility COMPATIBLE = new Compatibility ( "COMPATIBLE" ) ; public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE = new Compatibility ( "REQUIRE_SPECIFICATION_UPGRADE" ) ; public static final Compatibility REQUIRE_VENDOR_SWITCH = new Compatibility ( "REQUIRE_VENDOR_SWITCH" ) ; public static final Compatibility REQUIRE_IMPLEMENTATION_CHANGE = new Compatibility ( "REQUIRE_IMPLEMENTATION_CHANGE" ) ; public static final Compatibility INCOMPATIBLE = new Compatibility ( "INCOMPATIBLE" ) ; private String specificationTitle ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationTitle ; private String implementationVendor ; private String implementationVersion ; private String [ ] sections ; public static Specification [ ] getSpecifications ( final Manifest manifest ) throws ParseException { if ( null == manifest ) { return new Specification [ 0 ] ; } final ArrayList results = new ArrayList ( ) ; final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; final Specification specification = getSpecification ( key , attributes ) ; if ( null != specification ) { results . add ( specification ) ; } } final ArrayList trimmedResults = removeDuplicates ( results ) ; return ( Specification [ ] ) trimmedResults . toArray ( new Specification [ trimmedResults . size ( ) ] ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor ) { this ( specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , null ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor , final String [ ] sections ) { this . specificationTitle = specificationTitle ; this . specificationVendor = specificationVendor ; if ( null != specificationVersion ) { try { this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad specification version format '" + specificationVersion + "' in '" + specificationTitle + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } this . implementationTitle = implementationTitle ; this . implementationVendor = implementationVendor ; this . implementationVersion = implementationVersion ; if ( null == this . specificationTitle ) { throw new NullPointerException ( "specificationTitle" ) ; } String [ ] copy = null ; if ( null != sections ) { copy = new String [ sections . length ] ; System . arraycopy ( sections , 0 , copy , 0 , sections . length ) ; } this . sections = copy ; } public String getSpecificationTitle ( ) { return specificationTitle ; } public String getSpecificationVendor ( ) { return specificationVendor ; } public String getImplementationTitle ( ) { return implementationTitle ; } public DeweyDecimal getSpecificationVersion ( ) { return specificationVersion ; } public String getImplementationVendor ( ) { return implementationVendor ; } public String getImplementationVersion ( ) { return implementationVersion ; } public String [ ] getSections ( ) { if ( null == sections ) { return null ; } final String [ ] newSections = new String [ sections . length ] ; System . arraycopy ( sections , 0 , newSections , 0 , sections . length ) ; return newSections ; } public Compatibility getCompatibilityWith ( final Specification other ) { if ( ! specificationTitle . equals ( other . getSpecificationTitle ( ) ) ) { return INCOMPATIBLE ; } final DeweyDecimal otherSpecificationVersion = other . getSpecificationVersion ( ) ; if ( null != specificationVersion ) { if ( null == otherSpecificationVersion || ! isCompatible ( specificationVersion , otherSpecificationVersion ) ) { return REQUIRE_SPECIFICATION_UPGRADE ; } } final String otherImplementationVendor = other . getImplementationVendor ( ) ; if ( null != implementationVendor ) { if ( null == otherImplementationVendor || ! implementationVendor . equals ( otherImplementationVendor ) ) { return REQUIRE_VENDOR_SWITCH ; } } final String otherImplementationVersion = other . getImplementationVersion ( ) ; if ( null != implementationVersion ) { if ( null == otherImplementationVersion || ! implementationVersion . equals ( otherImplementationVersion ) ) { return REQUIRE_IMPLEMENTATION_CHANGE ; } } return COMPATIBLE ; } public boolean isCompatibleWith ( final Specification other ) { return ( COMPATIBLE == getCompatibilityWith ( other ) ) ; } public String toString ( ) { final String brace = ": " ; final StringBuffer sb = new StringBuffer ( SPECIFICATION_TITLE . toString ( ) ) ; sb . append ( brace ) ; sb . append ( specificationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( null != specificationVersion ) { sb . append ( SPECIFICATION_VERSION ) ; sb . append ( brace ) ; sb . append ( specificationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != specificationVendor ) { sb . append ( SPECIFICATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( specificationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationTitle ) { sb . append ( IMPLEMENTATION_TITLE ) ; sb . append ( brace ) ; sb . append ( implementationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVersion ) { sb . append ( IMPLEMENTATION_VERSION ) ; sb . append ( brace ) ; sb . append ( implementationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendor ) { sb . append ( IMPLEMENTATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( implementationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } return sb . toString ( ) ; } private boolean isCompatible ( final DeweyDecimal first , final DeweyDecimal second ) { return first . isGreaterThanOrEqual ( second ) ; } private static ArrayList removeDuplicates ( final ArrayList list ) { final ArrayList results = new ArrayList ( ) ; final ArrayList sections = new ArrayList ( ) ; while ( list . size ( ) > 0 ) { final Specification specification = ( Specification ) list . remove ( 0 ) ; final Iterator iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { final Specification other = ( Specification ) iterator . next ( ) ; if ( isEqual ( specification , other ) ) { final String [ ] otherSections = other . getSections ( ) ; if ( null != sections ) { sections . addAll ( Arrays . asList ( otherSections ) ) ; } iterator . remove ( ) ; } } final Specification merged = mergeInSections ( specification , sections ) ; results . add ( merged ) ; sections . clear ( ) ; } return results ; } private static boolean isEqual ( final Specification specification , final Specification other ) { return specification . getSpecificationTitle ( ) . equals ( other . getSpecificationTitle ( ) ) && specification . getSpecificationVersion ( ) . isEqual ( other . getSpecificationVersion ( ) ) && specification . getSpecificationVendor ( ) . equals ( other . getSpecificationVendor ( ) ) && specification . getImplementationTitle ( ) . equals ( other . getImplementationTitle ( ) ) && specification . getImplementationVersion ( ) . equals ( other . getImplementationVersion ( ) ) && specification . getImplementationVendor ( ) . equals ( other . getImplementationVendor ( ) ) ; } private static Specification mergeInSections ( final Specification specification , final ArrayList sectionsToAdd ) { if ( 0 == sectionsToAdd . size ( ) ) { return specification ; } sectionsToAdd . addAll ( Arrays . asList ( specification . getSections ( ) ) ) ; final String [ ] sections = ( String [ ] ) sectionsToAdd . toArray ( new String [ sectionsToAdd . size ( ) ] ) ; return new Specification ( specification . getSpecificationTitle ( ) , specification . getSpecificationVersion ( ) . toString ( ) , specification . getSpecificationVendor ( ) , specification . getImplementationTitle ( ) , specification . getImplementationVersion ( ) , specification . getImplementationVendor ( ) , sections ) ; } private static String getTrimmedString ( final String value ) { return value == null ? null : value . trim ( ) ; } private static Specification getSpecification ( final String section , final Attributes attributes ) throws ParseException { final String name = getTrimmedString ( attributes . getValue ( SPECIFICATION_TITLE ) ) ; if ( null == name ) { return null ; } final String specVendor = getTrimmedString ( attributes . getValue ( SPECIFICATION_VENDOR ) ) ; if ( null == specVendor ) { throw new ParseException ( MISSING + SPECIFICATION_VENDOR , 0 ) ; } final String specVersion = getTrimmedString ( attributes . getValue ( SPECIFICATION_VERSION ) ) ; if ( null == specVersion ) { throw new ParseException ( MISSING + SPECIFICATION_VERSION , 0 ) ; } final String impTitle = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_TITLE ) ) ; if ( null == impTitle ) { throw new ParseException ( MISSING + IMPLEMENTATION_TITLE , 0 ) ; } final String impVersion = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VERSION ) ) ; if ( null == impVersion ) { throw new ParseException ( MISSING + IMPLEMENTATION_VERSION , 0 ) ; } final String impVendor = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VENDOR ) ) ; if ( null == impVendor ) { throw new ParseException ( MISSING + IMPLEMENTATION_VENDOR , 0 ) ; } return new Specification ( name , specVersion , specVendor , impTitle , impVersion , impVendor , new String [ ] { section } ) ; } } 	0	['20', '1', '0', '5', '54', '138', '1', '4', '13', '0.789473684', '703', '0.421052632', '6', '0', '0.177631579', '0', '0', '33.2', '11', '2.3', '0']
package org . apache . tools . ant . taskdefs . optional . script ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicConfigurator ; import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; public class ScriptDefBase extends Task implements DynamicConfigurator { private Map nestedElementMap = new HashMap ( ) ; private Map attributes = new HashMap ( ) ; private String text ; public void execute ( ) { getScript ( ) . executeScript ( attributes , nestedElementMap , this ) ; } private ScriptDef getScript ( ) { String name = getTaskType ( ) ; Map scriptRepository = ( Map ) getProject ( ) . getReference ( MagicNames . SCRIPT_REPOSITORY ) ; if ( scriptRepository == null ) { throw new BuildException ( "Script repository not found for " + name ) ; } ScriptDef definition = ( ScriptDef ) scriptRepository . get ( getTaskType ( ) ) ; if ( definition == null ) { throw new BuildException ( "Script definition not found for " + name ) ; } return definition ; } public Object createDynamicElement ( String name ) { List nestedElementList = ( List ) nestedElementMap . get ( name ) ; if ( nestedElementList == null ) { nestedElementList = new ArrayList ( ) ; nestedElementMap . put ( name , nestedElementList ) ; } Object element = getScript ( ) . createNestedElement ( name ) ; nestedElementList . add ( element ) ; return element ; } public void setDynamicAttribute ( String name , String value ) { ScriptDef definition = getScript ( ) ; if ( ! definition . isAttributeSupported ( name ) ) { throw new BuildException ( "<" + getTaskType ( ) + "> does not support the \"" + name + "\" attribute" ) ; } attributes . put ( name , value ) ; } public void addText ( String text ) { this . text = getProject ( ) . replaceProperties ( text ) ; } public String getText ( ) { return text ; } public void fail ( String message ) { throw new BuildException ( message ) ; } } 	0	['8', '3', '0', '5', '25', '16', '1', '5', '7', '0.761904762', '152', '1', '0', '0.840909091', '0.75', '0', '0', '17.625', '3', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUpdate extends ClearCase { private boolean mGraphical = false ; private boolean mOverwrite = false ; private boolean mRename = false ; private boolean mCtime = false ; private boolean mPtime = false ; private String mLog = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UPDATE ) ; checkOptions ( commandLine ) ; getProject ( ) . log ( commandLine . toString ( ) , Project . MSG_DEBUG ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getGraphical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_GRAPHICAL ) ; } else { if ( getOverwrite ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OVERWRITE ) ; } else { if ( getRename ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RENAME ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOVERWRITE ) ; } } if ( getCurrentTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CURRENTTIME ) ; } else { if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } getLogCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setGraphical ( boolean graphical ) { mGraphical = graphical ; } public boolean getGraphical ( ) { return mGraphical ; } public void setOverwrite ( boolean ow ) { mOverwrite = ow ; } public boolean getOverwrite ( ) { return mOverwrite ; } public void setRename ( boolean ren ) { mRename = ren ; } public boolean getRename ( ) { return mRename ; } public void setCurrentTime ( boolean ct ) { mCtime = ct ; } public boolean getCurrentTime ( ) { return mCtime ; } public void setPreserveTime ( boolean pt ) { mPtime = pt ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setLog ( String log ) { mLog = log ; } public String getLog ( ) { return mLog ; } private void getLogCommand ( Commandline cmd ) { if ( getLog ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_LOG ) ; cmd . createArgument ( ) . setValue ( getLog ( ) ) ; } } public static final String FLAG_GRAPHICAL = "-graphical" ; public static final String FLAG_LOG = "-log" ; public static final String FLAG_OVERWRITE = "-overwrite" ; public static final String FLAG_NOVERWRITE = "-noverwrite" ; public static final String FLAG_RENAME = "-rename" ; public static final String FLAG_CURRENTTIME = "-ctime" ; public static final String FLAG_PRESERVETIME = "-ptime" ; } 	0	['16', '4', '0', '7', '38', '84', '0', '7', '14', '0.943589744', '234', '0.461538462', '0', '0.761904762', '0.375', '2', '3', '12.8125', '6', '1.3125', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . IOException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public abstract class P4Base extends org . apache . tools . ant . Task { protected Perl5Util util = null ; protected String shell ; protected String P4Port = "" ; protected String P4Client = "" ; protected String P4User = "" ; protected String P4View = "" ; protected boolean failOnError = true ; protected String P4Opts = "" ; protected String P4CmdOpts = "" ; private boolean inError = false ; private String errorMessage = "" ; public boolean getInError ( ) { return inError ; } public void setInError ( boolean inError ) { this . inError = inError ; } public String getErrorMessage ( ) { return errorMessage ; } public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; } public void setPort ( String p4Port ) { this . P4Port = "-p" + p4Port ; } public void setClient ( String p4Client ) { this . P4Client = "-c" + p4Client ; } public void setUser ( String p4User ) { this . P4User = "-u" + p4User ; } public void setGlobalopts ( String p4Opts ) { this . P4Opts = p4Opts ; } public void setView ( String p4View ) { this . P4View = p4View ; } public void setCmdopts ( String p4CmdOpts ) { this . P4CmdOpts = p4CmdOpts ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void init ( ) { util = new Perl5Util ( ) ; String tmpprop ; if ( ( tmpprop = getProject ( ) . getProperty ( "p4.port" ) ) != null ) { setPort ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.client" ) ) != null ) { setClient ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.user" ) ) != null ) { setUser ( tmpprop ) ; } } protected void execP4Command ( String command ) throws BuildException { execP4Command ( command , null ) ; } protected void execP4Command ( String command , P4Handler handler ) throws BuildException { try { inError = false ; errorMessage = "" ; Commandline commandline = new Commandline ( ) ; commandline . setExecutable ( "p4" ) ; if ( P4Port != null && P4Port . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Port ) ; } if ( P4User != null && P4User . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4User ) ; } if ( P4Client != null && P4Client . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Client ) ; } if ( P4Opts != null && P4Opts . length ( ) != 0 ) { commandline . createArgument ( ) . setLine ( P4Opts ) ; } commandline . createArgument ( ) . setLine ( command ) ; log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; if ( handler == null ) { handler = new SimpleP4OutputHandler ( this ) ; } Execute exe = new Execute ( handler , null ) ; exe . setAntRun ( getProject ( ) ) ; exe . setCommandline ( commandline . getCommandline ( ) ) ; try { exe . execute ( ) ; if ( inError && failOnError ) { throw new BuildException ( errorMessage ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { handler . stop ( ) ; } catch ( Exception e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } catch ( Exception e ) { String failMsg = "Problem exec'ing P4 command: " + e . getMessage ( ) ; if ( failOnError ) { throw new BuildException ( failMsg ) ; } else { log ( failMsg , Project . MSG_ERR ) ; } } } } 	0	['15', '3', '15', '27', '41', '57', '17', '11', '13', '0.818181818', '312', '1', '0', '0.725490196', '0.45', '0', '0', '19.06666667', '4', '1.1333', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . List ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collection ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public class Resources extends DataType implements ResourceCollection { public static final ResourceCollection NONE = new ResourceCollection ( ) { public boolean isFilesystemOnly ( ) { return true ; } public Iterator iterator ( ) { return EMPTY_ITERATOR ; } public int size ( ) { return 0 ; } } ; public static final Iterator EMPTY_ITERATOR = new Iterator ( ) { public Object next ( ) { throw new NoSuchElementException ( ) ; } public boolean hasNext ( ) { return false ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; private class MyCollection extends AbstractCollection { private int size ; MyCollection ( ) { size = 0 ; for ( Iterator rci = getNested ( ) . iterator ( ) ; rci . hasNext ( ) ; ) { size += ( ( ResourceCollection ) rci . next ( ) ) . size ( ) ; } } public int size ( ) { return size ; } public Iterator iterator ( ) { return new MyIterator ( ) ; } private class MyIterator implements Iterator { private Iterator rci = getNested ( ) . iterator ( ) ; private Iterator ri = null ; public boolean hasNext ( ) { boolean result = ri != null && ri . hasNext ( ) ; while ( ! result && rci . hasNext ( ) ) { ri = ( ( ResourceCollection ) rci . next ( ) ) . iterator ( ) ; result = ri . hasNext ( ) ; } return result ; } public Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return ri . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } } private Vector rc ; private Collection coll ; public synchronized void add ( ResourceCollection c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc == null ) { rc = new Vector ( ) ; } rc . add ( c ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return getRef ( ) . iterator ( ) ; } validate ( ) ; return new FailFast ( this , coll . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return getRef ( ) . size ( ) ; } validate ( ) ; return coll . size ( ) ; } public boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return getRef ( ) . isFilesystemOnly ( ) ; } validate ( ) ; for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ( ! ( ( ResourceCollection ) i . next ( ) ) . isFilesystemOnly ( ) ) ) { return false ; } } return true ; } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( coll == null || coll . isEmpty ( ) ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } setChecked ( true ) ; } } private ResourceCollection getRef ( ) { return ( ResourceCollection ) getCheckedRef ( ResourceCollection . class , "ResourceCollection" ) ; } private synchronized void validate ( ) { dieOnCircularReference ( ) ; coll = ( coll == null ) ? new MyCollection ( ) : coll ; } private synchronized List getNested ( ) { return rc == null ? Collections . EMPTY_LIST : rc ; } } 	0	['12', '3', '0', '15', '47', '44', '9', '8', '6', '0.781818182', '240', '0.4', '1', '0.75', '0.254545455', '1', '3', '18.58333333', '6', '2.1667', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . TestListener ; import org . apache . tools . ant . BuildException ; public interface JUnitResultFormatter extends TestListener , JUnitTaskMirror . JUnitResultFormatterMirror { void startTestSuite ( JUnitTest suite ) throws BuildException ; void endTestSuite ( JUnitTest suite ) throws BuildException ; void setOutput ( OutputStream out ) ; void setSystemOutput ( String out ) ; void setSystemError ( String err ) ; } 	0	['5', '1', '0', '11', '5', '10', '7', '4', '5', '2', '5', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; public interface Tokenizer { String getToken ( Reader in ) throws IOException ; String getPostToken ( ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( getInputStream ( ) ) ) ; do { System . err . println ( prompt ) ; System . err . flush ( ) ; try { String input = r . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from" + " Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to close input." , e ) ; } } } } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; String def = request . getDefaultValue ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( " (" ) ; Enumeration e = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( e . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( ", " ) ; } String next = ( String ) e . nextElement ( ) ; if ( next . equals ( def ) ) { sb . append ( '[' ) ; } sb . append ( next ) ; if ( next . equals ( def ) ) { sb . append ( ']' ) ; } first = false ; } sb . append ( ")" ) ; return sb . toString ( ) ; } else if ( def != null ) { return prompt + " [" + def + "]" ; } else { return prompt ; } } protected InputStream getInputStream ( ) { return System . in ; } } 	0	['4', '1', '1', '8', '26', '6', '4', '4', '2', '2', '152', '0', '0', '0', '0.75', '0', '0', '37', '7', '2.25', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckinDefault extends CCMCheck { public CCMCheckinDefault ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKIN ) ; setTask ( DEFAULT_TASK ) ; } public static final String DEFAULT_TASK = "default" ; } 	0	['1', '5', '0', '1', '4', '0', '0', '1', '1', '2', '11', '0', '0', '1', '1', '0', '0', '9', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0	['1', '1', '0', '36', '1', '0', '35', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . unix ; import org . apache . tools . ant . BuildException ; public class Chgrp extends AbstractAccessTask { private boolean haveGroup = false ; public Chgrp ( ) { super . setExecutable ( "chgrp" ) ; } public void setGroup ( String group ) { createArg ( ) . setValue ( group ) ; haveGroup = true ; } protected void checkConfiguration ( ) { if ( ! haveGroup ) { throw new BuildException ( "Required attribute group not set in " + "chgrp" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable" + " attribute" , getLocation ( ) ) ; } } 	0	['4', '6', '0', '4', '16', '0', '0', '4', '3', '0.333333333', '52', '1', '0', '0.973913043', '0.75', '2', '2', '11.75', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLiaison2 extends XSLTLiaison { void configure ( XSLTProcess xsltTask ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Resource ; public interface XSLTLiaison3 extends XSLTLiaison2 { void setStylesheet ( Resource stylesheet ) throws Exception ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . java15 ; import org . apache . tools . ant . BuildException ; import java . net . ProxySelector ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . Proxy ; import java . net . SocketAddress ; import java . net . InetSocketAddress ; import java . net . InetAddress ; import java . util . List ; import java . util . Iterator ; public class ProxyDiagnostics { private String destination ; private URI destURI ; public static final String DEFAULT_DESTINATION = "http://ant.apache.org/" ; public ProxyDiagnostics ( String destination ) { this . destination = destination ; try { this . destURI = new URI ( destination ) ; } catch ( URISyntaxException e ) { throw new BuildException ( e ) ; } } public ProxyDiagnostics ( ) { this ( DEFAULT_DESTINATION ) ; } public String toString ( ) { ProxySelector selector = ProxySelector . getDefault ( ) ; List list = selector . select ( destURI ) ; StringBuffer result = new StringBuffer ( ) ; Iterator proxies = list . listIterator ( ) ; while ( proxies . hasNext ( ) ) { Proxy proxy = ( Proxy ) proxies . next ( ) ; SocketAddress address = proxy . address ( ) ; if ( address == null ) { result . append ( "Direct connection\n" ) ; } else { result . append ( proxy . toString ( ) ) ; if ( address instanceof InetSocketAddress ) { InetSocketAddress ina = ( InetSocketAddress ) address ; result . append ( ' ' ) ; result . append ( ina . getHostName ( ) ) ; result . append ( ':' ) ; result . append ( ina . getPort ( ) ) ; if ( ina . isUnresolved ( ) ) { result . append ( " [unresolved]" ) ; } else { InetAddress addr = ina . getAddress ( ) ; result . append ( " [" ) ; result . append ( addr . getHostAddress ( ) ) ; result . append ( ']' ) ; } } result . append ( '\n' ) ; } } return result . toString ( ) ; } } 	0	['3', '1', '0', '1', '23', '1', '0', '1', '3', '0.666666667', '121', '0.666666667', '0', '0', '0.666666667', '0', '0', '38.33333333', '5', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import java . util . Enumeration ; public class Xor extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; boolean state = false ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; state ^= c . eval ( ) ; } return state ; } } 	0	['2', '3', '0', '3', '7', '1', '0', '3', '2', '2', '25', '0', '0', '0.96969697', '1', '0', '0', '11.5', '1', '0.5', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0	['3', '1', '0', '4', '19', '1', '0', '4', '2', '0.5', '89', '1', '0', '0', '0.5', '0', '0', '28.33333333', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FilenameFilter ; public class InnerClassFilenameFilter implements FilenameFilter { private String baseClassName ; InnerClassFilenameFilter ( String baseclass ) { int extidx = baseclass . lastIndexOf ( ".class" ) ; if ( extidx == - 1 ) { extidx = baseclass . length ( ) - 1 ; } baseClassName = baseclass . substring ( 0 , extidx ) ; } public boolean accept ( File dir , String filename ) { if ( ( filename . lastIndexOf ( "." ) != filename . lastIndexOf ( ".class" ) ) || ( filename . indexOf ( baseClassName + "$" ) != 0 ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '1', '11', '0', '1', '0', '1', '0', '47', '1', '0', '0', '0.833333333', '0', '0', '22', '3', '1.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Stack ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Quantifier ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Compare extends DataType implements ResourceSelector { private static final String ONE_CONTROL_MESSAGE = " the <control> element should be specified exactly once." ; private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; private Quantifier against = Quantifier . ALL ; private Comparison when = Comparison . EQUAL ; private Union control ; public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; } public synchronized void setAgainst ( Quantifier against ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . against = against ; } public synchronized void setWhen ( Comparison when ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . when = when ; } public synchronized ResourceCollection createControl ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( control != null ) { throw oneControl ( ) ; } control = new Union ( ) ; return control ; } public synchronized boolean isSelected ( Resource r ) { if ( isReference ( ) ) { return ( ( ResourceSelector ) getCheckedRef ( ) ) . isSelected ( r ) ; } if ( control == null ) { throw oneControl ( ) ; } int t = 0 , f = 0 ; for ( Iterator it = control . iterator ( ) ; it . hasNext ( ) ; ) { if ( when . evaluate ( comp . compare ( r , ( Resource ) it . next ( ) ) ) ) { t ++ ; } else { f ++ ; } } return against . evaluate ( t , f ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( control != null ) { DataType . invokeCircularReferenceCheck ( control , stk , p ) ; } DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } private BuildException oneControl ( ) { return new BuildException ( super . toString ( ) + ONE_CONTROL_MESSAGE ) ; } } 	0	['8', '3', '0', '11', '33', '4', '0', '11', '6', '0.771428571', '167', '1', '4', '0.810810811', '0.25', '1', '3', '19.25', '5', '2', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FloatCPInfo extends ConstantCPInfo { public FloatCPInfo ( ) { super ( CONSTANT_FLOAT , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Float ( cpStream . readFloat ( ) ) ) ; } public String toString ( ) { return "Float Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '38', '3', '3', '38', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Counter extends P4Base { public String counter = null ; public String property = null ; public boolean shouldSetValue = false ; public boolean shouldSetProperty = false ; public int value = 0 ; public void setName ( String counter ) { this . counter = counter ; } public void setValue ( int value ) { this . value = value ; shouldSetValue = true ; } public void setProperty ( String property ) { this . property = property ; shouldSetProperty = true ; } public void execute ( ) throws BuildException { if ( ( counter == null ) || counter . length ( ) == 0 ) { throw new BuildException ( "No counter specified to retrieve" ) ; } if ( shouldSetValue && shouldSetProperty ) { throw new BuildException ( "Cannot both set the value of the property and retrieve the " + "value of the property." ) ; } String command = "counter " + P4CmdOpts + " " + counter ; if ( ! shouldSetProperty ) { command = "-s " + command ; } if ( shouldSetValue ) { command += " " + value ; } if ( shouldSetProperty ) { final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( "P4Counter retrieved line \"" + line + "\"" , Project . MSG_VERBOSE ) ; try { value = Integer . parseInt ( line ) ; myProj . setProperty ( property , "" + value ) ; } catch ( NumberFormatException nfe ) { throw new BuildException ( "Perforce error. " + "Could not retrieve counter value." ) ; } } } ; execP4Command ( command , handler ) ; } else { execP4Command ( command , new SimpleP4OutputHandler ( this ) ) ; } } } 	0	['5', '4', '0', '6', '17', '0', '1', '6', '5', '0.55', '134', '0', '0', '0.927272727', '0.533333333', '1', '1', '24.8', '1', '0.8', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; public class ImmutableResourceException extends IOException { public ImmutableResourceException ( ) { super ( ) ; } public ImmutableResourceException ( String s ) { super ( s ) ; } } 	0	['2', '4', '0', '2', '4', '1', '2', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class BorlandGenerateClient extends Task { static final String JAVA_MODE = "java" ; static final String FORK_MODE = "fork" ; boolean debug = false ; File ejbjarfile = null ; File clientjarfile = null ; Path classpath ; String mode = FORK_MODE ; int version = BorlandDeploymentTool . BAS ; public void setVersion ( int version ) { this . version = version ; } public void setMode ( String s ) { mode = s ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setEjbjar ( File ejbfile ) { ejbjarfile = ejbfile ; } public void setClientjar ( File clientjar ) { clientjarfile = clientjar ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { if ( ejbjarfile == null || ejbjarfile . isDirectory ( ) ) { throw new BuildException ( "invalid ejb jar file." ) ; } if ( clientjarfile == null || clientjarfile . isDirectory ( ) ) { log ( "invalid or missing client jar file." , Project . MSG_VERBOSE ) ; String ejbjarname = ejbjarfile . getAbsolutePath ( ) ; String clientname = ejbjarname . substring ( 0 , ejbjarname . lastIndexOf ( "." ) ) ; clientname = clientname + "client.jar" ; clientjarfile = new File ( clientname ) ; } if ( mode == null ) { log ( "mode is null default mode  is java" ) ; setMode ( JAVA_MODE ) ; } if ( ! ( version == BorlandDeploymentTool . BES || version == BorlandDeploymentTool . BAS ) ) { throw new BuildException ( "version " + version + " is not supported" ) ; } log ( "client jar file is " + clientjarfile ) ; if ( mode . equalsIgnoreCase ( FORK_MODE ) ) { executeFork ( ) ; } else { executeJava ( ) ; } } protected void executeJava ( ) throws BuildException { try { if ( version == BorlandDeploymentTool . BES ) { throw new BuildException ( "java mode is supported only for " + "previous version <=" + BorlandDeploymentTool . BAS ) ; } log ( "mode : java" ) ; Java execTask = null ; execTask = new Java ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setClassname ( "com.inprise.server.commandline.EJBUtilities" ) ; execTask . setClasspath ( classpath . concatSystemClasspath ( ) ) ; execTask . setFork ( true ) ; execTask . createArg ( ) . setValue ( "generateclient" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-trace" ) ; } execTask . createArg ( ) . setValue ( "-short" ) ; execTask . createArg ( ) . setValue ( "-jarfile" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-single" ) ; execTask . createArg ( ) . setValue ( "-clientjarfile" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; log ( "Calling EJBUtilities" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void executeFork ( ) throws BuildException { if ( version == BorlandDeploymentTool . BAS ) { executeForkV4 ( ) ; } if ( version == BorlandDeploymentTool . BES ) { executeForkV5 ( ) ; } } protected void executeForkV4 ( ) throws BuildException { try { log ( "mode : fork " + BorlandDeploymentTool . BAS , Project . MSG_DEBUG ) ; ExecTask execTask = new ExecTask ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; execTask . createArg ( ) . setValue ( "generateclient" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-trace" ) ; } execTask . createArg ( ) . setValue ( "-short" ) ; execTask . createArg ( ) . setValue ( "-jarfile" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-single" ) ; execTask . createArg ( ) . setValue ( "-clientjarfile" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void executeForkV5 ( ) throws BuildException { try { log ( "mode : fork " + BorlandDeploymentTool . BES , Project . MSG_DEBUG ) ; ExecTask execTask = new ExecTask ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-debug" ) ; } execTask . createArg ( ) . setValue ( "-genclient" ) ; execTask . createArg ( ) . setValue ( "-jars" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-target" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-cp" ) ; execTask . createArg ( ) . setValue ( classpath . toString ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } 	0	['14', '3', '0', '9', '52', '15', '1', '8', '10', '0.730769231', '468', '0', '1', '0.74', '0.214285714', '2', '2', '31.85714286', '2', '1.0714', '0']
package org . apache . tools . ant . util . optional ; import java . security . Permission ; import org . apache . tools . ant . ExitException ; public class NoExitSecurityManager extends SecurityManager { public void checkExit ( int status ) { throw new ExitException ( status ) ; } public void checkPermission ( Permission perm ) { } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.954545455', '0.555555556', '1', '12', '3', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '6', '2', '0', '6', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private volatile boolean watch = false ; private Exception caught = null ; private volatile boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public ExecuteWatchdog ( int timeout ) { this ( ( long ) timeout ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; cleanUp ( ) ; } public synchronized void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected synchronized void cleanUp ( ) { watch = false ; process = null ; } public synchronized void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['9', '1', '0', '17', '23', '0', '14', '3', '8', '0.5', '141', '1', '1', '0', '0.288888889', '0', '0', '14.11111111', '4', '1.3333', '0']
package org . apache . tools . ant . util ; import java . io . OutputStream ; import java . io . IOException ; public class TeeOutputStream extends OutputStream { private OutputStream left ; private OutputStream right ; public TeeOutputStream ( OutputStream left , OutputStream right ) { this . left = left ; this . right = right ; } public void close ( ) throws IOException { try { left . close ( ) ; } finally { right . close ( ) ; } } public void flush ( ) throws IOException { left . flush ( ) ; right . flush ( ) ; } public void write ( byte [ ] b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } public void write ( byte [ ] b , int off , int len ) throws IOException { left . write ( b , off , len ) ; right . write ( b , off , len ) ; } public void write ( int b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } } 	0	['6', '2', '0', '4', '12', '0', '4', '0', '6', '0', '70', '1', '0', '0.5', '0.458333333', '1', '1', '10.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; public interface P4Handler extends ExecuteStreamHandler { void process ( String line ) throws BuildException ; void setOutput ( String line ) throws BuildException ; } 	0	['2', '1', '0', '20', '2', '1', '18', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; public class CCMkattr extends ClearCase { private boolean mReplace = false ; private boolean mRecurse = false ; private String mVersion = null ; private String mTypeName = null ; private String mTypeValue = null ; private String mComment = null ; private String mCfile = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } if ( getTypeValue ( ) == null ) { throw new BuildException ( "Required attribute TypeValue not specified" ) ; } if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKATTR ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( getVersion ( ) != null ) { getVersionCommand ( cmd ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getTypeName ( ) != null ) { getTypeCommand ( cmd ) ; } if ( getTypeValue ( ) != null ) { getTypeValueCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setRecurse ( boolean recurse ) { mRecurse = recurse ; } public boolean getRecurse ( ) { return mRecurse ; } public void setVersion ( String version ) { mVersion = version ; } public String getVersion ( ) { return mVersion ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setTypeValue ( String tv ) { mTypeValue = tv ; } public String getTypeValue ( ) { return mTypeValue ; } private void getVersionCommand ( Commandline cmd ) { if ( getVersion ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; cmd . createArgument ( ) . setValue ( getVersion ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getTypeCommand ( Commandline cmd ) { String typenm = getTypeName ( ) ; if ( typenm != null ) { cmd . createArgument ( ) . setValue ( typenm ) ; } } private void getTypeValueCommand ( Commandline cmd ) { String typevl = getTypeValue ( ) ; if ( typevl != null ) { if ( Os . isFamily ( "windows" ) ) { typevl = "\\\"" + typevl + "\\\"" ; } else { typevl = "\"" + typevl + "\"" ; } cmd . createArgument ( ) . setValue ( typevl ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_RECURSE = "-recurse" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['22', '4', '0', '8', '46', '189', '0', '8', '16', '0.919413919', '333', '0.538461538', '0', '0.695652174', '0.397727273', '2', '3', '13.54545455', '8', '1.5455', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class RegexpFactory extends RegexpMatcherFactory { public RegexpFactory ( ) { } public Regexp newRegexp ( ) throws BuildException { return ( Regexp ) newRegexp ( null ) ; } public Regexp newRegexp ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createRegexpInstance ( systemDefault ) ; } Throwable cause = null ; try { testAvailability ( "java.util.regex.Matcher" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , JavaEnvUtils . getJavaVersionNumber ( ) < 14 ) ; } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaOroRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } try { testAvailability ( "org.apache.regexp.RE" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } throw new BuildException ( "No supported regular expression matcher found" + ( cause != null ? ": " + cause : "" ) , cause ) ; } protected Regexp createRegexpInstance ( String classname ) throws BuildException { RegexpMatcher m = createInstance ( classname ) ; if ( m instanceof Regexp ) { return ( Regexp ) m ; } else { throw new BuildException ( classname + " doesn't implement the Regexp interface" ) ; } } } 	0	['4', '2', '0', '7', '18', '6', '1', '6', '3', '2', '119', '0', '0', '0.625', '0.5', '0', '0', '28.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . types . FileSet ; public class LibFileSet extends FileSet { private boolean includeURL ; private boolean includeImpl ; private String urlBase ; public void setIncludeUrl ( boolean includeURL ) { this . includeURL = includeURL ; } public void setIncludeImpl ( boolean includeImpl ) { this . includeImpl = includeImpl ; } public void setUrlBase ( String urlBase ) { this . urlBase = urlBase ; } boolean isIncludeURL ( ) { return includeURL ; } boolean isIncludeImpl ( ) { return includeImpl ; } String getUrlBase ( ) { return urlBase ; } } 	0	['7', '5', '0', '3', '8', '15', '2', '1', '4', '0.833333333', '34', '1', '0', '0.93814433', '0.476190476', '0', '0', '3.428571429', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class Compatibility { private final String name ; Compatibility ( final String name ) { this . name = name ; } public String toString ( ) { return name ; } } 	0	['2', '1', '0', '2', '3', '0', '2', '0', '1', '0', '12', '1', '0', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FilterOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class StringResource extends Resource { private static final int STRING_MAGIC = Resource . getMagicNumber ( "StringResource" . getBytes ( ) ) ; private String encoding = null ; public StringResource ( ) { } public StringResource ( String value ) { setValue ( value ) ; } public synchronized void setName ( String s ) { if ( getName ( ) != null ) { throw new BuildException ( new ImmutableResourceException ( ) ) ; } super . setName ( s ) ; } public synchronized void setValue ( String s ) { setName ( s ) ; } public synchronized String getName ( ) { return super . getName ( ) ; } public synchronized String getValue ( ) { return getName ( ) ; } public synchronized void setEncoding ( String s ) { encoding = s ; } public synchronized String getEncoding ( ) { return encoding ; } public synchronized long getSize ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) : ( long ) getContent ( ) . length ( ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return super . hashCode ( ) * STRING_MAGIC ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } return String . valueOf ( getContent ( ) ) ; } public synchronized InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } return new ByteArrayInputStream ( getContent ( ) . getBytes ( ) ) ; } public synchronized OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } if ( getValue ( ) != null ) { throw new ImmutableResourceException ( ) ; } final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; return new FilterOutputStream ( baos ) { public void close ( ) throws IOException { super . close ( ) ; StringResource . this . setValue ( encoding == null ? baos . toString ( ) : baos . toString ( encoding ) ) ; } } ; } public void setRefid ( Reference r ) { if ( encoding != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected synchronized String getContent ( ) { if ( isReference ( ) ) { return ( ( StringResource ) getCheckedRef ( ) ) . getContent ( ) ; } String value = getValue ( ) ; if ( value == null ) { return value ; } return getProject ( ) == null ? value : getProject ( ) . replaceProperties ( value ) ; } } 	0	['17', '4', '0', '8', '41', '104', '3', '6', '14', '0.8125', '185', '1', '0', '0.791044776', '0.328125', '2', '10', '9.764705882', '4', '1.2941', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . Tokenizer ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . regexp . Regexp ; public class TokenFilter extends BaseFilterReader implements ChainableReader { public interface Filter { String filter ( String string ) ; } private Vector filters = new Vector ( ) ; private Tokenizer tokenizer = null ; private String delimOutput = null ; private String line = null ; private int linePos = 0 ; public TokenFilter ( ) { super ( ) ; } public TokenFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } while ( line == null || line . length ( ) == 0 ) { line = tokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } for ( Enumeration e = filters . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; line = filter . filter ( line ) ; if ( line == null ) { break ; } } linePos = 0 ; if ( line != null ) { if ( tokenizer . getPostToken ( ) . length ( ) != 0 ) { if ( delimOutput != null ) { line = line + delimOutput ; } else { line = line + tokenizer . getPostToken ( ) ; } } } } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final Reader chain ( final Reader reader ) { TokenFilter newFilter = new TokenFilter ( reader ) ; newFilter . filters = filters ; newFilter . tokenizer = tokenizer ; newFilter . delimOutput = delimOutput ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } public void setDelimOutput ( String delimOutput ) { this . delimOutput = resolveBackSlash ( delimOutput ) ; } public void addLineTokenizer ( LineTokenizer tokenizer ) { add ( tokenizer ) ; } public void addStringTokenizer ( StringTokenizer tokenizer ) { add ( tokenizer ) ; } public void addFileTokenizer ( FileTokenizer tokenizer ) { add ( tokenizer ) ; } public void add ( Tokenizer tokenizer ) { if ( this . tokenizer != null ) { throw new BuildException ( "Only one tokenizer allowed" ) ; } this . tokenizer = tokenizer ; } public void addReplaceString ( ReplaceString filter ) { filters . addElement ( filter ) ; } public void addContainsString ( ContainsString filter ) { filters . addElement ( filter ) ; } public void addReplaceRegex ( ReplaceRegex filter ) { filters . addElement ( filter ) ; } public void addContainsRegex ( ContainsRegex filter ) { filters . addElement ( filter ) ; } public void addTrim ( Trim filter ) { filters . addElement ( filter ) ; } public void addIgnoreBlank ( IgnoreBlank filter ) { filters . addElement ( filter ) ; } public void addDeleteCharacters ( DeleteCharacters filter ) { filters . addElement ( filter ) ; } public void add ( Filter filter ) { filters . addElement ( filter ) ; } public static class FileTokenizer extends org . apache . tools . ant . util . FileTokenizer { } public static class StringTokenizer extends org . apache . tools . ant . util . StringTokenizer { } public abstract static class ChainableReaderFilter extends ProjectComponent implements ChainableReader , Filter { private boolean byLine = true ; public void setByLine ( boolean byLine ) { this . byLine = byLine ; } public Reader chain ( Reader reader ) { TokenFilter tokenFilter = new TokenFilter ( reader ) ; if ( ! byLine ) { tokenFilter . add ( new FileTokenizer ( ) ) ; } tokenFilter . add ( this ) ; return tokenFilter ; } } public static class ReplaceString extends ChainableReaderFilter { private String from ; private String to ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String filter ( String line ) { if ( from == null ) { throw new BuildException ( "Missing from in stringreplace" ) ; } StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = line . indexOf ( from ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( line . substring ( start , found ) ) ; } if ( to != null ) { ret . append ( to ) ; } start = found + from . length ( ) ; found = line . indexOf ( from , start ) ; } if ( line . length ( ) > start ) { ret . append ( line . substring ( start , line . length ( ) ) ) ; } return ret . toString ( ) ; } } public static class ContainsString extends ProjectComponent implements Filter { private String contains ; public void setContains ( String contains ) { this . contains = contains ; } public String filter ( String string ) { if ( contains == null ) { throw new BuildException ( "Missing contains in containsstring" ) ; } if ( string . indexOf ( contains ) > - 1 ) { return string ; } return null ; } } public static class ReplaceRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing pattern in replaceregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { to = "" ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String line ) { initialize ( ) ; if ( ! regexp . matches ( line , options ) ) { return line ; } return regexp . substitute ( line , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class ContainsRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing from in containsregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { return ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String string ) { initialize ( ) ; if ( ! regexp . matches ( string , options ) ) { return null ; } if ( substitution == null ) { return string ; } return regexp . substitute ( string , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class Trim extends ChainableReaderFilter { public String filter ( String line ) { return line . trim ( ) ; } } public static class IgnoreBlank extends ChainableReaderFilter { public String filter ( String line ) { if ( line . trim ( ) . length ( ) == 0 ) { return null ; } return line ; } } public static class DeleteCharacters extends ProjectComponent implements Filter , ChainableReader { private String deleteChars = "" ; public void setChars ( String deleteChars ) { this . deleteChars = resolveBackSlash ( deleteChars ) ; } public String filter ( String string ) { StringBuffer output = new StringBuffer ( string . length ( ) ) ; for ( int i = 0 ; i < string . length ( ) ; ++ i ) { char ch = string . charAt ( i ) ; if ( ! ( isDeleteCharacter ( ch ) ) ) { output . append ( ch ) ; } } return output . toString ( ) ; } public Reader chain ( Reader reader ) { return new BaseFilterReader ( reader ) { public int read ( ) throws IOException { while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { return c ; } if ( ! ( isDeleteCharacter ( ( char ) c ) ) ) { return c ; } } } } ; } private boolean isDeleteCharacter ( char c ) { for ( int d = 0 ; d < deleteChars . length ( ) ; ++ d ) { if ( deleteChars . charAt ( d ) == c ) { return true ; } } return false ; } } public static String resolveBackSlash ( String input ) { return StringUtils . resolveBackSlash ( input ) ; } public static int convertRegexOptions ( String flags ) { if ( flags == null ) { return 0 ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } return options ; } } 	0	['19', '4', '0', '19', '41', '23', '5', '17', '19', '0.688888889', '319', '1', '1', '0.604651163', '0.119298246', '2', '4', '15.52631579', '6', '1.2105', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; public class OutputStreamFunneler { public static final long DEFAULT_TIMEOUT_MILLIS = 1000 ; private final class Funnel extends OutputStream { private boolean closed = false ; private Funnel ( ) { synchronized ( OutputStreamFunneler . this ) { ++ count ; } } public void flush ( ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . flush ( ) ; } } public void write ( int b ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b ) ; } } public void write ( byte [ ] b ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b , off , len ) ; } } public void close ( ) throws IOException { release ( this ) ; } } private OutputStream out ; private int count = 0 ; private boolean closed ; private long timeoutMillis ; public OutputStreamFunneler ( OutputStream out ) { this ( out , DEFAULT_TIMEOUT_MILLIS ) ; } public OutputStreamFunneler ( OutputStream out , long timeoutMillis ) { if ( out == null ) { throw new IllegalArgumentException ( "OutputStreamFunneler.<init>:  out == null" ) ; } this . out = out ; this . closed = false ; setTimeout ( timeoutMillis ) ; } public synchronized void setTimeout ( long timeoutMillis ) { this . timeoutMillis = timeoutMillis ; } public synchronized OutputStream getFunnelInstance ( ) throws IOException { dieIfClosed ( ) ; try { return new Funnel ( ) ; } finally { notifyAll ( ) ; } } private synchronized void release ( Funnel funnel ) throws IOException { if ( ! funnel . closed ) { try { if ( timeoutMillis > 0 ) { try { wait ( timeoutMillis ) ; } catch ( InterruptedException eyeEx ) { } } if ( -- count == 0 ) { close ( ) ; } } finally { funnel . closed = true ; } } } private synchronized void close ( ) throws IOException { try { dieIfClosed ( ) ; out . close ( ) ; } finally { closed = true ; } } private synchronized void dieIfClosed ( ) throws IOException { if ( closed ) { throw new IOException ( "The funneled OutputStream has been closed." ) ; } } } 	0	['12', '1', '0', '2', '21', '42', '2', '1', '4', '0.654545455', '146', '0.8', '0', '0', '0.263888889', '0', '0', '10.75', '1', '0.8333', '0']
package org . apache . tools . ant . types . optional . depend ; import java . io . File ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; public class DependScanner extends DirectoryScanner { public static final String DEFAULT_ANALYZER_CLASS = "org.apache.tools.ant.util.depend.bcel.FullAnalyzer" ; private Vector rootClasses ; private Vector included ; private DirectoryScanner parentScanner ; public DependScanner ( DirectoryScanner parentScanner ) { this . parentScanner = parentScanner ; } public synchronized void setRootClasses ( Vector rootClasses ) { this . rootClasses = rootClasses ; } public String [ ] getIncludedFiles ( ) { String [ ] files = new String [ getIncludedFilesCount ( ) ] ; for ( int i = 0 ; i < files . length ; i ++ ) { files [ i ] = ( String ) included . elementAt ( i ) ; } return files ; } public synchronized int getIncludedFilesCount ( ) { if ( included == null ) { throw new IllegalStateException ( ) ; } return included . size ( ) ; } public synchronized void scan ( ) throws IllegalStateException { included = new Vector ( ) ; String analyzerClassName = DEFAULT_ANALYZER_CLASS ; DependencyAnalyzer analyzer = null ; try { Class analyzerClass = Class . forName ( analyzerClassName ) ; analyzer = ( DependencyAnalyzer ) analyzerClass . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( "Unable to load dependency analyzer: " + analyzerClassName , e ) ; } analyzer . addClassPath ( new Path ( null , basedir . getPath ( ) ) ) ; for ( Enumeration e = rootClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String rootClass = ( String ) e . nextElement ( ) ; analyzer . addRootClass ( rootClass ) ; } Enumeration e = analyzer . getClassDependencies ( ) ; String [ ] parentFiles = parentScanner . getIncludedFiles ( ) ; Hashtable parentSet = new Hashtable ( ) ; for ( int i = 0 ; i < parentFiles . length ; ++ i ) { parentSet . put ( parentFiles [ i ] , parentFiles [ i ] ) ; } while ( e . hasMoreElements ( ) ) { String classname = ( String ) e . nextElement ( ) ; String filename = classname . replace ( '.' , File . separatorChar ) ; filename = filename + ".class" ; File depFile = new File ( basedir , filename ) ; if ( depFile . exists ( ) && parentSet . containsKey ( filename ) ) { included . addElement ( filename ) ; } } } public void addDefaultExcludes ( ) { } public String [ ] getExcludedDirectories ( ) { return null ; } public String [ ] getExcludedFiles ( ) { return null ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public int getIncludedDirsCount ( ) { return 0 ; } public String [ ] getNotIncludedDirectories ( ) { return null ; } public String [ ] getNotIncludedFiles ( ) { return null ; } public void setExcludes ( String [ ] excludes ) { } public void setIncludes ( String [ ] includes ) { } public void setCaseSensitive ( boolean isCaseSensitive ) { } } 	0	['15', '2', '0', '6', '43', '95', '1', '5', '15', '0.946428571', '202', '0.75', '1', '0.813333333', '0.266666667', '1', '1', '12.2', '2', '1.0667', '0']
package org . apache . tools . ant . launch ; import java . util . Properties ; public interface AntMain { void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . lang . reflect . Constructor ; public class ReflectWrapper { private Object obj ; public ReflectWrapper ( ClassLoader loader , String name ) { try { Class clazz ; clazz = Class . forName ( name , true , loader ) ; Constructor constructor ; constructor = clazz . getConstructor ( ( Class [ ] ) null ) ; obj = constructor . newInstance ( ( Object [ ] ) null ) ; } catch ( Exception t ) { ReflectUtil . throwBuildException ( t ) ; } } public ReflectWrapper ( Object obj ) { this . obj = obj ; } public Object getObject ( ) { return obj ; } public Object invoke ( String methodName ) { return ReflectUtil . invoke ( obj , methodName ) ; } public Object invoke ( String methodName , Class argType , Object arg ) { return ReflectUtil . invoke ( obj , methodName , argType , arg ) ; } public Object invoke ( String methodName , Class argType1 , Object arg1 , Class argType2 , Object arg2 ) { return ReflectUtil . invoke ( obj , methodName , argType1 , arg1 , argType2 , arg2 ) ; } } 	0	['6', '1', '0', '3', '14', '0', '2', '1', '6', '0', '58', '1', '0', '0', '0.533333333', '0', '0', '8.5', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; String [ ] getDeselectedDirectories ( ) ; String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . filters . ClassConstants ; import org . apache . tools . ant . filters . EscapeUnicode ; import org . apache . tools . ant . filters . ExpandProperties ; import org . apache . tools . ant . filters . HeadFilter ; import org . apache . tools . ant . filters . LineContains ; import org . apache . tools . ant . filters . LineContainsRegExp ; import org . apache . tools . ant . filters . PrefixLines ; import org . apache . tools . ant . filters . ReplaceTokens ; import org . apache . tools . ant . filters . StripJavaComments ; import org . apache . tools . ant . filters . StripLineBreaks ; import org . apache . tools . ant . filters . StripLineComments ; import org . apache . tools . ant . filters . TabsToSpaces ; import org . apache . tools . ant . filters . TailFilter ; import org . apache . tools . ant . filters . TokenFilter ; public class FilterChain extends DataType implements Cloneable { private Vector filterReaders = new Vector ( ) ; public void addFilterReader ( final AntFilterReader filterReader ) { filterReaders . addElement ( filterReader ) ; } public Vector getFilterReaders ( ) { return filterReaders ; } public void addClassConstants ( final ClassConstants classConstants ) { filterReaders . addElement ( classConstants ) ; } public void addExpandProperties ( final ExpandProperties expandProperties ) { filterReaders . addElement ( expandProperties ) ; } public void addHeadFilter ( final HeadFilter headFilter ) { filterReaders . addElement ( headFilter ) ; } public void addLineContains ( final LineContains lineContains ) { filterReaders . addElement ( lineContains ) ; } public void addLineContainsRegExp ( final LineContainsRegExp lineContainsRegExp ) { filterReaders . addElement ( lineContainsRegExp ) ; } public void addPrefixLines ( final PrefixLines prefixLines ) { filterReaders . addElement ( prefixLines ) ; } public void addReplaceTokens ( final ReplaceTokens replaceTokens ) { filterReaders . addElement ( replaceTokens ) ; } public void addStripJavaComments ( final StripJavaComments stripJavaComments ) { filterReaders . addElement ( stripJavaComments ) ; } public void addStripLineBreaks ( final StripLineBreaks stripLineBreaks ) { filterReaders . addElement ( stripLineBreaks ) ; } public void addStripLineComments ( final StripLineComments stripLineComments ) { filterReaders . addElement ( stripLineComments ) ; } public void addTabsToSpaces ( final TabsToSpaces tabsToSpaces ) { filterReaders . addElement ( tabsToSpaces ) ; } public void addTailFilter ( final TailFilter tailFilter ) { filterReaders . addElement ( tailFilter ) ; } public void addEscapeUnicode ( final EscapeUnicode escapeUnicode ) { filterReaders . addElement ( escapeUnicode ) ; } public void addTokenFilter ( final TokenFilter tokenFilter ) { filterReaders . addElement ( tokenFilter ) ; } public void addDeleteCharacters ( TokenFilter . DeleteCharacters filter ) { filterReaders . addElement ( filter ) ; } public void addContainsRegex ( TokenFilter . ContainsRegex filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceRegex ( TokenFilter . ReplaceRegex filter ) { filterReaders . addElement ( filter ) ; } public void addTrim ( TokenFilter . Trim filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceString ( TokenFilter . ReplaceString filter ) { filterReaders . addElement ( filter ) ; } public void addIgnoreBlank ( TokenFilter . IgnoreBlank filter ) { filterReaders . addElement ( filter ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! filterReaders . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof FilterChain ) { FilterChain fc = ( FilterChain ) o ; filterReaders = fc . getFilterReaders ( ) ; } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterChain" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } public void add ( ChainableReader filter ) { filterReaders . addElement ( filter ) ; } } 	0	['25', '3', '1', '35', '39', '0', '9', '26', '25', '0', '189', '1', '0', '0.555555556', '0.08', '1', '1', '6.52', '1', '0.96', '0']
package org . apache . tools . ant . launch ; public class LaunchException extends Exception { public LaunchException ( String message ) { super ( message ) ; } } 	0	['1', '3', '0', '1', '2', '0', '1', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; public interface Native2AsciiAdapter { boolean convert ( Native2Ascii args , File srcFile , File destFile ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . InputStream ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . StreamPumper ; import org . apache . tools . ant . util . FileUtils ; public class GreedyInputHandler extends DefaultInputHandler { private static final int BUFFER_SIZE = 1024 ; public GreedyInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; InputStream in = null ; try { in = getInputStream ( ) ; System . err . println ( prompt ) ; System . err . flush ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; StreamPumper p = new StreamPumper ( in , baos ) ; Thread t = new Thread ( p ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { try { t . join ( ) ; } catch ( InterruptedException e2 ) { } } request . setInput ( new String ( baos . toByteArray ( ) ) ) ; if ( ! ( request . isInputValid ( ) ) ) { throw new BuildException ( "Received invalid console input" ) ; } if ( p . getException ( ) != null ) { throw new BuildException ( "Failed to read input from console" , p . getException ( ) ) ; } } finally { FileUtils . close ( in ) ; } } } 	0	['2', '2', '0', '6', '20', '1', '1', '5', '2', '2', '80', '1', '0', '0.75', '0.75', '1', '1', '38.5', '1', '0.5', '0']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . util . FileNameMapper ; import java . util . ArrayList ; public class ScriptMapper extends AbstractScriptComponent implements FileNameMapper { private ArrayList files ; static final String [ ] EMPTY_STRING_ARRAY = new String [ 0 ] ; public void setFrom ( String from ) { } public void setTo ( String to ) { } public void clear ( ) { files = new ArrayList ( 1 ) ; } public void addMappedName ( String mapping ) { files . add ( mapping ) ; } public String [ ] mapFileName ( String sourceFileName ) { initScriptRunner ( ) ; getRunner ( ) . addBean ( "source" , sourceFileName ) ; clear ( ) ; executeScript ( "ant_mapper" ) ; if ( files . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) files . toArray ( EMPTY_STRING_ARRAY ) ; } } } 	0	['7', '3', '0', '3', '16', '13', '0', '3', '6', '0.75', '55', '0.5', '0', '0.8', '0.833333333', '0', '0', '6.571428571', '2', '0.8571', '0']
package org . apache . tools . ant . types . resolver ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogEntry ; import org . apache . xml . resolver . helpers . PublicId ; public class ApacheCatalog extends Catalog { private ApacheCatalogResolver resolver = null ; protected Catalog newCatalog ( ) { ApacheCatalog cat = ( ApacheCatalog ) super . newCatalog ( ) ; cat . setResolver ( resolver ) ; return cat ; } public void setResolver ( ApacheCatalogResolver resolver ) { this . resolver = resolver ; } public void addEntry ( CatalogEntry entry ) { int type = entry . getEntryType ( ) ; if ( type == PUBLIC ) { String publicid = PublicId . normalize ( entry . getEntryArg ( 0 ) ) ; String systemid = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addPublicEntry ( publicid , systemid , base ) ; } } else if ( type == URI ) { String uri = normalizeURI ( entry . getEntryArg ( 0 ) ) ; String altURI = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addURIEntry ( uri , altURI , base ) ; } } super . addEntry ( entry ) ; } } 	0	['4', '2', '0', '6', '14', '0', '1', '6', '3', '0', '96', '1', '1', '0.916666667', '0.5', '1', '3', '22.75', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Edit extends P4Base { public String change = null ; public void setChange ( String change ) { this . change = change ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( P4View == null ) { throw new BuildException ( "No view specified to edit" ) ; } execP4Command ( "-s edit " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '10', '0', '0', '4', '3', '0', '55', '0', '0', '0.962264151', '0.666666667', '1', '1', '17', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSCHECKIN extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKIN ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } } 	0	['7', '4', '0', '6', '28', '21', '0', '6', '6', '2', '92', '0', '0', '0.93814433', '0.428571429', '1', '1', '12.14285714', '2', '1', '0']
package org . apache . tools . ant ; public interface DynamicElementNS { Object createDynamicElement ( String uri , String localName , String qName ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringReader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean spawn = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; private static boolean environmentCaseInSensitive = false ; static { try { if ( ! Os . isFamily ( "os/2" ) ) { vmLauncher = new Java13CommandLauncher ( ) ; } } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new OS2CommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { environmentCaseInSensitive = true ; CommandLauncher baseLauncher = new CommandLauncher ( ) ; if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher = new CommandLauncher ( ) ; shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else if ( Os . isFamily ( "openvms" ) ) { try { shellLauncher = new VmsCommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; if ( Os . isFamily ( "openvms" ) ) { procEnvironment = addVMSLogicals ( procEnvironment , in ) ; return procEnvironment ; } String var = null ; String line , lineSep = StringUtils . LINE_SEP ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { return new String [ ] { "cmd" , "/c" , "set" } ; } else if ( Os . isFamily ( "windows" ) ) { if ( Os . isFamily ( "win9x" ) ) { return new String [ ] { "command.com" , "/c" , "set" } ; } else { return new String [ ] { "cmd" , "/c" , "set" } ; } } else if ( Os . isFamily ( "z/os" ) || Os . isFamily ( "unix" ) ) { String [ ] cmd = new String [ 1 ] ; if ( new File ( "/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/bin/env" ; } else if ( new File ( "/usr/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/usr/bin/env" ; } else { cmd [ 0 ] = "env" ; } return cmd ; } else if ( Os . isFamily ( "netware" ) || Os . isFamily ( "os/400" ) ) { return new String [ ] { "env" } ; } else if ( Os . isFamily ( "openvms" ) ) { return new String [ ] { "show" , "logical" } ; } else { return null ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { return bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } else if ( Os . isFamily ( "os/400" ) ) { try { return bos . toString ( "Cp500" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { setStreamHandler ( streamHandler ) ; this . watchdog = watchdog ; if ( Os . isFamily ( "openvms" ) ) { useVMLauncher = false ; } } public void setStreamHandler ( ExecuteStreamHandler streamHandler ) { this . streamHandler = streamHandler ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { return ( env == null || newEnvironment ) ? env : patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { workingDirectory = ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) ? null : wd ; } public File getWorkingDirectory ( ) { return workingDirectory == null ? new File ( antWorkingDirectory ) : workingDirectory ; } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( dir + " doesn't exist." ) ; } CommandLauncher launcher = ( ( useVM && vmLauncher != null ) ? vmLauncher : shellLauncher ) ; return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new BuildException ( workingDirectory + " doesn't exist." ) ; } final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; try { processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; closeStreams ( process ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } catch ( ThreadDeath t ) { process . destroy ( ) ; throw t ; } finally { processDestroyer . remove ( process ) ; } } public void spawn ( ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new BuildException ( workingDirectory + " doesn't exist." ) ; } final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; if ( Os . isFamily ( "windows" ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { project . log ( "interruption in the sleep after having spawned a" + " process" , Project . MSG_VERBOSE ) ; } } OutputStream dummyOut = new OutputStream ( ) { public void write ( int b ) throws IOException { } } ; ExecuteStreamHandler handler = new PumpStreamHandler ( dummyOut ) ; handler . setProcessErrorStream ( process . getErrorStream ( ) ) ; handler . setProcessOutputStream ( process . getInputStream ( ) ) ; handler . start ( ) ; process . getOutputStream ( ) . close ( ) ; project . log ( "spawned process " + process . toString ( ) , Project . MSG_VERBOSE ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { process . destroy ( ) ; } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public static boolean isFailure ( int exitValue ) { return Os . isFamily ( "openvms" ) ? ( exitValue % 2 == 0 ) : ( exitValue != 0 ) ; } public boolean isFailure ( ) { return isFailure ( getExitValue ( ) ) ; } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { if ( Os . isFamily ( "openvms" ) ) { return env ; } Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { String keyValue = env [ i ] ; String key = keyValue . substring ( 0 , keyValue . indexOf ( '=' ) + 1 ) ; if ( environmentCaseInSensitive ) { key = key . toLowerCase ( ) ; } int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { String osEnvItem = ( String ) osEnv . elementAt ( j ) ; String convertedItem = environmentCaseInSensitive ? osEnvItem . toLowerCase ( ) : osEnvItem ; if ( convertedItem . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; if ( environmentCaseInSensitive ) { keyValue = osEnvItem . substring ( 0 , key . length ( ) ) + keyValue . substring ( key . length ( ) ) ; } break ; } } osEnv . addElement ( keyValue ) ; } return ( String [ ] ) ( osEnv . toArray ( new String [ osEnv . size ( ) ] ) ) ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( isFailure ( retval ) ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } public static void closeStreams ( Process process ) { FileUtils . close ( process . getInputStream ( ) ) ; FileUtils . close ( process . getOutputStream ( ) ) ; FileUtils . close ( process . getErrorStream ( ) ) ; } private static Vector addVMSLogicals ( Vector environment , BufferedReader in ) throws IOException { HashMap logicals = new HashMap ( ) ; String logName = null , logValue = null , newLogName ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "\t=" ) ) { if ( logName != null ) { logValue += "," + line . substring ( 4 , line . length ( ) - 1 ) ; } } else if ( line . startsWith ( "  \"" ) ) { if ( logName != null ) { logicals . put ( logName , logValue ) ; } int eqIndex = line . indexOf ( '=' ) ; newLogName = line . substring ( 3 , eqIndex - 2 ) ; if ( logicals . containsKey ( newLogName ) ) { logName = null ; } else { logName = newLogName ; logValue = line . substring ( eqIndex + 3 , line . length ( ) - 1 ) ; } } } if ( logName != null ) { logicals . put ( logName , logValue ) ; } for ( Iterator i = logicals . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String logical = ( String ) i . next ( ) ; environment . add ( logical + "=" + logicals . get ( logical ) ) ; } return environment ; } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java13CommandLauncher extends CommandLauncher { private Method myExecWithCWD ; public Java13CommandLauncher ( ) throws NoSuchMethodException { myExecWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return ( Process ) myExecWithCWD . invoke ( Runtime . getRuntime ( ) , new Object [ ] { cmd , env , workingDir } ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } } private static class CommandLauncherProxy extends CommandLauncher { private CommandLauncher myLauncher ; CommandLauncherProxy ( CommandLauncher launcher ) { myLauncher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return myLauncher . exec ( project , cmd , env ) ; } } private static class OS2CommandLauncher extends CommandLauncherProxy { OS2CommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 7 ; final String cmdDir = commandDir . getAbsolutePath ( ) ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = cmdDir . substring ( 0 , 2 ) ; newcmd [ 3 ] = "&&" ; newcmd [ 4 ] = "cd" ; newcmd [ 5 ] = cmdDir . substring ( 2 ) ; newcmd [ 6 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( MagicNames . ANT_HOME ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property '" + MagicNames . ANT_HOME + "' not found" ) ; } String antRun = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { private String myScript ; PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( MagicNames . ANT_HOME ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property '" + MagicNames . ANT_HOME + "' not found" ) ; } String antRun = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class VmsCommandLauncher extends Java13CommandLauncher { public VmsCommandLauncher ( ) throws NoSuchMethodException { super ( ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { File cmdFile = createCommandFile ( cmd , env ) ; Process p = super . exec ( project , new String [ ] { cmdFile . getPath ( ) } , env ) ; deleteAfter ( cmdFile , p ) ; return p ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File cmdFile = createCommandFile ( cmd , env ) ; Process p = super . exec ( project , new String [ ] { cmdFile . getPath ( ) } , env , workingDir ) ; deleteAfter ( cmdFile , p ) ; return p ; } private File createCommandFile ( String [ ] cmd , String [ ] env ) throws IOException { File script = FILE_UTILS . createTempFile ( "ANT" , ".COM" , null ) ; script . deleteOnExit ( ) ; PrintWriter out = null ; try { out = new PrintWriter ( new FileWriter ( script ) ) ; if ( env != null ) { int eqIndex ; for ( int i = 0 ; i < env . length ; i ++ ) { eqIndex = env [ i ] . indexOf ( '=' ) ; if ( eqIndex != - 1 ) { out . print ( "$ DEFINE/NOLOG " ) ; out . print ( env [ i ] . substring ( 0 , eqIndex ) ) ; out . print ( " \"" ) ; out . print ( env [ i ] . substring ( eqIndex + 1 ) ) ; out . println ( '\"' ) ; } } } out . print ( "$ " + cmd [ 0 ] ) ; for ( int i = 1 ; i < cmd . length ; i ++ ) { out . println ( " -" ) ; out . print ( cmd [ i ] ) ; } } finally { if ( out != null ) { out . close ( ) ; } } return script ; } private void deleteAfter ( final File f , final Process p ) { new Thread ( ) { public void run ( ) { try { p . waitFor ( ) ; } catch ( InterruptedException e ) { } FileUtils . delete ( f ) ; } } . start ( ) ; } } } 	0	['33', '1', '0', '70', '121', '440', '54', '22', '25', '0.860119048', '1095', '0.80952381', '7', '0', '0.110576923', '0', '0', '31.54545455', '11', '1.9697', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . DTDLocation ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . XmlConstants ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . ParserAdapter ; public class XMLValidateTask extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected static final String INIT_FAILED_MSG = "Could not start xml validation: " ; protected boolean failOnError = true ; protected boolean warn = true ; protected boolean lenient = false ; protected String readerClassName = null ; protected File file = null ; protected Vector filesets = new Vector ( ) ; protected Path classpath ; protected XMLReader xmlReader = null ; protected ValidatorErrorHandler errorHandler = new ValidatorErrorHandler ( ) ; private Vector attributeList = new Vector ( ) ; private final Vector propertyList = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; public static final String MESSAGE_FILES_VALIDATED = " file(s) have been successfully validated." ; public void setFailOnError ( boolean fail ) { failOnError = fail ; } public void setWarn ( boolean bool ) { warn = bool ; } public void setLenient ( boolean bool ) { lenient = bool ; } public void setClassName ( String className ) { readerClassName = className ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFile ( File file ) { this . file = file ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { xmlCatalog . addConfiguredXMLCatalog ( catalog ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Attribute createAttribute ( ) { final Attribute feature = new Attribute ( ) ; attributeList . addElement ( feature ) ; return feature ; } public Property createProperty ( ) { final Property prop = new Property ( ) ; propertyList . addElement ( prop ) ; return prop ; } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } public DTDLocation createDTD ( ) { DTDLocation dtdLocation = new DTDLocation ( ) ; xmlCatalog . addDTD ( dtdLocation ) ; return dtdLocation ; } protected EntityResolver getEntityResolver ( ) { return xmlCatalog ; } protected XMLReader getXmlReader ( ) { return xmlReader ; } public void execute ( ) throws BuildException { int fileProcessed = 0 ; if ( file == null && ( filesets . size ( ) == 0 ) ) { throw new BuildException ( "Specify at least one source - " + "a file or a fileset." ) ; } if ( file != null ) { if ( file . exists ( ) && file . canRead ( ) && file . isFile ( ) ) { doValidate ( file ) ; fileProcessed ++ ; } else { String errorMsg = "File " + file + " cannot be read" ; if ( failOnError ) { throw new BuildException ( errorMsg ) ; } else { log ( errorMsg , Project . MSG_ERR ) ; } } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File srcFile = new File ( fs . getDir ( getProject ( ) ) , files [ j ] ) ; doValidate ( srcFile ) ; fileProcessed ++ ; } } onSuccessfulValidation ( fileProcessed ) ; } protected void onSuccessfulValidation ( int fileProcessed ) { log ( fileProcessed + MESSAGE_FILES_VALIDATED ) ; } protected void initValidator ( ) { xmlReader = createXmlReader ( ) ; xmlReader . setEntityResolver ( getEntityResolver ( ) ) ; xmlReader . setErrorHandler ( errorHandler ) ; if ( ! isSax1Parser ( ) ) { if ( ! lenient ) { setFeature ( XmlConstants . FEATURE_VALIDATION , true ) ; } for ( int i = 0 ; i < attributeList . size ( ) ; i ++ ) { Attribute feature = ( Attribute ) attributeList . elementAt ( i ) ; setFeature ( feature . getName ( ) , feature . getValue ( ) ) ; } for ( int i = 0 ; i < propertyList . size ( ) ; i ++ ) { final Property prop = ( Property ) propertyList . elementAt ( i ) ; setProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } protected boolean isSax1Parser ( ) { return ( xmlReader instanceof ParserAdapter ) ; } protected XMLReader createXmlReader ( ) { Object reader = null ; if ( readerClassName == null ) { reader = createDefaultReaderOrParser ( ) ; } else { Class readerClass = null ; try { if ( classpath != null ) { AntClassLoader loader = getProject ( ) . createClassLoader ( classpath ) ; readerClass = Class . forName ( readerClassName , true , loader ) ; } else { readerClass = Class . forName ( readerClassName ) ; } reader = readerClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } } XMLReader newReader ; if ( reader instanceof XMLReader ) { newReader = ( XMLReader ) reader ; log ( "Using SAX2 reader " + reader . getClass ( ) . getName ( ) , Project . MSG_VERBOSE ) ; } else { if ( reader instanceof Parser ) { newReader = new ParserAdapter ( ( Parser ) reader ) ; log ( "Using SAX1 parser " + reader . getClass ( ) . getName ( ) , Project . MSG_VERBOSE ) ; } else { throw new BuildException ( INIT_FAILED_MSG + reader . getClass ( ) . getName ( ) + " implements nor SAX1 Parser nor SAX2 XMLReader." ) ; } } return newReader ; } private Object createDefaultReaderOrParser ( ) { Object reader ; try { reader = createDefaultReader ( ) ; } catch ( BuildException exc ) { reader = JAXPUtils . getParser ( ) ; } return reader ; } protected XMLReader createDefaultReader ( ) { return JAXPUtils . getXMLReader ( ) ; } protected void setFeature ( String feature , boolean value ) throws BuildException { log ( "Setting feature " + feature + "=" + value , Project . MSG_DEBUG ) ; try { xmlReader . setFeature ( feature , value ) ; } catch ( SAXNotRecognizedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't recognize feature " + feature , e , getLocation ( ) ) ; } catch ( SAXNotSupportedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't support feature " + feature , e , getLocation ( ) ) ; } } protected void setProperty ( String name , String value ) throws BuildException { if ( name == null || value == null ) { throw new BuildException ( "Property name and value must be specified." ) ; } try { xmlReader . setProperty ( name , value ) ; } catch ( SAXNotRecognizedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't recognize property " + name , e , getLocation ( ) ) ; } catch ( SAXNotSupportedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't support property " + name , e , getLocation ( ) ) ; } } protected boolean doValidate ( File afile ) { initValidator ( ) ; boolean result = true ; try { log ( "Validating " + afile . getName ( ) + "... " , Project . MSG_VERBOSE ) ; errorHandler . init ( afile ) ; InputSource is = new InputSource ( new FileInputStream ( afile ) ) ; String uri = FILE_UTILS . toURI ( afile . getAbsolutePath ( ) ) ; is . setSystemId ( uri ) ; xmlReader . parse ( is ) ; } catch ( SAXException ex ) { log ( "Caught when validating: " + ex . toString ( ) , Project . MSG_DEBUG ) ; if ( failOnError ) { throw new BuildException ( "Could not validate document " + afile ) ; } log ( "Could not validate document " + afile + ": " + ex . toString ( ) ) ; result = false ; } catch ( IOException ex ) { throw new BuildException ( "Could not validate document " + afile , ex ) ; } if ( errorHandler . getFailure ( ) ) { if ( failOnError ) { throw new BuildException ( afile + " is not a valid XML document." ) ; } result = false ; log ( afile + " is not a valid XML document" , Project . MSG_ERR ) ; } return result ; } protected class ValidatorErrorHandler implements ErrorHandler { protected File currentFile = null ; protected String lastErrorMessage = null ; protected boolean failed = false ; public void init ( File file ) { currentFile = file ; failed = false ; } public boolean getFailure ( ) { return failed ; } public void fatalError ( SAXParseException exception ) { failed = true ; doLog ( exception , Project . MSG_ERR ) ; } public void error ( SAXParseException exception ) { failed = true ; doLog ( exception , Project . MSG_ERR ) ; } public void warning ( SAXParseException exception ) { if ( warn ) { doLog ( exception , Project . MSG_WARN ) ; } } private void doLog ( SAXParseException e , int logLevel ) { log ( getMessage ( e ) , logLevel ) ; } private String getMessage ( SAXParseException e ) { String sysID = e . getSystemId ( ) ; if ( sysID != null ) { String name = sysID ; if ( sysID . startsWith ( "file:" ) ) { try { name = FILE_UTILS . fromURI ( sysID ) ; } catch ( Exception ex ) { } } int line = e . getLineNumber ( ) ; int col = e . getColumnNumber ( ) ; return name + ( line == - 1 ? "" : ( ":" + line + ( col == - 1 ? "" : ( ":" + col ) ) ) ) + ": " + e . getMessage ( ) ; } return e . getMessage ( ) ; } } public static class Attribute { private String attributeName = null ; private boolean attributeValue ; public void setName ( String name ) { attributeName = name ; } public void setValue ( boolean value ) { attributeValue = value ; } public String getName ( ) { return attributeName ; } public boolean getValue ( ) { return attributeValue ; } } public static final class Property { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } } 	0	['29', '3', '1', '18', '96', '294', '2', '17', '16', '0.897619048', '796', '0.933333333', '4', '0.578125', '0.162698413', '2', '2', '25.93103448', '5', '1.3793', '0']
package org . apache . tools . ant . types . optional . depend ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class ClassfileSet extends FileSet { private Vector rootClasses = new Vector ( ) ; private Vector rootFileSets = new Vector ( ) ; public static class ClassRoot { private String rootClass ; public void setClassname ( String name ) { this . rootClass = name ; } public String getClassname ( ) { return rootClass ; } } public ClassfileSet ( ) { } public void addRootFileset ( FileSet rootFileSet ) { rootFileSets . addElement ( rootFileSet ) ; } protected ClassfileSet ( ClassfileSet s ) { super ( s ) ; rootClasses = ( Vector ) s . rootClasses . clone ( ) ; } public void setRootClass ( String rootClass ) { rootClasses . addElement ( rootClass ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } Vector allRootClasses = ( Vector ) rootClasses . clone ( ) ; for ( Enumeration e = rootFileSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FileSet additionalRootSet = ( FileSet ) e . nextElement ( ) ; DirectoryScanner additionalScanner = additionalRootSet . getDirectoryScanner ( p ) ; String [ ] files = additionalScanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . endsWith ( ".class" ) ) { String classFilePath = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; String className = classFilePath . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; allRootClasses . addElement ( className ) ; } } } DirectoryScanner parentScanner = super . getDirectoryScanner ( p ) ; DependScanner scanner = new DependScanner ( parentScanner ) ; scanner . setBasedir ( getDir ( p ) ) ; scanner . setRootClasses ( allRootClasses ) ; scanner . scan ( ) ; return scanner ; } public void addConfiguredRoot ( ClassRoot root ) { rootClasses . addElement ( root . getClassname ( ) ) ; } public Object clone ( ) { return new ClassfileSet ( isReference ( ) ? ( ClassfileSet ) ( getRef ( getProject ( ) ) ) : this ) ; } } 	0	['7', '5', '0', '6', '31', '0', '0', '6', '6', '0.25', '163', '1', '0', '0.947916667', '0.285714286', '3', '10', '22', '5', '1.4286', '0']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '2', '3', '1', '2', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . Path ; public class JlinkTask extends MatchingTask { public void setOutfile ( File outfile ) { this . outfile = outfile ; } public Path createMergefiles ( ) { if ( this . mergefiles == null ) { this . mergefiles = new Path ( getProject ( ) ) ; } return this . mergefiles . createPath ( ) ; } public void setMergefiles ( Path mergefiles ) { if ( this . mergefiles == null ) { this . mergefiles = mergefiles ; } else { this . mergefiles . append ( mergefiles ) ; } } public Path createAddfiles ( ) { if ( this . addfiles == null ) { this . addfiles = new Path ( getProject ( ) ) ; } return this . addfiles . createPath ( ) ; } public void setAddfiles ( Path addfiles ) { if ( this . addfiles == null ) { this . addfiles = addfiles ; } else { this . addfiles . append ( addfiles ) ; } } public void setCompress ( boolean compress ) { this . compress = compress ; } public void execute ( ) throws BuildException { if ( outfile == null ) { throw new BuildException ( "outfile attribute is required! " + "Please set." ) ; } if ( ! haveAddFiles ( ) && ! haveMergeFiles ( ) ) { throw new BuildException ( "addfiles or mergefiles required! " + "Please set." ) ; } log ( "linking:     " + outfile . getPath ( ) ) ; log ( "compression: " + compress , Project . MSG_VERBOSE ) ; jlink linker = new jlink ( ) ; linker . setOutfile ( outfile . getPath ( ) ) ; linker . setCompression ( compress ) ; if ( haveMergeFiles ( ) ) { log ( "merge files: " + mergefiles . toString ( ) , Project . MSG_VERBOSE ) ; linker . addMergeFiles ( mergefiles . list ( ) ) ; } if ( haveAddFiles ( ) ) { log ( "add files: " + addfiles . toString ( ) , Project . MSG_VERBOSE ) ; linker . addAddFiles ( addfiles . list ( ) ) ; } try { linker . link ( ) ; } catch ( Exception ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } private boolean haveAddFiles ( ) { return haveEntries ( addfiles ) ; } private boolean haveMergeFiles ( ) { return haveEntries ( mergefiles ) ; } private boolean haveEntries ( Path p ) { if ( p == null ) { return false ; } if ( p . size ( ) > 0 ) { return true ; } return false ; } private File outfile = null ; private Path mergefiles = null ; private Path addfiles = null ; private boolean compress = false ; } 	0	['11', '4', '0', '6', '35', '9', '0', '6', '8', '0.7', '217', '1', '2', '0.886363636', '0.363636364', '2', '2', '18.36363636', '3', '1.4545', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; public interface XMLConstants { String TESTSUITES = "testsuites" ; String TESTSUITE = "testsuite" ; String TESTCASE = "testcase" ; String ERROR = "error" ; String FAILURE = "failure" ; String SYSTEM_ERR = "system-err" ; String SYSTEM_OUT = "system-out" ; String ATTR_PACKAGE = "package" ; String ATTR_NAME = "name" ; String ATTR_TIME = "time" ; String ATTR_ERRORS = "errors" ; String ATTR_FAILURES = "failures" ; String ATTR_TESTS = "tests" ; String ATTR_TYPE = "type" ; String ATTR_MESSAGE = "message" ; String PROPERTIES = "properties" ; String PROPERTY = "property" ; String ATTR_VALUE = "value" ; String ATTR_CLASSNAME = "classname" ; String ATTR_ID = "id" ; String TIMESTAMP = "timestamp" ; String HOSTNAME = "hostname" ; } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '22', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . filters ; import java . io . StringReader ; import org . apache . tools . ant . util . ReaderInputStream ; public class StringInputStream extends ReaderInputStream { public StringInputStream ( String source ) { super ( new StringReader ( source ) ) ; } public StringInputStream ( String source , String encoding ) { super ( new StringReader ( source ) , encoding ) ; } } 	0	['2', '3', '0', '1', '5', '1', '0', '1', '2', '2', '17', '0', '0', '1', '1', '0', '0', '7.5', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Dirname extends Task { private File file ; private String property ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } else { String value = file . getParent ( ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['4', '3', '0', '4', '10', '2', '0', '4', '4', '0.666666667', '48', '1', '0', '0.925', '0.5', '0', '0', '10.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . File ; import java . util . Vector ; import java . util . ArrayList ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class P4Fstat extends P4Base { private int changelist ; private String addCmd = "" ; private Vector filesets = new Vector ( ) ; private static final int DEFAULT_CMD_LENGTH = 300 ; private int cmdLength = DEFAULT_CMD_LENGTH ; private static final int SHOW_ALL = 0 ; private static final int SHOW_EXISTING = 1 ; private static final int SHOW_NON_EXISTING = 2 ; private int show = SHOW_NON_EXISTING ; private FStatP4OutputHandler handler ; private StringBuffer filelist ; private int fileNum = 0 ; private int doneFileNum = 0 ; private boolean debug = false ; private static final String EXISTING_HEADER = "Following files exist in perforce" ; private static final String NONEXISTING_HEADER = "Following files do not exist in perforce" ; public void setShowFilter ( String filter ) { if ( filter . equalsIgnoreCase ( "all" ) ) { show = SHOW_ALL ; } else if ( filter . equalsIgnoreCase ( "existing" ) ) { show = SHOW_EXISTING ; } else if ( filter . equalsIgnoreCase ( "non-existing" ) ) { show = SHOW_NON_EXISTING ; } else { throw new BuildException ( "P4Fstat: ShowFilter should be one of: " + "all, existing, non-existing" ) ; } } public void setChangelist ( int changelist ) throws BuildException { if ( changelist <= 0 ) { throw new BuildException ( "P4FStat: Changelist# should be a " + "positive number" ) ; } this . changelist = changelist ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { handler = new FStatP4OutputHandler ( this ) ; if ( P4View != null ) { addCmd = P4View ; } P4CmdOpts = ( changelist > 0 ) ? ( "-c " + changelist ) : "" ; filelist = new StringBuffer ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; fileNum = srcFiles . length ; if ( srcFiles != null ) { for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File f = new File ( ds . getBasedir ( ) , srcFiles [ j ] ) ; filelist . append ( " " ) . append ( '"' ) . append ( f . getAbsolutePath ( ) ) . append ( '"' ) ; doneFileNum ++ ; if ( filelist . length ( ) > cmdLength ) { execP4Fstat ( filelist ) ; filelist = new StringBuffer ( ) ; } } if ( filelist . length ( ) > 0 ) { execP4Fstat ( filelist ) ; } } else { log ( "No files specified to query status on!" , Project . MSG_WARN ) ; } } if ( show == SHOW_ALL || show == SHOW_EXISTING ) { printRes ( handler . getExisting ( ) , EXISTING_HEADER ) ; } if ( show == SHOW_ALL || show == SHOW_NON_EXISTING ) { printRes ( handler . getNonExisting ( ) , NONEXISTING_HEADER ) ; } } public int getLengthOfTask ( ) { return fileNum ; } int getPasses ( ) { return filesets . size ( ) ; } private void printRes ( ArrayList ar , String header ) { log ( header , Project . MSG_INFO ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { log ( ( String ) ar . get ( i ) , Project . MSG_INFO ) ; } } private void execP4Fstat ( StringBuffer list ) { String l = list . substring ( 0 ) ; if ( debug ) { log ( "Executing fstat " + P4CmdOpts + " " + addCmd + l + "\n" , Project . MSG_INFO ) ; } execP4Command ( "fstat " + P4CmdOpts + " " + addCmd + l , handler ) ; } } 	0	['9', '4', '0', '7', '37', '10', '1', '7', '6', '0.9296875', '323', '1', '1', '0.86440678', '0.277777778', '0', '0', '33.11111111', '4', '1.4444', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSCHECKOUT extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKOUT ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionDateLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getFileTimeStamp ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritableFiles ( ) ) ; commandLine . createArgument ( ) . setValue ( getGetLocalCopy ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setDate ( String date ) { super . setInternalDate ( date ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setFileTimeStamp ( CurrentModUpdated timestamp ) { super . setInternalFileTimeStamp ( timestamp ) ; } public void setWritableFiles ( WritableFiles files ) { super . setInternalWritableFiles ( files ) ; } public void setGetLocalCopy ( boolean get ) { super . setInternalGetLocalCopy ( get ) ; } } 	0	['11', '4', '0', '8', '38', '55', '0', '8', '10', '2', '122', '0', '0', '0.900990099', '0.303030303', '1', '1', '10.09090909', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . text . ParseException ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; class LibraryDisplayer { void displayLibrary ( final File file ) throws BuildException { final Manifest manifest = ExtensionUtil . getManifest ( file ) ; displayLibrary ( file , manifest ) ; } void displayLibrary ( final File file , final Manifest manifest ) throws BuildException { final Extension [ ] available = Extension . getAvailable ( manifest ) ; final Extension [ ] required = Extension . getRequired ( manifest ) ; final Extension [ ] options = Extension . getOptions ( manifest ) ; final Specification [ ] specifications = getSpecifications ( manifest ) ; if ( 0 == available . length && 0 == required . length && 0 == options . length && 0 == specifications . length ) { return ; } final String message = "File: " + file ; final int size = message . length ( ) ; printLine ( size ) ; System . out . println ( message ) ; printLine ( size ) ; if ( 0 != available . length ) { System . out . println ( "Extensions Supported By Library:" ) ; for ( int i = 0 ; i < available . length ; i ++ ) { final Extension extension = available [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != required . length ) { System . out . println ( "Extensions Required By Library:" ) ; for ( int i = 0 ; i < required . length ; i ++ ) { final Extension extension = required [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != options . length ) { System . out . println ( "Extensions that will be used by Library if present:" ) ; for ( int i = 0 ; i < options . length ; i ++ ) { final Extension extension = options [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != specifications . length ) { System . out . println ( "Specifications Supported By Library:" ) ; for ( int i = 0 ; i < specifications . length ; i ++ ) { final Specification specification = specifications [ i ] ; displaySpecification ( specification ) ; } } } private void printLine ( final int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( "-" ) ; } System . out . println ( ) ; } private Specification [ ] getSpecifications ( final Manifest manifest ) throws BuildException { try { return Specification . getSpecifications ( manifest ) ; } catch ( final ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe ) ; } } private void displaySpecification ( final Specification specification ) { final String [ ] sections = specification . getSections ( ) ; if ( null != sections ) { final StringBuffer sb = new StringBuffer ( "Sections: " ) ; for ( int i = 0 ; i < sections . length ; i ++ ) { sb . append ( " " ) ; sb . append ( sections [ i ] ) ; } System . out . println ( sb ) ; } System . out . println ( specification . toString ( ) ) ; } } 	0	['6', '1', '0', '5', '26', '15', '1', '4', '0', '2', '211', '0', '0', '0', '0.4', '0', '0', '34.16666667', '3', '1.3333', '0']
package org . apache . tools . ant . types ; import java . io . IOException ; import java . util . Map ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . TarResource ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class TarScanner extends ArchiveScanner { protected void fillMapsFromArchive ( Resource src , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) { TarEntry entry = null ; TarInputStream ti = null ; try { try { ti = new TarInputStream ( src . getInputStream ( ) ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } while ( ( entry = ti . getNextEntry ( ) ) != null ) { Resource r = new TarResource ( src , entry ) ; String name = entry . getName ( ) ; if ( entry . isDirectory ( ) ) { name = trimSeparator ( name ) ; dirEntries . put ( name , r ) ; if ( match ( name ) ) { matchDirEntries . put ( name , r ) ; } } else { fileEntries . put ( name , r ) ; if ( match ( name ) ) { matchFileEntries . put ( name , r ) ; } } } } catch ( IOException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } finally { if ( ti != null ) { try { ti . close ( ) ; } catch ( IOException ex ) { } } } } } 	0	['2', '3', '0', '7', '17', '1', '1', '6', '1', '2', '108', '0', '0', '0.987179487', '0.625', '1', '3', '53', '8', '4', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . io . File ; import java . io . BufferedReader ; import java . io . FileReader ; import org . apache . tools . ant . types . Parameter ; public final class ConcatFilter extends BaseParamFilterReader implements ChainableReader { private File prepend ; private File append ; private Reader prependReader = null ; private Reader appendReader = null ; public ConcatFilter ( ) { super ( ) ; } public ConcatFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( prependReader != null ) { ch = prependReader . read ( ) ; if ( ch == - 1 ) { prependReader . close ( ) ; prependReader = null ; } } if ( ch == - 1 ) { ch = super . read ( ) ; } if ( ch == - 1 ) { if ( appendReader != null ) { ch = appendReader . read ( ) ; if ( ch == - 1 ) { appendReader . close ( ) ; appendReader = null ; } } } return ch ; } public void setPrepend ( final File prepend ) { this . prepend = prepend ; } public File getPrepend ( ) { return prepend ; } public void setAppend ( final File append ) { this . append = append ; } public File getAppend ( ) { return append ; } public Reader chain ( final Reader rdr ) { ConcatFilter newFilter = new ConcatFilter ( rdr ) ; newFilter . setPrepend ( getPrepend ( ) ) ; newFilter . setAppend ( getAppend ( ) ) ; return newFilter ; } private void initialize ( ) throws IOException { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( "prepend" . equals ( params [ i ] . getName ( ) ) ) { setPrepend ( new File ( params [ i ] . getValue ( ) ) ) ; continue ; } if ( "append" . equals ( params [ i ] . getName ( ) ) ) { setAppend ( new File ( params [ i ] . getValue ( ) ) ) ; continue ; } } } if ( prepend != null ) { if ( ! prepend . isAbsolute ( ) ) { prepend = new File ( getProject ( ) . getBaseDir ( ) , prepend . getPath ( ) ) ; } prependReader = new BufferedReader ( new FileReader ( prepend ) ) ; } if ( append != null ) { if ( ! append . isAbsolute ( ) ) { append = new File ( getProject ( ) . getBaseDir ( ) , append . getPath ( ) ) ; } appendReader = new BufferedReader ( new FileReader ( append ) ) ; } } } 	0	['9', '5', '0', '4', '28', '12', '0', '4', '8', '0.5', '217', '1', '0', '0.8', '0.481481481', '2', '5', '22.66666667', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . util . Vector ; public class ImportTask extends Task { private String file ; private boolean optional ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setOptional ( boolean optional ) { this . optional = optional ; } public void setFile ( String file ) { this . file = file ; } public void execute ( ) { if ( file == null ) { throw new BuildException ( "import requires file attribute" ) ; } if ( getOwningTarget ( ) == null || ! "" . equals ( getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "import only allowed as a top-level task" ) ; } ProjectHelper helper = ( ProjectHelper ) getProject ( ) . getReference ( ProjectHelper . PROJECTHELPER_REFERENCE ) ; if ( helper == null ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } Vector importStack = helper . getImportStack ( ) ; if ( importStack . size ( ) == 0 ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } if ( getLocation ( ) == null || getLocation ( ) . getFileName ( ) == null ) { throw new BuildException ( "Unable to get location of import task" ) ; } File buildFile = new File ( getLocation ( ) . getFileName ( ) ) . getAbsoluteFile ( ) ; File buildFileParent = new File ( buildFile . getParent ( ) ) ; File importedFile = FILE_UTILS . resolveFile ( buildFileParent , file ) ; getProject ( ) . log ( "Importing file " + importedFile + " from " + buildFile . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( ! importedFile . exists ( ) ) { String message = "Cannot find " + file + " imported from " + buildFile . getAbsolutePath ( ) ; if ( optional ) { getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; return ; } else { throw new BuildException ( message ) ; } } if ( importStack . contains ( importedFile ) ) { getProject ( ) . log ( "Skipped already imported file:\n   " + importedFile + "\n" , Project . MSG_VERBOSE ) ; return ; } try { helper . parse ( getProject ( ) , importedFile ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } } 	0	['5', '3', '0', '7', '31', '4', '0', '7', '4', '0.75', '178', '1', '1', '0.925', '0.5', '2', '2', '34', '11', '2.6', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Resolve extends P4Base { private String resolvemode = null ; private boolean redoall ; private boolean simulationmode ; private boolean forcetextmode ; private boolean markersforall ; private static final String AUTOMATIC = "automatic" ; private static final String FORCE = "force" ; private static final String SAFE = "safe" ; private static final String THEIRS = "theirs" ; private static final String YOURS = "yours" ; private static final String [ ] RESOLVE_MODES = { AUTOMATIC , FORCE , SAFE , THEIRS , YOURS } ; public String getResolvemode ( ) { return resolvemode ; } public void setResolvemode ( String resolvemode ) { boolean found = false ; for ( int counter = 0 ; counter < RESOLVE_MODES . length ; counter ++ ) { if ( resolvemode . equals ( RESOLVE_MODES [ counter ] ) ) { found = true ; break ; } } if ( ! found ) { throw new BuildException ( "Unacceptable value for resolve mode" ) ; } this . resolvemode = resolvemode ; } public boolean isRedoall ( ) { return redoall ; } public void setRedoall ( boolean redoall ) { this . redoall = redoall ; } public boolean isSimulationmode ( ) { return simulationmode ; } public void setSimulationmode ( boolean simulationmode ) { this . simulationmode = simulationmode ; } public boolean isForcetextmode ( ) { return forcetextmode ; } public void setForcetextmode ( boolean forcetextmode ) { this . forcetextmode = forcetextmode ; } public boolean isMarkersforall ( ) { return markersforall ; } public void setMarkersforall ( boolean markersforall ) { this . markersforall = markersforall ; } public void execute ( ) throws BuildException { if ( this . resolvemode . equals ( AUTOMATIC ) ) { P4CmdOpts = P4CmdOpts + " -am" ; } else if ( this . resolvemode . equals ( FORCE ) ) { P4CmdOpts = P4CmdOpts + " -af" ; } else if ( this . resolvemode . equals ( SAFE ) ) { P4CmdOpts = P4CmdOpts + " -as" ; } else if ( this . resolvemode . equals ( THEIRS ) ) { P4CmdOpts = P4CmdOpts + " -at" ; } else if ( this . resolvemode . equals ( YOURS ) ) { P4CmdOpts = P4CmdOpts + " -ay" ; } else { throw new BuildException ( "unsupported or absent resolve mode" ) ; } if ( P4View == null ) { throw new BuildException ( "please specify a view" ) ; } if ( this . isRedoall ( ) ) { P4CmdOpts = P4CmdOpts + " -f" ; } if ( this . isSimulationmode ( ) ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . isForcetextmode ( ) ) { P4CmdOpts = P4CmdOpts + " -t" ; } if ( this . isMarkersforall ( ) ) { P4CmdOpts = P4CmdOpts + " -v" ; } execP4Command ( "-s resolve " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['13', '4', '0', '4', '22', '56', '0', '4', '12', '0.946969697', '298', '1', '0', '0.822580645', '0.472222222', '2', '2', '21.07692308', '4', '1.0769', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class SendEmail extends EmailTask { public void setMailport ( Integer value ) { setMailport ( value . intValue ( ) ) ; } } 	0	['2', '4', '0', '1', '5', '1', '0', '1', '2', '2', '10', '0', '0', '0.985507246', '0.75', '1', '1', '4', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . ProjectComponent ; public class StringTokenizer extends ProjectComponent implements Tokenizer { private String intraString = "" ; private int pushed = - 2 ; private char [ ] delims = null ; private boolean delimsAreTokens = false ; private boolean suppressDelims = false ; private boolean includeDelims = false ; public void setDelims ( String delims ) { this . delims = StringUtils . resolveBackSlash ( delims ) . toCharArray ( ) ; } public void setDelimsAreTokens ( boolean delimsAreTokens ) { this . delimsAreTokens = delimsAreTokens ; } public void setSuppressDelims ( boolean suppressDelims ) { this . suppressDelims = suppressDelims ; } public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } boolean inToken = true ; intraString = "" ; StringBuffer word = new StringBuffer ( ) ; StringBuffer padding = new StringBuffer ( ) ; while ( ch != - 1 ) { char c = ( char ) ch ; boolean isDelim = isDelim ( c ) ; if ( inToken ) { if ( isDelim ) { if ( delimsAreTokens ) { if ( word . length ( ) == 0 ) { word . append ( c ) ; } else { pushed = ch ; } break ; } padding . append ( c ) ; inToken = false ; } else { word . append ( c ) ; } } else { if ( isDelim ) { padding . append ( c ) ; } else { pushed = ch ; break ; } } ch = in . read ( ) ; } intraString = padding . toString ( ) ; if ( includeDelims ) { word . append ( intraString ) ; } return word . toString ( ) ; } public String getPostToken ( ) { return suppressDelims || includeDelims ? "" : intraString ; } private boolean isDelim ( char ch ) { if ( delims == null ) { return Character . isWhitespace ( ch ) ; } for ( int i = 0 ; i < delims . length ; ++ i ) { if ( delims [ i ] == ch ) { return true ; } } return false ; } } 	0	['8', '2', '1', '4', '18', '2', '1', '3', '7', '0.69047619', '194', '1', '0', '0.5625', '0.35', '0', '0', '22.5', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . GreedyInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . input . PropertyFileInputHandler ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { public class Handler extends DefBase { private String refid = null ; private HandlerType type = null ; private String classname = null ; public void setRefid ( String refid ) { this . refid = refid ; } public String getRefid ( ) { return refid ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setType ( HandlerType type ) { this . type = type ; } public HandlerType getType ( ) { return type ; } private InputHandler getInputHandler ( ) { if ( type != null ) { return type . getInputHandler ( ) ; } if ( refid != null ) { try { return ( InputHandler ) ( getProject ( ) . getReference ( refid ) ) ; } catch ( ClassCastException e ) { throw new BuildException ( refid + " does not denote an InputHandler" , e ) ; } } if ( classname != null ) { return ( InputHandler ) ( ClasspathUtils . newInstance ( classname , createLoader ( ) , InputHandler . class ) ) ; } throw new BuildException ( "Must specify refid, classname or type" ) ; } } public static class HandlerType extends EnumeratedAttribute { private static final String [ ] VALUES = { "default" , "propertyfile" , "greedy" } ; private static final InputHandler [ ] HANDLERS = { new DefaultInputHandler ( ) , new PropertyFileInputHandler ( ) , new GreedyInputHandler ( ) } ; public String [ ] getValues ( ) { return VALUES ; } private InputHandler getInputHandler ( ) { return HANDLERS [ getIndex ( ) ] ; } } private String validargs = null ; private String message = "" ; private String addproperty = null ; private String defaultvalue = null ; private Handler handler = null ; private boolean messageAttribute ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; messageAttribute = true ; } public void setDefaultvalue ( String defaultvalue ) { this . defaultvalue = defaultvalue ; } public void addText ( String msg ) { if ( messageAttribute && "" . equals ( msg . trim ( ) ) ) { return ; } message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { if ( addproperty != null && getProject ( ) . getProperty ( addproperty ) != null ) { log ( "skipping " + getTaskName ( ) + " as property " + addproperty + " has already been set." ) ; return ; } InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } request . setDefaultValue ( defaultvalue ) ; InputHandler h = handler == null ? getProject ( ) . getInputHandler ( ) : handler . getInputHandler ( ) ; h . handleInput ( request ) ; String value = request . getInput ( ) ; if ( ( value == null || value . trim ( ) . length ( ) == 0 ) && defaultvalue != null ) { value = defaultvalue ; } if ( addproperty != null && value != null ) { getProject ( ) . setNewProperty ( addproperty , value ) ; } } public Handler createHandler ( ) { if ( handler != null ) { throw new BuildException ( "Cannot define > 1 nested input handler" ) ; } handler = new Handler ( ) ; return handler ; } } 	0	['8', '3', '0', '8', '32', '0', '1', '8', '8', '0.775510204', '190', '0.857142857', '1', '0.840909091', '0.8125', '1', '1', '21.875', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public abstract class SOS extends Task implements SOSCmd { private String sosCmdDir = null ; private String sosUsername = null ; private String sosPassword = "" ; private String projectPath = null ; private String vssServerPath = null ; private String sosServerPath = null ; private String sosHome = null ; private String localPath = null ; private String version = null ; private String label = null ; private String comment = null ; private String filename = null ; private boolean noCompress = false ; private boolean noCache = false ; private boolean recursive = false ; private boolean verbose = false ; protected Commandline commandLine ; public final void setNoCache ( boolean nocache ) { noCache = nocache ; } public final void setNoCompress ( boolean nocompress ) { noCompress = nocompress ; } public final void setSosCmd ( String dir ) { sosCmdDir = FileUtils . translatePath ( dir ) ; } public final void setUsername ( String username ) { sosUsername = username ; } public final void setPassword ( String password ) { sosPassword = password ; } public final void setProjectPath ( String projectpath ) { if ( projectpath . startsWith ( SOSCmd . PROJECT_PREFIX ) ) { projectPath = projectpath ; } else { projectPath = SOSCmd . PROJECT_PREFIX + projectpath ; } } public final void setVssServerPath ( String vssServerPath ) { this . vssServerPath = vssServerPath ; } public final void setSosHome ( String sosHome ) { this . sosHome = sosHome ; } public final void setSosServerPath ( String sosServerPath ) { this . sosServerPath = sosServerPath ; } public final void setLocalPath ( Path path ) { localPath = path . toString ( ) ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } protected void setInternalFilename ( String file ) { filename = file ; } protected void setInternalRecursive ( boolean recurse ) { recursive = recurse ; } protected void setInternalComment ( String text ) { comment = text ; } protected void setInternalLabel ( String text ) { label = text ; } protected void setInternalVersion ( String text ) { version = text ; } protected String getSosCommand ( ) { if ( sosCmdDir == null ) { return COMMAND_SOS_EXE ; } else { return sosCmdDir + File . separator + COMMAND_SOS_EXE ; } } protected String getComment ( ) { return comment ; } protected String getVersion ( ) { return version ; } protected String getLabel ( ) { return label ; } protected String getUsername ( ) { return sosUsername ; } protected String getPassword ( ) { return sosPassword ; } protected String getProjectPath ( ) { return projectPath ; } protected String getVssServerPath ( ) { return vssServerPath ; } protected String getSosHome ( ) { return sosHome ; } protected String getSosServerPath ( ) { return sosServerPath ; } protected String getFilename ( ) { return filename ; } protected String getNoCompress ( ) { return noCompress ? FLAG_NO_COMPRESSION : "" ; } protected String getNoCache ( ) { return noCache ? FLAG_NO_CACHE : "" ; } protected String getVerbose ( ) { return verbose ? FLAG_VERBOSE : "" ; } protected String getRecursive ( ) { return recursive ? FLAG_RECURSION : "" ; } protected String getLocalPath ( ) { if ( localPath == null ) { return getProject ( ) . getBaseDir ( ) . getAbsolutePath ( ) ; } else { File dir = getProject ( ) . resolveFile ( localPath ) ; if ( ! dir . exists ( ) ) { boolean done = dir . mkdirs ( ) ; if ( ! done ) { String msg = "Directory " + localPath + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } getProject ( ) . log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } return dir . getAbsolutePath ( ) ; } } abstract Commandline buildCmdLine ( ) ; public void execute ( ) throws BuildException { int result = 0 ; buildCmdLine ( ) ; result = run ( commandLine ) ; if ( result == 255 ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected int run ( Commandline cmd ) { try { Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; exe . setVMLauncher ( false ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected void getRequiredAttributes ( ) { commandLine . setExecutable ( getSosCommand ( ) ) ; if ( getSosServerPath ( ) == null ) { throw new BuildException ( "sosserverpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_SOS_SERVER ) ; commandLine . createArgument ( ) . setValue ( getSosServerPath ( ) ) ; if ( getUsername ( ) == null ) { throw new BuildException ( "username attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_USERNAME ) ; commandLine . createArgument ( ) . setValue ( getUsername ( ) ) ; commandLine . createArgument ( ) . setValue ( FLAG_PASSWORD ) ; commandLine . createArgument ( ) . setValue ( getPassword ( ) ) ; if ( getVssServerPath ( ) == null ) { throw new BuildException ( "vssserverpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_VSS_SERVER ) ; commandLine . createArgument ( ) . setValue ( getVssServerPath ( ) ) ; if ( getProjectPath ( ) == null ) { throw new BuildException ( "projectpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getProjectPath ( ) ) ; } protected void getOptionalAttributes ( ) { commandLine . createArgument ( ) . setValue ( getVerbose ( ) ) ; commandLine . createArgument ( ) . setValue ( getNoCompress ( ) ) ; if ( getSosHome ( ) == null ) { commandLine . createArgument ( ) . setValue ( getNoCache ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( FLAG_SOS_HOME ) ; commandLine . createArgument ( ) . setValue ( getSosHome ( ) ) ; } if ( getLocalPath ( ) != null ) { commandLine . createArgument ( ) . setValue ( FLAG_WORKING_DIR ) ; commandLine . createArgument ( ) . setValue ( getLocalPath ( ) ) ; } } } 	0	['38', '3', '4', '16', '68', '601', '4', '12', '13', '0.92845787', '534', '1', '1', '0.5', '0.289473684', '0', '0', '12.60526316', '5', '1.3684', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class DotnetDefine { private String name ; private String ifCond ; private String unlessCond ; public void setIf ( String condition ) { this . ifCond = condition ; } public void setUnless ( String condition ) { this . unlessCond = condition ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( Task owner ) throws BuildException { if ( name == null ) { throw new BuildException ( "No name provided for the define element" , owner . getLocation ( ) ) ; } if ( ! isSet ( owner ) ) { return null ; } return name ; } public boolean isSet ( Task owner ) { Project p = owner . getProject ( ) ; if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } } 	0	['7', '1', '0', '5', '12', '11', '1', '4', '7', '0.666666667', '72', '1', '0', '0', '0.571428571', '0', '0', '8.857142857', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . util . Date ; public class CCMCheckin extends CCMCheck { public CCMCheckin ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKIN ) ; setComment ( "Checkin " + new Date ( ) ) ; } } 	0	['1', '5', '0', '1', '8', '0', '0', '1', '1', '2', '18', '0', '0', '1', '1', '0', '0', '17', '0', '0', '0']
package org . apache . tools . ant ; public interface SubBuildListener extends BuildListener { void subBuildStarted ( BuildEvent event ) ; void subBuildFinished ( BuildEvent event ) ; } 	0	['2', '1', '0', '6', '2', '1', '4', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . zip . GZIPInputStream ; import java . util . zip . GZIPOutputStream ; public class GZipResource extends CompressedResource { public GZipResource ( ) { } public GZipResource ( org . apache . tools . ant . types . ResourceCollection other ) { super ( other ) ; } protected InputStream wrapStream ( InputStream in ) throws IOException { return new GZIPInputStream ( in ) ; } protected OutputStream wrapStream ( OutputStream out ) throws IOException { return new GZIPOutputStream ( out ) ; } protected String getCompressionName ( ) { return "GZip" ; } } 	0	['5', '5', '0', '2', '9', '10', '0', '2', '2', '2', '24', '0', '0', '0.961538462', '0.4', '1', '2', '3.8', '1', '0.6', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private static final String NEGATE_KEY = "negate" ; private Vector regexps = new Vector ( ) ; private String line = null ; private boolean negate = false ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { final int regexpsSize = regexps . size ( ) ; for ( line = readLine ( ) ; line != null ; line = readLine ( ) ) { boolean matches = true ; for ( int i = 0 ; matches && i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; matches = re . matches ( line ) ; } if ( matches ^ isNegated ( ) ) { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private Vector getRegexps ( ) { return regexps ; } public Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setNegate ( isNegated ( ) ) ; return newFilter ; } public void setNegate ( boolean b ) { negate = b ; } public boolean isNegated ( ) { return negate ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } else if ( NEGATE_KEY . equals ( params [ i ] . getType ( ) ) ) { setNegate ( Project . toBoolean ( params [ i ] . getValue ( ) ) ) ; } } } } } 	0	['10', '5', '0', '7', '32', '0', '1', '6', '7', '0.688888889', '221', '1', '0', '0.777777778', '0.3', '2', '5', '20.6', '5', '1.2', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class FileSet extends AbstractFileSet implements ResourceCollection { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( getDir ( getProject ( ) ) , getDirectoryScanner ( getProject ( ) ) . getIncludedFiles ( ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( getProject ( ) ) . getIncludedFilesCount ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } 	0	['6', '4', '5', '64', '17', '15', '59', '5', '5', '2', '67', '0', '0', '0.956043956', '0.583333333', '3', '4', '10.16666667', '2', '1.1667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . ResourceUtils ; public class ResourcesMatch implements Condition { private Union resources = null ; private boolean asText = false ; public void setAsText ( boolean asText ) { this . asText = asText ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } resources = resources == null ? new Union ( ) : resources ; resources . add ( rc ) ; } public boolean eval ( ) throws BuildException { if ( resources == null ) { throw new BuildException ( "You must specify one or more nested resource collections" ) ; } if ( resources . size ( ) > 1 ) { Iterator i = resources . iterator ( ) ; Resource r1 = ( Resource ) i . next ( ) ; Resource r2 = null ; while ( i . hasNext ( ) ) { r2 = ( Resource ) i . next ( ) ; try { if ( ! ResourceUtils . contentEquals ( r1 , r2 , asText ) ) { return false ; } } catch ( IOException ioe ) { throw new BuildException ( "when comparing resources " + r1 . toString ( ) + " and " + r2 . toString ( ) , ioe ) ; } r1 = r2 ; } } return true ; } } 	0	['4', '1', '0', '6', '18', '0', '0', '6', '4', '0.333333333', '100', '1', '1', '0', '0.5', '0', '0', '23.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property = null ; private String value = "true" ; private String alternative = null ; public ConditionTask ( ) { super ( "condition" ) ; } public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void setElse ( String e ) { alternative = e ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <" + getTaskName ( ) + ">" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <" + getTaskName ( ) + ">" ) ; } if ( property == null ) { throw new BuildException ( "The property attribute is required." ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { log ( "Condition true; setting " + property + " to " + value , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , value ) ; } else if ( alternative != null ) { log ( "Condition false; setting " + property + " to " + alternative , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , alternative ) ; } else { log ( "Condition false; not setting " + property , Project . MSG_DEBUG ) ; } } } 	0	['5', '3', '0', '4', '18', '0', '0', '4', '5', '0.5', '148', '1', '0', '0.888888889', '0.8', '0', '0', '28', '1', '0.8', '0']
package org . apache . tools . ant . util . depend ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . types . Path ; public interface DependencyAnalyzer { void addSourcePath ( Path sourcePath ) ; void addClassPath ( Path classpath ) ; void addRootClass ( String classname ) ; Enumeration getFileDependencies ( ) ; Enumeration getClassDependencies ( ) ; void reset ( ) ; void config ( String name , Object info ) ; void setClosure ( boolean closure ) ; File getClassContainer ( String classname ) throws IOException ; File getSourceContainer ( String classname ) throws IOException ; } 	0	['10', '1', '0', '5', '10', '45', '4', '1', '10', '2', '10', '0', '0', '0', '0.36', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSCheckout extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKOUT_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKOUT_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; return commandLine ; } } 	0	['4', '4', '0', '3', '14', '6', '0', '3', '3', '2', '68', '0', '0', '0.961038961', '0.5', '1', '2', '16', '2', '1', '0']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; public class ScriptCondition extends AbstractScriptComponent implements Condition { private boolean value = false ; public boolean eval ( ) throws BuildException { initScriptRunner ( ) ; executeScript ( "ant_condition" ) ; return getValue ( ) ; } public boolean getValue ( ) { return value ; } public void setValue ( boolean value ) { this . value = value ; } } 	0	['4', '3', '0', '3', '7', '0', '0', '3', '4', '0', '26', '1', '0', '0.869565217', '0.625', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . ProjectComponent ; public class FileTokenizer extends ProjectComponent implements Tokenizer { public String getToken ( Reader in ) throws IOException { return FileUtils . readFully ( in ) ; } public String getPostToken ( ) { return "" ; } } 	0	['3', '2', '1', '4', '5', '3', '1', '3', '3', '2', '11', '0', '0', '0.818181818', '0.666666667', '0', '0', '2.666666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , getLocation ( ) ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , getLocation ( ) ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , getLocation ( ) ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { getProject ( ) . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '4', '24', '1', '0', '4', '6', '0.7', '135', '1', '0', '0.880952381', '0.416666667', '3', '3', '20.83333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; import org . apache . tools . ant . dispatch . Dispatchable ; import org . apache . tools . ant . dispatch . DispatchUtils ; public class TaskAdapter extends Task implements TypeAdapter { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { if ( ! Dispatchable . class . isAssignableFrom ( taskClass ) ) { try { final Method executeM = taskClass . getMethod ( "execute" , ( Class [ ] ) null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } catch ( LinkageError e ) { String message = "Could not load " + taskClass + ": " + e ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message , e ) ; } } } public void checkProxyClass ( Class proxyClass ) { checkTaskClass ( proxyClass , getProject ( ) ) ; } public void execute ( ) throws BuildException { try { Method setLocationM = proxy . getClass ( ) . getMethod ( "setLocation" , new Class [ ] { Location . class } ) ; if ( setLocationM != null ) { setLocationM . invoke ( proxy , new Object [ ] { getLocation ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting location in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } try { Method setProjectM = proxy . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { getProject ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } try { DispatchUtils . execute ( proxy ) ; } catch ( BuildException be ) { throw be ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return proxy ; } } 	0	['6', '3', '0', '7', '28', '9', '2', '6', '6', '0.85', '261', '0.25', '0', '0.880952381', '0.375', '1', '1', '41.83333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Reference ; public class AntStructure extends Task { private static final String LINE_SEP = System . getProperty ( "line.separator" ) ; private File output ; private StructurePrinter printer = new DTDPrinter ( ) ; public void setOutput ( File output ) { this . output = output ; } public void add ( StructurePrinter p ) { printer = p ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , getLocation ( ) ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printer . printHead ( out , getProject ( ) , getProject ( ) . getTaskDefinitions ( ) , getProject ( ) . getDataTypeDefinitions ( ) ) ; printer . printTargetDecl ( out ) ; Enumeration dataTypes = getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printer . printElementDecl ( out , getProject ( ) , typeName , ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = getProject ( ) . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String tName = ( String ) tasks . nextElement ( ) ; printer . printElementDecl ( out , getProject ( ) , tName , ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( tName ) ) ; } printer . printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , getLocation ( ) ) ; } finally { if ( out != null ) { out . close ( ) ; } } } public static interface StructurePrinter { void printHead ( PrintWriter out , Project p , Hashtable tasks , Hashtable types ) ; void printTargetDecl ( PrintWriter out ) ; void printElementDecl ( PrintWriter out , Project p , String name , Class element ) ; void printTail ( PrintWriter out ) ; } private static class DTDPrinter implements StructurePrinter { private static final String BOOLEAN = "%boolean;" ; private static final String TASKS = "%tasks;" ; private static final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; public void printTail ( PrintWriter out ) { visited . clear ( ) ; } public void printHead ( PrintWriter out , Project p , Hashtable tasks , Hashtable types ) { printHead ( out , tasks . keys ( ) , types . keys ( ) ) ; } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String tName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( tName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | " ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #IMPLIED" ) ; out . println ( "          default CDATA #IMPLIED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } public void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } public void printElementDecl ( PrintWriter out , Project p , String name , Class element ) { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( p , element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( LINE_SEP ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( LINE_SEP ) . append ( "          id ID #IMPLIED" ) ; sb . append ( LINE_SEP ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( LINE_SEP ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration e = ih . getNestedElements ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( count > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb = new StringBuffer ( "<!ATTLIST " ) ; sb . append ( name ) ; sb . append ( LINE_SEP ) . append ( "          id ID #IMPLIED" ) ; e = ih . getAttributes ( ) ; while ( e . hasMoreElements ( ) ) { String attrName = ( String ) e . nextElement ( ) ; if ( "id" . equals ( attrName ) ) { continue ; } sb . append ( LINE_SEP ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else if ( type . getSuperclass ( ) != null && type . getSuperclass ( ) . getName ( ) . equals ( "java.lang.Enum" ) ) { try { Object [ ] values = ( Object [ ] ) type . getMethod ( "values" , ( Class [ ] ) null ) . invoke ( null , ( Object [ ] ) null ) ; if ( values . length == 0 ) { sb . append ( "CDATA " ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( type . getMethod ( "name" , ( Class [ ] ) null ) . invoke ( values [ i ] , ( Object [ ] ) null ) ) ; } sb . append ( ") " ) ; } } catch ( Exception x ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( LINE_SEP ) ; out . println ( sb ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , p , nestedName , ih . getElementType ( nestedName ) ) ; } } } public static final boolean isNmtoken ( String s ) { final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } public static final boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } protected boolean isNmtoken ( String s ) { return DTDPrinter . isNmtoken ( s ) ; } protected boolean areNmtokens ( String [ ] s ) { return DTDPrinter . areNmtokens ( s ) ; } } 	0	['8', '3', '0', '6', '36', '18', '1', '6', '4', '1', '182', '0.428571429', '1', '0.860465116', '0.285714286', '0', '0', '20.875', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . util . Date ; import java . util . Vector ; public class CVSEntry { private Date date ; private String author ; private final String comment ; private final Vector files = new Vector ( ) ; public CVSEntry ( final Date date , final String author , final String comment ) { this . date = date ; this . author = author ; this . comment = comment ; } public void addFile ( final String file , final String revision ) { files . addElement ( new RCSFile ( file , revision ) ) ; } public void addFile ( final String file , final String revision , final String previousRevision ) { files . addElement ( new RCSFile ( file , revision , previousRevision ) ) ; } public Date getDate ( ) { return date ; } public void setAuthor ( final String author ) { this . author = author ; } public String getAuthor ( ) { return author ; } public String getComment ( ) { return comment ; } public Vector getFiles ( ) { return files ; } public String toString ( ) { return getAuthor ( ) + "\n" + getDate ( ) + "\n" + getFiles ( ) + "\n" + getComment ( ) ; } } 	0	['9', '1', '0', '4', '19', '14', '3', '1', '9', '0.65625', '88', '1', '0', '0', '0.518518519', '0', '0', '8.333333333', '1', '0.8889', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . types . Resource ; public class InstanceOf implements ResourceSelector { private static final String ONE_ONLY = "Exactly one of class|type must be set." ; private Project project ; private Class clazz ; private String type ; private String uri ; public void setProject ( Project p ) { project = p ; } public void setClass ( Class c ) { if ( clazz != null ) { throw new BuildException ( "The class attribute has already been set." ) ; } clazz = c ; } public void setType ( String s ) { type = s ; } public void setURI ( String u ) { uri = u ; } public Class getCheckClass ( ) { return clazz ; } public String getType ( ) { return type ; } public String getURI ( ) { return uri ; } public boolean isSelected ( Resource r ) { if ( ( clazz == null ) == ( type == null ) ) { throw new BuildException ( ONE_ONLY ) ; } Class c = clazz ; if ( type != null ) { if ( project == null ) { throw new BuildException ( "No project set for InstanceOf ResourceSelector; " + "the type attribute is invalid." ) ; } AntTypeDefinition d = ComponentHelper . getComponentHelper ( project ) . getDefinition ( ProjectHelper . genComponentName ( uri , type ) ) ; if ( d == null ) { throw new BuildException ( "type " + type + " not found." ) ; } try { c = d . innerGetTypeClass ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( e ) ; } } return c . isAssignableFrom ( r . getClass ( ) ) ; } } 	0	['9', '1', '0', '7', '21', '16', '0', '7', '9', '0.85', '123', '1', '1', '0', '0.311111111', '0', '0', '12.11111111', '7', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; import java . util . Date ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . Path ; public class WLJspc extends MatchingTask { private File destinationDirectory ; private File sourceDirectory ; private String destinationPackage ; private Path compileClasspath ; private String pathToPackage = "" ; private Vector filesToDo = new Vector ( ) ; public void execute ( ) throws BuildException { if ( ! destinationDirectory . isDirectory ( ) ) { throw new BuildException ( "destination directory " + destinationDirectory . getPath ( ) + " is not valid" ) ; } if ( ! sourceDirectory . isDirectory ( ) ) { throw new BuildException ( "src directory " + sourceDirectory . getPath ( ) + " is not valid" ) ; } if ( destinationPackage == null ) { throw new BuildException ( "package attribute must be present." , getLocation ( ) ) ; } pathToPackage = this . destinationPackage . replace ( '.' , File . separatorChar ) ; DirectoryScanner ds = super . getDirectoryScanner ( sourceDirectory ) ; if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } compileClasspath = compileClasspath . concatSystemClasspath ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; Java helperTask = new Java ( this ) ; helperTask . setFork ( true ) ; helperTask . setClassname ( "weblogic.jspc" ) ; helperTask . setTaskName ( getTaskName ( ) ) ; String [ ] args = new String [ 12 ] ; File jspFile = null ; String parents = "" ; int j = 0 ; args [ j ++ ] = "-d" ; args [ j ++ ] = destinationDirectory . getAbsolutePath ( ) . trim ( ) ; args [ j ++ ] = "-docroot" ; args [ j ++ ] = sourceDirectory . getAbsolutePath ( ) . trim ( ) ; args [ j ++ ] = "-keepgenerated" ; args [ j ++ ] = "-compilerclass" ; args [ j ++ ] = "sun.tools.javac.Main" ; args [ j ++ ] = "-classpath" ; args [ j ++ ] = compileClasspath . toString ( ) ; this . scanDir ( files ) ; log ( "Compiling " + filesToDo . size ( ) + " JSP files" ) ; for ( int i = 0 ; i < filesToDo . size ( ) ; i ++ ) { String filename = ( String ) filesToDo . elementAt ( i ) ; jspFile = new File ( filename ) ; args [ j ] = "-package" ; parents = jspFile . getParent ( ) ; if ( ( parents != null ) && ( ! ( "" ) . equals ( parents ) ) ) { parents = this . replaceString ( parents , File . separator , "_." ) ; args [ j + 1 ] = destinationPackage + "." + "_" + parents ; } else { args [ j + 1 ] = destinationPackage ; } args [ j + 2 ] = sourceDirectory + File . separator + filename ; helperTask . clearArgs ( ) ; for ( int x = 0 ; x < j + 3 ; x ++ ) { helperTask . createArg ( ) . setValue ( args [ x ] ) ; } helperTask . setClasspath ( compileClasspath ) ; if ( helperTask . executeJava ( ) != 0 ) { log ( filename + " failed to compile" , Project . MSG_WARN ) ; } } } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath ; } public void setSrc ( File dirName ) { sourceDirectory = dirName ; } public void setDest ( File dirName ) { destinationDirectory = dirName ; } public void setPackage ( String packageName ) { destinationPackage = packageName ; } protected void scanDir ( String [ ] files ) { long now = ( new Date ( ) ) . getTime ( ) ; File jspFile = null ; String parents = null ; String pack = "" ; for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( this . sourceDirectory , files [ i ] ) ; jspFile = new File ( files [ i ] ) ; parents = jspFile . getParent ( ) ; if ( ( parents != null ) && ( ! ( "" ) . equals ( parents ) ) ) { parents = this . replaceString ( parents , File . separator , "_/" ) ; pack = pathToPackage + File . separator + "_" + parents ; } else { pack = pathToPackage ; } String filePath = pack + File . separator + "_" ; int startingIndex = files [ i ] . lastIndexOf ( File . separator ) != - 1 ? files [ i ] . lastIndexOf ( File . separator ) + 1 : 0 ; int endingIndex = files [ i ] . indexOf ( ".jsp" ) ; if ( endingIndex == - 1 ) { log ( "Skipping " + files [ i ] + ". Not a JSP" , Project . MSG_VERBOSE ) ; continue ; } filePath += files [ i ] . substring ( startingIndex , endingIndex ) ; filePath += ".class" ; File classFile = new File ( this . destinationDirectory , filePath ) ; if ( srcFile . lastModified ( ) > now ) { log ( "Warning: file modified in the future: " + files [ i ] , Project . MSG_WARN ) ; } if ( srcFile . lastModified ( ) > classFile . lastModified ( ) ) { filesToDo . addElement ( files [ i ] ) ; log ( "Recompiling File " + files [ i ] , Project . MSG_VERBOSE ) ; } } } protected String replaceString ( String inpString , String escapeChars , String replaceChars ) { String localString = "" ; int numTokens = 0 ; StringTokenizer st = new StringTokenizer ( inpString , escapeChars , true ) ; numTokens = st . countTokens ( ) ; for ( int i = 0 ; i < numTokens ; i ++ ) { String test = st . nextToken ( ) ; test = ( test . equals ( escapeChars ) ? replaceChars : test ) ; localString += test ; } return localString ; } } 	0	['9', '4', '0', '9', '61', '14', '0', '9', '7', '0.770833333', '586', '1', '1', '0.906976744', '0.333333333', '4', '4', '63.44444444', '8', '2.1111', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . ArrayList ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Redirector ; public class RedirectorElement extends DataType { private boolean usingInput = false ; private boolean usingOutput = false ; private boolean usingError = false ; private Boolean logError ; private String outputProperty ; private String errorProperty ; private String inputString ; private Boolean append ; private Boolean alwaysLog ; private Boolean createEmptyFiles ; private Mapper inputMapper ; private Mapper outputMapper ; private Mapper errorMapper ; private Vector inputFilterChains = new Vector ( ) ; private Vector outputFilterChains = new Vector ( ) ; private Vector errorFilterChains = new Vector ( ) ; private String outputEncoding ; private String errorEncoding ; private String inputEncoding ; private Boolean logInputString ; public void addConfiguredInputMapper ( Mapper inputMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . inputMapper != null ) { if ( usingInput ) { throw new BuildException ( "attribute \"input\"" + " cannot coexist with a nested <inputmapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <inputmapper>" ) ; } } this . inputMapper = inputMapper ; } public void addConfiguredOutputMapper ( Mapper outputMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . outputMapper != null ) { if ( usingOutput ) { throw new BuildException ( "attribute \"output\"" + " cannot coexist with a nested <outputmapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <outputmapper>" ) ; } } this . outputMapper = outputMapper ; } public void addConfiguredErrorMapper ( Mapper errorMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . errorMapper != null ) { if ( usingError ) { throw new BuildException ( "attribute \"error\"" + " cannot coexist with a nested <errormapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <errormapper>" ) ; } } this . errorMapper = errorMapper ; } public void setRefid ( Reference r ) throws BuildException { if ( usingInput || usingOutput || usingError || inputString != null || logError != null || append != null || createEmptyFiles != null || inputEncoding != null || outputEncoding != null || errorEncoding != null || outputProperty != null || errorProperty != null || logInputString != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setInput ( File input ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } usingInput = true ; inputMapper = createMergeMapper ( input ) ; } public void setInputString ( String inputString ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( usingInput ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; } public void setLogInputString ( boolean logInputString ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . logInputString = logInputString ? Boolean . TRUE : Boolean . FALSE ; } public void setOutput ( File out ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( out == null ) { throw new IllegalArgumentException ( "output file specified as null" ) ; } usingOutput = true ; outputMapper = createMergeMapper ( out ) ; } public void setOutputEncoding ( String outputEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . outputEncoding = outputEncoding ; } public void setErrorEncoding ( String errorEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . errorEncoding = errorEncoding ; } public void setInputEncoding ( String inputEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . inputEncoding = inputEncoding ; } public void setLogError ( boolean logError ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . logError = ( ( logError ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setError ( File error ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( error == null ) { throw new IllegalArgumentException ( "error file specified as null" ) ; } usingError = true ; errorMapper = createMergeMapper ( error ) ; } public void setOutputProperty ( String outputProperty ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . outputProperty = outputProperty ; } public void setAppend ( boolean append ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . append = ( ( append ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setAlwaysLog ( boolean alwaysLog ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . alwaysLog = ( ( alwaysLog ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCreateEmptyFiles ( boolean createEmptyFiles ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . createEmptyFiles = ( ( createEmptyFiles ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setErrorProperty ( String errorProperty ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . errorProperty = errorProperty ; } public FilterChain createInputFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; inputFilterChains . add ( result ) ; return result ; } public FilterChain createOutputFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; outputFilterChains . add ( result ) ; return result ; } public FilterChain createErrorFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; errorFilterChains . add ( result ) ; return result ; } public void configure ( Redirector redirector ) { configure ( redirector , null ) ; } public void configure ( Redirector redirector , String sourcefile ) { if ( isReference ( ) ) { getRef ( ) . configure ( redirector , sourcefile ) ; return ; } if ( alwaysLog != null ) { redirector . setAlwaysLog ( alwaysLog . booleanValue ( ) ) ; } if ( logError != null ) { redirector . setLogError ( logError . booleanValue ( ) ) ; } if ( append != null ) { redirector . setAppend ( append . booleanValue ( ) ) ; } if ( createEmptyFiles != null ) { redirector . setCreateEmptyFiles ( createEmptyFiles . booleanValue ( ) ) ; } if ( outputProperty != null ) { redirector . setOutputProperty ( outputProperty ) ; } if ( errorProperty != null ) { redirector . setErrorProperty ( errorProperty ) ; } if ( inputString != null ) { redirector . setInputString ( inputString ) ; } if ( logInputString != null ) { redirector . setLogInputString ( logInputString . booleanValue ( ) ) ; } if ( inputMapper != null ) { String [ ] inputTargets = null ; try { inputTargets = inputMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( inputTargets != null && inputTargets . length > 0 ) { redirector . setInput ( toFileArray ( inputTargets ) ) ; } } if ( outputMapper != null ) { String [ ] outputTargets = null ; try { outputTargets = outputMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( outputTargets != null && outputTargets . length > 0 ) { redirector . setOutput ( toFileArray ( outputTargets ) ) ; } } if ( errorMapper != null ) { String [ ] errorTargets = null ; try { errorTargets = errorMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( errorTargets != null && errorTargets . length > 0 ) { redirector . setError ( toFileArray ( errorTargets ) ) ; } } if ( inputFilterChains . size ( ) > 0 ) { redirector . setInputFilterChains ( inputFilterChains ) ; } if ( outputFilterChains . size ( ) > 0 ) { redirector . setOutputFilterChains ( outputFilterChains ) ; } if ( errorFilterChains . size ( ) > 0 ) { redirector . setErrorFilterChains ( errorFilterChains ) ; } if ( inputEncoding != null ) { redirector . setInputEncoding ( inputEncoding ) ; } if ( outputEncoding != null ) { redirector . setOutputEncoding ( outputEncoding ) ; } if ( errorEncoding != null ) { redirector . setErrorEncoding ( errorEncoding ) ; } } protected Mapper createMergeMapper ( File destfile ) { Mapper result = new Mapper ( getProject ( ) ) ; result . setClassname ( org . apache . tools . ant . util . MergingMapper . class . getName ( ) ) ; result . setTo ( destfile . getAbsolutePath ( ) ) ; return result ; } protected File [ ] toFileArray ( String [ ] name ) { if ( name == null ) { return null ; } ArrayList list = new ArrayList ( name . length ) ; for ( int i = 0 ; i < name . length ; i ++ ) { if ( name [ i ] != null ) { list . add ( getProject ( ) . resolveFile ( name [ i ] ) ) ; } } return ( File [ ] ) ( list . toArray ( new File [ list . size ( ) ] ) ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { Mapper [ ] m = new Mapper [ ] { inputMapper , outputMapper , errorMapper } ; for ( int i = 0 ; i < m . length ; i ++ ) { if ( m [ i ] != null ) { stk . push ( m [ i ] ) ; m [ i ] . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } Vector [ ] v = new Vector [ ] { inputFilterChains , outputFilterChains , errorFilterChains } ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] != null ) { for ( Iterator fci = v [ i ] . iterator ( ) ; fci . hasNext ( ) ; ) { FilterChain fc = ( FilterChain ) fci . next ( ) ; stk . push ( fc ) ; fc . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } setChecked ( true ) ; } } private RedirectorElement getRef ( ) { return ( RedirectorElement ) getCheckedRef ( ) ; } } 	0	['28', '3', '0', '13', '85', '248', '5', '8', '24', '0.87654321', '860', '0.952380952', '3', '0.526315789', '0.189285714', '1', '4', '28.96428571', '28', '3.3214', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; cmd . setExecutable ( "at.dms.kjc.Main" ) ; ExecuteJava ej = new ExecuteJava ( ) ; ej . setJavaCommand ( cmd ) ; return ej . fork ( getJavac ( ) ) == 0 ; } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { cp . append ( p ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; if ( compileSourcepath != null ) { cp . append ( compileSourcepath ) ; } else { cp . append ( src ) ; } cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['3', '2', '0', '10', '23', '3', '1', '9', '2', '2', '145', '0', '0', '0.92', '1', '0', '0', '47.33333333', '10', '3.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class None extends ResourceSelectorContainer implements ResourceSelector { public None ( ) { } public None ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { boolean none = true ; for ( Iterator i = getSelectors ( ) ; none && i . hasNext ( ) ; ) { none = ! ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ; } return none ; } } 	0	['3', '4', '0', '3', '9', '3', '0', '3', '3', '2', '33', '0', '0', '0.972222222', '0.555555556', '0', '0', '10', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class WeblogicTOPLinkDeploymentTool extends WeblogicDeploymentTool { private static final String TL_DTD_LOC = "http://www.objectpeople.com/tlwl/dtd/toplink-cmp_2_5_1.dtd" ; private String toplinkDescriptor ; private String toplinkDTD ; public void setToplinkdescriptor ( String inString ) { this . toplinkDescriptor = inString ; } public void setToplinkdtd ( String inString ) { this . toplinkDTD = inString ; } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler handler = super . getDescriptorHandler ( srcDir ) ; if ( toplinkDTD != null ) { handler . registerDTD ( "-//The Object People, Inc.//" + "DTD TOPLink for WebLogic CMP 2.5.1//EN" , toplinkDTD ) ; } else { handler . registerDTD ( "-//The Object People, Inc.//" + "DTD TOPLink for WebLogic CMP 2.5.1//EN" , TL_DTD_LOC ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { super . addVendorFiles ( ejbFiles , ddPrefix ) ; File toplinkDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + toplinkDescriptor ) ; if ( toplinkDD . exists ( ) ) { ejbFiles . put ( META_DIR + toplinkDescriptor , toplinkDD ) ; } else { log ( "Unable to locate toplink deployment descriptor. " + "It was expected to be in " + toplinkDD . getPath ( ) , Project . MSG_WARN ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; if ( toplinkDescriptor == null ) { throw new BuildException ( "The toplinkdescriptor attribute must " + "be specified" ) ; } } } 	0	['6', '3', '0', '5', '22', '7', '1', '4', '4', '0.866666667', '98', '1', '0', '0.925373134', '0.458333333', '2', '4', '14.83333333', '2', '1.1667', '0']
package org . apache . tools . ant ; public interface DynamicConfigurator extends DynamicAttribute , DynamicElement { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool { protected static final String DEFAULT_ORB = "RMI" ; private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin" ; private static final String [ ] VALID_ACTIONS = { ACTION_DELETE , ACTION_DEPLOY , ACTION_LIST , ACTION_UNDEPLOY , ACTION_UPDATE } ; private File jonasroot ; private String orb = null ; private String davidHost ; private int davidPort ; public void setDavidhost ( final String inValue ) { davidHost = inValue ; } public void setDavidport ( final int inValue ) { davidPort = inValue ; } public void setJonasroot ( final File inValue ) { jonasroot = inValue ; } public void setOrb ( final String inValue ) { orb = inValue ; } public Path getClasspath ( ) { Path aClassPath = super . getClasspath ( ) ; if ( aClassPath == null ) { aClassPath = new Path ( getTask ( ) . getProject ( ) ) ; } if ( orb != null ) { String aOrbJar = new File ( jonasroot , "lib/" + orb + "_jonas.jar" ) . toString ( ) ; String aConfigDir = new File ( jonasroot , "config/" ) . toString ( ) ; Path aJOnASOrbPath = new Path ( aClassPath . getProject ( ) , aOrbJar + File . pathSeparator + aConfigDir ) ; aClassPath . append ( aJOnASOrbPath ) ; } return aClassPath ; } public void validateAttributes ( ) throws BuildException { Java java = getJava ( ) ; String action = getTask ( ) . getAction ( ) ; if ( action == null ) { throw new BuildException ( "The \"action\" attribute must be set" ) ; } if ( ! isActionValid ( ) ) { throw new BuildException ( "Invalid action \"" + action + "\" passed" ) ; } if ( getClassName ( ) == null ) { setClassName ( JONAS_DEPLOY_CLASS_NAME ) ; } if ( jonasroot == null || jonasroot . isDirectory ( ) ) { java . createJvmarg ( ) . setValue ( "-Dinstall.root=" + jonasroot ) ; java . createJvmarg ( ) . setValue ( "-Djava.security.policy=" + jonasroot + "/config/java.policy" ) ; if ( "DAVID" . equals ( orb ) ) { java . createJvmarg ( ) . setValue ( "-Dorg.omg.CORBA.ORBClass" + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB" ) ; java . createJvmarg ( ) . setValue ( "-Dorg.omg.CORBA.ORBSingletonClass=" + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.StubClass=" + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.PortableRemoteObjectClass=" + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.UtilClass=" + "org.objectweb.david.libs.helpers.RMIUtilDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_method=0" ) ; java . createJvmarg ( ) . setValue ( "-Ddavid.rmi.ValueHandlerClass=" + "com.sun.corba.se.internal.io.ValueHandlerImpl" ) ; if ( davidHost != null ) { java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_host=" + davidHost ) ; } if ( davidPort != 0 ) { java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_port=" + davidPort ) ; } } } if ( getServer ( ) != null ) { java . createArg ( ) . setLine ( "-n " + getServer ( ) ) ; } if ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) || action . equals ( "redeploy" ) ) { java . createArg ( ) . setLine ( "-a " + getTask ( ) . getSource ( ) ) ; } else if ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) { java . createArg ( ) . setLine ( "-r " + getTask ( ) . getSource ( ) ) ; } else if ( action . equals ( ACTION_LIST ) ) { java . createArg ( ) . setValue ( "-l" ) ; } } protected boolean isActionValid ( ) { boolean valid = false ; String action = getTask ( ) . getAction ( ) ; for ( int i = 0 ; i < VALID_ACTIONS . length ; i ++ ) { if ( action . equals ( VALID_ACTIONS [ i ] ) ) { valid = true ; break ; } } return valid ; } } 	0	['9', '3', '0', '8', '38', '14', '1', '8', '7', '0.875', '345', '1', '0', '0.766666667', '0.375', '3', '5', '36.55555556', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUnCheckout extends ClearCase { private boolean mKeep = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UNCHECKOUT ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getKeepCopy ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_KEEPCOPY ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_RM ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setKeepCopy ( boolean keep ) { mKeep = keep ; } public boolean getKeepCopy ( ) { return mKeep ; } public static final String FLAG_KEEPCOPY = "-keep" ; public static final String FLAG_RM = "-rm" ; } 	0	['5', '4', '0', '7', '27', '4', '0', '7', '4', '0.916666667', '109', '0.333333333', '0', '0.923076923', '0.466666667', '2', '3', '20.2', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import java . io . File ; import java . text . SimpleDateFormat ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class MSVSSHISTORY extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_HISTORY ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( FLAG_AUTORESPONSE_DEF ) ; commandLine . createArgument ( ) . setValue ( getVersionDate ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getStyle ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getOutput ( ) ) ; return commandLine ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setUser ( String user ) { super . setInternalUser ( user ) ; } public void setFromDate ( String fromDate ) { super . setInternalFromDate ( fromDate ) ; } public void setToDate ( String toDate ) { super . setInternalToDate ( toDate ) ; } public void setFromLabel ( String fromLabel ) { super . setInternalFromLabel ( fromLabel ) ; } public void setToLabel ( String toLabel ) { super . setInternalToLabel ( toLabel ) ; } public void setNumdays ( int numd ) { super . setInternalNumDays ( numd ) ; } public void setOutput ( File outfile ) { if ( outfile != null ) { super . setInternalOutputFilename ( outfile . getAbsolutePath ( ) ) ; } } public void setDateFormat ( String dateFormat ) { super . setInternalDateFormat ( new SimpleDateFormat ( dateFormat ) ) ; } public void setStyle ( BriefCodediffNofile attr ) { String option = attr . getValue ( ) ; if ( option . equals ( STYLE_BRIEF ) ) { super . setInternalStyle ( FLAG_BRIEF ) ; } else if ( option . equals ( STYLE_CODEDIFF ) ) { super . setInternalStyle ( FLAG_CODEDIFF ) ; } else if ( option . equals ( STYLE_DEFAULT ) ) { super . setInternalStyle ( "" ) ; } else if ( option . equals ( STYLE_NOFILE ) ) { super . setInternalStyle ( FLAG_NO_FILE ) ; } else { throw new BuildException ( "Style " + attr + " unknown." , getLocation ( ) ) ; } } public static class BriefCodediffNofile extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { STYLE_BRIEF , STYLE_CODEDIFF , STYLE_NOFILE , STYLE_DEFAULT } ; } } } 	0	['12', '4', '0', '6', '45', '66', '0', '6', '11', '2', '173', '0', '0', '0.892156863', '0.305555556', '1', '1', '13.41666667', '5', '1.4167', '0']
package org . apache . tools . ant ; public interface DynamicAttributeNS { void setDynamicAttribute ( String uri , String localName , String qName , String value ) throws BuildException ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . ArrayList ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . AntResolver ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . LocationResolver ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . URLResolver ; public class JarLibResolveTask extends Task { private String propertyName ; private Extension requiredExtension ; private final ArrayList resolvers = new ArrayList ( ) ; private boolean checkExtension = true ; private boolean failOnError = true ; public void setProperty ( final String property ) { this . propertyName = property ; } public void setCheckExtension ( final boolean checkExtension ) { this . checkExtension = checkExtension ; } public void setFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } public void addConfiguredLocation ( final LocationResolver loc ) { resolvers . add ( loc ) ; } public void addConfiguredUrl ( final URLResolver url ) { resolvers . add ( url ) ; } public void addConfiguredAnt ( final AntResolver ant ) { resolvers . add ( ant ) ; } public void addConfiguredExtension ( final ExtensionAdapter extension ) { if ( null != requiredExtension ) { final String message = "Can not specify extension to " + "resolve multiple times." ; throw new BuildException ( message ) ; } requiredExtension = extension . toExtension ( ) ; } public void execute ( ) throws BuildException { validate ( ) ; getProject ( ) . log ( "Resolving extension: " + requiredExtension , Project . MSG_VERBOSE ) ; String candidate = getProject ( ) . getProperty ( propertyName ) ; if ( null != candidate ) { final String message = "Property Already set to: " + candidate ; if ( failOnError ) { throw new BuildException ( message ) ; } getProject ( ) . log ( message , Project . MSG_ERR ) ; return ; } final int size = resolvers . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionResolver resolver = ( ExtensionResolver ) resolvers . get ( i ) ; getProject ( ) . log ( "Searching for extension using Resolver:" + resolver , Project . MSG_VERBOSE ) ; try { final File file = resolver . resolve ( requiredExtension , getProject ( ) ) ; try { checkExtension ( file ) ; return ; } catch ( final BuildException be ) { final String message = "File " + file + " returned by " + "resolver failed to satisfy extension due to: " + be . getMessage ( ) ; getProject ( ) . log ( message , Project . MSG_WARN ) ; } } catch ( final BuildException be ) { final String message = "Failed to resolve extension to file " + "using resolver " + resolver + " due to: " + be ; getProject ( ) . log ( message , Project . MSG_WARN ) ; } } missingExtension ( ) ; } private void missingExtension ( ) { final String message = "Unable to resolve extension to a file" ; if ( failOnError ) { throw new BuildException ( message ) ; } getProject ( ) . log ( message , Project . MSG_ERR ) ; } private void checkExtension ( final File file ) { if ( ! file . exists ( ) ) { final String message = "File " + file + " does not exist" ; throw new BuildException ( message ) ; } if ( ! file . isFile ( ) ) { final String message = "File " + file + " is not a file" ; throw new BuildException ( message ) ; } if ( ! checkExtension ) { final String message = "Setting property to " + file + " without verifying library satisfies extension" ; getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; setLibraryProperty ( file ) ; } else { getProject ( ) . log ( "Checking file " + file + " to see if it satisfies extension" , Project . MSG_VERBOSE ) ; final Manifest manifest = ExtensionUtil . getManifest ( file ) ; final Extension [ ] extensions = Extension . getAvailable ( manifest ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( requiredExtension ) ) { setLibraryProperty ( file ) ; return ; } } getProject ( ) . log ( "File " + file + " skipped as it " + "does not satisfy extension" , Project . MSG_VERBOSE ) ; final String message = "File " + file + " does not satisfy extension" ; throw new BuildException ( message ) ; } } private void setLibraryProperty ( final File file ) { getProject ( ) . setNewProperty ( propertyName , file . getAbsolutePath ( ) ) ; } private void validate ( ) throws BuildException { if ( null == propertyName ) { final String message = "Property attribute must be specified." ; throw new BuildException ( message ) ; } if ( null == requiredExtension ) { final String message = "Extension element must be specified." ; throw new BuildException ( message ) ; } } } 	0	['13', '3', '0', '10', '36', '20', '0', '10', '9', '0.716666667', '369', '1', '1', '0.755102041', '0.211538462', '1', '1', '27', '6', '1.4615', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Apt ; import org . apache . tools . ant . types . Commandline ; public class AptExternalCompilerAdapter extends DefaultCompilerAdapter { protected Apt getApt ( ) { return ( Apt ) getJavac ( ) ; } public boolean execute ( ) throws BuildException { attributes . log ( "Using external apt compiler" , Project . MSG_VERBOSE ) ; Apt apt = getApt ( ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( apt . getAptExecutable ( ) ) ; setupModernJavacCommandlineSwitches ( cmd ) ; AptCompilerAdapter . setAptCommandlineSwitches ( apt , cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return 0 == executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) ; } } 	0	['3', '2', '0', '6', '15', '3', '0', '6', '2', '2', '50', '0', '0', '0.92', '1', '0', '0', '15.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . types . CommandlineJava ; public abstract class DefaultJspCompilerAdapter implements JspCompilerAdapter { private static String lSep = System . getProperty ( "line.separator" ) ; protected void logAndAddFilesToCompile ( JspC jspc , Vector compileList , CommandlineJava cmd ) { jspc . log ( "Compilation " + cmd . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; Enumeration e = compileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " ) ; niceSourceList . append ( arg ) ; niceSourceList . append ( lSep ) ; } jspc . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected JspC owner ; public void setJspc ( JspC owner ) { this . owner = owner ; } public JspC getJspc ( ) { return owner ; } protected void addArg ( CommandlineJava cmd , String argument ) { if ( argument != null && argument . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( argument ) ; } } protected void addArg ( CommandlineJava cmd , String argument , String value ) { if ( value != null ) { cmd . createArgument ( ) . setValue ( argument ) ; cmd . createArgument ( ) . setValue ( value ) ; } } protected void addArg ( CommandlineJava cmd , String argument , File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( argument ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public boolean implementsOwnDependencyChecking ( ) { return false ; } public Project getProject ( ) { return getJspc ( ) . getProject ( ) ; } } 	0	['10', '1', '1', '6', '26', '41', '1', '5', '5', '0.833333333', '129', '1', '1', '0', '0.37037037', '0', '0', '11.7', '3', '1.4', '0']
package org . apache . tools . ant . types ; import java . net . URL ; public class ResourceLocation { private String publicId = null ; private String location = null ; private URL base = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public void setBase ( URL base ) { this . base = base ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } public URL getBase ( ) { return base ; } } 	0	['7', '1', '1', '6', '8', '3', '6', '0', '7', '0.666666667', '43', '1', '0', '0', '0.476190476', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DynamicElement ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . Checksum ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase extends ProjectComponent implements DynamicElement { private static final String CONDITION_ANTLIB = "antlib:org.apache.tools.ant.types.conditions:" ; private String taskName = "condition" ; private Vector conditions = new Vector ( ) ; protected ConditionBase ( ) { taskName = "component" ; } protected ConditionBase ( String taskName ) { this . taskName = taskName ; } protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return conditions . elements ( ) ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addChecksum ( Checksum c ) { conditions . addElement ( c ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } public void addIsSet ( IsSet i ) { conditions . addElement ( i ) ; } public void addHttp ( Http h ) { conditions . addElement ( h ) ; } public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } public void addFilesMatch ( FilesMatch test ) { conditions . addElement ( test ) ; } public void addContains ( Contains test ) { conditions . addElement ( test ) ; } public void addIsTrue ( IsTrue test ) { conditions . addElement ( test ) ; } public void addIsFalse ( IsFalse test ) { conditions . addElement ( test ) ; } public void addIsReference ( IsReference i ) { conditions . addElement ( i ) ; } public void addIsFileSelected ( IsFileSelected test ) { conditions . addElement ( test ) ; } public void add ( Condition c ) { conditions . addElement ( c ) ; } public Object createDynamicElement ( String name ) { Object cond = ComponentHelper . getComponentHelper ( getProject ( ) ) . createComponent ( CONDITION_ANTLIB + name ) ; if ( ! ( cond instanceof Condition ) ) { return null ; } log ( "Dynamically discovered '" + name + "' " + cond , Project . MSG_DEBUG ) ; add ( ( Condition ) cond ) ; return cond ; } } 	0	['25', '2', '7', '27', '38', '0', '8', '22', '21', '0.666666667', '198', '1', '0', '0.28125', '0.092', '0', '0', '6.8', '2', '0.96', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Integrate extends P4Base { private String change = null ; private String fromfile = null ; private String tofile = null ; private String branch = null ; private boolean restoredeletedrevisions = false ; private boolean forceintegrate = false ; private boolean leavetargetrevision = false ; private boolean enablebaselessmerges = false ; private boolean simulationmode = false ; private boolean reversebranchmappings = false ; private boolean propagatesourcefiletype = false ; private boolean nocopynewtargetfiles = false ; public String getChange ( ) { return change ; } public void setChange ( String change ) { this . change = change ; } public String getFromfile ( ) { return fromfile ; } public void setFromfile ( String fromf ) { this . fromfile = fromf ; } public String getTofile ( ) { return tofile ; } public void setTofile ( String tof ) { this . tofile = tof ; } public String getBranch ( ) { return branch ; } public void setBranch ( String br ) { this . branch = br ; } public boolean isRestoreDeletedRevisions ( ) { return restoredeletedrevisions ; } public void setRestoreDeletedRevisions ( boolean setrest ) { this . restoredeletedrevisions = setrest ; } public boolean isForceIntegrate ( ) { return forceintegrate ; } public void setForceIntegrate ( boolean setrest ) { this . forceintegrate = setrest ; } public boolean isLeaveTargetRevision ( ) { return leavetargetrevision ; } public void setLeaveTargetRevision ( boolean setrest ) { this . leavetargetrevision = setrest ; } public boolean isEnableBaselessMerges ( ) { return enablebaselessmerges ; } public void setEnableBaselessMerges ( boolean setrest ) { this . enablebaselessmerges = setrest ; } public boolean isSimulationMode ( ) { return simulationmode ; } public void setSimulationMode ( boolean setrest ) { this . simulationmode = setrest ; } public boolean isReversebranchmappings ( ) { return reversebranchmappings ; } public void setReversebranchmappings ( boolean reversebranchmappings ) { this . reversebranchmappings = reversebranchmappings ; } public boolean isPropagatesourcefiletype ( ) { return propagatesourcefiletype ; } public void setPropagatesourcefiletype ( boolean propagatesourcefiletype ) { this . propagatesourcefiletype = propagatesourcefiletype ; } public boolean isNocopynewtargetfiles ( ) { return nocopynewtargetfiles ; } public void setNocopynewtargetfiles ( boolean nocopynewtargetfiles ) { this . nocopynewtargetfiles = nocopynewtargetfiles ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( this . forceintegrate ) { P4CmdOpts = P4CmdOpts + " -f" ; } if ( this . restoredeletedrevisions ) { P4CmdOpts = P4CmdOpts + " -d" ; } if ( this . leavetargetrevision ) { P4CmdOpts = P4CmdOpts + " -h" ; } if ( this . enablebaselessmerges ) { P4CmdOpts = P4CmdOpts + " -i" ; } if ( this . simulationmode ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . reversebranchmappings ) { P4CmdOpts = P4CmdOpts + " -r" ; } if ( this . propagatesourcefiletype ) { P4CmdOpts = P4CmdOpts + " -t" ; } if ( this . nocopynewtargetfiles ) { P4CmdOpts = P4CmdOpts + "-v" ; } String command ; if ( branch == null && fromfile != null && tofile != null ) { command = P4CmdOpts + " " + fromfile + " " + tofile ; } else if ( branch != null && fromfile == null && tofile != null ) { command = P4CmdOpts + " -b " + branch + " " + tofile ; } else if ( branch != null && fromfile != null ) { command = P4CmdOpts + " -b " + branch + " -s " + fromfile + " " + tofile ; } else { throw new BuildException ( "you need to specify fromfile and tofile, " + "or branch and tofile, or branch and fromfile, or branch and fromfile and tofile " ) ; } execP4Command ( "-s integrate " + command , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['26', '4', '0', '4', '34', '203', '0', '4', '26', '0.88', '399', '1', '0', '0.671052632', '0.487179487', '1', '1', '13.88461538', '1', '0.9615', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class CCMCreateTask extends Continuus implements ExecuteStreamHandler { private String comment = null ; private String platform = null ; private String resolver = null ; private String release = null ; private String subSystem = null ; private String task = null ; public CCMCreateTask ( ) { super ( ) ; setCcmAction ( COMMAND_CREATE_TASK ) ; } public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; result = run ( commandLine , this ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } Commandline commandLine2 = new Commandline ( ) ; commandLine2 . setExecutable ( getCcmCommand ( ) ) ; commandLine2 . createArgument ( ) . setValue ( COMMAND_DEFAULT_TASK ) ; commandLine2 . createArgument ( ) . setValue ( getTask ( ) ) ; log ( commandLine . describeCommand ( ) , Project . MSG_DEBUG ) ; result = run ( commandLine2 ) ; if ( result != 0 ) { String msg = "Failed executing: " + commandLine2 . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( "\"" + getComment ( ) + "\"" ) ; } if ( getPlatform ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_PLATFORM ) ; cmd . createArgument ( ) . setValue ( getPlatform ( ) ) ; } if ( getResolver ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_RESOLVER ) ; cmd . createArgument ( ) . setValue ( getResolver ( ) ) ; } if ( getSubSystem ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_SUBSYSTEM ) ; cmd . createArgument ( ) . setValue ( "\"" + getSubSystem ( ) + "\"" ) ; } if ( getRelease ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_RELEASE ) ; cmd . createArgument ( ) . setValue ( getRelease ( ) ) ; } } public String getComment ( ) { return comment ; } public void setComment ( String v ) { this . comment = v ; } public String getPlatform ( ) { return platform ; } public void setPlatform ( String v ) { this . platform = v ; } public String getResolver ( ) { return resolver ; } public void setResolver ( String v ) { this . resolver = v ; } public String getRelease ( ) { return release ; } public void setRelease ( String v ) { this . release = v ; } public String getSubSystem ( ) { return subSystem ; } public void setSubSystem ( String v ) { this . subSystem = v ; } public String getTask ( ) { return task ; } public void setTask ( String v ) { this . task = v ; } public static final String FLAG_COMMENT = "/synopsis" ; public static final String FLAG_PLATFORM = "/plat" ; public static final String FLAG_RESOLVER = "/resolver" ; public static final String FLAG_RELEASE = "/release" ; public static final String FLAG_SUBSYSTEM = "/subsystem" ; public static final String FLAG_TASK = "/task" ; public void start ( ) throws IOException { } public void stop ( ) { } public void setProcessInputStream ( OutputStream param1 ) throws IOException { } public void setProcessErrorStream ( InputStream is ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String s = reader . readLine ( ) ; if ( s != null ) { log ( "err " + s , Project . MSG_DEBUG ) ; } } public void setProcessOutputStream ( InputStream is ) throws IOException { String buffer = "" ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; buffer = reader . readLine ( ) ; if ( buffer != null ) { log ( "buffer:" + buffer , Project . MSG_DEBUG ) ; String taskstring = buffer . substring ( buffer . indexOf ( ' ' ) ) . trim ( ) ; taskstring = taskstring . substring ( 0 , taskstring . lastIndexOf ( ' ' ) ) . trim ( ) ; setTask ( taskstring ) ; log ( "task is " + getTask ( ) , Project . MSG_DEBUG ) ; } } catch ( NullPointerException npe ) { log ( "error procession stream , null pointer exception" , Project . MSG_ERR ) ; npe . printStackTrace ( ) ; throw new BuildException ( npe . getClass ( ) . getName ( ) ) ; } catch ( Exception e ) { log ( "error procession stream " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( e . getMessage ( ) ) ; } } } 	0	['20', '4', '0', '7', '52', '154', '0', '7', '19', '0.942982456', '377', '0.5', '0', '0.693548387', '0.3', '2', '2', '17.25', '6', '1.2', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class RetryHandler { private int retriesAllowed = 0 ; private Task task ; public RetryHandler ( int retriesAllowed , Task task ) { this . retriesAllowed = retriesAllowed ; this . task = task ; } public void execute ( Retryable exe , String desc ) throws IOException { int retries = 0 ; while ( true ) { try { exe . execute ( ) ; break ; } catch ( IOException e ) { retries ++ ; if ( retries > this . retriesAllowed && this . retriesAllowed > - 1 ) { task . log ( "try #" + retries + ": IO error (" + desc + "), number of maximum retries reached (" + this . retriesAllowed + "), giving up" , Project . MSG_WARN ) ; throw e ; } else { task . log ( "try #" + retries + ": IO error (" + desc + "), retrying" , Project . MSG_WARN ) ; } } } } } 	0	['2', '1', '0', '2', '9', '0', '0', '2', '2', '0', '74', '1', '1', '0', '0.6', '0', '0', '35', '1', '0.5', '0']
package org . apache . tools . ant . types . mappers ; import java . io . StringReader ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . UnsupportedAttributeException ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; public class FilterMapper extends FilterChain implements FileNameMapper { public void setFrom ( String from ) { throw new UnsupportedAttributeException ( "filtermapper doesn't support the \"from\" attribute." , "from" ) ; } public void setTo ( String to ) { throw new UnsupportedAttributeException ( "filtermapper doesn't support the \"to\" attribute." , "to" ) ; } public String [ ] mapFileName ( String sourceFileName ) { try { Reader stringReader = new StringReader ( sourceFileName ) ; ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( 8192 ) ; helper . setPrimaryReader ( stringReader ) ; helper . setProject ( getProject ( ) ) ; Vector filterChains = new Vector ( ) ; filterChains . add ( this ) ; helper . setFilterChains ( filterChains ) ; String result = FileUtils . readFully ( helper . getAssembledReader ( ) ) ; if ( result . length ( ) == 0 ) { return null ; } else { return new String [ ] { result } ; } } catch ( BuildException ex ) { throw ex ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } 	0	['4', '4', '0', '7', '19', '6', '0', '7', '4', '2', '74', '0', '0', '0.947368421', '0.875', '0', '0', '17.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public final class CompilerAdapterFactory { private static final String MODERN_COMPILER = "com.sun.tools.javac.Main" ; private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { boolean isClassicCompilerSupported = true ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { isClassicCompilerSupported = false ; } if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { if ( isClassicCompilerSupported ) { return new Javac12 ( ) ; } else { task . log ( "This version of java does " + "not support the classic " + "compiler; upgrading to modern" , Project . MSG_WARN ) ; compilerType = "modern" ; } } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) || compilerType . equalsIgnoreCase ( "javac1.5" ) || compilerType . equalsIgnoreCase ( "javac1.6" ) ) { if ( doesModernCompilerExist ( ) ) { return new Javac13 ( ) ; } else { if ( isClassicCompilerSupported ) { task . log ( "Modern compiler not found - looking for " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } else { throw new BuildException ( "Unable to find a javac " + "compiler;\n" + MODERN_COMPILER + " is not on the " + "classpath.\n" + "Perhaps JAVA_HOME does not" + " point to the JDK.\n" + "It is currently set to \"" + JavaEnvUtils . getJavaHome ( ) + "\"" ) ; } } } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static boolean doesModernCompilerExist ( ) { try { Class . forName ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe ) { try { ClassLoader cl = CompilerAdapterFactory . class . getClassLoader ( ) ; if ( cl != null ) { cl . loadClass ( MODERN_COMPILER ) ; return true ; } } catch ( ClassNotFoundException cnfe2 ) { } } return false ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { return ( CompilerAdapter ) ClasspathUtils . newInstance ( className , CompilerAdapterFactory . class . getClassLoader ( ) , CompilerAdapter . class ) ; } } 	0	['4', '1', '0', '14', '27', '4', '1', '13', '1', '0.777777778', '221', '0.333333333', '0', '0', '0.333333333', '0', '0', '53.5', '3', '1.25', '0']
package org . apache . tools . ant . util ; import java . util . Hashtable ; import java . util . Enumeration ; public class LazyHashtable extends Hashtable { protected boolean initAllDone = false ; public LazyHashtable ( ) { super ( ) ; } protected void initAll ( ) { if ( initAllDone ) { return ; } initAllDone = true ; } public Enumeration elements ( ) { initAll ( ) ; return super . elements ( ) ; } public boolean isEmpty ( ) { initAll ( ) ; return super . isEmpty ( ) ; } public int size ( ) { initAll ( ) ; return super . size ( ) ; } public boolean contains ( Object value ) { initAll ( ) ; return super . contains ( value ) ; } public boolean containsKey ( Object value ) { initAll ( ) ; return super . containsKey ( value ) ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } public Enumeration keys ( ) { initAll ( ) ; return super . keys ( ) ; } } 	0	['9', '3', '0', '0', '16', '34', '0', '0', '8', '0', '60', '1', '0', '0.8', '0.666666667', '1', '1', '5.555555556', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . util . FileUtils ; public class DateSelector extends BaseExtendSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private long millis = - 1 ; private String dateTime = null ; private boolean includeDirs = false ; private long granularity = 0 ; private String pattern ; private TimeComparison when = TimeComparison . EQUAL ; public static final String MILLIS_KEY = "millis" ; public static final String DATETIME_KEY = "datetime" ; public static final String CHECKDIRS_KEY = "checkdirs" ; public static final String GRANULARITY_KEY = "granularity" ; public static final String WHEN_KEY = "when" ; public static final String PATTERN_KEY = "pattern" ; public DateSelector ( ) { granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dateselector date: " ) ; buf . append ( dateTime ) ; buf . append ( " compare: " ) . append ( when . getValue ( ) ) ; buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( pattern != null ) { buf . append ( " pattern: " ) . append ( pattern ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMillis ( long millis ) { this . millis = millis ; } public long getMillis ( ) { if ( dateTime != null ) { validate ( ) ; } return millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; millis = - 1 ; } public void setCheckdirs ( boolean includeDirs ) { this . includeDirs = includeDirs ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public void setWhen ( TimeComparisons tcmp ) { setWhen ( ( TimeComparison ) tcmp ) ; } public void setWhen ( TimeComparison t ) { when = t ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MILLIS_KEY . equalsIgnoreCase ( paramname ) ) { try { setMillis ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid millisecond setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( DATETIME_KEY . equalsIgnoreCase ( paramname ) ) { setDatetime ( parameters [ i ] . getValue ( ) ) ; } else if ( CHECKDIRS_KEY . equalsIgnoreCase ( paramname ) ) { setCheckdirs ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( GRANULARITY_KEY . equalsIgnoreCase ( paramname ) ) { try { setGranularity ( new Integer ( parameters [ i ] . getValue ( ) ) . intValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid granularity setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { setWhen ( new TimeComparison ( parameters [ i ] . getValue ( ) ) ) ; } else if ( PATTERN_KEY . equalsIgnoreCase ( paramname ) ) { setPattern ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( dateTime == null && millis < 0 ) { setError ( "You must provide a datetime or the number of " + "milliseconds." ) ; } else if ( millis < 0 && dateTime != null ) { DateFormat df = ( ( pattern == null ) ? DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) : new SimpleDateFormat ( pattern ) ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { setError ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + ( ( pattern == null ) ? " MM/DD/YYYY HH:MM AM_PM" : pattern ) + " format." ) ; } } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( file . isDirectory ( ) && ! includeDirs ) || when . evaluate ( file . lastModified ( ) , millis , granularity ) ; } public static class TimeComparisons extends TimeComparison { } } 	0	['14', '5', '0', '12', '41', '29', '6', '6', '13', '0.875739645', '377', '0.538461538', '2', '0.76', '0.196581197', '1', '4', '25', '9', '2.2857', '0']
package org . apache . tools . ant . taskdefs . optional . script ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . taskdefs . DefBase ; import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Set ; import java . util . HashSet ; import java . io . File ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; public class ScriptDef extends DefBase { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner = null ; private String name ; private List attributes = new ArrayList ( ) ; private List nestedElements = new ArrayList ( ) ; private Set attributeSet ; private Map nestedElementMap ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; helper . setSetBeans ( false ) ; } public void setName ( String name ) { this . name = name ; } public boolean isAttributeSupported ( String attributeName ) { return attributeSet . contains ( attributeName ) ; } public static class Attribute { private String name ; public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } } public void addAttribute ( Attribute attribute ) { attributes . add ( attribute ) ; } public static class NestedElement { private String name ; private String type ; private String className ; public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setType ( String type ) { this . type = type ; } public void setClassName ( String className ) { this . className = className ; } } public void addElement ( NestedElement nestedElement ) { nestedElements . add ( nestedElement ) ; } public void execute ( ) { if ( name == null ) { throw new BuildException ( "scriptdef requires a name attribute to " + "name the script" ) ; } if ( helper . getLanguage ( ) == null ) { throw new BuildException ( "<scriptdef> requires a language attribute " + "to specify the script language" ) ; } if ( getAntlibClassLoader ( ) != null || hasCpDelegate ( ) ) { helper . setClassLoader ( createLoader ( ) ) ; } runner = helper . getScriptRunner ( ) ; attributeSet = new HashSet ( ) ; for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; if ( attribute . name == null ) { throw new BuildException ( "scriptdef <attribute> elements " + "must specify an attribute name" ) ; } if ( attributeSet . contains ( attribute . name ) ) { throw new BuildException ( "scriptdef <" + name + "> declares " + "the " + attribute . name + " attribute more than once" ) ; } attributeSet . add ( attribute . name ) ; } nestedElementMap = new HashMap ( ) ; for ( Iterator i = nestedElements . iterator ( ) ; i . hasNext ( ) ; ) { NestedElement nestedElement = ( NestedElement ) i . next ( ) ; if ( nestedElement . name == null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify an element name" ) ; } if ( nestedElementMap . containsKey ( nestedElement . name ) ) { throw new BuildException ( "scriptdef <" + name + "> declares " + "the " + nestedElement . name + " nested element more " + "than once" ) ; } if ( nestedElement . className == null && nestedElement . type == null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify either a classname or type attribute" ) ; } if ( nestedElement . className != null && nestedElement . type != null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify only one of the classname and type " + "attributes" ) ; } nestedElementMap . put ( nestedElement . name , nestedElement ) ; } Map scriptRepository = null ; Project p = getProject ( ) ; synchronized ( p ) { scriptRepository = ( Map ) p . getReference ( MagicNames . SCRIPT_REPOSITORY ) ; if ( scriptRepository == null ) { scriptRepository = new HashMap ( ) ; p . addReference ( MagicNames . SCRIPT_REPOSITORY , scriptRepository ) ; } } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; scriptRepository . put ( name , this ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClass ( ScriptDefBase . class ) ; ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } public Object createNestedElement ( String elementName ) { NestedElement definition = ( NestedElement ) nestedElementMap . get ( elementName ) ; if ( definition == null ) { throw new BuildException ( "<" + name + "> does not support " + "the <" + elementName + "> nested element" ) ; } Object instance = null ; String classname = definition . className ; if ( classname == null ) { instance = getProject ( ) . createTask ( definition . type ) ; if ( instance == null ) { instance = getProject ( ) . createDataType ( definition . type ) ; } } else { ClassLoader loader = createLoader ( ) ; try { instance = ClasspathUtils . newInstance ( classname , loader ) ; } catch ( BuildException e ) { instance = ClasspathUtils . newInstance ( classname , ScriptDef . class . getClassLoader ( ) ) ; } getProject ( ) . setProjectReference ( instance ) ; } if ( instance == null ) { throw new BuildException ( "<" + name + "> is unable to create " + "the <" + elementName + "> nested element" ) ; } return instance ; } public void executeScript ( Map attributes , Map elements ) { executeScript ( attributes , elements , null ) ; } public void executeScript ( Map attributes , Map elements , ScriptDefBase instance ) { runner . addBean ( "attributes" , attributes ) ; runner . addBean ( "elements" , elements ) ; runner . addBean ( "project" , getProject ( ) ) ; if ( instance != null ) { runner . addBean ( "self" , instance ) ; } runner . executeScript ( "scriptdef_" + name ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } } 	0	['14', '5', '0', '14', '69', '25', '1', '14', '14', '0.837606838', '492', '0.777777778', '2', '0.805970149', '0.241071429', '1', '1', '33.5', '17', '2.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . AbstractSelectorContainer ; public class IsFileSelected extends AbstractSelectorContainer implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file ; private File baseDir ; public void setFile ( File file ) { this . file = file ; } public void setBaseDir ( File baseDir ) { this . baseDir = baseDir ; } public void validate ( ) { if ( selectorCount ( ) != 1 ) { throw new BuildException ( "Only one selector allowed" ) ; } super . validate ( ) ; } public boolean eval ( ) { if ( file == null ) { throw new BuildException ( "file attribute not set" ) ; } validate ( ) ; File myBaseDir = baseDir ; if ( myBaseDir == null ) { myBaseDir = getProject ( ) . getBaseDir ( ) ; } FileSelector f = getSelectors ( getProject ( ) ) [ 0 ] ; return f . isSelected ( myBaseDir , FILE_UTILS . removeLeadingPath ( myBaseDir , file ) , file ) ; } } 	0	['6', '4', '0', '7', '16', '9', '1', '6', '5', '0.8', '72', '1', '1', '0.933333333', '0.7', '0', '0', '10.5', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . List ; import java . util . Vector ; import java . util . ArrayList ; import java . util . StringTokenizer ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; public class PathConvert extends Task { private static boolean onWindows = Os . isFamily ( "dos" ) ; private Union path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean setonempty = true ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; private Mapper mapper = null ; public PathConvert ( ) { } public class MapEntry { private String from = null ; private String to = null ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set " + "in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) . replace ( '\\' , '/' ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) . replace ( '\\' , '/' ) : from ; return cmpElem . startsWith ( cmpFrom ) ? to + elem . substring ( from . length ( ) ) : elem ; } } public static class TargetOs extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "windows" , "unix" , "netware" , "os/2" , "tandem" } ; } } public Path createPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path result = new Path ( getProject ( ) ) ; add ( result ) ; return result ; } public void add ( ResourceCollection rc ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getPath ( ) . add ( rc ) ; } private synchronized Union getPath ( ) { if ( path == null ) { path = new Union ( ) ; path . setProject ( getProject ( ) ) ; } return path ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { TargetOs to = new TargetOs ( ) ; to . setValue ( target ) ; setTargetos ( to ) ; } public void setTargetos ( TargetOs target ) { targetOS = target . getValue ( ) ; targetWindows = ! targetOS . equals ( "unix" ) && ! targetOS . equals ( "tandem" ) ; } public void setSetonempty ( boolean setonempty ) { this . setonempty = setonempty ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) { throw noChildrenAllowed ( ) ; } refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { Union savedPath = path ; String savedPathSep = pathSep ; String savedDirSep = dirSep ; try { if ( isReference ( ) ) { Object o = refid . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof ResourceCollection ) ) { throw new BuildException ( "refid '" + refid . getRefId ( ) + "' does not refer to a resource collection." ) ; } getPath ( ) . add ( ( ResourceCollection ) o ) ; } validateSetup ( ) ; String fromDirSep = onWindows ? "\\" : "/" ; StringBuffer rslt = new StringBuffer ( ) ; String [ ] elems = path . list ( ) ; if ( mapper != null ) { FileNameMapper impl = mapper . getImplementation ( ) ; List ret = new ArrayList ( ) ; for ( int i = 0 ; i < elems . length ; ++ i ) { String [ ] mapped = impl . mapFileName ( elems [ i ] ) ; for ( int m = 0 ; mapped != null && m < mapped . length ; ++ m ) { ret . add ( mapped [ m ] ) ; } } elems = ( String [ ] ) ret . toArray ( new String [ ret . size ( ) ] ) ; } for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = mapElement ( elems [ i ] ) ; if ( i != 0 ) { rslt . append ( pathSep ) ; } StringTokenizer stDirectory = new StringTokenizer ( elem , fromDirSep , true ) ; while ( stDirectory . hasMoreTokens ( ) ) { String token = stDirectory . nextToken ( ) ; rslt . append ( fromDirSep . equals ( token ) ? dirSep : token ) ; } } if ( setonempty || rslt . length ( ) > 0 ) { String value = rslt . toString ( ) ; if ( property == null ) { log ( value ) ; } else { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } finally { path = savedPath ; dirSep = savedDirSep ; pathSep = savedPathSep ; } } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } public void addMapper ( Mapper mapper ) { if ( this . mapper != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } this . mapper = mapper ; } public void add ( FileNameMapper fileNameMapper ) { Mapper m = new Mapper ( getProject ( ) ) ; m . add ( fileNameMapper ) ; addMapper ( m ) ; } private void validateSetup ( ) throws BuildException { if ( path == null ) { throw new BuildException ( "You must specify a path to convert" ) ; } String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested " + "elements when using the refid attribute." ) ; } } 	0	['21', '3', '0', '12', '61', '144', '1', '12', '15', '0.836363636', '507', '1', '3', '0.660714286', '0.1875', '2', '2', '22.61904762', '4', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public class Jasper41Mangler implements JspMangler { public String mapJspToJavaName ( File jspFile ) { String jspUri = jspFile . getAbsolutePath ( ) ; int start = jspUri . lastIndexOf ( File . separatorChar ) + 1 ; int end = jspUri . length ( ) ; StringBuffer modifiedClassName ; modifiedClassName = new StringBuffer ( jspUri . length ( ) - start ) ; if ( ! Character . isJavaIdentifierStart ( jspUri . charAt ( start ) ) || jspUri . charAt ( start ) == '_' ) { modifiedClassName . append ( '_' ) ; } for ( int i = start ; i < end ; i ++ ) { char ch = jspUri . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( ch ) ) { modifiedClassName . append ( ch ) ; } else if ( ch == '.' ) { modifiedClassName . append ( '_' ) ; } else { modifiedClassName . append ( mangleChar ( ch ) ) ; } } return modifiedClassName . toString ( ) ; } private static String mangleChar ( char ch ) { String s = Integer . toHexString ( ch ) ; int nzeros = 5 - s . length ( ) ; char [ ] result = new char [ 6 ] ; result [ 0 ] = '_' ; for ( int i = 1 ; i <= nzeros ; i ++ ) { result [ i ] = '0' ; } for ( int i = nzeros + 1 , j = 0 ; i < 6 ; i ++ , j ++ ) { result [ i ] = s . charAt ( j ) ; } return new String ( result ) ; } public String mapPath ( String path ) { return null ; } } 	0	['4', '1', '0', '2', '17', '6', '1', '1', '3', '2', '127', '0', '0', '0', '0.375', '0', '0', '30.75', '6', '2.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public class Not implements ResourceSelector { private ResourceSelector sel ; public Not ( ) { } public Not ( ResourceSelector s ) { add ( s ) ; } public void add ( ResourceSelector s ) { if ( sel != null ) { throw new IllegalStateException ( "The Not ResourceSelector accepts a single nested ResourceSelector" ) ; } sel = s ; } public boolean isSelected ( Resource r ) { return ! ( sel . isSelected ( r ) ) ; } } 	0	['4', '1', '0', '5', '7', '4', '3', '2', '4', '0.333333333', '35', '1', '1', '0', '0.583333333', '0', '0', '7.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class MethodRefCPInfo extends ConstantPoolEntry { private String methodClassName ; private String methodName ; private String methodType ; private int classIndex ; private int nameAndTypeIndex ; public MethodRefCPInfo ( ) { super ( CONSTANT_METHODREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Method : Class = " + methodClassName + ", name = " + methodName + ", type = " + methodType ; } else { value = "Method : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo methodClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; methodClass . resolve ( constantPool ) ; methodClassName = methodClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; methodName = nt . getName ( ) ; methodType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String getMethodClassName ( ) { return methodClassName ; } public String getMethodName ( ) { return methodName ; } public String getMethodType ( ) { return methodType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . Writer ; import java . io . BufferedWriter ; import java . io . OutputStreamWriter ; import java . io . FileOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . LogLevel ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; private String encoding = "" ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { Writer out = null ; try { String filename = file . getAbsolutePath ( ) ; if ( encoding == null || encoding . length ( ) == 0 ) { out = new FileWriter ( filename , append ) ; } else { out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( filename , append ) , encoding ) ) ; } out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { FileUtils . close ( out ) ; } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public void setLevel ( EchoLevel echoLevel ) { logLevel = echoLevel . getLevel ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public static class EchoLevel extends LogLevel { } } 	0	['8', '3', '0', '6', '27', '0', '0', '6', '8', '0.685714286', '141', '1', '0', '0.840909091', '0.35', '1', '1', '16', '1', '0.875', '0']
package org . apache . tools . ant . util ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class DOMUtils { public static Document newDocument ( ) { return JAXPUtils . getDocumentBuilder ( ) . newDocument ( ) ; } public static Element createChildElement ( Element parent , String name ) { Document doc = parent . getOwnerDocument ( ) ; Element e = doc . createElement ( name ) ; parent . appendChild ( e ) ; return e ; } public static void appendText ( Element parent , String content ) { Document doc = parent . getOwnerDocument ( ) ; Text t = doc . createTextNode ( content ) ; parent . appendChild ( t ) ; } public static void appendCDATA ( Element parent , String content ) { Document doc = parent . getOwnerDocument ( ) ; CDATASection c = doc . createCDATASection ( content ) ; parent . appendChild ( c ) ; } public static void appendTextElement ( Element parent , String name , String content ) { Element e = createChildElement ( parent , name ) ; appendText ( e , content ) ; } public static void appendCDATAElement ( Element parent , String name , String content ) { Element e = createChildElement ( parent , name ) ; appendCDATA ( e , content ) ; } } 	0	['7', '1', '0', '3', '15', '21', '2', '1', '7', '2', '66', '0', '0', '0', '0.523809524', '0', '0', '8.428571429', '1', '0.8571', '0']
package org . apache . tools . ant . helper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Executor ; import org . apache . tools . ant . BuildException ; public class DefaultExecutor implements Executor { private static final SingleCheckExecutor SUB_EXECUTOR = new SingleCheckExecutor ( ) ; public void executeTargets ( Project project , String [ ] targetNames ) throws BuildException { BuildException thrownException = null ; for ( int i = 0 ; i < targetNames . length ; i ++ ) { try { project . executeTarget ( targetNames [ i ] ) ; } catch ( BuildException ex ) { if ( project . isKeepGoingMode ( ) ) { thrownException = ex ; } else { throw ex ; } } } if ( thrownException != null ) { throw thrownException ; } } public Executor getSubProjectExecutor ( ) { return SUB_EXECUTOR ; } } 	0	['4', '1', '0', '4', '8', '4', '0', '4', '3', '0.666666667', '45', '1', '1', '0', '0.555555556', '0', '0', '10', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class Compatability { private final String name ; Compatability ( final String name ) { this . name = name ; } public String toString ( ) { return name ; } } 	0	['2', '1', '0', '0', '3', '0', '0', '0', '1', '0', '12', '1', '0', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSGET extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_GET ) ; if ( getVsspath ( ) == null ) { throw new BuildException ( "vsspath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getQuiet ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionDateLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getFileTimeStamp ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritableFiles ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public final void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setQuiet ( boolean quiet ) { super . setInternalQuiet ( quiet ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setDate ( String date ) { super . setInternalDate ( date ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setFileTimeStamp ( CurrentModUpdated timestamp ) { super . setInternalFileTimeStamp ( timestamp ) ; } public void setWritableFiles ( WritableFiles files ) { super . setInternalWritableFiles ( files ) ; } } 	0	['12', '4', '0', '8', '41', '66', '0', '8', '11', '2', '130', '0', '0', '0.892156863', '0.305555556', '1', '1', '9.833333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Diagnostics ; public class DiagnosticsTask extends Task { private static final String [ ] ARGS = new String [ 0 ] ; public void execute ( ) throws BuildException { Diagnostics . main ( ARGS ) ; } } 	0	['3', '3', '0', '3', '5', '1', '0', '3', '2', '0.5', '14', '1', '0', '0.973684211', '1', '0', '0', '3.333333333', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class DeweyDecimal extends org . apache . tools . ant . util . DeweyDecimal { public DeweyDecimal ( final int [ ] components ) { super ( components ) ; } public DeweyDecimal ( final String string ) throws NumberFormatException { super ( string ) ; } } 	0	['2', '2', '0', '5', '4', '1', '4', '1', '2', '2', '10', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant ; public class UnsupportedElementException extends BuildException { private String element ; public UnsupportedElementException ( String msg , String element ) { super ( msg ) ; this . element = element ; } public String getElement ( ) { return element ; } } 	0	['2', '5', '0', '3', '3', '0', '2', '1', '2', '0', '13', '1', '0', '0.954545455', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMReconfigure extends Continuus { private String ccmProject = null ; private boolean recurse = false ; private boolean verbose = false ; public CCMReconfigure ( ) { super ( ) ; setCcmAction ( COMMAND_RECONFIGURE ) ; } public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; result = run ( commandLine ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( isRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( isVerbose ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_VERBOSE ) ; } if ( getCcmProject ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_PROJECT ) ; cmd . createArgument ( ) . setValue ( getCcmProject ( ) ) ; } } public String getCcmProject ( ) { return ccmProject ; } public void setCcmProject ( String v ) { this . ccmProject = v ; } public boolean isRecurse ( ) { return recurse ; } public void setRecurse ( boolean v ) { this . recurse = v ; } public boolean isVerbose ( ) { return verbose ; } public void setVerbose ( boolean v ) { this . verbose = v ; } public static final String FLAG_RECURSE = "/recurse" ; public static final String FLAG_VERBOSE = "/verbose" ; public static final String FLAG_PROJECT = "/project" ; } 	0	['9', '4', '0', '6', '25', '18', '0', '6', '8', '0.875', '120', '0.5', '0', '0.843137255', '0.361111111', '1', '1', '11.66666667', '4', '1.2222', '0']
package org . apache . tools . ant ; public interface Executor { void executeTargets ( Project project , String [ ] targetNames ) throws BuildException ; Executor getSubProjectExecutor ( ) ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Stack ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . util . ConcatResourceInputStream ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . Tokenizer ; public class Tokens extends BaseResourceCollectionWrapper { private Tokenizer tokenizer ; private String encoding ; protected synchronized Collection getCollection ( ) { ResourceCollection rc = getResourceCollection ( ) ; if ( rc . size ( ) == 0 ) { return Collections . EMPTY_SET ; } if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } ConcatResourceInputStream cat = new ConcatResourceInputStream ( rc ) ; cat . setManagingComponent ( this ) ; InputStreamReader rdr = null ; if ( encoding == null ) { rdr = new InputStreamReader ( cat ) ; } else { try { rdr = new InputStreamReader ( cat , encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( e ) ; } } ArrayList result = new ArrayList ( ) ; try { for ( String s = tokenizer . getToken ( rdr ) ; s != null ; s = tokenizer . getToken ( rdr ) ) { result . add ( new StringResource ( s ) ) ; } } catch ( IOException e ) { throw new BuildException ( "Error reading tokens" , e ) ; } return result ; } public synchronized void setEncoding ( String encoding ) { this . encoding = encoding ; } public synchronized void add ( Tokenizer tokenizer ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . tokenizer != null ) { throw new BuildException ( "Only one nested tokenizer allowed." ) ; } this . tokenizer = tokenizer ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( tokenizer instanceof DataType ) { stk . push ( tokenizer ) ; invokeCircularReferenceCheck ( ( DataType ) tokenizer , stk , p ) ; } setChecked ( true ) ; } } } 	0	['5', '4', '0', '10', '27', '2', '0', '10', '3', '0.625', '146', '1', '1', '0.913043478', '0.36', '2', '5', '27.8', '5', '2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '6', '13', '1', '1', '5', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class Javac12 extends DefaultCompilerAdapter { protected static final String CLASSIC_COMPILER_CLASSNAME = "sun.tools.javac.Main" ; public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( CLASSIC_COMPILER_CLASSNAME ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler , as it is " + "not available. \n" + " A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory.\n" + "It is currently set to \"" + JavaEnvUtils . getJavaHome ( ) + "\"" , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { FileUtils . close ( logstr ) ; } } } 	0	['2', '2', '0', '10', '22', '1', '1', '9', '2', '1.25', '163', '0.25', '0', '0.958333333', '1', '0', '0', '78.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Revert extends P4Base { private String revertChange = null ; private boolean onlyUnchanged = false ; public void setChange ( String revertChange ) throws BuildException { if ( revertChange == null || revertChange . equals ( "" ) ) { throw new BuildException ( "P4Revert: change cannot be null or empty" ) ; } this . revertChange = revertChange ; } public void setRevertOnlyUnchanged ( boolean onlyUnchanged ) { this . onlyUnchanged = onlyUnchanged ; } public void execute ( ) throws BuildException { String p4cmd = "-s revert" ; if ( onlyUnchanged ) { p4cmd += " -a" ; } if ( revertChange != null ) { p4cmd += " -c " + revertChange ; } execP4Command ( p4cmd + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['4', '4', '0', '4', '13', '0', '0', '4', '4', '0.333333333', '81', '1', '0', '0.944444444', '0.5', '1', '1', '18.75', '1', '0.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . types . Parameter ; public final class HeadFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private long linesRead = 0 ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; public HeadFilter ( ) { super ( ) ; } public HeadFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } line = headFilter ( line ) ; linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public void setLines ( final long lines ) { this . lines = lines ; } private long getLines ( ) { return lines ; } public void setSkip ( final long skip ) { this . skip = skip ; } private long getSkip ( ) { return skip ; } public Reader chain ( final Reader rdr ) { HeadFilter newFilter = new HeadFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { lines = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String headFilter ( String line ) { linesRead ++ ; if ( skip > 0 ) { if ( ( linesRead - 1 ) < skip ) { return null ; } } if ( lines > 0 ) { if ( linesRead > ( lines + skip ) ) { return null ; } } return line ; } } 	0	['10', '5', '0', '5', '25', '0', '1', '4', '6', '0.703703704', '251', '1', '1', '0.777777778', '0.375', '2', '4', '23.2', '5', '1.6', '0']
package org . apache . tools . ant . dispatch ; import org . apache . tools . ant . Task ; public abstract class DispatchTask extends Task implements Dispatchable { private String action ; public String getActionParameterName ( ) { return "action" ; } public void setAction ( String action ) { this . action = action ; } public String getAction ( ) { return action ; } } 	0	['4', '3', '1', '3', '5', '4', '1', '2', '4', '0.666666667', '17', '1', '0', '0.925', '0.625', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . ByteArrayInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . PropertyOutputStream ; public class PropertyResource extends Resource { private static final int PROPERTY_MAGIC = Resource . getMagicNumber ( "PropertyResource" . getBytes ( ) ) ; private static final InputStream UNSET = new InputStream ( ) { public int read ( ) { return - 1 ; } } ; public PropertyResource ( ) { } public PropertyResource ( Project p , String n ) { super ( n ) ; setProject ( p ) ; } public String getValue ( ) { Project p = getProject ( ) ; return p == null ? null : p . getProperty ( getName ( ) ) ; } public boolean isExists ( ) { return getValue ( ) != null ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } return isExists ( ) ? ( long ) getValue ( ) . length ( ) : 0L ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return super . hashCode ( ) * PROPERTY_MAGIC ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } return String . valueOf ( getValue ( ) ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } return isExists ( ) ? new ByteArrayInputStream ( getValue ( ) . getBytes ( ) ) : UNSET ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } if ( isExists ( ) ) { throw new ImmutableResourceException ( ) ; } return new PropertyOutputStream ( getProject ( ) , getName ( ) ) ; } } 	0	['10', '4', '0', '6', '32', '41', '1', '5', '9', '0.888888889', '134', '1', '0', '0.883333333', '0.407407407', '1', '6', '12.2', '3', '1.3', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . optional . jsp . compilers . JspCompilerAdapter ; import org . apache . tools . ant . taskdefs . optional . jsp . compilers . JspCompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class JspC extends MatchingTask { private Path classpath ; private Path compilerClasspath ; private Path src ; private File destDir ; private String packageName ; private String compilerName = "jasper" ; private String iepluginid ; private boolean mapped ; private int verbose = 0 ; protected Vector compileList = new Vector ( ) ; Vector javaFiles = new Vector ( ) ; protected boolean failOnError = true ; private File uriroot ; private File webinc ; private File webxml ; protected WebAppParameter webApp ; private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; public void setSrcDir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcDir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setPackage ( String pkg ) { this . packageName = pkg ; } public String getPackage ( ) { return packageName ; } public void setVerbose ( int i ) { verbose = i ; } public int getVerbose ( ) { return verbose ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public boolean getFailonerror ( ) { return failOnError ; } public String getIeplugin ( ) { return iepluginid ; } public void setIeplugin ( String iepluginid ) { this . iepluginid = iepluginid ; } public boolean isMapped ( ) { return mapped ; } public void setMapped ( boolean mapped ) { this . mapped = mapped ; } public void setUribase ( File uribase ) { log ( "Uribase is currently an unused parameter" , Project . MSG_WARN ) ; } public File getUribase ( ) { return uriroot ; } public void setUriroot ( File uriroot ) { this . uriroot = uriroot ; } public File getUriroot ( ) { return uriroot ; } public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setCompilerclasspath ( Path cp ) { if ( compilerClasspath == null ) { compilerClasspath = cp ; } else { compilerClasspath . append ( cp ) ; } } public Path getCompilerclasspath ( ) { return compilerClasspath ; } public Path createCompilerclasspath ( ) { if ( compilerClasspath == null ) { compilerClasspath = new Path ( getProject ( ) ) ; } return compilerClasspath . createPath ( ) ; } public void setWebxml ( File webxml ) { this . webxml = webxml ; } public File getWebxml ( ) { return this . webxml ; } public void setWebinc ( File webinc ) { this . webinc = webinc ; } public File getWebinc ( ) { return this . webinc ; } public void addWebApp ( WebAppParameter webappParam ) throws BuildException { if ( webApp == null ) { webApp = webappParam ; } else { throw new BuildException ( "Only one webapp can be specified" ) ; } } public WebAppParameter getWebApp ( ) { return webApp ; } public void setCompiler ( String compiler ) { this . compilerName = compiler ; } public Vector getCompileList ( ) { return compileList ; } public void execute ( ) throws BuildException { if ( destDir == null ) { throw new BuildException ( "destdir attribute must be set!" , getLocation ( ) ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , getLocation ( ) ) ; } File dest = getActualDestDir ( ) ; JspCompilerAdapter compiler = JspCompilerAdapterFactory . getCompiler ( compilerName , this , getProject ( ) . createClassLoader ( compilerClasspath ) ) ; if ( webApp != null ) { doCompilation ( compiler ) ; return ; } if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( compiler . implementsOwnDependencyChecking ( ) ) { doCompilation ( compiler ) ; return ; } JspMangler mangler = compiler . createMangler ( ) ; resetFileLists ( ) ; int filecount = 0 ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; filecount = files . length ; scanDir ( srcDir , dest , mangler , files ) ; } log ( "compiling " + compileList . size ( ) + " files" , Project . MSG_VERBOSE ) ; if ( compileList . size ( ) > 0 ) { log ( "Compiling " + compileList . size ( ) + " source file" + ( compileList . size ( ) == 1 ? "" : "s" ) + " to " + dest ) ; doCompilation ( compiler ) ; } else { if ( filecount == 0 ) { log ( "there were no files to compile" , Project . MSG_INFO ) ; } else { log ( "all files are up to date" , Project . MSG_VERBOSE ) ; } } } private File getActualDestDir ( ) { File dest = null ; if ( packageName == null ) { dest = destDir ; } else { String path = destDir . getPath ( ) + File . separatorChar + packageName . replace ( '.' , File . separatorChar ) ; dest = new File ( path ) ; } return dest ; } private void doCompilation ( JspCompilerAdapter compiler ) throws BuildException { compiler . setJspc ( this ) ; if ( ! compiler . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } protected void resetFileLists ( ) { compileList . removeAllElements ( ) ; } protected void scanDir ( File srcDir , File dest , JspMangler mangler , String [ ] files ) { long now = ( new Date ( ) ) . getTime ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( srcDir , filename ) ; File javaFile = mapToJavaFile ( mangler , srcFile , srcDir , dest ) ; if ( javaFile == null ) { continue ; } if ( srcFile . lastModified ( ) > now ) { log ( "Warning: file modified in the future: " + filename , Project . MSG_WARN ) ; } boolean shouldCompile = false ; shouldCompile = isCompileNeeded ( srcFile , javaFile ) ; if ( shouldCompile ) { compileList . addElement ( srcFile . getAbsolutePath ( ) ) ; javaFiles . addElement ( javaFile ) ; } } } private boolean isCompileNeeded ( File srcFile , File javaFile ) { boolean shouldCompile = false ; if ( ! javaFile . exists ( ) ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because java file " + javaFile . getPath ( ) + " does not exist" , Project . MSG_VERBOSE ) ; } else { if ( srcFile . lastModified ( ) > javaFile . lastModified ( ) ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because it is out of date with respect to " + javaFile . getPath ( ) , Project . MSG_VERBOSE ) ; } else { if ( javaFile . length ( ) == 0 ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because java file " + javaFile . getPath ( ) + " is empty" , Project . MSG_VERBOSE ) ; } } } return shouldCompile ; } protected File mapToJavaFile ( JspMangler mangler , File srcFile , File srcDir , File dest ) { if ( ! srcFile . getName ( ) . endsWith ( ".jsp" ) ) { return null ; } String javaFileName = mangler . mapJspToJavaName ( srcFile ) ; return new File ( dest , javaFileName ) ; } public void deleteEmptyJavaFiles ( ) { if ( javaFiles != null ) { Enumeration e = javaFiles . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; if ( file . exists ( ) && file . length ( ) == 0 ) { log ( "deleting empty output file " + file ) ; file . delete ( ) ; } } } } public static class WebAppParameter { private File directory ; public File getDirectory ( ) { return directory ; } public void setBaseDir ( File directory ) { this . directory = directory ; } } } 	0	['42', '4', '0', '15', '92', '753', '3', '13', '36', '0.948350072', '707', '0.941176471', '4', '0.655462185', '0.140692641', '3', '3', '15.42857143', '5', '1.4048', '0']
package org . apache . tools . ant . util . depend ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; public abstract class AbstractAnalyzer implements DependencyAnalyzer { public static final int MAX_LOOPS = 1000 ; private Path sourcePath = new Path ( null ) ; private Path classPath = new Path ( null ) ; private Vector rootClasses = new Vector ( ) ; private boolean determined = false ; private Vector fileDependencies ; private Vector classDependencies ; private boolean closure = true ; protected AbstractAnalyzer ( ) { reset ( ) ; } public void setClosure ( boolean closure ) { this . closure = closure ; } public Enumeration getFileDependencies ( ) { if ( ! supportsFileDependencies ( ) ) { throw new RuntimeException ( "File dependencies are not supported " + "by this analyzer" ) ; } if ( ! determined ) { determineDependencies ( fileDependencies , classDependencies ) ; } return fileDependencies . elements ( ) ; } public Enumeration getClassDependencies ( ) { if ( ! determined ) { determineDependencies ( fileDependencies , classDependencies ) ; } return classDependencies . elements ( ) ; } public File getClassContainer ( String classname ) throws IOException { String classLocation = classname . replace ( '.' , '/' ) + ".class" ; return getResourceContainer ( classLocation , classPath . list ( ) ) ; } public File getSourceContainer ( String classname ) throws IOException { String sourceLocation = classname . replace ( '.' , '/' ) + ".java" ; return getResourceContainer ( sourceLocation , sourcePath . list ( ) ) ; } public void addSourcePath ( Path sourcePath ) { if ( sourcePath == null ) { return ; } this . sourcePath . append ( sourcePath ) ; this . sourcePath . setProject ( sourcePath . getProject ( ) ) ; } public void addClassPath ( Path classPath ) { if ( classPath == null ) { return ; } this . classPath . append ( classPath ) ; this . classPath . setProject ( classPath . getProject ( ) ) ; } public void addRootClass ( String className ) { if ( className == null ) { return ; } if ( ! rootClasses . contains ( className ) ) { rootClasses . addElement ( className ) ; } } public void config ( String name , Object info ) { } public void reset ( ) { rootClasses . removeAllElements ( ) ; determined = false ; fileDependencies = new Vector ( ) ; classDependencies = new Vector ( ) ; } protected Enumeration getRootClasses ( ) { return rootClasses . elements ( ) ; } protected boolean isClosureRequired ( ) { return closure ; } protected abstract void determineDependencies ( Vector files , Vector classes ) ; protected abstract boolean supportsFileDependencies ( ) ; private File getResourceContainer ( String resourceLocation , String [ ] paths ) throws IOException { for ( int i = 0 ; i < paths . length ; ++ i ) { File element = new File ( paths [ i ] ) ; if ( ! element . exists ( ) ) { continue ; } if ( element . isDirectory ( ) ) { File resource = new File ( element , resourceLocation ) ; if ( resource . exists ( ) ) { return resource ; } } else { ZipFile zipFile = null ; try { zipFile = new ZipFile ( element ) ; if ( zipFile . getEntry ( resourceLocation ) != null ) { return element ; } } finally { if ( zipFile != null ) { zipFile . close ( ) ; } } } } return null ; } } 	0	['16', '1', '3', '6', '40', '80', '3', '3', '10', '0.858333333', '254', '0.875', '2', '0', '0.241071429', '0', '0', '14.375', '3', '1.375', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; public class ReaderInputStream extends InputStream { private Reader in ; private String encoding = System . getProperty ( "file.encoding" ) ; private byte [ ] slack ; private int begin ; public ReaderInputStream ( Reader reader ) { in = reader ; } public ReaderInputStream ( Reader reader , String encoding ) { this ( reader ) ; if ( encoding == null ) { throw new IllegalArgumentException ( "encoding must not be null" ) ; } else { this . encoding = encoding ; } } public synchronized int read ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } byte result ; if ( slack != null && begin < slack . length ) { result = slack [ begin ] ; if ( ++ begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) <= 0 ) { return - 1 ; } else { result = buf [ 0 ] ; } } return result & 0xFF ; } public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( len == 0 ) { return 0 ; } while ( slack == null ) { char [ ] buf = new char [ len ] ; int n = in . read ( buf ) ; if ( n == - 1 ) { return - 1 ; } if ( n > 0 ) { slack = new String ( buf , 0 , n ) . getBytes ( encoding ) ; begin = 0 ; } } if ( len > slack . length - begin ) { len = slack . length - begin ; } System . arraycopy ( slack , begin , b , off , len ) ; if ( ( begin += len ) >= slack . length ) { slack = null ; } return len ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized int available ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( slack != null ) { return slack . length - begin ; } if ( in . ready ( ) ) { return 1 ; } else { return 0 ; } } public boolean markSupported ( ) { return false ; } public synchronized void reset ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } slack = null ; in . reset ( ) ; } public synchronized void close ( ) throws IOException { if ( in != null ) { in . close ( ) ; slack = null ; in = null ; } } } 	0	['9', '2', '1', '2', '23', '0', '2', '0', '9', '0.5', '246', '1', '0', '0.5625', '0.333333333', '1', '2', '25.88888889', '1', '0.7778', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . FileUtils ; public class ContainsSelector extends BaseExtendSelector implements ResourceSelector { private String contains = null ; private boolean casesensitive = true ; private boolean ignorewhitespace = false ; public static final String EXPRESSION_KEY = "expression" ; public static final String CONTAINS_KEY = "text" ; public static final String CASE_KEY = "casesensitive" ; public static final String WHITESPACE_KEY = "ignorewhitespace" ; public ContainsSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsselector text: " ) ; buf . append ( '"' ) . append ( contains ) . append ( '"' ) ; buf . append ( " casesensitive: " ) ; buf . append ( casesensitive ? "true" : "false" ) ; buf . append ( " ignorewhitespace: " ) ; buf . append ( ignorewhitespace ? "true" : "false" ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setText ( String contains ) { this . contains = contains ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setIgnorewhitespace ( boolean ignorewhitespace ) { this . ignorewhitespace = ignorewhitespace ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( CONTAINS_KEY . equalsIgnoreCase ( paramname ) ) { setText ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( WHITESPACE_KEY . equalsIgnoreCase ( paramname ) ) { setIgnorewhitespace ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( contains == null ) { setError ( "The text attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( new FileResource ( file ) ) ; } public boolean isSelected ( Resource r ) { validate ( ) ; if ( r . isDirectory ( ) ) { return true ; } String userstr = contains ; if ( ! casesensitive ) { userstr = contains . toLowerCase ( ) ; } if ( ignorewhitespace ) { userstr = SelectorUtils . removeWhitespace ( userstr ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( r . getInputStream ( ) ) ) ; } catch ( Exception e ) { throw new BuildException ( "Could not get InputStream from " + r . toLongString ( ) , e ) ; } try { String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! casesensitive ) { teststr = teststr . toLowerCase ( ) ; } if ( ignorewhitespace ) { teststr = SelectorUtils . removeWhitespace ( teststr ) ; } if ( teststr . indexOf ( userstr ) > - 1 ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read " + r . toLongString ( ) ) ; } finally { FileUtils . close ( in ) ; } } } 	0	['9', '5', '0', '15', '34', '4', '6', '9', '9', '0.785714286', '266', '0.428571429', '0', '0.826086957', '0.296296296', '1', '4', '27.77777778', '11', '2.8889', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . JavaEnvUtils ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = new ExecTask ( this ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "keytool" ) ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '6', '34', '65', '0', '6', '14', '0.91025641', '378', '1', '1', '0.74', '0.595238095', '1', '1', '25.14285714', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { } 	0	['1', '6', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . helper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Executor ; import org . apache . tools . ant . BuildException ; public class SingleCheckExecutor implements Executor { public void executeTargets ( Project project , String [ ] targetNames ) throws BuildException { project . executeSortedTargets ( project . topoSort ( targetNames , project . getTargets ( ) , false ) ) ; } public Executor getSubProjectExecutor ( ) { return this ; } } 	0	['3', '1', '0', '4', '7', '3', '1', '3', '3', '2', '17', '0', '0', '0', '0.555555556', '0', '0', '4.666666667', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . math . BigInteger ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class Resource extends DataType implements Cloneable , Comparable , ResourceCollection { public static final long UNKNOWN_SIZE = - 1 ; public static final long UNKNOWN_DATETIME = 0L ; protected static final int MAGIC = getMagicNumber ( "Resource" . getBytes ( ) ) ; private static final int NULL_NAME = getMagicNumber ( "null name" . getBytes ( ) ) ; protected static int getMagicNumber ( byte [ ] seed ) { return new BigInteger ( seed ) . intValue ( ) ; } private String name = null ; private Boolean exists = null ; private Long lastmodified = null ; private Boolean directory = null ; private Long size = null ; public Resource ( ) { } public Resource ( String name ) { this ( name , false , 0 , false ) ; } public Resource ( String name , boolean exists , long lastmodified ) { this ( name , exists , lastmodified , false ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory ) { this ( name , exists , lastmodified , directory , UNKNOWN_SIZE ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory , long size ) { this . name = name ; setName ( name ) ; setExists ( exists ) ; setLastModified ( lastmodified ) ; setDirectory ( directory ) ; setSize ( size ) ; } public String getName ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getName ( ) : name ; } public void setName ( String name ) { checkAttributesAllowed ( ) ; this . name = name ; } public boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } return exists == null || exists . booleanValue ( ) ; } public void setExists ( boolean exists ) { checkAttributesAllowed ( ) ; this . exists = exists ? Boolean . TRUE : Boolean . FALSE ; } public long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } if ( ! isExists ( ) || lastmodified == null ) { return UNKNOWN_DATETIME ; } long result = lastmodified . longValue ( ) ; return result < UNKNOWN_DATETIME ? UNKNOWN_DATETIME : result ; } public void setLastModified ( long lastmodified ) { checkAttributesAllowed ( ) ; this . lastmodified = new Long ( lastmodified ) ; } public boolean isDirectory ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) ; } return directory != null && directory . booleanValue ( ) ; } public void setDirectory ( boolean directory ) { checkAttributesAllowed ( ) ; this . directory = directory ? Boolean . TRUE : Boolean . FALSE ; } public void setSize ( long size ) { checkAttributesAllowed ( ) ; this . size = new Long ( size > UNKNOWN_SIZE ? size : UNKNOWN_SIZE ) ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } return isExists ( ) ? ( size != null ? size . longValue ( ) : UNKNOWN_SIZE ) : 0L ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new UnsupportedOperationException ( "CloneNotSupportedException for a Resource caught. " + "Derived classes must support cloning." ) ; } } public int compareTo ( Object other ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( other ) ; } if ( ! ( other instanceof Resource ) ) { throw new IllegalArgumentException ( "Can only be compared with Resources" ) ; } return toString ( ) . compareTo ( other . toString ( ) ) ; } public boolean equals ( Object other ) { if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( other ) ; } return other . getClass ( ) . equals ( getClass ( ) ) && compareTo ( other ) == 0 ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } String name = getName ( ) ; return MAGIC * ( name == null ? NULL_NAME : name . hashCode ( ) ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } throw new UnsupportedOperationException ( ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( ) ; } public Iterator iterator ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . iterator ( ) : new Iterator ( ) { private boolean done = false ; public boolean hasNext ( ) { return ! done ; } public Object next ( ) { if ( done ) { throw new NoSuchElementException ( ) ; } done = true ; return Resource . this ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public int size ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . size ( ) : 1 ; } public boolean isFilesystemOnly ( ) { return isReference ( ) && ( ( Resource ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } String n = getName ( ) ; return n == null ? "(anonymous)" : n ; } public final String toLongString ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . toLongString ( ) : getDataTypeName ( ) + " \"" + toString ( ) + '"' ; } public void setRefid ( Reference r ) { if ( name != null || exists != null || lastmodified != null || directory != null || size != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } } 	0	['29', '3', '7', '89', '59', '328', '85', '5', '27', '0.880952381', '471', '0.777777778', '0', '0.566037736', '0.234693878', '3', '4', '14.93103448', '6', '2.0345', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class P4Add extends P4Base { private static final int DEFAULT_CMD_LENGTH = 450 ; private int changelist ; private String addCmd = "" ; private Vector filesets = new Vector ( ) ; private int cmdLength = DEFAULT_CMD_LENGTH ; public void setCommandlength ( int len ) throws BuildException { if ( len <= 0 ) { throw new BuildException ( "P4Add: Commandlength should be a positive number" ) ; } this . cmdLength = len ; } public void setChangelist ( int changelist ) throws BuildException { if ( changelist <= 0 ) { throw new BuildException ( "P4Add: Changelist# should be a positive number" ) ; } this . changelist = changelist ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( P4View != null ) { addCmd = P4View ; } P4CmdOpts = ( changelist > 0 ) ? ( "-c " + changelist ) : "" ; StringBuffer filelist = new StringBuffer ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; if ( srcFiles != null ) { for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File f = new File ( ds . getBasedir ( ) , srcFiles [ j ] ) ; filelist . append ( " " ) . append ( '"' ) . append ( f . getAbsolutePath ( ) ) . append ( '"' ) ; if ( filelist . length ( ) > cmdLength ) { execP4Add ( filelist ) ; filelist = new StringBuffer ( ) ; } } if ( filelist . length ( ) > 0 ) { execP4Add ( filelist ) ; } } else { log ( "No files specified to add!" , Project . MSG_WARN ) ; } } } private void execP4Add ( StringBuffer list ) { log ( "Execing add " + P4CmdOpts + " " + addCmd + list , Project . MSG_INFO ) ; execP4Command ( "-s add " + P4CmdOpts + " " + addCmd + list , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['6', '4', '0', '7', '29', '0', '0', '7', '5', '0.76', '195', '1', '0', '0.910714286', '0.416666667', '0', '0', '30.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class PropertyFile extends Task { private String comment ; private Properties properties ; private File propertyfile ; private Vector entries = new Vector ( ) ; public void execute ( ) throws BuildException { checkParameters ( ) ; readFile ( ) ; executeOperation ( ) ; writeFile ( ) ; } public Entry createEntry ( ) { Entry e = new Entry ( ) ; entries . addElement ( e ) ; return e ; } private void executeOperation ( ) throws BuildException { for ( Enumeration e = entries . elements ( ) ; e . hasMoreElements ( ) ; ) { Entry entry = ( Entry ) e . nextElement ( ) ; entry . executeOn ( properties ) ; } } private void readFile ( ) throws BuildException { properties = new Properties ( ) ; try { if ( propertyfile . exists ( ) ) { log ( "Updating property file: " + propertyfile . getAbsolutePath ( ) ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( propertyfile ) ; BufferedInputStream bis = new BufferedInputStream ( fis ) ; properties . load ( bis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } } else { log ( "Creating new property file: " + propertyfile . getAbsolutePath ( ) ) ; FileOutputStream out = null ; try { out = new FileOutputStream ( propertyfile . getAbsolutePath ( ) ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) ) ; } } private void checkParameters ( ) throws BuildException { if ( ! checkParam ( propertyfile ) ) { throw new BuildException ( "file token must not be null." , getLocation ( ) ) ; } } public void setFile ( File file ) { propertyfile = file ; } public void setComment ( String hdr ) { comment = hdr ; } private void writeFile ( ) throws BuildException { BufferedOutputStream bos = null ; try { bos = new BufferedOutputStream ( new FileOutputStream ( propertyfile ) ) ; properties . store ( bos , comment ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bos ) ; } } private boolean checkParam ( File param ) { return ! ( param == null ) ; } public static class Entry { private static final int DEFAULT_INT_VALUE = 0 ; private static final String DEFAULT_DATE_VALUE = "now" ; private static final String DEFAULT_STRING_VALUE = "" ; private String key = null ; private int type = Type . STRING_TYPE ; private int operation = Operation . EQUALS_OPER ; private String value = null ; private String defaultValue = null ; private String newValue = null ; private String pattern = null ; private int field = Calendar . DATE ; public void setKey ( String value ) { this . key = value ; } public void setValue ( String value ) { this . value = value ; } public void setOperation ( Operation value ) { this . operation = Operation . toOperation ( value . getValue ( ) ) ; } public void setType ( Type value ) { this . type = Type . toType ( value . getValue ( ) ) ; } public void setDefault ( String value ) { this . defaultValue = value ; } public void setPattern ( String value ) { this . pattern = value ; } public void setUnit ( PropertyFile . Unit unit ) { field = unit . getCalendarField ( ) ; } protected void executeOn ( Properties props ) throws BuildException { checkParameters ( ) ; String oldValue = ( String ) props . get ( key ) ; try { if ( type == Type . INTEGER_TYPE ) { executeInteger ( oldValue ) ; } else if ( type == Type . DATE_TYPE ) { executeDate ( oldValue ) ; } else if ( type == Type . STRING_TYPE ) { executeString ( oldValue ) ; } else { throw new BuildException ( "Unknown operation type: " + type ) ; } } catch ( NullPointerException npe ) { npe . printStackTrace ( ) ; } if ( newValue == null ) { newValue = "" ; } props . put ( key , newValue ) ; } private void executeDate ( String oldValue ) throws BuildException { Calendar currentValue = Calendar . getInstance ( ) ; if ( pattern == null ) { pattern = "yyyy/MM/dd HH:mm" ; } DateFormat fmt = new SimpleDateFormat ( pattern ) ; String currentStringValue = getCurrentValue ( oldValue ) ; if ( currentStringValue == null ) { currentStringValue = DEFAULT_DATE_VALUE ; } if ( "now" . equals ( currentStringValue ) ) { currentValue . setTime ( new Date ( ) ) ; } else { try { currentValue . setTime ( fmt . parse ( currentStringValue ) ) ; } catch ( ParseException pe ) { } } if ( operation != Operation . EQUALS_OPER ) { int offset = 0 ; try { offset = Integer . parseInt ( value ) ; if ( operation == Operation . DECREMENT_OPER ) { offset = - 1 * offset ; } } catch ( NumberFormatException e ) { throw new BuildException ( "Value not an integer on " + key ) ; } currentValue . add ( field , offset ) ; } newValue = fmt . format ( currentValue . getTime ( ) ) ; } private void executeInteger ( String oldValue ) throws BuildException { int currentValue = DEFAULT_INT_VALUE ; int newV = DEFAULT_INT_VALUE ; DecimalFormat fmt = ( pattern != null ) ? new DecimalFormat ( pattern ) : new DecimalFormat ( ) ; try { String curval = getCurrentValue ( oldValue ) ; if ( curval != null ) { currentValue = fmt . parse ( curval ) . intValue ( ) ; } else { currentValue = 0 ; } } catch ( NumberFormatException nfe ) { } catch ( ParseException pe ) { } if ( operation == Operation . EQUALS_OPER ) { newV = currentValue ; } else { int operationValue = 1 ; if ( value != null ) { try { operationValue = fmt . parse ( value ) . intValue ( ) ; } catch ( NumberFormatException nfe ) { } catch ( ParseException pe ) { } } if ( operation == Operation . INCREMENT_OPER ) { newV = currentValue + operationValue ; } else if ( operation == Operation . DECREMENT_OPER ) { newV = currentValue - operationValue ; } } this . newValue = fmt . format ( newV ) ; } private void executeString ( String oldValue ) throws BuildException { String newV = DEFAULT_STRING_VALUE ; String currentValue = getCurrentValue ( oldValue ) ; if ( currentValue == null ) { currentValue = DEFAULT_STRING_VALUE ; } if ( operation == Operation . EQUALS_OPER ) { newV = currentValue ; } else if ( operation == Operation . INCREMENT_OPER ) { newV = currentValue + value ; } this . newValue = newV ; } private void checkParameters ( ) throws BuildException { if ( type == Type . STRING_TYPE && operation == Operation . DECREMENT_OPER ) { throw new BuildException ( "- is not supported for string " + "properties (key:" + key + ")" ) ; } if ( value == null && defaultValue == null ) { throw new BuildException ( "\"value\" and/or \"default\" " + "attribute must be specified (key:" + key + ")" ) ; } if ( key == null ) { throw new BuildException ( "key is mandatory" ) ; } if ( type == Type . STRING_TYPE && pattern != null ) { throw new BuildException ( "pattern is not supported for string " + "properties (key:" + key + ")" ) ; } } private String getCurrentValue ( String oldValue ) { String ret = null ; if ( operation == Operation . EQUALS_OPER ) { if ( value != null && defaultValue == null ) { ret = value ; } if ( value == null && defaultValue != null && oldValue != null ) { ret = oldValue ; } if ( value == null && defaultValue != null && oldValue == null ) { ret = defaultValue ; } if ( value != null && defaultValue != null && oldValue != null ) { ret = value ; } if ( value != null && defaultValue != null && oldValue == null ) { ret = defaultValue ; } } else { ret = ( oldValue == null ) ? defaultValue : oldValue ; } return ret ; } public static class Operation extends EnumeratedAttribute { public static final int INCREMENT_OPER = 0 ; public static final int DECREMENT_OPER = 1 ; public static final int EQUALS_OPER = 2 ; public String [ ] getValues ( ) { return new String [ ] { "+" , "-" , "=" } ; } public static int toOperation ( String oper ) { if ( "+" . equals ( oper ) ) { return INCREMENT_OPER ; } else if ( "-" . equals ( oper ) ) { return DECREMENT_OPER ; } return EQUALS_OPER ; } } public static class Type extends EnumeratedAttribute { public static final int INTEGER_TYPE = 0 ; public static final int DATE_TYPE = 1 ; public static final int STRING_TYPE = 2 ; public String [ ] getValues ( ) { return new String [ ] { "int" , "date" , "string" } ; } public static int toType ( String type ) { if ( "int" . equals ( type ) ) { return INTEGER_TYPE ; } else if ( "date" . equals ( type ) ) { return DATE_TYPE ; } return STRING_TYPE ; } } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Map calendarFields = new HashMap ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	0	['10', '3', '0', '5', '41', '21', '0', '5', '5', '0.666666667', '214', '1', '0', '0.804347826', '0.433333333', '0', '0', '20', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import java . util . Vector ; public class Description extends DataType { public void addText ( String text ) { ProjectHelper ph = ProjectHelper . getProjectHelper ( ) ; if ( ! ( ph instanceof ProjectHelperImpl ) ) { return ; } String currentDescription = getProject ( ) . getDescription ( ) ; if ( currentDescription == null ) { getProject ( ) . setDescription ( text ) ; } else { getProject ( ) . setDescription ( currentDescription + text ) ; } } public static String getDescription ( Project project ) { Vector targets = ( Vector ) project . getReference ( "ant.targets" ) ; if ( targets == null ) { return null ; } StringBuffer description = new StringBuffer ( ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { Target t = ( Target ) targets . elementAt ( i ) ; concatDescriptions ( project , t , description ) ; } return description . toString ( ) ; } private static void concatDescriptions ( Project project , Target t , StringBuffer description ) { if ( t == null ) { return ; } Vector tasks = findElementInTarget ( project , t , "description" ) ; if ( tasks == null ) { return ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { Task task = ( Task ) tasks . elementAt ( i ) ; if ( ! ( task instanceof UnknownElement ) ) { continue ; } UnknownElement ue = ( ( UnknownElement ) task ) ; String descComp = ue . getWrapper ( ) . getText ( ) . toString ( ) ; if ( descComp != null ) { description . append ( project . replaceProperties ( descComp ) ) ; } } } private static Vector findElementInTarget ( Project project , Target t , String name ) { Task [ ] tasks = t . getTasks ( ) ; Vector elems = new Vector ( ) ; for ( int i = 0 ; i < tasks . length ; i ++ ) { if ( name . equals ( tasks [ i ] . getTaskName ( ) ) ) { elems . addElement ( tasks [ i ] ) ; } } return elems ; } } 	0	['5', '3', '0', '8', '26', '10', '1', '8', '3', '2', '144', '0', '0', '0.882352941', '0.4', '0', '0', '27.8', '6', '3', '0']
package org . apache . tools . ant . types ; public class FlexInteger { private Integer value ; public FlexInteger ( String value ) { this . value = Integer . decode ( value ) ; } public int intValue ( ) { return value . intValue ( ) ; } public String toString ( ) { return value . toString ( ) ; } } 	0	['3', '1', '0', '0', '7', '0', '0', '0', '3', '0', '19', '1', '0', '0', '0.666666667', '0', '0', '5', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or " + "only a filtersFile parameter is " + "required" , getLocation ( ) ) ; } if ( isSingleFilter ) { getProject ( ) . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; getProject ( ) . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '5', '17', '5', '0', '5', '5', '0.733333333', '94', '1', '0', '0.880952381', '0.5', '0', '0', '14.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; public class ExtensionUtil { private ExtensionUtil ( ) { } static ArrayList toExtensions ( final List adapters ) throws BuildException { final ArrayList results = new ArrayList ( ) ; final int size = adapters . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionAdapter adapter = ( ExtensionAdapter ) adapters . get ( i ) ; final Extension extension = adapter . toExtension ( ) ; results . add ( extension ) ; } return results ; } static void extractExtensions ( final Project project , final List libraries , final List fileset ) throws BuildException { if ( ! fileset . isEmpty ( ) ) { final Extension [ ] extensions = getExtensions ( project , fileset ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { libraries . add ( extensions [ i ] ) ; } } } private static Extension [ ] getExtensions ( final Project project , final List libraries ) throws BuildException { final ArrayList extensions = new ArrayList ( ) ; final Iterator iterator = libraries . iterator ( ) ; while ( iterator . hasNext ( ) ) { final FileSet fileSet = ( FileSet ) iterator . next ( ) ; boolean includeImpl = true ; boolean includeURL = true ; if ( fileSet instanceof LibFileSet ) { LibFileSet libFileSet = ( LibFileSet ) fileSet ; includeImpl = libFileSet . isIncludeImpl ( ) ; includeURL = libFileSet . isIncludeURL ( ) ; } final DirectoryScanner scanner = fileSet . getDirectoryScanner ( project ) ; final File basedir = scanner . getBasedir ( ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { final File file = new File ( basedir , files [ i ] ) ; loadExtensions ( file , extensions , includeImpl , includeURL ) ; } } return ( Extension [ ] ) extensions . toArray ( new Extension [ extensions . size ( ) ] ) ; } private static void loadExtensions ( final File file , final List extensionList , final boolean includeImpl , final boolean includeURL ) throws BuildException { try { final JarFile jarFile = new JarFile ( file ) ; final Extension [ ] extensions = Extension . getAvailable ( jarFile . getManifest ( ) ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; addExtension ( extensionList , extension , includeImpl , includeURL ) ; } } catch ( final Exception e ) { throw new BuildException ( e . getMessage ( ) , e ) ; } } private static void addExtension ( final List extensionList , final Extension originalExtension , final boolean includeImpl , final boolean includeURL ) { Extension extension = originalExtension ; if ( ! includeURL && null != extension . getImplementationURL ( ) ) { extension = new Extension ( extension . getExtensionName ( ) , extension . getSpecificationVersion ( ) . toString ( ) , extension . getSpecificationVendor ( ) , extension . getImplementationVersion ( ) . toString ( ) , extension . getImplementationVendor ( ) , extension . getImplementationVendorID ( ) , null ) ; } final boolean hasImplAttributes = null != extension . getImplementationURL ( ) || null != extension . getImplementationVersion ( ) || null != extension . getImplementationVendorID ( ) || null != extension . getImplementationVendor ( ) ; if ( ! includeImpl && hasImplAttributes ) { extension = new Extension ( extension . getExtensionName ( ) , extension . getSpecificationVersion ( ) . toString ( ) , extension . getSpecificationVendor ( ) , null , null , null , extension . getImplementationURL ( ) ) ; } extensionList . add ( extension ) ; } static Manifest getManifest ( final File file ) throws BuildException { try { final JarFile jarFile = new JarFile ( file ) ; Manifest m = jarFile . getManifest ( ) ; if ( m == null ) { throw new BuildException ( file + " doesn't have a MANIFEST" ) ; } return m ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } } } 	0	['7', '1', '0', '12', '46', '21', '4', '8', '0', '2', '264', '0', '0', '0', '0.30952381', '0', '0', '36.71428571', '9', '2', '0']
package org . apache . tools . ant . taskdefs . optional . unix ; import org . apache . tools . ant . BuildException ; public class Chown extends AbstractAccessTask { private boolean haveOwner = false ; public Chown ( ) { super . setExecutable ( "chown" ) ; } public void setOwner ( String owner ) { createArg ( ) . setValue ( owner ) ; haveOwner = true ; } protected void checkConfiguration ( ) { if ( ! haveOwner ) { throw new BuildException ( "Required attribute owner not set in" + " chown" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable" + " attribute" , getLocation ( ) ) ; } } 	0	['4', '6', '0', '4', '16', '0', '0', '4', '3', '0.333333333', '52', '1', '0', '0.973913043', '0.75', '2', '2', '11.75', '2', '1', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; import java . io . PrintWriter ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String message ) { super ( message ) ; } public BuildException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String message , Location location ) { super ( message ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public Throwable getCause ( ) { return getException ( ) ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['15', '4', '3', '499', '30', '0', '498', '1', '15', '0.392857143', '153', '1', '1', '0.619047619', '0.322222222', '1', '3', '9.066666667', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; public class ClassFileUtils { public static String convertSlashName ( String name ) { return name . replace ( '\\' , '.' ) . replace ( '/' , '.' ) ; } public static String convertDotName ( String dotName ) { return dotName . replace ( '.' , '/' ) ; } } 	0	['3', '1', '0', '2', '5', '3', '2', '0', '3', '2', '19', '0', '0', '0', '0.5', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; private int index = - 1 ; public abstract String [ ] getValues ( ) ; protected EnumeratedAttribute ( ) { } public static EnumeratedAttribute getInstance ( Class clazz , String value ) throws BuildException { if ( ! EnumeratedAttribute . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( "You have to provide a subclass from EnumeratedAttribut as clazz-parameter." ) ; } EnumeratedAttribute ea = null ; try { ea = ( EnumeratedAttribute ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } ea . setValue ( value ) ; return ea ; } public final void setValue ( String value ) throws BuildException { int idx = indexOfValue ( value ) ; if ( idx == - 1 ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . index = idx ; this . value = value ; } public final boolean containsValue ( String value ) { return ( indexOfValue ( value ) != - 1 ) ; } public final int indexOfValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return - 1 ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return i ; } } return - 1 ; } public final String getValue ( ) { return value ; } public final int getIndex ( ) { return index ; } public String toString ( ) { return getValue ( ) ; } } 	0	['9', '1', '59', '62', '22', '28', '61', '1', '8', '0.75', '130', '0.666666667', '0', '0', '0.481481481', '0', '0', '13.11111111', '5', '1.4444', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . taskdefs . optional . jsp . JspMangler ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; public class JasperC extends DefaultJspCompilerAdapter { JspMangler mangler ; public JasperC ( JspMangler mangler ) { this . mangler = mangler ; } public boolean execute ( ) throws BuildException { getJspc ( ) . log ( "Using jasper compiler" , Project . MSG_VERBOSE ) ; CommandlineJava cmd = setupJasperCommand ( ) ; try { Java java = new Java ( owner ) ; Path p = getClasspath ( ) ; if ( getJspc ( ) . getClasspath ( ) != null ) { getProject ( ) . log ( "using user supplied classpath: " + p , Project . MSG_DEBUG ) ; } else { getProject ( ) . log ( "using system classpath: " + p , Project . MSG_DEBUG ) ; } java . setClasspath ( p ) ; java . setDir ( getProject ( ) . getBaseDir ( ) ) ; java . setClassname ( "org.apache.jasper.JspC" ) ; String [ ] args = cmd . getJavaCommand ( ) . getArguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { java . createArg ( ) . setValue ( args [ i ] ) ; } java . setFailonerror ( getJspc ( ) . getFailonerror ( ) ) ; java . setFork ( true ) ; java . setTaskName ( "jasperc" ) ; java . execute ( ) ; return true ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error running jsp compiler: " , ex , getJspc ( ) . getLocation ( ) ) ; } } finally { getJspc ( ) . deleteEmptyJavaFiles ( ) ; } } private CommandlineJava setupJasperCommand ( ) { CommandlineJava cmd = new CommandlineJava ( ) ; JspC jspc = getJspc ( ) ; addArg ( cmd , "-d" , jspc . getDestdir ( ) ) ; addArg ( cmd , "-p" , jspc . getPackage ( ) ) ; if ( ! isTomcat5x ( ) ) { addArg ( cmd , "-v" + jspc . getVerbose ( ) ) ; } else { getProject ( ) . log ( "this task doesn't support Tomcat 5.x properly, " + "please use the Tomcat provided jspc task " + "instead" ) ; } addArg ( cmd , "-uriroot" , jspc . getUriroot ( ) ) ; addArg ( cmd , "-uribase" , jspc . getUribase ( ) ) ; addArg ( cmd , "-ieplugin" , jspc . getIeplugin ( ) ) ; addArg ( cmd , "-webinc" , jspc . getWebinc ( ) ) ; addArg ( cmd , "-webxml" , jspc . getWebxml ( ) ) ; addArg ( cmd , "-die9" ) ; if ( jspc . isMapped ( ) ) { addArg ( cmd , "-mapped" ) ; } if ( jspc . getWebApp ( ) != null ) { File dir = jspc . getWebApp ( ) . getDirectory ( ) ; addArg ( cmd , "-webapp" , dir ) ; } logAndAddFilesToCompile ( getJspc ( ) , getJspc ( ) . getCompileList ( ) , cmd ) ; return cmd ; } public JspMangler createMangler ( ) { return mangler ; } private Path getClasspath ( ) { Path p = getJspc ( ) . getClasspath ( ) ; if ( p == null ) { p = new Path ( getProject ( ) ) ; return p . concatSystemClasspath ( "only" ) ; } else { return p . concatSystemClasspath ( "ignore" ) ; } } private boolean isTomcat5x ( ) { AntClassLoader l = null ; try { l = getProject ( ) . createClassLoader ( getClasspath ( ) ) ; l . loadClass ( "org.apache.jasper.tagplugins.jstl.If" ) ; return true ; } catch ( ClassNotFoundException e ) { return false ; } finally { if ( l != null ) { l . cleanup ( ) ; } } } } 	0	['6', '2', '0', '15', '56', '13', '1', '14', '3', '0.8', '280', '0', '1', '0.615384615', '0.583333333', '0', '0', '45.5', '5', '2.1667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . xml . sax . SAXException ; public class IPlanetEjbcTask extends Task { private File ejbdescriptor ; private File iasdescriptor ; private File dest ; private Path classpath ; private boolean keepgenerated = false ; private boolean debug = false ; private File iashome ; public void setEjbdescriptor ( File ejbdescriptor ) { this . ejbdescriptor = ejbdescriptor ; } public void setIasdescriptor ( File iasdescriptor ) { this . iasdescriptor = iasdescriptor ; } public void setDest ( File dest ) { this . dest = dest ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setKeepgenerated ( boolean keepgenerated ) { this . keepgenerated = keepgenerated ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setIashome ( File iashome ) { this . iashome = iashome ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; executeEjbc ( getParser ( ) ) ; } private void checkConfiguration ( ) throws BuildException { if ( ejbdescriptor == null ) { String msg = "The standard EJB descriptor must be specified using " + "the \"ejbdescriptor\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! ejbdescriptor . exists ( ) ) || ( ! ejbdescriptor . isFile ( ) ) ) { String msg = "The standard EJB descriptor (" + ejbdescriptor + ") was not found or isn't a file." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( iasdescriptor == null ) { String msg = "The iAS-speific XML descriptor must be specified using" + " the \"iasdescriptor\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! iasdescriptor . exists ( ) ) || ( ! iasdescriptor . isFile ( ) ) ) { String msg = "The iAS-specific XML descriptor (" + iasdescriptor + ") was not found or isn't a file." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( dest == null ) { String msg = "The destination directory must be specified using " + "the \"dest\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! dest . exists ( ) ) || ( ! dest . isDirectory ( ) ) ) { String msg = "The destination directory (" + dest + ") was not " + "found or isn't a directory." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( iashome != null ) && ( ! iashome . isDirectory ( ) ) ) { String msg = "If \"iashome\" is specified, it must be a valid " + "directory (it was set to " + iashome + ")." ; throw new BuildException ( msg , getLocation ( ) ) ; } } private SAXParser getParser ( ) throws BuildException { SAXParser saxParser = null ; try { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; saxParserFactory . setValidating ( true ) ; saxParser = saxParserFactory . newSAXParser ( ) ; } catch ( SAXException e ) { String msg = "Unable to create a SAXParser: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( ParserConfigurationException e ) { String msg = "Unable to create a SAXParser: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } return saxParser ; } private void executeEjbc ( SAXParser saxParser ) throws BuildException { IPlanetEjbc ejbc = new IPlanetEjbc ( ejbdescriptor , iasdescriptor , dest , getClasspath ( ) . toString ( ) , saxParser ) ; ejbc . setRetainSource ( keepgenerated ) ; ejbc . setDebugOutput ( debug ) ; if ( iashome != null ) { ejbc . setIasHomeDir ( iashome ) ; } try { ejbc . execute ( ) ; } catch ( IOException e ) { String msg = "An IOException occurred while trying to read the XML " + "descriptor file: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( SAXException e ) { String msg = "A SAXException occurred while trying to read the XML " + "descriptor file: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( IPlanetEjbc . EjbcException e ) { String msg = "An exception occurred while trying to run the ejbc " + "utility: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } } private Path getClasspath ( ) { Path cp = null ; if ( classpath == null ) { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { cp = classpath . concatSystemClasspath ( "ignore" ) ; } return cp ; } } 	0	['14', '3', '0', '7', '43', '57', '0', '7', '10', '0.769230769', '386', '1', '1', '0.74', '0.314285714', '0', '0', '26.07142857', '2', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JavaCC extends Task { private static final String LOOKAHEAD = "LOOKAHEAD" ; private static final String CHOICE_AMBIGUITY_CHECK = "CHOICE_AMBIGUITY_CHECK" ; private static final String OTHER_AMBIGUITY_CHECK = "OTHER_AMBIGUITY_CHECK" ; private static final String STATIC = "STATIC" ; private static final String DEBUG_PARSER = "DEBUG_PARSER" ; private static final String DEBUG_LOOKAHEAD = "DEBUG_LOOKAHEAD" ; private static final String DEBUG_TOKEN_MANAGER = "DEBUG_TOKEN_MANAGER" ; private static final String OPTIMIZE_TOKEN_MANAGER = "OPTIMIZE_TOKEN_MANAGER" ; private static final String ERROR_REPORTING = "ERROR_REPORTING" ; private static final String JAVA_UNICODE_ESCAPE = "JAVA_UNICODE_ESCAPE" ; private static final String UNICODE_INPUT = "UNICODE_INPUT" ; private static final String IGNORE_CASE = "IGNORE_CASE" ; private static final String COMMON_TOKEN_ACTION = "COMMON_TOKEN_ACTION" ; private static final String USER_TOKEN_MANAGER = "USER_TOKEN_MANAGER" ; private static final String USER_CHAR_STREAM = "USER_CHAR_STREAM" ; private static final String BUILD_PARSER = "BUILD_PARSER" ; private static final String BUILD_TOKEN_MANAGER = "BUILD_TOKEN_MANAGER" ; private static final String SANITY_CHECK = "SANITY_CHECK" ; private static final String FORCE_LA_CHECK = "FORCE_LA_CHECK" ; private static final String CACHE_TOKENS = "CACHE_TOKENS" ; private static final String KEEP_LINE_COLUMN = "KEEP_LINE_COLUMN" ; private static final String JDK_VERSION = "JDK_VERSION" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private File outputDirectory = null ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; protected static final int TASKDEF_TYPE_JAVACC = 1 ; protected static final int TASKDEF_TYPE_JJTREE = 2 ; protected static final int TASKDEF_TYPE_JJDOC = 3 ; protected static final String [ ] ARCHIVE_LOCATIONS = new String [ ] { "JavaCC.zip" , "bin/lib/JavaCC.zip" , "bin/lib/javacc.jar" , "javacc.jar" , } ; protected static final int [ ] ARCHIVE_LOCATIONS_VS_MAJOR_VERSION = new int [ ] { 1 , 2 , 3 , 3 , } ; protected static final String COM_PACKAGE = "COM.sun.labs." ; protected static final String COM_JAVACC_CLASS = "javacc.Main" ; protected static final String COM_JJTREE_CLASS = "jjtree.Main" ; protected static final String COM_JJDOC_CLASS = "jjdoc.JJDocMain" ; protected static final String ORG_PACKAGE_3_0 = "org.netbeans.javacc." ; protected static final String ORG_PACKAGE_3_1 = "org.javacc." ; protected static final String ORG_JAVACC_CLASS = "parser.Main" ; protected static final String ORG_JJTREE_CLASS = COM_JJTREE_CLASS ; protected static final String ORG_JJDOC_CLASS = COM_JJDOC_CLASS ; public void setLookahead ( int lookahead ) { optionalAttrs . put ( LOOKAHEAD , new Integer ( lookahead ) ) ; } public void setChoiceambiguitycheck ( int choiceAmbiguityCheck ) { optionalAttrs . put ( CHOICE_AMBIGUITY_CHECK , new Integer ( choiceAmbiguityCheck ) ) ; } public void setOtherambiguityCheck ( int otherAmbiguityCheck ) { optionalAttrs . put ( OTHER_AMBIGUITY_CHECK , new Integer ( otherAmbiguityCheck ) ) ; } public void setStatic ( boolean staticParser ) { optionalAttrs . put ( STATIC , staticParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebugparser ( boolean debugParser ) { optionalAttrs . put ( DEBUG_PARSER , debugParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebuglookahead ( boolean debugLookahead ) { optionalAttrs . put ( DEBUG_LOOKAHEAD , debugLookahead ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebugtokenmanager ( boolean debugTokenManager ) { optionalAttrs . put ( DEBUG_TOKEN_MANAGER , debugTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setOptimizetokenmanager ( boolean optimizeTokenManager ) { optionalAttrs . put ( OPTIMIZE_TOKEN_MANAGER , optimizeTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setErrorreporting ( boolean errorReporting ) { optionalAttrs . put ( ERROR_REPORTING , errorReporting ? Boolean . TRUE : Boolean . FALSE ) ; } public void setJavaunicodeescape ( boolean javaUnicodeEscape ) { optionalAttrs . put ( JAVA_UNICODE_ESCAPE , javaUnicodeEscape ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUnicodeinput ( boolean unicodeInput ) { optionalAttrs . put ( UNICODE_INPUT , unicodeInput ? Boolean . TRUE : Boolean . FALSE ) ; } public void setIgnorecase ( boolean ignoreCase ) { optionalAttrs . put ( IGNORE_CASE , ignoreCase ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCommontokenaction ( boolean commonTokenAction ) { optionalAttrs . put ( COMMON_TOKEN_ACTION , commonTokenAction ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUsertokenmanager ( boolean userTokenManager ) { optionalAttrs . put ( USER_TOKEN_MANAGER , userTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUsercharstream ( boolean userCharStream ) { optionalAttrs . put ( USER_CHAR_STREAM , userCharStream ? Boolean . TRUE : Boolean . FALSE ) ; } public void setBuildparser ( boolean buildParser ) { optionalAttrs . put ( BUILD_PARSER , buildParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setBuildtokenmanager ( boolean buildTokenManager ) { optionalAttrs . put ( BUILD_TOKEN_MANAGER , buildTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setSanitycheck ( boolean sanityCheck ) { optionalAttrs . put ( SANITY_CHECK , sanityCheck ? Boolean . TRUE : Boolean . FALSE ) ; } public void setForcelacheck ( boolean forceLACheck ) { optionalAttrs . put ( FORCE_LA_CHECK , forceLACheck ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCachetokens ( boolean cacheTokens ) { optionalAttrs . put ( CACHE_TOKENS , cacheTokens ? Boolean . TRUE : Boolean . FALSE ) ; } public void setKeeplinecolumn ( boolean keepLineColumn ) { optionalAttrs . put ( KEEP_LINE_COLUMN , keepLineColumn ? Boolean . TRUE : Boolean . FALSE ) ; } public void setJDKversion ( String jdkVersion ) { optionalAttrs . put ( JDK_VERSION , jdkVersion ) ; } public void setOutputdirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public void setTarget ( File targetFile ) { this . targetFile = targetFile ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JavaCC ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputDirectory == null ) { outputDirectory = new File ( targetFile . getParent ( ) ) ; } else if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "Outputdir not a directory." ) ; } cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + outputDirectory . getAbsolutePath ( ) ) ; final File javaFile = getOutputJavaFile ( outputDirectory , targetFile ) ; if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JAVACC ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; Execute . runCommand ( this , cmdl . getCommandline ( ) ) ; } protected static File getArchiveFile ( File home ) throws BuildException { return new File ( home , ARCHIVE_LOCATIONS [ getArchiveLocationIndex ( home ) ] ) ; } protected static String getMainClass ( File home , int type ) throws BuildException { Path p = new Path ( null ) ; p . createPathElement ( ) . setLocation ( getArchiveFile ( home ) ) ; p . addJavaRuntime ( ) ; return getMainClass ( p , type ) ; } protected static String getMainClass ( Path path , int type ) throws BuildException { String packagePrefix = null ; String mainClass = null ; AntClassLoader l = new AntClassLoader ( ) ; l . setClassPath ( path . concatSystemClasspath ( "ignore" ) ) ; String javaccClass = COM_PACKAGE + COM_JAVACC_CLASS ; InputStream is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = COM_PACKAGE ; switch ( type ) { case TASKDEF_TYPE_JAVACC : mainClass = COM_JAVACC_CLASS ; break ; case TASKDEF_TYPE_JJTREE : mainClass = COM_JJTREE_CLASS ; break ; case TASKDEF_TYPE_JJDOC : mainClass = COM_JJDOC_CLASS ; break ; default : } } else { javaccClass = ORG_PACKAGE_3_1 + ORG_JAVACC_CLASS ; is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = ORG_PACKAGE_3_1 ; } else { javaccClass = ORG_PACKAGE_3_0 + ORG_JAVACC_CLASS ; is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = ORG_PACKAGE_3_0 ; } } if ( is != null ) { switch ( type ) { case TASKDEF_TYPE_JAVACC : mainClass = ORG_JAVACC_CLASS ; break ; case TASKDEF_TYPE_JJTREE : mainClass = ORG_JJTREE_CLASS ; break ; case TASKDEF_TYPE_JJDOC : mainClass = ORG_JJDOC_CLASS ; break ; default : } } } if ( packagePrefix == null ) { throw new BuildException ( "failed to load JavaCC" ) ; } if ( mainClass == null ) { throw new BuildException ( "unknown task type " + type ) ; } return packagePrefix + mainClass ; } private static int getArchiveLocationIndex ( File home ) throws BuildException { if ( home == null || ! home . isDirectory ( ) ) { throw new BuildException ( "JavaCC home must be a valid directory." ) ; } for ( int i = 0 ; i < ARCHIVE_LOCATIONS . length ; i ++ ) { File f = new File ( home , ARCHIVE_LOCATIONS [ i ] ) ; if ( f . exists ( ) ) { return i ; } } throw new BuildException ( "Could not find a path to JavaCC.zip " + "or javacc.jar from '" + home + "'." ) ; } protected static int getMajorVersionNumber ( File home ) throws BuildException { return ARCHIVE_LOCATIONS_VS_MAJOR_VERSION [ getArchiveLocationIndex ( home ) ] ; } private File getOutputJavaFile ( File outputdir , File srcfile ) { String path = srcfile . getPath ( ) ; int startBasename = path . lastIndexOf ( File . separator ) ; if ( startBasename != - 1 ) { path = path . substring ( startBasename + 1 ) ; } int startExtn = path . lastIndexOf ( '.' ) ; if ( startExtn != - 1 ) { path = path . substring ( 0 , startExtn ) + ".java" ; } else { path += ".java" ; } if ( outputdir != null ) { path = outputdir + File . separator + path ; } return new File ( path ) ; } } 	0	['34', '3', '0', '12', '86', '0', '2', '10', '27', '0.998521803', '822', '1', '1', '0.536231884', '0.308080808', '1', '1', '21.97058824', '4', '1.5588', '0']
package org . apache . tools . ant . util ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; public class ConcatResourceInputStream extends InputStream { private static final int EOF = - 1 ; private boolean eof = false ; private Iterator iter ; private InputStream currentStream ; private ProjectComponent managingPc ; private boolean ignoreErrors = false ; public ConcatResourceInputStream ( ResourceCollection rc ) { iter = rc . iterator ( ) ; } public void setIgnoreErrors ( boolean b ) { ignoreErrors = b ; } public boolean isIgnoreErrors ( ) { return ignoreErrors ; } public void close ( ) throws IOException { closeCurrent ( ) ; eof = true ; } public int read ( ) throws IOException { if ( eof ) { return EOF ; } int result = readCurrent ( ) ; if ( result == EOF ) { nextResource ( ) ; result = readCurrent ( ) ; } return result ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { ( loglevel > Project . MSG_WARN ? System . out : System . err ) . println ( message ) ; } } private int readCurrent ( ) throws IOException { return eof || currentStream == null ? EOF : currentStream . read ( ) ; } private void nextResource ( ) throws IOException { closeCurrent ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } log ( "Concating " + r . toLongString ( ) , Project . MSG_VERBOSE ) ; try { currentStream = new BufferedInputStream ( r . getInputStream ( ) ) ; return ; } catch ( IOException eyeOhEx ) { if ( ! ignoreErrors ) { log ( "Failed to get input stream for " + r , Project . MSG_ERR ) ; throw eyeOhEx ; } } } eof = true ; } private void closeCurrent ( ) { FileUtils . close ( currentStream ) ; currentStream = null ; } } 	0	['10', '2', '0', '6', '26', '9', '2', '4', '7', '0.722222222', '156', '1', '1', '0.5', '0.25', '1', '1', '14', '3', '1.1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; public class EqualComparator implements Comparator { public int compare ( Object o1 , Object o2 ) { if ( o1 == null ) { if ( o2 == null ) { return 1 ; } return 0 ; } return ( o1 . equals ( o2 ) ) ? 0 : 1 ; } public String toString ( ) { return "EqualComparator" ; } } 	0	['3', '1', '0', '1', '5', '3', '1', '0', '3', '2', '24', '0', '0', '0', '0.666666667', '0', '0', '7', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsFalse extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for falsehood" ) ; } return ! value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '34', '1', '0', '0.818181818', '0.666666667', '0', '0', '10', '2', '1', '0']
package org . apache . tools . ant . dispatch ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Task ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class DispatchUtils { public static final void execute ( Object task ) throws BuildException { String methodName = "execute" ; Dispatchable dispatchable = null ; try { if ( task instanceof Dispatchable ) { dispatchable = ( Dispatchable ) task ; } else if ( task instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) task ; Object realThing = ue . getRealThing ( ) ; if ( realThing != null && realThing instanceof Dispatchable && realThing instanceof Task ) { dispatchable = ( Dispatchable ) realThing ; } } if ( dispatchable != null ) { String mName = null ; try { final String name = dispatchable . getActionParameterName ( ) ; if ( name != null && name . trim ( ) . length ( ) > 0 ) { mName = "get" + name . trim ( ) . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( name . length ( ) > 1 ) { mName += name . substring ( 1 ) ; } final Class c = dispatchable . getClass ( ) ; final Method actionM = c . getMethod ( mName , new Class [ 0 ] ) ; if ( actionM != null ) { final Object o = actionM . invoke ( dispatchable , ( Object [ ] ) null ) ; if ( o != null ) { final String s = o . toString ( ) ; if ( s != null && s . trim ( ) . length ( ) > 0 ) { methodName = s . trim ( ) ; Method executeM = null ; executeM = dispatchable . getClass ( ) . getMethod ( methodName , new Class [ 0 ] ) ; if ( executeM == null ) { throw new BuildException ( "No public " + methodName + "() in " + dispatchable . getClass ( ) ) ; } executeM . invoke ( dispatchable , ( Object [ ] ) null ) ; if ( task instanceof UnknownElement ) { ( ( UnknownElement ) task ) . setRealThing ( null ) ; } } else { throw new BuildException ( "Dispatchable Task attribute '" + name . trim ( ) + "' not set or value is empty." ) ; } } else { throw new BuildException ( "Dispatchable Task attribute '" + name . trim ( ) + "' not set or value is empty." ) ; } } } else { throw new BuildException ( "Action Parameter Name must not be empty for Dispatchable Task." ) ; } } catch ( NoSuchMethodException nsme ) { throw new BuildException ( "No public " + mName + "() in " + task . getClass ( ) ) ; } } else { Method executeM = null ; executeM = task . getClass ( ) . getMethod ( methodName , new Class [ 0 ] ) ; if ( executeM == null ) { throw new BuildException ( "No public " + methodName + "() in " + task . getClass ( ) ) ; } executeM . invoke ( task , ( Object [ ] ) null ) ; if ( task instanceof UnknownElement ) { ( ( UnknownElement ) task ) . setRealThing ( null ) ; } } } catch ( InvocationTargetException ie ) { Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( NoSuchMethodException e ) { throw new BuildException ( e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '1', '0', '6', '23', '1', '3', '4', '2', '2', '265', '0', '0', '0', '0.5', '0', '0', '131.5', '1', '0.5', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public interface Regexp extends RegexpMatcher { int REPLACE_FIRST = 0x00000001 ; int REPLACE_ALL = 0x00000010 ; String substitute ( String input , String argument , int options ) throws BuildException ; } 	0	['1', '1', '0', '13', '1', '0', '11', '2', '1', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class SOSLabel extends SOS { public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_LABEL ) ; getRequiredAttributes ( ) ; if ( getLabel ( ) == null ) { throw new BuildException ( "label attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_LABEL ) ; commandLine . createArgument ( ) . setValue ( getLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getVerbose ( ) ) ; if ( getComment ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMENT ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; } return commandLine ; } } 	0	['5', '4', '0', '5', '18', '10', '0', '5', '4', '2', '81', '0', '0', '0.948717949', '0.8', '1', '2', '15.2', '3', '1.2', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public class Exists implements ResourceSelector { public boolean isSelected ( Resource r ) { return r . isExists ( ) ; } } 	0	['2', '1', '0', '6', '4', '1', '4', '2', '2', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . xml . sax . SAXException ; public class EjbJar extends MatchingTask { public static class DTDLocation extends org . apache . tools . ant . types . DTDLocation { } static class Config { public File srcDir ; public File descriptorDir ; public String baseNameTerminator = "-" ; public String baseJarName ; public boolean flatDestDir = false ; public Path classpath ; public List supportFileSets = new ArrayList ( ) ; public ArrayList dtdLocations = new ArrayList ( ) ; public NamingScheme namingScheme ; public File manifest ; public String analyzer ; } public static class NamingScheme extends EnumeratedAttribute { public static final String EJB_NAME = "ejb-name" ; public static final String DIRECTORY = "directory" ; public static final String DESCRIPTOR = "descriptor" ; public static final String BASEJARNAME = "basejarname" ; public String [ ] getValues ( ) { return new String [ ] { EJB_NAME , DIRECTORY , DESCRIPTOR , BASEJARNAME } ; } } public static class CMPVersion extends EnumeratedAttribute { public static final String CMP1_0 = "1.0" ; public static final String CMP2_0 = "2.0" ; public String [ ] getValues ( ) { return new String [ ] { CMP1_0 , CMP2_0 , } ; } } private Config config = new Config ( ) ; private File destDir ; private String genericJarSuffix = "-generic.jar" ; private String cmpVersion = CMPVersion . CMP1_0 ; private ArrayList deploymentTools = new ArrayList ( ) ; protected void addDeploymentTool ( EJBDeploymentTool deploymentTool ) { deploymentTool . setTask ( this ) ; deploymentTools . add ( deploymentTool ) ; } public WeblogicDeploymentTool createWeblogic ( ) { WeblogicDeploymentTool tool = new WeblogicDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public WebsphereDeploymentTool createWebsphere ( ) { WebsphereDeploymentTool tool = new WebsphereDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public BorlandDeploymentTool createBorland ( ) { log ( "Borland deployment tools" , Project . MSG_VERBOSE ) ; BorlandDeploymentTool tool = new BorlandDeploymentTool ( ) ; tool . setTask ( this ) ; deploymentTools . add ( tool ) ; return tool ; } public IPlanetDeploymentTool createIplanet ( ) { log ( "iPlanet Application Server deployment tools" , Project . MSG_VERBOSE ) ; IPlanetDeploymentTool tool = new IPlanetDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public JbossDeploymentTool createJboss ( ) { JbossDeploymentTool tool = new JbossDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public JonasDeploymentTool createJonas ( ) { log ( "JOnAS deployment tools" , Project . MSG_VERBOSE ) ; JonasDeploymentTool tool = new JonasDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public WeblogicTOPLinkDeploymentTool createWeblogictoplink ( ) { log ( "The <weblogictoplink> element is no longer required. Please use " + "the <weblogic> element and set newCMP=\"true\"" , Project . MSG_INFO ) ; WeblogicTOPLinkDeploymentTool tool = new WeblogicTOPLinkDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public Path createClasspath ( ) { if ( config . classpath == null ) { config . classpath = new Path ( getProject ( ) ) ; } return config . classpath . createPath ( ) ; } public DTDLocation createDTD ( ) { DTDLocation dtdLocation = new DTDLocation ( ) ; config . dtdLocations . add ( dtdLocation ) ; return dtdLocation ; } public FileSet createSupport ( ) { FileSet supportFileSet = new FileSet ( ) ; config . supportFileSets . add ( supportFileSet ) ; return supportFileSet ; } public void setManifest ( File manifest ) { config . manifest = manifest ; } public void setSrcdir ( File inDir ) { config . srcDir = inDir ; } public void setDescriptordir ( File inDir ) { config . descriptorDir = inDir ; } public void setDependency ( String analyzer ) { config . analyzer = analyzer ; } public void setBasejarname ( String inValue ) { config . baseJarName = inValue ; if ( config . namingScheme == null ) { config . namingScheme = new NamingScheme ( ) ; config . namingScheme . setValue ( NamingScheme . BASEJARNAME ) ; } else if ( ! config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) ) { throw new BuildException ( "The basejarname attribute is not " + "compatible with the " + config . namingScheme . getValue ( ) + " naming scheme" ) ; } } public void setNaming ( NamingScheme namingScheme ) { config . namingScheme = namingScheme ; if ( ! config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) && config . baseJarName != null ) { throw new BuildException ( "The basejarname attribute is not " + "compatible with the " + config . namingScheme . getValue ( ) + " naming scheme" ) ; } } public File getDestdir ( ) { return this . destDir ; } public void setDestdir ( File inDir ) { this . destDir = inDir ; } public String getCmpversion ( ) { return this . cmpVersion ; } public void setCmpversion ( CMPVersion version ) { this . cmpVersion = version . getValue ( ) ; } public void setClasspath ( Path classpath ) { config . classpath = classpath ; } public void setFlatdestdir ( boolean inValue ) { config . flatDestDir = inValue ; } public void setGenericjarsuffix ( String inString ) { this . genericJarSuffix = inString ; } public void setBasenameterminator ( String inValue ) { config . baseNameTerminator = inValue ; } private void validateConfig ( ) throws BuildException { if ( config . srcDir == null ) { throw new BuildException ( "The srcDir attribute must be specified" ) ; } if ( config . descriptorDir == null ) { config . descriptorDir = config . srcDir ; } if ( config . namingScheme == null ) { config . namingScheme = new NamingScheme ( ) ; config . namingScheme . setValue ( NamingScheme . DESCRIPTOR ) ; } else if ( config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) && config . baseJarName == null ) { throw new BuildException ( "The basejarname attribute must " + "be specified with the basejarname naming scheme" ) ; } } public void execute ( ) throws BuildException { validateConfig ( ) ; if ( deploymentTools . size ( ) == 0 ) { GenericDeploymentTool genericTool = new GenericDeploymentTool ( ) ; genericTool . setTask ( this ) ; genericTool . setDestdir ( destDir ) ; genericTool . setGenericJarSuffix ( genericJarSuffix ) ; deploymentTools . add ( genericTool ) ; } for ( Iterator i = deploymentTools . iterator ( ) ; i . hasNext ( ) ; ) { EJBDeploymentTool tool = ( EJBDeploymentTool ) i . next ( ) ; tool . configure ( config ) ; tool . validateConfigured ( ) ; } try { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; saxParserFactory . setValidating ( true ) ; SAXParser saxParser = saxParserFactory . newSAXParser ( ) ; DirectoryScanner ds = getDirectoryScanner ( config . descriptorDir ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; log ( files . length + " deployment descriptors located." , Project . MSG_VERBOSE ) ; for ( int index = 0 ; index < files . length ; ++ index ) { for ( Iterator i = deploymentTools . iterator ( ) ; i . hasNext ( ) ; ) { EJBDeploymentTool tool = ( EJBDeploymentTool ) i . next ( ) ; tool . processDescriptor ( files [ index ] , saxParser ) ; } } } catch ( SAXException se ) { String msg = "SAXException while creating parser." + "  Details: " + se . getMessage ( ) ; throw new BuildException ( msg , se ) ; } catch ( ParserConfigurationException pce ) { String msg = "ParserConfigurationException while creating parser. " + "Details: " + pce . getMessage ( ) ; throw new BuildException ( msg , pce ) ; } } } 	0	['28', '4', '0', '20', '78', '142', '1', '20', '26', '0.785185185', '503', '1', '1', '0.742857143', '0.183035714', '2', '2', '16.78571429', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . jdepend ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteWatchdog ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class JDependTask extends Task { private Path sourcesPath ; private Path classesPath ; private File outputFile ; private File dir ; private Path compileClasspath ; private boolean haltonerror = false ; private boolean fork = false ; private Long timeout = null ; private String jvm = null ; private String format = "text" ; private PatternSet defaultPatterns = new PatternSet ( ) ; private static Constructor packageFilterC ; private static Method setFilter ; private boolean includeRuntime = false ; private Path runtimeClasses = null ; static { try { Class packageFilter = Class . forName ( "jdepend.framework.PackageFilter" ) ; packageFilterC = packageFilter . getConstructor ( new Class [ ] { java . util . Collection . class } ) ; setFilter = jdepend . textui . JDepend . class . getDeclaredMethod ( "setFilter" , new Class [ ] { packageFilter } ) ; } catch ( Throwable t ) { if ( setFilter == null ) { packageFilterC = null ; } } } public void setIncluderuntime ( boolean b ) { includeRuntime = b ; } public void setTimeout ( Long value ) { timeout = value ; } public Long getTimeout ( ) { return timeout ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } public File getOutputFile ( ) { return outputFile ; } public void setHaltonerror ( boolean haltonerror ) { this . haltonerror = haltonerror ; } public boolean getHaltonerror ( ) { return haltonerror ; } public void setFork ( boolean value ) { fork = value ; } public boolean getFork ( ) { return fork ; } public void setJvm ( String value ) { jvm = value ; } public Path createSourcespath ( ) { if ( sourcesPath == null ) { sourcesPath = new Path ( getProject ( ) ) ; } return sourcesPath . createPath ( ) ; } public Path getSourcespath ( ) { return sourcesPath ; } public Path createClassespath ( ) { if ( classesPath == null ) { classesPath = new Path ( getProject ( ) ) ; } return classesPath . createPath ( ) ; } public Path getClassespath ( ) { return classesPath ; } public void setDir ( File dir ) { this . dir = dir ; } public File getDir ( ) { return dir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public Commandline . Argument createJvmarg ( CommandlineJava commandline ) { return commandline . createVmArgument ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public PatternSet . NameEntry createExclude ( ) { return defaultPatterns . createExclude ( ) ; } public PatternSet getExcludes ( ) { return defaultPatterns ; } public void setFormat ( FormatAttribute ea ) { format = ea . getValue ( ) ; } public static class FormatAttribute extends EnumeratedAttribute { private String [ ] formats = new String [ ] { "xml" , "text" } ; public String [ ] getValues ( ) { return formats ; } } private static final int SUCCESS = 0 ; private static final int ERRORS = 1 ; private void addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/jdepend/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; runtimeClasses . createPath ( ) . setLocation ( f ) ; } else { log ( "Couldn\'t find " + resource , Project . MSG_DEBUG ) ; } } public void execute ( ) throws BuildException { CommandlineJava commandline = new CommandlineJava ( ) ; if ( "text" . equals ( format ) ) { commandline . setClassname ( "jdepend.textui.JDepend" ) ; } else if ( "xml" . equals ( format ) ) { commandline . setClassname ( "jdepend.xmlui.JDepend" ) ; } if ( jvm != null ) { commandline . setVm ( jvm ) ; } if ( getSourcespath ( ) == null && getClassespath ( ) == null ) { throw new BuildException ( "Missing classespath required argument" ) ; } else if ( getClassespath ( ) == null ) { String msg = "sourcespath is deprecated in JDepend >= 2.5 " + "- please convert to classespath" ; log ( msg ) ; } int exitValue = JDependTask . ERRORS ; boolean wasKilled = false ; if ( ! getFork ( ) ) { exitValue = executeInVM ( commandline ) ; } else { ExecuteWatchdog watchdog = createWatchdog ( ) ; exitValue = executeAsForked ( commandline , watchdog ) ; if ( watchdog != null ) { wasKilled = watchdog . killedProcess ( ) ; } } boolean errorOccurred = exitValue == JDependTask . ERRORS || wasKilled ; if ( errorOccurred ) { String errorMessage = "JDepend FAILED" + ( wasKilled ? " - Timed out" : "" ) ; if ( getHaltonerror ( ) ) { throw new BuildException ( errorMessage , getLocation ( ) ) ; } else { log ( errorMessage , Project . MSG_ERR ) ; } } } public int executeInVM ( CommandlineJava commandline ) throws BuildException { jdepend . textui . JDepend jdepend ; if ( "xml" . equals ( format ) ) { jdepend = new jdepend . xmlui . JDepend ( ) ; } else { jdepend = new jdepend . textui . JDepend ( ) ; } FileWriter fw = null ; if ( getOutputFile ( ) != null ) { try { fw = new FileWriter ( getOutputFile ( ) . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when creating the output file: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } jdepend . setWriter ( new PrintWriter ( fw ) ) ; log ( "Output to be stored in " + getOutputFile ( ) . getPath ( ) ) ; } try { if ( getClassespath ( ) != null ) { String [ ] cP = getClassespath ( ) . list ( ) ; for ( int i = 0 ; i < cP . length ; i ++ ) { File f = new File ( cP [ i ] ) ; if ( ! f . exists ( ) ) { String msg = "\"" + f . getPath ( ) + "\" does not represent a valid" + " file or directory. JDepend would fail." ; log ( msg ) ; throw new BuildException ( msg ) ; } try { jdepend . addDirectory ( f . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when adding a class directory: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } } } else if ( getSourcespath ( ) != null ) { String [ ] sP = getSourcespath ( ) . list ( ) ; for ( int i = 0 ; i < sP . length ; i ++ ) { File f = new File ( sP [ i ] ) ; if ( ! f . exists ( ) || ! f . isDirectory ( ) ) { String msg = "\"" + f . getPath ( ) + "\" does not represent a valid" + " directory. JDepend would fail." ; log ( msg ) ; throw new BuildException ( msg ) ; } try { jdepend . addDirectory ( f . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when adding a source directory: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } } } String [ ] patterns = defaultPatterns . getExcludePatterns ( getProject ( ) ) ; if ( patterns != null && patterns . length > 0 ) { if ( setFilter != null ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < patterns . length ; i ++ ) { v . addElement ( patterns [ i ] ) ; } try { Object o = packageFilterC . newInstance ( new Object [ ] { v } ) ; setFilter . invoke ( jdepend , new Object [ ] { o } ) ; } catch ( Throwable e ) { log ( "excludes will be ignored as JDepend doesn't like me: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } else { log ( "Sorry, your version of JDepend doesn't support excludes" , Project . MSG_WARN ) ; } } jdepend . analyze ( ) ; } finally { FileUtils . close ( fw ) ; } return SUCCESS ; } public int executeAsForked ( CommandlineJava commandline , ExecuteWatchdog watchdog ) throws BuildException { runtimeClasses = new Path ( getProject ( ) ) ; addClasspathEntry ( "/jdepend/textui/JDepend.class" ) ; createClasspath ( ) ; if ( getClasspath ( ) . toString ( ) . length ( ) > 0 ) { createJvmarg ( commandline ) . setValue ( "-classpath" ) ; createJvmarg ( commandline ) . setValue ( getClasspath ( ) . toString ( ) ) ; } if ( includeRuntime ) { Vector v = Execute . getProcEnvironment ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { String s = ( String ) e . nextElement ( ) ; if ( s . startsWith ( "CLASSPATH=" ) ) { commandline . createClasspath ( getProject ( ) ) . createPath ( ) . append ( new Path ( getProject ( ) , s . substring ( "CLASSPATH=" . length ( ) ) ) ) ; } } log ( "Implicitly adding " + runtimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; commandline . createClasspath ( getProject ( ) ) . createPath ( ) . append ( runtimeClasses ) ; } if ( getOutputFile ( ) != null ) { commandline . createArgument ( ) . setValue ( "-file" ) ; commandline . createArgument ( ) . setValue ( outputFile . getPath ( ) ) ; } if ( getSourcespath ( ) != null ) { String [ ] sP = getSourcespath ( ) . list ( ) ; for ( int i = 0 ; i < sP . length ; i ++ ) { File f = new File ( sP [ i ] ) ; if ( ! f . exists ( ) || ! f . isDirectory ( ) ) { throw new BuildException ( "\"" + f . getPath ( ) + "\" does not represent a valid" + " directory. JDepend would" + " fail." ) ; } commandline . createArgument ( ) . setValue ( f . getPath ( ) ) ; } } if ( getClassespath ( ) != null ) { String [ ] cP = getClassespath ( ) . list ( ) ; for ( int i = 0 ; i < cP . length ; i ++ ) { File f = new File ( cP [ i ] ) ; if ( ! f . exists ( ) ) { throw new BuildException ( "\"" + f . getPath ( ) + "\" does not represent a valid" + " file or directory. JDepend would" + " fail." ) ; } commandline . createArgument ( ) . setValue ( f . getPath ( ) ) ; } } Execute execute = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , watchdog ) ; execute . setCommandline ( commandline . getCommandline ( ) ) ; if ( getDir ( ) != null ) { execute . setWorkingDirectory ( getDir ( ) ) ; execute . setAntRun ( getProject ( ) ) ; } if ( getOutputFile ( ) != null ) { log ( "Output to be stored in " + getOutputFile ( ) . getPath ( ) ) ; } log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { return execute . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Process fork failed." , e , getLocation ( ) ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( getTimeout ( ) == null ) { return null ; } return new ExecuteWatchdog ( getTimeout ( ) . longValue ( ) ) ; } } 	0	['31', '3', '0', '19', '107', '391', '0', '19', '28', '0.922807018', '977', '0.894736842', '5', '0.560606061', '0.15', '3', '3', '29.90322581', '3', '1.129', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . IOException ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . FileUtils ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( getJavac ( ) . getJavacExecutable ( ) ) ; if ( ! assumeJava11 ( ) && ! assumeJava12 ( ) ) { setupModernJavacCommandlineSwitches ( cmd ) ; } else { setupJavacCommandlineSwitches ( cmd , true ) ; } int firstFileName = assumeJava11 ( ) ? - 1 : cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; if ( Os . isFamily ( "openvms" ) ) { return execOnVMS ( cmd , firstFileName ) ; } return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) == 0 ; } private boolean execOnVMS ( Commandline cmd , int firstFileName ) { File vmsFile = null ; try { vmsFile = JavaEnvUtils . createVmsJavaOptionFile ( cmd . getArguments ( ) ) ; String [ ] commandLine = { cmd . getExecutable ( ) , "-V" , vmsFile . getPath ( ) } ; return 0 == executeExternalCompile ( commandLine , firstFileName , true ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to create a temporary file for \"-V\" switch" ) ; } finally { FileUtils . delete ( vmsFile ) ; } } } 	0	['3', '2', '0', '8', '24', '3', '1', '7', '2', '2', '116', '0', '0', '0.92', '0.555555556', '0', '0', '37.66666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . util . TeeOutputStream ; import org . apache . tools . ant . util . FileUtils ; public class ANTLR extends Task { private CommandlineJava commandline = new CommandlineJava ( ) ; private File targetFile ; private File outputDirectory ; private File superGrammar ; private boolean html ; private boolean diagnostic ; private boolean trace ; private boolean traceParser ; private boolean traceLexer ; private boolean traceTreeWalker ; private File workingdir = null ; private ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; private boolean debug ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public ANTLR ( ) { commandline . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; commandline . setClassname ( "antlr.Tool" ) ; } public void setTarget ( File target ) { log ( "Setting target to: " + target . toString ( ) , Project . MSG_VERBOSE ) ; this . targetFile = target ; } public void setOutputdirectory ( File outputDirectory ) { log ( "Setting output directory to: " + outputDirectory . toString ( ) , Project . MSG_VERBOSE ) ; this . outputDirectory = outputDirectory ; } public void setGlib ( String superGrammar ) { String sg = null ; if ( Os . isFamily ( "dos" ) ) { sg = superGrammar . replace ( '\\' , '/' ) ; } else { sg = superGrammar ; } setGlib ( FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , sg ) ) ; } public void setGlib ( File superGrammar ) { this . superGrammar = superGrammar ; } public void setDebug ( boolean enable ) { this . debug = enable ; } public void setHtml ( boolean enable ) { html = enable ; } public void setDiagnostic ( boolean enable ) { diagnostic = enable ; } public void setTrace ( boolean enable ) { trace = enable ; } public void setTraceParser ( boolean enable ) { traceParser = enable ; } public void setTraceLexer ( boolean enable ) { traceLexer = enable ; } public void setTraceTreeWalker ( boolean enable ) { traceTreeWalker = enable ; } public void setFork ( boolean s ) { } public void setDir ( File d ) { this . workingdir = d ; } public Path createClasspath ( ) { return commandline . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Commandline . Argument createJvmarg ( ) { return commandline . createVmArgument ( ) ; } public void init ( ) throws BuildException { addClasspathEntry ( "/antlr/ANTLRGrammarParseBehavior.class" ) ; } protected void addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; createClasspath ( ) . setLocation ( f ) ; } else { log ( "Couldn\'t find " + resource , Project . MSG_VERBOSE ) ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; File generatedFile = getGeneratedFile ( ) ; boolean targetIsOutOfDate = targetFile . lastModified ( ) > generatedFile . lastModified ( ) ; boolean superGrammarIsOutOfDate = superGrammar != null && ( superGrammar . lastModified ( ) > generatedFile . lastModified ( ) ) ; if ( targetIsOutOfDate || superGrammarIsOutOfDate ) { if ( targetIsOutOfDate ) { log ( "Compiling " + targetFile + " as it is newer than " + generatedFile , Project . MSG_VERBOSE ) ; } else if ( superGrammarIsOutOfDate ) { log ( "Compiling " + targetFile + " as " + superGrammar + " is newer than " + generatedFile , Project . MSG_VERBOSE ) ; } populateAttributes ( ) ; commandline . createArgument ( ) . setValue ( targetFile . toString ( ) ) ; log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; int err = run ( commandline . getCommandline ( ) ) ; if ( err != 0 ) { throw new BuildException ( "ANTLR returned: " + err , getLocation ( ) ) ; } else { String output = bos . toString ( ) ; if ( output . indexOf ( "error:" ) > - 1 ) { throw new BuildException ( "ANTLR signaled an error: " + output , getLocation ( ) ) ; } } } else { log ( "Skipped grammar file. Generated file " + generatedFile + " is newer." , Project . MSG_VERBOSE ) ; } } private void populateAttributes ( ) { commandline . createArgument ( ) . setValue ( "-o" ) ; commandline . createArgument ( ) . setValue ( outputDirectory . toString ( ) ) ; if ( superGrammar != null ) { commandline . createArgument ( ) . setValue ( "-glib" ) ; commandline . createArgument ( ) . setValue ( superGrammar . toString ( ) ) ; } if ( html ) { commandline . createArgument ( ) . setValue ( "-html" ) ; } if ( diagnostic ) { commandline . createArgument ( ) . setValue ( "-diagnostic" ) ; } if ( trace ) { commandline . createArgument ( ) . setValue ( "-trace" ) ; } if ( traceParser ) { commandline . createArgument ( ) . setValue ( "-traceParser" ) ; } if ( traceLexer ) { commandline . createArgument ( ) . setValue ( "-traceLexer" ) ; } if ( traceTreeWalker ) { if ( is272 ( ) ) { commandline . createArgument ( ) . setValue ( "-traceTreeParser" ) ; } else { commandline . createArgument ( ) . setValue ( "-traceTreeWalker" ) ; } } if ( debug ) { commandline . createArgument ( ) . setValue ( "-debug" ) ; } } private void validateAttributes ( ) throws BuildException { if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputDirectory == null ) { setOutputdirectory ( new File ( targetFile . getParent ( ) ) ) ; } if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "Invalid output directory: " + outputDirectory ) ; } } private File getGeneratedFile ( ) throws BuildException { String generatedFileName = null ; try { BufferedReader in = new BufferedReader ( new FileReader ( targetFile ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { int extendsIndex = line . indexOf ( " extends " ) ; if ( line . startsWith ( "class " ) && extendsIndex > - 1 ) { generatedFileName = line . substring ( 6 , extendsIndex ) . trim ( ) ; break ; } } in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Unable to determine generated class" , e ) ; } if ( generatedFileName == null ) { throw new BuildException ( "Unable to determine generated class" ) ; } return new File ( outputDirectory , generatedFileName + ( html ? ".html" : ".java" ) ) ; } private int run ( String [ ] command ) throws BuildException { PumpStreamHandler psh = new PumpStreamHandler ( new LogOutputStream ( this , Project . MSG_INFO ) , new TeeOutputStream ( new LogOutputStream ( this , Project . MSG_WARN ) , bos ) ) ; Execute exe = new Execute ( psh , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( workingdir != null ) { exe . setWorkingDirectory ( workingdir ) ; } exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( bos ) ; } } protected boolean is272 ( ) { AntClassLoader l = null ; try { l = getProject ( ) . createClassLoader ( commandline . getClasspath ( ) ) ; l . loadClass ( "antlr.Version" ) ; return true ; } catch ( ClassNotFoundException e ) { return false ; } finally { if ( l != null ) { l . cleanup ( ) ; } } } } 	0	['25', '3', '0', '18', '91', '218', '0', '18', '18', '0.889880952', '671', '1', '2', '0.616666667', '0.325', '1', '1', '25.28', '10', '1.56', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMklabel extends ClearCase { private boolean mReplace = false ; private boolean mRecurse = false ; private String mVersion = null ; private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKLABEL ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( getVersion ( ) != null ) { getVersionCommand ( cmd ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getTypeName ( ) != null ) { getTypeCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setRecurse ( boolean recurse ) { mRecurse = recurse ; } public boolean getRecurse ( ) { return mRecurse ; } public void setVersion ( String version ) { mVersion = version ; } public String getVersion ( ) { return mVersion ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } private void getVersionCommand ( Commandline cmd ) { if ( getVersion ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; cmd . createArgument ( ) . setValue ( getVersion ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getTypeCommand ( Commandline cmd ) { String typenm = null ; if ( getTypeName ( ) != null ) { typenm = getTypeName ( ) ; if ( getVOB ( ) != null ) { typenm += "@" + getVOB ( ) ; } cmd . createArgument ( ) . setValue ( typenm ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_RECURSE = "-recurse" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['21', '4', '0', '7', '45', '168', '0', '7', '16', '0.923076923', '302', '0.538461538', '0', '0.705882353', '0.392857143', '2', '3', '12.76190476', '7', '1.4762', '0']
package org . apache . tools . ant . util ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; public class UUEncoder { protected static final int DEFAULT_MODE = 644 ; private static final int MAX_CHARS_PER_LINE = 45 ; private OutputStream out ; private String name ; public UUEncoder ( String name ) { this . name = name ; } public void encode ( InputStream is , OutputStream out ) throws IOException { this . out = out ; encodeBegin ( ) ; byte [ ] buffer = new byte [ MAX_CHARS_PER_LINE * 100 ] ; int count ; while ( ( count = is . read ( buffer , 0 , buffer . length ) ) != - 1 ) { int pos = 0 ; while ( count > 0 ) { int num = count > MAX_CHARS_PER_LINE ? MAX_CHARS_PER_LINE : count ; encodeLine ( buffer , pos , num , out ) ; pos += num ; count -= num ; } } out . flush ( ) ; encodeEnd ( ) ; } private void encodeString ( String n ) throws IOException { PrintStream writer = new PrintStream ( out ) ; writer . print ( n ) ; writer . flush ( ) ; } private void encodeBegin ( ) throws IOException { encodeString ( "begin " + DEFAULT_MODE + " " + name + "\n" ) ; } private void encodeEnd ( ) throws IOException { encodeString ( " \nend\n" ) ; } private void encodeLine ( byte [ ] data , int offset , int length , OutputStream out ) throws IOException { out . write ( ( byte ) ( ( length & 0x3F ) + ' ' ) ) ; byte a ; byte b ; byte c ; for ( int i = 0 ; i < length ; ) { b = 1 ; c = 1 ; a = data [ offset + i ++ ] ; if ( i < length ) { b = data [ offset + i ++ ] ; if ( i < length ) { c = data [ offset + i ++ ] ; } } byte d1 = ( byte ) ( ( ( a > > > 2 ) & 0x3F ) + ' ' ) ; byte d2 = ( byte ) ( ( ( ( a << 4 ) & 0x30 ) | ( ( b > > > 4 ) & 0x0F ) ) + ' ' ) ; byte d3 = ( byte ) ( ( ( ( b << 2 ) & 0x3C ) | ( ( c > > > 6 ) & 0x3 ) ) + ' ' ) ; byte d4 = ( byte ) ( ( c & 0x3F ) + ' ' ) ; out . write ( d1 ) ; out . write ( d2 ) ; out . write ( d3 ) ; out . write ( d4 ) ; } out . write ( '\n' ) ; } } 	0	['6', '1', '0', '1', '16', '11', '1', '0', '2', '0.85', '202', '1', '0', '0', '0.361111111', '0', '0', '32', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Permissions perm = null ; private Method main = null ; private Long timeout = null ; private volatile Throwable caught = null ; private volatile boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } Class target = null ; try { if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = project . createClassLoader ( classpath ) ; loader . setParent ( project . getCoreLoader ( ) ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; loader . forceLoadClass ( classname ) ; target = Class . forName ( classname , true , loader ) ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } main = target . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( ( main . getModifiers ( ) & Modifier . STATIC ) == 0 ) { throw new BuildException ( "main() method in " + classname + " is not declared static" ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( BuildException e ) { throw e ; } catch ( SecurityException e ) { throw e ; } catch ( ThreadDeath e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; loader = null ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( perm != null ) { perm . setSecurityManager ( ) ; } main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public synchronized boolean killedProcess ( ) { return timedOut ; } public int fork ( ProjectComponent pc ) throws BuildException { CommandlineJava cmdl = new CommandlineJava ( ) ; cmdl . setClassname ( javaCommand . getExecutable ( ) ) ; String [ ] args = javaCommand . getArguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { cmdl . createArgument ( ) . setValue ( args [ i ] ) ; } if ( classpath != null ) { cmdl . createClasspath ( pc . getProject ( ) ) . append ( classpath ) ; } if ( sysProperties != null ) { cmdl . addSysproperties ( sysProperties ) ; } Redirector redirector = new Redirector ( pc ) ; Execute exe = new Execute ( redirector . createHandler ( ) , timeout == null ? null : new ExecuteWatchdog ( timeout . longValue ( ) ) ) ; exe . setAntRun ( pc . getProject ( ) ) ; if ( Os . isFamily ( "openvms" ) ) { setupCommandLineForVMS ( exe , cmdl . getCommandline ( ) ) ; } else { exe . setCommandline ( cmdl . getCommandline ( ) ) ; } try { int rc = exe . execute ( ) ; redirector . complete ( ) ; return rc ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { timedOut = exe . killedProcess ( ) ; } } public static void setupCommandLineForVMS ( Execute exe , String [ ] command ) { exe . setVMLauncher ( true ) ; File vmsJavaOptionFile = null ; try { String [ ] args = new String [ command . length - 1 ] ; System . arraycopy ( command , 1 , args , 0 , command . length - 1 ) ; vmsJavaOptionFile = JavaEnvUtils . createVmsJavaOptionFile ( args ) ; vmsJavaOptionFile . deleteOnExit ( ) ; String [ ] vmsCmd = { command [ 0 ] , "-V" , vmsJavaOptionFile . getPath ( ) } ; exe . setCommandline ( vmsCmd ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to create a temporary file for \"-V\" switch" ) ; } } } 	0	['13', '1', '0', '24', '82', '22', '5', '19', '13', '0.783333333', '552', '0.9', '4', '0', '0.147435897', '0', '0', '40.69230769', '6', '1.3846', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class ParserSupports extends ProjectComponent implements Condition { private String feature ; private String property ; private String value ; public static final String ERROR_BOTH_ATTRIBUTES = "Property and feature attributes are exclusive" ; public static final String FEATURE = "feature" ; public static final String PROPERTY = "property" ; public static final String NOT_RECOGNIZED = " not recognized: " ; public static final String NOT_SUPPORTED = " not supported: " ; public static final String ERROR_NO_ATTRIBUTES = "Neither feature or property are set" ; public static final String ERROR_NO_VALUE = "A value is needed when testing for property support" ; public void setFeature ( String feature ) { this . feature = feature ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public boolean eval ( ) throws BuildException { if ( feature != null && property != null ) { throw new BuildException ( ERROR_BOTH_ATTRIBUTES ) ; } if ( feature == null && property == null ) { throw new BuildException ( ERROR_NO_ATTRIBUTES ) ; } if ( feature != null ) { return evalFeature ( ) ; } if ( value == null ) { throw new BuildException ( ERROR_NO_VALUE ) ; } return evalProperty ( ) ; } private XMLReader getReader ( ) { JAXPUtils . getParser ( ) ; return JAXPUtils . getXMLReader ( ) ; } public boolean evalFeature ( ) { XMLReader reader = getReader ( ) ; if ( value == null ) { value = "true" ; } boolean v = Project . toBoolean ( value ) ; try { reader . setFeature ( feature , v ) ; } catch ( SAXNotRecognizedException e ) { log ( FEATURE + NOT_RECOGNIZED + feature , Project . MSG_VERBOSE ) ; return false ; } catch ( SAXNotSupportedException e ) { log ( FEATURE + NOT_SUPPORTED + feature , Project . MSG_VERBOSE ) ; return false ; } return true ; } public boolean evalProperty ( ) { XMLReader reader = getReader ( ) ; try { reader . setProperty ( property , value ) ; } catch ( SAXNotRecognizedException e ) { log ( PROPERTY + NOT_RECOGNIZED + property , Project . MSG_VERBOSE ) ; return false ; } catch ( SAXNotSupportedException e ) { log ( PROPERTY + NOT_SUPPORTED + property , Project . MSG_VERBOSE ) ; return false ; } return true ; } } 	0	['8', '2', '0', '5', '19', '8', '0', '5', '7', '1', '165', '0.3', '0', '0.5625', '0.6875', '0', '0', '18.375', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSCheckin extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKIN_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKIN_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; if ( getComment ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMENT ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; } return commandLine ; } } 	0	['5', '4', '0', '3', '17', '10', '0', '3', '4', '2', '87', '0', '0', '0.948717949', '0.533333333', '1', '2', '16.4', '3', '1.2', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public interface Algorithm { boolean isValid ( ) ; String getValue ( File file ) ; } 	0	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . bcel . classfile . ConstantClass ; import org . apache . bcel . classfile . ConstantPool ; import org . apache . bcel . classfile . EmptyVisitor ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . classfile . ConstantNameAndType ; public class DependencyVisitor extends EmptyVisitor { private Hashtable dependencies = new Hashtable ( ) ; private ConstantPool constantPool ; public Enumeration getDependencies ( ) { return dependencies . keys ( ) ; } public void clearDependencies ( ) { dependencies . clear ( ) ; } public void visitConstantPool ( ConstantPool constantPool ) { this . constantPool = constantPool ; } public void visitConstantClass ( ConstantClass constantClass ) { String classname = constantClass . getConstantValue ( constantPool ) . toString ( ) ; addSlashClass ( classname ) ; } public void visitConstantNameAndType ( ConstantNameAndType obj ) { String name = obj . getName ( constantPool ) ; if ( obj . getSignature ( constantPool ) . equals ( "Ljava/lang/Class;" ) && name . startsWith ( "class$" ) ) { String classname = name . substring ( 6 ) . replace ( '$' , '.' ) ; int index = classname . lastIndexOf ( "." ) ; if ( index > 0 ) { char start ; int index2 = classname . lastIndexOf ( "." , index - 1 ) ; if ( index2 != - 1 ) { start = classname . charAt ( index2 + 1 ) ; } else { start = classname . charAt ( 0 ) ; } if ( ( start > 0x40 ) && ( start < 0x5B ) ) { classname = classname . substring ( 0 , index ) + "$" + classname . substring ( index + 1 ) ; addClass ( classname ) ; } else { addClass ( classname ) ; } } else { addClass ( classname ) ; } } } public void visitField ( Field field ) { addClasses ( field . getSignature ( ) ) ; } public void visitJavaClass ( JavaClass javaClass ) { addClass ( javaClass . getClassName ( ) ) ; } public void visitMethod ( Method method ) { String signature = method . getSignature ( ) ; int pos = signature . indexOf ( ")" ) ; addClasses ( signature . substring ( 1 , pos ) ) ; addClasses ( signature . substring ( pos + 1 ) ) ; } void addClass ( String classname ) { dependencies . put ( classname , classname ) ; } private void addClasses ( String string ) { StringTokenizer tokens = new StringTokenizer ( string , ";" ) ; while ( tokens . hasMoreTokens ( ) ) { String descriptor = tokens . nextToken ( ) ; int pos = descriptor . indexOf ( 'L' ) ; if ( pos != - 1 ) { addSlashClass ( descriptor . substring ( pos + 1 ) ) ; } } } private void addSlashClass ( String classname ) { addClass ( classname . replace ( '/' , '.' ) ) ; } } 	0	['12', '2', '0', '8', '41', '48', '1', '7', '9', '0.636363636', '203', '1', '0', '0.744186047', '0.21875', '1', '1', '15.75', '7', '1.5833', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitutions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '40', '10', '0', '2', '8', '0.714285714', '281', '1', '0', '0.840909091', '0.325', '1', '1', '33.625', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class NameAndTypeCPInfo extends ConstantPoolEntry { public NameAndTypeCPInfo ( ) { super ( CONSTANT_NAMEANDTYPE , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { nameIndex = cpStream . readUnsignedShort ( ) ; descriptorIndex = cpStream . readUnsignedShort ( ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Name = " + name + ", type = " + type ; } else { value = "Name index = " + nameIndex + ", descriptor index = " + descriptorIndex ; } return value ; } public void resolve ( ConstantPool constantPool ) { name = ( ( Utf8CPInfo ) constantPool . getEntry ( nameIndex ) ) . getValue ( ) ; type = ( ( Utf8CPInfo ) constantPool . getEntry ( descriptorIndex ) ) . getValue ( ) ; super . resolve ( constantPool ) ; } public String getName ( ) { return name ; } public String getType ( ) { return type ; } private String name ; private String type ; private int nameIndex ; private int descriptorIndex ; } 	0	['6', '2', '0', '6', '16', '1', '5', '3', '6', '0.6', '84', '1', '0', '0.545454545', '0.444444444', '1', '1', '12.33333333', '2', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . zip . Checksum ; import java . util . zip . CRC32 ; import java . util . zip . Adler32 ; import java . util . zip . CheckedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . security . NoSuchAlgorithmException ; import org . apache . tools . ant . BuildException ; public class ChecksumAlgorithm implements Algorithm { private String algorithm = "CRC" ; private Checksum checksum = null ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void initChecksum ( ) { if ( checksum != null ) { return ; } if ( "CRC" . equalsIgnoreCase ( algorithm ) ) { checksum = new CRC32 ( ) ; } else if ( "ADLER" . equalsIgnoreCase ( algorithm ) ) { checksum = new Adler32 ( ) ; } else { throw new BuildException ( new NoSuchAlgorithmException ( ) ) ; } } public boolean isValid ( ) { return "CRC" . equalsIgnoreCase ( algorithm ) || "ADLER" . equalsIgnoreCase ( algorithm ) ; } public String getValue ( File file ) { initChecksum ( ) ; String rval = null ; try { if ( file . canRead ( ) ) { checksum . reset ( ) ; FileInputStream fis = new FileInputStream ( file ) ; CheckedInputStream check = new CheckedInputStream ( fis , checksum ) ; BufferedInputStream in = new BufferedInputStream ( check ) ; while ( in . read ( ) != - 1 ) { } rval = Long . toString ( check . getChecksum ( ) . getValue ( ) ) ; in . close ( ) ; } } catch ( Exception e ) { rval = null ; } return rval ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<ChecksumAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['6', '1', '0', '3', '25', '0', '1', '2', '6', '0.3', '135', '1', '0', '0', '0.444444444', '0', '0', '21.16666667', '4', '2', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '4', '19', '0', '1', '3', '2', '0.75', '101', '0.5', '0', '0', '0.666666667', '0', '0', '32', '1', '0.6667', '0']
package org . apache . tools . ant . types ; public class DTDLocation extends ResourceLocation { } 	0	['1', '2', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Sync extends P4Base { String label ; private String syncCmd = "" ; public void setLabel ( String label ) throws BuildException { if ( label == null || label . equals ( "" ) ) { throw new BuildException ( "P4Sync: Labels cannot be Null or Empty" ) ; } this . label = label ; } public void setForce ( String force ) throws BuildException { if ( force == null && ! label . equals ( "" ) ) { throw new BuildException ( "P4Sync: If you want to force, set force to non-null string!" ) ; } P4CmdOpts = "-f" ; } public void execute ( ) throws BuildException { if ( P4View != null ) { syncCmd = P4View ; } if ( label != null && ! label . equals ( "" ) ) { syncCmd = syncCmd + "@" + label ; } log ( "Execing sync " + P4CmdOpts + " " + syncCmd , Project . MSG_VERBOSE ) ; execP4Command ( "-s sync " + P4CmdOpts + " " + syncCmd , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['4', '4', '0', '4', '14', '0', '0', '4', '4', '0.5', '108', '0.5', '0', '0.944444444', '0.75', '3', '3', '25.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  " + "Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , getLocation ( ) ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , getLocation ( ) ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '0.666666667', '147', '1', '0', '0.925', '0.75', '1', '1', '35.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . types . Commandline ; public class KaffeRmic extends DefaultRmicAdapter { private static final String [ ] RMIC_CLASSNAMES = new String [ ] { "gnu.classpath.tools.rmi.rmic.RMIC" , "gnu.java.rmi.rmic.RMIC" , "kaffe.rmi.rmic.RMIC" , } ; public static final String COMPILER_NAME = "kaffe" ; public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; Class c = getRmicClass ( ) ; if ( c == null ) { StringBuffer buf = new StringBuffer ( "Cannot use Kaffe rmic, as it" + " is not available.  None" + " of " ) ; for ( int i = 0 ; i < RMIC_CLASSNAMES . length ; i ++ ) { if ( i != 0 ) { buf . append ( ", " ) ; } buf . append ( RMIC_CLASSNAMES [ i ] ) ; } buf . append ( " have been found. A common solution is to set the" + " environment variable JAVA_HOME or CLASSPATH." ) ; throw new BuildException ( buf . toString ( ) , getRmic ( ) . getLocation ( ) ) ; } cmd . setExecutable ( c . getName ( ) ) ; if ( ! c . getName ( ) . equals ( RMIC_CLASSNAMES [ RMIC_CLASSNAMES . length - 1 ] ) ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; getRmic ( ) . log ( Commandline . describeCommand ( cmd ) ) ; } ExecuteJava ej = new ExecuteJava ( ) ; ej . setJavaCommand ( cmd ) ; return ej . fork ( getRmic ( ) ) == 0 ; } public static boolean isAvailable ( ) { return getRmicClass ( ) != null ; } private static Class getRmicClass ( ) { for ( int i = 0 ; i < RMIC_CLASSNAMES . length ; i ++ ) { try { return Class . forName ( RMIC_CLASSNAMES [ i ] ) ; } catch ( ClassNotFoundException cnfe ) { } } return null ; } } 	0	['5', '2', '0', '9', '25', '4', '1', '8', '3', '0.75', '137', '0.5', '0', '0.8125', '0.5', '0', '0', '26', '2', '1', '0']
package org . apache . tools . ant . input ; public class InputRequest { private String prompt ; private String input ; private String defaultValue ; public InputRequest ( String prompt ) { if ( prompt == null ) { throw new IllegalArgumentException ( "prompt must not be null" ) ; } this . prompt = prompt ; } public String getPrompt ( ) { return prompt ; } public void setInput ( String input ) { this . input = input ; } public boolean isInputValid ( ) { return true ; } public String getInput ( ) { return input ; } public String getDefaultValue ( ) { return defaultValue ; } public void setDefaultValue ( String d ) { defaultValue = d ; } } 	0	['7', '1', '1', '6', '9', '15', '6', '0', '7', '0.833333333', '42', '1', '0', '0', '0.714285714', '0', '0', '4.571428571', '1', '0.8571', '0']
package org . apache . tools . ant ; public class UnsupportedAttributeException extends BuildException { private String attribute ; public UnsupportedAttributeException ( String msg , String attribute ) { super ( msg ) ; this . attribute = attribute ; } public String getAttribute ( ) { return attribute ; } } 	0	['2', '5', '0', '4', '3', '0', '3', '1', '2', '0', '13', '1', '0', '0.954545455', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . taskdefs . condition . IsSigned ; public class SignedSelector extends DataType implements FileSelector { private IsSigned isSigned = new IsSigned ( ) ; public void setName ( String name ) { isSigned . setName ( name ) ; } public boolean isSelected ( File basedir , String filename , File file ) { if ( file . isDirectory ( ) ) { return false ; } isSigned . setProject ( getProject ( ) ) ; isSigned . setFile ( file ) ; return isSigned . eval ( ) ; } } 	0	['3', '3', '0', '4', '11', '0', '0', '4', '3', '0', '35', '1', '1', '0.9375', '0.666666667', '0', '0', '10.33333333', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class PrefixLines extends BaseParamFilterReader implements ChainableReader { private static final String PREFIX_KEY = "prefix" ; private String prefix = null ; private String queuedData = null ; public PrefixLines ( ) { super ( ) ; } public PrefixLines ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readLine ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { if ( prefix != null ) { queuedData = prefix + queuedData ; } return read ( ) ; } } return ch ; } public void setPrefix ( final String prefix ) { this . prefix = prefix ; } private String getPrefix ( ) { return prefix ; } public Reader chain ( final Reader rdr ) { PrefixLines newFilter = new PrefixLines ( rdr ) ; newFilter . setPrefix ( getPrefix ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( PREFIX_KEY . equals ( params [ i ] . getName ( ) ) ) { prefix = params [ i ] . getValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '4', '23', '0', '1', '3', '5', '0.555555556', '150', '1', '0', '0.848484848', '0.476190476', '2', '5', '20', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; public class Patch extends Task { private File originalFile ; private File directory ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setDestfile ( File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void setDir ( File directory ) { this . directory = directory ; } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , getLocation ( ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; if ( directory != null ) { if ( directory . exists ( ) && directory . isDirectory ( ) ) { exe . setWorkingDirectory ( directory ) ; } else if ( ! directory . isDirectory ( ) ) { throw new BuildException ( directory + " is not a directory." , getLocation ( ) ) ; } else { throw new BuildException ( "directory " + directory + " doesn\'t exist" , getLocation ( ) ) ; } } else { exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } } 	0	['11', '3', '0', '10', '39', '0', '0', '10', '11', '0.7', '247', '1', '1', '0.787234043', '0.454545455', '1', '1', '21.09090909', '2', '1.4545', '0']
package org . apache . tools . ant . types . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . selectors . BaseSelector ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; public class ScriptSelector extends BaseSelector { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner ; private File basedir ; private String filename ; private File file ; private boolean selected ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } private void init ( ) throws BuildException { if ( runner != null ) { return ; } runner = helper . getScriptRunner ( ) ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } public void setSetBeans ( boolean setBeans ) { helper . setSetBeans ( setBeans ) ; } public boolean isSelected ( File basedir , String filename , File file ) { init ( ) ; setSelected ( true ) ; this . file = file ; this . basedir = basedir ; this . filename = filename ; runner . addBean ( "basedir" , basedir ) ; runner . addBean ( "filename" , filename ) ; runner . addBean ( "file" , file ) ; runner . executeScript ( "ant_selector" ) ; return isSelected ( ) ; } public File getBasedir ( ) { return basedir ; } public String getFilename ( ) { return filename ; } public File getFile ( ) { return file ; } public boolean isSelected ( ) { return selected ; } public void setSelected ( boolean selected ) { this . selected = selected ; } } 	0	['17', '4', '0', '8', '32', '16', '0', '8', '16', '0.822916667', '140', '1', '2', '0.68627451', '0.235294118', '1', '1', '6.882352941', '1', '0.9412', '0']
package org . apache . tools . ant . taskdefs . email ; public class EmailAddress { private String name ; private String address ; public EmailAddress ( ) { } public EmailAddress ( String email ) { final int minLen = 9 ; int len = email . length ( ) ; if ( len > minLen ) { if ( ( email . charAt ( 0 ) == '<' || email . charAt ( 1 ) == '<' ) && ( email . charAt ( len - 1 ) == '>' || email . charAt ( len - 2 ) == '>' ) ) { this . address = trim ( email , true ) ; return ; } } int paramDepth = 0 ; int start = 0 ; int end = 0 ; int nStart = 0 ; int nEnd = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = email . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; nStart = i + 1 ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; nEnd = i ; } } else if ( paramDepth == 0 && c == '<' ) { if ( start == 0 ) { nEnd = i ; } start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; if ( end != len - 1 ) { nStart = i + 1 ; } } } if ( end == 0 ) { end = len ; } if ( nEnd == 0 ) { nEnd = len ; } this . address = trim ( email . substring ( start , end ) , true ) ; this . name = trim ( email . substring ( nStart , nEnd ) , false ) ; if ( this . name . length ( ) + this . address . length ( ) > len ) { this . name = null ; } } private String trim ( String t , boolean trimAngleBrackets ) { int start = 0 ; int end = t . length ( ) ; boolean trim = false ; do { trim = false ; if ( t . charAt ( end - 1 ) == ')' || ( t . charAt ( end - 1 ) == '>' && trimAngleBrackets ) || ( t . charAt ( end - 1 ) == '"' && t . charAt ( end - 2 ) != '\\' ) || t . charAt ( end - 1 ) <= ' ' ) { trim = true ; end -- ; } if ( t . charAt ( start ) == '(' || ( t . charAt ( start ) == '<' && trimAngleBrackets ) || t . charAt ( start ) == '"' || t . charAt ( start ) <= ' ' ) { trim = true ; start ++ ; } } while ( trim ) ; return t . substring ( start , end ) ; } public void setName ( String name ) { this . name = name ; } public void setAddress ( String address ) { this . address = address ; } public String toString ( ) { if ( name == null ) { return address ; } else { return name + " <" + address + ">" ; } } public String getAddress ( ) { return address ; } public String getName ( ) { return name ; } } 	0	['8', '1', '0', '5', '16', '6', '5', '0', '7', '0.571428571', '284', '1', '0', '0', '0.541666667', '0', '0', '34.25', '13', '2.375', '0']
package org . apache . tools . ant . types ; import java . lang . reflect . Method ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; private Path catalogPath ; public static final String APACHE_RESOLVER = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver" ; public static final String CATALOG_RESOLVER = "org.apache.xml.resolver.tools.CatalogResolver" ; public XMLCatalog ( ) { setChecked ( false ) ; } private Vector getElements ( ) { return getRef ( ) . elements ; } private Path getClasspath ( ) { return getRef ( ) . classpath ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } setChecked ( false ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path createCatalogPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . catalogPath == null ) { this . catalogPath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . catalogPath . createPath ( ) ; } public void setCatalogPathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createCatalogPath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path getCatalogPath ( ) { return getRef ( ) . catalogPath ; } public void addDTD ( ResourceLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; setChecked ( false ) ; } public void addEntity ( ResourceLocation entity ) throws BuildException { addDTD ( entity ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration e = newElements . elements ( ) ; while ( e . hasMoreElements ( ) ) { ourElements . addElement ( e . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; Path nestedCatalogPath = catalog . getCatalogPath ( ) ; createCatalogPath ( ) . append ( nestedCatalogPath ) ; setChecked ( false ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( isReference ( ) ) { return getRef ( ) . resolveEntity ( publicId , systemId ) ; } dieOnCircularReference ( ) ; log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = getCatalogResolver ( ) . resolveEntity ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( isReference ( ) ) { return getRef ( ) . resolve ( href , base ) ; } dieOnCircularReference ( ) ; SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = ( SAXSource ) getCatalogResolver ( ) . resolve ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; URL baseURL = null ; try { if ( base == null ) { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } else { baseURL = new URL ( base ) ; } URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private XMLCatalog getRef ( ) { if ( ! isReference ( ) ) { return this ; } return ( XMLCatalog ) getCheckedRef ( XMLCatalog . class , "xmlcatalog" ) ; } private CatalogResolver catalogResolver = null ; private CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { AntClassLoader loader = null ; loader = getProject ( ) . createClassLoader ( Path . systemClasspath ) ; try { Class clazz = Class . forName ( APACHE_RESOLVER , true , loader ) ; ClassLoader apacheResolverLoader = clazz . getClassLoader ( ) ; Class baseResolverClass = Class . forName ( CATALOG_RESOLVER , true , apacheResolverLoader ) ; ClassLoader baseResolverLoader = baseResolverClass . getClassLoader ( ) ; clazz = Class . forName ( APACHE_RESOLVER , true , baseResolverLoader ) ; Object obj = clazz . newInstance ( ) ; catalogResolver = new ExternalResolver ( clazz , obj ) ; } catch ( Throwable ex ) { catalogResolver = new InternalResolver ( ) ; if ( getCatalogPath ( ) != null && getCatalogPath ( ) . list ( ) . length != 0 ) { log ( "Warning: XML resolver not found; external catalogs" + " will be ignored" , Project . MSG_WARN ) ; } log ( "Failed to load Apache resolver: " + ex , Project . MSG_DEBUG ) ; } } return catalogResolver ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private ResourceLocation findMatchingEntry ( String publicId ) { Enumeration e = getElements ( ) . elements ( ) ; ResourceLocation element = null ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof ResourceLocation ) { element = ( ResourceLocation ) o ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } } return null ; } private String removeFragment ( String uri ) { String result = uri ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; } return result ; } private InputSource filesystemLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; uri = uri . replace ( File . separatorChar , '/' ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { File testFile = new File ( uri ) ; if ( testFile . exists ( ) && testFile . canRead ( ) ) { log ( "uri : '" + uri + "' matches a readable file" , Project . MSG_DEBUG ) ; try { url = FILE_UTILS . getFileURL ( testFile ) ; } catch ( MalformedURLException ex1 ) { throw new BuildException ( "could not find an URL for :" + testFile . getAbsolutePath ( ) ) ; } } else { log ( "uri : '" + uri + "' does not match a readable file" , Project . MSG_DEBUG ) ; } } if ( url != null && url . getProtocol ( ) . equals ( "file" ) ) { String fileName = FILE_UTILS . fromURI ( url . toString ( ) ) ; if ( fileName != null ) { log ( "fileName " + fileName , Project . MSG_DEBUG ) ; File resFile = new File ( fileName ) ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; String sysid = JAXPUtils . getSystemId ( resFile ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( IOException ex ) { } } } } return source ; } private InputSource classpathLookup ( ResourceLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; Path cp = classpath ; if ( cp != null ) { cp = classpath . concatSystemClasspath ( "ignore" ) ; } else { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } loader = getProject ( ) . createClassLoader ( cp ) ; InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private interface CatalogResolver extends URIResolver , EntityResolver { InputSource resolveEntity ( String publicId , String systemId ) ; Source resolve ( String href , String base ) throws TransformerException ; } private class InternalResolver implements CatalogResolver { public InternalResolver ( ) { log ( "Apache resolver library not found, internal resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source == null ) { source = urlLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } private class ExternalResolver implements CatalogResolver { private Method setXMLCatalog = null ; private Method parseCatalog = null ; private Method resolveEntity = null ; private Method resolve = null ; private Object resolverImpl = null ; private boolean externalCatalogsProcessed = false ; public ExternalResolver ( Class resolverImplClass , Object resolverImpl ) { this . resolverImpl = resolverImpl ; try { setXMLCatalog = resolverImplClass . getMethod ( "setXMLCatalog" , new Class [ ] { XMLCatalog . class } ) ; parseCatalog = resolverImplClass . getMethod ( "parseCatalog" , new Class [ ] { String . class } ) ; resolveEntity = resolverImplClass . getMethod ( "resolveEntity" , new Class [ ] { String . class , String . class } ) ; resolve = resolverImplClass . getMethod ( "resolve" , new Class [ ] { String . class , String . class } ) ; } catch ( NoSuchMethodException ex ) { throw new BuildException ( ex ) ; } log ( "Apache resolver library found, xml-commons resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } private void processExternalCatalogs ( ) { if ( ! externalCatalogsProcessed ) { try { setXMLCatalog . invoke ( resolverImpl , new Object [ ] { XMLCatalog . this } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } Path catPath = getCatalogPath ( ) ; if ( catPath != null ) { log ( "Using catalogpath '" + getCatalogPath ( ) + "'" , Project . MSG_DEBUG ) ; String [ ] catPathList = getCatalogPath ( ) . list ( ) ; for ( int i = 0 ; i < catPathList . length ; i ++ ) { File catFile = new File ( catPathList [ i ] ) ; log ( "Parsing " + catFile , Project . MSG_DEBUG ) ; try { parseCatalog . invoke ( resolverImpl , new Object [ ] { catFile . getPath ( ) } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } } externalCatalogsProcessed = true ; } } } 	0	['28', '3', '0', '17', '105', '344', '7', '12', '13', '0.864197531', '874', '0.555555556', '4', '0.535714286', '0.243386243', '1', '1', '29.89285714', '9', '2.0714', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Native2AsciiAdapterFactory { public static String getDefault ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { return KaffeNative2Ascii . IMPLEMENTATION_NAME ; } return SunNative2Ascii . IMPLEMENTATION_NAME ; } public static Native2AsciiAdapter getAdapter ( String choice , ProjectComponent log ) throws BuildException { if ( ( JavaEnvUtils . isKaffe ( ) && choice == null ) || KaffeNative2Ascii . IMPLEMENTATION_NAME . equals ( choice ) ) { return new KaffeNative2Ascii ( ) ; } else if ( SunNative2Ascii . IMPLEMENTATION_NAME . equals ( choice ) ) { return new SunNative2Ascii ( ) ; } else if ( choice != null ) { return resolveClassName ( choice ) ; } return new SunNative2Ascii ( ) ; } private static Native2AsciiAdapter resolveClassName ( String className ) throws BuildException { return ( Native2AsciiAdapter ) ClasspathUtils . newInstance ( className , Native2AsciiAdapterFactory . class . getClassLoader ( ) , Native2AsciiAdapter . class ) ; } } 	0	['4', '1', '0', '8', '14', '6', '1', '7', '3', '0.666666667', '79', '0', '0', '0', '0.333333333', '0', '0', '18.25', '2', '1', '0']
package org . apache . tools . bzip2 ; final class CRC { static final int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } void updateCRC ( int inCh , int repeat ) { int globalCrcShadow = this . globalCrc ; while ( repeat -- > 0 ) { int temp = ( globalCrcShadow > > 24 ) ^ inCh ; globalCrcShadow = ( globalCrcShadow << 8 ) ^ crc32Table [ ( temp >= 0 ) ? temp : ( temp + 256 ) ] ; } this . globalCrc = globalCrcShadow ; } int globalCrc ; } 	0	['8', '1', '0', '2', '9', '0', '2', '0', '0', '0.428571429', '1107', '0', '0', '0', '0.714285714', '0', '0', '137.125', '3', '1.125', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Apt ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . File ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; public class AptCompilerAdapter extends DefaultCompilerAdapter { private static final int APT_COMPILER_SUCCESS = 0 ; public static final String APT_ENTRY_POINT = "com.sun.tools.apt.Main" ; public static final String APT_METHOD_NAME = "process" ; protected Apt getApt ( ) { return ( Apt ) getJavac ( ) ; } static void setAptCommandlineSwitches ( Apt apt , Commandline cmd ) { if ( ! apt . isCompile ( ) ) { cmd . createArgument ( ) . setValue ( "-nocompile" ) ; } String factory = apt . getFactory ( ) ; if ( factory != null ) { cmd . createArgument ( ) . setValue ( "-factory" ) ; cmd . createArgument ( ) . setValue ( factory ) ; } Path factoryPath = apt . getFactoryPath ( ) ; if ( factoryPath != null ) { cmd . createArgument ( ) . setValue ( "-factorypath" ) ; cmd . createArgument ( ) . setPath ( factoryPath ) ; } File preprocessDir = apt . getPreprocessDir ( ) ; if ( preprocessDir != null ) { cmd . createArgument ( ) . setValue ( "-s" ) ; cmd . createArgument ( ) . setFile ( preprocessDir ) ; } Vector options = apt . getOptions ( ) ; Enumeration elements = options . elements ( ) ; Apt . Option opt ; StringBuffer arg = null ; while ( elements . hasMoreElements ( ) ) { opt = ( Apt . Option ) elements . nextElement ( ) ; arg = new StringBuffer ( ) ; arg . append ( "-A" ) . append ( opt . getName ( ) ) ; if ( opt . getValue ( ) != null ) { arg . append ( "=" ) . append ( opt . getValue ( ) ) ; } cmd . createArgument ( ) . setValue ( arg . toString ( ) ) ; } } protected void setAptCommandlineSwitches ( Commandline cmd ) { Apt apt = getApt ( ) ; setAptCommandlineSwitches ( apt , cmd ) ; } public boolean execute ( ) throws BuildException { attributes . log ( "Using apt compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; setAptCommandlineSwitches ( cmd ) ; try { Class c = Class . forName ( APT_ENTRY_POINT ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( APT_METHOD_NAME , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == APT_COMPILER_SUCCESS ) ; } catch ( BuildException be ) { throw be ; } catch ( Exception ex ) { throw new BuildException ( "Error starting apt compiler" , ex , location ) ; } } } 	0	['5', '2', '0', '10', '34', '10', '1', '9', '2', '1.25', '171', '0.333333333', '0', '0.851851852', '0.466666667', '0', '0', '32.6', '7', '2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class GZip extends Pack { protected void pack ( ) { GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; zipResource ( getSrcResource ( ) , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( zOut ) ; } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( GZip . class ) ; } } 	0	['3', '4', '0', '5', '20', '3', '0', '5', '1', '1', '71', '0', '0', '0.961538462', '1', '2', '4', '22.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs . cvslib ; public class CvsTagEntry { private String filename ; private String prevRevision ; private String revision ; public CvsTagEntry ( final String filename ) { this ( filename , null , null ) ; } public CvsTagEntry ( final String filename , final String revision ) { this ( filename , revision , null ) ; } public CvsTagEntry ( final String filename , final String revision , final String prevRevision ) { this . filename = filename ; this . revision = revision ; this . prevRevision = prevRevision ; } public String getFile ( ) { return filename ; } public String getRevision ( ) { return revision ; } public String getPreviousRevision ( ) { return prevRevision ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( filename ) ; if ( ( revision == null ) ) { buffer . append ( " was removed" ) ; if ( prevRevision != null ) { buffer . append ( "; previous revision was " ) . append ( prevRevision ) ; } } else if ( revision != null && prevRevision == null ) { buffer . append ( " is new; current revision is " ) . append ( revision ) ; } else if ( revision != null && prevRevision != null ) { buffer . append ( " has changed from " ) . append ( prevRevision ) . append ( " to " ) . append ( revision ) ; } return buffer . toString ( ) ; } } 	0	['7', '1', '0', '1', '11', '7', '1', '0', '7', '0.333333333', '105', '1', '0', '0', '0.714285714', '0', '0', '13.57142857', '7', '1.4286', '0']
package org . apache . tools . ant . util ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collections ; import org . apache . tools . ant . types . Mapper ; public abstract class ContainerMapper implements FileNameMapper { private List mappers = new ArrayList ( ) ; public void addConfiguredMapper ( Mapper mapper ) { add ( mapper . getImplementation ( ) ) ; } public void addConfigured ( FileNameMapper fileNameMapper ) { add ( fileNameMapper ) ; } public synchronized void add ( FileNameMapper fileNameMapper ) { if ( this == fileNameMapper || ( fileNameMapper instanceof ContainerMapper && ( ( ContainerMapper ) fileNameMapper ) . contains ( this ) ) ) { throw new IllegalArgumentException ( "Circular mapper containment condition detected" ) ; } else { mappers . add ( fileNameMapper ) ; } } protected synchronized boolean contains ( FileNameMapper fileNameMapper ) { boolean foundit = false ; for ( Iterator iter = mappers . iterator ( ) ; iter . hasNext ( ) && ! foundit ; ) { FileNameMapper next = ( FileNameMapper ) ( iter . next ( ) ) ; foundit |= ( next == fileNameMapper || ( next instanceof ContainerMapper && ( ( ContainerMapper ) next ) . contains ( fileNameMapper ) ) ) ; } return foundit ; } public synchronized List getMappers ( ) { return Collections . unmodifiableList ( mappers ) ; } public void setFrom ( String ignore ) { } public void setTo ( String ignore ) { } } 	0	['8', '1', '2', '4', '17', '16', '3', '2', '7', '0.285714286', '89', '1', '0', '0', '0.4375', '0', '0', '10', '6', '1.875', '0']
package org . apache . tools . ant . util ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . apache . tools . ant . DynamicElementNS ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . DynamicConfiguratorNS ; public class XMLFragment extends ProjectComponent implements DynamicElementNS { private Document doc ; private DocumentFragment fragment ; public XMLFragment ( ) { doc = JAXPUtils . getDocumentBuilder ( ) . newDocument ( ) ; fragment = doc . createDocumentFragment ( ) ; } public DocumentFragment getFragment ( ) { return fragment ; } public void addText ( String s ) { addText ( fragment , s ) ; } public Object createDynamicElement ( String uri , String name , String qName ) { Element e = null ; if ( uri . equals ( "" ) ) { e = doc . createElement ( name ) ; } else { e = doc . createElementNS ( uri , qName ) ; } fragment . appendChild ( e ) ; return new Child ( e ) ; } private void addText ( Node n , String s ) { s = getProject ( ) . replaceProperties ( s ) ; if ( s != null && ! s . trim ( ) . equals ( "" ) ) { Text t = doc . createTextNode ( s . trim ( ) ) ; n . appendChild ( t ) ; } } public class Child implements DynamicConfiguratorNS { private Element e ; Child ( Element e ) { this . e = e ; } public void addText ( String s ) { XMLFragment . this . addText ( e , s ) ; } public void setDynamicAttribute ( String uri , String name , String qName , String value ) { if ( uri . equals ( "" ) ) { e . setAttribute ( name , value ) ; } else { e . setAttributeNS ( uri , qName , value ) ; } } public Object createDynamicElement ( String uri , String name , String qName ) { Element e2 = null ; if ( uri . equals ( "" ) ) { e2 = doc . createElement ( name ) ; } else { e2 = doc . createElementNS ( uri , qName ) ; } e . appendChild ( e2 ) ; return new Child ( e2 ) ; } } } 	0	['7', '2', '1', '6', '21', '0', '2', '5', '4', '0.333333333', '90', '1', '0', '0.6', '0.464285714', '0', '0', '11.57142857', '3', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import java . text . NumberFormat ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; public class SummaryJUnitResultFormatter implements JUnitResultFormatter , JUnitTaskMirror . SummaryJUnitResultFormatterMirror { private NumberFormat nf = NumberFormat . getInstance ( ) ; private OutputStream out ; private boolean withOutAndErr = false ; private String systemOutput = null ; private String systemError = null ; public SummaryJUnitResultFormatter ( ) { } public void startTestSuite ( JUnitTest suite ) { String newLine = System . getProperty ( "line.separator" ) ; StringBuffer sb = new StringBuffer ( "Running " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( newLine ) ; try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write summary output" , ioex ) ; } } public void startTest ( Test t ) { } public void endTest ( Test test ) { } public void addFailure ( Test test , Throwable t ) { } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void setWithOutAndErr ( boolean value ) { withOutAndErr = value ; } public void endTestSuite ( JUnitTest suite ) throws BuildException { String newLine = System . getProperty ( "line.separator" ) ; StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( nf . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( newLine ) ; if ( withOutAndErr ) { if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "Output:" ) . append ( newLine ) . append ( systemOutput ) . append ( newLine ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "Error: " ) . append ( newLine ) . append ( systemError ) . append ( newLine ) ; } } try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write summary output" , ioex ) ; } finally { if ( out != System . out && out != System . err ) { try { out . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['12', '1', '1', '8', '31', '46', '2', '6', '12', '0.836363636', '223', '1', '0', '0', '0.270833333', '0', '0', '17.16666667', '1', '0.9167', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class FileResourceIterator implements Iterator { private File basedir ; private String [ ] files ; private int pos = 0 ; public FileResourceIterator ( ) { } public FileResourceIterator ( File f ) { basedir = f ; } public FileResourceIterator ( File f , String [ ] s ) { this ( f ) ; addFiles ( s ) ; } public void addFiles ( String [ ] s ) { int start = ( files == null ) ? 0 : files . length ; String [ ] newfiles = new String [ start + s . length ] ; if ( start > 0 ) { System . arraycopy ( files , 0 , newfiles , 0 , start ) ; } files = newfiles ; System . arraycopy ( s , 0 , files , start , s . length ) ; } public boolean hasNext ( ) { return pos < files . length ; } public Object next ( ) { return nextResource ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public FileResource nextResource ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return new FileResource ( basedir , files [ pos ++ ] ) ; } } 	0	['8', '1', '0', '9', '13', '12', '8', '1', '8', '0.428571429', '109', '1', '0', '0', '0.5', '0', '0', '12.25', '3', '1.125', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '14', '1', '0', '13', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class AndSelector extends BaseSelectorContainer { public AndSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{andselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; } } 	0	['3', '5', '0', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . Perl5Substitution ; import org . apache . oro . text . regex . Substitution ; import org . apache . oro . text . regex . Util ; import org . apache . tools . ant . BuildException ; public class JakartaOroRegexp extends JakartaOroMatcher implements Regexp { public JakartaOroRegexp ( ) { super ( ) ; } public String substitute ( String input , String argument , int options ) throws BuildException { StringBuffer subst = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '$' ) { subst . append ( '\\' ) ; subst . append ( '$' ) ; } else if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { subst . append ( "$" ) . append ( value ) ; } else { subst . append ( c ) ; } } else { subst . append ( '\\' ) ; } } else { subst . append ( c ) ; } } Substitution s = new Perl5Substitution ( subst . toString ( ) , Perl5Substitution . INTERPOLATE_ALL ) ; return Util . substitute ( matcher , getCompiledPattern ( options ) , s , input , getSubsOptions ( options ) ) ; } protected int getSubsOptions ( int options ) { boolean replaceAll = RegexpUtil . hasFlag ( options , REPLACE_ALL ) ; int subsOptions = 1 ; if ( replaceAll ) { subsOptions = Util . SUBSTITUTE_ALL ; } return subsOptions ; } } 	0	['3', '2', '0', '10', '16', '3', '0', '10', '2', '2', '105', '0', '0', '0.8', '0.666666667', '0', '0', '34', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { void setJavac ( Javac attributes ) ; boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class DotnetCompile extends DotnetBaseMatchingTask { private String references ; private boolean includeDefaultReferences = true ; private File win32icon ; private File win32res ; private boolean failOnError ; private Path referenceFiles ; private boolean optimize ; protected Vector definitionList = new Vector ( ) ; protected Vector resources = new Vector ( ) ; protected String executable ; protected static final String REFERENCE_OPTION = "/reference:" ; protected boolean debug ; private int warnLevel ; protected String mainClass ; protected String extraOptions ; protected String targetType ; protected boolean utf8output = false ; protected String additionalModules ; protected Vector referenceFilesets = new Vector ( ) ; private boolean useResponseFile = false ; private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64 ; public DotnetCompile ( ) { clear ( ) ; setIncludes ( getFilePattern ( ) ) ; } public void clear ( ) { targetType = null ; win32icon = null ; srcDir = null ; mainClass = null ; warnLevel = 3 ; optimize = false ; debug = true ; references = null ; failOnError = true ; additionalModules = null ; includeDefaultReferences = true ; extraOptions = null ; } public void setReferences ( String s ) { references = s ; } protected String getReferencesParameter ( ) { if ( notEmpty ( references ) ) { if ( isWindows ) { return '\"' + REFERENCE_OPTION + references + '\"' ; } else { return REFERENCE_OPTION + references ; } } else { return null ; } } public void setReferenceFiles ( Path path ) { if ( referenceFiles == null ) { referenceFiles = new Path ( this . getProject ( ) ) ; } referenceFiles . append ( path ) ; } public void addReference ( FileSet reference ) { referenceFilesets . add ( reference ) ; } protected String getReferenceFilesParameter ( ) { if ( references == null ) { return null ; } if ( references . length ( ) == 0 ) { return null ; } StringBuffer s = new StringBuffer ( REFERENCE_OPTION ) ; if ( isWindows ) { s . append ( '\"' ) ; } s . append ( references ) ; if ( isWindows ) { s . append ( '\"' ) ; } return s . toString ( ) ; } public void setIncludeDefaultReferences ( boolean f ) { includeDefaultReferences = f ; } public boolean getIncludeDefaultReferences ( ) { return includeDefaultReferences ; } protected String getIncludeDefaultReferencesParameter ( ) { return "/nostdlib" + ( includeDefaultReferences ? "-" : "+" ) ; } public void setOptimize ( boolean f ) { optimize = f ; } public boolean getOptimize ( ) { return optimize ; } protected String getOptimizeParameter ( ) { return "/optimize" + ( optimize ? "+" : "-" ) ; } public void setDebug ( boolean f ) { debug = f ; } public boolean getDebug ( ) { return debug ; } protected String getDebugParameter ( ) { return "/debug" + ( debug ? "+" : "-" ) ; } public void setWarnLevel ( int warnLevel ) { this . warnLevel = warnLevel ; } public int getWarnLevel ( ) { return warnLevel ; } protected String getWarnLevelParameter ( ) { return "/warn:" + warnLevel ; } public void setMainClass ( String mainClass ) { this . mainClass = mainClass ; } public String getMainClass ( ) { return this . mainClass ; } protected String getMainClassParameter ( ) { if ( mainClass != null && mainClass . length ( ) != 0 ) { return "/main:" + mainClass ; } else { return null ; } } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public String getExtraOptions ( ) { return this . extraOptions ; } protected String getExtraOptionsParameter ( ) { if ( extraOptions != null && extraOptions . length ( ) != 0 ) { return extraOptions ; } else { return null ; } } protected String [ ] getExtraOptionsParameters ( ) { String extra = getExtraOptionsParameter ( ) ; return extra == null ? null : Commandline . translateCommandline ( extra ) ; } public void setDestDir ( File dirName ) { log ( "DestDir currently unused" , Project . MSG_WARN ) ; } public void setTargetType ( TargetTypes targetType ) { this . targetType = targetType . getValue ( ) ; } public void setTargetType ( String ttype ) throws BuildException { ttype = ttype . toLowerCase ( ) ; if ( ttype . equals ( "exe" ) || ttype . equals ( "library" ) || ttype . equals ( "module" ) || ttype . equals ( "winexe" ) ) { targetType = ttype ; } else { throw new BuildException ( "targetType " + ttype + " is not one of 'exe', 'module', 'winexe' or 'library'" ) ; } } public String getTargetType ( ) { return targetType ; } protected String getTargetTypeParameter ( ) { if ( notEmpty ( targetType ) ) { return "/target:" + targetType ; } else { return null ; } } public void setWin32Icon ( File fileName ) { win32icon = fileName ; } protected String getWin32IconParameter ( ) { if ( win32icon != null ) { return "/win32icon:" + win32icon . toString ( ) ; } else { return null ; } } public void setWin32Res ( File fileName ) { win32res = fileName ; } public File getWin32Res ( ) { return win32res ; } protected String getWin32ResParameter ( ) { if ( win32res != null ) { return "/win32res:" + win32res . toString ( ) ; } else { return null ; } } public void setUtf8Output ( boolean enabled ) { utf8output = enabled ; } protected String getUtf8OutputParameter ( ) { return utf8output ? "/utf8output" : null ; } public void addDefine ( DotnetDefine define ) { definitionList . addElement ( define ) ; } protected String getDefinitionsParameter ( ) throws BuildException { StringBuffer defines = new StringBuffer ( ) ; Enumeration defEnum = definitionList . elements ( ) ; boolean firstDefinition = true ; while ( defEnum . hasMoreElements ( ) ) { DotnetDefine define = ( DotnetDefine ) defEnum . nextElement ( ) ; if ( define . isSet ( this ) ) { if ( ! firstDefinition ) { defines . append ( getDefinitionsDelimiter ( ) ) ; } defines . append ( define . getValue ( this ) ) ; firstDefinition = false ; } } if ( defines . length ( ) == 0 ) { return null ; } else { return "/d:" + defines ; } } public void setAdditionalModules ( String params ) { additionalModules = params ; } protected String getAdditionalModulesParameter ( ) { if ( notEmpty ( additionalModules ) ) { return "/addmodule:" + additionalModules ; } else { return null ; } } protected String getDestFileParameter ( ) { if ( outputFile != null ) { return "/out:" + outputFile . toString ( ) ; } else { return null ; } } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailOnError ( ) { return failOnError ; } public void addResource ( DotnetResource resource ) { resources . add ( resource ) ; } protected String getExecutable ( ) { return executable ; } public void setExecutable ( String executable ) { this . executable = executable ; } protected boolean notEmpty ( String s ) { return s != null && s . length ( ) != 0 ; } protected void validate ( ) throws BuildException { if ( outputFile != null && outputFile . isDirectory ( ) ) { throw new BuildException ( "destFile cannot be a directory" ) ; } if ( getExecutable ( ) == null ) { throw new BuildException ( "There is no executable defined for this task" ) ; } } public String getFilePattern ( ) { return "**/*." + getFileExtension ( ) ; } public boolean isUseResponseFile ( ) { return useResponseFile ; } public void setUseResponseFile ( boolean useResponseFile ) { this . useResponseFile = useResponseFile ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; NetCommand command = createNetCommand ( ) ; command . setAutomaticResponseFileThreshold ( AUTOMATIC_RESPONSE_FILE_THRESHOLD ) ; command . setUseResponseFile ( useResponseFile ) ; fillInSharedParameters ( command ) ; addResources ( command ) ; addCompilerSpecificOptions ( command ) ; int referencesOutOfDate = addReferenceFilesets ( command , getOutputFileTimestamp ( ) ) ; boolean forceBuild = referencesOutOfDate > 0 ; addFilesAndExecute ( command , forceBuild ) ; } public abstract String getReferenceDelimiter ( ) ; public abstract String getFileExtension ( ) ; protected void fillInSharedParameters ( NetCommand command ) { command . setFailOnError ( getFailOnError ( ) ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( getAdditionalModulesParameter ( ) ) ; command . addArgument ( getDebugParameter ( ) ) ; command . addArgument ( getDefinitionsParameter ( ) ) ; command . addArguments ( getExtraOptionsParameters ( ) ) ; command . addArgument ( getMainClassParameter ( ) ) ; command . addArgument ( getOptimizeParameter ( ) ) ; command . addArgument ( getDestFileParameter ( ) ) ; command . addArgument ( getReferencesParameter ( ) ) ; command . addArgument ( getTargetTypeParameter ( ) ) ; command . addArgument ( getUtf8OutputParameter ( ) ) ; command . addArgument ( getWin32IconParameter ( ) ) ; command . addArgument ( getWin32ResParameter ( ) ) ; } protected void addResources ( NetCommand command ) { Enumeration e = resources . elements ( ) ; while ( e . hasMoreElements ( ) ) { DotnetResource resource = ( DotnetResource ) e . nextElement ( ) ; createResourceParameter ( command , resource ) ; } } protected abstract void createResourceParameter ( NetCommand command , DotnetResource resource ) ; protected int addReferenceFilesets ( NetCommand command , long outputTimestamp ) { int filesOutOfDate = 0 ; Hashtable filesToBuild = new Hashtable ( ) ; for ( int i = 0 ; i < referenceFilesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) referenceFilesets . elementAt ( i ) ; filesOutOfDate += command . scanOneFileset ( fs . getDirectoryScanner ( getProject ( ) ) , filesToBuild , outputTimestamp ) ; } if ( filesToBuild . size ( ) == 0 ) { return 0 ; } Enumeration files = filesToBuild . elements ( ) ; while ( files . hasMoreElements ( ) ) { File file = ( File ) files . nextElement ( ) ; if ( isFileManagedBinary ( file ) ) { if ( isWindows ) { command . addArgument ( '"' + REFERENCE_OPTION + file . toString ( ) + '"' ) ; } else { command . addArgument ( REFERENCE_OPTION + file . toString ( ) ) ; } } else { log ( "ignoring " + file + " as it is not a managed executable" , Project . MSG_VERBOSE ) ; } } return filesOutOfDate ; } protected NetCommand createNetCommand ( ) { NetCommand command = new NetCommand ( this , getTaskName ( ) , getExecutable ( ) ) ; return command ; } protected abstract void addCompilerSpecificOptions ( NetCommand command ) ; public String getDefinitionsDelimiter ( ) { return ";" ; } protected static boolean isFileManagedBinary ( File file ) { String filename = file . toString ( ) . toLowerCase ( ) ; return filename . endsWith ( ".exe" ) || filename . endsWith ( ".dll" ) || filename . endsWith ( ".netmodule" ) ; } public static class TargetTypes extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "exe" , "library" , "module" , "winexe" } ; } } } 	0	['64', '5', '3', '15', '111', '1836', '3', '12', '38', '0.945578231', '888', '1', '1', '0.58', '0.12109375', '2', '3', '12.546875', '6', '1.4844', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . NumberFormat ; import java . util . Hashtable ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class PlainJUnitResultFormatter implements JUnitResultFormatter { private NumberFormat nf = NumberFormat . getInstance ( ) ; private Hashtable testStarts = new Hashtable ( ) ; private OutputStream out ; private StringWriter inner ; private PrintWriter wri ; private Hashtable failed = new Hashtable ( ) ; private String systemOutput = null ; private String systemError = null ; public PlainJUnitResultFormatter ( ) { inner = new StringWriter ( ) ; wri = new PrintWriter ( inner ) ; } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void startTestSuite ( JUnitTest suite ) throws BuildException { if ( out == null ) { return ; } StringBuffer sb = new StringBuffer ( "Testsuite: " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( StringUtils . LINE_SEP ) ; try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to write output" , ex ) ; } } public void endTestSuite ( JUnitTest suite ) throws BuildException { StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( nf . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "------------- Standard Output ---------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemOutput ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "------------- Standard Error -----------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemError ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } sb . append ( StringUtils . LINE_SEP ) ; if ( out != null ) { try { out . write ( sb . toString ( ) . getBytes ( ) ) ; wri . close ( ) ; out . write ( inner . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write output" , ioex ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( out ) ; } } } } public void startTest ( Test t ) { testStarts . put ( t , new Long ( System . currentTimeMillis ( ) ) ) ; failed . put ( t , Boolean . FALSE ) ; } public void endTest ( Test test ) { if ( Boolean . TRUE . equals ( failed . get ( test ) ) ) { return ; } synchronized ( wri ) { wri . print ( "Testcase: " + JUnitVersionHelper . getTestCaseName ( test ) ) ; Long l = ( Long ) testStarts . get ( test ) ; double seconds = 0 ; if ( l != null ) { seconds = ( System . currentTimeMillis ( ) - l . longValue ( ) ) / 1000.0 ; } wri . println ( " took " + nf . format ( seconds ) + " sec" ) ; } } public void addFailure ( Test test , Throwable t ) { formatError ( "\tFAILED" , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { formatError ( "\tCaused an ERROR" , test , t ) ; } private void formatError ( String type , Test test , Throwable t ) { synchronized ( wri ) { if ( test != null ) { endTest ( test ) ; failed . put ( test , Boolean . TRUE ) ; } wri . println ( type ) ; wri . println ( t . getMessage ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( t ) ; wri . print ( strace ) ; wri . println ( "" ) ; } } } 	0	['12', '1', '0', '9', '46', '34', '0', '9', '11', '0.715909091', '386', '1', '0', '0', '0.333333333', '0', '0', '30.5', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Iterator i = nestedTasks . iterator ( ) ; i . hasNext ( ) ; ) { Task nestedTask = ( Task ) i . next ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class InterfaceMethodRefCPInfo extends ConstantPoolEntry { private String interfaceMethodClassName ; private String interfaceMethodName ; private String interfaceMethodType ; private int classIndex ; private int nameAndTypeIndex ; public InterfaceMethodRefCPInfo ( ) { super ( CONSTANT_INTERFACEMETHODREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo interfaceMethodClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; interfaceMethodClass . resolve ( constantPool ) ; interfaceMethodClassName = interfaceMethodClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; interfaceMethodName = nt . getName ( ) ; interfaceMethodType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "InterfaceMethod : Class = " + interfaceMethodClassName + ", name = " + interfaceMethodName + ", type = " + interfaceMethodType ; } else { value = "InterfaceMethod : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public String getInterfaceMethodClassName ( ) { return interfaceMethodClassName ; } public String getInterfaceMethodName ( ) { return interfaceMethodName ; } public String getInterfaceMethodType ( ) { return interfaceMethodType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant ; import java . io . File ; public interface FileScanner { void addDefaultExcludes ( ) ; File getBasedir ( ) ; String [ ] getExcludedDirectories ( ) ; String [ ] getExcludedFiles ( ) ; String [ ] getIncludedDirectories ( ) ; String [ ] getIncludedFiles ( ) ; String [ ] getNotIncludedDirectories ( ) ; String [ ] getNotIncludedFiles ( ) ; void scan ( ) throws IllegalStateException ; void setBasedir ( String basedir ) ; void setBasedir ( File basedir ) ; void setExcludes ( String [ ] excludes ) ; void setIncludes ( String [ ] includes ) ; void setCaseSensitive ( boolean isCaseSensitive ) ; } 	0	['14', '1', '0', '5', '14', '91', '5', '0', '14', '2', '14', '0', '0', '0', '0.271428571', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public interface EJBDeploymentTool { void processDescriptor ( String descriptorFilename , SAXParser saxParser ) throws BuildException ; void validateConfigured ( ) throws BuildException ; void setTask ( Task task ) ; void configure ( EjbJar . Config config ) ; } 	0	['4', '1', '0', '5', '4', '6', '2', '3', '4', '2', '4', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class JarLibManifestTask extends Task { private static final String MANIFEST_VERSION = "1.0" ; private static final String CREATED_BY = "Created-By" ; private File destFile ; private Extension extension ; private final ArrayList dependencies = new ArrayList ( ) ; private final ArrayList optionals = new ArrayList ( ) ; private final ArrayList extraAttributes = new ArrayList ( ) ; public void setDestfile ( final File destFile ) { this . destFile = destFile ; } public void addConfiguredExtension ( final ExtensionAdapter extensionAdapter ) throws BuildException { if ( null != extension ) { final String message = "Can not have multiple extensions defined in one library." ; throw new BuildException ( message ) ; } extension = extensionAdapter . toExtension ( ) ; } public void addConfiguredDepends ( final ExtensionSet extensionSet ) { dependencies . add ( extensionSet ) ; } public void addConfiguredOptions ( final ExtensionSet extensionSet ) { optionals . add ( extensionSet ) ; } public void addConfiguredAttribute ( final ExtraAttribute attribute ) { extraAttributes . add ( attribute ) ; } public void execute ( ) throws BuildException { validate ( ) ; final Manifest manifest = new Manifest ( ) ; final Attributes attributes = manifest . getMainAttributes ( ) ; attributes . put ( Attributes . Name . MANIFEST_VERSION , MANIFEST_VERSION ) ; final String createdBy = "Apache Ant " + getProject ( ) . getProperty ( MagicNames . ANT_VERSION ) ; attributes . putValue ( CREATED_BY , createdBy ) ; appendExtraAttributes ( attributes ) ; if ( null != extension ) { Extension . addExtension ( extension , attributes ) ; } final ArrayList depends = toExtensions ( dependencies ) ; appendExtensionList ( attributes , Extension . EXTENSION_LIST , "lib" , depends . size ( ) ) ; appendLibraryList ( attributes , "lib" , depends ) ; final ArrayList option = toExtensions ( optionals ) ; appendExtensionList ( attributes , Extension . OPTIONAL_EXTENSION_LIST , "opt" , option . size ( ) ) ; appendLibraryList ( attributes , "opt" , option ) ; try { final String message = "Generating manifest " + destFile . getAbsoluteFile ( ) ; log ( message , Project . MSG_INFO ) ; writeManifest ( manifest ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } } private void validate ( ) throws BuildException { if ( null == destFile ) { final String message = "Destfile attribute not specified." ; throw new BuildException ( message ) ; } if ( destFile . exists ( ) && ! destFile . isFile ( ) ) { final String message = destFile + " is not a file." ; throw new BuildException ( message ) ; } } private void appendExtraAttributes ( final Attributes attributes ) { final Iterator iterator = extraAttributes . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ExtraAttribute attribute = ( ExtraAttribute ) iterator . next ( ) ; attributes . putValue ( attribute . getName ( ) , attribute . getValue ( ) ) ; } } private void writeManifest ( final Manifest manifest ) throws IOException { FileOutputStream output = null ; try { output = new FileOutputStream ( destFile ) ; manifest . write ( output ) ; output . flush ( ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException e ) { } } } } private void appendLibraryList ( final Attributes attributes , final String listPrefix , final ArrayList extensions ) throws BuildException { final int size = extensions . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Extension ext = ( Extension ) extensions . get ( i ) ; final String prefix = listPrefix + i + "-" ; Extension . addExtension ( ext , prefix , attributes ) ; } } private void appendExtensionList ( final Attributes attributes , final Attributes . Name extensionKey , final String listPrefix , final int size ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( listPrefix ) ; sb . append ( i ) ; sb . append ( ' ' ) ; } attributes . put ( extensionKey , sb . toString ( ) ) ; } private ArrayList toExtensions ( final ArrayList extensionSets ) throws BuildException { final ArrayList results = new ArrayList ( ) ; final int size = extensionSets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionSet set = ( ExtensionSet ) extensionSets . get ( i ) ; final Extension [ ] extensions = set . toExtensions ( getProject ( ) ) ; for ( int j = 0 ; j < extensions . length ; j ++ ) { results . add ( extensions [ j ] ) ; } } return results ; } } 	0	['13', '3', '0', '7', '52', '48', '0', '7', '7', '0.892857143', '355', '1', '1', '0.755102041', '0.195804196', '1', '1', '25.76923077', '2', '1.0769', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . util . StringUtils ; public final class Extension { public static final Attributes . Name EXTENSION_LIST = new Attributes . Name ( "Extension-List" ) ; public static final Attributes . Name OPTIONAL_EXTENSION_LIST = new Attributes . Name ( "Optional-Extension-List" ) ; public static final Attributes . Name EXTENSION_NAME = new Attributes . Name ( "Extension-Name" ) ; public static final Attributes . Name SPECIFICATION_VERSION = Attributes . Name . SPECIFICATION_VERSION ; public static final Attributes . Name SPECIFICATION_VENDOR = Attributes . Name . SPECIFICATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_VERSION = Attributes . Name . IMPLEMENTATION_VERSION ; public static final Attributes . Name IMPLEMENTATION_VENDOR = Attributes . Name . IMPLEMENTATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_URL = new Attributes . Name ( "Implementation-URL" ) ; public static final Attributes . Name IMPLEMENTATION_VENDOR_ID = new Attributes . Name ( "Implementation-Vendor-Id" ) ; public static final Compatibility COMPATIBLE = new Compatibility ( "COMPATIBLE" ) ; public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE = new Compatibility ( "REQUIRE_SPECIFICATION_UPGRADE" ) ; public static final Compatibility REQUIRE_VENDOR_SWITCH = new Compatibility ( "REQUIRE_VENDOR_SWITCH" ) ; public static final Compatibility REQUIRE_IMPLEMENTATION_UPGRADE = new Compatibility ( "REQUIRE_IMPLEMENTATION_UPGRADE" ) ; public static final Compatibility INCOMPATIBLE = new Compatibility ( "INCOMPATIBLE" ) ; private String extensionName ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationVendorID ; private String implementationVendor ; private DeweyDecimal implementationVersion ; private String implementationURL ; public static Extension [ ] getAvailable ( final Manifest manifest ) { if ( null == manifest ) { return new Extension [ 0 ] ; } final ArrayList results = new ArrayList ( ) ; final Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( null != mainAttributes ) { final Extension extension = getExtension ( "" , mainAttributes ) ; if ( null != extension ) { results . add ( extension ) ; } } final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; final Extension extension = getExtension ( "" , attributes ) ; if ( null != extension ) { results . add ( extension ) ; } } return ( Extension [ ] ) results . toArray ( new Extension [ results . size ( ) ] ) ; } public static Extension [ ] getRequired ( final Manifest manifest ) { return getListed ( manifest , Attributes . Name . EXTENSION_LIST ) ; } public static Extension [ ] getOptions ( final Manifest manifest ) { return getListed ( manifest , OPTIONAL_EXTENSION_LIST ) ; } public static void addExtension ( final Extension extension , final Attributes attributes ) { addExtension ( extension , "" , attributes ) ; } public static void addExtension ( final Extension extension , final String prefix , final Attributes attributes ) { attributes . putValue ( prefix + EXTENSION_NAME , extension . getExtensionName ( ) ) ; final String specificationVendor = extension . getSpecificationVendor ( ) ; if ( null != specificationVendor ) { attributes . putValue ( prefix + SPECIFICATION_VENDOR , specificationVendor ) ; } final DeweyDecimal specificationVersion = extension . getSpecificationVersion ( ) ; if ( null != specificationVersion ) { attributes . putValue ( prefix + SPECIFICATION_VERSION , specificationVersion . toString ( ) ) ; } final String implementationVendorID = extension . getImplementationVendorID ( ) ; if ( null != implementationVendorID ) { attributes . putValue ( prefix + IMPLEMENTATION_VENDOR_ID , implementationVendorID ) ; } final String implementationVendor = extension . getImplementationVendor ( ) ; if ( null != implementationVendor ) { attributes . putValue ( prefix + IMPLEMENTATION_VENDOR , implementationVendor ) ; } final DeweyDecimal implementationVersion = extension . getImplementationVersion ( ) ; if ( null != implementationVersion ) { attributes . putValue ( prefix + IMPLEMENTATION_VERSION , implementationVersion . toString ( ) ) ; } final String implementationURL = extension . getImplementationURL ( ) ; if ( null != implementationURL ) { attributes . putValue ( prefix + IMPLEMENTATION_URL , implementationURL ) ; } } public Extension ( final String extensionName , final String specificationVersion , final String specificationVendor , final String implementationVersion , final String implementationVendor , final String implementationVendorId , final String implementationURL ) { this . extensionName = extensionName ; this . specificationVendor = specificationVendor ; if ( null != specificationVersion ) { try { this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad specification version format '" + specificationVersion + "' in '" + extensionName + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } this . implementationURL = implementationURL ; this . implementationVendor = implementationVendor ; this . implementationVendorID = implementationVendorId ; if ( null != implementationVersion ) { try { this . implementationVersion = new DeweyDecimal ( implementationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad implementation version format '" + implementationVersion + "' in '" + extensionName + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } if ( null == this . extensionName ) { throw new NullPointerException ( "extensionName property is null" ) ; } } public String getExtensionName ( ) { return extensionName ; } public String getSpecificationVendor ( ) { return specificationVendor ; } public DeweyDecimal getSpecificationVersion ( ) { return specificationVersion ; } public String getImplementationURL ( ) { return implementationURL ; } public String getImplementationVendor ( ) { return implementationVendor ; } public String getImplementationVendorID ( ) { return implementationVendorID ; } public DeweyDecimal getImplementationVersion ( ) { return implementationVersion ; } public Compatibility getCompatibilityWith ( final Extension required ) { if ( ! extensionName . equals ( required . getExtensionName ( ) ) ) { return INCOMPATIBLE ; } final DeweyDecimal requiredSpecificationVersion = required . getSpecificationVersion ( ) ; if ( null != requiredSpecificationVersion ) { if ( null == specificationVersion || ! isCompatible ( specificationVersion , requiredSpecificationVersion ) ) { return REQUIRE_SPECIFICATION_UPGRADE ; } } final String requiredImplementationVendorID = required . getImplementationVendorID ( ) ; if ( null != requiredImplementationVendorID ) { if ( null == implementationVendorID || ! implementationVendorID . equals ( requiredImplementationVendorID ) ) { return REQUIRE_VENDOR_SWITCH ; } } final DeweyDecimal requiredImplementationVersion = required . getImplementationVersion ( ) ; if ( null != requiredImplementationVersion ) { if ( null == implementationVersion || ! isCompatible ( implementationVersion , requiredImplementationVersion ) ) { return REQUIRE_IMPLEMENTATION_UPGRADE ; } } return COMPATIBLE ; } public boolean isCompatibleWith ( final Extension required ) { return ( COMPATIBLE == getCompatibilityWith ( required ) ) ; } public String toString ( ) { final String brace = ": " ; final StringBuffer sb = new StringBuffer ( EXTENSION_NAME . toString ( ) ) ; sb . append ( brace ) ; sb . append ( extensionName ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( null != specificationVersion ) { sb . append ( SPECIFICATION_VERSION ) ; sb . append ( brace ) ; sb . append ( specificationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != specificationVendor ) { sb . append ( SPECIFICATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( specificationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVersion ) { sb . append ( IMPLEMENTATION_VERSION ) ; sb . append ( brace ) ; sb . append ( implementationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendorID ) { sb . append ( IMPLEMENTATION_VENDOR_ID ) ; sb . append ( brace ) ; sb . append ( implementationVendorID ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendor ) { sb . append ( IMPLEMENTATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( implementationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationURL ) { sb . append ( IMPLEMENTATION_URL ) ; sb . append ( brace ) ; sb . append ( implementationURL ) ; sb . append ( StringUtils . LINE_SEP ) ; } return sb . toString ( ) ; } private boolean isCompatible ( final DeweyDecimal first , final DeweyDecimal second ) { return first . isGreaterThanOrEqual ( second ) ; } private static Extension [ ] getListed ( final Manifest manifest , final Attributes . Name listKey ) { final ArrayList results = new ArrayList ( ) ; final Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( null != mainAttributes ) { getExtension ( mainAttributes , results , listKey ) ; } final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; getExtension ( attributes , results , listKey ) ; } return ( Extension [ ] ) results . toArray ( new Extension [ results . size ( ) ] ) ; } private static void getExtension ( final Attributes attributes , final ArrayList required , final Attributes . Name listKey ) { final String names = attributes . getValue ( listKey ) ; if ( null == names ) { return ; } final String [ ] extentions = split ( names , " " ) ; for ( int i = 0 ; i < extentions . length ; i ++ ) { final String prefix = extentions [ i ] + "-" ; final Extension extension = getExtension ( prefix , attributes ) ; if ( null != extension ) { required . add ( extension ) ; } } } private static String [ ] split ( final String string , final String onToken ) { final StringTokenizer tokenizer = new StringTokenizer ( string , onToken ) ; final String [ ] result = new String [ tokenizer . countTokens ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = tokenizer . nextToken ( ) ; } return result ; } private static Extension getExtension ( final String prefix , final Attributes attributes ) { final String nameKey = prefix + EXTENSION_NAME ; final String name = getTrimmedString ( attributes . getValue ( nameKey ) ) ; if ( null == name ) { return null ; } final String specVendorKey = prefix + SPECIFICATION_VENDOR ; final String specVendor = getTrimmedString ( attributes . getValue ( specVendorKey ) ) ; final String specVersionKey = prefix + SPECIFICATION_VERSION ; final String specVersion = getTrimmedString ( attributes . getValue ( specVersionKey ) ) ; final String impVersionKey = prefix + IMPLEMENTATION_VERSION ; final String impVersion = getTrimmedString ( attributes . getValue ( impVersionKey ) ) ; final String impVendorKey = prefix + IMPLEMENTATION_VENDOR ; final String impVendor = getTrimmedString ( attributes . getValue ( impVendorKey ) ) ; final String impVendorIDKey = prefix + IMPLEMENTATION_VENDOR_ID ; final String impVendorId = getTrimmedString ( attributes . getValue ( impVendorIDKey ) ) ; final String impURLKey = prefix + IMPLEMENTATION_URL ; final String impURL = getTrimmedString ( attributes . getValue ( impURLKey ) ) ; return new Extension ( name , specVersion , specVendor , impVersion , impVendor , impVendorId , impURL ) ; } private static String getTrimmedString ( final String value ) { return null == value ? null : value . trim ( ) ; } } 	0	['23', '1', '0', '15', '56', '191', '11', '4', '16', '0.807359307', '850', '0.333333333', '7', '0', '0.1875', '0', '0', '35.04347826', '11', '2.4783', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '8', '5', '6', '7', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . File ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class JAXPUtils { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static SAXParserFactory parserFactory = null ; private static SAXParserFactory nsParserFactory = null ; private static DocumentBuilderFactory builderFactory = null ; public static synchronized SAXParserFactory getParserFactory ( ) throws BuildException { if ( parserFactory == null ) { parserFactory = newParserFactory ( ) ; } return parserFactory ; } public static synchronized SAXParserFactory getNSParserFactory ( ) throws BuildException { if ( nsParserFactory == null ) { nsParserFactory = newParserFactory ( ) ; nsParserFactory . setNamespaceAware ( true ) ; } return nsParserFactory ; } public static SAXParserFactory newParserFactory ( ) throws BuildException { try { return SAXParserFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "XML parser factory has not been " + "configured correctly: " + e . getMessage ( ) , e ) ; } } public static Parser getParser ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getParser ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getXMLReader ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getNamespaceXMLReader ( ) throws BuildException { try { return newSAXParser ( getNSParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static String getSystemId ( File file ) { return FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ; } public static DocumentBuilder getDocumentBuilder ( ) throws BuildException { try { return getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( e ) ; } } private static SAXParser newSAXParser ( SAXParserFactory factory ) throws BuildException { try { return factory . newSAXParser ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( "Cannot create parser for the given " + "configuration: " + e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static BuildException convertToBuildException ( SAXException e ) { Exception nested = e . getException ( ) ; if ( nested != null ) { return new BuildException ( nested ) ; } else { return new BuildException ( e ) ; } } private static synchronized DocumentBuilderFactory getDocumentBuilderFactory ( ) throws BuildException { if ( builderFactory == null ) { try { builderFactory = DocumentBuilderFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "Document builder factory has not " + "been configured correctly: " + e . getMessage ( ) , e ) ; } } return builderFactory ; } } 	0	['13', '1', '0', '12', '32', '70', '10', '2', '9', '0.833333333', '155', '1', '1', '0', '0.083333333', '0', '0', '10.61538462', '2', '0.9231', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class UnPackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( '.' , File . separatorChar ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class MatchingTask extends Task implements SelectorContainer { protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { fileset . setDefaultexcludes ( useDefaultExcludes ) ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; return fileset . getDirectoryScanner ( getProject ( ) ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { fileset . addContainsRegexp ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { fileset . addDifferent ( selector ) ; } public void addType ( TypeSelector selector ) { fileset . addType ( selector ) ; } public void addModified ( ModifiedSelector selector ) { fileset . addModified ( selector ) ; } public void add ( FileSelector selector ) { fileset . add ( selector ) ; } protected final FileSet getImplicitFileSet ( ) { return fileset ; } } 	0	['42', '3', '21', '47', '98', '0', '21', '26', '40', '0', '327', '1', '1', '0.474358974', '0.073412698', '2', '2', '6.761904762', '6', '1.1667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Set ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import java . util . zip . ZipEntry ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class GenericDeploymentTool implements EJBDeploymentTool { public static final int DEFAULT_BUFFER_SIZE = 1024 ; public static final int JAR_COMPRESS_LEVEL = 9 ; protected static final String META_DIR = "META-INF/" ; protected static final String MANIFEST = META_DIR + "MANIFEST.MF" ; protected static final String EJB_DD = "ejb-jar.xml" ; public static final String ANALYZER_SUPER = "super" ; public static final String ANALYZER_FULL = "full" ; public static final String ANALYZER_NONE = "none" ; public static final String DEFAULT_ANALYZER = ANALYZER_SUPER ; public static final String ANALYZER_CLASS_SUPER = "org.apache.tools.ant.util.depend.bcel.AncestorAnalyzer" ; public static final String ANALYZER_CLASS_FULL = "org.apache.tools.ant.util.depend.bcel.FullAnalyzer" ; private EjbJar . Config config ; private File destDir ; private Path classpath ; private String genericJarSuffix = "-generic.jar" ; private Task task ; private ClassLoader classpathLoader = null ; private Set addedfiles ; private DescriptorHandler handler ; private DependencyAnalyzer dependencyAnalyzer ; public GenericDeploymentTool ( ) { } public void setDestdir ( File inDir ) { this . destDir = inDir ; } protected File getDestDir ( ) { return destDir ; } public void setTask ( Task task ) { this . task = task ; } protected Task getTask ( ) { return task ; } protected EjbJar . Config getConfig ( ) { return config ; } protected boolean usingBaseJarName ( ) { return config . baseJarName != null ; } public void setGenericJarSuffix ( String inString ) { this . genericJarSuffix = inString ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( task . getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { this . classpath = classpath ; } protected Path getCombinedClasspath ( ) { Path combinedPath = classpath ; if ( config . classpath != null ) { if ( combinedPath == null ) { combinedPath = config . classpath ; } else { combinedPath . append ( config . classpath ) ; } } return combinedPath ; } protected void log ( String message , int level ) { getTask ( ) . log ( message , level ) ; } protected Location getLocation ( ) { return getTask ( ) . getLocation ( ) ; } private void createAnalyzer ( ) { String analyzer = config . analyzer ; if ( analyzer == null ) { analyzer = DEFAULT_ANALYZER ; } if ( analyzer . equals ( ANALYZER_NONE ) ) { return ; } String analyzerClassName = null ; if ( analyzer . equals ( ANALYZER_SUPER ) ) { analyzerClassName = ANALYZER_CLASS_SUPER ; } else if ( analyzer . equals ( ANALYZER_FULL ) ) { analyzerClassName = ANALYZER_CLASS_FULL ; } else { analyzerClassName = analyzer ; } try { Class analyzerClass = Class . forName ( analyzerClassName ) ; dependencyAnalyzer = ( DependencyAnalyzer ) analyzerClass . newInstance ( ) ; dependencyAnalyzer . addClassPath ( new Path ( task . getProject ( ) , config . srcDir . getPath ( ) ) ) ; dependencyAnalyzer . addClassPath ( config . classpath ) ; } catch ( NoClassDefFoundError e ) { dependencyAnalyzer = null ; task . log ( "Unable to load dependency analyzer: " + analyzerClassName + " - dependent class not found: " + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Exception e ) { dependencyAnalyzer = null ; task . log ( "Unable to load dependency analyzer: " + analyzerClassName + " - exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void configure ( EjbJar . Config config ) { this . config = config ; createAnalyzer ( ) ; classpathLoader = null ; } protected void addFileToJar ( JarOutputStream jStream , File inputFile , String logicalFilename ) throws BuildException { FileInputStream iStream = null ; try { if ( ! addedfiles . contains ( logicalFilename ) ) { iStream = new FileInputStream ( inputFile ) ; ZipEntry zipEntry = new ZipEntry ( logicalFilename . replace ( '\\' , '/' ) ) ; jStream . putNextEntry ( zipEntry ) ; byte [ ] byteBuffer = new byte [ 2 * DEFAULT_BUFFER_SIZE ] ; int count = 0 ; do { jStream . write ( byteBuffer , 0 , count ) ; count = iStream . read ( byteBuffer , 0 , byteBuffer . length ) ; } while ( count != - 1 ) ; addedfiles . add ( logicalFilename ) ; } } catch ( IOException ioe ) { log ( "WARNING: IOException while adding entry " + logicalFilename + " to jarfile from " + inputFile . getPath ( ) + " " + ioe . getClass ( ) . getName ( ) + "-" + ioe . getMessage ( ) , Project . MSG_WARN ) ; } finally { if ( iStream != null ) { try { iStream . close ( ) ; } catch ( IOException closeException ) { } } } } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler h = new DescriptorHandler ( getTask ( ) , srcDir ) ; registerKnownDTDs ( h ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; h . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return h ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { } public void processDescriptor ( String descriptorFileName , SAXParser saxParser ) { checkConfiguration ( descriptorFileName , saxParser ) ; try { handler = getDescriptorHandler ( config . srcDir ) ; Hashtable ejbFiles = parseEjbFiles ( descriptorFileName , saxParser ) ; addSupportClasses ( ejbFiles ) ; String baseName = getJarBaseName ( descriptorFileName ) ; String ddPrefix = getVendorDDPrefix ( baseName , descriptorFileName ) ; File manifestFile = getManifestFile ( ddPrefix ) ; if ( manifestFile != null ) { ejbFiles . put ( MANIFEST , manifestFile ) ; } ejbFiles . put ( META_DIR + EJB_DD , new File ( config . descriptorDir , descriptorFileName ) ) ; addVendorFiles ( ejbFiles , ddPrefix ) ; checkAndAddDependants ( ejbFiles ) ; if ( config . flatDestDir && baseName . length ( ) != 0 ) { int startName = baseName . lastIndexOf ( File . separator ) ; if ( startName == - 1 ) { startName = 0 ; } int endName = baseName . length ( ) ; baseName = baseName . substring ( startName , endName ) ; } File jarFile = getVendorOutputJarFile ( baseName ) ; if ( needToRebuild ( ejbFiles , jarFile ) ) { log ( "building " + jarFile . getName ( ) + " with " + String . valueOf ( ejbFiles . size ( ) ) + " files" , Project . MSG_INFO ) ; String publicId = getPublicId ( ) ; writeJar ( baseName , jarFile , ejbFiles , publicId ) ; } else { log ( jarFile . toString ( ) + " is up to date." , Project . MSG_VERBOSE ) ; } } catch ( SAXException se ) { String msg = "SAXException while parsing '" + descriptorFileName + "'. This probably indicates badly-formed XML." + "  Details: " + se . getMessage ( ) ; throw new BuildException ( msg , se ) ; } catch ( IOException ioe ) { String msg = "IOException while parsing'" + descriptorFileName . toString ( ) + "'.  This probably indicates that the descriptor" + " doesn't exist. Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { } protected Hashtable parseEjbFiles ( String descriptorFileName , SAXParser saxParser ) throws IOException , SAXException { FileInputStream descriptorStream = null ; Hashtable ejbFiles = null ; try { descriptorStream = new FileInputStream ( new File ( config . descriptorDir , descriptorFileName ) ) ; saxParser . parse ( new InputSource ( descriptorStream ) , handler ) ; ejbFiles = handler . getFiles ( ) ; } finally { if ( descriptorStream != null ) { try { descriptorStream . close ( ) ; } catch ( IOException closeException ) { } } } return ejbFiles ; } protected void addSupportClasses ( Hashtable ejbFiles ) { Project project = task . getProject ( ) ; for ( Iterator i = config . supportFileSets . iterator ( ) ; i . hasNext ( ) ; ) { FileSet supportFileSet = ( FileSet ) i . next ( ) ; File supportBaseDir = supportFileSet . getDir ( project ) ; DirectoryScanner supportScanner = supportFileSet . getDirectoryScanner ( project ) ; supportScanner . scan ( ) ; String [ ] supportFiles = supportScanner . getIncludedFiles ( ) ; for ( int j = 0 ; j < supportFiles . length ; ++ j ) { ejbFiles . put ( supportFiles [ j ] , new File ( supportBaseDir , supportFiles [ j ] ) ) ; } } } protected String getJarBaseName ( String descriptorFileName ) { String baseName = "" ; if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . BASEJARNAME ) ) { String canonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int index = canonicalDescriptor . lastIndexOf ( '/' ) ; if ( index != - 1 ) { baseName = descriptorFileName . substring ( 0 , index + 1 ) ; } baseName += config . baseJarName ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { int lastSeparatorIndex = descriptorFileName . lastIndexOf ( File . separator ) ; int endBaseName = - 1 ; if ( lastSeparatorIndex != - 1 ) { endBaseName = descriptorFileName . indexOf ( config . baseNameTerminator , lastSeparatorIndex ) ; } else { endBaseName = descriptorFileName . indexOf ( config . baseNameTerminator ) ; } if ( endBaseName != - 1 ) { baseName = descriptorFileName . substring ( 0 , endBaseName ) ; } else { throw new BuildException ( "Unable to determine jar name " + "from descriptor \"" + descriptorFileName + "\"" ) ; } } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DIRECTORY ) ) { File descriptorFile = new File ( config . descriptorDir , descriptorFileName ) ; String path = descriptorFile . getAbsolutePath ( ) ; int lastSeparatorIndex = path . lastIndexOf ( File . separator ) ; if ( lastSeparatorIndex == - 1 ) { throw new BuildException ( "Unable to determine directory name holding descriptor" ) ; } String dirName = path . substring ( 0 , lastSeparatorIndex ) ; int dirSeparatorIndex = dirName . lastIndexOf ( File . separator ) ; if ( dirSeparatorIndex != - 1 ) { dirName = dirName . substring ( dirSeparatorIndex + 1 ) ; } baseName = dirName ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . EJB_NAME ) ) { baseName = handler . getEjbName ( ) ; } return baseName ; } public String getVendorDDPrefix ( String baseName , String descriptorFileName ) { String ddPrefix = null ; if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { ddPrefix = baseName + config . baseNameTerminator ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . BASEJARNAME ) || config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . EJB_NAME ) || config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DIRECTORY ) ) { String canonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int index = canonicalDescriptor . lastIndexOf ( '/' ) ; if ( index == - 1 ) { ddPrefix = "" ; } else { ddPrefix = descriptorFileName . substring ( 0 , index + 1 ) ; } } return ddPrefix ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { } File getVendorOutputJarFile ( String baseName ) { return new File ( destDir , baseName + genericJarSuffix ) ; } protected boolean needToRebuild ( Hashtable ejbFiles , File jarFile ) { if ( jarFile . exists ( ) ) { long lastBuild = jarFile . lastModified ( ) ; Iterator fileIter = ejbFiles . values ( ) . iterator ( ) ; while ( fileIter . hasNext ( ) ) { File currentFile = ( File ) fileIter . next ( ) ; if ( lastBuild < currentFile . lastModified ( ) ) { log ( "Build needed because " + currentFile . getPath ( ) + " is out of date" , Project . MSG_VERBOSE ) ; return true ; } } return false ; } return true ; } protected String getPublicId ( ) { return handler . getPublicId ( ) ; } protected File getManifestFile ( String prefix ) { File manifestFile = new File ( getConfig ( ) . descriptorDir , prefix + "manifest.mf" ) ; if ( manifestFile . exists ( ) ) { return manifestFile ; } if ( config . manifest != null ) { return config . manifest ; } return null ; } protected void writeJar ( String baseName , File jarfile , Hashtable files , String publicId ) throws BuildException { JarOutputStream jarStream = null ; try { if ( addedfiles == null ) { addedfiles = new HashSet ( ) ; } else { addedfiles . clear ( ) ; } if ( jarfile . exists ( ) ) { jarfile . delete ( ) ; } jarfile . getParentFile ( ) . mkdirs ( ) ; jarfile . createNewFile ( ) ; InputStream in = null ; Manifest manifest = null ; try { File manifestFile = ( File ) files . get ( MANIFEST ) ; if ( manifestFile != null && manifestFile . exists ( ) ) { in = new FileInputStream ( manifestFile ) ; } else { String defaultManifest = "/org/apache/tools/ant/defaultManifest.mf" ; in = this . getClass ( ) . getResourceAsStream ( defaultManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find " + "default manifest: " + defaultManifest ) ; } } manifest = new Manifest ( in ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest" , e , getLocation ( ) ) ; } finally { if ( in != null ) { in . close ( ) ; } } jarStream = new JarOutputStream ( new FileOutputStream ( jarfile ) , manifest ) ; jarStream . setMethod ( JarOutputStream . DEFLATED ) ; for ( Iterator entryIterator = files . keySet ( ) . iterator ( ) ; entryIterator . hasNext ( ) ; ) { String entryName = ( String ) entryIterator . next ( ) ; if ( entryName . equals ( MANIFEST ) ) { continue ; } File entryFile = ( File ) files . get ( entryName ) ; log ( "adding file '" + entryName + "'" , Project . MSG_VERBOSE ) ; addFileToJar ( jarStream , entryFile , entryName ) ; InnerClassFilenameFilter flt = new InnerClassFilenameFilter ( entryFile . getName ( ) ) ; File entryDir = entryFile . getParentFile ( ) ; String [ ] innerfiles = entryDir . list ( flt ) ; if ( innerfiles != null ) { for ( int i = 0 , n = innerfiles . length ; i < n ; i ++ ) { int entryIndex = entryName . lastIndexOf ( entryFile . getName ( ) ) - 1 ; if ( entryIndex < 0 ) { entryName = innerfiles [ i ] ; } else { entryName = entryName . substring ( 0 , entryIndex ) + File . separatorChar + innerfiles [ i ] ; } entryFile = new File ( config . srcDir , entryName ) ; log ( "adding innerclass file '" + entryName + "'" , Project . MSG_VERBOSE ) ; addFileToJar ( jarStream , entryFile , entryName ) ; } } } } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file '" + jarfile . toString ( ) + "'. Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( jarStream != null ) { try { jarStream . close ( ) ; } catch ( IOException closeException ) { } } } } protected void checkAndAddDependants ( Hashtable checkEntries ) throws BuildException { if ( dependencyAnalyzer == null ) { return ; } dependencyAnalyzer . reset ( ) ; Iterator i = checkEntries . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { String entryName = ( String ) i . next ( ) ; if ( entryName . endsWith ( ".class" ) ) { String className = entryName . substring ( 0 , entryName . length ( ) - ".class" . length ( ) ) ; className = className . replace ( File . separatorChar , '/' ) ; className = className . replace ( '/' , '.' ) ; dependencyAnalyzer . addRootClass ( className ) ; } } Enumeration e = dependencyAnalyzer . getClassDependencies ( ) ; while ( e . hasMoreElements ( ) ) { String classname = ( String ) e . nextElement ( ) ; String location = classname . replace ( '.' , File . separatorChar ) + ".class" ; File classFile = new File ( config . srcDir , location ) ; if ( classFile . exists ( ) ) { checkEntries . put ( location , classFile ) ; log ( "dependent class: " + classname + " - " + classFile , Project . MSG_VERBOSE ) ; } } } protected ClassLoader getClassLoaderForBuild ( ) { if ( classpathLoader != null ) { return classpathLoader ; } Path combinedClasspath = getCombinedClasspath ( ) ; if ( combinedClasspath == null ) { classpathLoader = getClass ( ) . getClassLoader ( ) ; } else { classpathLoader = getTask ( ) . getProject ( ) . createClassLoader ( combinedClasspath ) ; } return classpathLoader ; } public void validateConfigured ( ) throws BuildException { if ( ( destDir == null ) || ( ! destDir . isDirectory ( ) ) ) { String msg = "A valid destination directory must be specified " + "using the \"destdir\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } } } 	0	['33', '1', '6', '22', '135', '316', '7', '15', '10', '0.940625', '1367', '0.6', '5', '0', '0.17630854', '0', '0', '39.81818182', '10', '2.0909', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; public class Union extends BaseResourceCollectionContainer { public static Union getInstance ( ResourceCollection rc ) { return rc instanceof Union ? ( Union ) rc : new Union ( rc ) ; } public Union ( ) { } public Union ( ResourceCollection rc ) { add ( rc ) ; } public String [ ] list ( ) { if ( isReference ( ) ) { return ( ( Union ) getCheckedRef ( ) ) . list ( ) ; } Collection result = getCollection ( true ) ; return ( String [ ] ) ( result . toArray ( new String [ result . size ( ) ] ) ) ; } public Resource [ ] listResources ( ) { if ( isReference ( ) ) { return ( ( Union ) getCheckedRef ( ) ) . listResources ( ) ; } Collection result = getCollection ( ) ; return ( Resource [ ] ) ( result . toArray ( new Resource [ result . size ( ) ] ) ) ; } protected Collection getCollection ( ) { return getCollection ( false ) ; } protected Collection getCollection ( boolean asString ) { List rc = getResourceCollections ( ) ; if ( rc . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } ArrayList union = new ArrayList ( rc . size ( ) * 2 ) ; for ( Iterator rcIter = rc . iterator ( ) ; rcIter . hasNext ( ) ; ) { for ( Iterator r = nextRC ( rcIter ) . iterator ( ) ; r . hasNext ( ) ; ) { Object o = r . next ( ) ; if ( asString ) { o = o . toString ( ) ; } if ( ! ( union . contains ( o ) ) ) { union . add ( o ) ; } } } return union ; } private static ResourceCollection nextRC ( Iterator i ) { return ( ResourceCollection ) i . next ( ) ; } } 	0	['8', '4', '0', '16', '25', '28', '13', '3', '5', '2', '122', '0', '0', '0.88', '0.3125', '1', '1', '14.25', '6', '1.75', '0']
package org . apache . tools . ant . util ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public abstract class LineOrientedOutputStream extends OutputStream { private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; private boolean skip = false ; public final void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == LF ) || ( c == CR ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == CR ) ; } public final void flush ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } } protected void processBuffer ( ) throws IOException { try { processLine ( buffer . toString ( ) ) ; } finally { buffer . reset ( ) ; } } protected abstract void processLine ( String line ) throws IOException ; public final void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } public final void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['7', '2', '2', '2', '15', '0', '2', '0', '5', '0.866666667', '143', '1', '0', '0.454545455', '0.392857143', '1', '1', '18.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . jsp . JspNameMangler ; import org . apache . tools . ant . taskdefs . optional . jsp . Jasper41Mangler ; public final class JspCompilerAdapterFactory { private JspCompilerAdapterFactory ( ) { } public static JspCompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { return getCompiler ( compilerType , task , task . getProject ( ) . createClassLoader ( null ) ) ; } public static JspCompilerAdapter getCompiler ( String compilerType , Task task , AntClassLoader loader ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jasper" ) ) { return new JasperC ( new JspNameMangler ( ) ) ; } if ( compilerType . equalsIgnoreCase ( "jasper41" ) ) { return new JasperC ( new Jasper41Mangler ( ) ) ; } return resolveClassName ( compilerType , loader ) ; } private static JspCompilerAdapter resolveClassName ( String className , AntClassLoader classloader ) throws BuildException { try { Class c = classloader . findClass ( className ) ; Object o = c . newInstance ( ) ; return ( JspCompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	0	['4', '1', '0', '11', '18', '6', '1', '10', '2', '2', '97', '0', '0', '0', '0.5', '0', '0', '23.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Reference ; public class ExtensionAdapter extends DataType { private String extensionName ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationVendorID ; private String implementationVendor ; private DeweyDecimal implementationVersion ; private String implementationURL ; public void setExtensionName ( final String extensionName ) { verifyNotAReference ( ) ; this . extensionName = extensionName ; } public void setSpecificationVersion ( final String specificationVersion ) { verifyNotAReference ( ) ; this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } public void setSpecificationVendor ( final String specificationVendor ) { verifyNotAReference ( ) ; this . specificationVendor = specificationVendor ; } public void setImplementationVendorId ( final String implementationVendorID ) { verifyNotAReference ( ) ; this . implementationVendorID = implementationVendorID ; } public void setImplementationVendor ( final String implementationVendor ) { verifyNotAReference ( ) ; this . implementationVendor = implementationVendor ; } public void setImplementationVersion ( final String implementationVersion ) { verifyNotAReference ( ) ; this . implementationVersion = new DeweyDecimal ( implementationVersion ) ; } public void setImplementationUrl ( final String implementationURL ) { verifyNotAReference ( ) ; this . implementationURL = implementationURL ; } public void setRefid ( final Reference reference ) throws BuildException { if ( null != extensionName || null != specificationVersion || null != specificationVendor || null != implementationVersion || null != implementationVendorID || null != implementationVendor || null != implementationURL ) { throw tooManyAttributes ( ) ; } Object o = reference . getReferencedObject ( getProject ( ) ) ; if ( o instanceof ExtensionAdapter ) { final ExtensionAdapter other = ( ExtensionAdapter ) o ; extensionName = other . extensionName ; specificationVersion = other . specificationVersion ; specificationVendor = other . specificationVendor ; implementationVersion = other . implementationVersion ; implementationVendorID = other . implementationVendorID ; implementationVendor = other . implementationVendor ; implementationURL = other . implementationURL ; } else { final String message = reference . getRefId ( ) + " doesn\'t refer to a Extension" ; throw new BuildException ( message ) ; } super . setRefid ( reference ) ; } private void verifyNotAReference ( ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } Extension toExtension ( ) throws BuildException { if ( null == extensionName ) { final String message = "Extension is missing name." ; throw new BuildException ( message ) ; } String specificationVersionString = null ; if ( null != specificationVersion ) { specificationVersionString = specificationVersion . toString ( ) ; } String implementationVersionString = null ; if ( null != implementationVersion ) { implementationVersionString = implementationVersion . toString ( ) ; } return new Extension ( extensionName , specificationVersionString , specificationVendor , implementationVersionString , implementationVendor , implementationVendorID , implementationURL ) ; } public String toString ( ) { return "{" + toExtension ( ) . toString ( ) + "}" ; } } 	0	['12', '3', '0', '11', '28', '36', '5', '6', '10', '0.727272727', '214', '1', '2', '0.731707317', '0.555555556', '1', '1', '16.25', '1', '0.9167', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class ClassCPInfo extends ConstantPoolEntry { private String className ; private int index ; public ClassCPInfo ( ) { super ( CONSTANT_CLASS , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { index = cpStream . readUnsignedShort ( ) ; className = "unresolved" ; } public String toString ( ) { return "Class Constant Pool Entry for " + className + "[" + index + "]" ; } public void resolve ( ConstantPool constantPool ) { className = ( ( Utf8CPInfo ) constantPool . getEntry ( index ) ) . getValue ( ) ; super . resolve ( constantPool ) ; } public String getClassName ( ) { return className ; } } 	0	['5', '2', '0', '7', '14', '0', '6', '3', '5', '0.375', '51', '1', '0', '0.6', '0.466666667', '1', '1', '8.8', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . oro . text . regex . MatchResult ; import org . apache . oro . text . regex . Pattern ; import org . apache . oro . text . regex . Perl5Compiler ; import org . apache . oro . text . regex . Perl5Matcher ; import org . apache . tools . ant . BuildException ; public class JakartaOroMatcher implements RegexpMatcher { private String pattern ; protected final Perl5Compiler compiler = new Perl5Compiler ( ) ; protected final Perl5Matcher matcher = new Perl5Matcher ( ) ; public JakartaOroMatcher ( ) { } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return this . pattern ; } protected Pattern getCompiledPattern ( int options ) throws BuildException { try { Pattern p = compiler . compile ( pattern , getCompilerOptions ( options ) ) ; return p ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { Pattern p = getCompiledPattern ( options ) ; return matcher . contains ( input , p ) ; } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { if ( ! matches ( input , options ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = matcher . getMatch ( ) ; int cnt = mr . groups ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String match = mr . group ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = Perl5Compiler . DEFAULT_MASK ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= Perl5Compiler . CASE_INSENSITIVE_MASK ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= Perl5Compiler . MULTILINE_MASK ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= Perl5Compiler . SINGLELINE_MASK ; } return cOptions ; } } 	0	['9', '1', '1', '8', '21', '22', '1', '7', '7', '0.541666667', '135', '1', '0', '0', '0.666666667', '0', '0', '13.66666667', '4', '1.2222', '0']
package org . apache . tools . ant . types . spi ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildException ; public class Provider extends ProjectComponent { private String type ; public String getClassName ( ) { return type ; } public void setClassName ( String type ) { this . type = type ; } public void check ( ) { if ( type == null ) { throw new BuildException ( "classname attribute must be set for provider element" , getLocation ( ) ) ; } if ( type . length ( ) == 0 ) { throw new BuildException ( "Invalid empty classname" , getLocation ( ) ) ; } } } 	0	['4', '2', '0', '4', '8', '0', '1', '3', '4', '0.333333333', '37', '1', '0', '0.75', '0.625', '0', '0', '8', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Have extends P4Base { public void execute ( ) throws BuildException { execP4Command ( "have " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['2', '4', '0', '4', '8', '1', '0', '4', '2', '2', '25', '0', '0', '0.980769231', '1', '1', '1', '11.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . optional . native2ascii . Native2AsciiAdapter ; import org . apache . tools . ant . taskdefs . optional . native2ascii . Native2AsciiAdapterFactory ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . util . facade . ImplementationSpecificArgument ; public class Native2Ascii extends MatchingTask { private boolean reverse = false ; private String encoding = null ; private File srcDir = null ; private File destDir = null ; private String extension = null ; private Mapper mapper ; private FacadeTaskHelper facade = null ; public Native2Ascii ( ) { facade = new FacadeTaskHelper ( Native2AsciiAdapterFactory . getDefault ( ) ) ; } public void setReverse ( boolean reverse ) { this . reverse = reverse ; } public boolean getReverse ( ) { return reverse ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setSrc ( File srcDir ) { this . srcDir = srcDir ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setExt ( String ext ) { this . extension = ext ; } public void setImplementation ( String impl ) { if ( "default" . equals ( impl ) ) { facade . setImplementation ( Native2AsciiAdapterFactory . getDefault ( ) ) ; } else { facade . setImplementation ( impl ) ; } } public Mapper createMapper ( ) throws BuildException { if ( mapper != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapper = new Mapper ( getProject ( ) ) ; return mapper ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public ImplementationSpecificArgument createArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public void execute ( ) throws BuildException { DirectoryScanner scanner = null ; String [ ] files ; if ( srcDir == null ) { srcDir = getProject ( ) . resolveFile ( "." ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." ) ; } if ( srcDir . equals ( destDir ) && extension == null && mapper == null ) { throw new BuildException ( "The ext attribute or a mapper must be set if" + " src and dest dirs are the same." ) ; } FileNameMapper m = null ; if ( mapper == null ) { if ( extension == null ) { m = new IdentityMapper ( ) ; } else { m = new ExtMapper ( ) ; } } else { m = mapper . getImplementation ( ) ; } scanner = getDirectoryScanner ( srcDir ) ; files = scanner . getIncludedFiles ( ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; files = sfs . restrict ( files , srcDir , destDir , m ) ; int count = files . length ; if ( count == 0 ) { return ; } String message = "Converting " + count + " file" + ( count != 1 ? "s" : "" ) + " from " ; log ( message + srcDir + " to " + destDir ) ; for ( int i = 0 ; i < files . length ; i ++ ) { convert ( files [ i ] , m . mapFileName ( files [ i ] ) [ 0 ] ) ; } } private void convert ( String srcName , String destName ) throws BuildException { File srcFile ; File destFile ; srcFile = new File ( srcDir , srcName ) ; destFile = new File ( destDir , destName ) ; if ( srcFile . equals ( destFile ) ) { throw new BuildException ( "file " + srcFile + " would overwrite its self" ) ; } String parentName = destFile . getParent ( ) ; if ( parentName != null ) { File parentFile = new File ( parentName ) ; if ( ( ! parentFile . exists ( ) ) && ( ! parentFile . mkdirs ( ) ) ) { throw new BuildException ( "cannot create parent directory " + parentName ) ; } } log ( "converting " + srcName , Project . MSG_VERBOSE ) ; Native2AsciiAdapter ad = Native2AsciiAdapterFactory . getAdapter ( facade . getImplementation ( ) , this ) ; if ( ! ad . convert ( this , srcFile , destFile ) ) { throw new BuildException ( "conversion failed" ) ; } } public String [ ] getCurrentArgs ( ) { return facade . getArgs ( ) ; } private class ExtMapper implements FileNameMapper { public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String fileName ) { int lastDot = fileName . lastIndexOf ( '.' ) ; if ( lastDot >= 0 ) { return new String [ ] { fileName . substring ( 0 , lastDot ) + extension } ; } else { return new String [ ] { fileName + extension } ; } } } } 	0	['16', '4', '0', '19', '56', '60', '5', '16', '14', '0.80952381', '362', '1', '2', '0.838709677', '0.25', '3', '3', '21.1875', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; public abstract class AbstractHotDeploymentTool implements HotDeploymentTool { private ServerDeploy task ; private Path classpath ; private String userName ; private String password ; private String server ; public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( task . getProject ( ) ) ; } return classpath . createPath ( ) ; } protected abstract boolean isActionValid ( ) ; public void validateAttributes ( ) throws BuildException { if ( task . getAction ( ) == null ) { throw new BuildException ( "The \"action\" attribute must be set" ) ; } if ( ! isActionValid ( ) ) { throw new BuildException ( "Invalid action \"" + task . getAction ( ) + "\" passed" ) ; } if ( classpath == null ) { throw new BuildException ( "The classpath attribute must be set" ) ; } } public abstract void deploy ( ) throws BuildException ; public void setTask ( ServerDeploy task ) { this . task = task ; } protected ServerDeploy getTask ( ) { return task ; } public Path getClasspath ( ) { return classpath ; } public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public String getUserName ( ) { return userName ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServer ( ) { return server ; } public void setServer ( String server ) { this . server = server ; } } 	0	['15', '1', '2', '7', '24', '77', '2', '5', '13', '0.871428571', '109', '1', '2', '0', '0.333333333', '0', '0', '5.933333333', '2', '1', '0']
package org . apache . tools . ant ; import java . io . Serializable ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . Locator ; public class Location implements Serializable { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( Locator loc ) { this ( loc . getSystemId ( ) , loc . getLineNumber ( ) , loc . getColumnNumber ( ) ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { if ( fileName != null && fileName . startsWith ( "file:" ) ) { this . fileName = FILE_UTILS . fromURI ( fileName ) ; } else { this . fileName = fileName ; } this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getFileName ( ) { return fileName ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } public boolean equals ( Object other ) { if ( this == other ) { return true ; } if ( other == null ) { return false ; } if ( ! ( other . getClass ( ) == getClass ( ) ) ) { return false ; } return toString ( ) . equals ( other . toString ( ) ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } } 	0	['11', '1', '0', '150', '26', '41', '149', '1', '9', '0.56', '134', '0.8', '2', '0', '0.3', '1', '1', '10.72727273', '4', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class ZipFileSet extends ArchiveFileSet { private String encoding = null ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ZipFileSet ( ZipFileSet fileset ) { super ( fileset ) ; encoding = fileset . encoding ; } public void setEncoding ( String enc ) { checkZipFileSetAttributesAllowed ( ) ; this . encoding = enc ; } public String getEncoding ( ) { if ( isReference ( ) ) { AbstractFileSet ref = getRef ( getProject ( ) ) ; if ( ref instanceof ZipFileSet ) { return ( ( ZipFileSet ) ref ) . getEncoding ( ) ; } else { return null ; } } return encoding ; } protected ArchiveScanner newArchiveScanner ( ) { ZipScanner zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; return zs ; } protected AbstractFileSet getRef ( Project p ) { dieOnCircularReference ( p ) ; Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof ZipFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { ZipFileSet zfs = new ZipFileSet ( ( FileSet ) o ) ; configureFileSet ( zfs ) ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a zipfileset or a fileset" ; throw new BuildException ( msg ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } private void checkZipFileSetAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof ZipFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	0	['9', '6', '0', '12', '28', '6', '4', '8', '4', '0.125', '143', '1', '0', '0.953125', '0.288888889', '5', '18', '14.77777778', '4', '1.5556', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; InputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = srcResource . getInputStream ( ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; FileUtils . close ( out ) ; FileUtils . close ( zIn ) ; } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( GUnzip . class ) ; } } 	0	['4', '4', '0', '5', '26', '6', '0', '5', '1', '1.166666667', '129', '0.5', '0', '0.942307692', '1', '3', '5', '30.75', '5', '2', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . PipedInputStream ; import java . io . PipedOutputStream ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class LeadPipeInputStream extends PipedInputStream { private ProjectComponent managingPc ; public LeadPipeInputStream ( ) { super ( ) ; } public LeadPipeInputStream ( int size ) { super ( ) ; setBufferSize ( size ) ; } public LeadPipeInputStream ( PipedOutputStream src ) throws IOException { super ( src ) ; } public LeadPipeInputStream ( PipedOutputStream src , int size ) throws IOException { super ( src ) ; setBufferSize ( size ) ; } public synchronized int read ( ) throws IOException { int result = - 1 ; try { result = super . read ( ) ; } catch ( IOException eyeOhEx ) { if ( "write end dead" . equalsIgnoreCase ( eyeOhEx . getMessage ( ) ) ) { if ( super . in > 0 && super . out < super . buffer . length && super . out > super . in ) { result = super . buffer [ super . out ++ ] & 0xFF ; } } else { log ( "error at LeadPipeInputStream.read():  " + eyeOhEx . getMessage ( ) , Project . MSG_INFO ) ; } } return result ; } public synchronized void setBufferSize ( int size ) { if ( size > buffer . length ) { byte [ ] newBuffer = new byte [ size ] ; if ( in >= 0 ) { if ( in > out ) { System . arraycopy ( buffer , out , newBuffer , out , in - out ) ; } else { int outlen = buffer . length - out ; System . arraycopy ( buffer , out , newBuffer , 0 , outlen ) ; System . arraycopy ( buffer , 0 , newBuffer , outlen , in ) ; in += outlen ; out = 0 ; } } buffer = newBuffer ; } } public void setManagingTask ( Task task ) { setManagingComponent ( task ) ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { if ( loglevel > Project . MSG_WARN ) { System . out . println ( message ) ; } else { System . err . println ( message ) ; } } } } 	0	['9', '3', '0', '3', '20', '34', '1', '2', '9', '0.625', '177', '1', '1', '0.761904762', '0.333333333', '1', '3', '18.55555556', '4', '1.1111', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . RuntimeConfigurable ; public class AntXMLContext { private Project project ; private File buildFile ; private Vector targetVector = new Vector ( ) ; private File buildFileParent ; private String currentProjectName ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private Target currentTarget = null ; private Vector wStack = new Vector ( ) ; private boolean ignoreProjectTag = false ; private Map prefixMapping = new HashMap ( ) ; private Map currentTargets = null ; public AntXMLContext ( Project project ) { this . project = project ; implicitTarget . setProject ( project ) ; implicitTarget . setName ( "" ) ; targetVector . addElement ( implicitTarget ) ; } public void setBuildFile ( File buildFile ) { this . buildFile = buildFile ; this . buildFileParent = new File ( buildFile . getParent ( ) ) ; implicitTarget . setLocation ( new Location ( buildFile . getAbsolutePath ( ) ) ) ; } public File getBuildFile ( ) { return buildFile ; } public File getBuildFileParent ( ) { return buildFileParent ; } public Project getProject ( ) { return project ; } public String getCurrentProjectName ( ) { return currentProjectName ; } public void setCurrentProjectName ( String name ) { this . currentProjectName = name ; } public RuntimeConfigurable currentWrapper ( ) { if ( wStack . size ( ) < 1 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 1 ) ; } public RuntimeConfigurable parentWrapper ( ) { if ( wStack . size ( ) < 2 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 2 ) ; } public void pushWrapper ( RuntimeConfigurable wrapper ) { wStack . addElement ( wrapper ) ; } public void popWrapper ( ) { if ( wStack . size ( ) > 0 ) { wStack . removeElementAt ( wStack . size ( ) - 1 ) ; } } public Vector getWrapperStack ( ) { return wStack ; } public void addTarget ( Target target ) { targetVector . addElement ( target ) ; currentTarget = target ; } public Target getCurrentTarget ( ) { return currentTarget ; } public Target getImplicitTarget ( ) { return implicitTarget ; } public void setCurrentTarget ( Target target ) { this . currentTarget = target ; } public void setImplicitTarget ( Target target ) { this . implicitTarget = target ; } public Vector getTargets ( ) { return targetVector ; } public void configureId ( Object element , Attributes attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addIdReference ( id , element ) ; } } public Locator getLocator ( ) { return locator ; } public void setLocator ( Locator locator ) { this . locator = locator ; } public boolean isIgnoringProjectTag ( ) { return ignoreProjectTag ; } public void setIgnoreProjectTag ( boolean flag ) { this . ignoreProjectTag = flag ; } public void startPrefixMapping ( String prefix , String uri ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null ) { list = new ArrayList ( ) ; prefixMapping . put ( prefix , list ) ; } list . add ( uri ) ; } public void endPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return ; } list . remove ( list . size ( ) - 1 ) ; } public String getPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return null ; } return ( String ) list . get ( list . size ( ) - 1 ) ; } public Map getCurrentTargets ( ) { return currentTargets ; } public void setCurrentTargets ( Map currentTargets ) { this . currentTargets = currentTargets ; } } 	0	['28', '1', '0', '11', '52', '282', '7', '4', '28', '0.919753086', '300', '1', '3', '0', '0.13961039', '0', '0', '9.285714286', '3', '1.2857', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . regexp . RE ; import org . apache . regexp . RESyntaxException ; import org . apache . tools . ant . BuildException ; public class JakartaRegexpMatcher implements RegexpMatcher { private String pattern ; public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return pattern ; } protected RE getCompiledPattern ( int options ) throws BuildException { int cOptions = getCompilerOptions ( options ) ; try { RE reg = new RE ( pattern ) ; reg . setMatchFlags ( cOptions ) ; return reg ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { return matches ( input , getCompiledPattern ( options ) ) ; } private boolean matches ( String input , RE reg ) { return reg . match ( input ) ; } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { RE reg = getCompiledPattern ( options ) ; if ( ! matches ( input , reg ) ) { return null ; } Vector v = new Vector ( ) ; int cnt = reg . getParenCount ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String match = reg . getParen ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = RE . MATCH_NORMAL ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= RE . MATCH_CASEINDEPENDENT ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= RE . MATCH_MULTILINE ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= RE . MATCH_SINGLELINE ; } return cOptions ; } } 	0	['10', '1', '1', '6', '20', '39', '1', '5', '7', '0.555555556', '129', '1', '0', '0', '0.525', '0', '0', '11.8', '4', '1.2', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . regexp . RE ; import org . apache . tools . ant . BuildException ; public class JakartaRegexpRegexp extends JakartaRegexpMatcher implements Regexp { public JakartaRegexpRegexp ( ) { super ( ) ; } protected int getSubsOptions ( int options ) { int subsOptions = RE . REPLACE_FIRSTONLY ; if ( RegexpUtil . hasFlag ( options , REPLACE_ALL ) ) { subsOptions = RE . REPLACE_ALL ; } return subsOptions ; } public String substitute ( String input , String argument , int options ) throws BuildException { Vector v = getGroups ( input , options ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( c ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( c ) ; } } argument = result . toString ( ) ; RE reg = getCompiledPattern ( options ) ; int sOptions = getSubsOptions ( options ) ; return reg . subst ( input , argument , sOptions ) ; } } 	0	['3', '2', '0', '5', '16', '3', '0', '5', '2', '2', '95', '0', '0', '0.818181818', '0.666666667', '0', '0', '30.66666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . pvcs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . text . MessageFormat ; import java . text . ParseException ; import java . util . Enumeration ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class Pvcs extends org . apache . tools . ant . Task { private static final int POS_1 = 1 ; private static final int POS_2 = 2 ; private static final int POS_3 = 3 ; private String pvcsbin ; private String repository ; private String pvcsProject ; private Vector pvcsProjects ; private String workspace ; private String force ; private String promotiongroup ; private String label ; private String revision ; private boolean ignorerc ; private boolean updateOnly ; private String filenameFormat ; private String lineStart ; private String userId ; private String config ; private static final String PCLI_EXE = "pcli" ; private static final String GET_EXE = "get" ; protected int runCmd ( Commandline cmd , ExecuteStreamHandler out ) { try { Project aProj = getProject ( ) ; Execute exe = new Execute ( out ) ; exe . setAntRun ( aProj ) ; exe . setWorkingDirectory ( aProj . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { String msg = "Failed executing: " + cmd . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private String getExecutable ( String exe ) { StringBuffer correctedExe = new StringBuffer ( ) ; if ( getPvcsbin ( ) != null ) { if ( pvcsbin . endsWith ( File . separator ) ) { correctedExe . append ( pvcsbin ) ; } else { correctedExe . append ( pvcsbin ) . append ( File . separator ) ; } } return correctedExe . append ( exe ) . toString ( ) ; } public void execute ( ) throws org . apache . tools . ant . BuildException { int result = 0 ; if ( repository == null || repository . trim ( ) . equals ( "" ) ) { throw new BuildException ( "Required argument repository not specified" ) ; } Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getExecutable ( PCLI_EXE ) ) ; commandLine . createArgument ( ) . setValue ( "lvf" ) ; commandLine . createArgument ( ) . setValue ( "-z" ) ; commandLine . createArgument ( ) . setValue ( "-aw" ) ; if ( getWorkspace ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-sp" + getWorkspace ( ) ) ; } commandLine . createArgument ( ) . setValue ( "-pr" + getRepository ( ) ) ; String uid = getUserId ( ) ; if ( uid != null ) { commandLine . createArgument ( ) . setValue ( "-id" + uid ) ; } if ( getPvcsproject ( ) == null && getPvcsprojects ( ) . isEmpty ( ) ) { pvcsProject = "/" ; } if ( getPvcsproject ( ) != null ) { commandLine . createArgument ( ) . setValue ( getPvcsproject ( ) ) ; } if ( ! getPvcsprojects ( ) . isEmpty ( ) ) { Enumeration e = getPvcsprojects ( ) . elements ( ) ; while ( e . hasMoreElements ( ) ) { String projectName = ( ( PvcsProject ) e . nextElement ( ) ) . getName ( ) ; if ( projectName == null || ( projectName . trim ( ) ) . equals ( "" ) ) { throw new BuildException ( "name is a required attribute " + "of pvcsproject" ) ; } commandLine . createArgument ( ) . setValue ( projectName ) ; } } File tmp = null ; File tmp2 = null ; try { Random rand = new Random ( System . currentTimeMillis ( ) ) ; tmp = new File ( "pvcs_ant_" + rand . nextLong ( ) + ".log" ) ; FileOutputStream fos = new FileOutputStream ( tmp ) ; tmp2 = new File ( "pvcs_ant_" + rand . nextLong ( ) + ".log" ) ; log ( commandLine . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { result = runCmd ( commandLine , new PumpStreamHandler ( fos , new LogOutputStream ( this , Project . MSG_WARN ) ) ) ; } finally { fos . close ( ) ; } if ( Execute . isFailure ( result ) && ! ignorerc ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ! tmp . exists ( ) ) { throw new BuildException ( "Communication between ant and pvcs " + "failed. No output generated from executing PVCS " + "commandline interface \"pcli\" and \"get\"" ) ; } log ( "Creating folders" , Project . MSG_INFO ) ; createFolders ( tmp ) ; massagePCLI ( tmp , tmp2 ) ; commandLine . clearArgs ( ) ; commandLine . setExecutable ( getExecutable ( GET_EXE ) ) ; if ( getConfig ( ) != null && getConfig ( ) . length ( ) > 0 ) { commandLine . createArgument ( ) . setValue ( "-c" + getConfig ( ) ) ; } if ( getForce ( ) != null && getForce ( ) . equals ( "yes" ) ) { commandLine . createArgument ( ) . setValue ( "-Y" ) ; } else { commandLine . createArgument ( ) . setValue ( "-N" ) ; } if ( getPromotiongroup ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-G" + getPromotiongroup ( ) ) ; } else { if ( getLabel ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-v" + getLabel ( ) ) ; } else { if ( getRevision ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-r" + getRevision ( ) ) ; } } } if ( updateOnly ) { commandLine . createArgument ( ) . setValue ( "-U" ) ; } commandLine . createArgument ( ) . setValue ( "@" + tmp2 . getAbsolutePath ( ) ) ; log ( "Getting files" , Project . MSG_INFO ) ; log ( "Executing " + commandLine . toString ( ) , Project . MSG_VERBOSE ) ; result = runCmd ( commandLine , new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; if ( result != 0 && ! ignorerc ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Return code was " + result ; throw new BuildException ( msg , getLocation ( ) ) ; } } catch ( FileNotFoundException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } catch ( IOException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } catch ( ParseException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } finally { if ( tmp != null ) { tmp . delete ( ) ; } if ( tmp2 != null ) { tmp2 . delete ( ) ; } } } private void createFolders ( File file ) throws IOException , ParseException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; MessageFormat mf = new MessageFormat ( getFilenameFormat ( ) ) ; String line = in . readLine ( ) ; while ( line != null ) { log ( "Considering \"" + line + "\"" , Project . MSG_VERBOSE ) ; if ( line . startsWith ( "\"\\" ) || line . startsWith ( "\"/" ) || ( line . length ( ) > POS_3 && line . startsWith ( "\"" ) && Character . isLetter ( line . charAt ( POS_1 ) ) && String . valueOf ( line . charAt ( POS_2 ) ) . equals ( ":" ) && String . valueOf ( line . charAt ( POS_3 ) ) . equals ( "\\" ) ) ) { Object [ ] objs = mf . parse ( line ) ; String f = ( String ) objs [ 1 ] ; int index = f . lastIndexOf ( File . separator ) ; if ( index > - 1 ) { File dir = new File ( f . substring ( 0 , index ) ) ; if ( ! dir . exists ( ) ) { log ( "Creating " + dir . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( dir . mkdirs ( ) ) { log ( "Created " + dir . getAbsolutePath ( ) , Project . MSG_INFO ) ; } else { log ( "Failed to create " + dir . getAbsolutePath ( ) , Project . MSG_INFO ) ; } } else { log ( dir . getAbsolutePath ( ) + " exists. Skipping" , Project . MSG_VERBOSE ) ; } } else { log ( "File separator problem with " + line , Project . MSG_WARN ) ; } } else { log ( "Skipped \"" + line + "\"" , Project . MSG_VERBOSE ) ; } line = in . readLine ( ) ; } } finally { if ( in != null ) { in . close ( ) ; } } } private void massagePCLI ( File in , File out ) throws IOException { BufferedReader inReader = null ; BufferedWriter outWriter = null ; try { inReader = new BufferedReader ( new FileReader ( in ) ) ; outWriter = new BufferedWriter ( new FileWriter ( out ) ) ; String s = null ; while ( ( s = inReader . readLine ( ) ) != null ) { String sNormal = s . replace ( '\\' , '/' ) ; outWriter . write ( sNormal ) ; outWriter . newLine ( ) ; } } finally { if ( inReader != null ) { inReader . close ( ) ; } if ( outWriter != null ) { outWriter . close ( ) ; } } } public String getRepository ( ) { return repository ; } public String getFilenameFormat ( ) { return filenameFormat ; } public void setFilenameFormat ( String f ) { filenameFormat = f ; } public String getLineStart ( ) { return lineStart ; } public void setLineStart ( String l ) { lineStart = l ; } public void setRepository ( String repo ) { repository = repo ; } public String getPvcsproject ( ) { return pvcsProject ; } public void setPvcsproject ( String prj ) { pvcsProject = prj ; } public Vector getPvcsprojects ( ) { return pvcsProjects ; } public String getWorkspace ( ) { return workspace ; } public void setWorkspace ( String ws ) { workspace = ws ; } public String getPvcsbin ( ) { return pvcsbin ; } public void setPvcsbin ( String bin ) { pvcsbin = bin ; } public String getForce ( ) { return force ; } public void setForce ( String f ) { if ( f != null && f . equalsIgnoreCase ( "yes" ) ) { force = "yes" ; } else { force = "no" ; } } public String getPromotiongroup ( ) { return promotiongroup ; } public void setPromotiongroup ( String w ) { promotiongroup = w ; } public String getLabel ( ) { return label ; } public void setLabel ( String l ) { label = l ; } public String getRevision ( ) { return revision ; } public void setRevision ( String r ) { revision = r ; } public boolean getIgnoreReturnCode ( ) { return ignorerc ; } public void setIgnoreReturnCode ( boolean b ) { ignorerc = b ; } public void addPvcsproject ( PvcsProject p ) { pvcsProjects . addElement ( p ) ; } public boolean getUpdateOnly ( ) { return updateOnly ; } public void setUpdateOnly ( boolean l ) { updateOnly = l ; } public String getConfig ( ) { return config ; } public void setConfig ( File f ) { config = f . toString ( ) ; } public String getUserId ( ) { return userId ; } public void setUserId ( String u ) { userId = u ; } public Pvcs ( ) { super ( ) ; pvcsProject = null ; pvcsProjects = new Vector ( ) ; workspace = null ; repository = null ; pvcsbin = null ; force = null ; promotiongroup = null ; label = null ; ignorerc = false ; updateOnly = false ; lineStart = "\"P:" ; filenameFormat = "{0}-arc({1})" ; } } 	0	['36', '3', '0', '12', '111', '528', '0', '12', '32', '0.947142857', '1006', '1', '0', '0.513888889', '0.222222222', '2', '2', '26.38888889', '3', '1.0833', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NoneSelector extends BaseSelectorContainer { public NoneSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{noneselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '9', '14', '3', '8', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '22', '1', '0', '21', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . regexp . Regexp ; public class ContainsRegexpSelector extends BaseExtendSelector implements ResourceSelector { private String userProvidedExpression = null ; private RegularExpression myRegExp = null ; private Regexp myExpression = null ; public static final String EXPRESSION_KEY = "expression" ; public ContainsRegexpSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsregexpselector expression: " ) ; buf . append ( userProvidedExpression ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setExpression ( String theexpression ) { this . userProvidedExpression = theexpression ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( EXPRESSION_KEY . equalsIgnoreCase ( paramname ) ) { setExpression ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( userProvidedExpression == null ) { setError ( "The expression attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( new FileResource ( file ) ) ; } public boolean isSelected ( Resource r ) { String teststr = null ; BufferedReader in = null ; validate ( ) ; if ( r . isDirectory ( ) ) { return true ; } if ( myRegExp == null ) { myRegExp = new RegularExpression ( ) ; myRegExp . setPattern ( userProvidedExpression ) ; myExpression = myRegExp . getRegexp ( getProject ( ) ) ; } try { in = new BufferedReader ( new InputStreamReader ( r . getInputStream ( ) ) ) ; } catch ( Exception e ) { throw new BuildException ( "Could not get InputStream from " + r . toLongString ( ) , e ) ; } try { teststr = in . readLine ( ) ; while ( teststr != null ) { if ( myExpression . matches ( teststr ) ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read " + r . toLongString ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close " + r . toLongString ( ) ) ; } } } } } 	0	['7', '5', '0', '15', '32', '1', '6', '9', '7', '0.625', '209', '0.75', '2', '0.863636364', '0.342857143', '1', '4', '28.28571429', '9', '2.5714', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2Resource extends CompressedResource { private static final char [ ] MAGIC = new char [ ] { 'B' , 'Z' } ; public BZip2Resource ( ) { } public BZip2Resource ( org . apache . tools . ant . types . ResourceCollection other ) { super ( other ) ; } protected InputStream wrapStream ( InputStream in ) throws IOException { for ( int i = 0 ; i < MAGIC . length ; i ++ ) { if ( in . read ( ) != MAGIC [ i ] ) { throw new IOException ( "Invalid bz2 stream." ) ; } } return new CBZip2InputStream ( in ) ; } protected OutputStream wrapStream ( OutputStream out ) throws IOException { for ( int i = 0 ; i < MAGIC . length ; i ++ ) { out . write ( MAGIC [ i ] ) ; } return new CBZip2OutputStream ( out ) ; } protected String getCompressionName ( ) { return "Bzip2" ; } } 	0	['6', '5', '0', '4', '13', '9', '0', '4', '2', '0.6', '70', '1', '0', '0.961538462', '0.4', '1', '2', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . SftpException ; import com . jcraft . jsch . SftpProgressMonitor ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Iterator ; public class ScpToMessageBySftp extends ScpToMessage { private File localFile ; private String remotePath ; private List directoryList ; public ScpToMessageBySftp ( boolean verbose , Session session , File aLocalFile , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . localFile = aLocalFile ; } public ScpToMessageBySftp ( boolean verbose , Session session , List aDirectoryList , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . directoryList = aDirectoryList ; } private ScpToMessageBySftp ( boolean verbose , Session session , String aRemotePath ) { super ( verbose , session ) ; this . remotePath = aRemotePath ; } public ScpToMessageBySftp ( Session session , File aLocalFile , String aRemotePath ) { this ( false , session , aLocalFile , aRemotePath ) ; } public ScpToMessageBySftp ( Session session , List aDirectoryList , String aRemotePath ) { this ( false , session , aDirectoryList , aRemotePath ) ; } public void execute ( ) throws IOException , JSchException { if ( directoryList != null ) { doMultipleTransfer ( ) ; } if ( localFile != null ) { doSingleTransfer ( ) ; } log ( "done.\n" ) ; } private void doSingleTransfer ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { sendFileToRemote ( channel , localFile , remotePath ) ; } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void doMultipleTransfer ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { channel . cd ( remotePath ) ; for ( Iterator i = directoryList . iterator ( ) ; i . hasNext ( ) ; ) { Directory current = ( Directory ) i . next ( ) ; sendDirectory ( channel , current ) ; } } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void sendDirectory ( ChannelSftp channel , Directory current ) throws IOException , SftpException { for ( Iterator fileIt = current . filesIterator ( ) ; fileIt . hasNext ( ) ; ) { sendFileToRemote ( channel , ( File ) fileIt . next ( ) , null ) ; } for ( Iterator dirIt = current . directoryIterator ( ) ; dirIt . hasNext ( ) ; ) { Directory dir = ( Directory ) dirIt . next ( ) ; sendDirectoryToRemote ( channel , dir ) ; } } private void sendDirectoryToRemote ( ChannelSftp channel , Directory directory ) throws IOException , SftpException { String dir = directory . getDirectory ( ) . getName ( ) ; try { channel . stat ( dir ) ; } catch ( SftpException e ) { if ( e . id == ChannelSftp . SSH_FX_NO_SUCH_FILE ) { channel . mkdir ( dir ) ; } } channel . cd ( dir ) ; sendDirectory ( channel , directory ) ; channel . cd ( ".." ) ; } private void sendFileToRemote ( ChannelSftp channel , File localFile , String remotePath ) throws IOException , SftpException { long filesize = localFile . length ( ) ; if ( remotePath == null ) { remotePath = localFile . getName ( ) ; } long startTime = System . currentTimeMillis ( ) ; long totalLength = filesize ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; SftpProgressMonitor monitor = null ; if ( trackProgress ) { monitor = getProgressMonitor ( ) ; } try { if ( this . getVerbose ( ) ) { log ( "Sending: " + localFile . getName ( ) + " : " + filesize ) ; } channel . put ( localFile . getAbsolutePath ( ) , remotePath , monitor ) ; } finally { if ( this . getVerbose ( ) ) { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , ( int ) totalLength ) ; } } } public File getLocalFile ( ) { return localFile ; } public String getRemotePath ( ) { return remotePath ; } } 	0	['13', '3', '0', '9', '41', '48', '1', '8', '7', '0.583333333', '285', '1', '0', '0.703703704', '0.355769231', '2', '3', '20.69230769', '1', '0.6154', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; public class Assertions extends DataType implements Cloneable { private Boolean enableSystemAssertions ; private ArrayList assertionList = new ArrayList ( ) ; public void addEnable ( EnabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void addDisable ( DisabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void setEnableSystemAssertions ( Boolean enableSystemAssertions ) { checkAttributesAllowed ( ) ; this . enableSystemAssertions = enableSystemAssertions ; } public void setRefid ( Reference ref ) { if ( assertionList . size ( ) > 0 || enableSystemAssertions != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( ref ) ; } private Assertions getFinalReference ( ) { if ( getRefid ( ) == null ) { return this ; } else { Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Assertions ) ) { throw new BuildException ( "reference is of wrong type" ) ; } return ( Assertions ) o ; } } public int size ( ) { Assertions clause = getFinalReference ( ) ; return clause . getFinalSize ( ) ; } private int getFinalSize ( ) { return assertionList . size ( ) + ( enableSystemAssertions != null ? 1 : 0 ) ; } public void applyAssertions ( List commandList ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandList . add ( arg ) ; } } public void applyAssertions ( CommandlineJava command ) { Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; addVmArgument ( command , arg ) ; } } public void applyAssertions ( final ListIterator commandIterator ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandIterator . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandIterator . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandIterator . add ( arg ) ; } } private static void addVmArgument ( CommandlineJava command , String arg ) { Commandline . Argument argument ; argument = command . createVmArgument ( ) ; argument . setValue ( arg ) ; } public Object clone ( ) throws CloneNotSupportedException { Assertions that = ( Assertions ) super . clone ( ) ; that . assertionList = ( ArrayList ) assertionList . clone ( ) ; return that ; } public abstract static class BaseAssertion { private String packageName ; private String className ; public void setClass ( String className ) { this . className = className ; } public void setPackage ( String packageName ) { this . packageName = packageName ; } protected String getClassName ( ) { return className ; } protected String getPackageName ( ) { return packageName ; } public abstract String getCommandPrefix ( ) ; public String toCommand ( ) { if ( getPackageName ( ) != null && getClassName ( ) != null ) { throw new BuildException ( "Both package and class have been set" ) ; } StringBuffer command = new StringBuffer ( getCommandPrefix ( ) ) ; if ( getPackageName ( ) != null ) { command . append ( ':' ) ; command . append ( getPackageName ( ) ) ; if ( ! command . toString ( ) . endsWith ( "..." ) ) { command . append ( "..." ) ; } } else if ( getClassName ( ) != null ) { command . append ( ':' ) ; command . append ( getClassName ( ) ) ; } return command . toString ( ) ; } } public static class EnabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-ea" ; } } public static class DisabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-da" ; } } } 	0	['13', '3', '0', '11', '40', '0', '3', '9', '10', '0.375', '289', '1', '0', '0.714285714', '0.179487179', '2', '3', '21.07692308', '4', '2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . XSLTProcess ; import org . apache . tools . ant . taskdefs . Delete ; import org . apache . tools . ant . taskdefs . TempFile ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . URLResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . w3c . dom . Document ; public class AggregateTransformer { public static final String FRAMES = "frames" ; public static final String NOFRAMES = "noframes" ; public static class Format extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { FRAMES , NOFRAMES } ; } } protected Task task ; protected Document document ; protected File styleDir ; protected File toDir ; private List params ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static int counter = 0 ; protected String format = FRAMES ; private static DocumentBuilderFactory privateDBFactory ; protected static DocumentBuilderFactory dbfactory ; static { privateDBFactory = DocumentBuilderFactory . newInstance ( ) ; dbfactory = privateDBFactory ; } public AggregateTransformer ( Task task ) { this . task = task ; params = new Vector ( ) ; } protected static DocumentBuilderFactory getDocumentBuilderFactory ( ) { return privateDBFactory ; } public void setFormat ( Format format ) { this . format = format . getValue ( ) ; } public void setXmlDocument ( Document doc ) { this . document = doc ; } protected void setXmlfile ( File xmlfile ) throws BuildException { try { DocumentBuilder builder = privateDBFactory . newDocumentBuilder ( ) ; InputStream in = new FileInputStream ( xmlfile ) ; try { Document doc = builder . parse ( in ) ; setXmlDocument ( doc ) ; } finally { in . close ( ) ; } } catch ( Exception e ) { throw new BuildException ( "Error while parsing document: " + xmlfile , e ) ; } } public void setStyledir ( File styledir ) { this . styleDir = styledir ; } public void setTodir ( File todir ) { this . toDir = todir ; } public void setExtension ( String ext ) { task . log ( "extension is not used anymore" , Project . MSG_WARN ) ; } public XSLTProcess . Param createParam ( ) { XSLTProcess . Param p = new XSLTProcess . Param ( ) ; params . add ( p ) ; return p ; } public void transform ( ) throws BuildException { checkOptions ( ) ; Project project = task . getProject ( ) ; TempFile tempFileTask = new TempFile ( ) ; tempFileTask . bindToOwner ( task ) ; XSLTProcess xsltTask = new XSLTProcess ( ) ; xsltTask . bindToOwner ( task ) ; xsltTask . setXslResource ( getStylesheet ( ) ) ; xsltTask . setIn ( ( ( XMLResultAggregator ) task ) . getDestinationFile ( ) ) ; File outputFile = null ; if ( format . equals ( FRAMES ) ) { String tempFileProperty = getClass ( ) . getName ( ) + String . valueOf ( counter ++ ) ; File tmp = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , project . getProperty ( "java.io.tmpdir" ) ) ; tempFileTask . setDestDir ( tmp ) ; tempFileTask . setProperty ( tempFileProperty ) ; tempFileTask . execute ( ) ; outputFile = new File ( project . getProperty ( tempFileProperty ) ) ; } else { outputFile = new File ( toDir , "junit-noframes.html" ) ; } xsltTask . setOut ( outputFile ) ; for ( Iterator i = params . iterator ( ) ; i . hasNext ( ) ; ) { XSLTProcess . Param param = ( XSLTProcess . Param ) i . next ( ) ; XSLTProcess . Param newParam = xsltTask . createParam ( ) ; newParam . setProject ( task . getProject ( ) ) ; newParam . setName ( param . getName ( ) ) ; newParam . setExpression ( param . getExpression ( ) ) ; } XSLTProcess . Param paramx = xsltTask . createParam ( ) ; paramx . setProject ( task . getProject ( ) ) ; paramx . setName ( "output.dir" ) ; paramx . setExpression ( toDir . getAbsolutePath ( ) ) ; final long t0 = System . currentTimeMillis ( ) ; try { xsltTask . execute ( ) ; } catch ( Exception e ) { throw new BuildException ( "Errors while applying transformations: " + e . getMessage ( ) , e ) ; } final long dt = System . currentTimeMillis ( ) - t0 ; task . log ( "Transform time: " + dt + "ms" ) ; if ( format . equals ( FRAMES ) ) { Delete delete = new Delete ( ) ; delete . bindToOwner ( task ) ; delete . setFile ( outputFile ) ; delete . execute ( ) ; } } protected Resource getStylesheet ( ) { String xslname = "junit-frames.xsl" ; if ( NOFRAMES . equals ( format ) ) { xslname = "junit-noframes.xsl" ; } if ( styleDir == null ) { URLResource stylesheet = new URLResource ( ) ; URL stylesheetURL = getClass ( ) . getClassLoader ( ) . getResource ( "org/apache/tools/ant/taskdefs/optional/junit/xsl/" + xslname ) ; stylesheet . setURL ( stylesheetURL ) ; return stylesheet ; } FileResource stylesheet = new FileResource ( ) ; File stylesheetFile = new File ( styleDir , xslname ) ; stylesheet . setFile ( stylesheetFile ) ; return stylesheet ; } protected void checkOptions ( ) throws BuildException { if ( toDir == null ) { toDir = task . getProject ( ) . resolveFile ( "." ) ; } else if ( ! toDir . isAbsolute ( ) ) { toDir = task . getProject ( ) . resolveFile ( toDir . getPath ( ) ) ; } } protected String getStylesheetSystemId ( ) throws IOException { String xslname = "junit-frames.xsl" ; if ( NOFRAMES . equals ( format ) ) { xslname = "junit-noframes.xsl" ; } if ( styleDir == null ) { URL url = getClass ( ) . getResource ( "xsl/" + xslname ) ; if ( url == null ) { throw new FileNotFoundException ( "Could not find jar resource " + xslname ) ; } return url . toExternalForm ( ) ; } File file = new File ( styleDir , xslname ) ; if ( ! file . exists ( ) ) { throw new FileNotFoundException ( "Could not find file '" + file + "'" ) ; } return JAXPUtils . getSystemId ( file ) ; } } 	0	['14', '1', '0', '16', '86', '41', '3', '14', '8', '0.891025641', '451', '0.833333333', '2', '0', '0.243589744', '0', '0', '30.35714286', '3', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . DescendingVisitor ; import org . apache . bcel . classfile . JavaClass ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class FullAnalyzer extends AbstractAnalyzer { public FullAnalyzer ( ) { try { new ClassParser ( "force" ) ; } catch ( IOException e ) { } } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 2 ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { DependencyVisitor dependencyVisitor = new DependencyVisitor ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ClassParser parser = null ; if ( container . getName ( ) . endsWith ( ".class" ) ) { parser = new ClassParser ( container . getPath ( ) ) ; } else { parser = new ClassParser ( container . getPath ( ) , classname . replace ( '.' , '/' ) + ".class" ) ; } JavaClass javaClass = parser . parse ( ) ; DescendingVisitor traverser = new DescendingVisitor ( javaClass , dependencyVisitor ) ; traverser . visit ( ) ; } catch ( IOException ioe ) { } } toAnalyze . clear ( ) ; Enumeration depsEnum = dependencyVisitor . getDependencies ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; if ( ! dependencies . containsKey ( className ) ) { toAnalyze . put ( className , className ) ; } } } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	0	['3', '2', '0', '6', '32', '3', '0', '6', '1', '2', '185', '0', '0', '0.882352941', '0.666666667', '1', '2', '60.66666667', '12', '4.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; public interface LogListener { void log ( String message ) ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private boolean running = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { super ( "ProcessDestroyer Shutdown Hook" ) ; } public void run ( ) { if ( shouldDestroy ) { ProcessDestroyer . this . run ( ) ; } } public void setShouldDestroy ( boolean shouldDestroy ) { this . shouldDestroy = shouldDestroy ; } } public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; addShutdownHookMethod = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; removeShutdownHookMethod = Runtime . class . getMethod ( "removeShutdownHook" , paramTypes ) ; } catch ( NoSuchMethodException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void addShutdownHook ( ) { if ( addShutdownHookMethod != null && ! running ) { destroyProcessThread = new ProcessDestroyerImpl ( ) ; Object [ ] args = { destroyProcessThread } ; try { addShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; added = true ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t != null && t . getClass ( ) == IllegalStateException . class ) { running = true ; } else { e . printStackTrace ( ) ; } } } } private void removeShutdownHook ( ) { if ( removeShutdownHookMethod != null && added && ! running ) { Object [ ] args = { destroyProcessThread } ; try { Boolean removed = ( Boolean ) removeShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; if ( ! removed . booleanValue ( ) ) { System . err . println ( "Could not remove shutdown hook" ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t != null && t . getClass ( ) == IllegalStateException . class ) { running = true ; } else { e . printStackTrace ( ) ; } } destroyProcessThread . setShouldDestroy ( false ) ; if ( ! destroyProcessThread . getThreadGroup ( ) . isDestroyed ( ) ) { destroyProcessThread . start ( ) ; } try { destroyProcessThread . join ( 20000 ) ; } catch ( InterruptedException ie ) { } destroyProcessThread = null ; added = false ; } } public boolean isAddedAsShutdownHook ( ) { return added ; } public boolean add ( Process process ) { synchronized ( processes ) { if ( processes . size ( ) == 0 ) { addShutdownHook ( ) ; } processes . addElement ( process ) ; return processes . contains ( process ) ; } } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( processRemoved && processes . size ( ) == 0 ) { removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { synchronized ( processes ) { running = true ; Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } } } } 	0	['7', '1', '0', '2', '36', '0', '2', '1', '5', '0.555555556', '335', '0.666666667', '1', '0', '0.642857143', '0', '0', '45.57142857', '9', '3.2857', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Name extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return foo . getName ( ) . compareTo ( bar . getName ( ) ) ; } } 	0	['2', '4', '0', '2', '5', '1', '0', '2', '1', '2', '11', '0', '0', '0.971428571', '0.75', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public class EscapeUnicode extends BaseParamFilterReader implements ChainableReader { private StringBuffer unicodeBuf ; public EscapeUnicode ( ) { super ( ) ; unicodeBuf = new StringBuffer ( ) ; } public EscapeUnicode ( final Reader in ) { super ( in ) ; unicodeBuf = new StringBuffer ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( unicodeBuf . length ( ) == 0 ) { ch = in . read ( ) ; if ( ch != - 1 ) { char achar = ( char ) ch ; if ( achar >= '' ) { unicodeBuf = new StringBuffer ( "u0000" ) ; String s = Integer . toHexString ( ch ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { unicodeBuf . setCharAt ( unicodeBuf . length ( ) - s . length ( ) + i , s . charAt ( i ) ) ; } ch = '\\' ; } } } else { ch = ( int ) unicodeBuf . charAt ( 0 ) ; unicodeBuf . deleteCharAt ( 0 ) ; } return ch ; } public final Reader chain ( final Reader rdr ) { EscapeUnicode newFilter = new EscapeUnicode ( rdr ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { } } 	0	['5', '5', '0', '3', '19', '4', '1', '2', '4', '0.25', '107', '1', '0', '0.903225806', '0.7', '2', '5', '20.2', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public abstract class DefaultNative2Ascii implements Native2AsciiAdapter { public DefaultNative2Ascii ( ) { } public final boolean convert ( Native2Ascii args , File srcFile , File destFile ) throws BuildException { Commandline cmd = new Commandline ( ) ; setup ( cmd , args ) ; addFiles ( cmd , args , srcFile , destFile ) ; return run ( cmd , args ) ; } protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getEncoding ( ) != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( args . getEncoding ( ) ) ; } cmd . addArguments ( args . getCurrentArgs ( ) ) ; } protected void addFiles ( Commandline cmd , ProjectComponent log , File src , File dest ) throws BuildException { cmd . createArgument ( ) . setFile ( src ) ; cmd . createArgument ( ) . setFile ( dest ) ; } protected abstract boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException ; } 	0	['5', '1', '2', '8', '13', '10', '2', '6', '2', '2', '53', '0', '0', '0', '0.56', '0', '0', '9.6', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; public class RegexpUtil { public static boolean hasFlag ( int options , int flag ) { return ( ( options & flag ) > 0 ) ; } public static int removeFlag ( int options , int flag ) { return ( options & ( 0xFFFFFFFF - flag ) ) ; } } 	0	['3', '1', '0', '6', '4', '3', '6', '0', '3', '2', '20', '0', '0', '0', '0.5', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . Project ; public class PropertyOutputStream extends ByteArrayOutputStream { private Project project ; private String property ; private boolean trim ; public PropertyOutputStream ( Project p , String s ) { this ( p , s , true ) ; } public PropertyOutputStream ( Project p , String s , boolean b ) { project = p ; property = s ; trim = b ; } public void close ( ) { if ( project != null && property != null ) { String s = new String ( toByteArray ( ) ) ; project . setNewProperty ( property , trim ? s . trim ( ) : s ) ; } } } 	0	['3', '3', '0', '3', '8', '1', '2', '1', '3', '0', '49', '1', '1', '0.9375', '0.666666667', '0', '0', '14.33333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Ant ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class AntResolver implements ExtensionResolver { private File antfile ; private File destfile ; private String target ; public void setAntfile ( final File antfile ) { this . antfile = antfile ; } public void setDestfile ( final File destfile ) { this . destfile = destfile ; } public void setTarget ( final String target ) { this . target = target ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { validate ( ) ; final Ant ant = new Ant ( ) ; ant . setProject ( project ) ; ant . setInheritAll ( false ) ; ant . setAntfile ( antfile . getName ( ) ) ; try { final File dir = antfile . getParentFile ( ) . getCanonicalFile ( ) ; ant . setDir ( dir ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } if ( null != target ) { ant . setTarget ( target ) ; } ant . execute ( ) ; return destfile ; } private void validate ( ) { if ( null == antfile ) { final String message = "Must specify Buildfile" ; throw new BuildException ( message ) ; } if ( null == destfile ) { final String message = "Must specify destination file" ; throw new BuildException ( message ) ; } } public String toString ( ) { return "Ant[" + antfile + "==>" + destfile + "]" ; } } 	0	['7', '1', '0', '6', '25', '1', '1', '5', '6', '0.611111111', '104', '1', '0', '0', '0.342857143', '0', '0', '13.42857143', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . JSch ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public abstract class SSHBase extends Task implements LogListener { private static final int SSH_PORT = 22 ; private String host ; private String knownHosts ; private int port = SSH_PORT ; private boolean failOnError = true ; private boolean verbose ; private SSHUserInfo userInfo ; public SSHBase ( ) { super ( ) ; userInfo = new SSHUserInfo ( ) ; } public void setHost ( String host ) { this . host = host ; } public String getHost ( ) { return host ; } public void setFailonerror ( boolean failure ) { failOnError = failure ; } public boolean getFailonerror ( ) { return failOnError ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setUsername ( String username ) { userInfo . setName ( username ) ; } public void setPassword ( String password ) { userInfo . setPassword ( password ) ; } public void setKeyfile ( String keyfile ) { userInfo . setKeyfile ( keyfile ) ; } public void setPassphrase ( String passphrase ) { userInfo . setPassphrase ( passphrase ) ; } public void setKnownhosts ( String knownHosts ) { this . knownHosts = knownHosts ; } public void setTrust ( boolean yesOrNo ) { userInfo . setTrust ( yesOrNo ) ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return port ; } public void init ( ) throws BuildException { super . init ( ) ; this . knownHosts = System . getProperty ( "user.home" ) + "/.ssh/known_hosts" ; this . port = SSH_PORT ; } protected Session openSession ( ) throws JSchException { JSch jsch = new JSch ( ) ; if ( null != userInfo . getKeyfile ( ) ) { jsch . addIdentity ( userInfo . getKeyfile ( ) ) ; } if ( ! userInfo . getTrust ( ) && knownHosts != null ) { log ( "Using known hosts: " + knownHosts , Project . MSG_DEBUG ) ; jsch . setKnownHosts ( knownHosts ) ; } Session session = jsch . getSession ( userInfo . getName ( ) , host , port ) ; session . setUserInfo ( userInfo ) ; log ( "Connecting to " + host + ":" + port ) ; session . connect ( ) ; return session ; } protected SSHUserInfo getUserInfo ( ) { return userInfo ; } } 	0	['18', '3', '2', '10', '43', '61', '2', '8', '16', '0.857142857', '184', '1', '1', '0.685185185', '0.388888889', '0', '0', '8.833333333', '1', '0.9444', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . ArrayList ; import org . apache . tools . ant . types . FileSet ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; public class DotnetResource { private File file ; private boolean embed = true ; private Boolean isPublic = null ; private String name = null ; private ArrayList fileSets = new ArrayList ( ) ; private String namespace = null ; public boolean isEmbed ( ) { return embed ; } public void setEmbed ( boolean embed ) { this . embed = embed ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public Boolean getPublic ( ) { return isPublic ; } public void setPublic ( Boolean aPublic ) { isPublic = aPublic ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace == null ) { this . namespace = null ; } else { this . namespace = ( namespace . length ( ) == 0 || namespace . endsWith ( "." ) ? namespace : namespace + '.' ) ; } } private void checkParameters ( ) { if ( hasFilesets ( ) ) { if ( getName ( ) != null ) { throw new BuildException ( "Cannot use <resource name=\"...\"> attribute with filesets" ) ; } if ( getFile ( ) != null ) { throw new BuildException ( "Cannot use <resource file=\"...\"> attribute with filesets" ) ; } } else { if ( getNamespace ( ) != null ) { throw new BuildException ( "Cannot use <resource namespace=\"...\"> attribute without filesets" ) ; } } } public void getParameters ( Project p , NetCommand command , boolean csharpStyle ) { checkParameters ( ) ; if ( hasFilesets ( ) ) { for ( Iterator listIter = fileSets . iterator ( ) ; listIter . hasNext ( ) ; ) { FileSet fs = ( FileSet ) listIter . next ( ) ; String baseDirectory = fs . getDir ( p ) . toString ( ) ; String namespace = getNamespace ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( p ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String file = files [ i ] ; command . addArgument ( getParameter ( baseDirectory + File . separatorChar + file , ( namespace == null ? null : namespace + file . replace ( File . separatorChar , '.' ) ) , csharpStyle ) ) ; } } } else { command . addArgument ( getParameter ( getFile ( ) . toString ( ) , getName ( ) , csharpStyle ) ) ; } } private String getParameter ( String fileName , String name , boolean csharpStyle ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( isEmbed ( ) ? "/resource" : "/linkresource" ) ; buffer . append ( ':' ) ; buffer . append ( fileName ) ; if ( name != null ) { buffer . append ( ',' ) ; buffer . append ( name ) ; if ( csharpStyle ) { if ( getPublic ( ) != null ) { throw new BuildException ( "This compiler does not support the " + "public/private option." ) ; } else { if ( getPublic ( ) != null ) { buffer . append ( ',' ) ; buffer . append ( getPublic ( ) . booleanValue ( ) ? "public" : "private" ) ; } } } else if ( getPublic ( ) != null ) { throw new BuildException ( "You cannot have a public or private " + "option without naming the resource" ) ; } } return buffer . toString ( ) ; } public void addFileset ( FileSet fileset ) { fileSets . add ( fileset ) ; } public boolean hasFilesets ( ) { return fileSets . size ( ) > 0 ; } } 	0	['16', '1', '0', '9', '39', '82', '4', '5', '14', '0.766666667', '297', '1', '0', '0', '0.2109375', '0', '0', '17.1875', '8', '2.125', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class LongCPInfo extends ConstantCPInfo { public LongCPInfo ( ) { super ( CONSTANT_LONG , 2 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Long ( cpStream . readLong ( ) ) ) ; } public String toString ( ) { return "Long Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipResource ( getSrcResource ( ) , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( zOut ) ; } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( BZip2 . class ) ; } } 	0	['3', '4', '0', '6', '22', '3', '0', '6', '1', '1', '82', '0', '0', '0.961538462', '1', '2', '4', '26', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class StringCPInfo extends ConstantCPInfo { public StringCPInfo ( ) { super ( CONSTANT_STRING , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { index = cpStream . readUnsignedShort ( ) ; setValue ( "unresolved" ) ; } public String toString ( ) { return "String Constant Pool Entry for " + getValue ( ) + "[" + index + "]" ; } public void resolve ( ConstantPool constantPool ) { setValue ( ( ( Utf8CPInfo ) constantPool . getEntry ( index ) ) . getValue ( ) ) ; super . resolve ( constantPool ) ; } private int index ; } 	0	['4', '3', '0', '4', '16', '0', '1', '4', '4', '0.333333333', '46', '1', '0', '0.727272727', '0.5', '2', '3', '10.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . util . LineOrientedOutputStream ; class RedirectingOutputStream extends LineOrientedOutputStream { private final ChangeLogParser parser ; public RedirectingOutputStream ( final ChangeLogParser parser ) { this . parser = parser ; } protected void processLine ( final String line ) { parser . stdout ( line ) ; } } 	0	['2', '3', '0', '3', '4', '0', '1', '2', '1', '0', '14', '1', '1', '0.916666667', '0.666666667', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public abstract class BaseFilterReader extends FilterReader { private static final int BUFFER_SIZE = 8192 ; private boolean initialized = false ; private Project project = null ; public BaseFilterReader ( ) { super ( new StringReader ( "" ) ) ; FileUtils . close ( this ) ; } public BaseFilterReader ( final Reader in ) { super ( in ) ; } public final int read ( final char [ ] cbuf , final int off , final int len ) throws IOException { for ( int i = 0 ; i < len ; i ++ ) { final int ch = read ( ) ; if ( ch == - 1 ) { if ( i == 0 ) { return - 1 ; } else { return i ; } } cbuf [ off + i ] = ( char ) ch ; } return len ; } public final long skip ( final long n ) throws IOException , IllegalArgumentException { if ( n < 0L ) { throw new IllegalArgumentException ( "skip value is negative" ) ; } for ( long i = 0 ; i < n ; i ++ ) { if ( read ( ) == - 1 ) { return i ; } } return n ; } protected final void setInitialized ( final boolean initialized ) { this . initialized = initialized ; } protected final boolean getInitialized ( ) { return initialized ; } public final void setProject ( final Project project ) { this . project = project ; } protected final Project getProject ( ) { return project ; } protected final String readLine ( ) throws IOException { int ch = in . read ( ) ; if ( ch == - 1 ) { return null ; } StringBuffer line = new StringBuffer ( ) ; while ( ch != - 1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n' ) { break ; } ch = in . read ( ) ; } return line . toString ( ) ; } protected final String readFully ( ) throws IOException { return FileUtils . readFully ( in , BUFFER_SIZE ) ; } } 	0	['10', '3', '6', '9', '20', '21', '7', '2', '5', '0.814814815', '146', '1', '1', '0.692307692', '0.228571429', '1', '2', '13.3', '1', '0.8', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class DirSet extends AbstractFileSet implements ResourceCollection { public DirSet ( ) { super ( ) ; } protected DirSet ( DirSet dirset ) { super ( dirset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( getDir ( getProject ( ) ) , getDirectoryScanner ( getProject ( ) ) . getIncludedDirectories ( ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( getProject ( ) ) . getIncludedDirsCount ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } public String toString ( ) { DirectoryScanner ds = getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( i > 0 ) { sb . append ( ';' ) ; } sb . append ( dirs [ i ] ) ; } return sb . toString ( ) ; } } 	0	['7', '4', '0', '9', '22', '21', '4', '5', '6', '2', '103', '0', '0', '0.945652174', '0.571428571', '3', '5', '13.71428571', '3', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public final class SunNative2Ascii extends DefaultNative2Ascii { public static final String IMPLEMENTATION_NAME = "sun" ; protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getReverse ( ) ) { cmd . createArgument ( ) . setValue ( "-reverse" ) ; } super . setup ( cmd , args ) ; } protected boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException { try { Class n2aMain = Class . forName ( "sun.tools.native2ascii.Main" ) ; Class [ ] param = new Class [ ] { String [ ] . class } ; Method convert = n2aMain . getMethod ( "convert" , param ) ; if ( convert == null ) { throw new BuildException ( "Could not find convert() method in " + "sun.tools.native2ascii.Main" ) ; } Object o = n2aMain . newInstance ( ) ; return ( ( Boolean ) convert . invoke ( o , new Object [ ] { cmd . getArguments ( ) } ) ) . booleanValue ( ) ; } catch ( BuildException ex ) { throw ex ; } catch ( Exception ex ) { throw new BuildException ( "Error starting Sun's native2ascii: " , ex ) ; } } } 	0	['3', '2', '0', '7', '18', '3', '1', '6', '1', '1.25', '82', '0', '0', '0.666666667', '0.583333333', '1', '2', '25.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class PreSetDef extends AntlibDefinition implements TaskContainer { private UnknownElement nestedTask ; private String name ; public void setName ( String name ) { this . name = name ; } public void addTask ( Task nestedTask ) { if ( this . nestedTask != null ) { throw new BuildException ( "Only one nested element allowed" ) ; } if ( ! ( nestedTask instanceof UnknownElement ) ) { throw new BuildException ( "addTask called with a task that is not an unknown element" ) ; } this . nestedTask = ( UnknownElement ) nestedTask ; } public void execute ( ) { if ( nestedTask == null ) { throw new BuildException ( "Missing nested element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( nestedTask . getNamespace ( ) , nestedTask . getTag ( ) ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { throw new BuildException ( "Unable to find typedef " + componentName ) ; } PreSetDefinition newDef = new PreSetDefinition ( def , nestedTask ) ; newDef . setName ( name ) ; helper . addDataTypeDefinition ( newDef ) ; log ( "defining preset " + name , Project . MSG_VERBOSE ) ; } public static class PreSetDefinition extends AntTypeDefinition { private AntTypeDefinition parent ; private UnknownElement element ; public PreSetDefinition ( AntTypeDefinition parent , UnknownElement el ) { if ( parent instanceof PreSetDefinition ) { PreSetDefinition p = ( PreSetDefinition ) parent ; el . applyPreSet ( p . element ) ; parent = p . parent ; } this . parent = parent ; this . element = el ; } public void setClass ( Class clazz ) { throw new BuildException ( "Not supported" ) ; } public void setClassName ( String className ) { throw new BuildException ( "Not supported" ) ; } public String getClassName ( ) { return parent . getClassName ( ) ; } public void setAdapterClass ( Class adapterClass ) { throw new BuildException ( "Not supported" ) ; } public void setAdaptToClass ( Class adaptToClass ) { throw new BuildException ( "Not supported" ) ; } public void setClassLoader ( ClassLoader classLoader ) { throw new BuildException ( "Not supported" ) ; } public ClassLoader getClassLoader ( ) { return parent . getClassLoader ( ) ; } public Class getExposedClass ( Project project ) { return parent . getExposedClass ( project ) ; } public Class getTypeClass ( Project project ) { return parent . getTypeClass ( project ) ; } public void checkClass ( Project project ) { parent . checkClass ( project ) ; } public Object createObject ( Project project ) { return parent . create ( project ) ; } public UnknownElement getPreSets ( ) { return element ; } public Object create ( Project project ) { return this ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) == getClass ( ) && parent != null && parent . sameDefinition ( ( ( PreSetDefinition ) other ) . parent , project ) && element . similar ( ( ( PreSetDefinition ) other ) . element ) ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) . getName ( ) . equals ( getClass ( ) . getName ( ) ) && parent != null && parent . similarDefinition ( ( ( PreSetDefinition ) other ) . parent , project ) && element . similar ( ( ( PreSetDefinition ) other ) . element ) ) ; } } } 	0	['4', '4', '0', '10', '20', '2', '0', '10', '4', '0.666666667', '112', '1', '1', '0.931818182', '0.5', '1', '1', '26.5', '4', '2', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JavahAdapterFactory { public static String getDefault ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { return Kaffeh . IMPLEMENTATION_NAME ; } return SunJavah . IMPLEMENTATION_NAME ; } public static JavahAdapter getAdapter ( String choice , ProjectComponent log ) throws BuildException { if ( ( JavaEnvUtils . isKaffe ( ) && choice == null ) || Kaffeh . IMPLEMENTATION_NAME . equals ( choice ) ) { return new Kaffeh ( ) ; } else if ( SunJavah . IMPLEMENTATION_NAME . equals ( choice ) ) { return new SunJavah ( ) ; } else if ( choice != null ) { return resolveClassName ( choice ) ; } return new SunJavah ( ) ; } private static JavahAdapter resolveClassName ( String className ) throws BuildException { return ( JavahAdapter ) ClasspathUtils . newInstance ( className , JavahAdapterFactory . class . getClassLoader ( ) , JavahAdapter . class ) ; } } 	0	['4', '1', '0', '8', '14', '6', '1', '7', '3', '0.666666667', '79', '0', '0', '0', '0.333333333', '0', '0', '18.25', '2', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; public class DelegatedResourceComparator extends ResourceComparator { private Vector v = null ; public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } v = ( v == null ) ? new Vector ( ) : v ; v . add ( c ) ; } public synchronized boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( o ) ; } if ( ! ( o instanceof DelegatedResourceComparator ) ) { return false ; } Vector ov = ( ( DelegatedResourceComparator ) o ) . v ; return v == null ? ov == null : v . equals ( ov ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return v == null ? 0 : v . hashCode ( ) ; } protected synchronized int resourceCompare ( Resource foo , Resource bar ) { if ( v == null || v . isEmpty ( ) ) { return foo . compareTo ( bar ) ; } int result = 0 ; for ( Iterator i = v . iterator ( ) ; result == 0 && i . hasNext ( ) ; ) { result = ( ( ResourceComparator ) i . next ( ) ) . resourceCompare ( foo , bar ) ; } return result ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( ! ( v == null || v . isEmpty ( ) ) ) { for ( Iterator i = v . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } } setChecked ( true ) ; } } } 	0	['6', '4', '0', '7', '27', '0', '2', '5', '4', '0', '169', '1', '0', '0.871794872', '0.305555556', '3', '7', '27', '6', '3.1667', '0']
package org . apache . tools . ant . util ; import java . util . StringTokenizer ; public class DeweyDecimal { private int [ ] components ; public DeweyDecimal ( final int [ ] components ) { this . components = new int [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { this . components [ i ] = components [ i ] ; } } public DeweyDecimal ( final String string ) throws NumberFormatException { final StringTokenizer tokenizer = new StringTokenizer ( string , "." , true ) ; final int size = tokenizer . countTokens ( ) ; components = new int [ ( size + 1 ) / 2 ] ; for ( int i = 0 ; i < components . length ; i ++ ) { final String component = tokenizer . nextToken ( ) ; if ( component . equals ( "" ) ) { throw new NumberFormatException ( "Empty component in string" ) ; } components [ i ] = Integer . parseInt ( component ) ; if ( tokenizer . hasMoreTokens ( ) ) { tokenizer . nextToken ( ) ; if ( ! tokenizer . hasMoreTokens ( ) ) { throw new NumberFormatException ( "DeweyDecimal ended in a '.'" ) ; } } } } public int getSize ( ) { return components . length ; } public int get ( final int index ) { return components [ index ] ; } public boolean isEqual ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 != component1 ) { return false ; } } return true ; } public boolean isLessThan ( final DeweyDecimal other ) { return ! isGreaterThanOrEqual ( other ) ; } public boolean isLessThanOrEqual ( final DeweyDecimal other ) { return ! isGreaterThan ( other ) ; } public boolean isGreaterThan ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 > component1 ) { return false ; } if ( component2 < component1 ) { return true ; } } return false ; } public boolean isGreaterThanOrEqual ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 > component1 ) { return false ; } if ( component2 < component1 ) { return true ; } } return true ; } public String toString ( ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( '.' ) ; } sb . append ( components [ i ] ) ; } return sb . toString ( ) ; } } 	0	['10', '1', '1', '4', '23', '0', '4', '0', '10', '0', '298', '1', '0', '0', '0.36', '0', '0', '28.7', '6', '2.6', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; public interface ChainableReader { Reader chain ( Reader rdr ) ; } 	0	['1', '1', '0', '23', '1', '0', '23', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . net . MalformedURLException ; import java . net . JarURLConnection ; import java . util . jar . JarFile ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; public class URLResource extends Resource { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final int NULL_URL = Resource . getMagicNumber ( "null URL" . getBytes ( ) ) ; private URL url ; private URLConnection conn ; public URLResource ( ) { } public URLResource ( URL u ) { setURL ( u ) ; } public URLResource ( File f ) { setFile ( f ) ; } public URLResource ( String u ) { this ( newURL ( u ) ) ; } public synchronized void setURL ( URL u ) { checkAttributesAllowed ( ) ; url = u ; } public synchronized void setFile ( File f ) { try { setURL ( FILE_UTILS . getFileURL ( f ) ) ; } catch ( MalformedURLException e ) { throw new BuildException ( e ) ; } } public synchronized URL getURL ( ) { if ( isReference ( ) ) { return ( ( URLResource ) getCheckedRef ( ) ) . getURL ( ) ; } return url ; } public synchronized void setRefid ( Reference r ) { if ( url != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public synchronized String getName ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getName ( ) : getURL ( ) . getFile ( ) . substring ( 1 ) ; } public synchronized String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : String . valueOf ( getURL ( ) ) ; } public synchronized boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } return isExists ( false ) ; } private synchronized boolean isExists ( boolean closeConnection ) { if ( getURL ( ) == null ) { return false ; } try { connect ( ) ; return true ; } catch ( IOException e ) { return false ; } finally { if ( closeConnection ) { close ( ) ; } } } public synchronized long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } if ( ! isExists ( false ) ) { return 0L ; } return conn . getLastModified ( ) ; } public synchronized boolean isDirectory ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) : getName ( ) . endsWith ( "/" ) ; } public synchronized long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } if ( ! isExists ( false ) ) { return 0L ; } try { connect ( ) ; long contentlength = conn . getContentLength ( ) ; close ( ) ; return contentlength ; } catch ( IOException e ) { return UNKNOWN_SIZE ; } } public synchronized boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } URLResource otheru = ( URLResource ) another ; return getURL ( ) == null ? otheru . getURL ( ) == null : getURL ( ) . equals ( otheru . getURL ( ) ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return MAGIC * ( ( getURL ( ) == null ) ? NULL_URL : getURL ( ) . hashCode ( ) ) ; } public synchronized InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } connect ( ) ; try { return conn . getInputStream ( ) ; } finally { conn = null ; } } public synchronized OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } connect ( ) ; try { return conn . getOutputStream ( ) ; } finally { conn = null ; } } protected synchronized void connect ( ) throws IOException { URL u = getURL ( ) ; if ( u == null ) { throw new BuildException ( "URL not set" ) ; } if ( conn == null ) { try { conn = u . openConnection ( ) ; conn . connect ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; conn = null ; throw e ; } } } private synchronized void close ( ) { if ( conn != null ) { try { if ( conn instanceof JarURLConnection ) { JarURLConnection juc = ( JarURLConnection ) conn ; JarFile jf = juc . getJarFile ( ) ; jf . close ( ) ; jf = null ; } else if ( conn instanceof HttpURLConnection ) { ( ( HttpURLConnection ) conn ) . disconnect ( ) ; } } catch ( IOException exc ) { } finally { conn = null ; } } } private static URL newURL ( String u ) { try { return new URL ( u ) ; } catch ( MalformedURLException e ) { throw new BuildException ( e ) ; } } } 	0	['23', '4', '0', '6', '64', '213', '2', '4', '18', '0.738636364', '409', '1', '1', '0.746478873', '0.194805195', '2', '13', '16.60869565', '6', '1.9565', '0']
package org . apache . tools . ant . listener ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogConfigurationException ; import org . apache . commons . logging . LogFactory ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import java . io . PrintStream ; public class CommonsLoggingListener implements BuildListener , BuildLogger { private boolean initialized = false ; private LogFactory logFactory ; public static final String TARGET_LOG = "org.apache.tools.ant.Target" ; public static final String PROJECT_LOG = "org.apache.tools.ant.Project" ; public CommonsLoggingListener ( ) { } private Log getLog ( String cat , String suffix ) { if ( suffix != null ) { suffix = suffix . replace ( '.' , '-' ) ; suffix = suffix . replace ( ' ' , '-' ) ; cat = cat + "." + suffix ; } PrintStream tmpOut = System . out ; PrintStream tmpErr = System . err ; System . setOut ( out ) ; System . setErr ( err ) ; if ( ! initialized ) { try { logFactory = LogFactory . getFactory ( ) ; } catch ( LogConfigurationException e ) { e . printStackTrace ( System . err ) ; return null ; } } initialized = true ; Log log = logFactory . getInstance ( cat ) ; System . setOut ( tmpOut ) ; System . setErr ( tmpErr ) ; return log ; } public void buildStarted ( BuildEvent event ) { String categoryString = PROJECT_LOG ; Log log = getLog ( categoryString , null ) ; if ( initialized ) { realLog ( log , "Build started." , Project . MSG_INFO , null ) ; } } public void buildFinished ( BuildEvent event ) { if ( initialized ) { String categoryString = PROJECT_LOG ; Log log = getLog ( categoryString , event . getProject ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { realLog ( log , "Build finished." , Project . MSG_INFO , null ) ; } else { realLog ( log , "Build finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void targetStarted ( BuildEvent event ) { if ( initialized ) { Log log = getLog ( TARGET_LOG , event . getTarget ( ) . getName ( ) ) ; realLog ( log , "Start: " + event . getTarget ( ) . getName ( ) , Project . MSG_VERBOSE , null ) ; } } public void targetFinished ( BuildEvent event ) { if ( initialized ) { String targetName = event . getTarget ( ) . getName ( ) ; Log log = getLog ( TARGET_LOG , event . getTarget ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { realLog ( log , "Target end: " + targetName , Project . MSG_DEBUG , null ) ; } else { realLog ( log , "Target \"" + targetName + "\" finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void taskStarted ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Object real = task ; if ( task instanceof UnknownElement ) { Object realObj = ( ( UnknownElement ) task ) . getTask ( ) ; if ( realObj != null ) { real = realObj ; } } Log log = getLog ( real . getClass ( ) . getName ( ) , null ) ; if ( log . isTraceEnabled ( ) ) { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" started " , Project . MSG_VERBOSE , null ) ; } } } public void taskFinished ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Object real = task ; if ( task instanceof UnknownElement ) { Object realObj = ( ( UnknownElement ) task ) . getTask ( ) ; if ( realObj != null ) { real = realObj ; } } Log log = getLog ( real . getClass ( ) . getName ( ) , null ) ; if ( event . getException ( ) == null ) { if ( log . isTraceEnabled ( ) ) { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" finished." , Project . MSG_VERBOSE , null ) ; } } else { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void messageLogged ( BuildEvent event ) { if ( initialized ) { Object categoryObject = event . getTask ( ) ; String categoryString = null ; String categoryDetail = null ; if ( categoryObject == null ) { categoryObject = event . getTarget ( ) ; if ( categoryObject == null ) { categoryObject = event . getProject ( ) ; categoryString = PROJECT_LOG ; categoryDetail = event . getProject ( ) . getName ( ) ; } else { categoryString = TARGET_LOG ; categoryDetail = event . getTarget ( ) . getName ( ) ; } } else { if ( event . getTarget ( ) != null ) { categoryString = categoryObject . getClass ( ) . getName ( ) ; categoryDetail = event . getTarget ( ) . getName ( ) ; } else { categoryString = categoryObject . getClass ( ) . getName ( ) ; } } Log log = getLog ( categoryString , categoryDetail ) ; int priority = event . getPriority ( ) ; String message = event . getMessage ( ) ; realLog ( log , message , priority , null ) ; } } private void realLog ( Log log , String message , int priority , Throwable t ) { PrintStream tmpOut = System . out ; PrintStream tmpErr = System . err ; System . setOut ( out ) ; System . setErr ( err ) ; switch ( priority ) { case Project . MSG_ERR : if ( t == null ) { log . error ( message ) ; } else { log . error ( message , t ) ; } break ; case Project . MSG_WARN : if ( t == null ) { log . warn ( message ) ; } else { log . warn ( message , t ) ; } break ; case Project . MSG_INFO : if ( t == null ) { log . info ( message ) ; } else { log . info ( message , t ) ; } break ; case Project . MSG_VERBOSE : log . debug ( message ) ; break ; case Project . MSG_DEBUG : log . debug ( message ) ; break ; default : log . error ( message ) ; break ; } System . setOut ( tmpOut ) ; System . setErr ( tmpErr ) ; } PrintStream out = System . out ; PrintStream err = System . err ; public void setMessageOutputLevel ( int level ) { } public void setOutputPrintStream ( PrintStream output ) { this . out = output ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { this . err = err ; } } 	0	['14', '1', '0', '10', '45', '3', '0', '10', '12', '0.576923077', '459', '0.333333333', '0', '0', '0.267857143', '0', '0', '31.35714286', '6', '2.7143', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . InvocationTargetException ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Properties ; import java . util . Set ; import java . util . Stack ; import org . apache . tools . ant . taskdefs . Typedef ; import org . apache . tools . ant . taskdefs . Definer ; import org . apache . tools . ant . launch . Launcher ; import org . apache . tools . ant . util . FileUtils ; public class ComponentHelper { private AntTypeTable antTypeTable ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private boolean rebuildTaskClassDefinitions = true ; private Hashtable typeClassDefinitions = new Hashtable ( ) ; private boolean rebuildTypeClassDefinitions = true ; private Set checkedNamespaces = new HashSet ( ) ; private Stack antLibStack = new Stack ( ) ; private String antLibCurrentUri = null ; private ComponentHelper next ; private Project project ; private static final String ERROR_NO_TASK_LIST_LOAD = "Can't load default task list" ; private static final String ERROR_NO_TYPE_LIST_LOAD = "Can't load default type list" ; public static final String COMPONENT_HELPER_REFERENCE = "ant.ComponentHelper" ; private static final String BUILD_SYSCLASSPATH_ONLY = "only" ; private static final String ANT_PROPERTY_TASK = "property" ; private static Properties [ ] defaultDefinitions = new Properties [ 2 ] ; public static ComponentHelper getComponentHelper ( Project project ) { if ( project == null ) { return null ; } ComponentHelper ph = ( ComponentHelper ) project . getReference ( COMPONENT_HELPER_REFERENCE ) ; if ( ph != null ) { return ph ; } ph = new ComponentHelper ( ) ; ph . setProject ( project ) ; project . addReference ( COMPONENT_HELPER_REFERENCE , ph ) ; return ph ; } protected ComponentHelper ( ) { } public void setNext ( ComponentHelper next ) { this . next = next ; } public ComponentHelper getNext ( ) { return next ; } public void setProject ( Project project ) { this . project = project ; antTypeTable = new AntTypeTable ( project ) ; } public void initSubProject ( ComponentHelper helper ) { AntTypeTable typeTable = helper . antTypeTable ; for ( Iterator i = typeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; antTypeTable . put ( def . getName ( ) , def ) ; } for ( Iterator i = helper . checkedNamespaces . iterator ( ) ; i . hasNext ( ) ; ) { checkedNamespaces . add ( i . next ( ) ) ; } } public Object createComponent ( UnknownElement ue , String ns , String componentType ) throws BuildException { Object component = createComponent ( componentType ) ; if ( component instanceof Task ) { Task task = ( Task ) component ; task . setLocation ( ue . getLocation ( ) ) ; task . setTaskType ( componentType ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . setOwningTarget ( ue . getOwningTarget ( ) ) ; task . init ( ) ; } return component ; } public Object createComponent ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; return ( def == null ) ? null : def . create ( project ) ; } public Class getComponentClass ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; return ( def == null ) ? null : def . getExposedClass ( project ) ; } public AntTypeDefinition getDefinition ( String componentName ) { checkNamespace ( componentName ) ; return antTypeTable . getDefinition ( componentName ) ; } public void initDefaultDefinitions ( ) { initTasks ( ) ; initTypes ( ) ; } public void addTaskDefinition ( String taskName , Class taskClass ) { checkTaskClass ( taskClass ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( taskName ) ; def . setClassLoader ( taskClass . getClassLoader ( ) ) ; def . setClass ( taskClass ) ; def . setAdapterClass ( TaskAdapter . class ) ; def . setClassName ( taskClass . getName ( ) ) ; def . setAdaptToClass ( Task . class ) ; updateDataTypeDefinition ( def ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , project ) ; } } public Hashtable getTaskDefinitions ( ) { synchronized ( taskClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTaskClassDefinitions ) { taskClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( Task . class . isAssignableFrom ( clazz ) ) { taskClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTaskClassDefinitions = false ; } } } return taskClassDefinitions ; } public Hashtable getDataTypeDefinitions ( ) { synchronized ( typeClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTypeClassDefinitions ) { typeClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( ! ( Task . class . isAssignableFrom ( clazz ) ) ) { typeClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTypeClassDefinitions = false ; } } } return typeClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( typeName ) ; def . setClass ( typeClass ) ; updateDataTypeDefinition ( def ) ; project . log ( " +User datatype: " + typeName + "     " + typeClass . getName ( ) , Project . MSG_DEBUG ) ; } public void addDataTypeDefinition ( AntTypeDefinition def ) { updateDataTypeDefinition ( def ) ; } public Hashtable getAntTypeTable ( ) { return antTypeTable ; } public Task createTask ( String taskType ) throws BuildException { Task task = createNewTask ( taskType ) ; if ( task == null && taskType . equals ( ANT_PROPERTY_TASK ) ) { addTaskDefinition ( ANT_PROPERTY_TASK , org . apache . tools . ant . taskdefs . Property . class ) ; task = createNewTask ( taskType ) ; } return task ; } private Task createNewTask ( String taskType ) throws BuildException { Class c = getComponentClass ( taskType ) ; if ( c == null || ! ( Task . class . isAssignableFrom ( c ) ) ) { return null ; } Object obj = createComponent ( taskType ) ; if ( obj == null ) { return null ; } if ( ! ( obj instanceof Task ) ) { throw new BuildException ( "Expected a Task from '" + taskType + "' but got an instance of " + obj . getClass ( ) . getName ( ) + " instead" ) ; } Task task = ( Task ) obj ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; project . log ( "   +Task: " + taskType , Project . MSG_DEBUG ) ; return task ; } public Object createDataType ( String typeName ) throws BuildException { return createComponent ( typeName ) ; } public String getElementName ( Object element ) { return getElementName ( element , false ) ; } public String getElementName ( Object o , boolean brief ) { Class elementClass = o . getClass ( ) ; String elementClassname = elementClass . getName ( ) ; for ( Iterator i = antTypeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; if ( elementClassname . equals ( def . getClassName ( ) ) && ( elementClass == def . getExposedClass ( project ) ) ) { String name = def . getName ( ) ; return brief ? name : "The <" + name + "> type" ; } } return getUnmappedElementName ( o . getClass ( ) , brief ) ; } public static String getElementName ( Project p , Object o , boolean brief ) { if ( p == null ) { p = getProject ( o ) ; } return p == null ? getUnmappedElementName ( o . getClass ( ) , brief ) : getComponentHelper ( p ) . getElementName ( o , brief ) ; } private static String getUnmappedElementName ( Class c , boolean brief ) { if ( brief ) { String name = c . getName ( ) ; return name . substring ( name . lastIndexOf ( '.' ) + 1 ) ; } return c . toString ( ) ; } private static Project getProject ( Object o ) { if ( o instanceof ProjectComponent ) { return ( ( ProjectComponent ) o ) . getProject ( ) ; } try { Method m = o . getClass ( ) . getMethod ( "getProject" , ( Class [ ] ) null ) ; if ( Project . class == m . getReturnType ( ) ) { return ( Project ) m . invoke ( o , ( Object [ ] ) null ) ; } } catch ( Exception e ) { } return null ; } private boolean validDefinition ( AntTypeDefinition def ) { return ! ( def . getTypeClass ( project ) == null || def . getExposedClass ( project ) == null ) ; } private boolean sameDefinition ( AntTypeDefinition def , AntTypeDefinition old ) { boolean defValid = validDefinition ( def ) ; boolean sameValidity = ( defValid == validDefinition ( old ) ) ; return sameValidity && ( ! defValid || def . sameDefinition ( old , project ) ) ; } private void updateDataTypeDefinition ( AntTypeDefinition def ) { String name = def . getName ( ) ; synchronized ( antTypeTable ) { rebuildTaskClassDefinitions = true ; rebuildTypeClassDefinitions = true ; AntTypeDefinition old = antTypeTable . getDefinition ( name ) ; if ( old != null ) { if ( sameDefinition ( def , old ) ) { return ; } Class oldClass = antTypeTable . getExposedClass ( name ) ; boolean isTask = ( oldClass != null && Task . class . isAssignableFrom ( oldClass ) ) ; project . log ( "Trying to override old definition of " + ( isTask ? "task " : "datatype " ) + name , ( def . similarDefinition ( old , project ) ) ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } project . log ( " +Datatype " + name + " " + def . getClassName ( ) , Project . MSG_DEBUG ) ; antTypeTable . put ( name , def ) ; } } public void enterAntLib ( String uri ) { antLibCurrentUri = uri ; antLibStack . push ( uri ) ; } public String getCurrentAntlibUri ( ) { return antLibCurrentUri ; } public void exitAntLib ( ) { antLibStack . pop ( ) ; antLibCurrentUri = ( antLibStack . size ( ) == 0 ) ? null : ( String ) antLibStack . peek ( ) ; } private void initTasks ( ) { ClassLoader classLoader = getClassLoader ( null ) ; Properties props = getDefaultDefinitions ( false ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; def . setAdaptToClass ( Task . class ) ; def . setAdapterClass ( TaskAdapter . class ) ; antTypeTable . put ( name , def ) ; } } private ClassLoader getClassLoader ( ClassLoader classLoader ) { String buildSysclasspath = project . getProperty ( MagicNames . BUILD_SYSCLASSPATH ) ; if ( project . getCoreLoader ( ) != null && ! ( BUILD_SYSCLASSPATH_ONLY . equals ( buildSysclasspath ) ) ) { classLoader = project . getCoreLoader ( ) ; } return classLoader ; } private static synchronized Properties getDefaultDefinitions ( boolean type ) throws BuildException { int idx = type ? 1 : 0 ; if ( defaultDefinitions [ idx ] == null ) { String resource = type ? MagicNames . TYPEDEFS_PROPERTIES_RESOURCE : MagicNames . TASKDEF_PROPERTIES_RESOURCE ; String errorString = type ? ERROR_NO_TYPE_LIST_LOAD : ERROR_NO_TASK_LIST_LOAD ; InputStream in = null ; try { in = ComponentHelper . class . getResourceAsStream ( resource ) ; if ( in == null ) { throw new BuildException ( errorString ) ; } Properties p = new Properties ( ) ; p . load ( in ) ; defaultDefinitions [ idx ] = p ; } catch ( IOException e ) { throw new BuildException ( errorString , e ) ; } finally { FileUtils . close ( in ) ; } } return defaultDefinitions [ idx ] ; } private void initTypes ( ) { ClassLoader classLoader = getClassLoader ( null ) ; Properties props = getDefaultDefinitions ( true ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; antTypeTable . put ( name , def ) ; } } private synchronized void checkNamespace ( String componentName ) { String uri = ProjectHelper . extractUriFromComponentName ( componentName ) ; if ( "" . equals ( uri ) ) { uri = ProjectHelper . ANT_CORE_URI ; } if ( ! uri . startsWith ( ProjectHelper . ANTLIB_URI ) ) { return ; } if ( checkedNamespaces . contains ( uri ) ) { return ; } checkedNamespaces . add ( uri ) ; Typedef definer = new Typedef ( ) ; definer . setProject ( project ) ; definer . init ( ) ; definer . setURI ( uri ) ; definer . setTaskName ( uri ) ; definer . setResource ( Definer . makeResourceFromURI ( uri ) ) ; definer . setOnError ( new Typedef . OnError ( Typedef . OnError . POLICY_IGNORE ) ) ; definer . execute ( ) ; } public String diagnoseCreationFailure ( String componentName , String type ) { StringWriter errorText = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( errorText ) ; out . println ( "Problem: failed to create " + type + " " + componentName ) ; boolean lowlevel = false ; boolean jars = false ; boolean definitions = false ; boolean antTask ; String home = System . getProperty ( Launcher . USER_HOMEDIR ) ; File libDir = new File ( home , Launcher . USER_LIBDIR ) ; String antHomeLib ; boolean probablyIDE = false ; String anthome = System . getProperty ( MagicNames . ANT_HOME ) ; if ( anthome != null ) { File antHomeLibDir = new File ( anthome , "lib" ) ; antHomeLib = antHomeLibDir . getAbsolutePath ( ) ; } else { probablyIDE = true ; antHomeLib = "ANT_HOME" + File . separatorChar + "lib" ; } StringBuffer dirListingText = new StringBuffer ( ) ; final String tab = "        -" ; dirListingText . append ( tab ) ; dirListingText . append ( antHomeLib ) ; dirListingText . append ( '\n' ) ; if ( probablyIDE ) { dirListingText . append ( tab ) ; dirListingText . append ( "the IDE Ant configuration dialogs" ) ; } else { dirListingText . append ( tab ) ; dirListingText . append ( libDir ) ; dirListingText . append ( '\n' ) ; dirListingText . append ( tab ) ; dirListingText . append ( "a directory added on the command line with the -lib argument" ) ; } String dirListing = dirListingText . toString ( ) ; AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { boolean isAntlib = componentName . indexOf ( MagicNames . ANTLIB_PREFIX ) == 0 ; out . println ( "Cause: The name is undefined." ) ; out . println ( "Action: Check the spelling." ) ; out . println ( "Action: Check that any custom tasks/types have been declared." ) ; out . println ( "Action: Check that any <presetdef>/<macrodef>" + " declarations have taken place." ) ; if ( isAntlib ) { out . println ( ) ; out . println ( "This appears to be an antlib declaration. " ) ; out . println ( "Action: Check that the implementing library exists in one of:" ) ; out . println ( dirListing ) ; } definitions = true ; } else { final String classname = def . getClassName ( ) ; antTask = classname . startsWith ( "org.apache.tools.ant." ) ; boolean optional = classname . startsWith ( "org.apache.tools.ant.taskdefs.optional" ) ; optional |= classname . startsWith ( "org.apache.tools.ant.types.optional" ) ; Class clazz = null ; try { clazz = def . innerGetTypeClass ( ) ; } catch ( ClassNotFoundException e ) { out . println ( "Cause: the class " + classname + " was not found." ) ; jars = true ; if ( optional ) { out . println ( "        This looks like one of Ant's optional components." ) ; out . println ( "Action: Check that the appropriate optional JAR exists in" ) ; out . println ( dirListing ) ; } else { out . println ( "Action: Check that the component has been correctly declared" ) ; out . println ( "        and that the implementing JAR is in one of:" ) ; out . println ( dirListing ) ; definitions = true ; } } catch ( NoClassDefFoundError ncdfe ) { jars = true ; out . println ( "Cause: Could not load a dependent class " + ncdfe . getMessage ( ) ) ; if ( optional ) { out . println ( "       It is not enough to have Ant's optional JARs" ) ; out . println ( "       you need the JAR files that the" + " optional tasks depend upon." ) ; out . println ( "       Ant's optional task dependencies are" + " listed in the manual." ) ; } else { out . println ( "       This class may be in a separate JAR" + " that is not installed." ) ; } out . println ( "Action: Determine what extra JAR files are" + " needed, and place them in one of:" ) ; out . println ( dirListing ) ; } if ( clazz != null ) { try { def . innerCreateAndSet ( clazz , project ) ; out . println ( "The component could be instantiated." ) ; } catch ( NoSuchMethodException e ) { lowlevel = true ; out . println ( "Cause: The class " + classname + " has no compatible constructor." ) ; } catch ( InstantiationException e ) { lowlevel = true ; out . println ( "Cause: The class " + classname + " is abstract and cannot be instantiated." ) ; } catch ( IllegalAccessException e ) { lowlevel = true ; out . println ( "Cause: The constructor for " + classname + " is private and cannot be invoked." ) ; } catch ( InvocationTargetException ex ) { lowlevel = true ; Throwable t = ex . getTargetException ( ) ; out . println ( "Cause: The constructor threw the exception" ) ; out . println ( t . toString ( ) ) ; t . printStackTrace ( out ) ; } catch ( NoClassDefFoundError ncdfe ) { jars = true ; out . println ( "Cause:  A class needed by class " + classname + " cannot be found: " ) ; out . println ( "       " + ncdfe . getMessage ( ) ) ; out . println ( "Action: Determine what extra JAR files are" + " needed, and place them in:" ) ; out . println ( dirListing ) ; } } out . println ( ) ; out . println ( "Do not panic, this is a common problem." ) ; if ( definitions ) { out . println ( "It may just be a typographical error in the build file " + "or the task/type declaration." ) ; } if ( jars ) { out . println ( "The commonest cause is a missing JAR." ) ; } if ( lowlevel ) { out . println ( "This is quite a low level problem, which may need " + "consultation with the author of the task." ) ; if ( antTask ) { out . println ( "This may be the Ant team. Please file a " + "defect or contact the developer team." ) ; } else { out . println ( "This does not appear to be a task bundled with Ant." ) ; out . println ( "Please take it up with the supplier of the third-party " + type + "." ) ; out . println ( "If you have written it yourself, you probably have a bug to fix." ) ; } } else { out . println ( ) ; out . println ( "This is not a bug; it is a configuration problem" ) ; } } out . flush ( ) ; out . close ( ) ; return errorText . toString ( ) ; } private static class AntTypeTable extends Hashtable { private Project project ; AntTypeTable ( Project project ) { this . project = project ; } AntTypeDefinition getDefinition ( String key ) { return ( AntTypeDefinition ) ( super . get ( key ) ) ; } public Object get ( Object key ) { return getTypeClass ( ( String ) key ) ; } Object create ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . create ( project ) ; } Class getTypeClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . getTypeClass ( project ) ; } Class getExposedClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . getExposedClass ( project ) ; } public boolean contains ( Object clazz ) { boolean found = false ; if ( clazz instanceof Class ) { for ( Iterator i = values ( ) . iterator ( ) ; i . hasNext ( ) && ! found ; ) { found |= ( ( ( AntTypeDefinition ) ( i . next ( ) ) ) . getExposedClass ( project ) == clazz ) ; } } return found ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } } } 	0	['39', '1', '0', '26', '154', '449', '13', '16', '26', '0.878446115', '1711', '0.714285714', '3', '0', '0.178947368', '0', '0', '42.33333333', '13', '2.5641', '0']
package org . apache . tools . mail ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null && line . length ( ) >= 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . length ( ) > 3 && line . charAt ( 3 ) == '-' ; } private void append ( String line ) { if ( line . length ( ) > 4 ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } } 	0	['5', '1', '0', '1', '19', '0', '1', '0', '3', '0.5', '108', '1', '0', '0', '0.533333333', '0', '0', '20.2', '3', '1.4', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; public final class FixCrLfFilter extends BaseParamFilterReader implements ChainableReader { private static final char CTRLZ = '' ; private int tabLength = 8 ; private CrLf eol ; private AddAsisRemove ctrlz ; private AddAsisRemove tabs ; private boolean javafiles = false ; private boolean fixlast = true ; private boolean initialized = false ; public FixCrLfFilter ( ) { super ( ) ; } public FixCrLfFilter ( final Reader in ) throws IOException { super ( in ) ; } { tabs = AddAsisRemove . ASIS ; if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { ctrlz = AddAsisRemove . REMOVE ; setEol ( CrLf . MAC ) ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = AddAsisRemove . ASIS ; setEol ( CrLf . DOS ) ; } else { ctrlz = AddAsisRemove . REMOVE ; setEol ( CrLf . UNIX ) ; } } public Reader chain ( final Reader rdr ) { try { FixCrLfFilter newFilter = new FixCrLfFilter ( rdr ) ; newFilter . setJavafiles ( getJavafiles ( ) ) ; newFilter . setEol ( getEol ( ) ) ; newFilter . setTab ( getTab ( ) ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setEof ( getEof ( ) ) ; newFilter . setFixlast ( getFixlast ( ) ) ; newFilter . initInternalFilters ( ) ; return newFilter ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public AddAsisRemove getEof ( ) { return ctrlz . newInstance ( ) ; } public CrLf getEol ( ) { return eol . newInstance ( ) ; } public boolean getFixlast ( ) { return fixlast ; } public boolean getJavafiles ( ) { return javafiles ; } public AddAsisRemove getTab ( ) { return tabs . newInstance ( ) ; } public int getTablength ( ) { return tabLength ; } private static String calculateEolString ( CrLf eol ) { if ( eol == CrLf . ASIS ) { return System . getProperty ( "line.separator" ) ; } if ( eol == CrLf . CR || eol == CrLf . MAC ) { return "\r" ; } if ( eol == CrLf . CRLF || eol == CrLf . DOS ) { return "\r\n" ; } return "\n" ; } private void initInternalFilters ( ) { in = ( ctrlz == AddAsisRemove . REMOVE ) ? new RemoveEofFilter ( in ) : in ; in = new NormalizeEolFilter ( in , calculateEolString ( eol ) , getFixlast ( ) ) ; if ( tabs != AddAsisRemove . ASIS ) { if ( getJavafiles ( ) ) { in = new MaskJavaTabLiteralsFilter ( in ) ; } in = ( tabs == AddAsisRemove . ADD ) ? ( Reader ) new AddTabFilter ( in , getTablength ( ) ) : ( Reader ) new RemoveTabFilter ( in , getTablength ( ) ) ; } in = ( ctrlz == AddAsisRemove . ADD ) ? new AddEofFilter ( in ) : in ; initialized = true ; } public synchronized int read ( ) throws IOException { if ( ! initialized ) { initInternalFilters ( ) ; } return in . read ( ) ; } public void setEof ( AddAsisRemove attr ) { ctrlz = attr . resolve ( ) ; } public void setEol ( CrLf attr ) { eol = attr . resolve ( ) ; } public void setFixlast ( boolean fixlast ) { this . fixlast = fixlast ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setTab ( AddAsisRemove attr ) { tabs = attr . resolve ( ) ; } public void setTablength ( int tabLength ) throws IOException { if ( tabLength < 2 || tabLength > 80 ) { throw new IOException ( "tablength must be between 2 and 80" ) ; } this . tabLength = tabLength ; } private static class SimpleFilterReader extends Reader { private Reader in ; private int [ ] preempt = new int [ 16 ] ; private int preemptIndex = 0 ; public SimpleFilterReader ( Reader in ) { this . in = in ; } public void push ( char c ) { push ( ( int ) c ) ; } public void push ( int c ) { try { preempt [ preemptIndex ++ ] = c ; } catch ( ArrayIndexOutOfBoundsException e ) { int [ ] p2 = new int [ preempt . length * 2 ] ; System . arraycopy ( preempt , 0 , p2 , 0 , preempt . length ) ; preempt = p2 ; push ( c ) ; } } public void push ( char [ ] cs , int start , int length ) { for ( int i = start + length - 1 ; i >= start ; ) { push ( cs [ i -- ] ) ; } } public void push ( char [ ] cs ) { push ( cs , 0 , cs . length ) ; } public void push ( String s ) { push ( s . toCharArray ( ) ) ; } public boolean editsBlocked ( ) { return in instanceof SimpleFilterReader && ( ( SimpleFilterReader ) in ) . editsBlocked ( ) ; } public int read ( ) throws java . io . IOException { return preemptIndex > 0 ? preempt [ -- preemptIndex ] : in . read ( ) ; } public void close ( ) throws java . io . IOException { in . close ( ) ; } public void reset ( ) throws IOException { in . reset ( ) ; } public boolean markSupported ( ) { return in . markSupported ( ) ; } public boolean ready ( ) throws java . io . IOException { return in . ready ( ) ; } public void mark ( int i ) throws java . io . IOException { in . mark ( i ) ; } public long skip ( long i ) throws java . io . IOException { return in . skip ( i ) ; } public int read ( char [ ] buf ) throws java . io . IOException { return read ( buf , 0 , buf . length ) ; } public int read ( char [ ] buf , int start , int length ) throws java . io . IOException { int count = 0 ; int c = 0 ; while ( length -- > 0 && ( c = this . read ( ) ) != - 1 ) { buf [ start ++ ] = ( char ) c ; count ++ ; } return ( count == 0 && c == - 1 ) ? - 1 : count ; } } private static class MaskJavaTabLiteralsFilter extends SimpleFilterReader { private boolean editsBlocked = false ; private static final int JAVA = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int TRANS_TO_COMMENT = 6 ; private static final int TRANS_FROM_MULTI = 8 ; private int state ; public MaskJavaTabLiteralsFilter ( Reader in ) { super ( in ) ; state = JAVA ; } public boolean editsBlocked ( ) { return editsBlocked || super . editsBlocked ( ) ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; editsBlocked = ( state == IN_CHAR_CONST || state == IN_STR_CONST ) ; switch ( state ) { case JAVA : switch ( thisChar ) { case '\'' : state = IN_CHAR_CONST ; break ; case '"' : state = IN_STR_CONST ; break ; case '/' : state = TRANS_TO_COMMENT ; break ; default : } break ; case IN_CHAR_CONST : switch ( thisChar ) { case '\'' : state = JAVA ; break ; default : } break ; case IN_STR_CONST : switch ( thisChar ) { case '"' : state = JAVA ; break ; default : } break ; case IN_SINGLE_COMMENT : switch ( thisChar ) { case '\n' : case '\r' : state = JAVA ; break ; default : } break ; case IN_MULTI_COMMENT : switch ( thisChar ) { case '*' : state = TRANS_FROM_MULTI ; break ; default : } break ; case TRANS_TO_COMMENT : switch ( thisChar ) { case '*' : state = IN_MULTI_COMMENT ; break ; case '/' : state = IN_SINGLE_COMMENT ; break ; case '\'' : state = IN_CHAR_CONST ; break ; case '"' : state = IN_STR_CONST ; break ; default : state = JAVA ; } break ; case TRANS_FROM_MULTI : switch ( thisChar ) { case '/' : state = JAVA ; break ; default : } break ; default : } return thisChar ; } } private static class NormalizeEolFilter extends SimpleFilterReader { private boolean previousWasEOL ; private boolean fixLast ; private int normalizedEOL = 0 ; private char [ ] eol = null ; public NormalizeEolFilter ( Reader in , String eolString , boolean fixLast ) { super ( in ) ; eol = eolString . toCharArray ( ) ; this . fixLast = fixLast ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; if ( normalizedEOL == 0 ) { int numEOL = 0 ; boolean atEnd = false ; switch ( thisChar ) { case CTRLZ : int c = super . read ( ) ; if ( c == - 1 ) { atEnd = true ; if ( fixLast && ! previousWasEOL ) { numEOL = 1 ; push ( thisChar ) ; } } else { push ( c ) ; } break ; case - 1 : atEnd = true ; if ( fixLast && ! previousWasEOL ) { numEOL = 1 ; } break ; case '\n' : numEOL = 1 ; break ; case '\r' : numEOL = 1 ; int c1 = super . read ( ) ; int c2 = super . read ( ) ; if ( c1 == '\r' && c2 == '\n' ) { } else if ( c1 == '\r' ) { numEOL = 2 ; push ( c2 ) ; } else if ( c1 == '\n' ) { push ( c2 ) ; } else { push ( c2 ) ; push ( c1 ) ; } default : } if ( numEOL > 0 ) { while ( numEOL -- > 0 ) { push ( eol ) ; normalizedEOL += eol . length ; } previousWasEOL = true ; thisChar = read ( ) ; } else if ( ! atEnd ) { previousWasEOL = false ; } } else { normalizedEOL -- ; } return thisChar ; } } private static class AddEofFilter extends SimpleFilterReader { private int lastChar = - 1 ; public AddEofFilter ( Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; if ( thisChar == - 1 ) { if ( lastChar != CTRLZ ) { lastChar = CTRLZ ; return lastChar ; } } else { lastChar = thisChar ; } return thisChar ; } } private static class RemoveEofFilter extends SimpleFilterReader { private int lookAhead = - 1 ; public RemoveEofFilter ( Reader in ) { super ( in ) ; try { lookAhead = in . read ( ) ; } catch ( IOException e ) { lookAhead = - 1 ; } } public int read ( ) throws IOException { int lookAhead2 = super . read ( ) ; if ( lookAhead2 == - 1 && lookAhead == CTRLZ ) { return - 1 ; } int i = lookAhead ; lookAhead = lookAhead2 ; return i ; } } private static class AddTabFilter extends SimpleFilterReader { private int columnNumber = 0 ; private int tabLength = 0 ; public AddTabFilter ( Reader in , int tabLength ) { super ( in ) ; this . tabLength = tabLength ; } public int read ( ) throws IOException { int c = super . read ( ) ; switch ( c ) { case '\r' : case '\n' : columnNumber = 0 ; break ; case ' ' : columnNumber ++ ; if ( ! editsBlocked ( ) ) { int colNextTab = ( ( columnNumber + tabLength - 1 ) / tabLength ) * tabLength ; int countSpaces = 1 ; int numTabs = 0 ; scanWhitespace : while ( ( c = super . read ( ) ) != - 1 ) { switch ( c ) { case ' ' : if ( ++ columnNumber == colNextTab ) { numTabs ++ ; countSpaces = 0 ; colNextTab += tabLength ; } else { countSpaces ++ ; } break ; case '\t' : columnNumber = colNextTab ; numTabs ++ ; countSpaces = 0 ; colNextTab += tabLength ; break ; default : push ( c ) ; break scanWhitespace ; } } while ( countSpaces -- > 0 ) { push ( ' ' ) ; columnNumber -- ; } while ( numTabs -- > 0 ) { push ( '\t' ) ; columnNumber -= tabLength ; } c = super . read ( ) ; switch ( c ) { case ' ' : columnNumber ++ ; break ; case '\t' : columnNumber += tabLength ; break ; default : } } break ; case '\t' : columnNumber = ( ( columnNumber + tabLength - 1 ) / tabLength ) * tabLength ; break ; default : columnNumber ++ ; } return c ; } } private static class RemoveTabFilter extends SimpleFilterReader { private int columnNumber = 0 ; private int tabLength = 0 ; public RemoveTabFilter ( Reader in , int tabLength ) { super ( in ) ; this . tabLength = tabLength ; } public int read ( ) throws IOException { int c = super . read ( ) ; switch ( c ) { case '\r' : case '\n' : columnNumber = 0 ; break ; case '\t' : int width = tabLength - columnNumber % tabLength ; if ( ! editsBlocked ( ) ) { for ( ; width > 1 ; width -- ) { push ( ' ' ) ; } c = ' ' ; } columnNumber += width ; break ; default : columnNumber ++ ; } return c ; } } public static class AddAsisRemove extends EnumeratedAttribute { private static final AddAsisRemove ASIS = newInstance ( "asis" ) ; private static final AddAsisRemove ADD = newInstance ( "add" ) ; private static final AddAsisRemove REMOVE = newInstance ( "remove" ) ; public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } public boolean equals ( Object other ) { return other instanceof AddAsisRemove && getIndex ( ) == ( ( AddAsisRemove ) other ) . getIndex ( ) ; } public int hashCode ( ) { return getIndex ( ) ; } AddAsisRemove resolve ( ) throws IllegalStateException { if ( this . equals ( ASIS ) ) { return ASIS ; } if ( this . equals ( ADD ) ) { return ADD ; } if ( this . equals ( REMOVE ) ) { return REMOVE ; } throw new IllegalStateException ( "No replacement for " + this ) ; } private AddAsisRemove newInstance ( ) { return newInstance ( getValue ( ) ) ; } public static AddAsisRemove newInstance ( String value ) { AddAsisRemove a = new AddAsisRemove ( ) ; a . setValue ( value ) ; return a ; } } public static class CrLf extends EnumeratedAttribute { private static final CrLf ASIS = newInstance ( "asis" ) ; private static final CrLf CR = newInstance ( "cr" ) ; private static final CrLf CRLF = newInstance ( "crlf" ) ; private static final CrLf DOS = newInstance ( "dos" ) ; private static final CrLf LF = newInstance ( "lf" ) ; private static final CrLf MAC = newInstance ( "mac" ) ; private static final CrLf UNIX = newInstance ( "unix" ) ; public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } public boolean equals ( Object other ) { return other instanceof CrLf && getIndex ( ) == ( ( CrLf ) other ) . getIndex ( ) ; } public int hashCode ( ) { return getIndex ( ) ; } CrLf resolve ( ) { if ( this . equals ( ASIS ) ) { return ASIS ; } if ( this . equals ( CR ) || this . equals ( MAC ) ) { return CR ; } if ( this . equals ( CRLF ) || this . equals ( DOS ) ) { return CRLF ; } if ( this . equals ( LF ) || this . equals ( UNIX ) ) { return LF ; } throw new IllegalStateException ( "No replacement for " + this ) ; } private CrLf newInstance ( ) { return newInstance ( getValue ( ) ) ; } public static CrLf newInstance ( String value ) { CrLf c = new CrLf ( ) ; c . setValue ( value ) ; return c ; } } } 	0	['18', '5', '0', '14', '44', '77', '2', '12', '16', '0.713235294', '331', '1', '3', '0.636363636', '0.240740741', '2', '8', '16.94444444', '6', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class AbstractJarSignerTask extends Task { protected File jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected boolean verbose ; protected String maxMemory ; protected Vector filesets = new Vector ( ) ; protected static final String JARSIGNER_COMMAND = "jarsigner" ; private RedirectorElement redirector ; private Environment sysProperties = new Environment ( ) ; public static final String ERROR_NO_SOURCE = "jar must be set through jar attribute " + "or nested filesets" ; private Path path = null ; public void setMaxmemory ( String max ) { maxMemory = max ; } public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } protected void beginExecution ( ) { redirector = createRedirector ( ) ; } protected void endExecution ( ) { redirector = null ; } private RedirectorElement createRedirector ( ) { RedirectorElement result = new RedirectorElement ( ) ; if ( storepass != null ) { StringBuffer input = new StringBuffer ( storepass ) . append ( '\n' ) ; if ( keypass != null ) { input . append ( keypass ) . append ( '\n' ) ; } result . setInputString ( input . toString ( ) ) ; result . setLogInputString ( false ) ; } return result ; } public RedirectorElement getRedirector ( ) { return redirector ; } protected void setCommonOptions ( final ExecTask cmd ) { if ( maxMemory != null ) { addValue ( cmd , "-J-Xmx" + maxMemory ) ; } if ( verbose ) { addValue ( cmd , "-verbose" ) ; } Vector props = sysProperties . getVariablesVector ( ) ; Enumeration e = props . elements ( ) ; while ( e . hasMoreElements ( ) ) { Environment . Variable variable = ( Environment . Variable ) e . nextElement ( ) ; declareSysProperty ( cmd , variable ) ; } } protected void declareSysProperty ( ExecTask cmd , Environment . Variable property ) throws BuildException { addValue ( cmd , "-J-D" + property . getContent ( ) ) ; } protected void bindToKeystore ( final ExecTask cmd ) { if ( null != keystore ) { addValue ( cmd , "-keystore" ) ; String loc ; File keystoreFile = getProject ( ) . resolveFile ( keystore ) ; if ( keystoreFile . exists ( ) ) { loc = keystoreFile . getPath ( ) ; } else { loc = keystore ; } addValue ( cmd , loc ) ; } if ( null != storetype ) { addValue ( cmd , "-storetype" ) ; addValue ( cmd , storetype ) ; } } protected ExecTask createJarSigner ( ) { final ExecTask cmd = new ExecTask ( this ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( JARSIGNER_COMMAND ) ) ; cmd . setTaskType ( JARSIGNER_COMMAND ) ; cmd . setFailonerror ( true ) ; cmd . addConfiguredRedirector ( redirector ) ; return cmd ; } protected Vector createUnifiedSources ( ) { Vector sources = ( Vector ) filesets . clone ( ) ; if ( jar != null ) { FileSet sourceJar = new FileSet ( ) ; sourceJar . setProject ( getProject ( ) ) ; sourceJar . setFile ( jar ) ; sourceJar . setDir ( jar . getParentFile ( ) ) ; sources . add ( sourceJar ) ; } return sources ; } protected Path createUnifiedSourcePath ( ) { Path p = path == null ? new Path ( getProject ( ) ) : ( Path ) path . clone ( ) ; Vector s = createUnifiedSources ( ) ; Enumeration e = s . elements ( ) ; while ( e . hasMoreElements ( ) ) { p . add ( ( FileSet ) e . nextElement ( ) ) ; } return p ; } protected boolean hasResources ( ) { return path != null || filesets . size ( ) > 0 ; } protected void addValue ( final ExecTask cmd , String value ) { cmd . createArg ( ) . setValue ( value ) ; } } 	0	['24', '3', '2', '14', '65', '222', '2', '12', '13', '0.937888199', '348', '0.928571429', '3', '0.616666667', '0.238095238', '0', '0', '12.91666667', '4', '1.5417', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class JbossDeploymentTool extends GenericDeploymentTool { protected static final String JBOSS_DD = "jboss.xml" ; protected static final String JBOSS_CMP10D = "jaws.xml" ; protected static final String JBOSS_CMP20D = "jbosscmp-jdbc.xml" ; private String jarSuffix = ".jar" ; public void setSuffix ( String inString ) { jarSuffix = inString ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { File jbossDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + JBOSS_DD ) ; if ( jbossDD . exists ( ) ) { ejbFiles . put ( META_DIR + JBOSS_DD , jbossDD ) ; } else { log ( "Unable to locate jboss deployment descriptor. " + "It was expected to be in " + jbossDD . getPath ( ) , Project . MSG_WARN ) ; return ; } String descriptorFileName = JBOSS_CMP10D ; if ( EjbJar . CMPVersion . CMP2_0 . equals ( getParent ( ) . getCmpversion ( ) ) ) { descriptorFileName = JBOSS_CMP20D ; } File jbossCMPD = new File ( getConfig ( ) . descriptorDir , ddPrefix + descriptorFileName ) ; if ( jbossCMPD . exists ( ) ) { ejbFiles . put ( META_DIR + descriptorFileName , jbossCMPD ) ; } else { log ( "Unable to locate jboss cmp descriptor. " + "It was expected to be in " + jbossCMPD . getPath ( ) , Project . MSG_VERBOSE ) ; return ; } } File getVendorOutputJarFile ( String baseName ) { if ( getDestDir ( ) == null && getParent ( ) . getDestdir ( ) == null ) { throw new BuildException ( "DestDir not specified" ) ; } if ( getDestDir ( ) == null ) { return new File ( getParent ( ) . getDestdir ( ) , baseName + jarSuffix ) ; } else { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } } public void validateConfigured ( ) throws BuildException { } private EjbJar getParent ( ) { return ( EjbJar ) this . getTask ( ) ; } } 	0	['6', '2', '0', '5', '23', '9', '1', '5', '3', '1.05', '160', '1', '0', '0.864864865', '0.555555556', '2', '3', '25', '4', '1.8333', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Reopen extends P4Base { private String toChange = "" ; public void setToChange ( String toChange ) throws BuildException { if ( toChange == null || toChange . equals ( "" ) ) { throw new BuildException ( "P4Reopen: tochange cannot be null or empty" ) ; } this . toChange = toChange ; } public void execute ( ) throws BuildException { if ( P4View == null ) { throw new BuildException ( "No view specified to reopen" ) ; } execP4Command ( "-s reopen -c " + toChange + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '11', '0', '0', '4', '3', '0', '53', '1', '0', '0.962264151', '0.666666667', '1', '1', '16.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public abstract class BaseSelector extends DataType implements FileSelector { private String errmsg = null ; public BaseSelector ( ) { } public void setError ( String msg ) { if ( errmsg == null ) { errmsg = msg ; } } public String getError ( ) { return errmsg ; } public void verifySettings ( ) { if ( isReference ( ) ) { ( ( BaseSelector ) getCheckedRef ( ) ) . verifySettings ( ) ; } } public void validate ( ) { if ( getError ( ) == null ) { verifySettings ( ) ; } if ( getError ( ) != null ) { throw new BuildException ( errmsg ) ; } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; } 	0	['6', '3', '6', '10', '10', '3', '7', '3', '6', '0.4', '46', '1', '0', '0.857142857', '0.5', '0', '0', '6.5', '3', '1.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public class ResourceSelectorContainer extends DataType { private Vector v = new Vector ( ) ; public ResourceSelectorContainer ( ) { } public ResourceSelectorContainer ( ResourceSelector [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { add ( r [ i ] ) ; } } public void add ( ResourceSelector s ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( s == null ) { return ; } v . add ( s ) ; setChecked ( false ) ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . hasSelectors ( ) ; } dieOnCircularReference ( ) ; return ! v . isEmpty ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . selectorCount ( ) ; } dieOnCircularReference ( ) ; return v . size ( ) ; } public Iterator getSelectors ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . getSelectors ( ) ; } dieOnCircularReference ( ) ; return Collections . unmodifiableList ( v ) . iterator ( ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = v . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } setChecked ( true ) ; } } } 	0	['7', '3', '5', '9', '26', '0', '5', '4', '6', '0', '141', '1', '0', '0.857142857', '0.314285714', '1', '3', '19', '3', '1.5714', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; public class JarFileIterator implements ClassFileIterator { private ZipInputStream jarStream ; public JarFileIterator ( InputStream stream ) throws IOException { super ( ) ; jarStream = new ZipInputStream ( stream ) ; } public ClassFile getNextClassFile ( ) { ZipEntry jarEntry ; ClassFile nextElement = null ; try { jarEntry = jarStream . getNextEntry ( ) ; while ( nextElement == null && jarEntry != null ) { String entryName = jarEntry . getName ( ) ; if ( ! jarEntry . isDirectory ( ) && entryName . endsWith ( ".class" ) ) { ClassFile javaClass = new ClassFile ( ) ; javaClass . read ( jarStream ) ; nextElement = javaClass ; } else { jarEntry = jarStream . getNextEntry ( ) ; } } } catch ( IOException e ) { String message = e . getMessage ( ) ; String text = e . getClass ( ) . getName ( ) ; if ( message != null ) { text += ": " + message ; } throw new RuntimeException ( "Problem reading JAR file: " + text ) ; } return nextElement ; } } 	0	['2', '1', '0', '2', '18', '0', '0', '2', '2', '0', '83', '1', '0', '0', '0.75', '0', '0', '40', '6', '3', '0']
