package org . apache . xalan . xsltc ; public interface StripFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0	['1', '1', '0', '11', '1', '0', '11', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . serialize ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import org . xml . sax . ContentHandler ; public interface Serializer { public void setOutputStream ( OutputStream output ) ; public OutputStream getOutputStream ( ) ; public void setWriter ( Writer writer ) ; public Writer getWriter ( ) ; public void setOutputFormat ( Properties format ) ; public Properties getOutputFormat ( ) ; public ContentHandler asContentHandler ( ) throws IOException ; public DOMSerializer asDOMSerializer ( ) throws IOException ; public boolean reset ( ) ; } 	0	['9', '1', '0', '3', '9', '36', '2', '1', '9', '2', '9', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; public class XMLStringFactoryDefault extends XMLStringFactory { private static final XMLStringDefault EMPTY_STR = new XMLStringDefault ( "" ) ; public XMLString newstr ( String string ) { return new XMLStringDefault ( string ) ; } public XMLString newstr ( FastStringBuffer fsb , int start , int length ) { return new XMLStringDefault ( fsb . getString ( start , length ) ) ; } public XMLString newstr ( char [ ] string , int start , int length ) { return new XMLStringDefault ( new String ( string , start , length ) ) ; } public XMLString emptystr ( ) { return EMPTY_STR ; } } 	0	['6', '2', '0', '4', '10', '13', '0', '4', '5', '0.8', '41', '1', '1', '0.5', '0.4', '0', '0', '5.666666667', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; final class ChunkedIntArray { final int slotsize = 4 ; static final int lowbits = 10 ; static final int chunkalloc = 1 << lowbits ; static final int lowmask = chunkalloc - 1 ; ChunksVector chunks = new ChunksVector ( ) ; final int fastArray [ ] = new int [ chunkalloc ] ; int lastUsed = 0 ; ChunkedIntArray ( int slotsize ) { if ( this . slotsize < slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHUNKEDINTARRAY_NOT_SUPPORTED , new Object [ ] { Integer . toString ( slotsize ) } ) ) ; else if ( this . slotsize > slotsize ) System . out . println ( "*****WARNING: ChunkedIntArray(" + slotsize + ") wasting " + ( this . slotsize - slotsize ) + " words per slot" ) ; chunks . addElement ( fastArray ) ; } int appendSlot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = 4 ; int newoffset = ( lastUsed + 1 ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; return ++ lastUsed ; } } int readEntry ( int position , int offset ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; return chunk [ slotpos + offset ] ; } } int specialFind ( int startPos , int position ) { int ancestor = startPos ; while ( ancestor > 0 ) { ancestor *= slotsize ; int chunkpos = ancestor > > lowbits ; int slotpos = ancestor & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; ancestor = chunk [ slotpos + 1 ] ; if ( ancestor == position ) break ; } if ( ancestor <= 0 ) { return position ; } return - 1 ; } int slotsUsed ( ) { return lastUsed ; } void discardLast ( ) { -- lastUsed ; } void writeEntry ( int position , int offset , int value ) throws ArrayIndexOutOfBoundsException { { if ( offset >= slotsize ) throw new ArrayIndexOutOfBoundsException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_OFFSET_BIGGER_THAN_SLOT , null ) ) ; position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = position & lowmask ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos + offset ] = value ; } } void writeSlot ( int position , int w0 , int w1 , int w2 , int w3 ) { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; } void readSlot ( int position , int [ ] buffer ) { { position *= slotsize ; int chunkpos = position > > lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; System . arraycopy ( chunk , slotpos , buffer , 0 , slotsize ) ; } } class ChunksVector { final int BLOCKSIZE = 64 ; int [ ] m_map [ ] = new int [ BLOCKSIZE ] [ ] ; int m_mapSize = BLOCKSIZE ; int pos = 0 ; ChunksVector ( ) { } final int size ( ) { return pos ; } void addElement ( int [ ] value ) { if ( pos >= m_mapSize ) { int orgMapSize = m_mapSize ; while ( pos >= m_mapSize ) m_mapSize += BLOCKSIZE ; int [ ] newMap [ ] = new int [ m_mapSize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , orgMapSize ) ; m_map = newMap ; } m_map [ pos ] = value ; pos ++ ; } final int [ ] elementAt ( int pos ) { return m_map [ pos ] ; } } } 	0	['9', '1', '0', '3', '24', '0', '2', '2', '0', '0.892857143', '353', '0', '1', '0', '0.62962963', '0', '0', '37.44444444', '3', '1.4444', '0']
package org . apache . xalan . transformer ; public class XalanProperties { public final static String SOURCE_LOCATION = "http://xml.apache.org/xalan/properties/source-location" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . utils ; import java . util . Hashtable ; class ElemDesc { Hashtable m_attrs = null ; int m_flags ; static final int EMPTY = ( 1 << 1 ) ; static final int FLOW = ( 1 << 2 ) ; static final int BLOCK = ( 1 << 3 ) ; static final int BLOCKFORM = ( 1 << 4 ) ; static final int BLOCKFORMFIELDSET = ( 1 << 5 ) ; static final int CDATA = ( 1 << 6 ) ; static final int PCDATA = ( 1 << 7 ) ; static final int RAW = ( 1 << 8 ) ; static final int INLINE = ( 1 << 9 ) ; static final int INLINEA = ( 1 << 10 ) ; static final int INLINELABEL = ( 1 << 11 ) ; static final int FONTSTYLE = ( 1 << 12 ) ; static final int PHRASE = ( 1 << 13 ) ; static final int FORMCTRL = ( 1 << 14 ) ; static final int SPECIAL = ( 1 << 15 ) ; static final int ASPECIAL = ( 1 << 16 ) ; static final int HEADMISC = ( 1 << 17 ) ; static final int HEAD = ( 1 << 18 ) ; static final int LIST = ( 1 << 19 ) ; static final int PREFORMATTED = ( 1 << 20 ) ; static final int WHITESPACESENSITIVE = ( 1 << 21 ) ; static final int ATTRURL = ( 1 << 1 ) ; static final int ATTREMPTY = ( 1 << 2 ) ; ElemDesc ( int flags ) { m_flags = flags ; } boolean is ( int flags ) { return ( m_flags & flags ) != 0 ; } void setAttr ( String name , int flags ) { if ( null == m_attrs ) m_attrs = new Hashtable ( ) ; m_attrs . put ( name , new Integer ( flags ) ) ; } boolean isAttrFlagSet ( String name , int flags ) { if ( null != m_attrs ) { Integer _flags = ( Integer ) m_attrs . get ( name ) ; if ( null != _flags ) { return ( _flags . intValue ( ) & flags ) != 0 ; } } return false ; } } 	0	['4', '1', '0', '0', '10', '0', '0', '0', '0', '1.266666667', '90', '0', '0', '0', '0.833333333', '0', '0', '15.25', '4', '2', '0']
package org . apache . xalan . trace ; public interface TraceListenerEx2 extends TraceListenerEx { public void traceEnd ( TracerEvent ev ) ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . functions ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '3', '20', '53', '3', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . trace ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . xalan . transformer . TransformerImpl ; public class ExtensionEvent { public static final int DEFAULT_CONSTRUCTOR = 0 ; public static final int METHOD = 1 ; public static final int CONSTRUCTOR = 2 ; public final int m_callType ; public final TransformerImpl m_transformer ; public final Object m_method ; public final Object m_instance ; public final Object [ ] m_arguments ; public ExtensionEvent ( TransformerImpl transformer , Method method , Object instance , Object [ ] arguments ) { m_transformer = transformer ; m_method = method ; m_instance = instance ; m_arguments = arguments ; m_callType = METHOD ; } public ExtensionEvent ( TransformerImpl transformer , Constructor constructor , Object [ ] arguments ) { m_transformer = transformer ; m_instance = null ; m_arguments = arguments ; m_method = constructor ; m_callType = CONSTRUCTOR ; } public ExtensionEvent ( TransformerImpl transformer , Class clazz ) { m_transformer = transformer ; m_instance = null ; m_arguments = null ; m_method = clazz ; m_callType = DEFAULT_CONSTRUCTOR ; } } 	0	['3', '1', '0', '6', '4', '0', '5', '1', '3', '0.5625', '65', '0', '1', '0', '0.571428571', '0', '0', '18', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class RtMethodGenerator extends MethodGenerator { private static final int HANDLER_INDEX = 2 ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; public RtMethodGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; } public int getIteratorIndex ( ) { return INVALID_INDEX ; } public final Instruction storeHandler ( ) { return _astoreHandler ; } public final Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	0	['5', '5', '0', '7', '8', '6', '0', '7', '5', '0.916666667', '41', '1', '0', '0.971830986', '0.325', '1', '2', '6.6', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class ObjectType extends Type { private String _javaClassName = "java.lang.Object" ; private Class _clazz = java . lang . Object . class ; protected ObjectType ( String javaClassName ) { _javaClassName = javaClassName ; try { _clazz = ObjectFactory . findProviderClass ( javaClassName , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ClassNotFoundException e ) { _clazz = null ; } } protected ObjectType ( Class clazz ) { _clazz = clazz ; _javaClassName = clazz . getName ( ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } public boolean equals ( Object obj ) { return ( obj instanceof ObjectType ) ; } public String getJavaClassName ( ) { return _javaClassName ; } public Class getJavaClass ( ) { return _clazz ; } public String toString ( ) { return _javaClassName ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { final StringBuffer result = new StringBuffer ( "L" ) ; result . append ( _javaClassName . replace ( '.' , '/' ) ) . append ( ';' ) ; return result . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return Util . getJCRefType ( toSignature ( ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; final BranchHandle ifNull = il . append ( new IFNULL ( null ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( _javaClassName , "toString" , "()" + STRING_SIG ) ) ) ; final BranchHandle gotobh = il . append ( new GOTO ( null ) ) ; ifNull . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( cpg , "" ) ) ; gotobh . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . isAssignableFrom ( _clazz ) ) methodGen . getInstructionList ( ) . append ( NOP ) ; else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['16', '2', '0', '30', '47', '74', '8', '23', '14', '0.6', '225', '1', '0', '0.70212766', '0.236111111', '2', '3', '12.9375', '2', '1.0625', '0']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Element ; public interface WhitespaceStrippingElementMatcher { public boolean shouldStripWhiteSpace ( XPathContext support , Element targetElement ) throws TransformerException ; public boolean canStripWhiteSpace ( ) ; } 	0	['2', '1', '0', '2', '2', '1', '1', '1', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BinOpExpr extends Expression { public static final int PLUS = 0 ; public static final int MINUS = 1 ; public static final int TIMES = 2 ; public static final int DIV = 3 ; public static final int MOD = 4 ; private static final String [ ] Ops = { "+" , "-" , "*" , "/" , "%" } ; private int _op ; private Expression _left , _right ; public BinOpExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { if ( _left . hasPositionCall ( ) ) return true ; if ( _right . hasPositionCall ( ) ) return true ; return false ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) || _right . hasLastCall ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final Type tright = _right . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , Ops [ _op ] , new MethodType ( Type . Void , tleft , tright ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } final Type arg2 = ( Type ) ptype . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) { _right = new CastExpr ( _right , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; _right . translate ( classGen , methodGen ) ; switch ( _op ) { case PLUS : il . append ( _type . ADD ( ) ) ; break ; case MINUS : il . append ( _type . SUB ( ) ) ; break ; case TIMES : il . append ( _type . MUL ( ) ) ; break ; case DIV : il . append ( _type . DIV ( ) ) ; break ; case MOD : il . append ( _type . REM ( ) ) ; break ; default : ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_BINARY_OP_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } } 	0	['8', '3', '0', '14', '38', '0', '0', '14', '7', '0.80952381', '255', '0.444444444', '2', '0.922077922', '0.265306122', '2', '8', '29.75', '3', '1.375', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnaryOpExpr extends Expression { private Expression _left ; public UnaryOpExpr ( Expression left ) { ( _left = left ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) ) ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tleft = _left . typeCheck ( stable ) ; final MethodType ptype = lookupPrimop ( stable , "u-" , new MethodType ( Type . Void , tleft ) ) ; if ( ptype != null ) { final Type arg1 = ( Type ) ptype . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) { _left = new CastExpr ( _left , arg1 ) ; } return _type = ptype . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public String toString ( ) { return "u-" + '(' + _left + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; il . append ( _type . NEG ( ) ) ; } } 	0	['7', '3', '0', '13', '30', '0', '0', '13', '7', '0', '106', '1', '1', '0.922077922', '0.285714286', '2', '8', '14', '1', '0.8571', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xml . utils ; public interface PrefixResolver { String getNamespaceForPrefix ( String prefix ) ; String getNamespaceForPrefix ( String prefix , org . w3c . dom . Node context ) ; public String getBaseIdentifier ( ) ; public boolean handlesNullPrefixes ( ) ; } 	0	['4', '1', '0', '68', '4', '6', '68', '0', '4', '2', '4', '0', '0', '0', '0.583333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; public final class AbsoluteIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; public AbsoluteIterator ( DTMAxisIterator source ) { _source = source ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator setStartNode ( int node ) { _startNode = DTMDefaultBase . ROOTNODE ; if ( _isRestartable ) { _source . setStartNode ( _startNode ) ; resetPosition ( ) ; } return this ; } public int next ( ) { return returnNode ( _source . next ( ) ) ; } public DTMAxisIterator cloneIterator ( ) { try { final AbsoluteIterator clone = ( AbsoluteIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . resetPosition ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['8', '2', '0', '3', '21', '0', '1', '3', '8', '0', '85', '1', '1', '0.65', '0.34375', '1', '5', '9.5', '2', '1', '0']
package org . apache . xml . utils ; public abstract class XMLStringFactory { public abstract XMLString newstr ( String string ) ; public abstract XMLString newstr ( FastStringBuffer string , int start , int length ) ; public abstract XMLString newstr ( char [ ] string , int start , int length ) ; public abstract XMLString emptystr ( ) ; } 	0	['5', '1', '2', '21', '6', '10', '19', '2', '5', '2', '8', '0', '0', '0', '0.4', '0', '0', '0.6', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NamespaceUriCall extends NameBase { public NamespaceUriCall ( QName fname ) { super ( fname ) ; } public NamespaceUriCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNamespace = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceName" , "(I)" + STRING_SIG ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getNamespace , 2 ) ) ; } } 	0	['3', '5', '0', '9', '11', '3', '0', '9', '3', '2', '37', '0', '0', '0.99', '0.533333333', '3', '5', '11.33333333', '1', '0.3333', '0']
package org . apache . xpath . axes ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . functions . FuncLast ; import org . apache . xpath . functions . FuncPosition ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . operations . Div ; import org . apache . xpath . operations . Minus ; import org . apache . xpath . operations . Mod ; import org . apache . xpath . operations . Mult ; import org . apache . xpath . operations . Plus ; import org . apache . xpath . operations . Quo ; import org . apache . xpath . operations . Variable ; public class HasPositionalPredChecker extends XPathVisitor { private boolean m_hasPositionalPred = false ; private int m_predDepth = 0 ; public static boolean check ( LocPathIterator path ) { HasPositionalPredChecker hppc = new HasPositionalPredChecker ( ) ; path . callVisitors ( null , hppc ) ; return hppc . m_hasPositionalPred ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncPosition ) || ( func instanceof FuncLast ) ) m_hasPositionalPred = true ; return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { m_predDepth ++ ; if ( m_predDepth == 1 ) { if ( ( pred instanceof Variable ) || ( pred instanceof XNumber ) || ( pred instanceof Div ) || ( pred instanceof Plus ) || ( pred instanceof Minus ) || ( pred instanceof Mod ) || ( pred instanceof Quo ) || ( pred instanceof Mult ) || ( pred instanceof org . apache . xpath . operations . Number ) || ( pred instanceof Function ) ) m_hasPositionalPred = true ; else pred . callVisitors ( owner , this ) ; } m_predDepth -- ; return false ; } } 	0	['4', '2', '0', '17', '7', '0', '1', '16', '4', '0.166666667', '93', '1', '0', '0.8', '0.4', '0', '0', '21.75', '12', '4', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . IFLE ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IF_ICMPGE ; import org . apache . bcel . generic . IF_ICMPGT ; import org . apache . bcel . generic . IF_ICMPLE ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class BooleanType extends Type { protected BooleanType ( ) { } public String toString ( ) { return "boolean" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Z" ; } public boolean isSimple ( ) { return true ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . BOOLEAN ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; il . append ( new PUSH ( cpg , "true" ) ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( new PUSH ( cpg , "false" ) ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { methodGen . getInstructionList ( ) . append ( I2D ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( BOOLEAN_CLASS , "<init>" , "(Z)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz == java . lang . Boolean . TYPE ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Boolean . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { translateTo ( classGen , methodGen , clazz ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( BOOLEAN_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( BOOLEAN_CLASS , BOOLEAN_VALUE , BOOLEAN_VALUE_SIG ) ) ) ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } public BranchInstruction GT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGT ( null ) : ( BranchInstruction ) new IF_ICMPGT ( null ) ; } public BranchInstruction GE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGE ( null ) : ( BranchInstruction ) new IF_ICMPGE ( null ) ; } public BranchInstruction LT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLT ( null ) : ( BranchInstruction ) new IF_ICMPLT ( null ) ; } public BranchInstruction LE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLE ( null ) : ( BranchInstruction ) new IF_ICMPLE ( null ) ; } } 	0	['20', '2', '0', '49', '52', '188', '17', '36', '19', '2', '298', '0', '0', '0.634615385', '0.245', '1', '2', '13.9', '4', '1.45', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeCounterGenerator extends ClassGenerator { private Instruction _aloadTranslet ; public NodeCounterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public void setTransletIndex ( int index ) { _aloadTranslet = new ALOAD ( index ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['4', '4', '0', '5', '6', '4', '1', '4', '4', '0.666666667', '26', '1', '0', '0.964285714', '0.45', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionConstants ; public interface Constants extends InstructionConstants { public final int INTERNAL = 0 ; public final int UNSUPPORTED = 1 ; public final int FATAL = 2 ; public final int ERROR = 3 ; public final int WARNING = 4 ; public static final String EMPTYSTRING = "" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String TRANSLET_INTF = "org.apache.xalan.xsltc.Translet" ; public static final String TRANSLET_INTF_SIG = "Lorg/apache/xalan/xsltc/Translet;" ; public static final String ATTRIBUTES_SIG = "Lorg/apache/xalan/xsltc/runtime/Attributes;" ; public static final String NODE_ITERATOR_SIG = "Lorg/apache/xml/dtm/DTMAxisIterator;" ; public static final String DOM_INTF_SIG = "Lorg/apache/xalan/xsltc/DOM;" ; public static final String DOM_IMPL_CLASS = "org/apache/xalan/xsltc/DOM" ; public static final String SAX_IMPL_CLASS = "org/apache/xalan/xsltc/DOM/SAXImpl" ; public static final String DOM_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String SAX_IMPL_SIG = "Lorg/apache/xalan/xsltc/dom/SAXImpl;" ; public static final String DOM_ADAPTER_CLASS = "org/apache/xalan/xsltc/dom/DOMAdapter" ; public static final String DOM_ADAPTER_SIG = "Lorg/apache/xalan/xsltc/dom/DOMAdapter;" ; public static final String MULTI_DOM_CLASS = "org.apache.xalan.xsltc.dom.MultiDOM" ; public static final String MULTI_DOM_SIG = "Lorg/apache/xalan/xsltc/dom/MultiDOM;" ; public static final String STRING = "java.lang.String" ; public static final int ACC_PUBLIC = org . apache . bcel . Constants . ACC_PUBLIC ; public static final int ACC_SUPER = org . apache . bcel . Constants . ACC_SUPER ; public static final int ACC_FINAL = org . apache . bcel . Constants . ACC_FINAL ; public static final int ACC_PRIVATE = org . apache . bcel . Constants . ACC_PRIVATE ; public static final int ACC_PROTECTED = org . apache . bcel . Constants . ACC_PROTECTED ; public static final int ACC_STATIC = org . apache . bcel . Constants . ACC_STATIC ; public static final String STRING_SIG = "Ljava/lang/String;" ; public static final String STRING_BUFFER_SIG = "Ljava/lang/StringBuffer;" ; public static final String OBJECT_SIG = "Ljava/lang/Object;" ; public static final String DOUBLE_SIG = "Ljava/lang/Double;" ; public static final String INTEGER_SIG = "Ljava/lang/Integer;" ; public static final String COLLATOR_CLASS = "java/text/Collator" ; public static final String COLLATOR_SIG = "Ljava/text/Collator;" ; public static final String NODE = "int" ; public static final String NODE_ITERATOR = "org.apache.xml.dtm.DTMAxisIterator" ; public static final String NODE_ITERATOR_BASE = "org.apache.xml.dtm.ref.DTMAxisIteratorBase" ; public static final String SORT_ITERATOR = "org.apache.xalan.xsltc.dom.SortingIterator" ; public static final String SORT_ITERATOR_SIG = "Lorg.apache.xalan.xsltc.dom.SortingIterator;" ; public static final String NODE_SORT_RECORD = "org.apache.xalan.xsltc.dom.NodeSortRecord" ; public static final String NODE_SORT_FACTORY = "org/apache/xalan/xsltc/dom/NodeSortRecordFactory" ; public static final String NODE_SORT_RECORD_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecord;" ; public static final String NODE_SORT_FACTORY_SIG = "Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;" ; public static final String LOCALE_CLASS = "java.util.Locale" ; public static final String LOCALE_SIG = "Ljava/util/Locale;" ; public static final String STRING_VALUE_HANDLER = "org.apache.xalan.xsltc.runtime.StringValueHandler" ; public static final String STRING_VALUE_HANDLER_SIG = "Lorg/apache/xalan/xsltc/runtime/StringValueHandler;" ; public static final String OUTPUT_HANDLER = "org/apache/xml/serializer/SerializationHandler" ; public static final String OUTPUT_HANDLER_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String FILTER_INTERFACE = "org.apache.xalan.xsltc.dom.Filter" ; public static final String FILTER_INTERFACE_SIG = "Lorg/apache/xalan/xsltc/dom/Filter;" ; public static final String UNION_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.UnionIterator" ; public static final String STEP_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.StepIterator" ; public static final String CACHED_NODE_LIST_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.CachedNodeListIterator" ; public static final String NTH_ITERATOR_CLASS = "org.apache.xalan.xsltc.dom.NthIterator" ; public static final String ABSOLUTE_ITERATOR = "org.apache.xalan.xsltc.dom.AbsoluteIterator" ; public static final String DUP_FILTERED_ITERATOR = "org.apache.xalan.xsltc.dom.DupFilterIterator" ; public static final String CURRENT_NODE_LIST_ITERATOR = "org.apache.xalan.xsltc.dom.CurrentNodeListIterator" ; public static final String CURRENT_NODE_LIST_FILTER = "org.apache.xalan.xsltc.dom.CurrentNodeListFilter" ; public static final String CURRENT_NODE_LIST_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;" ; public static final String CURRENT_NODE_LIST_FILTER_SIG = "Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;" ; public static final String FILTER_STEP_ITERATOR = "org.apache.xalan.xsltc.dom.FilteredStepIterator" ; public static final String FILTER_ITERATOR = "org.apache.xalan.xsltc.dom.FilterIterator" ; public static final String SINGLETON_ITERATOR = "org.apache.xalan.xsltc.dom.SingletonIterator" ; public static final String MATCHING_ITERATOR = "org.apache.xalan.xsltc.dom.MatchingIterator" ; public static final String NODE_SIG = "I" ; public static final String GET_PARENT = "getParent" ; public static final String GET_PARENT_SIG = "(" + NODE_SIG + ")" + NODE_SIG ; public static final String NEXT_SIG = "()" + NODE_SIG ; public static final String NEXT = "next" ; public static final String NEXTID = "nextNodeID" ; public static final String MAKE_NODE = "makeNode" ; public static final String MAKE_NODE_LIST = "makeNodeList" ; public static final String GET_UNPARSED_ENTITY_URI = "getUnparsedEntityURI" ; public static final String STRING_TO_REAL = "stringToReal" ; public static final String STRING_TO_REAL_SIG = "(" + STRING_SIG + ")D" ; public static final String STRING_TO_INT = "stringToInt" ; public static final String STRING_TO_INT_SIG = "(" + STRING_SIG + ")I" ; public static final String XSLT_PACKAGE = "org.apache.xalan.xsltc" ; public static final String COMPILER_PACKAGE = XSLT_PACKAGE + ".compiler" ; public static final String RUNTIME_PACKAGE = XSLT_PACKAGE + ".runtime" ; public static final String TRANSLET_CLASS = RUNTIME_PACKAGE + ".AbstractTranslet" ; public static final String TRANSLET_SIG = "Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;" ; public static final String UNION_ITERATOR_SIG = "Lorg/apache/xalan/xsltc/dom/UnionIterator;" ; public static final String TRANSLET_OUTPUT_SIG = "Lorg/apache/xml/serializer/SerializationHandler;" ; public static final String MAKE_NODE_SIG = "(I)Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/Node;" ; public static final String MAKE_NODE_LIST_SIG = "(I)Lorg/w3c/dom/NodeList;" ; public static final String MAKE_NODE_LIST_SIG2 = "(" + NODE_ITERATOR_SIG + ")Lorg/w3c/dom/NodeList;" ; public static final String STREAM_XML_OUTPUT = "org.apache.xml.serializer.ToXMLStream" ; public static final String OUTPUT_BASE = "org.apache.xml.serializer.SerializerBase" ; public static final String LOAD_DOCUMENT_CLASS = "org.apache.xalan.xsltc.dom.LoadDocument" ; public static final String KEY_INDEX_CLASS = "org/apache/xalan/xsltc/dom/KeyIndex" ; public static final String KEY_INDEX_SIG = "Lorg/apache/xalan/xsltc/dom/KeyIndex;" ; public static final String DOM_INTF = "org.apache.xalan.xsltc.DOM" ; public static final String DOM_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String SAX_IMPL = "org.apache.xalan.xsltc.dom.SAXImpl" ; public static final String STRING_CLASS = "java.lang.String" ; public static final String OBJECT_CLASS = "java.lang.Object" ; public static final String BOOLEAN_CLASS = "java.lang.Boolean" ; public static final String STRING_BUFFER_CLASS = "java.lang.StringBuffer" ; public static final String STRING_WRITER = "java.io.StringWriter" ; public static final String WRITER_SIG = "Ljava/io/Writer;" ; public static final String TRANSLET_OUTPUT_BASE = "org.apache.xalan.xsltc.TransletOutputBase" ; public static final String CALL_FUNCTION_CLASS = "org.apache.xalan.xsltc.runtime.CallFunction" ; public static final String TRANSLET_OUTPUT_INTERFACE = "org.apache.xml.serializer.SerializationHandler" ; public static final String BASIS_LIBRARY_CLASS = "org.apache.xalan.xsltc.runtime.BasisLibrary" ; public static final String ATTRIBUTE_LIST_IMPL_CLASS = "org.apache.xalan.xsltc.runtime.AttributeListImpl" ; public static final String DOUBLE_CLASS = "java.lang.Double" ; public static final String INTEGER_CLASS = "java.lang.Integer" ; public static final String RUNTIME_NODE_CLASS = "org.apache.xalan.xsltc.runtime.Node" ; public static final String MATH_CLASS = "java.lang.Math" ; public static final String BOOLEAN_VALUE = "booleanValue" ; public static final String BOOLEAN_VALUE_SIG = "()Z" ; public static final String INT_VALUE = "intValue" ; public static final String INT_VALUE_SIG = "()I" ; public static final String DOUBLE_VALUE = "doubleValue" ; public static final String DOUBLE_VALUE_SIG = "()D" ; public static final String DOM_PNAME = "dom" ; public static final String NODE_PNAME = "node" ; public static final String TRANSLET_OUTPUT_PNAME = "handler" ; public static final String ITERATOR_PNAME = "iterator" ; public static final String DOCUMENT_PNAME = "document" ; public static final String TRANSLET_PNAME = "translet" ; public static final String INVOKE_METHOD = "invokeMethod" ; public static final String GET_NODE_NAME = "getNodeNameX" ; public static final String CHARACTERSW = "characters" ; public static final String GET_CHILDREN = "getChildren" ; public static final String GET_TYPED_CHILDREN = "getTypedChildren" ; public static final String CHARACTERS = "characters" ; public static final String APPLY_TEMPLATES = "applyTemplates" ; public static final String GET_NODE_TYPE = "getNodeType" ; public static final String GET_NODE_VALUE = "getStringValueX" ; public static final String GET_ELEMENT_VALUE = "getElementValue" ; public static final String GET_ATTRIBUTE_VALUE = "getAttributeValue" ; public static final String HAS_ATTRIBUTE = "hasAttribute" ; public static final String ADD_ITERATOR = "addIterator" ; public static final String SET_START_NODE = "setStartNode" ; public static final String RESET = "reset" ; public static final String ATTR_SET_SIG = "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String GET_NODE_NAME_SIG = "(" + NODE_SIG + ")" + STRING_SIG ; public static final String CHARACTERSW_SIG = "(" + STRING_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String CHARACTERS_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; public static final String GET_CHILDREN_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String GET_TYPED_CHILDREN_SIG = "(I)" + NODE_ITERATOR_SIG ; public static final String GET_NODE_TYPE_SIG = "()S" ; public static final String GET_NODE_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ELEMENT_VALUE_SIG = "(I)" + STRING_SIG ; public static final String GET_ATTRIBUTE_VALUE_SIG = "(II)" + STRING_SIG ; public static final String HAS_ATTRIBUTE_SIG = "(II)Z" ; public static final String GET_ITERATOR_SIG = "()" + NODE_ITERATOR_SIG ; public static final String NAMES_INDEX = "namesArray" ; public static final String NAMES_INDEX_SIG = "[" + STRING_SIG ; public static final String URIS_INDEX = "urisArray" ; public static final String URIS_INDEX_SIG = "[" + STRING_SIG ; public static final String TYPES_INDEX = "typesArray" ; public static final String TYPES_INDEX_SIG = "[I" ; public static final String NAMESPACE_INDEX = "namespaceArray" ; public static final String NAMESPACE_INDEX_SIG = "[" + STRING_SIG ; public static final String HASIDCALL_INDEX = "_hasIdCall" ; public static final String HASIDCALL_INDEX_SIG = "Z" ; public static final String TRANSLET_VERSION_INDEX = "transletVersion" ; public static final String TRANSLET_VERSION_INDEX_SIG = "I" ; public static final String DOM_FIELD = "_dom" ; public static final String STATIC_NAMES_ARRAY_FIELD = "_sNamesArray" ; public static final String STATIC_URIS_ARRAY_FIELD = "_sUrisArray" ; public static final String STATIC_TYPES_ARRAY_FIELD = "_sTypesArray" ; public static final String STATIC_NAMESPACE_ARRAY_FIELD = "_sNamespaceArray" ; public static final String STATIC_CHAR_DATA_FIELD = "_scharData" ; public static final String STATIC_CHAR_DATA_FIELD_SIG = "[C" ; public static final String FORMAT_SYMBOLS_FIELD = "format_symbols" ; public static final String ITERATOR_FIELD_SIG = NODE_ITERATOR_SIG ; public static final String NODE_FIELD = "node" ; public static final String NODE_FIELD_SIG = "I" ; public static final String EMPTYATTR_FIELD = "EmptyAttributes" ; public static final String ATTRIBUTE_LIST_FIELD = "attributeList" ; public static final String CLEAR_ATTRIBUTES = "clear" ; public static final String ADD_ATTRIBUTE = "addAttribute" ; public static final String ATTRIBUTE_LIST_IMPL_SIG = "Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;" ; public static final String CLEAR_ATTRIBUTES_SIG = "()" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ATTRIBUTE_SIG = "(" + STRING_SIG + STRING_SIG + ")" + ATTRIBUTE_LIST_IMPL_SIG ; public static final String ADD_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + ")" + UNION_ITERATOR_SIG ; public static final String ORDER_ITERATOR = "orderNodes" ; public static final String ORDER_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I)" + NODE_ITERATOR_SIG ; public static final String SET_START_NODE_SIG = "(" + NODE_SIG + ")" + NODE_ITERATOR_SIG ; public static final String NODE_COUNTER = "org.apache.xalan.xsltc.dom.NodeCounter" ; public static final String NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/NodeCounter;" ; public static final String DEFAULT_NODE_COUNTER = "org.apache.xalan.xsltc.dom.DefaultNodeCounter" ; public static final String DEFAULT_NODE_COUNTER_SIG = "Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;" ; public static final String TRANSLET_FIELD = "translet" ; public static final String TRANSLET_FIELD_SIG = TRANSLET_SIG ; public static final String RESET_SIG = "()" + NODE_ITERATOR_SIG ; public static final String GET_PARAMETER = "getParameter" ; public static final String ADD_PARAMETER = "addParameter" ; public static final String PUSH_PARAM_FRAME = "pushParamFrame" ; public static final String PUSH_PARAM_FRAME_SIG = "()V" ; public static final String POP_PARAM_FRAME = "popParamFrame" ; public static final String POP_PARAM_FRAME_SIG = "()V" ; public static final String GET_PARAMETER_SIG = "(" + STRING_SIG + ")" + OBJECT_SIG ; public static final String ADD_PARAMETER_SIG = "(" + STRING_SIG + OBJECT_SIG + "Z)" + OBJECT_SIG ; public static final String STRIP_SPACE = "stripSpace" ; public static final String STRIP_SPACE_INTF = "org/apache/xalan/xsltc/StripFilter" ; public static final String STRIP_SPACE_SIG = "Lorg/apache/xalan/xsltc/StripFilter;" ; public static final String STRIP_SPACE_PARAMS = "(Lorg/apache/xalan/xsltc/DOM;II)Z" ; public static final String GET_NODE_VALUE_ITERATOR = "getNodeValueIterator" ; public static final String GET_NODE_VALUE_ITERATOR_SIG = "(" + NODE_ITERATOR_SIG + "I" + STRING_SIG + "Z)" + NODE_ITERATOR_SIG ; public static final String GET_UNPARSED_ENTITY_URI_SIG = "(" + STRING_SIG + ")" + STRING_SIG ; public static final int POSITION_INDEX = 2 ; public static final int LAST_INDEX = 3 ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; public static final String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String XHTML_URI = "http://www.w3.org/1999/xhtml" ; public static final String TRANSLET_URI = "http://xml.apache.org/xalan/xsltc" ; public static final String REDIRECT_URI = "http://xml.apache.org/xalan/redirect" ; public static final String FALLBACK_CLASS = "org.apache.xalan.xsltc.compiler.Fallback" ; public static final int RTF_INITIAL_SIZE = 32 ; } 	0	['0', '1', '0', '6', '0', '0', '5', '1', '0', '2', '218', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xpath . functions ; public class WrongNumberArgsException extends Exception { public WrongNumberArgsException ( String argsExpected ) { super ( argsExpected ) ; } } 	0	['1', '3', '0', '12', '2', '0', '12', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . io . IOException ; import java . io . OutputStream ; import java . io . Writer ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . trax . SAX2DOM ; import org . apache . xml . serializer . ToHTMLSAXHandler ; import org . apache . xml . serializer . ToHTMLStream ; import org . apache . xml . serializer . ToTextSAXHandler ; import org . apache . xml . serializer . ToTextStream ; import org . apache . xml . serializer . ToUnknownStream ; import org . apache . xml . serializer . ToXMLSAXHandler ; import org . apache . xml . serializer . ToXMLStream ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . ext . LexicalHandler ; public class TransletOutputHandlerFactory { public static final int STREAM = 0 ; public static final int SAX = 1 ; public static final int DOM = 2 ; private String _encoding = "utf-8" ; private String _method = null ; private int _outputType = STREAM ; private OutputStream _ostream = System . out ; private Writer _writer = null ; private Node _node = null ; private int _indentNumber = - 1 ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; static public TransletOutputHandlerFactory newInstance ( ) { return new TransletOutputHandlerFactory ( ) ; } public void setOutputType ( int outputType ) { _outputType = outputType ; } public void setEncoding ( String encoding ) { if ( encoding != null ) { _encoding = encoding ; } } public void setOutputMethod ( String method ) { _method = method ; } public void setOutputStream ( OutputStream ostream ) { _ostream = ostream ; } public void setWriter ( Writer writer ) { _writer = writer ; } public void setHandler ( ContentHandler handler ) { _handler = handler ; } public void setLexicalHandler ( LexicalHandler lex ) { _lexHandler = lex ; } public void setNode ( Node node ) { _node = node ; } public Node getNode ( ) { return ( _handler instanceof SAX2DOM ) ? ( ( SAX2DOM ) _handler ) . getDOM ( ) : null ; } public void setIndentNumber ( int value ) { _indentNumber = value ; } public SerializationHandler getSerializationHandler ( ) throws IOException , ParserConfigurationException { SerializationHandler result = null ; switch ( _outputType ) { case STREAM : if ( _method == null ) { result = new ToUnknownStream ( ) ; } else if ( _method . equalsIgnoreCase ( "xml" ) ) { result = new ToXMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "html" ) ) { result = new ToHTMLStream ( ) ; } else if ( _method . equalsIgnoreCase ( "text" ) ) { result = new ToTextStream ( ) ; } if ( result != null && _indentNumber >= 0 ) { result . setIndentAmount ( _indentNumber ) ; } result . setEncoding ( _encoding ) ; if ( _writer != null ) { result . setWriter ( _writer ) ; } else { result . setOutputStream ( _ostream ) ; } return result ; case DOM : _handler = ( _node != null ) ? new SAX2DOM ( _node ) : new SAX2DOM ( ) ; _lexHandler = ( LexicalHandler ) _handler ; case SAX : if ( _method == null ) { _method = "xml" ; } if ( _method . equalsIgnoreCase ( "xml" ) ) { if ( _lexHandler == null ) { result = new ToXMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToXMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "html" ) ) { if ( _lexHandler == null ) { result = new ToHTMLSAXHandler ( _handler , _encoding ) ; } else { result = new ToHTMLSAXHandler ( _handler , _lexHandler , _encoding ) ; } } else if ( _method . equalsIgnoreCase ( "text" ) ) { if ( _lexHandler == null ) { result = new ToTextSAXHandler ( _handler , _encoding ) ; } else { result = new ToTextSAXHandler ( _handler , _lexHandler , _encoding ) ; } } return result ; } return null ; } } 	0	['13', '1', '0', '12', '32', '34', '3', '9', '13', '0.826388889', '289', '0.75', '0', '0', '0.201923077', '0', '0', '20.30769231', '2', '1.0769', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; class TopLevelElement extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } public InstructionList compile ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList result , save = methodGen . getInstructionList ( ) ; methodGen . setInstructionList ( result = new InstructionList ( ) ) ; translate ( classGen , methodGen ) ; methodGen . setInstructionList ( save ) ; return result ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "TopLevelElement" ) ; displayContents ( indent + IndentIncrement ) ; } } 	0	['5', '2', '10', '24', '17', '10', '14', '10', '4', '2', '56', '0', '0', '0.931034483', '0.44', '1', '4', '10.2', '1', '0.8', '0']
package org . apache . xml . utils . synthetic ; import org . apache . xml . utils . synthetic . reflection . Method ; public class TestDriver { public static int sampleField = 32 ; private boolean inTest = false ; public static void main ( String [ ] args ) { try { System . out . println ( "Proxying java.awt.Frame..." ) ; Class myC = Class . forName ( "java.awt.Frame" ) ; myC . toSource ( System . out , 0 ) ; System . out . println ( "\nProxying org.apache.xml.utils.synthetic.TestDriver..." ) ; myC = Class . forName ( "com.ibm.org.apache.xml.utils.synthetic.TestDriver" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "Couldn't proxy: " ) ; e . printStackTrace ( ) ; } try { System . out . println ( "\nBuild a new beast..." ) ; Class myC = Class . declareClass ( "com.ibm.org.apache.xml.utils.synthetic.BuildMe" ) ; Class inner = myC . declareInnerClass ( "island" ) ; inner . addExtends ( Class . forName ( "java.lang.String" ) ) ; Method m = inner . declareMethod ( "getValue" ) ; m . setReturnType ( Class . forName ( "java.lang.String" ) ) ; m . getBody ( ) . append ( "return toString();" ) ; myC . toSource ( System . out , 0 ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } catch ( IllegalStateException e ) { System . out . println ( "Unwritten function: " + e ) ; e . printStackTrace ( ) ; } } public static void dumpClass ( Class C ) { System . out . println ( "toString(): " + C ) ; System . out . println ( "\tisPrimitive(): " + C . isPrimitive ( ) ) ; System . out . println ( "\tisInterface(): " + C . isInterface ( ) ) ; System . out . println ( "\tisInstance(\"foo\"): " + C . isInstance ( "foo" ) ) ; System . out . println ( "\tisArray(): " + C . isArray ( ) ) ; System . out . println ( "\tgetRealClass(): " + C . getRealClass ( ) ) ; } public void quickcheck ( ) { Inner a = new Inner ( ) ; a . setTest ( ! a . getTest ( ) ) ; } private class Inner { public boolean getTest ( ) { return inTest ; } public void setTest ( boolean test ) { inTest = test ; } } } 	0	['7', '1', '0', '5', '34', '15', '1', '5', '4', '0.833333333', '189', '0.5', '0', '0', '0.233333333', '0', '0', '25.71428571', '2', '0.8571', '0']
package org . apache . xalan . lib ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . processor ; public class ProcessorStylesheetDoc extends XSLTElementProcessor { } 	0	['1', '4', '0', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class IntStack extends IntVector { public IntStack ( ) { super ( ) ; } public IntStack ( int blocksize ) { super ( blocksize ) ; } public IntStack ( IntStack v ) { super ( v ) ; } public int push ( int i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public final int pop ( ) { return m_map [ -- m_firstFree ] ; } public final void quickPop ( int n ) { m_firstFree -= n ; } public final int peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public int peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( int val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( int o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { return ( IntStack ) super . clone ( ) ; } } 	0	['12', '2', '0', '11', '20', '24', '10', '1', '12', '2', '153', '0', '0', '0.64', '0.527777778', '1', '14', '11.75', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; final class LastCall extends FunctionCall { public LastCall ( QName fname ) { super ( fname ) ; } public boolean hasPositionCall ( ) { return true ; } public boolean hasLastCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadLastNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( LAST_INDEX ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int getLast = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getLast" , "()I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKEINTERFACE ( getLast , 1 ) ) ; } } } 	0	['4', '4', '0', '12', '13', '6', '0', '12', '4', '2', '59', '0', '0', '0.96969697', '0.4375', '2', '4', '13.75', '3', '1.25', '0']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xml . serializer ; import org . xml . sax . SAXException ; public interface ExtendedLexicalHandler extends org . xml . sax . ext . LexicalHandler { public void comment ( String comment ) throws SAXException ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncStringLength extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } } 	0	['2', '5', '0', '5', '6', '1', '0', '5', '2', '2', '14', '0', '0', '0.982142857', '0.75', '2', '7', '6', '1', '0.5', '0']
package org . apache . xalan . xsltc . dom ; import java . text . CollationKey ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . CollatorFactory ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . utils . StringComparable ; public abstract class NodeSortRecord { public static final int COMPARE_STRING = 0 ; public static final int COMPARE_NUMERIC = 1 ; public static final int COMPARE_ASCENDING = 0 ; public static final int COMPARE_DESCENDING = 1 ; private static final Collator DEFAULT_COLLATOR = Collator . getInstance ( ) ; protected Collator _collator = DEFAULT_COLLATOR ; protected Collator [ ] _collators ; protected Locale _locale ; protected CollatorFactory _collatorFactory ; protected SortSettings _settings ; private DOM _dom = null ; private int _node ; private int _last = 0 ; private int _scanned = 0 ; private Object [ ] _values ; public NodeSortRecord ( int node ) { _node = node ; } public NodeSortRecord ( ) { this ( 0 ) ; } public final void initialize ( int node , int last , DOM dom , SortSettings settings ) throws TransletException { _dom = dom ; _node = node ; _last = last ; _settings = settings ; int levels = settings . getSortOrders ( ) . length ; _values = new Object [ levels ] ; String colFactClassname = System . getProperty ( "org.apache.xalan.xsltc.COLLATOR_FACTORY" ) ; if ( colFactClassname != null ) { try { Object candObj = ObjectFactory . findProviderClass ( colFactClassname , ObjectFactory . findClassLoader ( ) , true ) ; _collatorFactory = ( CollatorFactory ) candObj ; } catch ( ClassNotFoundException e ) { throw new TransletException ( e ) ; } Locale [ ] locales = settings . getLocales ( ) ; _collators = new Collator [ levels ] ; for ( int i = 0 ; i < levels ; i ++ ) { _collators [ i ] = _collatorFactory . getCollator ( locales [ i ] ) ; } _collator = _collators [ 0 ] ; } else { _collators = settings . getCollators ( ) ; _collator = _collators [ 0 ] ; } } public final int getNode ( ) { return _node ; } public final int compareDocOrder ( NodeSortRecord other ) { return _node - other . _node ; } private final Comparable stringValue ( int level ) { if ( _scanned <= level ) { AbstractTranslet translet = _settings . getTranslet ( ) ; Locale [ ] locales = _settings . getLocales ( ) ; String [ ] caseOrder = _settings . getCaseOrders ( ) ; final String str = extractValueFromDOM ( _dom , _node , level , translet , _last ) ; final Comparable key = StringComparable . getComparator ( str , locales [ level ] , _collators [ level ] , caseOrder [ level ] ) ; _values [ _scanned ++ ] = key ; return ( key ) ; } return ( ( Comparable ) _values [ level ] ) ; } private final Double numericValue ( int level ) { if ( _scanned <= level ) { AbstractTranslet translet = _settings . getTranslet ( ) ; final String str = extractValueFromDOM ( _dom , _node , level , translet , _last ) ; Double num ; try { num = new Double ( str ) ; } catch ( NumberFormatException e ) { num = new Double ( Double . NEGATIVE_INFINITY ) ; } _values [ _scanned ++ ] = num ; return ( num ) ; } return ( ( Double ) _values [ level ] ) ; } public int compareTo ( NodeSortRecord other ) { int cmp , level ; int [ ] sortOrder = _settings . getSortOrders ( ) ; int levels = _settings . getSortOrders ( ) . length ; int [ ] compareTypes = _settings . getTypes ( ) ; for ( level = 0 ; level < levels ; level ++ ) { if ( compareTypes [ level ] == COMPARE_NUMERIC ) { final Double our = numericValue ( level ) ; final Double their = other . numericValue ( level ) ; cmp = our . compareTo ( their ) ; } else { final Comparable our = stringValue ( level ) ; final Comparable their = other . stringValue ( level ) ; cmp = our . compareTo ( their ) ; } if ( cmp != 0 ) { return sortOrder [ level ] == COMPARE_DESCENDING ? 0 - cmp : cmp ; } } return ( _node - other . _node ) ; } public Collator [ ] getCollator ( ) { return _collators ; } public abstract String extractValueFromDOM ( DOM dom , int current , int level , AbstractTranslet translet , int last ) ; } 	0	['11', '1', '0', '9', '29', '7', '2', '7', '8', '0.806666667', '324', '0.733333333', '3', '0', '0.35', '0', '0', '27.09090909', '5', '1.2727', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . serializer . ElemDesc ; import org . apache . xml . serializer . SerializationHandler ; final class LiteralAttribute extends Instruction { private final String _name ; private final AttributeValue _value ; public LiteralAttribute ( String name , String value , Parser parser ) { _name = name ; _value = AttributeValue . create ( this , value , parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralAttribute name=" + _name + " value=" + _value ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _value . typeCheck ( stable ) ; typeCheckContents ( stable ) ; return Type . Void ; } protected boolean contextDependent ( ) { return _value . contextDependent ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; _value . translate ( classGen , methodGen ) ; SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof LiteralElement && ( ( LiteralElement ) parent ) . allAttributesUnique ( ) ) { int flags = 0 ; boolean isHTMLAttrEmpty = false ; ElemDesc elemDesc = ( ( LiteralElement ) parent ) . getElemDesc ( ) ; if ( elemDesc != null ) { if ( elemDesc . isAttrFlagSet ( _name , ElemDesc . ATTREMPTY ) ) { flags = flags | SerializationHandler . HTML_ATTREMPTY ; isHTMLAttrEmpty = true ; } else if ( elemDesc . isAttrFlagSet ( _name , ElemDesc . ATTRURL ) ) { flags = flags | SerializationHandler . HTML_ATTRURL ; } } if ( _value instanceof SimpleAttributeValue ) { String attrValue = ( ( SimpleAttributeValue ) _value ) . toString ( ) ; if ( ! hasBadChars ( attrValue ) && ! isHTMLAttrEmpty ) { flags = flags | SerializationHandler . NO_BAD_CHARS ; } } il . append ( new PUSH ( cpg , flags ) ) ; il . append ( methodGen . uniqueAttribute ( ) ) ; } else { il . append ( methodGen . attribute ( ) ) ; } } private boolean hasBadChars ( String value ) { char [ ] chars = value . toCharArray ( ) ; int size = chars . length ; for ( int i = 0 ; i < size ; i ++ ) { char ch = chars [ i ] ; if ( ch < 32 || 126 < ch || ch == '<' || ch == '>' || ch == '&' || ch == '\"' ) return true ; } return false ; } public String getName ( ) { return _name ; } public AttributeValue getValue ( ) { return _value ; } } 	0	['8', '3', '0', '20', '35', '0', '2', '19', '6', '0.428571429', '208', '1', '1', '0.888888889', '0.267857143', '1', '4', '24.75', '9', '2.75', '0']
package org . apache . xalan . processor ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xml . serializer . OutputPropertiesFactory ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . Attributes ; class ProcessorOutputElem extends XSLTElementProcessor { private OutputProperties m_outputProperties ; public void setCdataSectionElements ( java . util . Vector newValue ) { m_outputProperties . setQNameProperties ( OutputKeys . CDATA_SECTION_ELEMENTS , newValue ) ; } public void setDoctypePublic ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . DOCTYPE_PUBLIC , newValue ) ; } public void setDoctypeSystem ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . DOCTYPE_SYSTEM , newValue ) ; } public void setEncoding ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . ENCODING , newValue ) ; } public void setIndent ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . INDENT , newValue ) ; } public void setMediaType ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . MEDIA_TYPE , newValue ) ; } public void setMethod ( org . apache . xml . utils . QName newValue ) { m_outputProperties . setQNameProperty ( OutputKeys . METHOD , newValue ) ; } public void setOmitXmlDeclaration ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . OMIT_XML_DECLARATION , newValue ) ; } public void setStandalone ( boolean newValue ) { m_outputProperties . setBooleanProperty ( OutputKeys . STANDALONE , newValue ) ; } public void setVersion ( String newValue ) { m_outputProperties . setProperty ( OutputKeys . VERSION , newValue ) ; } public void setForeignAttr ( String attrUri , String attrLocalName , String attrRawName , String attrValue ) { QName key = new QName ( attrUri , attrLocalName ) ; m_outputProperties . setProperty ( key , attrValue ) ; } public void addLiteralResultAttribute ( String attrUri , String attrLocalName , String attrRawName , String attrValue ) { QName key = new QName ( attrUri , attrLocalName ) ; m_outputProperties . setProperty ( key , attrValue ) ; } public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { m_outputProperties = new OutputProperties ( ) ; m_outputProperties . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; m_outputProperties . setLocaterInfo ( handler . getLocator ( ) ) ; m_outputProperties . setUid ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , this ) ; String entitiesFileName = ( String ) m_outputProperties . getProperties ( ) . get ( OutputPropertiesFactory . S_KEY_ENTITIES ) ; if ( null != entitiesFileName ) { try { String absURL = SystemIDResolver . getAbsoluteURI ( entitiesFileName , handler . getBaseIdentifier ( ) ) ; m_outputProperties . getProperties ( ) . put ( OutputPropertiesFactory . S_KEY_ENTITIES , absURL ) ; } catch ( TransformerException te ) { handler . error ( te . getMessage ( ) , te ) ; } } handler . getStylesheet ( ) . setOutput ( m_outputProperties ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( m_outputProperties ) ; m_outputProperties = null ; } } 	0	['14', '4', '0', '9', '40', '0', '1', '8', '13', '0.076923077', '174', '1', '1', '0.941704036', '0.295918367', '2', '3', '11.35714286', '1', '0.9286', '0']
package org . apache . xalan . templates ; import java . io . Serializable ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . patterns . StepPattern ; class TemplateSubPatternAssociation implements Serializable , Cloneable { StepPattern m_stepPattern ; private String m_pattern ; private ElemTemplate m_template ; private TemplateSubPatternAssociation m_next = null ; private boolean m_wild ; private String m_targetString ; TemplateSubPatternAssociation ( ElemTemplate template , StepPattern pattern , String pat ) { m_pattern = pat ; m_template = template ; m_stepPattern = pattern ; m_targetString = m_stepPattern . getTargetString ( ) ; m_wild = m_targetString . equals ( "*" ) ; } public Object clone ( ) throws CloneNotSupportedException { TemplateSubPatternAssociation tspa = ( TemplateSubPatternAssociation ) super . clone ( ) ; tspa . m_next = null ; return tspa ; } public final String getTargetString ( ) { return m_targetString ; } public void setTargetString ( String key ) { m_targetString = key ; } boolean matchMode ( QName m1 ) { return matchModes ( m1 , m_template . getMode ( ) ) ; } private boolean matchModes ( QName m1 , QName m2 ) { return ( ( ( null == m1 ) && ( null == m2 ) ) || ( ( null != m1 ) && ( null != m2 ) && m1 . equals ( m2 ) ) ) ; } public boolean matches ( XPathContext xctxt , int targetNode , QName mode ) throws TransformerException { double score = m_stepPattern . getMatchScore ( xctxt , targetNode ) ; return ( XPath . MATCH_SCORE_NONE != score ) && matchModes ( mode , m_template . getMode ( ) ) ; } public final boolean isWild ( ) { return m_wild ; } public final StepPattern getStepPattern ( ) { return m_stepPattern ; } public final String getPattern ( ) { return m_pattern ; } public int getDocOrderPos ( ) { return m_template . getUid ( ) ; } public final int getImportLevel ( ) { return m_template . getStylesheetComposed ( ) . getImportCountComposed ( ) ; } public final ElemTemplate getTemplate ( ) { return m_template ; } public final TemplateSubPatternAssociation getNext ( ) { return m_next ; } public void setNext ( TemplateSubPatternAssociation mp ) { m_next = mp ; } } 	0	['15', '1', '0', '7', '25', '49', '2', '5', '12', '0.833333333', '139', '0.833333333', '3', '0', '0.208333333', '0', '0', '7.866666667', '6', '1.2667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Attribute extends Instruction { private QName _name ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "Attribute " + _name ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _name = parser . getQName ( getAttribute ( "name" ) ) ; parseChildren ( parser ) ; } } 	0	['3', '3', '0', '4', '14', '1', '0', '4', '2', '0.5', '37', '1', '1', '0.965517241', '0.555555556', '1', '4', '11', '1', '0.6667', '0']
package org . apache . xml . utils ; import org . w3c . dom . Node ; public interface NodeConsumer { public void setOriginatingNode ( Node n ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public interface CoroutineParser { public int getParserCoroutineID ( ) ; public CoroutineManager getCoroutineManager ( ) ; public void setContentHandler ( ContentHandler handler ) ; public void setLexHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public Object doParse ( InputSource source , int appCoroutine ) ; public Object doMore ( boolean parsemore , int appCoroutine ) ; public void doTerminate ( int appCoroutine ) ; public void init ( CoroutineManager co , int appCoroutineID , XMLReader parser ) ; } 	0	['8', '1', '0', '1', '8', '28', '0', '1', '8', '2', '8', '0', '0', '0', '0.28125', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Otherwise extends Instruction { public void display ( int indent ) { indent ( indent ) ; Util . println ( "Otherwise" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Parser parser = getParser ( ) ; final ErrorMsg err = new ErrorMsg ( ErrorMsg . STRAY_OTHERWISE_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } } 	0	['4', '3', '0', '12', '12', '6', '3', '10', '3', '2', '43', '0', '0', '0.949152542', '0.4', '1', '4', '9.75', '1', '0.75', '0']
package org . apache . xpath ; public interface XPathVisitable { public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) ; } 	0	['1', '1', '0', '3', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncCount extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator nl = m_arg0 . asIterator ( xctxt , xctxt . getCurrentNode ( ) ) ; int i = nl . getLength ( ) ; nl . detach ( ) ; return new XNumber ( ( double ) i ) ; } } 	0	['2', '4', '0', '6', '8', '1', '0', '6', '2', '2', '23', '0', '0', '0.979591837', '0.75', '1', '6', '10.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime ; import org . xml . sax . SAXException ; import org . apache . xml . serializer . EmptySerializer ; public final class StringValueHandler extends EmptySerializer { private StringBuffer _buffer = new StringBuffer ( ) ; private String _str = null ; private static final String EMPTY_STR = "" ; private boolean m_escaping = false ; private int _nestedLevel = 0 ; public void characters ( char [ ] ch , int off , int len ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( ch , off , len ) ; } public String getValue ( ) { if ( _buffer . length ( ) != 0 ) { String result = _buffer . toString ( ) ; _buffer . setLength ( 0 ) ; return result ; } else { String result = _str ; _str = null ; return ( result != null ) ? result : EMPTY_STR ; } } public void characters ( String characters ) throws SAXException { if ( _nestedLevel > 0 ) return ; if ( _str == null && _buffer . length ( ) == 0 ) { _str = characters ; } else { if ( _str != null ) { _buffer . append ( _str ) ; _str = null ; } _buffer . append ( characters ) ; } } public void startElement ( String qname ) throws SAXException { _nestedLevel ++ ; } public void endElement ( String qname ) throws SAXException { _nestedLevel -- ; } public boolean setEscaping ( boolean bool ) { boolean oldEscaping = m_escaping ; m_escaping = bool ; return bool ; } public String getValueOfPI ( ) { final String value = getValue ( ) ; if ( value . indexOf ( "?>" ) > 0 ) { final int n = value . length ( ) ; final StringBuffer valueOfPI = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; ) { final char ch = value . charAt ( i ++ ) ; if ( ch == '?' && value . charAt ( i ) == '>' ) { valueOfPI . append ( "? >" ) ; i ++ ; } else { valueOfPI . append ( ch ) ; } } return valueOfPI . toString ( ) ; } return value ; } } 	0	['8', '2', '0', '2', '19', '0', '1', '1', '8', '0.657142857', '183', '1', '0', '0.932692308', '0.35', '0', '0', '21.25', '5', '1.625', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . NodeTest ; public abstract class Type implements Constants { public static final Type Int = new IntType ( ) ; public static final Type Real = new RealType ( ) ; public static final Type Boolean = new BooleanType ( ) ; public static final Type NodeSet = new NodeSetType ( ) ; public static final Type String = new StringType ( ) ; public static final Type ResultTree = new ResultTreeType ( ) ; public static final Type Reference = new ReferenceType ( ) ; public static final Type Void = new VoidType ( ) ; public static final Type Object = new ObjectType ( java . lang . Object . class ) ; public static final Type ObjectString = new ObjectType ( java . lang . String . class ) ; public static final Type Node = new NodeType ( NodeTest . ANODE ) ; public static final Type Root = new NodeType ( NodeTest . ROOT ) ; public static final Type Element = new NodeType ( NodeTest . ELEMENT ) ; public static final Type Attribute = new NodeType ( NodeTest . ATTRIBUTE ) ; public static final Type Text = new NodeType ( NodeTest . TEXT ) ; public static final Type Comment = new NodeType ( NodeTest . COMMENT ) ; public static final Type Processing_Instruction = new NodeType ( NodeTest . PI ) ; public static Type newObjectType ( String javaClassName ) { if ( javaClassName == "java.lang.Object" ) { return Type . Object ; } else if ( javaClassName == "java.lang.String" ) { return Type . ObjectString ; } else { return new ObjectType ( javaClassName ) ; } } public static Type newObjectType ( Class clazz ) { if ( clazz == java . lang . Object . class ) { return Type . Object ; } else if ( clazz == java . lang . String . class ) { return Type . ObjectString ; } else { return new ObjectType ( clazz ) ; } } public abstract String toString ( ) ; public abstract boolean identicalTo ( Type other ) ; public boolean isNumber ( ) { return false ; } public boolean implementedAsMethod ( ) { return false ; } public boolean isSimple ( ) { return false ; } public abstract org . apache . bcel . generic . Type toJCType ( ) ; public int distanceTo ( Type type ) { return type == this ? 0 : Integer . MAX_VALUE ; } public abstract String toSignature ( ) ; public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { FlowList fl = null ; if ( type == Type . Boolean ) { fl = translateToDesynthesized ( classGen , methodGen , ( BooleanType ) type ) ; } else { translateTo ( classGen , methodGen , type ) ; } return fl ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; return null ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getClass ( ) . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , clazz . getClass ( ) . toString ( ) , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , "[" + toString ( ) + "]" ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , "[" + toString ( ) + "]" , toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } public String getClassName ( ) { return ( EMPTYSTRING ) ; } public Instruction ADD ( ) { return null ; } public Instruction SUB ( ) { return null ; } public Instruction MUL ( ) { return null ; } public Instruction DIV ( ) { return null ; } public Instruction REM ( ) { return null ; } public Instruction NEG ( ) { return null ; } public Instruction LOAD ( int slot ) { return null ; } public Instruction STORE ( int slot ) { return null ; } public Instruction POP ( ) { return POP ; } public BranchInstruction GT ( boolean tozero ) { return null ; } public BranchInstruction GE ( boolean tozero ) { return null ; } public BranchInstruction LT ( boolean tozero ) { return null ; } public BranchInstruction LE ( boolean tozero ) { return null ; } public Instruction CMP ( boolean less ) { return null ; } public Instruction DUP ( ) { return DUP ; } } 	0	['35', '1', '10', '113', '56', '587', '104', '20', '34', '0.991349481', '339', '0', '17', '0', '0.202614379', '0', '0', '8.2', '3', '1.1143', '0']
package org . apache . xml . utils ; import java . util . Stack ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . w3c . dom . CDATASection ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; public class DOMBuilder implements ContentHandler , LexicalHandler { public Document m_doc ; protected Node m_currentNode = null ; public DocumentFragment m_docFrag = null ; protected Stack m_elemStack = new Stack ( ) ; public DOMBuilder ( Document doc , Node node ) { m_doc = doc ; m_currentNode = node ; } public DOMBuilder ( Document doc , DocumentFragment docFrag ) { m_doc = doc ; m_docFrag = docFrag ; } public DOMBuilder ( Document doc ) { m_doc = doc ; } public Node getRootNode ( ) { return ( null != m_docFrag ) ? ( Node ) m_docFrag : ( Node ) m_doc ; } public Node getCurrentNode ( ) { return m_currentNode ; } public java . io . Writer getWriter ( ) { return null ; } protected void append ( Node newNode ) throws org . xml . sax . SAXException { Node currentNode = m_currentNode ; if ( null != currentNode ) { currentNode . appendChild ( newNode ) ; } else if ( null != m_docFrag ) { m_docFrag . appendChild ( newNode ) ; } else { boolean ok = true ; short type = newNode . getNodeType ( ) ; if ( type == Node . TEXT_NODE ) { String data = newNode . getNodeValue ( ) ; if ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANT_OUTPUT_TEXT_BEFORE_DOC , null ) ) ; } ok = false ; } else if ( type == Node . ELEMENT_NODE ) { if ( m_doc . getDocumentElement ( ) != null ) { throw new org . xml . sax . SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANT_HAVE_MORE_THAN_ONE_ROOT , null ) ) ; } } if ( ok ) m_doc . appendChild ( newNode ) ; } } public void setDocumentLocator ( Locator locator ) { } public void startDocument ( ) throws org . xml . sax . SAXException { } public void endDocument ( ) throws org . xml . sax . SAXException { } public void startElement ( String ns , String localName , String name , Attributes atts ) throws org . xml . sax . SAXException { Element elem ; if ( ( null == ns ) || ( ns . length ( ) == 0 ) ) elem = m_doc . createElementNS ( null , name ) ; else elem = m_doc . createElementNS ( ns , name ) ; append ( elem ) ; try { int nAtts = atts . getLength ( ) ; if ( 0 != nAtts ) { for ( int i = 0 ; i < nAtts ; i ++ ) { if ( atts . getType ( i ) . equalsIgnoreCase ( "ID" ) ) setIDAttribute ( atts . getValue ( i ) , elem ) ; String attrNS = atts . getURI ( i ) ; if ( "" . equals ( attrNS ) ) attrNS = null ; String attrQName = atts . getQName ( i ) ; if ( attrQName . startsWith ( "xmlns:" ) ) attrNS = "http://www.w3.org/2000/xmlns/" ; elem . setAttributeNS ( attrNS , attrQName , atts . getValue ( i ) ) ; } } m_elemStack . push ( elem ) ; m_currentNode = elem ; } catch ( java . lang . Exception de ) { throw new org . xml . sax . SAXException ( de ) ; } } public void endElement ( String ns , String localName , String name ) throws org . xml . sax . SAXException { m_elemStack . pop ( ) ; m_currentNode = m_elemStack . isEmpty ( ) ? null : ( Node ) m_elemStack . peek ( ) ; } public void setIDAttribute ( String id , Element elem ) { } public void characters ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; if ( m_inCData ) { cdata ( ch , start , length ) ; return ; } String s = new String ( ch , start , length ) ; Node childNode ; childNode = m_currentNode != null ? m_currentNode . getLastChild ( ) : null ; if ( childNode != null && childNode . getNodeType ( ) == Node . TEXT_NODE ) { ( ( Text ) childNode ) . appendData ( s ) ; } else { Text text = m_doc . createTextNode ( s ) ; append ( text ) ; } } public void charactersRaw ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createProcessingInstruction ( "xslt-next-is-raw" , "formatter-to-dom" ) ) ; append ( m_doc . createTextNode ( s ) ) ; } public void startEntity ( String name ) throws org . xml . sax . SAXException { } public void endEntity ( String name ) throws org . xml . sax . SAXException { } public void entityReference ( String name ) throws org . xml . sax . SAXException { append ( m_doc . createEntityReference ( name ) ) ; } public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) ) return ; String s = new String ( ch , start , length ) ; append ( m_doc . createTextNode ( s ) ) ; } private boolean isOutsideDocElem ( ) { return ( null == m_docFrag ) && m_elemStack . size ( ) == 0 && ( null == m_currentNode || m_currentNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ; } public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { append ( m_doc . createProcessingInstruction ( target , data ) ) ; } public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { append ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; } protected boolean m_inCData = false ; public void startCDATA ( ) throws org . xml . sax . SAXException { m_inCData = true ; append ( m_doc . createCDATASection ( "" ) ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { m_inCData = false ; } public void cdata ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { if ( isOutsideDocElem ( ) && org . apache . xml . utils . XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) return ; String s = new String ( ch , start , length ) ; CDATASection section = ( CDATASection ) m_currentNode . getLastChild ( ) ; section . appendData ( s ) ; } public void startDTD ( String name , String publicId , String systemId ) throws org . xml . sax . SAXException { } public void endDTD ( ) throws org . xml . sax . SAXException { } public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { } public void endPrefixMapping ( String prefix ) throws org . xml . sax . SAXException { } public void skippedEntity ( String name ) throws org . xml . sax . SAXException { } } 	0	['30', '1', '0', '4', '68', '207', '2', '2', '28', '0.620689655', '494', '0.6', '0', '0', '0.2', '0', '0', '15.3', '5', '1.0667', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class MatchingIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final int _match ; public MatchingIterator ( int match , DTMAxisIterator source ) { _source = source ; _match = match ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final MatchingIterator clone = ( MatchingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _position = 1 ; while ( ( node = _source . next ( ) ) != END && node != _match ) { _position ++ ; } } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { return _source . next ( ) ; } public int getLast ( ) { if ( _last == - 1 ) { _last = _source . getLast ( ) ; } return _last ; } public int getPosition ( ) { return _position ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['10', '2', '0', '3', '23', '0', '0', '3', '10', '0.5', '116', '1', '1', '0.590909091', '0.35', '1', '8', '10.4', '4', '1.3', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class TestGenerator extends MethodGenerator { private static int CONTEXT_NODE_INDEX = 1 ; private static int CURRENT_NODE_INDEX = 4 ; private static int ITERATOR_INDEX = 6 ; private Instruction _aloadDom ; private final Instruction _iloadCurrent ; private final Instruction _iloadContext ; private final Instruction _istoreCurrent ; private final Instruction _istoreContext ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; public TestGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_NODE_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_NODE_INDEX ) ; _iloadContext = new ILOAD ( CONTEXT_NODE_INDEX ) ; _istoreContext = new ILOAD ( CONTEXT_NODE_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public int getIteratorIndex ( ) { return ITERATOR_INDEX ; } public void setDomIndex ( int domIndex ) { _aloadDom = new ALOAD ( domIndex ) ; } public Instruction loadDOM ( ) { return _aloadDom ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction loadContextNode ( ) { return _iloadContext ; } public Instruction storeContextNode ( ) { return _istoreContext ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_NODE_INDEX ; } else { return super . getLocalIndex ( name ) ; } } } 	0	['13', '5', '0', '12', '20', '54', '3', '9', '12', '0.9', '119', '1', '0', '0.926174497', '0.21875', '2', '5', '7.384615385', '2', '0.9231', '0']
package org . apache . xml . utils ; public class WrongParserException extends RuntimeException { public WrongParserException ( String message ) { super ( message ) ; } } 	0	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . dtm . DTM ; final class AbsolutePathPattern extends LocationPathPattern { private final RelativePathPattern _left ; public AbsolutePathPattern ( RelativePathPattern left ) { _left = left ; if ( left != null ) { left . setParent ( this ) ; } } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _left != null ) _left . setParser ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _left == null ? Type . Root : _left . typeCheck ( stable ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _left != null ? _left . getKernelPattern ( ) : null ; } public void reduceKernelPattern ( ) { _left . reduceKernelPattern ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _left != null ) { if ( _left instanceof StepPattern ) { final LocalVariableGen local = methodGen . addLocalVariable2 ( "apptmp" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; il . append ( DUP ) ; il . append ( new ISTORE ( local . getIndex ( ) ) ) ; _left . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( new ILOAD ( local . getIndex ( ) ) ) ) ; methodGen . removeLocalVariable ( local ) ; } else { _left . translate ( classGen , methodGen ) ; } } final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; final int getType = cpg . addInterfaceMethodref ( DOM_INTF , "getExpandedTypeID" , "(I)I" ) ; InstructionHandle begin = il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; if ( _left instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } il . append ( new INVOKEINTERFACE ( getType , 2 ) ) ; il . append ( new PUSH ( cpg , DTM . DOCUMENT_NODE ) ) ; final BranchHandle skip = il . append ( new IF_ICMPEQ ( null ) ) ; _falseList . add ( il . append ( new GOTO_W ( null ) ) ) ; skip . setTarget ( il . append ( NOP ) ) ; if ( _left != null ) { _left . backPatchTrueList ( begin ) ; if ( _left instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _left ; _falseList . backPatch ( ancestor . getLoopHandle ( ) ) ; } _falseList . append ( _left . _falseList ) ; } } public String toString ( ) { return "absolutePathPattern(" + ( _left != null ? _left . toString ( ) : ")" ) ; } } 	0	['8', '5', '0', '29', '45', '0', '1', '29', '8', '0.142857143', '241', '1', '1', '0.933962264', '0.270833333', '4', '5', '29', '6', '1.875', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import java . io . Writer ; public class SerializerTraceWriter extends Writer { private final java . io . Writer m_writer ; private final SerializerTrace m_tracer ; private int buf_length ; private byte buf [ ] ; private int count ; private void setBufferSize ( int size ) { buf = new byte [ size + 3 ] ; buf_length = size ; count = 0 ; } public SerializerTraceWriter ( Writer out , SerializerTrace tracer ) { m_writer = out ; m_tracer = tracer ; setBufferSize ( 1024 ) ; } private void flushBuffer ( ) throws IOException { if ( count > 0 ) { char [ ] chars = new char [ count ] ; for ( int i = 0 ; i < count ; i ++ ) chars [ i ] = ( char ) buf [ i ] ; if ( m_tracer != null ) m_tracer . fireGenerateEvent ( SerializerTrace . EVENTTYPE_OUTPUT_CHARACTERS , chars , 0 , chars . length ) ; count = 0 ; } } public void flush ( ) throws java . io . IOException { if ( m_writer != null ) m_writer . flush ( ) ; flushBuffer ( ) ; } public void close ( ) throws java . io . IOException { if ( m_writer != null ) m_writer . close ( ) ; flushBuffer ( ) ; } public void write ( final int c ) throws IOException { if ( m_writer != null ) m_writer . write ( c ) ; if ( count >= buf_length ) flushBuffer ( ) ; if ( c < 0x80 ) { buf [ count ++ ] = ( byte ) ( c ) ; } else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } public void write ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( m_writer != null ) m_writer . write ( chars , start , length ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( 2 * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } final int n = length + start ; for ( int i = start ; i < n ; i ++ ) { final char c = chars [ i ] ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } public void write ( final String s ) throws IOException { if ( m_writer != null ) m_writer . write ( s ) ; final int length = s . length ( ) ; int lengthx3 = ( length << 1 ) + length ; if ( lengthx3 >= buf_length ) { flushBuffer ( ) ; setBufferSize ( 2 * lengthx3 ) ; } if ( lengthx3 > buf_length - count ) { flushBuffer ( ) ; } for ( int i = 0 ; i < length ; i ++ ) { final char c = s . charAt ( i ) ; if ( c < 0x80 ) buf [ count ++ ] = ( byte ) ( c ) ; else if ( c < 0x800 ) { buf [ count ++ ] = ( byte ) ( 0xc0 + ( c > > 6 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } else { buf [ count ++ ] = ( byte ) ( 0xe0 + ( c > > 12 ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( ( c > > 6 ) & 0x3f ) ) ; buf [ count ++ ] = ( byte ) ( 0x80 + ( c & 0x3f ) ) ; } } } } 	0	['8', '2', '0', '2', '17', '0', '1', '1', '6', '0.171428571', '514', '1', '1', '0.65', '0.3125', '1', '2', '62.625', '1', '0.875', '0']
package org . apache . xml . serializer ; import java . io . IOException ; import org . w3c . dom . Node ; public interface DOMSerializer { public void serialize ( Node node ) throws IOException ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . templates ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . Source ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . SourceTreeManager ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncDocument extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; XObject arg = ( XObject ) this . getArg0 ( ) . execute ( xctxt ) ; String base = "" ; Expression arg1Expr = this . getArg1 ( ) ; if ( null != arg1Expr ) { XObject arg2 = arg1Expr . execute ( xctxt ) ; if ( XObject . CLASS_NODESET == arg2 . getType ( ) ) { int baseNode = arg2 . iter ( ) . nextNode ( ) ; if ( baseNode == DTM . NULL ) { warn ( xctxt , XSLTErrorResources . WG_EMPTY_SECOND_ARG , null ) ; XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; return nodes ; } else { DTM baseDTM = xctxt . getDTM ( baseNode ) ; base = baseDTM . getDocumentBaseURI ( ) ; } } else { arg2 . iter ( ) ; } } else { assertion ( null != xctxt . getNamespaceContext ( ) , "Namespace context can not be null!" ) ; base = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; } XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM mnl = nodes . mutableNodeset ( ) ; DTMIterator iterator = ( XObject . CLASS_NODESET == arg . getType ( ) ) ? arg . iter ( ) : null ; int pos = DTM . NULL ; while ( ( null == iterator ) || ( DTM . NULL != ( pos = iterator . nextNode ( ) ) ) ) { XMLString ref = ( null != iterator ) ? xctxt . getDTM ( pos ) . getStringValue ( pos ) : arg . xstr ( ) ; if ( null == arg1Expr && DTM . NULL != pos ) { DTM baseDTM = xctxt . getDTM ( pos ) ; base = baseDTM . getDocumentBaseURI ( ) ; } if ( null == ref ) continue ; if ( DTM . NULL == docContext ) { error ( xctxt , XSLTErrorResources . ER_NO_CONTEXT_OWNERDOC , null ) ; } int indexOfColon = ref . indexOf ( ':' ) ; int indexOfSlash = ref . indexOf ( '/' ) ; if ( ( indexOfColon != - 1 ) && ( indexOfSlash != - 1 ) && ( indexOfColon < indexOfSlash ) ) { base = null ; } int newDoc = getDoc ( xctxt , context , ref . toString ( ) , base ) ; if ( DTM . NULL != newDoc ) { if ( ! mnl . contains ( newDoc ) ) { mnl . addElement ( newDoc ) ; } } if ( null == iterator || newDoc == DTM . NULL ) break ; } return nodes ; } int getDoc ( XPathContext xctxt , int context , String uri , String base ) throws javax . xml . transform . TransformerException { SourceTreeManager treeMgr = xctxt . getSourceTreeManager ( ) ; Source source ; int newDoc ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; newDoc = treeMgr . getNode ( source ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } catch ( TransformerException te ) { throw new TransformerException ( te ) ; } if ( DTM . NULL != newDoc ) return newDoc ; if ( uri . length ( ) == 0 ) { uri = xctxt . getNamespaceContext ( ) . getBaseIdentifier ( ) ; try { source = treeMgr . resolveURI ( base , uri , xctxt . getSAXLocator ( ) ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe . getMessage ( ) , ( SourceLocator ) xctxt . getSAXLocator ( ) , ioe ) ; } } String diagnosticsString = null ; try { if ( ( null != uri ) && ( uri . toString ( ) . length ( ) > 0 ) ) { newDoc = treeMgr . getSourceTree ( source , xctxt . getSAXLocator ( ) , xctxt ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_MAKE_URL_FROM , new Object [ ] { ( ( base == null ) ? "" : base ) + uri } ) ; } catch ( Throwable throwable ) { newDoc = DTM . NULL ; while ( throwable instanceof org . apache . xml . utils . WrappedRuntimeException ) { throwable = ( ( org . apache . xml . utils . WrappedRuntimeException ) throwable ) . getException ( ) ; } if ( ( throwable instanceof NullPointerException ) || ( throwable instanceof ClassCastException ) ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ( Exception ) throwable ) ; } StringWriter sw = new StringWriter ( ) ; PrintWriter diagnosticsWriter = new PrintWriter ( sw ) ; if ( throwable instanceof TransformerException ) { TransformerException spe = ( TransformerException ) throwable ; { Throwable e = spe ; while ( null != e ) { if ( null != e . getMessage ( ) ) { diagnosticsWriter . println ( " (" + e . getClass ( ) . getName ( ) + "): " + e . getMessage ( ) ) ; } if ( e instanceof TransformerException ) { TransformerException spe2 = ( TransformerException ) e ; SourceLocator locator = spe2 . getLocator ( ) ; if ( ( null != locator ) && ( null != locator . getSystemId ( ) ) ) diagnosticsWriter . println ( "   ID: " + locator . getSystemId ( ) + " Line #" + locator . getLineNumber ( ) + " Column #" + locator . getColumnNumber ( ) ) ; e = spe2 . getException ( ) ; if ( e instanceof org . apache . xml . utils . WrappedRuntimeException ) e = ( ( org . apache . xml . utils . WrappedRuntimeException ) e ) . getException ( ) ; } else e = null ; } } } else { diagnosticsWriter . println ( " (" + throwable . getClass ( ) . getName ( ) + "): " + throwable . getMessage ( ) ) ; } diagnosticsString = throwable . getMessage ( ) ; } if ( DTM . NULL == newDoc ) { if ( null != diagnosticsString ) { warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { diagnosticsString } ) ; } else warn ( xctxt , XSLTErrorResources . WG_CANNOT_LOAD_REQUESTED_DOC , new Object [ ] { uri == null ? ( ( base == null ) ? "" : base ) + uri : uri . toString ( ) } ) ; } else { } return newDoc ; } public void error ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . error ( spe ) ; else System . out . println ( formattedMsg ) ; } public void warn ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . warning ( spe ) ; else System . out . println ( formattedMsg ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum < 1 ) || ( argNum > 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ONE_OR_TWO , null ) ) ; } public boolean isNodesetExpr ( ) { return true ; } } 	0	['8', '5', '0', '16', '66', '28', '1', '15', '6', '2', '551', '0', '0', '0.888888889', '0.475', '3', '8', '67.875', '1', '0.875', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncRound extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { final XObject obj = m_arg0 . execute ( xctxt ) ; final double val = obj . num ( ) ; if ( val >= - 0.5 && val < 0 ) return new XNumber ( - 0.0 ) ; if ( val == 0.0 ) return new XNumber ( val ) ; return new XNumber ( java . lang . Math . floor ( val + 0.5 ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '43', '0', '0', '0.979591837', '0.75', '1', '6', '20.5', '1', '0.5', '0']
package org . apache . xml . utils ; public interface RawCharacterHandler { public void charactersRaw ( char ch [ ] , int start , int length ) throws javax . xml . transform . TransformerException ; } 	0	['1', '1', '0', '0', '1', '0', '0', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class Instruction extends SyntaxTreeNode { public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } } 	0	['3', '2', '26', '36', '9', '3', '28', '8', '2', '2', '24', '0', '0', '0.964285714', '0.5', '1', '2', '7', '1', '0.6667', '0']
package org . apache . xalan . transformer ; import java . text . CollationKey ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class NodeSorter { XPathContext m_execContext ; Vector m_keys ; public NodeSorter ( XPathContext p ) { m_execContext = p ; } public void sort ( DTMIterator v , Vector keys , XPathContext support ) throws javax . xml . transform . TransformerException { m_keys = keys ; int n = v . getLength ( ) ; Vector nodes = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { NodeCompareElem elem = new NodeCompareElem ( v . item ( i ) ) ; nodes . addElement ( elem ) ; } Vector scratchVector = new Vector ( ) ; mergesort ( nodes , scratchVector , 0 , n - 1 , support ) ; for ( int i = 0 ; i < n ; i ++ ) { v . setItem ( ( ( NodeCompareElem ) nodes . elementAt ( i ) ) . m_node , i ) ; } v . setCurrentPos ( 0 ) ; } int compare ( NodeCompareElem n1 , NodeCompareElem n2 , int kIndex , XPathContext support ) throws TransformerException { int result = 0 ; NodeSortKey k = ( NodeSortKey ) m_keys . elementAt ( kIndex ) ; if ( k . m_treatAsNumbers ) { double n1Num , n2Num ; if ( kIndex == 0 ) { n1Num = ( ( Double ) n1 . m_key1Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key1Value ) . doubleValue ( ) ; } else if ( kIndex == 1 ) { n1Num = ( ( Double ) n1 . m_key2Value ) . doubleValue ( ) ; n2Num = ( ( Double ) n2 . m_key2Value ) . doubleValue ( ) ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1Num = r1 . num ( ) ; n2Num = r2 . num ( ) ; } if ( ( n1Num == n2Num ) && ( ( kIndex + 1 ) < m_keys . size ( ) ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } else { double diff ; if ( Double . isNaN ( n1Num ) ) { if ( Double . isNaN ( n2Num ) ) diff = 0.0 ; else diff = - 1 ; } else if ( Double . isNaN ( n2Num ) ) diff = 1 ; else diff = n1Num - n2Num ; result = ( int ) ( ( diff < 0.0 ) ? ( k . m_descending ? 1 : - 1 ) : ( diff > 0.0 ) ? ( k . m_descending ? - 1 : 1 ) : 0 ) ; } } else { CollationKey n1String , n2String ; if ( kIndex == 0 ) { n1String = ( CollationKey ) n1 . m_key1Value ; n2String = ( CollationKey ) n2 . m_key1Value ; } else if ( kIndex == 1 ) { n1String = ( CollationKey ) n1 . m_key2Value ; n2String = ( CollationKey ) n2 . m_key2Value ; } else { XObject r1 = k . m_selectPat . execute ( m_execContext , n1 . m_node , k . m_namespaceContext ) ; XObject r2 = k . m_selectPat . execute ( m_execContext , n2 . m_node , k . m_namespaceContext ) ; n1String = k . m_col . getCollationKey ( r1 . str ( ) ) ; n2String = k . m_col . getCollationKey ( r2 . str ( ) ) ; } result = n1String . compareTo ( n2String ) ; if ( k . m_caseOrderUpper ) { String tempN1 = n1String . getSourceString ( ) . toLowerCase ( ) ; String tempN2 = n2String . getSourceString ( ) . toLowerCase ( ) ; if ( tempN1 . equals ( tempN2 ) ) { result = result == 0 ? 0 : - result ; } } if ( k . m_descending ) { result = - result ; } } if ( 0 == result ) { if ( ( kIndex + 1 ) < m_keys . size ( ) ) { result = compare ( n1 , n2 , kIndex + 1 , support ) ; } } if ( 0 == result ) { DTM dtm = support . getDTM ( n1 . m_node ) ; result = dtm . isNodeAfter ( n1 . m_node , n2 . m_node ) ? - 1 : 1 ; } return result ; } void mergesort ( Vector a , Vector b , int l , int r , XPathContext support ) throws TransformerException { if ( ( r - l ) > 0 ) { int m = ( r + l ) / 2 ; mergesort ( a , b , l , m , support ) ; mergesort ( a , b , m + 1 , r , support ) ; int i , j , k ; for ( i = m ; i >= l ; i -- ) { if ( i >= b . size ( ) ) b . insertElementAt ( a . elementAt ( i ) , i ) ; else b . setElementAt ( a . elementAt ( i ) , i ) ; } i = l ; for ( j = ( m + 1 ) ; j <= r ; j ++ ) { if ( r + m + 1 - j >= b . size ( ) ) b . insertElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; else b . setElementAt ( a . elementAt ( j ) , r + m + 1 - j ) ; } j = r ; int compVal ; for ( k = l ; k <= r ; k ++ ) { if ( i == j ) compVal = - 1 ; else compVal = compare ( ( NodeCompareElem ) b . elementAt ( i ) , ( NodeCompareElem ) b . elementAt ( j ) , 0 , support ) ; if ( compVal < 0 ) { a . setElementAt ( b . elementAt ( i ) , k ) ; i ++ ; } else if ( compVal > 0 ) { a . setElementAt ( b . elementAt ( j ) , k ) ; j -- ; } } } } class NodeCompareElem { int m_node ; int maxkey = 2 ; Object m_key1Value ; Object m_key2Value ; NodeCompareElem ( int node ) throws javax . xml . transform . TransformerException { m_node = node ; if ( ! m_keys . isEmpty ( ) ) { NodeSortKey k1 = ( NodeSortKey ) m_keys . elementAt ( 0 ) ; XObject r = k1 . m_selectPat . execute ( m_execContext , node , k1 . m_namespaceContext ) ; double d ; if ( k1 . m_treatAsNumbers ) { d = r . num ( ) ; m_key1Value = new Double ( d ) ; } else { m_key1Value = k1 . m_col . getCollationKey ( r . str ( ) ) ; } if ( r . getType ( ) == XObject . CLASS_NODESET ) { DTMIterator ni = ( ( XNodeSet ) r ) . iterRaw ( ) ; int current = ni . getCurrentNode ( ) ; if ( DTM . NULL == current ) current = ni . nextNode ( ) ; } if ( m_keys . size ( ) > 1 ) { NodeSortKey k2 = ( NodeSortKey ) m_keys . elementAt ( 1 ) ; XObject r2 = k2 . m_selectPat . execute ( m_execContext , node , k2 . m_namespaceContext ) ; if ( k2 . m_treatAsNumbers ) { d = r2 . num ( ) ; m_key2Value = new Double ( d ) ; } else { m_key2Value = k2 . m_col . getCollationKey ( r2 . str ( ) ) ; } } } } } } 	0	['4', '1', '0', '9', '28', '2', '2', '8', '2', '0.333333333', '475', '0', '1', '0', '0.583333333', '0', '0', '117.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Comment extends Instruction { public void parseContents ( Parser parser ) { parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; Text rawText = null ; if ( elementCount ( ) == 1 ) { Object content = elementAt ( 0 ) ; if ( content instanceof Text ) { rawText = ( Text ) content ; } } if ( rawText != null ) { il . append ( methodGen . loadHandler ( ) ) ; if ( rawText . canLoadAsArrayOffsetLength ( ) ) { rawText . loadAsArrayOffsetLength ( classGen , methodGen ) ; final int comment = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "comment" , "([CII)V" ) ; il . append ( new INVOKEINTERFACE ( comment , 4 ) ) ; } else { il . append ( new PUSH ( cpg , rawText . getText ( ) ) ) ; final int comment = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "comment" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( comment , 2 ) ) ; } } else { il . append ( methodGen . loadHandler ( ) ) ; il . append ( DUP ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( TRANSLET_CLASS , "stringValueHandler" , STRING_VALUE_HANDLER_SIG ) ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeHandler ( ) ) ; translateContents ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_VALUE_HANDLER , "getValue" , "()" + STRING_SIG ) ) ) ; final int comment = cpg . addInterfaceMethodref ( TRANSLET_OUTPUT_INTERFACE , "comment" , "(" + STRING_SIG + ")V" ) ; il . append ( new INVOKEINTERFACE ( comment , 2 ) ) ; il . append ( methodGen . storeHandler ( ) ) ; } } } 	0	['4', '3', '0', '19', '27', '6', '1', '18', '3', '2', '161', '0', '0', '0.949152542', '0.4', '1', '4', '39.25', '5', '1.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Fallback extends Instruction { private boolean _active = false ; public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _active ) { return ( typeCheckContents ( stable ) ) ; } else { return Type . Void ; } } public void activate ( ) { _active = true ; } public String toString ( ) { return ( "fallback" ) ; } public void parseContents ( Parser parser ) { if ( _active ) parseChildren ( parser ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _active ) translateContents ( classGen , methodGen ) ; } } 	0	['6', '3', '0', '10', '12', '0', '1', '9', '5', '0.2', '49', '1', '0', '0.918032787', '0.333333333', '1', '3', '7', '2', '1.1667', '0']
package org . apache . xalan . templates ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; public class XUnresolvedVariableSimple extends XObject { public XUnresolvedVariableSimple ( ElemVariable obj ) { super ( obj ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { Expression expr = ( ( ElemVariable ) m_obj ) . getSelect ( ) . getExpression ( ) ; XObject xobj = expr . execute ( xctxt ) ; xobj . allowDetachToRelease ( false ) ; return xobj ; } public int getType ( ) { return CLASS_UNRESOLVEDVARIABLE ; } public String getTypeString ( ) { return "XUnresolvedVariableSimple (" + object ( ) . getClass ( ) . getName ( ) + ")" ; } } 	0	['4', '3', '0', '6', '15', '6', '1', '5', '4', '2', '39', '0', '0', '0.959459459', '0.5', '2', '12', '8.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . CompareGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . TestGenerator ; final class PositionCall extends FunctionCall { public PositionCall ( QName fname ) { super ( fname ) ; } public boolean hasPositionCall ( ) { return true ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( methodGen instanceof CompareGenerator ) { il . append ( ( ( CompareGenerator ) methodGen ) . loadCurrentNode ( ) ) ; } else if ( methodGen instanceof TestGenerator ) { il . append ( new ILOAD ( POSITION_INDEX ) ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final int index = cpg . addInterfaceMethodref ( NODE_ITERATOR , "getPosition" , "()I" ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } } } 	0	['3', '4', '0', '13', '12', '3', '1', '12', '3', '2', '56', '0', '0', '0.979591837', '0.5', '2', '4', '17.66666667', '3', '1.3333', '0']
package org . apache . xpath . axes ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ContextNodeList { public Node getCurrentNode ( ) ; public int getCurrentPos ( ) ; public void reset ( ) ; public void setShouldCacheNodes ( boolean b ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int size ( ) ; public boolean isFresh ( ) ; public NodeIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public int getLast ( ) ; public void setLast ( int last ) ; } 	0	['12', '1', '0', '1', '12', '66', '1', '0', '12', '2', '12', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . extensions ; import java . util . Hashtable ; public abstract class ExtensionHandlerJava extends ExtensionHandler { protected String m_className = "" ; private Hashtable m_cachedMethods = new Hashtable ( ) ; protected ExtensionHandlerJava ( String namespaceUri , String scriptLang , String className ) { super ( namespaceUri , scriptLang ) ; m_className = className ; } public Object getFromCache ( Object methodKey , Object objType , Object [ ] methodArgs ) { return m_cachedMethods . get ( methodKey ) ; } public Object putToCache ( Object methodKey , Object objType , Object [ ] methodArgs , Object methodObj ) { return m_cachedMethods . put ( methodKey , methodObj ) ; } } 	0	['3', '2', '2', '3', '7', '0', '2', '1', '2', '0.5', '32', '1', '0', '0.75', '0.666666667', '0', '0', '9', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class DocumentCall extends FunctionCall { private Expression _arg1 = null ; private Expression _arg2 = null ; private Type _arg1Type ; public DocumentCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int ac = argumentCount ( ) ; if ( ( ac < 1 ) || ( ac > 2 ) ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } if ( getStylesheet ( ) == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _arg1 = argument ( 0 ) ; if ( _arg1 == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . DOCUMENT_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } _arg1Type = _arg1 . typeCheck ( stable ) ; if ( ( _arg1Type != Type . NodeSet ) && ( _arg1Type != Type . String ) ) { _arg1 = new CastExpr ( _arg1 , Type . String ) ; } if ( ac == 2 ) { _arg2 = argument ( 1 ) ; if ( _arg2 == null ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . DOCUMENT_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } final Type arg2Type = _arg2 . typeCheck ( stable ) ; if ( arg2Type . identicalTo ( Type . Node ) ) { _arg2 = new CastExpr ( _arg2 , Type . NodeSet ) ; } else if ( arg2Type . identicalTo ( Type . NodeSet ) ) { } else { ErrorMsg msg = new ErrorMsg ( ErrorMsg . DOCUMENT_ARG_ERR , this ) ; throw new TypeCheckError ( msg ) ; } } return _type = Type . NodeSet ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int ac = argumentCount ( ) ; final int domField = cpg . addFieldref ( classGen . getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; String docParamList = null ; if ( ac == 1 ) { docParamList = "(" + OBJECT_SIG + STRING_SIG + TRANSLET_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ; } else { docParamList = "(" + OBJECT_SIG + NODE_ITERATOR_SIG + STRING_SIG + TRANSLET_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ; } final int docIdx = cpg . addMethodref ( LOAD_DOCUMENT_CLASS , "documentF" , docParamList ) ; _arg1 . translate ( classGen , methodGen ) ; if ( _arg1Type == Type . NodeSet ) { _arg1 . startIterator ( classGen , methodGen ) ; } if ( ac == 2 ) { _arg2 . translate ( classGen , methodGen ) ; _arg2 . startIterator ( classGen , methodGen ) ; } il . append ( new PUSH ( cpg , getStylesheet ( ) . getSystemId ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( new INVOKESTATIC ( docIdx ) ) ; } } 	0	['3', '4', '0', '21', '26', '0', '0', '21', '3', '0.166666667', '246', '1', '3', '0.979591837', '0.444444444', '3', '14', '80', '4', '1.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class CurrentCall extends FunctionCall { public CurrentCall ( QName fname ) { super ( fname ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( methodGen . loadCurrentNode ( ) ) ; } } 	0	['2', '4', '0', '7', '6', '1', '0', '7', '2', '2', '13', '0', '0', '0.989690722', '0.625', '2', '4', '5.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class CeilingCall extends FunctionCall { public CeilingCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( 0 ) . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( MATH_CLASS , "ceil" , "(D)D" ) ) ) ; } } 	0	['2', '4', '0', '10', '10', '1', '0', '10', '2', '2', '31', '0', '0', '0.989690722', '0.6', '2', '5', '14.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Vector ; import java . lang . reflect . Modifier ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . IllegalAccessException ; import java . lang . IllegalArgumentException ; import java . lang . InstantiationException ; public final class CallFunction { public static String className ; public static String methodName ; public static int nArgs ; public static Class clazz ; public static String invokeMethod ( String _className , String _methodName , Object [ ] _arguments ) { className = _className ; methodName = _methodName ; int size = _arguments . length - 1 ; Object [ ] arguments = new Object [ size ] ; Object object = _arguments [ 0 ] ; clazz = null ; try { clazz = ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; if ( clazz == null ) { throw new RuntimeException ( "Couldn't load the class" ) ; } } catch ( ClassNotFoundException e ) { throw new RuntimeException ( "Couldn't load the class" ) ; } for ( int i = 0 , j = 1 ; i < size ; i ++ , ++ j ) { arguments [ i ] = _arguments [ j ] ; } nArgs = size ; if ( methodName != null ) { Method method ; if ( ( method = findMethods ( arguments ) ) == null ) { throw new RuntimeException ( "Method not found" ) ; } try { Object obj = method . invoke ( object , arguments ) ; return obj . toString ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( "Error: Method is inaccessible" ) ; } catch ( IllegalArgumentException e ) { throw new RuntimeException ( "Error: Number of actual and formal argument differ " ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( "Error: underlying constructor throws an exception " ) ; } } else { Constructor constructor ; if ( ( constructor = findConstructor ( arguments ) ) == null ) { throw new RuntimeException ( "Constructor not found" ) ; } try { Object obs = constructor . newInstance ( arguments ) ; return obs . toString ( ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( "Error: constructor throws an exception " ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( "Error: constructor is inaccessible" ) ; } catch ( IllegalArgumentException e ) { throw new RuntimeException ( "Error: Number of actual and formal argument differ " ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( "Error: Class that declares the underlying constructor represents an abstract class" ) ; } } } private static Constructor findConstructor ( Object [ ] arguments ) { Vector constructors = null ; final Constructor [ ] c_constructors = clazz . getConstructors ( ) ; for ( int i = 0 ; i < c_constructors . length ; i ++ ) { final int mods = c_constructors [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && c_constructors [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( constructors == null ) { constructors = new Vector ( ) ; } constructors . addElement ( c_constructors [ i ] ) ; } } if ( constructors == null ) { throw new RuntimeException ( "CONSTRUCTOR_NOT_FOUND_ERR" + className + ":" + methodName ) ; } int nConstructors = constructors . size ( ) ; boolean accept = false ; for ( int j , i = 0 ; i < nConstructors ; i ++ ) { final Constructor constructor = ( Constructor ) constructors . elementAt ( i ) ; final Class [ ] paramTypes = constructor . getParameterTypes ( ) ; for ( j = 0 ; j < nArgs ; j ++ ) { Class argumentClass = arguments [ j ] . getClass ( ) ; if ( argumentClass == paramTypes [ j ] ) { accept = true ; } else if ( argumentClass . isAssignableFrom ( paramTypes [ j ] ) ) { accept = true ; } else { accept = false ; break ; } } if ( accept ) return constructor ; } return null ; } private static Method findMethods ( Object [ ] arguments ) { Vector methods = null ; final Method [ ] m_methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < m_methods . length ; i ++ ) { final int mods = m_methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && m_methods [ i ] . getName ( ) . equals ( methodName ) && m_methods [ i ] . getParameterTypes ( ) . length == nArgs ) { if ( methods == null ) { methods = new Vector ( ) ; } methods . addElement ( m_methods [ i ] ) ; } } if ( methods == null ) { throw new RuntimeException ( "METHOD_NOT_FOUND_ERR" + className + ":" + methodName ) ; } int nMethods = methods . size ( ) ; boolean accept = false ; for ( int j , i = 0 ; i < nMethods ; i ++ ) { final Method method = ( Method ) methods . elementAt ( i ) ; final Class [ ] paramTypes = method . getParameterTypes ( ) ; for ( j = 0 ; j < nArgs ; j ++ ) { Class argumentClass = arguments [ j ] . getClass ( ) ; if ( argumentClass == paramTypes [ j ] ) { accept = true ; } else if ( argumentClass . isAssignableFrom ( paramTypes [ j ] ) ) { accept = true ; } else if ( paramTypes [ j ] . isPrimitive ( ) ) { arguments [ j ] = isPrimitive ( paramTypes [ j ] , arguments [ j ] ) ; accept = true ; } else { accept = false ; break ; } } if ( accept ) return method ; } return null ; } public static Object isPrimitive ( Class paramType , Object argument ) { if ( argument . getClass ( ) == Integer . class ) return typeCast ( paramType , ( Integer ) argument ) ; else if ( argument . getClass ( ) == Float . class ) return typeCast ( paramType , ( Float ) argument ) ; else if ( argument . getClass ( ) == Double . class ) return typeCast ( paramType , ( Double ) argument ) ; else if ( argument . getClass ( ) == Long . class ) return typeCast ( paramType , ( Long ) argument ) ; else if ( argument . getClass ( ) == Boolean . class ) return ( Boolean ) argument ; else if ( argument . getClass ( ) == Byte . class ) return ( Byte ) argument ; else return null ; } static Object typeCast ( Class paramType , Double object ) { if ( paramType == Long . TYPE ) return new Long ( object . longValue ( ) ) ; else if ( paramType == Integer . TYPE ) return new Integer ( object . intValue ( ) ) ; else if ( paramType == Float . TYPE ) return new Float ( object . floatValue ( ) ) ; else if ( paramType == Short . TYPE ) return new Short ( object . shortValue ( ) ) ; else if ( paramType == Byte . TYPE ) return new Byte ( object . byteValue ( ) ) ; else return object ; } static Object typeCast ( Class paramType , Long object ) { if ( paramType == Integer . TYPE ) return new Integer ( object . intValue ( ) ) ; else if ( paramType == Float . TYPE ) return new Float ( object . floatValue ( ) ) ; else if ( paramType == Short . TYPE ) return new Short ( object . shortValue ( ) ) ; else if ( paramType == Byte . TYPE ) return new Byte ( object . byteValue ( ) ) ; else return object ; } static Object typeCast ( Class paramType , Integer object ) { if ( paramType == Double . TYPE ) return new Double ( object . doubleValue ( ) ) ; else if ( paramType == Float . TYPE ) return new Float ( object . floatValue ( ) ) ; else if ( paramType == Short . TYPE ) return new Short ( object . shortValue ( ) ) ; else if ( paramType == Byte . TYPE ) return new Byte ( object . byteValue ( ) ) ; else return object ; } static Object typeCast ( Class paramType , Float object ) { if ( paramType == Double . TYPE ) return new Double ( object . doubleValue ( ) ) ; else if ( paramType == Integer . TYPE ) return new Float ( object . intValue ( ) ) ; else if ( paramType == Short . TYPE ) return new Short ( object . shortValue ( ) ) ; else if ( paramType == Byte . TYPE ) return new Byte ( object . byteValue ( ) ) ; else return object ; } } 	0	['9', '1', '0', '1', '58', '30', '0', '1', '3', '0.75', '619', '0', '0', '0', '0.185185185', '0', '0', '67.33333333', '13', '6.3333', '0']
package org . apache . xml . dtm . ref ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xml . dtm . ref ; import java . io . IOException ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . ThreadControllerWrapper ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; public class IncrementalSAXSource_Filter implements IncrementalSAXSource , ContentHandler , DTDHandler , LexicalHandler , ErrorHandler , Runnable { boolean DEBUG = false ; private CoroutineManager fCoroutineManager = null ; private int fControllerCoroutineID = - 1 ; private int fSourceCoroutineID = - 1 ; private ContentHandler clientContentHandler = null ; private LexicalHandler clientLexicalHandler = null ; private DTDHandler clientDTDHandler = null ; private ErrorHandler clientErrorHandler = null ; private int eventcounter ; private int frequency = 5 ; private boolean fNoMoreEvents = false ; private XMLReader fXMLReader = null ; private InputSource fXMLReaderInputSource = null ; public IncrementalSAXSource_Filter ( ) { this . init ( new CoroutineManager ( ) , - 1 , - 1 ) ; } public IncrementalSAXSource_Filter ( CoroutineManager co , int controllerCoroutineID ) { this . init ( co , controllerCoroutineID , - 1 ) ; } static public IncrementalSAXSource createIncrementalSAXSource ( CoroutineManager co , int controllerCoroutineID ) { return new IncrementalSAXSource_Filter ( co , controllerCoroutineID ) ; } public void init ( CoroutineManager co , int controllerCoroutineID , int sourceCoroutineID ) { if ( co == null ) co = new CoroutineManager ( ) ; fCoroutineManager = co ; fControllerCoroutineID = co . co_joinCoroutineSet ( controllerCoroutineID ) ; fSourceCoroutineID = co . co_joinCoroutineSet ( sourceCoroutineID ) ; if ( fControllerCoroutineID == - 1 || fSourceCoroutineID == - 1 ) throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COJOINROUTINESET_FAILED , null ) ) ; fNoMoreEvents = false ; eventcounter = frequency ; } public void setXMLReader ( XMLReader eventsource ) { fXMLReader = eventsource ; eventsource . setContentHandler ( this ) ; eventsource . setDTDHandler ( this ) ; eventsource . setErrorHandler ( this ) ; try { eventsource . setProperty ( "http://xml.org/sax/properties/lexical-handler" , this ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } } public void setContentHandler ( ContentHandler handler ) { clientContentHandler = handler ; } public void setDTDHandler ( DTDHandler handler ) { clientDTDHandler = handler ; } public void setLexicalHandler ( LexicalHandler handler ) { clientLexicalHandler = handler ; } public void setErrHandler ( ErrorHandler handler ) { clientErrorHandler = handler ; } public void setReturnFrequency ( int events ) { if ( events < 1 ) events = 1 ; frequency = eventcounter = events ; } public void characters ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . characters ( ch , start , length ) ; } public void endDocument ( ) throws org . xml . sax . SAXException { if ( clientContentHandler != null ) clientContentHandler . endDocument ( ) ; eventcounter = 0 ; co_yield ( false ) ; } public void endElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . endElement ( namespaceURI , localName , qName ) ; } public void endPrefixMapping ( java . lang . String prefix ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . endPrefixMapping ( prefix ) ; } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . ignorableWhitespace ( ch , start , length ) ; } public void processingInstruction ( java . lang . String target , java . lang . String data ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . processingInstruction ( target , data ) ; } public void setDocumentLocator ( Locator locator ) { if ( -- eventcounter <= 0 ) { eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . setDocumentLocator ( locator ) ; } public void skippedEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . skippedEntity ( name ) ; } public void startDocument ( ) throws org . xml . sax . SAXException { co_entry_pause ( ) ; if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startDocument ( ) ; } public void startElement ( java . lang . String namespaceURI , java . lang . String localName , java . lang . String qName , Attributes atts ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startElement ( namespaceURI , localName , qName , atts ) ; } public void startPrefixMapping ( java . lang . String prefix , java . lang . String uri ) throws org . xml . sax . SAXException { if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } if ( clientContentHandler != null ) clientContentHandler . startPrefixMapping ( prefix , uri ) ; } public void comment ( char [ ] ch , int start , int length ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . comment ( ch , start , length ) ; } public void endCDATA ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endCDATA ( ) ; } public void endDTD ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endDTD ( ) ; } public void endEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . endEntity ( name ) ; } public void startCDATA ( ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startCDATA ( ) ; } public void startDTD ( java . lang . String name , java . lang . String publicId , java . lang . String systemId ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startDTD ( name , publicId , systemId ) ; } public void startEntity ( java . lang . String name ) throws org . xml . sax . SAXException { if ( null != clientLexicalHandler ) clientLexicalHandler . startEntity ( name ) ; } public void notationDecl ( String a , String b , String c ) throws SAXException { if ( null != clientDTDHandler ) clientDTDHandler . notationDecl ( a , b , c ) ; } public void unparsedEntityDecl ( String a , String b , String c , String d ) throws SAXException { if ( null != clientDTDHandler ) clientDTDHandler . unparsedEntityDecl ( a , b , c , d ) ; } public void error ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; } public void fatalError ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; eventcounter = 0 ; co_yield ( false ) ; } public void warning ( SAXParseException exception ) throws SAXException { if ( null != clientErrorHandler ) clientErrorHandler . error ( exception ) ; } public int getSourceCoroutineID ( ) { return fSourceCoroutineID ; } public int getControllerCoroutineID ( ) { return fControllerCoroutineID ; } public CoroutineManager getCoroutineManager ( ) { return fCoroutineManager ; } protected void count_and_yield ( boolean moreExpected ) throws SAXException { if ( ! moreExpected ) eventcounter = 0 ; if ( -- eventcounter <= 0 ) { co_yield ( true ) ; eventcounter = frequency ; } } private void co_entry_pause ( ) throws SAXException { if ( fCoroutineManager == null ) { init ( null , - 1 , - 1 ) ; } try { Object arg = fCoroutineManager . co_entry_pause ( fSourceCoroutineID ) ; if ( arg == Boolean . FALSE ) co_yield ( false ) ; } catch ( NoSuchMethodException e ) { if ( DEBUG ) e . printStackTrace ( ) ; throw new SAXException ( e ) ; } } private void co_yield ( boolean moreRemains ) throws SAXException { if ( fNoMoreEvents ) return ; try { Object arg = Boolean . FALSE ; if ( moreRemains ) { arg = fCoroutineManager . co_resume ( Boolean . TRUE , fSourceCoroutineID , fControllerCoroutineID ) ; } if ( arg == Boolean . FALSE ) { fNoMoreEvents = true ; if ( fXMLReader != null ) throw new StopException ( ) ; fCoroutineManager . co_exit_to ( Boolean . FALSE , fSourceCoroutineID , fControllerCoroutineID ) ; } } catch ( NoSuchMethodException e ) { fNoMoreEvents = true ; fCoroutineManager . co_exit ( fSourceCoroutineID ) ; throw new SAXException ( e ) ; } } public void startParse ( InputSource source ) throws SAXException { if ( fNoMoreEvents ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_INCRSAXSRCFILTER_NOT_RESTARTABLE , null ) ) ; if ( fXMLReader == null ) throw new SAXException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_XMLRDR_NOT_BEFORE_STARTPARSE , null ) ) ; fXMLReaderInputSource = source ; ThreadControllerWrapper . runThread ( this , - 1 ) ; } public void run ( ) { if ( fXMLReader == null ) return ; if ( DEBUG ) System . out . println ( "IncrementalSAXSource_Filter parse thread launched" ) ; Object arg = Boolean . FALSE ; try { fXMLReader . parse ( fXMLReaderInputSource ) ; } catch ( IOException ex ) { arg = ex ; } catch ( StopException ex ) { if ( DEBUG ) System . out . println ( "Active IncrementalSAXSource_Filter normal stop exception" ) ; } catch ( SAXException ex ) { Exception inner = ex . getException ( ) ; if ( inner instanceof StopException ) { if ( DEBUG ) System . out . println ( "Active IncrementalSAXSource_Filter normal stop exception" ) ; } else { if ( DEBUG ) { System . out . println ( "Active IncrementalSAXSource_Filter UNEXPECTED SAX exception: " + inner ) ; inner . printStackTrace ( ) ; } arg = ex ; } } fXMLReader = null ; try { fNoMoreEvents = true ; fCoroutineManager . co_exit_to ( arg , fSourceCoroutineID , fControllerCoroutineID ) ; } catch ( java . lang . NoSuchMethodException e ) { e . printStackTrace ( System . err ) ; fCoroutineManager . co_exit ( fSourceCoroutineID ) ; } } class StopException extends RuntimeException { } public Object deliverMoreNodes ( boolean parsemore ) { if ( fNoMoreEvents ) return Boolean . FALSE ; try { Object result = fCoroutineManager . co_resume ( parsemore ? Boolean . TRUE : Boolean . FALSE , fControllerCoroutineID , fSourceCoroutineID ) ; if ( result == Boolean . FALSE ) fCoroutineManager . co_exit ( fControllerCoroutineID ) ; return result ; } catch ( NoSuchMethodException e ) { return e ; } } } 	0	['42', '1', '0', '10', '90', '335', '6', '5', '39', '0.667917448', '877', '0.923076923', '1', '0', '0.125396825', '0', '0', '19.57142857', '6', '1.2857', '0']
package org . apache . xalan . templates ; public class ElemOtherwise extends ElemTemplateElement { public int getXSLToken ( ) { return Constants . ELEMNAME_OTHERWISE ; } public String getNodeName ( ) { return Constants . ELEMNAME_OTHERWISE_STRING ; } } 	0	['3', '3', '0', '1', '4', '3', '0', '1', '3', '2', '10', '0', '0', '0.98989899', '1', '2', '4', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . KeyDeclaration ; import org . xml . sax . Attributes ; class ProcessorKey extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { KeyDeclaration kd = new KeyDeclaration ( handler . getStylesheet ( ) , handler . nextUid ( ) ) ; kd . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; kd . setLocaterInfo ( handler . getLocator ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , kd ) ; handler . getStylesheet ( ) . setKey ( kd ) ; } void setPropertiesFromAttributes ( StylesheetHandler handler , String rawName , Attributes attributes , org . apache . xalan . templates . ElemTemplateElement target ) throws org . xml . sax . SAXException { XSLTElementDef def = getElemDef ( ) ; Vector processedDefs = new Vector ( ) ; int nAttrs = attributes . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { String attrUri = attributes . getURI ( i ) ; String attrLocalName = attributes . getLocalName ( i ) ; XSLTAttributeDef attrDef = def . getAttributeDef ( attrUri , attrLocalName ) ; if ( null == attrDef ) { handler . error ( attributes . getQName ( i ) + "attribute is not allowed on the " + rawName + " element!" , null ) ; } else { String valueString = attributes . getValue ( i ) ; if ( valueString . indexOf ( org . apache . xpath . compiler . Keywords . FUNC_KEY_STRING + "(" ) >= 0 ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_KEY_CALL , null ) , null ) ; processedDefs . addElement ( attrDef ) ; attrDef . setAttrValue ( handler , attrUri , attrLocalName , attributes . getQName ( i ) , attributes . getValue ( i ) , target ) ; } } XSLTAttributeDef [ ] attrDefs = def . getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int i = 0 ; i < nAttrDefs ; i ++ ) { XSLTAttributeDef attrDef = attrDefs [ i ] ; String defVal = attrDef . getDefault ( ) ; if ( null != defVal ) { if ( ! processedDefs . contains ( attrDef ) ) { attrDef . setDefAttrValue ( handler , target ) ; } } if ( attrDef . getRequired ( ) ) { if ( ! processedDefs . contains ( attrDef ) ) handler . error ( XSLMessages . createMessage ( XSLTErrorResources . ER_REQUIRES_ATTRIB , new Object [ ] { rawName , attrDef . getName ( ) } ) , null ) ; } } } } 	0	['3', '4', '0', '10', '34', '3', '1', '9', '1', '2', '169', '0', '0', '0.990566038', '0.666666667', '1', '1', '55.33333333', '1', '0.6667', '0']
package org . apache . xalan . trace ; public interface TraceListenerEx extends TraceListener { public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . res ; public class XMLErrorResources_en extends XMLErrorResources { } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . res . XPATHErrorResources ; public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable { XObject m_selected ; public XRTreeFragSelectWrapper ( Expression expr ) { super ( expr ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { ( ( Expression ) m_obj ) . fixupVariables ( vars , globalsSize ) ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { m_selected = ( ( Expression ) m_obj ) . execute ( xctxt ) ; m_selected . allowDetachToRelease ( m_allowRelease ) ; if ( m_selected . getType ( ) == CLASS_STRING ) return m_selected ; else return new XString ( m_selected . str ( ) ) ; } public void detach ( ) { if ( m_allowRelease ) { m_selected . detach ( ) ; m_selected = null ; } super . detach ( ) ; } public double num ( ) throws javax . xml . transform . TransformerException { return m_selected . num ( ) ; } public XMLString xstr ( ) { return m_selected . xstr ( ) ; } public String str ( ) { return m_selected . str ( ) ; } public int getType ( ) { return CLASS_STRING ; } public int rtf ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } public DTMIterator asNodeIterator ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER , null ) ) ; } } 	0	['10', '4', '0', '9', '23', '23', '1', '8', '10', '0.555555556', '89', '0', '1', '0.905263158', '0.28', '3', '22', '7.8', '2', '1', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncPosition extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getPositionInContextNodeList ( XPathContext xctxt ) { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) { int prox = iter . getProximityPosition ( xctxt ) ; return prox ; } DTMIterator cnl = xctxt . getContextNodeList ( ) ; if ( null != cnl ) { int n = cnl . getCurrentNode ( ) ; if ( n == DTM . NULL ) { if ( cnl . getCurrentPos ( ) == 0 ) return 0 ; try { cnl = cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } int currentNode = xctxt . getContextNode ( ) ; while ( DTM . NULL != ( n = cnl . nextNode ( ) ) ) { if ( n == currentNode ) break ; } } return cnl . getCurrentPos ( ) ; } return - 1 ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { double pos = ( double ) getPositionInContextNodeList ( xctxt ) ; return new XNumber ( pos ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['5', '3', '0', '9', '17', '8', '1', '8', '5', '0.5', '92', '1', '0', '0.904761905', '0.4', '1', '6', '17.2', '8', '2.4', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; class ProcessorPreserveSpace extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { Stylesheet thisSheet = handler . getStylesheet ( ) ; WhitespaceInfoPaths paths = new WhitespaceInfoPaths ( thisSheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , paths ) ; Vector xpaths = paths . getElements ( ) ; for ( int i = 0 ; i < xpaths . size ( ) ; i ++ ) { WhiteSpaceInfo wsi = new WhiteSpaceInfo ( ( XPath ) xpaths . elementAt ( i ) , false , thisSheet ) ; wsi . setUid ( handler . nextUid ( ) ) ; thisSheet . setPreserveSpaces ( wsi ) ; } paths . clearElements ( ) ; } } 	0	['2', '4', '1', '9', '14', '1', '2', '7', '1', '2', '50', '0', '0', '0.995260664', '0.625', '2', '2', '24', '1', '0.5', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; class IllegalArgumentException extends GetOptsException { public IllegalArgumentException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Plus extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) + right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_right . num ( xctxt ) + m_left . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . runtime . output ; interface OutputBuffer { public String close ( ) ; public OutputBuffer append ( char ch ) ; public OutputBuffer append ( String s ) ; public OutputBuffer append ( char [ ] s , int from , int to ) ; } 	0	['4', '1', '0', '2', '4', '6', '2', '0', '4', '2', '4', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . util ; public final class IntegerArray { private static final int InitialSize = 32 ; private int [ ] _array ; private int _size ; private int _free = 0 ; public IntegerArray ( ) { this ( InitialSize ) ; } public IntegerArray ( int size ) { _array = new int [ _size = size ] ; } public IntegerArray ( int [ ] array ) { this ( array . length ) ; System . arraycopy ( array , 0 , _array , 0 , _free = _size ) ; } public void clear ( ) { _free = 0 ; } public Object clone ( ) { final IntegerArray clone = new IntegerArray ( _free > 0 ? _free : 1 ) ; System . arraycopy ( _array , 0 , clone . _array , 0 , _free ) ; clone . _free = _free ; return clone ; } public int [ ] toIntArray ( ) { final int [ ] result = new int [ cardinality ( ) ] ; System . arraycopy ( _array , 0 , result , 0 , cardinality ( ) ) ; return result ; } public final int at ( int index ) { return _array [ index ] ; } public final void set ( int index , int value ) { _array [ index ] = value ; } public int indexOf ( int n ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( n == _array [ i ] ) return i ; } return - 1 ; } public final void add ( int value ) { if ( _free == _size ) { growArray ( _size * 2 ) ; } _array [ _free ++ ] = value ; } public void addNew ( int value ) { for ( int i = 0 ; i < _free ; i ++ ) { if ( _array [ i ] == value ) return ; } add ( value ) ; } public void reverse ( ) { int left = 0 ; int right = _free - 1 ; while ( left < right ) { int temp = _array [ left ] ; _array [ left ++ ] = _array [ right ] ; _array [ right -- ] = temp ; } } public void merge ( IntegerArray other ) { final int newSize = _free + other . _free ; int [ ] newArray = new int [ newSize ] ; int i = 0 , j = 0 , k ; for ( k = 0 ; i < _free && j < other . _free ; k ++ ) { int x = _array [ i ] ; int y = other . _array [ j ] ; if ( x < y ) { newArray [ k ] = x ; i ++ ; } else if ( x > y ) { newArray [ k ] = y ; j ++ ; } else { newArray [ k ] = x ; i ++ ; j ++ ; } } if ( i >= _free ) { while ( j < other . _free ) { newArray [ k ++ ] = other . _array [ j ++ ] ; } } else { while ( i < _free ) { newArray [ k ++ ] = _array [ i ++ ] ; } } _array = newArray ; _free = _size = newSize ; } public void sort ( ) { quicksort ( _array , 0 , _free - 1 ) ; } private static void quicksort ( int [ ] array , int p , int r ) { if ( p < r ) { final int q = partition ( array , p , r ) ; quicksort ( array , p , q ) ; quicksort ( array , q + 1 , r ) ; } } private static int partition ( int [ ] array , int p , int r ) { final int x = array [ ( p + r ) > > > 1 ] ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x < array [ -- j ] ) ; while ( x > array [ ++ i ] ) ; if ( i < j ) { int temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } else { return j ; } } } private void growArray ( int size ) { final int [ ] newArray = new int [ _size = size ] ; System . arraycopy ( _array , 0 , newArray , 0 , _free ) ; _array = newArray ; } public int popLast ( ) { return _array [ -- _free ] ; } public int last ( ) { return _array [ _free - 1 ] ; } public void setLast ( int n ) { _array [ _free - 1 ] = n ; } public void pop ( ) { _free -- ; } public void pop ( int n ) { _free -= n ; } public final int cardinality ( ) { return _free ; } public void print ( java . io . PrintStream out ) { if ( _free > 0 ) { for ( int i = 0 ; i < _free - 1 ; i ++ ) { out . print ( _array [ i ] ) ; out . print ( ' ' ) ; } out . println ( _array [ _free - 1 ] ) ; } else { out . println ( "IntegerArray: empty" ) ; } } } 	0	['24', '1', '0', '5', '30', '0', '5', '0', '21', '0.543478261', '486', '1', '0', '0', '0.316666667', '0', '0', '19.08333333', '8', '1.7083', '0']
package org . apache . xml . utils . synthetic ; import java . lang . reflect . Modifier ; import org . apache . xml . utils . synthetic . reflection . Constructor ; import org . apache . xml . utils . synthetic . reflection . Field ; import org . apache . xml . utils . synthetic . reflection . Method ; public class Class extends Object implements java . io . Serializable { private static java . util . Hashtable global_classtable = new java . util . Hashtable ( ) ; private java . lang . String name ; private java . lang . Class realclass = null ; private int modifiers ; private boolean isInterface = false ; private Class superclass = null ; private Class declaringclass = null ; private Class [ ] interfaces = new Class [ 0 ] ; private Class [ ] allclasses = new Class [ 0 ] ; private Class [ ] declaredclasses = new Class [ 0 ] ; private Constructor [ ] allconstructors = new Constructor [ 0 ] ; private Constructor [ ] declaredconstructors = new Constructor [ 0 ] ; private Method [ ] allmethods = new Method [ 0 ] ; private Method [ ] declaredmethods = new Method [ 0 ] ; private Field [ ] allfields = new Field [ 0 ] ; private Field [ ] declaredfields = new Field [ 0 ] ; private Class [ ] innerclasses = new Class [ 0 ] ; Class ( java . lang . Class realclass ) { this ( realclass . getName ( ) ) ; try { setRealClass ( realclass ) ; } catch ( SynthesisException e ) { e . printStackTrace ( ) ; } } Class ( String fullname ) { this . name = fullname ; global_classtable . put ( fullname , this ) ; } public static Class forClass ( java . lang . Class cls ) { if ( cls == null ) return null ; Class ret = ( Class ) ( global_classtable . get ( cls . getName ( ) ) ) ; if ( null == ret ) ret = new Class ( cls ) ; return ret ; } public Class forNameInContext ( String classname ) throws ClassNotFoundException { for ( int i = innerclasses . length - 1 ; i >= 0 ; -- i ) { if ( classname . equals ( innerclasses [ i ] . getShortName ( ) ) ) return innerclasses [ i ] ; } return forName ( classname ) ; } public static Class forName ( String className ) throws ClassNotFoundException { if ( className . endsWith ( "]" ) ) { StringBuffer arrayname = new StringBuffer ( ) ; for ( int i = className . indexOf ( '[' ) ; i != - 1 ; i = className . indexOf ( '[' , i + 1 ) ) { arrayname . append ( '[' ) ; } String classname = className . substring ( 0 , className . indexOf ( '[' ) ) ; if ( "byte" . equals ( classname ) ) arrayname . append ( 'B' ) ; else if ( "char" . equals ( classname ) ) arrayname . append ( 'C' ) ; else if ( "double" . equals ( classname ) ) arrayname . append ( 'D' ) ; else if ( "float" . equals ( classname ) ) arrayname . append ( 'F' ) ; else if ( "int" . equals ( classname ) ) arrayname . append ( 'I' ) ; else if ( "long" . equals ( classname ) ) arrayname . append ( 'J' ) ; else if ( "short" . equals ( classname ) ) arrayname . append ( 'S' ) ; else if ( "boolean" . equals ( classname ) ) arrayname . append ( 'Z' ) ; else arrayname . append ( 'L' ) . append ( classname ) . append ( ';' ) ; return forName ( arrayname . toString ( ) ) ; } Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) { if ( "boolean" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Boolean . TYPE ; } else if ( "byte" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Byte . TYPE ; } else if ( "char" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Character . TYPE ; } else if ( "short" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Short . TYPE ; } else if ( "int" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Integer . TYPE ; } else if ( "long" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Long . TYPE ; } else if ( "float" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Float . TYPE ; } else if ( "double" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Double . TYPE ; } else if ( "void" . equals ( className ) ) { ret = new Class ( className ) ; ret . realclass = java . lang . Class . forName ( "java.lang.Object" ) ; } else ret = new Class ( java . lang . Class . forName ( className ) ) ; } return ret ; } public static Class declareClass ( String className ) throws SynthesisException { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null == ret ) ret = new Class ( className ) ; if ( ret . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; return ret ; } public static Class reallyDeclareClass ( String className ) { Class ret = ( Class ) ( global_classtable . get ( className ) ) ; if ( null != ret ) global_classtable . remove ( ret ) ; ret = new Class ( className ) ; return ret ; } public Class [ ] getClasses ( ) { if ( realclass != null && allclasses == null ) { java . lang . Class [ ] realDE = realclass . getClasses ( ) ; allclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { allclasses [ i ] = forClass ( realDE [ i ] ) ; } } return allclasses ; } public ClassLoader getClassLoader ( ) { return ( realclass == null ) ? null : realclass . getClassLoader ( ) ; } public Class getComponentType ( ) { return realclass == null ? null : new Class ( realclass . getComponentType ( ) ) ; } public Constructor getConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException , SynthesisException { if ( realclass == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; java . lang . Class [ ] real = new java . lang . Class [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) { if ( ( real [ i ] = parameterTypes [ i ] . getRealClass ( ) ) == null ) throw new SynthesisException ( SynthesisException . UNREIFIED ) ; } return new Constructor ( realclass . getConstructor ( real ) , this ) ; } public Constructor [ ] getConstructors ( ) throws SecurityException { if ( realclass != null && allconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getConstructors ( ) ; allconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { allconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return allconstructors ; } public Class [ ] getDeclaredClasses ( ) throws SecurityException { if ( realclass != null && declaredclasses == null ) { java . lang . Class [ ] realDE = realclass . getDeclaredClasses ( ) ; declaredclasses = new Class [ realDE . length ] ; for ( int i = 0 ; i < realDE . length ; ++ i ) { declaredclasses [ i ] = forClass ( realDE [ i ] ) ; if ( ! realDE [ i ] . isInterface ( ) ) superclass = declaredclasses [ i ] ; } } return declaredclasses ; } public void addExtends ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ declaredclasses . length + 1 ] ; System . arraycopy ( declaredclasses , 0 , scratch , 0 , declaredclasses . length ) ; scratch [ declaredclasses . length ] = newclass ; declaredclasses = scratch ; } public Constructor getDeclaredConstructor ( Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Constructor declareConstructor ( ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Constructor newctor = new Constructor ( this ) ; Constructor [ ] scratch = new Constructor [ declaredconstructors . length + 1 ] ; System . arraycopy ( declaredconstructors , 0 , scratch , 0 , declaredconstructors . length ) ; scratch [ declaredconstructors . length ] = newctor ; declaredconstructors = scratch ; scratch = new Constructor [ allconstructors . length + 1 ] ; System . arraycopy ( allconstructors , 0 , scratch , 0 , allconstructors . length ) ; scratch [ allconstructors . length ] = newctor ; allconstructors = scratch ; return newctor ; } public Class declareInterface ( Class newifce ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( ! newifce . isInterface ( ) ) throw new SynthesisException ( SynthesisException . SYNTAX , newifce . getName ( ) + " isn't an interface" ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newifce ; interfaces = scratch ; scratch = new Class [ allclasses . length + 1 ] ; System . arraycopy ( allclasses , 0 , scratch , 0 , allclasses . length ) ; scratch [ allclasses . length ] = newifce ; allclasses = scratch ; return newifce ; } public Constructor [ ] getDeclaredConstructors ( ) throws SecurityException { if ( realclass != null && declaredconstructors == null ) { java . lang . reflect . Constructor [ ] realDC = realclass . getDeclaredConstructors ( ) ; declaredconstructors = new Constructor [ realDC . length ] ; for ( int i = 0 ; i < realDC . length ; ++ i ) { declaredconstructors [ i ] = new Constructor ( realDC [ i ] , this ) ; } } return declaredconstructors ; } public Field getDeclaredField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field declareField ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Field newfield = new Field ( name , this ) ; Field [ ] scratch = new Field [ declaredfields . length + 1 ] ; System . arraycopy ( declaredfields , 0 , scratch , 0 , declaredfields . length ) ; scratch [ declaredfields . length ] = newfield ; declaredfields = scratch ; scratch = new Field [ allfields . length + 1 ] ; System . arraycopy ( allfields , 0 , scratch , 0 , allfields . length ) ; scratch [ allfields . length ] = newfield ; allfields = scratch ; return newfield ; } public Field [ ] getDeclaredFields ( ) throws SecurityException { if ( realclass != null && declaredfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getDeclaredFields ( ) ; declaredfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { declaredfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return declaredfields ; } public Method getDeclaredMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method declareMethod ( String name ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Method newMethod = new Method ( name , this ) ; Method [ ] scratch = new Method [ declaredmethods . length + 1 ] ; System . arraycopy ( declaredmethods , 0 , scratch , 0 , declaredmethods . length ) ; scratch [ declaredmethods . length ] = newMethod ; declaredmethods = scratch ; scratch = new Method [ allmethods . length + 1 ] ; System . arraycopy ( allmethods , 0 , scratch , 0 , allmethods . length ) ; scratch [ allmethods . length ] = newMethod ; allmethods = scratch ; return newMethod ; } public Method [ ] getDeclaredMethods ( ) throws SecurityException { if ( realclass != null && declaredmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getDeclaredMethods ( ) ; declaredmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { declaredmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return declaredmethods ; } public Class getDeclaringClass ( ) { if ( realclass != null && declaringclass == null ) { java . lang . Class dc = realclass . getDeclaringClass ( ) ; if ( dc == null ) declaringclass = null ; else declaringclass = forClass ( dc ) ; } return declaringclass ; } private void addInnerClass ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; if ( newclass . getDeclaringClass ( ) != this ) throw new SynthesisException ( SynthesisException . WRONG_OWNER ) ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; } public Class declareInnerClass ( String className ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; String relativeName = getName ( ) + "$" + className ; Class newclass = ( Class ) ( global_classtable . get ( relativeName ) ) ; if ( newclass != null ) throw new SynthesisException ( SynthesisException . SYNTAX , "Inner class " + name + " already exists" ) ; newclass = new Class ( className ) ; newclass . declaringclass = this ; Class [ ] scratch = new Class [ innerclasses . length + 1 ] ; System . arraycopy ( innerclasses , 0 , scratch , 0 , innerclasses . length ) ; scratch [ innerclasses . length ] = newclass ; innerclasses = scratch ; return newclass ; } public Class [ ] getInnerClasses ( ) { return innerclasses ; } public Field getField ( String name ) throws NoSuchFieldException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Field [ ] getFields ( ) throws SecurityException { if ( realclass != null && allfields == null ) { java . lang . reflect . Field [ ] realDF = realclass . getFields ( ) ; allfields = new Field [ realDF . length ] ; for ( int i = 0 ; i < realDF . length ; ++ i ) { allfields [ i ] = new Field ( realDF [ i ] , this ) ; } } return allfields ; } public Class [ ] getInterfaces ( ) { if ( realclass != null && interfaces == null ) { java . lang . Class [ ] realI = realclass . getInterfaces ( ) ; interfaces = new Class [ realI . length ] ; for ( int i = 0 ; i < realI . length ; ++ i ) { interfaces [ i ] = forClass ( realI [ i ] ) ; } } return interfaces ; } public void addImplements ( Class newclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; Class [ ] scratch = new Class [ interfaces . length + 1 ] ; System . arraycopy ( interfaces , 0 , scratch , 0 , interfaces . length ) ; scratch [ interfaces . length ] = newclass ; interfaces = scratch ; } public Method getMethod ( String name , Class parameterTypes [ ] ) throws NoSuchMethodException , SecurityException { throw new java . lang . IllegalStateException ( ) ; } public Method [ ] getMethods ( ) throws SecurityException { if ( realclass != null && allmethods == null ) { java . lang . reflect . Method [ ] realDM = realclass . getMethods ( ) ; allmethods = new Method [ realDM . length ] ; for ( int i = 0 ; i < realDM . length ; ++ i ) { allmethods [ i ] = new Method ( realDM [ i ] , this ) ; } } return allmethods ; } public int getModifiers ( ) { return modifiers ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public java . lang . String getName ( ) { return name ; } public java . lang . String getJavaName ( ) { if ( name . charAt ( 0 ) != '[' ) return name ; int count = name . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( name . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getShortName ( ) { int start = name . lastIndexOf ( "." ) ; if ( start != 0 || name . charAt ( 0 ) == '.' ) ++ start ; if ( declaringclass != null ) { int d = name . lastIndexOf ( '$' , start ) ; if ( d != 0 ) start = d + 1 ; } return name . substring ( start ) ; } public java . lang . String getJavaShortName ( ) { String shortname = getShortName ( ) ; if ( shortname . charAt ( 0 ) != '[' ) return shortname ; int count = shortname . lastIndexOf ( '[' ) ; StringBuffer jname = new StringBuffer ( shortname . substring ( count + 2 ) ) ; jname . setLength ( jname . length ( ) - 1 ) ; while ( count -- >= 0 ) { jname . append ( "[]" ) ; } return jname . toString ( ) ; } public java . lang . String getPackageName ( ) { int start = name . lastIndexOf ( "." ) ; return name . substring ( 0 , start ) ; } public java . lang . Class getRealClass ( ) { return realclass ; } public void setRealClass ( java . lang . Class realclass ) throws SynthesisException { if ( this . realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . realclass = realclass ; this . modifiers = realclass . getModifiers ( ) ; this . isInterface = realclass . isInterface ( ) ; this . declaringclass = null ; this . interfaces = null ; this . declaredconstructors = null ; this . allconstructors = null ; this . declaredmethods = null ; this . allmethods = null ; this . declaredfields = null ; this . allfields = null ; this . declaredclasses = null ; this . allclasses = null ; this . superclass = null ; } public void setSuperClass ( Class superclass ) throws SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = superclass ; } public void setSuperClass ( java . lang . Class superclass ) throws ClassNotFoundException , SynthesisException { if ( realclass != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . superclass = Class . forClass ( superclass ) ; } public java . net . URL getResource ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public java . io . InputStream getResourceAsStream ( String name ) { throw new java . lang . IllegalStateException ( ) ; } public Object [ ] getSigners ( ) { throw new java . lang . IllegalStateException ( ) ; } public Class getSuperclass ( ) { if ( realclass != null && superclass == null ) { superclass = forClass ( realclass . getSuperclass ( ) ) ; } if ( superclass == null ) superclass = forClass ( Object . class ) ; return superclass ; } public boolean isArray ( ) { return realclass != null && realclass . isArray ( ) ; } public boolean isAssignableFrom ( Class cls ) { if ( realclass != null && cls . realclass != null ) return realclass . isAssignableFrom ( cls . realclass ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isAssignableFrom ( java . lang . Class cls ) { if ( realclass != null ) return realclass . isAssignableFrom ( ( java . lang . Class ) cls ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInstance ( Object obj ) { if ( realclass != null ) return realclass . isInstance ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean isInterface ( ) { return ( realclass != null ) ? realclass . isInterface ( ) : isInterface ; } public void isInterface ( boolean isInterface ) throws SynthesisException { if ( realclass == null ) this . isInterface = isInterface ; else if ( realclass . isInterface ( ) != isInterface ) throw new SynthesisException ( SynthesisException . REIFIED ) ; } public boolean isPrimitive ( ) { return realclass != null && realclass . isPrimitive ( ) ; } public Object newInstance ( ) throws InstantiationException , IllegalAccessException { throw new java . lang . IllegalStateException ( ) ; } public String toString ( ) { if ( realclass != null ) return realclass . toString ( ) ; else if ( isInterface ( ) ) return "interface " + name ; else return "class " + name ; } public void toSource ( java . io . OutputStream out , int depth ) { java . io . PrintWriter writer = new java . io . PrintWriter ( out ) ; toSource ( writer , depth ) ; } public void toSource ( java . io . PrintWriter out , int depth ) { String tab = tabset ( depth ) ; if ( realclass != null ) out . println ( tab + "/** Code back-generated from a \"real\" Class; accuracy limited by reflection APIs. */" ) ; else out . println ( tab + "/** Code generated via org.apache.xml.utils.synthetic.Class */" ) ; if ( getDeclaringClass ( ) == null ) out . println ( tab + "package " + getPackageName ( ) + ";" ) ; out . print ( tab + Modifier . toString ( getModifiers ( ) ) ) ; if ( isInterface ( ) ) out . print ( " interface " ) ; else out . print ( " class " ) ; out . println ( getJavaShortName ( ) ) ; if ( superclass != null ) { out . print ( '\n' + tab + " extends " + superclass . getJavaName ( ) ) ; } Class [ ] ext = getInterfaces ( ) ; if ( ext != null & ext . length > 0 ) { out . print ( '\n' + tab + ( isInterface ? " extends " : " implements " ) + ext [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < ext . length ; ++ i ) { out . print ( ", " + ext [ i ] . getJavaName ( ) ) ; } out . print ( "\n" ) ; } out . print ( tab + "{\n" ) ; tab = tabset ( ++ depth ) ; Field [ ] fields = null ; try { fields = getDeclaredFields ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving fields" ) ; } if ( fields != null ) { for ( int i = 0 ; i < fields . length ; ++ i ) { out . println ( tab + fields [ i ] . toSource ( ) ) ; } } Constructor [ ] ctors = null ; try { ctors = getDeclaredConstructors ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving ctors" ) ; } if ( ctors != null ) { for ( int i = 0 ; i < ctors . length ; ++ i ) { out . print ( ctors [ i ] . toSource ( tab ) ) ; } } Method [ ] methods = null ; try { methods = getDeclaredMethods ( ) ; } catch ( SecurityException e ) { out . println ( tab + "//SecurityException retrieving methods" ) ; } if ( methods != null ) { for ( int i = 0 ; i < methods . length ; ++ i ) { out . print ( '\n' ) ; out . print ( methods [ i ] . toSource ( tab ) ) ; } } Class [ ] inners = getInnerClasses ( ) ; if ( inners != null ) { for ( int i = 0 ; i < inners . length ; ++ i ) { out . print ( '\n' ) ; inners [ i ] . toSource ( out , depth ) ; } } tab = tabset ( -- depth ) ; out . print ( tab + "}\n" ) ; out . flush ( ) ; } private String tabset ( int depth ) { StringBuffer t = new StringBuffer ( ) ; while ( depth -- > 0 ) { t . append ( "    " ) ; } return t . toString ( ) ; } static final int [ ] val = { Modifier . ABSTRACT , Modifier . FINAL , Modifier . INTERFACE , Modifier . NATIVE , Modifier . PRIVATE , Modifier . PROTECTED , Modifier . PUBLIC , Modifier . STATIC , Modifier . SYNCHRONIZED , Modifier . TRANSIENT , Modifier . VOLATILE } ; static final String [ ] kwd = { "abstract" , "final" , "interface" , "native" , "private" , "protected" , "public" , "static" , "synchronized" , "transient" , "volatile" } ; static public int modifierFromString ( String t ) { for ( int i = 0 ; i < kwd . length ; ++ i ) { if ( kwd [ i ] . equals ( t ) ) return val [ i ] ; } return 0 ; } static public int modifiersFromString ( String s ) { int mods = 0 ; java . util . StringTokenizer parts = new java . util . StringTokenizer ( s ) ; while ( parts . hasMoreTokens ( ) ) { String t = parts . nextToken ( ) ; mods |= modifierFromString ( t ) ; } return mods ; } } 	0	['64', '1', '0', '7', '136', '444', '6', '4', '59', '0.719298246', '2278', '0.894736842', '12', '0', '0.152380952', '0', '0', '34.296875', '18', '1.8438', '0']
package org . apache . xml . dtm . ref ; import javax . xml . transform . SourceLocator ; public class NodeLocator implements SourceLocator { protected String m_publicId ; protected String m_systemId ; protected int m_lineNumber ; protected int m_columnNumber ; public NodeLocator ( String publicId , String systemId , int lineNumber , int columnNumber ) { this . m_publicId = publicId ; this . m_systemId = systemId ; this . m_lineNumber = lineNumber ; this . m_columnNumber = columnNumber ; } public String getPublicId ( ) { return m_publicId ; } public String getSystemId ( ) { return m_systemId ; } public int getLineNumber ( ) { return m_lineNumber ; } public int getColumnNumber ( ) { return m_columnNumber ; } public String toString ( ) { return "file '" + m_systemId + "', line #" + m_lineNumber + ", column #" + m_columnNumber ; } } 	0	['6', '1', '0', '1', '11', '0', '1', '0', '6', '0.65', '57', '1', '0', '0', '0.444444444', '0', '0', '7.833333333', '1', '0.8333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . runtime . AttributeList ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . utils . XMLString ; import org . apache . xml . serializer . SerializationHandler ; import javax . xml . transform . SourceLocator ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class AdaptiveResultTreeImpl extends SimpleResultTreeImpl { private static int _documentURIIndex = 0 ; private SAXImpl _dom ; private DTMWSFilter _wsfilter ; private int _initSize ; private boolean _buildIdIndex ; private final AttributeList _attributes = new AttributeList ( ) ; private String _openElementName ; public AdaptiveResultTreeImpl ( XSLTCDTMManager dtmManager , int documentID , DTMWSFilter wsfilter , int initSize , boolean buildIdIndex ) { super ( dtmManager , documentID ) ; _wsfilter = wsfilter ; _initSize = initSize ; _buildIdIndex = buildIdIndex ; } public DOM getNestedDOM ( ) { return _dom ; } public int getDocument ( ) { if ( _dom != null ) { return _dom . getDocument ( ) ; } else { return super . getDocument ( ) ; } } public String getStringValue ( ) { if ( _dom != null ) { return _dom . getStringValue ( ) ; } else { return super . getStringValue ( ) ; } } public DTMAxisIterator getIterator ( ) { if ( _dom != null ) { return _dom . getIterator ( ) ; } else { return super . getIterator ( ) ; } } public DTMAxisIterator getChildren ( final int node ) { if ( _dom != null ) { return _dom . getChildren ( node ) ; } else { return super . getChildren ( node ) ; } } public DTMAxisIterator getTypedChildren ( final int type ) { if ( _dom != null ) { return _dom . getTypedChildren ( type ) ; } else { return super . getTypedChildren ( type ) ; } } public DTMAxisIterator getAxisIterator ( final int axis ) { if ( _dom != null ) { return _dom . getAxisIterator ( axis ) ; } else { return super . getAxisIterator ( axis ) ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { if ( _dom != null ) { return _dom . getTypedAxisIterator ( axis , type ) ; } else { return super . getTypedAxisIterator ( axis , type ) ; } } public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) { if ( _dom != null ) { return _dom . getNthDescendant ( node , n , includeself ) ; } else { return super . getNthDescendant ( node , n , includeself ) ; } } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { if ( _dom != null ) { return _dom . getNamespaceAxisIterator ( axis , ns ) ; } else { return super . getNamespaceAxisIterator ( axis , ns ) ; } } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) { if ( _dom != null ) { return _dom . getNodeValueIterator ( iter , returnType , value , op ) ; } else { return super . getNodeValueIterator ( iter , returnType , value , op ) ; } } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { if ( _dom != null ) { return _dom . orderNodes ( source , node ) ; } else { return super . orderNodes ( source , node ) ; } } public String getNodeName ( final int node ) { if ( _dom != null ) { return _dom . getNodeName ( node ) ; } else { return super . getNodeName ( node ) ; } } public String getNodeNameX ( final int node ) { if ( _dom != null ) { return _dom . getNodeNameX ( node ) ; } else { return super . getNodeNameX ( node ) ; } } public String getNamespaceName ( final int node ) { if ( _dom != null ) { return _dom . getNamespaceName ( node ) ; } else { return super . getNamespaceName ( node ) ; } } public int getExpandedTypeID ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getExpandedTypeID ( nodeHandle ) ; } else { return super . getExpandedTypeID ( nodeHandle ) ; } } public int getNamespaceType ( final int node ) { if ( _dom != null ) { return _dom . getNamespaceType ( node ) ; } else { return super . getNamespaceType ( node ) ; } } public int getParent ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getParent ( nodeHandle ) ; } else { return super . getParent ( nodeHandle ) ; } } public int getAttributeNode ( final int gType , final int element ) { if ( _dom != null ) { return _dom . getAttributeNode ( gType , element ) ; } else { return super . getAttributeNode ( gType , element ) ; } } public String getStringValueX ( final int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValueX ( nodeHandle ) ; } else { return super . getStringValueX ( nodeHandle ) ; } } public void copy ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . copy ( node , handler ) ; } else { super . copy ( node , handler ) ; } } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . copy ( nodes , handler ) ; } else { super . copy ( nodes , handler ) ; } } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { return _dom . shallowCopy ( node , handler ) ; } else { return super . shallowCopy ( node , handler ) ; } } public boolean lessThan ( final int node1 , final int node2 ) { if ( _dom != null ) { return _dom . lessThan ( node1 , node2 ) ; } else { return super . lessThan ( node1 , node2 ) ; } } public void characters ( final int node , SerializationHandler handler ) throws TransletException { if ( _dom != null ) { _dom . characters ( node , handler ) ; } else { super . characters ( node , handler ) ; } } public Node makeNode ( int index ) { if ( _dom != null ) { return _dom . makeNode ( index ) ; } else { return super . makeNode ( index ) ; } } public Node makeNode ( DTMAxisIterator iter ) { if ( _dom != null ) { return _dom . makeNode ( iter ) ; } else { return super . makeNode ( iter ) ; } } public NodeList makeNodeList ( int index ) { if ( _dom != null ) { return _dom . makeNodeList ( index ) ; } else { return super . makeNodeList ( index ) ; } } public NodeList makeNodeList ( DTMAxisIterator iter ) { if ( _dom != null ) { return _dom . makeNodeList ( iter ) ; } else { return super . makeNodeList ( iter ) ; } } public String getLanguage ( int node ) { if ( _dom != null ) { return _dom . getLanguage ( node ) ; } else { return super . getLanguage ( node ) ; } } public int getSize ( ) { if ( _dom != null ) { return _dom . getSize ( ) ; } else { return super . getSize ( ) ; } } public String getDocumentURI ( int node ) { if ( _dom != null ) { return _dom . getDocumentURI ( node ) ; } else { return "adaptive_rtf" + _documentURIIndex ++ ; } } public void setFilter ( StripFilter filter ) { if ( _dom != null ) { _dom . setFilter ( filter ) ; } else { super . setFilter ( filter ) ; } } public void setupMapping ( String [ ] names , String [ ] uris , int [ ] types , String [ ] namespaces ) { if ( _dom != null ) { _dom . setupMapping ( names , uris , types , namespaces ) ; } else { super . setupMapping ( names , uris , types , namespaces ) ; } } public boolean isElement ( final int node ) { if ( _dom != null ) { return _dom . isElement ( node ) ; } else { return super . isElement ( node ) ; } } public boolean isAttribute ( final int node ) { if ( _dom != null ) { return _dom . isAttribute ( node ) ; } else { return super . isAttribute ( node ) ; } } public String lookupNamespace ( int node , String prefix ) throws TransletException { if ( _dom != null ) { return _dom . lookupNamespace ( node , prefix ) ; } else { return super . lookupNamespace ( node , prefix ) ; } } public final int getNodeIdent ( final int nodehandle ) { if ( _dom != null ) { return _dom . getNodeIdent ( nodehandle ) ; } else { return super . getNodeIdent ( nodehandle ) ; } } public final int getNodeHandle ( final int nodeId ) { if ( _dom != null ) { return _dom . getNodeHandle ( nodeId ) ; } else { return super . getNodeHandle ( nodeId ) ; } } public DOM getResultTreeFrag ( int initialSize , int rtfType ) { if ( _dom != null ) { return _dom . getResultTreeFrag ( initialSize , rtfType ) ; } else { return super . getResultTreeFrag ( initialSize , rtfType ) ; } } public SerializationHandler getOutputDomBuilder ( ) { return this ; } public int getNSType ( int node ) { if ( _dom != null ) { return _dom . getNSType ( node ) ; } else { return super . getNSType ( node ) ; } } public String getUnparsedEntityURI ( String name ) { if ( _dom != null ) { return _dom . getUnparsedEntityURI ( name ) ; } else { return super . getUnparsedEntityURI ( name ) ; } } public Hashtable getElementsWithIDs ( ) { if ( _dom != null ) { return _dom . getElementsWithIDs ( ) ; } else { return super . getElementsWithIDs ( ) ; } } private void maybeEmitStartElement ( ) throws SAXException { if ( _openElementName != null ) { int index ; if ( ( index = _openElementName . indexOf ( ":" ) ) < 0 ) _dom . startElement ( null , _openElementName , _openElementName , _attributes ) ; else _dom . startElement ( null , _openElementName . substring ( index + 1 ) , _openElementName , _attributes ) ; _openElementName = null ; } } private void prepareNewDOM ( ) throws SAXException { _dom = ( SAXImpl ) _dtmManager . getDTM ( null , true , _wsfilter , true , false , false , _initSize , _buildIdIndex ) ; _dom . startDocument ( ) ; for ( int i = 0 ; i < _size ; i ++ ) { String str = _textArray [ i ] ; _dom . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } _size = 0 ; } public void startDocument ( ) throws SAXException { } public void endDocument ( ) throws SAXException { if ( _dom != null ) { _dom . endDocument ( ) ; } else { super . endDocument ( ) ; } } public void characters ( String str ) throws SAXException { if ( _dom != null ) { characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } else { super . characters ( str ) ; } } public void characters ( char [ ] ch , int offset , int length ) throws SAXException { if ( _dom != null ) { maybeEmitStartElement ( ) ; _dom . characters ( ch , offset , length ) ; } else { super . characters ( ch , offset , length ) ; } } public boolean setEscaping ( boolean escape ) throws SAXException { if ( _dom != null ) { return _dom . setEscaping ( escape ) ; } else { return super . setEscaping ( escape ) ; } } public void startElement ( String elementName ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _openElementName = elementName ; _attributes . clear ( ) ; } public void startElement ( String uri , String localName , String qName ) throws SAXException { startElement ( qName ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { startElement ( qName ) ; } public void endElement ( String elementName ) throws SAXException { maybeEmitStartElement ( ) ; _dom . endElement ( null , null , elementName ) ; } public void endElement ( String uri , String localName , String qName ) throws SAXException { endElement ( qName ) ; } public void addUniqueAttribute ( String qName , String value , int flags ) throws SAXException { addAttribute ( qName , value ) ; } public void addAttribute ( String name , String value ) { if ( _openElementName != null ) { _attributes . add ( name , value ) ; } else { BasisLibrary . runTimeError ( BasisLibrary . STRAY_ATTRIBUTE_ERR , name ) ; } } public void namespaceAfterStartElement ( String prefix , String uri ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } _dom . startPrefixMapping ( prefix , uri ) ; } public void comment ( String comment ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; char [ ] chars = comment . toCharArray ( ) ; _dom . comment ( chars , 0 , chars . length ) ; } public void comment ( char [ ] chars , int offset , int length ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _dom . comment ( chars , offset , length ) ; } public void processingInstruction ( String target , String data ) throws SAXException { if ( _dom == null ) { prepareNewDOM ( ) ; } maybeEmitStartElement ( ) ; _dom . processingInstruction ( target , data ) ; } public void setFeature ( String featureId , boolean state ) { if ( _dom != null ) { _dom . setFeature ( featureId , state ) ; } } public void setProperty ( String property , Object value ) { if ( _dom != null ) { _dom . setProperty ( property , value ) ; } } public DTMAxisTraverser getAxisTraverser ( final int axis ) { if ( _dom != null ) { return _dom . getAxisTraverser ( axis ) ; } else { return super . getAxisTraverser ( axis ) ; } } public boolean hasChildNodes ( int nodeHandle ) { if ( _dom != null ) { return _dom . hasChildNodes ( nodeHandle ) ; } else { return super . hasChildNodes ( nodeHandle ) ; } } public int getFirstChild ( int nodeHandle ) { if ( _dom != null ) { return _dom . getFirstChild ( nodeHandle ) ; } else { return super . getFirstChild ( nodeHandle ) ; } } public int getLastChild ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLastChild ( nodeHandle ) ; } else { return super . getLastChild ( nodeHandle ) ; } } public int getAttributeNode ( int elementHandle , String namespaceURI , String name ) { if ( _dom != null ) { return _dom . getAttributeNode ( elementHandle , namespaceURI , name ) ; } else { return super . getAttributeNode ( elementHandle , namespaceURI , name ) ; } } public int getFirstAttribute ( int nodeHandle ) { if ( _dom != null ) { return _dom . getFirstAttribute ( nodeHandle ) ; } else { return super . getFirstAttribute ( nodeHandle ) ; } } public int getFirstNamespaceNode ( int nodeHandle , boolean inScope ) { if ( _dom != null ) { return _dom . getFirstNamespaceNode ( nodeHandle , inScope ) ; } else { return super . getFirstNamespaceNode ( nodeHandle , inScope ) ; } } public int getNextSibling ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNextSibling ( nodeHandle ) ; } else { return super . getNextSibling ( nodeHandle ) ; } } public int getPreviousSibling ( int nodeHandle ) { if ( _dom != null ) { return _dom . getPreviousSibling ( nodeHandle ) ; } else { return super . getPreviousSibling ( nodeHandle ) ; } } public int getNextAttribute ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNextAttribute ( nodeHandle ) ; } else { return super . getNextAttribute ( nodeHandle ) ; } } public int getNextNamespaceNode ( int baseHandle , int namespaceHandle , boolean inScope ) { if ( _dom != null ) { return _dom . getNextNamespaceNode ( baseHandle , namespaceHandle , inScope ) ; } else { return super . getNextNamespaceNode ( baseHandle , namespaceHandle , inScope ) ; } } public int getOwnerDocument ( int nodeHandle ) { if ( _dom != null ) { return _dom . getOwnerDocument ( nodeHandle ) ; } else { return super . getOwnerDocument ( nodeHandle ) ; } } public int getDocumentRoot ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentRoot ( nodeHandle ) ; } else { return super . getDocumentRoot ( nodeHandle ) ; } } public XMLString getStringValue ( int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValue ( nodeHandle ) ; } else { return super . getStringValue ( nodeHandle ) ; } } public int getStringValueChunkCount ( int nodeHandle ) { if ( _dom != null ) { return _dom . getStringValueChunkCount ( nodeHandle ) ; } else { return super . getStringValueChunkCount ( nodeHandle ) ; } } public char [ ] getStringValueChunk ( int nodeHandle , int chunkIndex , int [ ] startAndLen ) { if ( _dom != null ) { return _dom . getStringValueChunk ( nodeHandle , chunkIndex , startAndLen ) ; } else { return super . getStringValueChunk ( nodeHandle , chunkIndex , startAndLen ) ; } } public int getExpandedTypeID ( String namespace , String localName , int type ) { if ( _dom != null ) { return _dom . getExpandedTypeID ( namespace , localName , type ) ; } else { return super . getExpandedTypeID ( namespace , localName , type ) ; } } public String getLocalNameFromExpandedNameID ( int ExpandedNameID ) { if ( _dom != null ) { return _dom . getLocalNameFromExpandedNameID ( ExpandedNameID ) ; } else { return super . getLocalNameFromExpandedNameID ( ExpandedNameID ) ; } } public String getNamespaceFromExpandedNameID ( int ExpandedNameID ) { if ( _dom != null ) { return _dom . getNamespaceFromExpandedNameID ( ExpandedNameID ) ; } else { return super . getNamespaceFromExpandedNameID ( ExpandedNameID ) ; } } public String getLocalName ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLocalName ( nodeHandle ) ; } else { return super . getLocalName ( nodeHandle ) ; } } public String getPrefix ( int nodeHandle ) { if ( _dom != null ) { return _dom . getPrefix ( nodeHandle ) ; } else { return super . getPrefix ( nodeHandle ) ; } } public String getNamespaceURI ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNamespaceURI ( nodeHandle ) ; } else { return super . getNamespaceURI ( nodeHandle ) ; } } public String getNodeValue ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNodeValue ( nodeHandle ) ; } else { return super . getNodeValue ( nodeHandle ) ; } } public short getNodeType ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNodeType ( nodeHandle ) ; } else { return super . getNodeType ( nodeHandle ) ; } } public short getLevel ( int nodeHandle ) { if ( _dom != null ) { return _dom . getLevel ( nodeHandle ) ; } else { return super . getLevel ( nodeHandle ) ; } } public boolean isSupported ( String feature , String version ) { if ( _dom != null ) { return _dom . isSupported ( feature , version ) ; } else { return super . isSupported ( feature , version ) ; } } public String getDocumentBaseURI ( ) { if ( _dom != null ) { return _dom . getDocumentBaseURI ( ) ; } else { return super . getDocumentBaseURI ( ) ; } } public void setDocumentBaseURI ( String baseURI ) { if ( _dom != null ) { _dom . setDocumentBaseURI ( baseURI ) ; } else { super . setDocumentBaseURI ( baseURI ) ; } } public String getDocumentSystemIdentifier ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentSystemIdentifier ( nodeHandle ) ; } else { return super . getDocumentSystemIdentifier ( nodeHandle ) ; } } public String getDocumentEncoding ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentEncoding ( nodeHandle ) ; } else { return super . getDocumentEncoding ( nodeHandle ) ; } } public String getDocumentStandalone ( int nodeHandle ) { if ( _dom != null ) { return _dom . getDocumentStandalone ( nodeHandle ) ; } else { return super . getDocumentStandalone ( nodeHandle ) ; } } public String getDocumentVersion ( int documentHandle ) { if ( _dom != null ) { return _dom . getDocumentVersion ( documentHandle ) ; } else { return super . getDocumentVersion ( documentHandle ) ; } } public boolean getDocumentAllDeclarationsProcessed ( ) { if ( _dom != null ) { return _dom . getDocumentAllDeclarationsProcessed ( ) ; } else { return super . getDocumentAllDeclarationsProcessed ( ) ; } } public String getDocumentTypeDeclarationSystemIdentifier ( ) { if ( _dom != null ) { return _dom . getDocumentTypeDeclarationSystemIdentifier ( ) ; } else { return super . getDocumentTypeDeclarationSystemIdentifier ( ) ; } } public String getDocumentTypeDeclarationPublicIdentifier ( ) { if ( _dom != null ) { return _dom . getDocumentTypeDeclarationPublicIdentifier ( ) ; } else { return super . getDocumentTypeDeclarationPublicIdentifier ( ) ; } } public int getElementById ( String elementId ) { if ( _dom != null ) { return _dom . getElementById ( elementId ) ; } else { return super . getElementById ( elementId ) ; } } public boolean supportsPreStripping ( ) { if ( _dom != null ) { return _dom . supportsPreStripping ( ) ; } else { return super . supportsPreStripping ( ) ; } } public boolean isNodeAfter ( int firstNodeHandle , int secondNodeHandle ) { if ( _dom != null ) { return _dom . isNodeAfter ( firstNodeHandle , secondNodeHandle ) ; } else { return super . isNodeAfter ( firstNodeHandle , secondNodeHandle ) ; } } public boolean isCharacterElementContentWhitespace ( int nodeHandle ) { if ( _dom != null ) { return _dom . isCharacterElementContentWhitespace ( nodeHandle ) ; } else { return super . isCharacterElementContentWhitespace ( nodeHandle ) ; } } public boolean isDocumentAllDeclarationsProcessed ( int documentHandle ) { if ( _dom != null ) { return _dom . isDocumentAllDeclarationsProcessed ( documentHandle ) ; } else { return super . isDocumentAllDeclarationsProcessed ( documentHandle ) ; } } public boolean isAttributeSpecified ( int attributeHandle ) { if ( _dom != null ) { return _dom . isAttributeSpecified ( attributeHandle ) ; } else { return super . isAttributeSpecified ( attributeHandle ) ; } } public void dispatchCharactersEvents ( int nodeHandle , org . xml . sax . ContentHandler ch , boolean normalize ) throws org . xml . sax . SAXException { if ( _dom != null ) { _dom . dispatchCharactersEvents ( nodeHandle , ch , normalize ) ; } else { super . dispatchCharactersEvents ( nodeHandle , ch , normalize ) ; } } public void dispatchToEvents ( int nodeHandle , org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { if ( _dom != null ) { _dom . dispatchToEvents ( nodeHandle , ch ) ; } else { super . dispatchToEvents ( nodeHandle , ch ) ; } } public org . w3c . dom . Node getNode ( int nodeHandle ) { if ( _dom != null ) { return _dom . getNode ( nodeHandle ) ; } else { return super . getNode ( nodeHandle ) ; } } public boolean needsTwoThreads ( ) { if ( _dom != null ) { return _dom . needsTwoThreads ( ) ; } else { return super . needsTwoThreads ( ) ; } } public org . xml . sax . ContentHandler getContentHandler ( ) { if ( _dom != null ) { return _dom . getContentHandler ( ) ; } else { return super . getContentHandler ( ) ; } } public org . xml . sax . ext . LexicalHandler getLexicalHandler ( ) { if ( _dom != null ) { return _dom . getLexicalHandler ( ) ; } else { return super . getLexicalHandler ( ) ; } } public org . xml . sax . EntityResolver getEntityResolver ( ) { if ( _dom != null ) { return _dom . getEntityResolver ( ) ; } else { return super . getEntityResolver ( ) ; } } public org . xml . sax . DTDHandler getDTDHandler ( ) { if ( _dom != null ) { return _dom . getDTDHandler ( ) ; } else { return super . getDTDHandler ( ) ; } } public org . xml . sax . ErrorHandler getErrorHandler ( ) { if ( _dom != null ) { return _dom . getErrorHandler ( ) ; } else { return super . getErrorHandler ( ) ; } } public org . xml . sax . ext . DeclHandler getDeclHandler ( ) { if ( _dom != null ) { return _dom . getDeclHandler ( ) ; } else { return super . getDeclHandler ( ) ; } } public void appendChild ( int newChild , boolean clone , boolean cloneDepth ) { if ( _dom != null ) { _dom . appendChild ( newChild , clone , cloneDepth ) ; } else { super . appendChild ( newChild , clone , cloneDepth ) ; } } public void appendTextChild ( String str ) { if ( _dom != null ) { _dom . appendTextChild ( str ) ; } else { super . appendTextChild ( str ) ; } } public SourceLocator getSourceLocatorFor ( int node ) { if ( _dom != null ) { return _dom . getSourceLocatorFor ( node ) ; } else { return super . getSourceLocatorFor ( node ) ; } } public void documentRegistration ( ) { if ( _dom != null ) { _dom . documentRegistration ( ) ; } else { super . documentRegistration ( ) ; } } public void documentRelease ( ) { if ( _dom != null ) { _dom . documentRelease ( ) ; } else { super . documentRelease ( ) ; } } } 	0	['122', '3', '0', '16', '346', '0', '2', '15', '119', '0.80755608', '1640', '1', '3', '0.63190184', '0.13553719', '1', '18', '12.3852459', '2', '1.7541', '0']
package org . apache . xml . dtm ; public interface DTMFilter { public static final int SHOW_ALL = 0xFFFFFFFF ; public static final int SHOW_ELEMENT = 0x00000001 ; public static final int SHOW_ATTRIBUTE = 0x00000002 ; public static final int SHOW_TEXT = 0x00000004 ; public static final int SHOW_CDATA_SECTION = 0x00000008 ; public static final int SHOW_ENTITY_REFERENCE = 0x00000010 ; public static final int SHOW_ENTITY = 0x00000020 ; public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040 ; public static final int SHOW_COMMENT = 0x00000080 ; public static final int SHOW_DOCUMENT = 0x00000100 ; public static final int SHOW_DOCUMENT_TYPE = 0x00000200 ; public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400 ; public static final int SHOW_NOTATION = 0x00000800 ; public static final int SHOW_NAMESPACE = 0x00001000 ; public static final int SHOW_BYFUNCTION = 0x00010000 ; public short acceptNode ( int nodeHandle , int whatToShow ) ; public short acceptNode ( int nodeHandle , int whatToShow , int expandedName ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '17', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; public class StringToStringTableVector { private int m_blocksize ; private StringToStringTable m_map [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToStringTableVector ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new StringToStringTable [ m_blocksize ] ; } public StringToStringTableVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new StringToStringTable [ blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final int size ( ) { return m_firstFree ; } public final void addElement ( StringToStringTable value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; StringToStringTable newMap [ ] = new StringToStringTable [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String get ( String key ) { for ( int i = m_firstFree - 1 ; i >= 0 ; -- i ) { String nsuri = m_map [ i ] . get ( key ) ; if ( nsuri != null ) return nsuri ; } return null ; } public final boolean containsKey ( String key ) { for ( int i = m_firstFree - 1 ; i >= 0 ; -- i ) { if ( m_map [ i ] . get ( key ) != null ) return true ; } return false ; } public final void removeLastElem ( ) { if ( m_firstFree > 0 ) { m_map [ m_firstFree ] = null ; m_firstFree -- ; } } public final StringToStringTable elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( StringToStringTable s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( s ) ) return true ; } return false ; } } 	0	['10', '1', '0', '1', '14', '0', '0', '1', '10', '0.472222222', '180', '1', '1', '0', '0.4', '0', '0', '16.6', '3', '1.6', '0']
package org . apache . xalan . transformer ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPath ; class NodeSortKey { XPath m_selectPat ; boolean m_treatAsNumbers ; boolean m_descending ; boolean m_caseOrderUpper ; Collator m_col ; Locale m_locale ; org . apache . xml . utils . PrefixResolver m_namespaceContext ; TransformerImpl m_processor ; NodeSortKey ( TransformerImpl transformer , XPath selectPat , boolean treatAsNumbers , boolean descending , String langValue , boolean caseOrderUpper , org . apache . xml . utils . PrefixResolver namespaceContext ) throws javax . xml . transform . TransformerException { m_processor = transformer ; m_namespaceContext = namespaceContext ; m_selectPat = selectPat ; m_treatAsNumbers = treatAsNumbers ; m_descending = descending ; m_caseOrderUpper = caseOrderUpper ; if ( null != langValue && m_treatAsNumbers == false ) { m_locale = new Locale ( langValue . toLowerCase ( ) , Locale . getDefault ( ) . getCountry ( ) ) ; if ( null == m_locale ) { m_locale = Locale . getDefault ( ) ; } } else { m_locale = Locale . getDefault ( ) ; } m_col = Collator . getInstance ( m_locale ) ; if ( null == m_col ) { m_processor . getMsgMgr ( ) . warn ( null , XSLTErrorResources . WG_CANNOT_FIND_COLLATOR , new Object [ ] { langValue } ) ; m_col = Collator . getInstance ( ) ; } } } 	0	['1', '1', '0', '6', '10', '0', '3', '4', '0', '2', '80', '0', '3', '0', '1', '0', '0', '71', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; final class ParameterRef extends VariableRefBase { QName _name = null ; public ParameterRef ( Param param ) { super ( param ) ; _name = param . _name ; } public String toString ( ) { return "parameter-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = BasisLibrary . mapQNameToJavaName ( _name . toString ( ) ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	0	['3', '4', '0', '19', '32', '0', '1', '18', '3', '0.5', '161', '0', '1', '0.974358974', '0.5', '2', '3', '52.33333333', '8', '3', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Hashtable ; import java . util . Vector ; public final class MultiHashtable extends Hashtable { public Object put ( Object key , Object value ) { Vector vector = ( Vector ) get ( key ) ; if ( vector == null ) super . put ( key , vector = new Vector ( ) ) ; vector . add ( value ) ; return vector ; } public Object maps ( Object from , Object to ) { if ( from == null ) return null ; final Vector vector = ( Vector ) get ( from ) ; if ( vector != null ) { final int n = vector . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object item = vector . elementAt ( i ) ; if ( item . equals ( to ) ) { return item ; } } } return null ; } } 	0	['3', '3', '0', '2', '11', '3', '2', '0', '3', '2', '61', '0', '0', '0.95', '0.833333333', '1', '2', '19.33333333', '5', '2.3333', '0']
package org . apache . xml . serializer ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '5', '44', '64', '3', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . transformer ; public interface TransformSnapshot { } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xml . utils ; import java . io . File ; import javax . xml . transform . TransformerException ; import org . apache . xml . utils . URI . MalformedURIException ; public class SystemIDResolver { public static String getAbsoluteURIFromRelative ( String localPath ) { if ( localPath == null || localPath . length ( ) == 0 ) return "" ; String absolutePath = localPath ; if ( ! isAbsolutePath ( localPath ) ) { try { absolutePath = getAbsolutePathFromRelativePath ( localPath ) ; } catch ( SecurityException se ) { return "file:" + localPath ; } } String urlString ; if ( null != absolutePath ) { if ( absolutePath . startsWith ( File . separator ) ) urlString = "file://" + absolutePath ; else urlString = "file:///" + absolutePath ; } else urlString = "file:" + localPath ; return replaceChars ( urlString ) ; } private static String getAbsolutePathFromRelativePath ( String relativePath ) { return new File ( relativePath ) . getAbsolutePath ( ) ; } public static boolean isAbsoluteURI ( String systemId ) { if ( isWindowsAbsolutePath ( systemId ) ) { return false ; } final int fragmentIndex = systemId . indexOf ( '#' ) ; final int queryIndex = systemId . indexOf ( '?' ) ; final int slashIndex = systemId . indexOf ( '/' ) ; final int colonIndex = systemId . indexOf ( ':' ) ; int index = systemId . length ( ) - 1 ; if ( fragmentIndex > 0 ) index = fragmentIndex ; if ( ( queryIndex > 0 ) && ( queryIndex < index ) ) index = queryIndex ; if ( ( slashIndex > 0 ) && ( slashIndex < index ) ) index = slashIndex ; return ( ( colonIndex > 0 ) && ( colonIndex < index ) ) ; } public static boolean isAbsolutePath ( String systemId ) { if ( systemId == null ) return false ; final File file = new File ( systemId ) ; return file . isAbsolute ( ) ; } private static boolean isWindowsAbsolutePath ( String systemId ) { if ( ! isAbsolutePath ( systemId ) ) return false ; if ( systemId . length ( ) > 2 && systemId . charAt ( 1 ) == ':' && Character . isLetter ( systemId . charAt ( 0 ) ) && ( systemId . charAt ( 2 ) == '\\' || systemId . charAt ( 2 ) == '/' ) ) return true ; else return false ; } private static String replaceChars ( String str ) { StringBuffer buf = new StringBuffer ( str ) ; int length = buf . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char currentChar = buf . charAt ( i ) ; if ( currentChar == ' ' ) { buf . setCharAt ( i , '%' ) ; buf . insert ( i + 1 , "20" ) ; length = length + 2 ; i = i + 2 ; } else if ( currentChar == '\\' ) { buf . setCharAt ( i , '/' ) ; } } return buf . toString ( ) ; } public static String getAbsoluteURI ( String systemId ) { String absoluteURI = systemId ; if ( isAbsoluteURI ( systemId ) ) { if ( systemId . startsWith ( "file:" ) ) { String str = systemId . substring ( 5 ) ; if ( str != null && str . startsWith ( "/" ) ) { if ( str . startsWith ( "///" ) || ! str . startsWith ( "//" ) ) { int secondColonIndex = systemId . indexOf ( ':' , 5 ) ; if ( secondColonIndex > 0 ) { String localPath = systemId . substring ( secondColonIndex - 1 ) ; try { if ( ! isAbsolutePath ( localPath ) ) absoluteURI = systemId . substring ( 0 , secondColonIndex - 1 ) + getAbsolutePathFromRelativePath ( localPath ) ; } catch ( SecurityException se ) { return systemId ; } } } } else { return getAbsoluteURIFromRelative ( systemId . substring ( 5 ) ) ; } return replaceChars ( absoluteURI ) ; } else return systemId ; } else return getAbsoluteURIFromRelative ( systemId ) ; } public static String getAbsoluteURI ( String urlString , String base ) throws TransformerException { if ( base == null ) return getAbsoluteURI ( urlString ) ; String absoluteBase = getAbsoluteURI ( base ) ; URI uri = null ; try { URI baseURI = new URI ( absoluteBase ) ; uri = new URI ( baseURI , urlString ) ; } catch ( MalformedURIException mue ) { throw new TransformerException ( mue ) ; } return replaceChars ( uri . toString ( ) ) ; } } 	0	['9', '1', '0', '22', '34', '36', '20', '2', '6', '2', '341', '0', '0', '0', '0.5', '0', '0', '36.88888889', '9', '4.1111', '0']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FunctionDef1Arg extends FunctionOneArg { protected int getArg0AsNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( null == m_arg0 ) ? xctxt . getCurrentNode ( ) : m_arg0 . asNode ( xctxt ) ; } public boolean Arg0IsNodesetExpr ( ) { return ( null == m_arg0 ) ? true : m_arg0 . isNodesetExpr ( ) ; } protected XMLString getArg0AsString ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return XString . EMPTYSTRING ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; return dtm . getStringValue ( currentNode ) ; } } else return m_arg0 . execute ( xctxt ) . xstr ( ) ; } protected double getArg0AsNumber ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { if ( null == m_arg0 ) { int currentNode = xctxt . getCurrentNode ( ) ; if ( DTM . NULL == currentNode ) return 0 ; else { DTM dtm = xctxt . getDTM ( currentNode ) ; XMLString str = dtm . getStringValue ( currentNode ) ; return str . toDouble ( ) ; } } else return m_arg0 . execute ( xctxt ) . num ( ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum > 1 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_ZERO_OR_ONE , null ) ) ; } public boolean canTraverseOutsideSubtree ( ) { return ( null == m_arg0 ) ? false : super . canTraverseOutsideSubtree ( ) ; } } 	0	['8', '4', '9', '18', '21', '8', '9', '9', '4', '2', '110', '0', '0', '0.872727273', '0.5', '2', '5', '12.75', '2', '1.125', '0']
package org . apache . xalan . templates ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . StringVector ; import org . apache . xml . utils . SystemIDResolver ; public class Stylesheet extends ElemTemplateElement implements java . io . Serializable { public Stylesheet ( Stylesheet parent ) { if ( null != parent ) { m_stylesheetParent = parent ; m_stylesheetRoot = parent . getStylesheetRoot ( ) ; } } public Stylesheet getStylesheet ( ) { return this ; } public boolean isAggregatedType ( ) { return false ; } public boolean isRoot ( ) { return false ; } public static final String STYLESHEET_EXT = ".lxc" ; private void readObject ( ObjectInputStream stream ) throws IOException , TransformerException { try { stream . defaultReadObject ( ) ; } catch ( ClassNotFoundException cnfe ) { throw new TransformerException ( cnfe ) ; } } private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; } private String m_XmlnsXsl ; public void setXmlnsXsl ( String v ) { m_XmlnsXsl = v ; } public String getXmlnsXsl ( ) { return m_XmlnsXsl ; } private StringVector m_ExtensionElementURIs ; public void setExtensionElementPrefixes ( StringVector v ) { m_ExtensionElementURIs = v ; } public String getExtensionElementPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExtensionElementURIs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExtensionElementURIs . elementAt ( i ) ; } public int getExtensionElementPrefixCount ( ) { return ( null != m_ExtensionElementURIs ) ? m_ExtensionElementURIs . size ( ) : 0 ; } public boolean containsExtensionElementURI ( String uri ) { if ( null == m_ExtensionElementURIs ) return false ; return m_ExtensionElementURIs . contains ( uri ) ; } private StringVector m_ExcludeResultPrefixs ; public void setExcludeResultPrefixes ( StringVector v ) { m_ExcludeResultPrefixs = v ; } public String getExcludeResultPrefix ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_ExcludeResultPrefixs ) throw new ArrayIndexOutOfBoundsException ( ) ; return m_ExcludeResultPrefixs . elementAt ( i ) ; } public int getExcludeResultPrefixCount ( ) { return ( null != m_ExcludeResultPrefixs ) ? m_ExcludeResultPrefixs . size ( ) : 0 ; } public boolean containsExcludeResultPrefix ( String prefix , String uri ) { if ( null == m_ExcludeResultPrefixs || uri == null ) return false ; for ( int i = 0 ; i < m_ExcludeResultPrefixs . size ( ) ; i ++ ) { if ( uri . equals ( getNamespaceForPrefix ( m_ExcludeResultPrefixs . elementAt ( i ) ) ) ) return true ; } return false ; } private String m_Id ; public void setId ( String v ) { m_Id = v ; } public String getId ( ) { return m_Id ; } private String m_Version ; private boolean m_isCompatibleMode = false ; public void setVersion ( String v ) { m_Version = v ; m_isCompatibleMode = ( Double . valueOf ( v ) . doubleValue ( ) > Constants . XSLTVERSUPPORTED ) ; } public boolean getCompatibleMode ( ) { return m_isCompatibleMode ; } public String getVersion ( ) { return m_Version ; } private Vector m_imports ; public void setImport ( StylesheetComposed v ) { if ( null == m_imports ) m_imports = new Vector ( ) ; m_imports . addElement ( v ) ; } public StylesheetComposed getImport ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_imports ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( StylesheetComposed ) m_imports . elementAt ( i ) ; } public int getImportCount ( ) { return ( null != m_imports ) ? m_imports . size ( ) : 0 ; } private Vector m_includes ; public void setInclude ( Stylesheet v ) { if ( null == m_includes ) m_includes = new Vector ( ) ; m_includes . addElement ( v ) ; } public Stylesheet getInclude ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_includes ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( Stylesheet ) m_includes . elementAt ( i ) ; } public int getIncludeCount ( ) { return ( null != m_includes ) ? m_includes . size ( ) : 0 ; } Stack m_DecimalFormatDeclarations ; public void setDecimalFormat ( DecimalFormatProperties edf ) { if ( null == m_DecimalFormatDeclarations ) m_DecimalFormatDeclarations = new Stack ( ) ; m_DecimalFormatDeclarations . push ( edf ) ; } public DecimalFormatProperties getDecimalFormat ( QName name ) { if ( null == m_DecimalFormatDeclarations ) return null ; int n = getDecimalFormatCount ( ) ; for ( int i = ( n - 1 ) ; i >= 0 ; i ++ ) { DecimalFormatProperties dfp = getDecimalFormat ( i ) ; if ( dfp . getName ( ) . equals ( name ) ) return dfp ; } return null ; } public DecimalFormatProperties getDecimalFormat ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_DecimalFormatDeclarations ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( DecimalFormatProperties ) m_DecimalFormatDeclarations . elementAt ( i ) ; } public int getDecimalFormatCount ( ) { return ( null != m_DecimalFormatDeclarations ) ? m_DecimalFormatDeclarations . size ( ) : 0 ; } private Vector m_whitespaceStrippingElements ; public void setStripSpaces ( WhiteSpaceInfo wsi ) { if ( null == m_whitespaceStrippingElements ) { m_whitespaceStrippingElements = new Vector ( ) ; } m_whitespaceStrippingElements . addElement ( wsi ) ; } public WhiteSpaceInfo getStripSpace ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_whitespaceStrippingElements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( WhiteSpaceInfo ) m_whitespaceStrippingElements . elementAt ( i ) ; } public int getStripSpaceCount ( ) { return ( null != m_whitespaceStrippingElements ) ? m_whitespaceStrippingElements . size ( ) : 0 ; } private Vector m_whitespacePreservingElements ; public void setPreserveSpaces ( WhiteSpaceInfo wsi ) { if ( null == m_whitespacePreservingElements ) { m_whitespacePreservingElements = new Vector ( ) ; } m_whitespacePreservingElements . addElement ( wsi ) ; } public WhiteSpaceInfo getPreserveSpace ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_whitespacePreservingElements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( WhiteSpaceInfo ) m_whitespacePreservingElements . elementAt ( i ) ; } public int getPreserveSpaceCount ( ) { return ( null != m_whitespacePreservingElements ) ? m_whitespacePreservingElements . size ( ) : 0 ; } private Vector m_output ; public void setOutput ( OutputProperties v ) { if ( null == m_output ) { m_output = new Vector ( ) ; } m_output . addElement ( v ) ; } public OutputProperties getOutput ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_output ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( OutputProperties ) m_output . elementAt ( i ) ; } public int getOutputCount ( ) { return ( null != m_output ) ? m_output . size ( ) : 0 ; } private Vector m_keyDeclarations ; public void setKey ( KeyDeclaration v ) { if ( null == m_keyDeclarations ) m_keyDeclarations = new Vector ( ) ; m_keyDeclarations . addElement ( v ) ; } public KeyDeclaration getKey ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_keyDeclarations ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( KeyDeclaration ) m_keyDeclarations . elementAt ( i ) ; } public int getKeyCount ( ) { return ( null != m_keyDeclarations ) ? m_keyDeclarations . size ( ) : 0 ; } private Vector m_attributeSets ; public void setAttributeSet ( ElemAttributeSet attrSet ) { if ( null == m_attributeSets ) { m_attributeSets = new Vector ( ) ; } m_attributeSets . addElement ( attrSet ) ; } public ElemAttributeSet getAttributeSet ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_attributeSets ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemAttributeSet ) m_attributeSets . elementAt ( i ) ; } public int getAttributeSetCount ( ) { return ( null != m_attributeSets ) ? m_attributeSets . size ( ) : 0 ; } private Vector m_topLevelVariables ; public void setVariable ( ElemVariable v ) { if ( null == m_topLevelVariables ) m_topLevelVariables = new Vector ( ) ; m_topLevelVariables . addElement ( v ) ; } public ElemVariable getVariableOrParam ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = ( ElemVariable ) getVariableOrParam ( i ) ; if ( var . getName ( ) . equals ( qname ) ) return var ; } } return null ; } public ElemVariable getVariable ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = getVariableOrParam ( i ) ; if ( ( var . getXSLToken ( ) == Constants . ELEMNAME_VARIABLE ) && ( var . getName ( ) . equals ( qname ) ) ) return var ; } } return null ; } public ElemVariable getVariableOrParam ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_topLevelVariables ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemVariable ) m_topLevelVariables . elementAt ( i ) ; } public int getVariableOrParamCount ( ) { return ( null != m_topLevelVariables ) ? m_topLevelVariables . size ( ) : 0 ; } public void setParam ( ElemParam v ) { setVariable ( v ) ; } public ElemParam getParam ( QName qname ) { if ( null != m_topLevelVariables ) { int n = getVariableOrParamCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { ElemVariable var = getVariableOrParam ( i ) ; if ( ( var . getXSLToken ( ) == Constants . ELEMNAME_PARAMVARIABLE ) && ( var . getName ( ) . equals ( qname ) ) ) return ( ElemParam ) var ; } } return null ; } private Vector m_templates ; public void setTemplate ( ElemTemplate v ) { if ( null == m_templates ) m_templates = new Vector ( ) ; m_templates . addElement ( v ) ; v . setStylesheet ( this ) ; } public ElemTemplate getTemplate ( int i ) throws TransformerException { if ( null == m_templates ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( ElemTemplate ) m_templates . elementAt ( i ) ; } public int getTemplateCount ( ) { return ( null != m_templates ) ? m_templates . size ( ) : 0 ; } private Vector m_prefix_aliases ; public void setNamespaceAlias ( NamespaceAlias na ) { if ( m_prefix_aliases == null ) m_prefix_aliases = new Vector ( ) ; m_prefix_aliases . addElement ( na ) ; } public NamespaceAlias getNamespaceAlias ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_prefix_aliases ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( NamespaceAlias ) m_prefix_aliases . elementAt ( i ) ; } public int getNamespaceAliasCount ( ) { return ( null != m_prefix_aliases ) ? m_prefix_aliases . size ( ) : 0 ; } private Hashtable m_NonXslTopLevel ; public void setNonXslTopLevel ( QName name , Object obj ) { if ( null == m_NonXslTopLevel ) m_NonXslTopLevel = new Hashtable ( ) ; m_NonXslTopLevel . put ( name , obj ) ; } public Object getNonXslTopLevel ( QName name ) { return ( null != m_NonXslTopLevel ) ? m_NonXslTopLevel . get ( name ) : null ; } private String m_href = null ; private String m_publicId ; private String m_systemId ; public String getHref ( ) { return m_href ; } public void setHref ( String baseIdent ) { m_href = baseIdent ; } public void setLocaterInfo ( SourceLocator locator ) { if ( null != locator ) { m_publicId = locator . getPublicId ( ) ; m_systemId = locator . getSystemId ( ) ; if ( null != m_systemId ) { try { m_href = SystemIDResolver . getAbsoluteURI ( m_systemId , null ) ; } catch ( TransformerException se ) { } } super . setLocaterInfo ( locator ) ; } } private StylesheetRoot m_stylesheetRoot ; public StylesheetRoot getStylesheetRoot ( ) { return m_stylesheetRoot ; } public void setStylesheetRoot ( StylesheetRoot v ) { m_stylesheetRoot = v ; } private Stylesheet m_stylesheetParent ; public Stylesheet getStylesheetParent ( ) { return m_stylesheetParent ; } public void setStylesheetParent ( Stylesheet v ) { m_stylesheetParent = v ; } public StylesheetComposed getStylesheetComposed ( ) { Stylesheet sheet = this ; while ( ! sheet . isAggregatedType ( ) ) { sheet = sheet . getStylesheetParent ( ) ; } return ( StylesheetComposed ) sheet ; } public short getNodeType ( ) { return DTM . DOCUMENT_NODE ; } public int getXSLToken ( ) { return Constants . ELEMNAME_STYLESHEET ; } public String getNodeName ( ) { return Constants . ELEMNAME_STYLESHEET_STRING ; } public void replaceTemplate ( ElemTemplate v , int i ) throws TransformerException { if ( null == m_templates ) throw new ArrayIndexOutOfBoundsException ( ) ; replaceChild ( v , ( ElemTemplateElement ) m_templates . elementAt ( i ) ) ; m_templates . setElementAt ( v , i ) ; v . setStylesheet ( this ) ; } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { int s = getImportCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { getImport ( j ) . callVisitors ( visitor ) ; } s = getIncludeCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { getInclude ( j ) . callVisitors ( visitor ) ; } s = getOutputCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getOutput ( j ) ) ; } s = getAttributeSetCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { ElemAttributeSet attrSet = getAttributeSet ( j ) ; if ( visitor . visitTopLevelInstruction ( attrSet ) ) { attrSet . callChildVisitors ( visitor ) ; } } s = getDecimalFormatCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getDecimalFormat ( j ) ) ; } s = getKeyCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getKey ( j ) ) ; } s = getNamespaceAliasCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getNamespaceAlias ( j ) ) ; } s = getTemplateCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { try { ElemTemplate template = getTemplate ( j ) ; if ( visitor . visitTopLevelInstruction ( template ) ) { template . callChildVisitors ( visitor ) ; } } catch ( TransformerException te ) { throw new org . apache . xml . utils . WrappedRuntimeException ( te ) ; } } s = getVariableOrParamCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { ElemVariable var = getVariableOrParam ( j ) ; if ( visitor . visitTopLevelVariableOrParamDecl ( var ) ) { var . callChildVisitors ( visitor ) ; } } s = getStripSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getStripSpace ( j ) ) ; } s = getPreserveSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { visitor . visitTopLevelInstruction ( getPreserveSpace ( j ) ) ; } if ( null != m_NonXslTopLevel ) { java . util . Enumeration elements = m_NonXslTopLevel . elements ( ) ; while ( elements . hasMoreElements ( ) ) { ElemTemplateElement elem = ( ElemTemplateElement ) elements . nextElement ( ) ; if ( visitor . visitTopLevelInstruction ( elem ) ) { elem . callChildVisitors ( visitor ) ; } } } } protected boolean accept ( XSLTVisitor visitor ) { return visitor . visitStylesheet ( this ) ; } } 	0	['75', '3', '1', '43', '122', '2607', '33', '17', '71', '0.966779279', '1155', '0.916666667', '4', '0.725925926', '0.073043478', '3', '19', '14.08', '16', '1.84', '0']
package org . apache . xalan . templates ; public class XMLNSDecl implements java . io . Serializable { public XMLNSDecl ( String prefix , String uri , boolean isExcluded ) { m_prefix = prefix ; m_uri = uri ; m_isExcluded = isExcluded ; } private String m_prefix ; public String getPrefix ( ) { return m_prefix ; } private String m_uri ; public String getURI ( ) { return m_uri ; } private boolean m_isExcluded ; public boolean getIsExcluded ( ) { return m_isExcluded ; } } 	0	['4', '1', '0', '2', '5', '0', '2', '0', '4', '0.666666667', '28', '1', '0', '0', '0.5', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . xalan . xsltc . dom ; import java . io . FileNotFoundException ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMCache ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . trax . TemplatesImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . dtm . ref . EmptyIterator ; import org . apache . xml . utils . SystemIDResolver ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; public final class LoadDocument { private static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static DTMAxisIterator documentF ( Object arg1 , DTMAxisIterator arg2 , String xslURI , AbstractTranslet translet , DOM dom ) throws TransletException { String baseURI = null ; final int arg2FirstNode = arg2 . next ( ) ; if ( arg2FirstNode == DTMAxisIterator . END ) { return EmptyIterator . getInstance ( ) ; } else { baseURI = dom . getDocumentURI ( arg2FirstNode ) ; if ( ! SystemIDResolver . isAbsoluteURI ( baseURI ) ) baseURI = SystemIDResolver . getAbsoluteURIFromRelative ( baseURI ) ; } try { if ( arg1 instanceof String ) { if ( ( ( String ) arg1 ) . length ( ) == 0 ) { return document ( xslURI , "" , translet , dom ) ; } else { return document ( ( String ) arg1 , baseURI , translet , dom ) ; } } else if ( arg1 instanceof DTMAxisIterator ) { return document ( ( DTMAxisIterator ) arg1 , baseURI , translet , dom ) ; } else { final String err = "document(" + arg1 . toString ( ) + ")" ; throw new IllegalArgumentException ( err ) ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } public static DTMAxisIterator documentF ( Object arg , String xslURI , AbstractTranslet translet , DOM dom ) throws TransletException { try { if ( arg instanceof String ) { String baseURI = xslURI ; if ( ! SystemIDResolver . isAbsoluteURI ( xslURI ) ) baseURI = SystemIDResolver . getAbsoluteURIFromRelative ( xslURI ) ; String href = ( String ) arg ; if ( href . length ( ) == 0 ) { href = "" ; TemplatesImpl templates = ( TemplatesImpl ) translet . getTemplates ( ) ; DOM sdom = null ; if ( templates != null ) { sdom = templates . getStylesheetDOM ( ) ; } if ( sdom != null ) { return document ( sdom , translet , dom ) ; } else { return document ( href , baseURI , translet , dom , true ) ; } } else { return document ( href , baseURI , translet , dom ) ; } } else if ( arg instanceof DTMAxisIterator ) { return document ( ( DTMAxisIterator ) arg , null , translet , dom ) ; } else { final String err = "document(" + arg . toString ( ) + ")" ; throw new IllegalArgumentException ( err ) ; } } catch ( Exception e ) { throw new TransletException ( e ) ; } } private static DTMAxisIterator document ( String uri , String base , AbstractTranslet translet , DOM dom ) throws Exception { return document ( uri , base , translet , dom , false ) ; } private static DTMAxisIterator document ( String uri , String base , AbstractTranslet translet , DOM dom , boolean cacheDOM ) throws Exception { try { final String originalUri = uri ; MultiDOM multiplexer = ( MultiDOM ) dom ; if ( base != null && ! base . equals ( "" ) ) { uri = SystemIDResolver . getAbsoluteURI ( uri , base ) ; } if ( uri == null || uri . equals ( "" ) ) { return ( EmptyIterator . getInstance ( ) ) ; } int mask = multiplexer . getDocumentMask ( uri ) ; if ( mask != - 1 ) { DOM newDom = ( ( DOMAdapter ) multiplexer . getDOMAdapter ( uri ) ) . getDOMImpl ( ) ; if ( newDom instanceof DOMEnhancedForDTM ) { return new SingletonIterator ( ( ( DOMEnhancedForDTM ) newDom ) . getDocument ( ) , true ) ; } } DOMCache cache = translet . getDOMCache ( ) ; DOM newdom ; mask = multiplexer . nextMask ( ) ; if ( cache != null ) { newdom = cache . retrieveDocument ( base , originalUri , translet ) ; if ( newdom == null ) { final Exception e = new FileNotFoundException ( originalUri ) ; throw new TransletException ( e ) ; } } else { XSLTCDTMManager dtmManager = ( XSLTCDTMManager ) multiplexer . getDTMManager ( ) ; DOMEnhancedForDTM enhancedDOM = ( DOMEnhancedForDTM ) dtmManager . getDTM ( new StreamSource ( uri ) , false , null , true , false , translet . hasIdCall ( ) , cacheDOM ) ; newdom = enhancedDOM ; if ( cacheDOM ) { TemplatesImpl templates = ( TemplatesImpl ) translet . getTemplates ( ) ; if ( templates != null ) { templates . setStylesheetDOM ( enhancedDOM ) ; } } translet . prepassDocument ( enhancedDOM ) ; enhancedDOM . setDocumentURI ( uri ) ; } final DOMAdapter domAdapter = translet . makeDOMAdapter ( newdom ) ; multiplexer . addDOMAdapter ( domAdapter ) ; translet . buildKeys ( domAdapter , null , null , newdom . getDocument ( ) ) ; return new SingletonIterator ( newdom . getDocument ( ) , true ) ; } catch ( Exception e ) { throw e ; } } private static DTMAxisIterator document ( DTMAxisIterator arg1 , String baseURI , AbstractTranslet translet , DOM dom ) throws Exception { UnionIterator union = new UnionIterator ( dom ) ; int node = DTM . NULL ; while ( ( node = arg1 . next ( ) ) != DTM . NULL ) { String uri = dom . getStringValueX ( node ) ; if ( baseURI == null ) { baseURI = dom . getDocumentURI ( node ) ; if ( ! SystemIDResolver . isAbsoluteURI ( baseURI ) ) baseURI = SystemIDResolver . getAbsoluteURIFromRelative ( baseURI ) ; } union . addIterator ( document ( uri , baseURI , translet , dom ) ) ; } return ( union ) ; } private static DTMAxisIterator document ( DOM newdom , AbstractTranslet translet , DOM dom ) throws Exception { DTMManager dtmManager = ( ( MultiDOM ) dom ) . getDTMManager ( ) ; if ( dtmManager != null && newdom instanceof DTM ) { ( ( DTM ) newdom ) . migrateTo ( dtmManager ) ; } translet . prepassDocument ( newdom ) ; final DOMAdapter domAdapter = translet . makeDOMAdapter ( newdom ) ; ( ( MultiDOM ) dom ) . addDOMAdapter ( domAdapter ) ; translet . buildKeys ( domAdapter , null , null , newdom . getDocument ( ) ) ; return new SingletonIterator ( newdom . getDocument ( ) , true ) ; } } 	0	['7', '1', '0', '19', '48', '21', '0', '19', '3', '1.166666667', '389', '1', '0', '0', '0.469387755', '0', '0', '54.42857143', '1', '0.8571', '0']
package org . apache . xalan . xsltc . compiler ; abstract class AttributeValue extends Expression { public static final AttributeValue create ( SyntaxTreeNode parent , String text , Parser parser ) { AttributeValue result ; if ( text . indexOf ( '{' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else if ( text . indexOf ( '}' ) != - 1 ) { result = new AttributeValueTemplate ( text , parser , parent ) ; } else { result = new SimpleAttributeValue ( text ) ; result . setParser ( parser ) ; result . setParent ( parent ) ; } return result ; } } 	0	['2', '3', '2', '11', '8', '1', '8', '5', '1', '2', '44', '0', '0', '0.986111111', '0.5', '0', '0', '21', '3', '1.5', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; public final class FilteredStepIterator extends StepIterator { private Filter _filter ; public FilteredStepIterator ( DTMAxisIterator source , DTMAxisIterator iterator , Filter filter ) { super ( source , iterator ) ; _filter = filter ; } public int next ( ) { int node ; while ( ( node = super . next ( ) ) != END ) { if ( _filter . test ( node ) ) { return returnNode ( node ) ; } } return node ; } } 	0	['2', '3', '0', '3', '6', '0', '0', '3', '2', '0', '28', '1', '1', '0.952380952', '0.666666667', '1', '2', '12.5', '3', '1.5', '0']
package org . apache . xalan . transformer ; class XSLInfiniteLoopException { XSLInfiniteLoopException ( ) { super ( ) ; } public String getMessage ( ) { return "Processing Terminated." ; } } 	0	['2', '1', '0', '0', '3', '1', '0', '0', '1', '2', '7', '0', '0', '0', '1', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NamespaceAlias extends TopLevelElement { private String sPrefix ; private String rPrefix ; public void parseContents ( Parser parser ) { sPrefix = getAttribute ( "stylesheet-prefix" ) ; rPrefix = getAttribute ( "result-prefix" ) ; parser . getSymbolTable ( ) . addPrefixAlias ( sPrefix , rPrefix ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['4', '3', '0', '8', '8', '6', '1', '7', '3', '1', '30', '1', '0', '0.952380952', '0.4', '2', '4', '6', '1', '0.75', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ContainsCall extends FunctionCall { private Expression _base = null ; private Expression _token = null ; public ContainsCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public boolean isBoolean ( ) { return true ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) != 2 ) { throw new TypeCheckError ( ErrorMsg . ILLEGAL_ARG_ERR , getName ( ) , this ) ; } _base = argument ( 0 ) ; Type baseType = _base . typeCheck ( stable ) ; if ( baseType != Type . String ) _base = new CastExpr ( _base , Type . String ) ; _token = argument ( 1 ) ; Type tokenType = _token . typeCheck ( stable ) ; if ( tokenType != Type . String ) _token = new CastExpr ( _token , Type . String ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _base . translate ( classGen , methodGen ) ; _token . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "indexOf" , "(" + STRING_SIG + ")I" ) ) ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; } } 	0	['5', '4', '0', '18', '22', '4', '0', '18', '5', '0.25', '126', '1', '2', '0.96', '0.4', '3', '14', '23.8', '1', '0.8', '0']
package org . apache . xalan . xsltc . dom ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . CollatorFactory ; public class CollatorFactoryBase implements CollatorFactory { public static final Locale DEFAULT_LOCALE = Locale . getDefault ( ) ; public static final Collator DEFAULT_COLLATOR = Collator . getInstance ( ) ; public CollatorFactoryBase ( ) { } public Collator getCollator ( String lang , String country ) { return Collator . getInstance ( new Locale ( lang , country ) ) ; } public Collator getCollator ( Locale locale ) { if ( locale == DEFAULT_LOCALE ) return DEFAULT_COLLATOR ; else return Collator . getInstance ( locale ) ; } } 	0	['4', '1', '0', '1', '9', '4', '0', '1', '3', '0.666666667', '29', '0', '0', '0', '0.555555556', '0', '0', '5.75', '2', '0.75', '0']
package org . apache . xml . serializer ; import org . xml . sax . Attributes ; public interface SerializerTrace { public static final int EVENTTYPE_STARTDOCUMENT = 1 ; public static final int EVENTTYPE_ENDDOCUMENT = 2 ; public static final int EVENTTYPE_STARTELEMENT = 3 ; public static final int EVENTTYPE_ENDELEMENT = 4 ; public static final int EVENTTYPE_CHARACTERS = 5 ; public static final int EVENTTYPE_IGNORABLEWHITESPACE = 6 ; public static final int EVENTTYPE_PI = 7 ; public static final int EVENTTYPE_COMMENT = 8 ; public static final int EVENTTYPE_ENTITYREF = 9 ; public static final int EVENTTYPE_CDATA = 10 ; public static final int EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS = 11 ; public static final int EVENTTYPE_OUTPUT_CHARACTERS = 12 ; public boolean hasTraceListeners ( ) ; public void fireGenerateEvent ( int eventType ) ; public void fireGenerateEvent ( int eventType , String name , Attributes atts ) ; public void fireGenerateEvent ( int eventType , char ch [ ] , int start , int length ) ; public void fireGenerateEvent ( int eventType , String name , String data ) ; public void fireGenerateEvent ( int eventType , String data ) ; } 	0	['6', '1', '0', '12', '6', '15', '12', '0', '6', '1.2', '18', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . xalan . templates . Constants ; import org . apache . xml . utils . QName ; public class XSLTElementDef { XSLTElementDef ( ) { } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || namespace . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required ) { this . m_has_required = has_required ; build ( namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; if ( ( null != namespace ) && ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) || namespace . equals ( Constants . S_BUILTIN_OLD_EXTENSIONS_URL ) ) ) { schema . addAvailableElement ( new QName ( namespace , name ) ) ; if ( null != nameAlias ) schema . addAvailableElement ( new QName ( namespace , nameAlias ) ) ; } } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required ) ; this . m_required = required ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_required , boolean required , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , has_required , required ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , boolean has_order , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject , order , multiAllowed ) ; this . m_isOrdered = has_order ; } XSLTElementDef ( XSLTSchema schema , String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject , int order , boolean multiAllowed ) { this ( schema , namespace , name , nameAlias , elements , attributes , contentHandler , classObject ) ; this . m_order = order ; this . m_multiAllowed = multiAllowed ; } XSLTElementDef ( Class classObject , XSLTElementProcessor contentHandler , int type ) { this . m_classObject = classObject ; this . m_type = type ; setElementProcessor ( contentHandler ) ; } void build ( String namespace , String name , String nameAlias , XSLTElementDef [ ] elements , XSLTAttributeDef [ ] attributes , XSLTElementProcessor contentHandler , Class classObject ) { this . m_namespace = namespace ; this . m_name = name ; this . m_nameAlias = nameAlias ; this . m_elements = elements ; this . m_attributes = attributes ; setElementProcessor ( contentHandler ) ; this . m_classObject = classObject ; if ( hasRequired ( ) && m_elements != null ) { int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def != null && def . getRequired ( ) ) { if ( m_requiredFound == null ) m_requiredFound = new Hashtable ( ) ; m_requiredFound . put ( def . getName ( ) , "xsl:" + def . getName ( ) ) ; } } } } private static boolean equalsMayBeNull ( Object obj1 , Object obj2 ) { return ( obj2 == obj1 ) || ( ( null != obj1 ) && ( null != obj2 ) && obj2 . equals ( obj1 ) ) ; } private static boolean equalsMayBeNullOrZeroLen ( String s1 , String s2 ) { int len1 = ( s1 == null ) ? 0 : s1 . length ( ) ; int len2 = ( s2 == null ) ? 0 : s2 . length ( ) ; return ( len1 != len2 ) ? false : ( len1 == 0 ) ? true : s1 . equals ( s2 ) ; } static final int T_ELEMENT = 1 , T_PCDATA = 2 , T_ANY = 3 ; private int m_type = T_ELEMENT ; int getType ( ) { return m_type ; } void setType ( int t ) { m_type = t ; } private String m_namespace ; String getNamespace ( ) { return m_namespace ; } private String m_name ; String getName ( ) { return m_name ; } private String m_nameAlias ; String getNameAlias ( ) { return m_nameAlias ; } private XSLTElementDef [ ] m_elements ; XSLTElementDef [ ] getElements ( ) { return m_elements ; } void setElements ( XSLTElementDef [ ] defs ) { m_elements = defs ; } private boolean QNameEquals ( String uri , String localName ) { return ( equalsMayBeNullOrZeroLen ( m_namespace , uri ) && ( equalsMayBeNullOrZeroLen ( m_name , localName ) || equalsMayBeNullOrZeroLen ( m_nameAlias , localName ) ) ) ; } XSLTElementProcessor getProcessorFor ( String uri , String localName ) { XSLTElementProcessor elemDef = null ; if ( null == m_elements ) return null ; int n = m_elements . length ; int order = - 1 ; boolean multiAllowed = true ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "*" ) ) { if ( ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { elemDef = def . m_elementProcessor ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; } } else if ( def . QNameEquals ( uri , localName ) ) { if ( def . getRequired ( ) ) this . setRequiredFound ( def . getName ( ) , true ) ; order = def . getOrder ( ) ; multiAllowed = def . getMultiAllowed ( ) ; elemDef = def . m_elementProcessor ; break ; } } if ( elemDef != null && this . isOrdered ( ) ) { int lastOrder = getLastOrder ( ) ; if ( order > lastOrder ) setLastOrder ( order ) ; else if ( order == lastOrder && ! multiAllowed ) { return null ; } else if ( order < lastOrder && order > 0 ) { return null ; } } return elemDef ; } XSLTElementProcessor getProcessorForUnknown ( String uri , String localName ) { if ( null == m_elements ) return null ; int n = m_elements . length ; for ( int i = 0 ; i < n ; i ++ ) { XSLTElementDef def = m_elements [ i ] ; if ( def . m_name . equals ( "unknown" ) && uri . length ( ) > 0 ) { return def . m_elementProcessor ; } } return null ; } private XSLTAttributeDef [ ] m_attributes ; XSLTAttributeDef [ ] getAttributes ( ) { return m_attributes ; } XSLTAttributeDef getAttributeDef ( String uri , String localName ) { XSLTAttributeDef defaultDef = null ; XSLTAttributeDef [ ] attrDefs = getAttributes ( ) ; int nAttrDefs = attrDefs . length ; for ( int k = 0 ; k < nAttrDefs ; k ++ ) { XSLTAttributeDef attrDef = attrDefs [ k ] ; String uriDef = attrDef . getNamespace ( ) ; String nameDef = attrDef . getName ( ) ; if ( nameDef . equals ( "*" ) && ( equalsMayBeNullOrZeroLen ( uri , uriDef ) || ( uriDef != null && uriDef . equals ( "*" ) && uri != null && uri . length ( ) > 0 ) ) ) { return attrDef ; } else if ( nameDef . equals ( "*" ) && ( uriDef == null ) ) { defaultDef = attrDef ; } else if ( equalsMayBeNullOrZeroLen ( uri , uriDef ) && localName . equals ( nameDef ) ) { return attrDef ; } } if ( null == defaultDef ) { if ( uri . length ( ) > 0 && ! equalsMayBeNullOrZeroLen ( uri , Constants . S_XSLNAMESPACEURL ) ) { return XSLTAttributeDef . m_foreignAttr ; } } return defaultDef ; } private XSLTElementProcessor m_elementProcessor ; XSLTElementProcessor getElementProcessor ( ) { return m_elementProcessor ; } void setElementProcessor ( XSLTElementProcessor handler ) { if ( handler != null ) { m_elementProcessor = handler ; m_elementProcessor . setElemDef ( this ) ; } } private Class m_classObject ; Class getClassObject ( ) { return m_classObject ; } private boolean m_has_required = false ; boolean hasRequired ( ) { return m_has_required ; } private boolean m_required = false ; boolean getRequired ( ) { return m_required ; } Hashtable m_requiredFound ; void setRequiredFound ( String elem , boolean found ) { if ( m_requiredFound . get ( elem ) != null ) m_requiredFound . remove ( elem ) ; } boolean getRequiredFound ( ) { if ( m_requiredFound == null ) return true ; return m_requiredFound . isEmpty ( ) ; } String getRequiredElem ( ) { if ( m_requiredFound == null ) return null ; Enumeration elems = m_requiredFound . elements ( ) ; String s = "" ; boolean first = true ; while ( elems . hasMoreElements ( ) ) { if ( first ) first = false ; else s = s + ", " ; s = s + ( String ) elems . nextElement ( ) ; } return s ; } boolean m_isOrdered = false ; boolean isOrdered ( ) { return m_isOrdered ; } private int m_order = - 1 ; int getOrder ( ) { return m_order ; } private int m_lastOrder = - 1 ; int getLastOrder ( ) { return m_lastOrder ; } void setLastOrder ( int order ) { m_lastOrder = order ; } private boolean m_multiAllowed = true ; boolean getMultiAllowed ( ) { return m_multiAllowed ; } } 	0	['37', '1', '1', '8', '57', '440', '6', '4', '0', '0.793209877', '812', '0.722222222', '3', '0', '0.289189189', '0', '0', '20.45945946', '15', '2.2162', '0']
package org . apache . xalan . xsltc . compiler ; final class ArgumentList { private final Expression _arg ; private final ArgumentList _rest ; public ArgumentList ( Expression arg , ArgumentList rest ) { _arg = arg ; _rest = rest ; } public String toString ( ) { return _rest == null ? _arg . toString ( ) : _arg . toString ( ) + ", " + _rest . toString ( ) ; } } 	0	['2', '1', '0', '1', '7', '0', '0', '1', '2', '0', '35', '1', '2', '0', '0.666666667', '0', '0', '15.5', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class StringCall extends FunctionCall { public StringCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int argc = argumentCount ( ) ; if ( argc > 1 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , this ) ; throw new TypeCheckError ( err ) ; } if ( argc > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . String ) ) { targ . translateTo ( classGen , methodGen , Type . String ) ; } } } 	0	['3', '4', '0', '13', '17', '3', '0', '13', '3', '2', '75', '0', '0', '0.979591837', '0.444444444', '3', '13', '24', '3', '1.3333', '0']
package org . apache . xalan . serialize ; public interface DOMSerializer extends org . apache . xml . serializer . DOMSerializer { } 	0	['0', '1', '0', '4', '0', '0', '3', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . xslt ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '4', '44', '64', '2', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncNamespace extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; String s ; if ( context != DTM . NULL ) { DTM dtm = xctxt . getDTM ( context ) ; int t = dtm . getNodeType ( context ) ; if ( t == DTM . ELEMENT_NODE ) { s = dtm . getNamespaceURI ( context ) ; } else if ( t == DTM . ATTRIBUTE_NODE ) { s = dtm . getNodeName ( context ) ; if ( s . startsWith ( "xmlns:" ) || s . equals ( "xmlns" ) ) return XString . EMPTYSTRING ; s = dtm . getNamespaceURI ( context ) ; } else return XString . EMPTYSTRING ; } else return XString . EMPTYSTRING ; return ( ( null == s ) ? XString . EMPTYSTRING : new XString ( s ) ) ; } } 	0	['2', '5', '0', '5', '11', '1', '0', '5', '2', '2', '65', '0', '0', '0.982142857', '0.75', '3', '8', '31.5', '1', '0.5', '0']
package org . apache . xml . utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemVariable ; class ProcessorGlobalVariableDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemVariable v = ( ElemVariable ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setVariable ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0	['3', '5', '0', '6', '10', '3', '1', '5', '1', '2', '30', '0', '0', '0.990697674', '0.583333333', '1', '2', '9', '1', '0.6667', '0']
package org . apache . xpath . axes ; import org . apache . xpath . XPathContext ; public interface SubContextList { public int getLastPos ( XPathContext xctxt ) ; public int getProximityPosition ( XPathContext xctxt ) ; } 	0	['2', '1', '0', '7', '2', '1', '7', '1', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . compiler ; public class OpCodes { public static final int ENDOP = - 1 ; public static final int EMPTY = - 2 ; public static final int ELEMWILDCARD = - 3 ; public static final int OP_XPATH = 1 ; public static final int OP_OR = 2 ; public static final int OP_AND = 3 ; public static final int OP_NOTEQUALS = 4 ; public static final int OP_EQUALS = 5 ; public static final int OP_LTE = 6 ; public static final int OP_LT = 7 ; public static final int OP_GTE = 8 ; public static final int OP_GT = 9 ; public static final int OP_PLUS = 10 ; public static final int OP_MINUS = 11 ; public static final int OP_MULT = 12 ; public static final int OP_DIV = 13 ; public static final int OP_MOD = 14 ; public static final int OP_QUO = 15 ; public static final int OP_NEG = 16 ; public static final int OP_STRING = 17 ; public static final int OP_BOOL = 18 ; public static final int OP_NUMBER = 19 ; public static final int OP_UNION = 20 ; public static final int OP_LITERAL = 21 ; static final int FIRST_NODESET_OP = 22 ; public static final int OP_VARIABLE = 22 ; public static final int OP_GROUP = 23 ; public static final int OP_EXTFUNCTION = 24 ; public static final int OP_FUNCTION = 25 ; static final int LAST_NODESET_OP = 25 ; public static final int OP_ARGUMENT = 26 ; public static final int OP_NUMBERLIT = 27 ; public static final int OP_LOCATIONPATH = 28 ; public static final int OP_PREDICATE = 29 ; public static final int OP_MATCHPATTERN = 30 ; public static final int OP_LOCATIONPATHPATTERN = 31 ; public static final int NODETYPE_COMMENT = 1030 ; public static final int NODETYPE_TEXT = 1031 ; public static final int NODETYPE_PI = 1032 ; public static final int NODETYPE_NODE = 1033 ; public static final int NODENAME = 34 ; public static final int NODETYPE_ROOT = 35 ; public static final int NODETYPE_ANYELEMENT = 36 ; public static final int NODETYPE_FUNCTEST = 1034 ; public static final int AXES_START_TYPES = 37 ; public static final int FROM_ANCESTORS = 37 ; public static final int FROM_ANCESTORS_OR_SELF = 38 ; public static final int FROM_ATTRIBUTES = 39 ; public static final int FROM_CHILDREN = 40 ; public static final int FROM_DESCENDANTS = 41 ; public static final int FROM_DESCENDANTS_OR_SELF = 42 ; public static final int FROM_FOLLOWING = 43 ; public static final int FROM_FOLLOWING_SIBLINGS = 44 ; public static final int FROM_PARENT = 45 ; public static final int FROM_PRECEDING = 46 ; public static final int FROM_PRECEDING_SIBLINGS = 47 ; public static final int FROM_SELF = 48 ; public static final int FROM_NAMESPACE = 49 ; public static final int FROM_ROOT = 50 ; public static final int MATCH_ATTRIBUTE = 51 ; public static final int MATCH_ANY_ANCESTOR = 52 ; public static final int MATCH_IMMEDIATE_ANCESTOR = 53 ; public static final int AXES_END_TYPES = 53 ; private static final int NEXT_FREE_ID = 99 ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '68', '0.015625', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . dtm . ref ; public class DTMSafeStringPool extends DTMStringPool { public synchronized void removeAllElements ( ) { super . removeAllElements ( ) ; } public synchronized String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { return super . indexToString ( i ) ; } public synchronized int stringToIndex ( String s ) { return super . stringToIndex ( s ) ; } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; DTMStringPool pool = new DTMSafeStringPool ( ) ; System . out . println ( "If no complaints are printed below, we passed initial test." ) ; for ( int pass = 0 ; pass <= 1 ; ++ pass ) { int i ; for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch populating pool: assigned " + j + " for create " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch in stringToIndex: returned " + j + " for lookup " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { String w = pool . indexToString ( i ) ; if ( ! word [ i ] . equals ( w ) ) System . out . println ( "\tMismatch in indexToString: returned" + w + " for lookup " + i ) ; } pool . removeAllElements ( ) ; System . out . println ( "\nPass " + pass + " complete\n" ) ; } } } 	0	['5', '2', '0', '1', '15', '10', '0', '1', '5', '2', '305', '0', '0', '0.5', '0.35', '1', '4', '60', '8', '2.2', '0']
package org . apache . xml . utils ; import java . io . Serializable ; public class NameSpace implements Serializable { public NameSpace m_next = null ; public String m_prefix ; public String m_uri ; public NameSpace ( String prefix , String uri ) { m_prefix = prefix ; m_uri = uri ; } } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '16', '0', '1', '0', '1', '0', '0', '12', '0', '0', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Bool extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { if ( XObject . CLASS_BOOLEAN == right . getType ( ) ) return right ; else return right . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_right . bool ( xctxt ) ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '24', '0', '0', '0.952380952', '0.555555556', '1', '1', '7', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ConcatCall extends FunctionCall { public ConcatCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { for ( int i = 0 ; i < argumentCount ( ) ; i ++ ) { final Expression exp = argument ( i ) ; if ( ! exp . typeCheck ( stable ) . identicalTo ( Type . String ) ) { setArgument ( i , new CastExpr ( exp , Type . String ) ) ; } } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int nArgs = argumentCount ( ) ; switch ( nArgs ) { case 0 : il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; break ; case 1 : argument ( ) . translate ( classGen , methodGen ) ; break ; default : final int initBuffer = cpg . addMethodref ( STRING_BUFFER_CLASS , "<init>" , "()V" ) ; final Instruction append = new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_BUFFER_CLASS , "append" , "(" + STRING_SIG + ")" + STRING_BUFFER_SIG ) ) ; final int toString = cpg . addMethodref ( STRING_BUFFER_CLASS , "toString" , "()" + STRING_SIG ) ; il . append ( new NEW ( cpg . addClass ( STRING_BUFFER_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( initBuffer ) ) ; for ( int i = 0 ; i < nArgs ; i ++ ) { argument ( i ) . translate ( classGen , methodGen ) ; il . append ( append ) ; } il . append ( new INVOKEVIRTUAL ( toString ) ) ; } } } 	0	['3', '4', '0', '19', '22', '3', '0', '19', '3', '2', '131', '0', '0', '0.979591837', '0.444444444', '3', '14', '42.66666667', '5', '2', '0']
package org . apache . xalan . lib ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . util . Hashtable ; import javax . xml . transform . Result ; import javax . xml . transform . TransformerException ; import javax . xml . transform . stream . StreamResult ; import org . apache . xalan . extensions . XSLProcessorContext ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . OutputProperties ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xpath . XPath ; import org . apache . xpath . objects . XObject ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . ContentHandler ; public class Redirect { protected Hashtable m_formatterListeners = new Hashtable ( ) ; protected Hashtable m_outputStreams = new Hashtable ( ) ; public static final boolean DEFAULT_APPEND_OPEN = false ; public static final boolean DEFAULT_APPEND_WRITE = false ; public void open ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object flistener = m_formatterListeners . get ( fileName ) ; if ( null == flistener ) { String mkdirsExpr = elem . getAttribute ( "mkdirs" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean mkdirs = ( mkdirsExpr != null ) ? ( mkdirsExpr . equals ( "true" ) || mkdirsExpr . equals ( "yes" ) ) : true ; String appendExpr = elem . getAttribute ( "append" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean append = ( appendExpr != null ) ? ( appendExpr . equals ( "true" ) || appendExpr . equals ( "yes" ) ) : DEFAULT_APPEND_OPEN ; Object ignored = makeFormatterListener ( context , elem , fileName , true , mkdirs , append ) ; } } public void write ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object flObject = m_formatterListeners . get ( fileName ) ; ContentHandler formatter ; boolean inTable = false ; if ( null == flObject ) { String mkdirsExpr = ( ( ElemExtensionCall ) elem ) . getAttribute ( "mkdirs" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean mkdirs = ( mkdirsExpr != null ) ? ( mkdirsExpr . equals ( "true" ) || mkdirsExpr . equals ( "yes" ) ) : true ; String appendExpr = elem . getAttribute ( "append" , context . getContextNode ( ) , context . getTransformer ( ) ) ; boolean append = ( appendExpr != null ) ? ( appendExpr . equals ( "true" ) || appendExpr . equals ( "yes" ) ) : DEFAULT_APPEND_WRITE ; formatter = makeFormatterListener ( context , elem , fileName , true , mkdirs , append ) ; } else { inTable = true ; formatter = ( ContentHandler ) flObject ; } TransformerImpl transf = context . getTransformer ( ) ; transf . executeChildTemplates ( elem , context . getContextNode ( ) , context . getMode ( ) , formatter ) ; if ( ! inTable ) { OutputStream ostream = ( OutputStream ) m_outputStreams . get ( fileName ) ; if ( null != ostream ) { try { formatter . endDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } ostream . close ( ) ; m_outputStreams . remove ( fileName ) ; m_formatterListeners . remove ( fileName ) ; } } } public void close ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName = getFilename ( context , elem ) ; Object formatterObj = m_formatterListeners . get ( fileName ) ; if ( null != formatterObj ) { ContentHandler fl = ( ContentHandler ) formatterObj ; try { fl . endDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } OutputStream ostream = ( OutputStream ) m_outputStreams . get ( fileName ) ; if ( null != ostream ) { ostream . close ( ) ; m_outputStreams . remove ( fileName ) ; } m_formatterListeners . remove ( fileName ) ; } } private String getFilename ( XSLProcessorContext context , ElemExtensionCall elem ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { String fileName ; String fileNameExpr = ( ( ElemExtensionCall ) elem ) . getAttribute ( "select" , context . getContextNode ( ) , context . getTransformer ( ) ) ; if ( null != fileNameExpr ) { org . apache . xpath . XPathContext xctxt = context . getTransformer ( ) . getXPathContext ( ) ; XPath myxpath = new XPath ( fileNameExpr , elem , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; XObject xobj = myxpath . execute ( xctxt , context . getContextNode ( ) , elem ) ; fileName = xobj . str ( ) ; if ( ( null == fileName ) || ( fileName . length ( ) == 0 ) ) { fileName = elem . getAttribute ( "file" , context . getContextNode ( ) , context . getTransformer ( ) ) ; } } else { fileName = elem . getAttribute ( "file" , context . getContextNode ( ) , context . getTransformer ( ) ) ; } if ( null == fileName ) { context . getTransformer ( ) . getMsgMgr ( ) . error ( elem , elem , context . getContextNode ( ) , XSLTErrorResources . ER_REDIRECT_COULDNT_GET_FILENAME ) ; } return fileName ; } private String urlToFileName ( String base ) { if ( null != base ) { if ( base . startsWith ( "file:////" ) ) { base = base . substring ( 7 ) ; } else if ( base . startsWith ( "file:///" ) ) { base = base . substring ( 6 ) ; } else if ( base . startsWith ( "file://" ) ) { base = base . substring ( 5 ) ; } else if ( base . startsWith ( "file:/" ) ) { base = base . substring ( 5 ) ; } else if ( base . startsWith ( "file:" ) ) { base = base . substring ( 4 ) ; } } return base ; } private ContentHandler makeFormatterListener ( XSLProcessorContext context , ElemExtensionCall elem , String fileName , boolean shouldPutInTable , boolean mkdirs , boolean append ) throws java . net . MalformedURLException , java . io . FileNotFoundException , java . io . IOException , javax . xml . transform . TransformerException { File file = new File ( fileName ) ; TransformerImpl transformer = context . getTransformer ( ) ; String base ; if ( ! file . isAbsolute ( ) ) { Result outputTarget = transformer . getOutputTarget ( ) ; if ( ( null != outputTarget ) && ( ( base = outputTarget . getSystemId ( ) ) != null ) ) { base = urlToFileName ( base ) ; } else { base = urlToFileName ( transformer . getBaseURLOfSource ( ) ) ; } if ( null != base ) { File baseFile = new File ( base ) ; file = new File ( baseFile . getParent ( ) , fileName ) ; } } if ( mkdirs ) { String dirStr = file . getParent ( ) ; if ( ( null != dirStr ) && ( dirStr . length ( ) > 0 ) ) { File dir = new File ( dirStr ) ; dir . mkdirs ( ) ; } } OutputProperties format = transformer . getOutputFormat ( ) ; FileOutputStream ostream = new FileOutputStream ( file . getPath ( ) , append ) ; try { SerializationHandler flistener = transformer . createSerializationHandler ( new StreamResult ( ostream ) , format ) ; try { flistener . startDocument ( ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } if ( shouldPutInTable ) { m_outputStreams . put ( fileName , ostream ) ; m_formatterListeners . put ( fileName , flistener ) ; } return flistener ; } catch ( TransformerException te ) { throw new javax . xml . transform . TransformerException ( te ) ; } } } 	0	['7', '1', '0', '12', '45', '1', '0', '12', '4', '0.75', '499', '0.5', '0', '0', '0.571428571', '0', '0', '69.71428571', '7', '1.7143', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IF_ICMPEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Whitespace extends TopLevelElement { public static final int USE_PREDICATE = 0 ; public static final int STRIP_SPACE = 1 ; public static final int PRESERVE_SPACE = 2 ; public static final int RULE_NONE = 0 ; public static final int RULE_ELEMENT = 1 ; public static final int RULE_NAMESPACE = 2 ; public static final int RULE_ALL = 3 ; private String _elementList ; private int _action ; private int _importPrecedence ; private final static class WhitespaceRule { private final int _action ; private String _namespace ; private String _element ; private int _type ; private int _priority ; public WhitespaceRule ( int action , String element , int precedence ) { _action = action ; final int colon = element . indexOf ( ':' ) ; if ( colon >= 0 ) { _namespace = element . substring ( 0 , colon ) ; _element = element . substring ( colon + 1 , element . length ( ) ) ; } else { _namespace = Constants . EMPTYSTRING ; _element = element ; } _priority = precedence << 2 ; if ( _element . equals ( "*" ) ) { if ( _namespace == Constants . EMPTYSTRING ) { _type = RULE_ALL ; _priority += 2 ; } else { _type = RULE_NAMESPACE ; _priority += 1 ; } } else { _type = RULE_ELEMENT ; } } public int compareTo ( WhitespaceRule other ) { return _priority < other . _priority ? - 1 : _priority > other . _priority ? 1 : 0 ; } public int getAction ( ) { return _action ; } public int getStrength ( ) { return _type ; } public int getPriority ( ) { return _priority ; } public String getElement ( ) { return _element ; } public String getNamespace ( ) { return _namespace ; } } public void parseContents ( Parser parser ) { _action = _qname . getLocalPart ( ) . endsWith ( "strip-space" ) ? STRIP_SPACE : PRESERVE_SPACE ; _importPrecedence = parser . getCurrentImportPrecedence ( ) ; _elementList = getAttribute ( "elements" ) ; if ( _elementList == null || _elementList . length ( ) == 0 ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "elements" ) ; return ; } final SymbolTable stable = parser . getSymbolTable ( ) ; StringTokenizer list = new StringTokenizer ( _elementList ) ; StringBuffer elements = new StringBuffer ( Constants . EMPTYSTRING ) ; while ( list . hasMoreElements ( ) ) { String token = list . nextToken ( ) ; String prefix ; String namespace ; int col ; if ( ( col = token . indexOf ( ':' ) ) != - 1 ) { prefix = token . substring ( 0 , col ) ; } else { prefix = Constants . EMPTYSTRING ; } namespace = lookupNamespace ( prefix ) ; if ( namespace != null ) elements . append ( namespace + ":" + token . substring ( col + 1 , token . length ( ) ) ) ; else elements . append ( token ) ; if ( list . hasMoreElements ( ) ) elements . append ( " " ) ; } _elementList = elements . toString ( ) ; } public Vector getRules ( ) { final Vector rules = new Vector ( ) ; final StringTokenizer list = new StringTokenizer ( _elementList ) ; while ( list . hasMoreElements ( ) ) { rules . add ( new WhitespaceRule ( _action , list . nextToken ( ) , _importPrecedence ) ) ; } return rules ; } private static WhitespaceRule findContradictingRule ( Vector rules , WhitespaceRule rule ) { for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { WhitespaceRule currentRule = ( WhitespaceRule ) rules . elementAt ( i ) ; if ( currentRule == rule ) { return null ; } switch ( currentRule . getStrength ( ) ) { case RULE_ALL : return currentRule ; case RULE_ELEMENT : if ( ! rule . getElement ( ) . equals ( currentRule . getElement ( ) ) ) { break ; } case RULE_NAMESPACE : if ( rule . getNamespace ( ) . equals ( currentRule . getNamespace ( ) ) ) { return currentRule ; } break ; } } return null ; } private static int prioritizeRules ( Vector rules ) { WhitespaceRule currentRule ; int defaultAction = PRESERVE_SPACE ; quicksort ( rules , 0 , rules . size ( ) - 1 ) ; boolean strip = false ; for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { currentRule = ( WhitespaceRule ) rules . elementAt ( i ) ; if ( currentRule . getAction ( ) == STRIP_SPACE ) { strip = true ; } } if ( ! strip ) { rules . removeAllElements ( ) ; return PRESERVE_SPACE ; } for ( int idx = 0 ; idx < rules . size ( ) ; ) { currentRule = ( WhitespaceRule ) rules . elementAt ( idx ) ; if ( findContradictingRule ( rules , currentRule ) != null ) { rules . remove ( idx ) ; } else { if ( currentRule . getStrength ( ) == RULE_ALL ) { defaultAction = currentRule . getAction ( ) ; for ( int i = idx ; i < rules . size ( ) ; i ++ ) { rules . removeElementAt ( i ) ; } } idx ++ ; } } if ( rules . size ( ) == 0 ) { return defaultAction ; } do { currentRule = ( WhitespaceRule ) rules . lastElement ( ) ; if ( currentRule . getAction ( ) == defaultAction ) { rules . removeElementAt ( rules . size ( ) - 1 ) ; } else { break ; } } while ( rules . size ( ) > 0 ) ; return defaultAction ; } public static void compileStripSpace ( BranchHandle strip [ ] , int sCount , InstructionList il ) { final InstructionHandle target = il . append ( ICONST_1 ) ; il . append ( IRETURN ) ; for ( int i = 0 ; i < sCount ; i ++ ) { strip [ i ] . setTarget ( target ) ; } } public static void compilePreserveSpace ( BranchHandle preserve [ ] , int pCount , InstructionList il ) { final InstructionHandle target = il . append ( ICONST_0 ) ; il . append ( IRETURN ) ; for ( int i = 0 ; i < pCount ; i ++ ) { preserve [ i ] . setTarget ( target ) ; } } private static void compilePredicate ( Vector rules , int defaultAction , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final MethodGenerator stripSpace = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "node" , "type" } , "stripSpace" , classGen . getClassName ( ) , il , cpg ) ; classGen . addInterface ( "org/apache/xalan/xsltc/StripFilter" ) ; final int paramDom = stripSpace . getLocalIndex ( "dom" ) ; final int paramCurrent = stripSpace . getLocalIndex ( "node" ) ; final int paramType = stripSpace . getLocalIndex ( "type" ) ; BranchHandle strip [ ] = new BranchHandle [ rules . size ( ) ] ; BranchHandle preserve [ ] = new BranchHandle [ rules . size ( ) ] ; int sCount = 0 ; int pCount = 0 ; for ( int i = 0 ; i < rules . size ( ) ; i ++ ) { WhitespaceRule rule = ( WhitespaceRule ) rules . elementAt ( i ) ; final int gns = cpg . addInterfaceMethodref ( DOM_INTF , "getNamespaceName" , "(I)Ljava/lang/String;" ) ; final int strcmp = cpg . addMethodref ( "java/lang/String" , "compareTo" , "(Ljava/lang/String;)I" ) ; if ( rule . getStrength ( ) == RULE_NAMESPACE ) { il . append ( new ALOAD ( paramDom ) ) ; il . append ( new ILOAD ( paramCurrent ) ) ; il . append ( new INVOKEINTERFACE ( gns , 2 ) ) ; il . append ( new PUSH ( cpg , rule . getNamespace ( ) ) ) ; il . append ( new INVOKEVIRTUAL ( strcmp ) ) ; il . append ( ICONST_0 ) ; if ( rule . getAction ( ) == STRIP_SPACE ) { strip [ sCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } else { preserve [ pCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } } else if ( rule . getStrength ( ) == RULE_ELEMENT ) { final Parser parser = classGen . getParser ( ) ; QName qname ; if ( rule . getNamespace ( ) != Constants . EMPTYSTRING ) qname = parser . getQName ( rule . getNamespace ( ) , null , rule . getElement ( ) ) ; else qname = parser . getQName ( rule . getElement ( ) ) ; final int elementType = xsltc . registerElement ( qname ) ; il . append ( new ILOAD ( paramType ) ) ; il . append ( new PUSH ( cpg , elementType ) ) ; if ( rule . getAction ( ) == STRIP_SPACE ) strip [ sCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; else preserve [ pCount ++ ] = il . append ( new IF_ICMPEQ ( null ) ) ; } } if ( defaultAction == STRIP_SPACE ) { compileStripSpace ( strip , sCount , il ) ; compilePreserveSpace ( preserve , pCount , il ) ; } else { compilePreserveSpace ( preserve , pCount , il ) ; compileStripSpace ( strip , sCount , il ) ; } stripSpace . stripAttributes ( true ) ; stripSpace . setMaxLocals ( ) ; stripSpace . setMaxStack ( ) ; stripSpace . removeNOPs ( ) ; classGen . addMethod ( stripSpace . getMethod ( ) ) ; } private static void compileDefault ( int defaultAction , ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final XSLTC xsltc = classGen . getParser ( ) . getXSLTC ( ) ; final MethodGenerator stripSpace = new MethodGenerator ( ACC_PUBLIC | ACC_FINAL , org . apache . bcel . generic . Type . BOOLEAN , new org . apache . bcel . generic . Type [ ] { Util . getJCRefType ( DOM_INTF_SIG ) , org . apache . bcel . generic . Type . INT , org . apache . bcel . generic . Type . INT } , new String [ ] { "dom" , "node" , "type" } , "stripSpace" , classGen . getClassName ( ) , il , cpg ) ; classGen . addInterface ( "org/apache/xalan/xsltc/StripFilter" ) ; if ( defaultAction == STRIP_SPACE ) il . append ( ICONST_1 ) ; else il . append ( ICONST_0 ) ; il . append ( IRETURN ) ; stripSpace . stripAttributes ( true ) ; stripSpace . setMaxLocals ( ) ; stripSpace . setMaxStack ( ) ; stripSpace . removeNOPs ( ) ; classGen . addMethod ( stripSpace . getMethod ( ) ) ; } public static int translateRules ( Vector rules , ClassGenerator classGen ) { final int defaultAction = prioritizeRules ( rules ) ; if ( rules . size ( ) == 0 ) { compileDefault ( defaultAction , classGen ) ; return defaultAction ; } compilePredicate ( rules , defaultAction , classGen ) ; return USE_PREDICATE ; } private static void quicksort ( Vector rules , int p , int r ) { while ( p < r ) { final int q = partition ( rules , p , r ) ; quicksort ( rules , p , q ) ; p = q + 1 ; } } private static int partition ( Vector rules , int p , int r ) { final WhitespaceRule x = ( WhitespaceRule ) rules . elementAt ( ( p + r ) > > > 1 ) ; int i = p - 1 , j = r + 1 ; while ( true ) { while ( x . compareTo ( ( WhitespaceRule ) rules . elementAt ( -- j ) ) < 0 ) { } while ( x . compareTo ( ( WhitespaceRule ) rules . elementAt ( ++ i ) ) > 0 ) { } if ( i < j ) { final WhitespaceRule tmp = ( WhitespaceRule ) rules . elementAt ( i ) ; rules . setElementAt ( rules . elementAt ( j ) , i ) ; rules . setElementAt ( tmp , j ) ; } else { return j ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['14', '3', '0', '30', '81', '79', '1', '29', '7', '1.030769231', '805', '0.3', '0', '0.821917808', '0.207142857', '2', '6', '55.78571429', '11', '3.5714', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . dtm . DTM ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xml . utils . XMLString ; public class ClonerToResultTree { public static void cloneToResultTree ( int node , int nodeType , DTM dtm , SerializationHandler rth , boolean shouldCloneAttributes ) throws TransformerException { try { switch ( nodeType ) { case DTM . TEXT_NODE : dtm . dispatchCharactersEvents ( node , rth , false ) ; break ; case DTM . DOCUMENT_FRAGMENT_NODE : case DTM . DOCUMENT_NODE : break ; case DTM . ELEMENT_NODE : { String ns = dtm . getNamespaceURI ( node ) ; if ( ns == null ) ns = "" ; String localName = dtm . getLocalName ( node ) ; rth . startElement ( ns , localName , dtm . getNodeNameX ( node ) ) ; if ( shouldCloneAttributes ) { SerializerUtils . addAttributes ( rth , node ) ; SerializerUtils . processNSDecls ( rth , node , nodeType , dtm ) ; } } break ; case DTM . CDATA_SECTION_NODE : rth . startCDATA ( ) ; dtm . dispatchCharactersEvents ( node , rth , false ) ; rth . endCDATA ( ) ; break ; case DTM . ATTRIBUTE_NODE : SerializerUtils . addAttribute ( rth , node ) ; break ; case DTM . NAMESPACE_NODE : SerializerUtils . processNSDecls ( rth , node , DTM . NAMESPACE_NODE , dtm ) ; break ; case DTM . COMMENT_NODE : XMLString xstr = dtm . getStringValue ( node ) ; xstr . dispatchAsComment ( rth ) ; break ; case DTM . ENTITY_REFERENCE_NODE : rth . entityReference ( dtm . getNodeNameX ( node ) ) ; break ; case DTM . PROCESSING_INSTRUCTION_NODE : { rth . processingInstruction ( dtm . getNodeNameX ( node ) , dtm . getNodeValue ( node ) ) ; } break ; default : throw new TransformerException ( "Can't clone node: " + dtm . getNodeName ( node ) ) ; } } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } } } 	0	['2', '1', '0', '7', '24', '1', '3', '4', '2', '2', '109', '0', '0', '0', '0.5', '0', '0', '53.5', '1', '0.5', '0']
package org . apache . xalan . lib ; import java . util . StringTokenizer ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class ExsltStrings extends ExsltBase { public static String align ( String targetStr , String paddingStr , String type ) { if ( targetStr . length ( ) >= paddingStr . length ( ) ) return targetStr . substring ( 0 , paddingStr . length ( ) ) ; if ( type . equals ( "right" ) ) { return paddingStr . substring ( 0 , paddingStr . length ( ) - targetStr . length ( ) ) + targetStr ; } else if ( type . equals ( "center" ) ) { int startIndex = ( paddingStr . length ( ) - targetStr . length ( ) ) / 2 ; return paddingStr . substring ( 0 , startIndex ) + targetStr + paddingStr . substring ( startIndex + targetStr . length ( ) ) ; } else { return targetStr + paddingStr . substring ( targetStr . length ( ) ) ; } } public static String align ( String targetStr , String paddingStr ) { return align ( targetStr , paddingStr , "left" ) ; } public static String concat ( NodeList nl ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node node = nl . item ( i ) ; String value = toString ( node ) ; if ( value != null && value . length ( ) > 0 ) sb . append ( value ) ; } return sb . toString ( ) ; } public static String padding ( double length , String pattern ) { if ( pattern == null || pattern . length ( ) == 0 ) return "" ; StringBuffer sb = new StringBuffer ( ) ; int len = ( int ) length ; int numAdded = 0 ; int index = 0 ; while ( numAdded < len ) { if ( index == pattern . length ( ) ) index = 0 ; sb . append ( pattern . charAt ( index ) ) ; index ++ ; numAdded ++ ; } return sb . toString ( ) ; } public static String padding ( double length ) { return padding ( length , " " ) ; } public static NodeList split ( String str , String pattern ) { NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; boolean done = false ; int fromIndex = 0 ; int matchIndex = 0 ; String token = null ; while ( ! done && fromIndex < str . length ( ) ) { matchIndex = str . indexOf ( pattern , fromIndex ) ; if ( matchIndex >= 0 ) { token = str . substring ( fromIndex , matchIndex ) ; fromIndex = matchIndex + pattern . length ( ) ; } else { done = true ; token = str . substring ( fromIndex ) ; } Document doc = DocumentHolder . m_doc ; synchronized ( doc ) { Element element = doc . createElement ( "token" ) ; Text text = doc . createTextNode ( token ) ; element . appendChild ( text ) ; resultSet . addNode ( element ) ; } } return resultSet ; } public static NodeList split ( String str ) { return split ( str , " " ) ; } public static NodeList tokenize ( String toTokenize , String delims ) { NodeSet resultSet = new NodeSet ( ) ; if ( delims != null && delims . length ( ) > 0 ) { StringTokenizer lTokenizer = new StringTokenizer ( toTokenize , delims ) ; Document doc = DocumentHolder . m_doc ; synchronized ( doc ) { while ( lTokenizer . hasMoreTokens ( ) ) { Element element = doc . createElement ( "token" ) ; element . appendChild ( doc . createTextNode ( lTokenizer . nextToken ( ) ) ) ; resultSet . addNode ( element ) ; } } } else { Document doc = DocumentHolder . m_doc ; synchronized ( doc ) { for ( int i = 0 ; i < toTokenize . length ( ) ; i ++ ) { Element element = doc . createElement ( "token" ) ; element . appendChild ( doc . createTextNode ( toTokenize . substring ( i , i + 1 ) ) ) ; resultSet . addNode ( element ) ; } } } return resultSet ; } public static NodeList tokenize ( String toTokenize ) { return tokenize ( toTokenize , " \t\n\r" ) ; } private static class DocumentHolder { private static final Document m_doc ; static { try { m_doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } catch ( ParserConfigurationException pce ) { throw new org . apache . xml . utils . WrappedRuntimeException ( pce ) ; } } } } 	0	['10', '2', '0', '3', '37', '45', '0', '3', '10', '2', '341', '0', '0', '0.181818182', '0.275', '0', '0', '33.1', '5', '2.6', '0']
package org . apache . xalan . xsltc . compiler ; import org . xml . sax . InputSource ; public interface SourceLoader { public InputSource loadSource ( String href , String context , XSLTC xsltc ) ; } 	0	['1', '1', '0', '6', '1', '0', '6', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Lte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . lessThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xml . dtm ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xml . utils ; import java . util . Vector ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class ObjectPool implements java . io . Serializable { private final Class objectType ; private final Vector freeStack ; public ObjectPool ( Class type ) { objectType = type ; freeStack = new Vector ( ) ; } public ObjectPool ( String className ) { try { objectType = ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; } catch ( ClassNotFoundException cnfe ) { throw new WrappedRuntimeException ( cnfe ) ; } freeStack = new Vector ( ) ; } public ObjectPool ( Class type , int size ) { objectType = type ; freeStack = new Vector ( size ) ; } public ObjectPool ( ) { objectType = null ; freeStack = new Vector ( ) ; } public synchronized Object getInstanceIfFree ( ) { if ( ! freeStack . isEmpty ( ) ) { Object result = freeStack . lastElement ( ) ; freeStack . setSize ( freeStack . size ( ) - 1 ) ; return result ; } return null ; } public synchronized Object getInstance ( ) { if ( freeStack . isEmpty ( ) ) { try { return objectType . newInstance ( ) ; } catch ( InstantiationException ex ) { } catch ( IllegalAccessException ex ) { } throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_EXCEPTION_CREATING_POOL , null ) ) ; } else { Object result = freeStack . lastElement ( ) ; freeStack . setSize ( freeStack . size ( ) - 1 ) ; return result ; } } public synchronized void freeInstance ( Object obj ) { freeStack . addElement ( obj ) ; } } 	0	['7', '1', '0', '5', '21', '0', '2', '3', '7', '0.166666667', '121', '1', '0', '0', '0.342857143', '0', '0', '16', '2', '0.7143', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class IdKeyPattern extends LocationPathPattern { protected RelativePathPattern _left = null ; ; private String _index = null ; private String _value = null ; ; public IdKeyPattern ( String index , String value ) { _index = index ; _value = value ; } public String getIndexName ( ) { return ( _index ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . NodeSet ; } public boolean isWildcard ( ) { return false ; } public void setLeft ( RelativePathPattern left ) { _left = left ; } public StepPattern getKernelPattern ( ) { return ( null ) ; } public void reduceKernelPattern ( ) { } public String toString ( ) { return "id/keyPattern(" + _index + ", " + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getKeyIndex = cpg . addMethodref ( TRANSLET_CLASS , "getKeyIndex" , "(Ljava/lang/String;)" + KEY_INDEX_SIG ) ; final int lookupId = cpg . addMethodref ( KEY_INDEX_CLASS , "containsID" , "(ILjava/lang/Object;)I" ) ; final int lookupKey = cpg . addMethodref ( KEY_INDEX_CLASS , "containsKey" , "(ILjava/lang/Object;)I" ) ; final int getNodeIdent = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeIdent" , "(I)" + NODE_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , _index ) ) ; il . append ( new INVOKEVIRTUAL ( getKeyIndex ) ) ; il . append ( SWAP ) ; il . append ( new PUSH ( cpg , _value ) ) ; if ( this instanceof IdPattern ) { il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( lookupId ) ) ; } else { il . append ( SWAP ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( getNodeIdent , 2 ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( lookupKey ) ) ; } _trueList . add ( il . append ( new IFNE ( null ) ) ) ; _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } 	0	['9', '5', '2', '25', '29', '22', '3', '23', '9', '0.75', '214', '1', '1', '0.925233645', '0.259259259', '3', '4', '22.44444444', '2', '1', '0']
package org . apache . xalan . templates ; public class ElemExtensionScript extends ElemTemplateElement { public ElemExtensionScript ( ) { } private String m_lang = null ; public void setLang ( String v ) { m_lang = v ; } public String getLang ( ) { return m_lang ; } private String m_src = null ; public void setSrc ( String v ) { m_src = v ; } public String getSrc ( ) { return m_src ; } public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONSCRIPT ; } } 	0	['6', '3', '0', '2', '7', '3', '1', '1', '6', '0.6', '33', '1', '0', '0.975124378', '0.666666667', '1', '2', '4.166666667', '1', '0.8333', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncQname extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; XObject val ; if ( DTM . NULL != context ) { DTM dtm = xctxt . getDTM ( context ) ; String qname = dtm . getNodeNameX ( context ) ; val = ( null == qname ) ? XString . EMPTYSTRING : new XString ( qname ) ; } else { val = XString . EMPTYSTRING ; } return val ; } } 	0	['2', '5', '0', '5', '7', '1', '0', '5', '2', '2', '35', '0', '0', '0.982142857', '0.75', '2', '7', '16.5', '1', '0.5', '0']
package org . apache . xalan . lib . sql ; import java . util . * ; import java . sql . * ; import org . apache . xpath . objects . * ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xml . utils . QName ; import javax . xml . transform . TransformerException ; public class SQLQueryParser { private boolean m_InlineVariables = false ; private boolean m_IsCallable = false ; private String m_OrigQuery = null ; private StringBuffer m_ParsedQuery = null ; private Vector m_Parameters = null ; private boolean m_hasOutput = false ; private boolean m_HasParameters ; public static final int NO_OVERRIDE = 0 ; public static final int NO_INLINE_PARSER = 1 ; public static final int INLINE_PARSER = 2 ; public SQLQueryParser ( ) { init ( ) ; } private SQLQueryParser ( String query ) { m_OrigQuery = query ; } private void init ( ) { } public SQLQueryParser parse ( XConnection xconn , String query , int override ) { SQLQueryParser parser = new SQLQueryParser ( query ) ; parser . parse ( xconn , override ) ; return parser ; } private void parse ( XConnection xconn , int override ) { m_InlineVariables = "true" . equals ( xconn . getFeature ( "inline-variables" ) ) ; if ( override == NO_INLINE_PARSER ) m_InlineVariables = false ; else if ( override == INLINE_PARSER ) m_InlineVariables = true ; if ( m_InlineVariables ) inlineParser ( ) ; } public boolean hasParameters ( ) { return m_HasParameters ; } public boolean isCallable ( ) { return m_IsCallable ; } public Vector getParameters ( ) { return m_Parameters ; } public void setParameters ( Vector p ) { m_HasParameters = true ; m_Parameters = p ; } public String getSQLQuery ( ) { if ( m_InlineVariables ) return m_ParsedQuery . toString ( ) ; else return m_OrigQuery ; } public void populateStatement ( PreparedStatement stmt , ExpressionContext ctx ) { for ( int indx = 0 ; indx < m_Parameters . size ( ) ; indx ++ ) { QueryParameter parm = ( QueryParameter ) m_Parameters . elementAt ( indx ) ; try { if ( m_InlineVariables ) { XObject value = ( XObject ) ctx . getVariableOrParam ( new QName ( parm . getName ( ) ) ) ; if ( value != null ) { stmt . setObject ( indx + 1 , value . object ( ) , parm . getType ( ) , 4 ) ; } else { stmt . setNull ( indx + 1 , parm . getType ( ) ) ; } } else { String value = parm . getValue ( ) ; if ( value != null ) { stmt . setObject ( indx + 1 , value , parm . getType ( ) , 4 ) ; } else { stmt . setNull ( indx + 1 , parm . getType ( ) ) ; } } } catch ( Exception tx ) { } } } public void registerOutputParameters ( CallableStatement cstmt ) throws SQLException { if ( m_IsCallable && m_hasOutput ) { for ( int indx = 0 ; indx < m_Parameters . size ( ) ; indx ++ ) { QueryParameter parm = ( QueryParameter ) m_Parameters . elementAt ( indx ) ; if ( parm . isOutput ( ) ) { cstmt . registerOutParameter ( indx + 1 , parm . getType ( ) ) ; } } } } protected void inlineParser ( ) { QueryParameter curParm = null ; int state = 0 ; StringBuffer tok = new StringBuffer ( ) ; boolean firstword = true ; if ( m_Parameters == null ) m_Parameters = new Vector ( ) ; if ( m_ParsedQuery == null ) m_ParsedQuery = new StringBuffer ( ) ; for ( int idx = 0 ; idx < m_OrigQuery . length ( ) ; idx ++ ) { char ch = m_OrigQuery . charAt ( idx ) ; switch ( state ) { case 0 : if ( ch == '\'' ) state = 1 ; else if ( ch == '?' ) state = 4 ; else if ( firstword && ( Character . isLetterOrDigit ( ch ) || ch == '#' ) ) { tok . append ( ch ) ; state = 3 ; } m_ParsedQuery . append ( ch ) ; break ; case 1 : if ( ch == '\'' ) state = 0 ; else if ( ch == '\\' ) state = 2 ; m_ParsedQuery . append ( ch ) ; break ; case 2 : state = 1 ; m_ParsedQuery . append ( ch ) ; break ; case 3 : if ( Character . isLetterOrDigit ( ch ) || ch == '#' || ch == '_' ) tok . append ( ch ) ; else { if ( tok . toString ( ) . equalsIgnoreCase ( "call" ) ) { m_IsCallable = true ; if ( curParm != null ) { curParm . setIsOutput ( true ) ; } } firstword = false ; tok = new StringBuffer ( ) ; if ( ch == '\'' ) state = 1 ; else if ( ch == '?' ) state = 4 ; else state = 0 ; } m_ParsedQuery . append ( ch ) ; break ; case 4 : if ( ch == '[' ) state = 5 ; break ; case 5 : if ( ! Character . isWhitespace ( ch ) && ch != '=' ) { tok . append ( Character . toUpperCase ( ch ) ) ; } else if ( tok . length ( ) > 0 ) { m_HasParameters = true ; curParm = new QueryParameter ( ) ; curParm . setTypeName ( tok . toString ( ) ) ; m_Parameters . addElement ( curParm ) ; tok = new StringBuffer ( ) ; if ( ch == '=' ) state = 7 ; else state = 6 ; } break ; case 6 : if ( ch == '=' ) state = 7 ; break ; case 7 : if ( ! Character . isWhitespace ( ch ) && ch != ']' ) tok . append ( ch ) ; else if ( tok . length ( ) > 0 ) { curParm . setName ( tok . toString ( ) ) ; tok = new StringBuffer ( ) ; if ( ch == ']' ) { state = 0 ; } else state = 8 ; } break ; case 8 : if ( ! Character . isWhitespace ( ch ) && ch != ']' ) { tok . append ( ch ) ; } else if ( tok . length ( ) > 0 ) { tok . setLength ( 3 ) ; if ( tok . toString ( ) . equalsIgnoreCase ( "OUT" ) ) { curParm . setIsOutput ( true ) ; m_hasOutput = true ; } tok = new StringBuffer ( ) ; if ( ch == ']' ) { state = 0 ; } } break ; } } if ( m_IsCallable ) { m_ParsedQuery . insert ( 0 , '{' ) ; m_ParsedQuery . append ( '}' ) ; } } } 	0	['13', '1', '0', '6', '46', '8', '2', '5', '9', '0.716666667', '528', '0.7', '0', '0', '0.221153846', '0', '0', '38.84615385', '35', '4.0769', '0']
package org . apache . xalan . xsltc ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTMAxisIterator ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . apache . xml . serializer . SerializationHandler ; public interface DOM { public final static int FIRST_TYPE = 0 ; public final static int NO_TYPE = - 1 ; public final static int NULL = 0 ; public final static int RETURN_CURRENT = 0 ; public final static int RETURN_PARENT = 1 ; public final static int SIMPLE_RTF = 0 ; public final static int ADAPTIVE_RTF = 1 ; public final static int TREE_RTF = 2 ; public DTMAxisIterator getIterator ( ) ; public String getStringValue ( ) ; public DTMAxisIterator getChildren ( final int node ) ; public DTMAxisIterator getTypedChildren ( final int type ) ; public DTMAxisIterator getAxisIterator ( final int axis ) ; public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) ; public DTMAxisIterator getNthDescendant ( int node , int n , boolean includeself ) ; public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) ; public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iter , int returnType , String value , boolean op ) ; public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) ; public String getNodeName ( final int node ) ; public String getNodeNameX ( final int node ) ; public String getNamespaceName ( final int node ) ; public int getExpandedTypeID ( final int node ) ; public int getNamespaceType ( final int node ) ; public int getParent ( final int node ) ; public int getAttributeNode ( final int gType , final int element ) ; public String getStringValueX ( final int node ) ; public void copy ( final int node , SerializationHandler handler ) throws TransletException ; public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException ; public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException ; public boolean lessThan ( final int node1 , final int node2 ) ; public void characters ( final int textNode , SerializationHandler handler ) throws TransletException ; public Node makeNode ( int index ) ; public Node makeNode ( DTMAxisIterator iter ) ; public NodeList makeNodeList ( int index ) ; public NodeList makeNodeList ( DTMAxisIterator iter ) ; public String getLanguage ( int node ) ; public int getSize ( ) ; public String getDocumentURI ( int node ) ; public void setFilter ( StripFilter filter ) ; public void setupMapping ( String [ ] names , String [ ] urisArray , int [ ] typesArray , String [ ] namespaces ) ; public boolean isElement ( final int node ) ; public boolean isAttribute ( final int node ) ; public String lookupNamespace ( int node , String prefix ) throws TransletException ; public int getNodeIdent ( final int nodehandle ) ; public int getNodeHandle ( final int nodeId ) ; public DOM getResultTreeFrag ( int initialSize , int rtfType ) ; public DOM getResultTreeFrag ( int initialSize , int rtfType , boolean addToDTMManager ) ; public SerializationHandler getOutputDomBuilder ( ) ; public int getNSType ( int node ) ; public int getDocument ( ) ; public String getUnparsedEntityURI ( String name ) ; public Hashtable getElementsWithIDs ( ) ; } 	0	['44', '1', '0', '38', '44', '946', '34', '5', '44', '1.023255814', '52', '0', '0', '0', '0.237373737', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; abstract class RelativeLocationPath extends Expression { public abstract int getAxis ( ) ; public abstract void setAxis ( int axis ) ; } 	0	['3', '3', '2', '4', '4', '3', '3', '1', '2', '2', '6', '0', '0', '0.97260274', '0.666666667', '0', '0', '1', '1', '0.6667', '0']
package org . apache . xpath . functions ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . extensions ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . apache . xml . serializer . NamespaceMappings ; public class DOM2TO implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom ; private SerializationHandler _handler ; public DOM2TO ( Node root , SerializationHandler handler ) { _dom = root ; _handler = handler ; } public ContentHandler getContentHandler ( ) { return null ; } public void setContentHandler ( ContentHandler handler ) { } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _handler . startDocument ( ) ; parse ( _dom ) ; _handler . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : _handler . startCDATA ( ) ; _handler . characters ( node . getNodeValue ( ) ) ; _handler . endCDATA ( ) ; break ; case Node . COMMENT_NODE : _handler . comment ( node . getNodeValue ( ) ) ; break ; case Node . DOCUMENT_NODE : _handler . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endDocument ( ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } break ; case Node . ELEMENT_NODE : final String qname = node . getNodeName ( ) ; _handler . startElement ( null , null , qname ) ; String prefix ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; NamespaceMappings nm = new NamespaceMappings ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int colon ; final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; } else { final String uriAttr = attr . getNamespaceURI ( ) ; if ( uriAttr != null && ! uriAttr . equals ( EMPTYSTRING ) ) { colon = qnameAttr . lastIndexOf ( ':' ) ; String newPrefix = nm . lookupPrefix ( uriAttr ) ; if ( newPrefix == null ) newPrefix = nm . generateNextPrefix ( ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : newPrefix ; _handler . namespaceAfterStartElement ( prefix , uriAttr ) ; _handler . addAttribute ( ( prefix + ":" + qnameAttr ) , attr . getNodeValue ( ) ) ; } else { _handler . addAttribute ( qnameAttr , attr . getNodeValue ( ) ) ; } } } final String uri = node . getNamespaceURI ( ) ; final String localName = node . getLocalName ( ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , uri ) ; } else { if ( uri == null && localName != null ) { prefix = EMPTYSTRING ; _handler . namespaceAfterStartElement ( prefix , EMPTYSTRING ) ; } } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _handler . endElement ( qname ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : _handler . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : _handler . characters ( node . getNodeValue ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	0	['22', '1', '0', '3', '56', '221', '1', '2', '20', '0.964285714', '385', '1', '1', '0', '0.143939394', '0', '0', '16.31818182', '2', '1', '0']
package org . apache . xalan . xslt ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class VariableRefBase extends Expression { protected final VariableBase _variable ; protected Closure _closure = null ; public VariableRefBase ( VariableBase variable ) { _variable = variable ; variable . addReference ( this ) ; } public VariableRefBase ( ) { _variable = null ; } public VariableBase getVariable ( ) { return _variable ; } public VariableBase findParentVariable ( ) { SyntaxTreeNode node = this ; while ( node != null && ! ( node instanceof VariableBase ) ) { node = node . getParent ( ) ; } return ( VariableBase ) node ; } public boolean equals ( Object obj ) { try { return ( _variable == ( ( VariableRefBase ) obj ) . _variable ) ; } catch ( ClassCastException e ) { return false ; } } public String toString ( ) { return "variable-ref(" + _variable . getName ( ) + '/' + _variable . getType ( ) + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) return _type ; if ( _variable . isLocal ( ) ) { SyntaxTreeNode node = getParent ( ) ; do { if ( node instanceof Closure ) { _closure = ( Closure ) node ; break ; } if ( node instanceof TopLevelElement ) { break ; } node = node . getParent ( ) ; } while ( node != null ) ; if ( _closure != null ) { _closure . addVariable ( this ) ; } } VariableBase parent = findParentVariable ( ) ; if ( parent != null ) { VariableBase var = _variable ; if ( _variable . _ignore ) { if ( _variable instanceof Variable ) { var = parent . getSymbolTable ( ) . lookupVariable ( _variable . _name ) ; } else if ( _variable instanceof Param ) { var = parent . getSymbolTable ( ) . lookupParam ( _variable . _name ) ; } } parent . addDependency ( var ) ; } _type = _variable . getType ( ) ; if ( _type == null ) { _variable . typeCheck ( stable ) ; _type = _variable . getType ( ) ; } return _type ; } } 	0	['7', '3', '3', '18', '25', '0', '10', '11', '7', '0.416666667', '175', '1', '2', '0.934210526', '0.357142857', '2', '4', '23.71428571', '3', '1.1429', '0']
package org . apache . xpath ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Node ; public class XPathException extends TransformerException { Object m_styleNode = null ; public Object getStylesheetNode ( ) { return m_styleNode ; } public void setStylesheetNode ( Object styleNode ) { m_styleNode = styleNode ; } protected Exception m_exception ; public XPathException ( String message , ExpressionNode ex ) { super ( message ) ; this . setLocator ( ex ) ; setStylesheetNode ( getStylesheetNode ( ex ) ) ; } public XPathException ( String message ) { super ( message ) ; } public org . w3c . dom . Node getStylesheetNode ( ExpressionNode ex ) { ExpressionNode owner = getExpressionOwner ( ex ) ; if ( null != owner && owner instanceof org . w3c . dom . Node ) { return ( ( org . w3c . dom . Node ) owner ) ; } return null ; } protected ExpressionNode getExpressionOwner ( ExpressionNode ex ) { ExpressionNode parent = ex . exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } public XPathException ( String message , Object styleNode ) { super ( message ) ; m_styleNode = styleNode ; } public XPathException ( String message , Node styleNode , Exception e ) { super ( message ) ; m_styleNode = styleNode ; this . m_exception = e ; } public XPathException ( String message , Exception e ) { super ( message ) ; this . m_exception = e ; } public void printStackTrace ( java . io . PrintStream s ) { if ( s == null ) s = System . err ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; exception . printStackTrace ( s ) ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } } public String getMessage ( ) { String lastMessage = super . getMessage ( ) ; Throwable exception = m_exception ; while ( null != exception ) { String nextMessage = exception . getMessage ( ) ; if ( null != nextMessage ) lastMessage = nextMessage ; if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) break ; } else { exception = null ; } } return ( null != lastMessage ) ? lastMessage : "" ; } public void printStackTrace ( java . io . PrintWriter s ) { if ( s == null ) s = new java . io . PrintWriter ( System . err ) ; try { super . printStackTrace ( s ) ; } catch ( Exception e ) { } Throwable exception = m_exception ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; try { exception . printStackTrace ( s ) ; } catch ( Exception e ) { s . println ( "Could not print stack trace..." ) ; } if ( exception instanceof TransformerException ) { TransformerException se = ( TransformerException ) exception ; Throwable prev = exception ; exception = se . getException ( ) ; if ( prev == exception ) { exception = null ; break ; } } else { exception = null ; } } } public Throwable getException ( ) { return m_exception ; } } 	0	['13', '4', '1', '4', '26', '8', '2', '2', '12', '0.541666667', '257', '0.5', '0', '0.771428571', '0.269230769', '2', '4', '18.61538462', '5', '1.8462', '0']
package org . apache . xml . utils . synthetic ; public class SynthesisException extends Exception { int code ; public static final int SYNTAX = 0 ; public static final int UNSUPPORTED = 1 ; public static final int REIFIED = 2 ; public static final int UNREIFIED = 3 ; public static final int WRONG_OWNER = 4 ; public static final String [ ] errToString = { "(Syntax error; specific message should be passed in)" , "Feature not yet supported" , "Can't change features of 'real' class" , "Can't yet instantiate/invoke without 'real' class" , "Can't add Member to an object other than its declarer" , } ; public SynthesisException ( int code ) { super ( errToString [ code ] ) ; this . code = code ; } public SynthesisException ( int code , String msg ) { super ( msg ) ; this . code = code ; } int getCode ( ) { return code ; } } 	0	['4', '3', '0', '6', '5', '0', '6', '0', '2', '1.095238095', '54', '0', '0', '0.944444444', '0.666666667', '0', '0', '10.75', '1', '0.25', '0']
package org . apache . xalan . xsltc . dom ; public interface Filter { public boolean test ( int node ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . objects ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xpath . res . XPATHErrorResources ; public class XStringForChars extends XString { int m_start ; int m_length ; protected String m_strCache = null ; public XStringForChars ( char [ ] val , int start , int length ) { super ( val ) ; m_start = start ; m_length = length ; if ( null == val ) throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FASTSTRINGBUFFER_CANNOT_BE_NULL , null ) ) ; } private XStringForChars ( String val ) { super ( val ) ; throw new IllegalArgumentException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING , null ) ) ; } public FastStringBuffer fsb ( ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS , null ) ) ; } public void appendToFsb ( org . apache . xml . utils . FastStringBuffer fsb ) { fsb . append ( ( char [ ] ) m_obj , m_start , m_length ) ; } public boolean hasString ( ) { return ( null != m_strCache ) ; } public String str ( ) { if ( null == m_strCache ) m_strCache = new String ( ( char [ ] ) m_obj , m_start , m_length ) ; return m_strCache ; } public Object object ( ) { return str ( ) ; } public void dispatchCharactersEvents ( org . xml . sax . ContentHandler ch ) throws org . xml . sax . SAXException { ch . characters ( ( char [ ] ) m_obj , m_start , m_length ) ; } public void dispatchAsComment ( org . xml . sax . ext . LexicalHandler lh ) throws org . xml . sax . SAXException { lh . comment ( ( char [ ] ) m_obj , m_start , m_length ) ; } public int length ( ) { return m_length ; } public char charAt ( int index ) { return ( ( char [ ] ) m_obj ) [ index + m_start ] ; } public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { System . arraycopy ( ( char [ ] ) m_obj , m_start + srcBegin , dst , dstBegin , srcEnd ) ; } } 	0	['12', '4', '0', '4', '22', '4', '1', '3', '11', '0.484848485', '148', '0.333333333', '0', '0.921875', '0.25', '3', '15', '11.08333333', '2', '1', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . Axis ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . compiler . Compiler ; public class WalkingIteratorSorted extends WalkingIterator { protected boolean m_inNaturalOrderStatic = false ; public WalkingIteratorSorted ( PrefixResolver nscontext ) { super ( nscontext ) ; } WalkingIteratorSorted ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; } public boolean isDocOrdered ( ) { return m_inNaturalOrderStatic ; } boolean canBeWalkedInNaturalDocOrderStatic ( ) { if ( null != m_firstWalker ) { AxesWalker walker = m_firstWalker ; int prevAxis = - 1 ; boolean prevIsSimpleDownAxis = true ; for ( int i = 0 ; null != walker ; i ++ ) { int axis = walker . getAxis ( ) ; if ( walker . isDocOrdered ( ) ) { boolean isSimpleDownAxis = ( ( axis == Axis . CHILD ) || ( axis == Axis . SELF ) || ( axis == Axis . ROOT ) ) ; if ( isSimpleDownAxis || ( axis == - 1 ) ) walker = walker . getNextWalker ( ) ; else { boolean isLastWalker = ( null == walker . getNextWalker ( ) ) ; if ( isLastWalker ) { if ( walker . isDocOrdered ( ) && ( axis == Axis . DESCENDANT || axis == Axis . DESCENDANTORSELF || axis == Axis . DESCENDANTSFROMROOT || axis == Axis . DESCENDANTSORSELFFROMROOT ) || ( axis == Axis . ATTRIBUTE ) ) return true ; } return false ; } } else return false ; } return true ; } return false ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; int analysis = getAnalysisBits ( ) ; if ( WalkerFactory . isNaturalDocOrder ( analysis ) ) { m_inNaturalOrderStatic = true ; } else { m_inNaturalOrderStatic = false ; } } } 	0	['5', '6', '0', '5', '13', '0', '1', '5', '3', '0.25', '129', '1', '0', '0.979020979', '0.366666667', '1', '1', '24.6', '17', '4', '0']
package org . apache . xalan . templates ; public class NamespaceAlias extends ElemTemplateElement { public NamespaceAlias ( int docOrderNumber ) { super ( ) ; m_docOrderNumber = docOrderNumber ; } private String m_StylesheetPrefix ; public void setStylesheetPrefix ( String v ) { m_StylesheetPrefix = v ; } public String getStylesheetPrefix ( ) { return m_StylesheetPrefix ; } private String m_StylesheetNamespace ; public void setStylesheetNamespace ( String v ) { m_StylesheetNamespace = v ; } public String getStylesheetNamespace ( ) { return m_StylesheetNamespace ; } private String m_ResultPrefix ; public void setResultPrefix ( String v ) { m_ResultPrefix = v ; } public String getResultPrefix ( ) { return m_ResultPrefix ; } private String m_ResultNamespace ; public void setResultNamespace ( String v ) { m_ResultNamespace = v ; } public String getResultNamespace ( ) { return m_ResultNamespace ; } public void recompose ( StylesheetRoot root ) { root . recomposeNamespaceAliases ( this ) ; } } 	0	['10', '3', '0', '6', '12', '37', '6', '2', '10', '0.888888889', '52', '1', '0', '0.956097561', '0.4', '1', '1', '3.8', '1', '0.9', '0']
package org . apache . xml . dtm ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class SingletonIterator extends DTMAxisIteratorBase { private int _node ; private final boolean _isConstant ; public SingletonIterator ( ) { this ( Integer . MIN_VALUE , false ) ; } public SingletonIterator ( int node ) { this ( node , false ) ; } public SingletonIterator ( int node , boolean constant ) { _node = _startNode = node ; _isConstant = constant ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else if ( _isRestartable ) { if ( _node <= 0 ) _node = _startNode = node ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { if ( _isConstant ) { _node = _startNode ; return resetPosition ( ) ; } else { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; } return this ; } public int next ( ) { final int result = _node ; _node = DTMAxisIterator . END ; return returnNode ( result ) ; } public void setMark ( ) { _markedNode = _node ; } public void gotoMark ( ) { _node = _markedNode ; } } 	0	['8', '2', '0', '4', '11', '0', '2', '2', '8', '0.214285714', '105', '1', '0', '0.722222222', '0.5', '1', '6', '11.875', '4', '1.125', '0']
package org . apache . xml . dtm ; public interface DTMAxisIterator extends Cloneable { public static final int END = DTM . NULL ; public int next ( ) ; public DTMAxisIterator reset ( ) ; public int getLast ( ) ; public int getPosition ( ) ; public void setMark ( ) ; public void gotoMark ( ) ; public DTMAxisIterator setStartNode ( int node ) ; public int getStartNode ( ) ; public boolean isReverse ( ) ; public DTMAxisIterator cloneIterator ( ) ; public void setRestartable ( boolean isRestartable ) ; public int getNodeByPosition ( int position ) ; } 	0	['12', '1', '0', '83', '12', '66', '83', '0', '12', '1.090909091', '13', '0', '0', '0', '0.416666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . lib . sql ; import java . util . Hashtable ; import java . sql . PreparedStatement ; import java . sql . CallableStatement ; import java . sql . Statement ; public class QueryParameter { private int m_type ; private String m_name ; private String m_value ; private boolean m_output ; private String m_typeName ; private static Hashtable m_Typetable = null ; public QueryParameter ( ) { m_type = - 1 ; m_name = null ; m_value = null ; m_output = false ; m_typeName = null ; } public QueryParameter ( String v , String t ) { m_name = null ; m_value = v ; m_output = false ; setTypeName ( t ) ; } public QueryParameter ( String name , String value , String type , boolean out_flag ) { m_name = name ; m_value = value ; m_output = out_flag ; setTypeName ( type ) ; } public String getValue ( ) { return m_value ; } public void setValue ( String newValue ) { m_value = newValue ; } public void setTypeName ( String newType ) { m_type = map_type ( newType ) ; m_typeName = newType ; } public String getTypeName ( ) { return m_typeName ; } public int getType ( ) { return m_type ; } public String getName ( ) { return m_name ; } public void setName ( String n ) { m_name = n ; } public boolean isOutput ( ) { return m_output ; } public void setIsOutput ( boolean flag ) { m_output = flag ; } private static int map_type ( String typename ) { if ( m_Typetable == null ) { m_Typetable = new Hashtable ( ) ; m_Typetable . put ( "BIGINT" , new Integer ( java . sql . Types . BIGINT ) ) ; m_Typetable . put ( "BINARY" , new Integer ( java . sql . Types . BINARY ) ) ; m_Typetable . put ( "BIT" , new Integer ( java . sql . Types . BIT ) ) ; m_Typetable . put ( "CHAR" , new Integer ( java . sql . Types . CHAR ) ) ; m_Typetable . put ( "DATE" , new Integer ( java . sql . Types . DATE ) ) ; m_Typetable . put ( "DECIMAL" , new Integer ( java . sql . Types . DECIMAL ) ) ; m_Typetable . put ( "DOUBLE" , new Integer ( java . sql . Types . DOUBLE ) ) ; m_Typetable . put ( "FLOAT" , new Integer ( java . sql . Types . FLOAT ) ) ; m_Typetable . put ( "INTEGER" , new Integer ( java . sql . Types . INTEGER ) ) ; m_Typetable . put ( "LONGVARBINARY" , new Integer ( java . sql . Types . LONGVARBINARY ) ) ; m_Typetable . put ( "LONGVARCHAR" , new Integer ( java . sql . Types . LONGVARCHAR ) ) ; m_Typetable . put ( "NULL" , new Integer ( java . sql . Types . NULL ) ) ; m_Typetable . put ( "NUMERIC" , new Integer ( java . sql . Types . NUMERIC ) ) ; m_Typetable . put ( "OTHER" , new Integer ( java . sql . Types . OTHER ) ) ; m_Typetable . put ( "REAL" , new Integer ( java . sql . Types . REAL ) ) ; m_Typetable . put ( "SMALLINT" , new Integer ( java . sql . Types . SMALLINT ) ) ; m_Typetable . put ( "TIME" , new Integer ( java . sql . Types . TIME ) ) ; m_Typetable . put ( "TIMESTAMP" , new Integer ( java . sql . Types . TIMESTAMP ) ) ; m_Typetable . put ( "TINYINT" , new Integer ( java . sql . Types . TINYINT ) ) ; m_Typetable . put ( "VARBINARY" , new Integer ( java . sql . Types . VARBINARY ) ) ; m_Typetable . put ( "VARCHAR" , new Integer ( java . sql . Types . VARCHAR ) ) ; m_Typetable . put ( "STRING" , new Integer ( java . sql . Types . VARCHAR ) ) ; m_Typetable . put ( "BIGDECIMAL" , new Integer ( java . sql . Types . NUMERIC ) ) ; m_Typetable . put ( "BOOLEAN" , new Integer ( java . sql . Types . BIT ) ) ; m_Typetable . put ( "BYTES" , new Integer ( java . sql . Types . LONGVARBINARY ) ) ; m_Typetable . put ( "LONG" , new Integer ( java . sql . Types . BIGINT ) ) ; m_Typetable . put ( "SHORT" , new Integer ( java . sql . Types . SMALLINT ) ) ; } Integer type = ( Integer ) m_Typetable . get ( typename . toUpperCase ( ) ) ; int rtype ; if ( type == null ) rtype = java . sql . Types . OTHER ; else rtype = type . intValue ( ) ; return ( rtype ) ; } } 	0	['14', '1', '0', '3', '21', '31', '3', '0', '12', '0.717948718', '344', '1', '0', '0', '0.512820513', '0', '0', '23.14285714', '3', '0.8571', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class If extends Instruction { private Expression _test ; private boolean _ignore = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "If" ) ; indent ( indent + IndentIncrement ) ; System . out . print ( "test " ) ; Util . println ( _test . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _test = parser . parseExpression ( this , "test" , null ) ; if ( _test . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "test" ) ; return ; } Object result = _test . evaluateAtCompileTime ( ) ; if ( result != null && result instanceof Boolean ) { _ignore = ! ( ( Boolean ) result ) . booleanValue ( ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _test . typeCheck ( stable ) instanceof BooleanType == false ) { _test = new CastExpr ( _test , Type . Boolean ) ; } if ( ! _ignore ) { typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _test . translateDesynthesized ( classGen , methodGen ) ; final InstructionHandle truec = il . getEnd ( ) ; if ( ! _ignore ) { translateContents ( classGen , methodGen ) ; } _test . backPatchFalseList ( il . append ( NOP ) ) ; _test . backPatchTrueList ( truec . getNext ( ) ) ; } } 	0	['5', '3', '0', '17', '28', '0', '3', '15', '4', '0.25', '129', '1', '1', '0.933333333', '0.333333333', '1', '5', '24.4', '5', '1.8', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; public class WhitespaceInfoPaths extends WhiteSpaceInfo { private Vector m_elements ; public void setElements ( Vector elems ) { m_elements = elems ; } Vector getElements ( ) { return m_elements ; } public void clearElements ( ) { m_elements = null ; } public WhitespaceInfoPaths ( Stylesheet thisSheet ) { super ( thisSheet ) ; setStylesheet ( thisSheet ) ; } } 	0	['4', '5', '0', '4', '6', '0', '2', '2', '3', '0.333333333', '23', '1', '0', '0.986486486', '0.5', '0', '0', '4.5', '1', '0.75', '0']
package org . apache . xml . serializer ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '3', '20', '53', '3', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncContains extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String s1 = m_arg0 . execute ( xctxt ) . str ( ) ; String s2 = m_arg1 . execute ( xctxt ) . str ( ) ; if ( s1 . length ( ) == 0 && s2 . length ( ) == 0 ) return XBoolean . S_TRUE ; int index = s1 . indexOf ( s2 ) ; return ( index > - 1 ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '5', '0', '5', '7', '1', '0', '5', '2', '2', '36', '0', '0', '0.98245614', '0.75', '1', '6', '17', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Vector ; public final class MethodType extends Type { private final Type _resultType ; private final Vector _argsType ; public MethodType ( Type resultType ) { _argsType = null ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 ) { if ( arg1 != Type . Void ) { _argsType = new Vector ( ) ; _argsType . addElement ( arg1 ) ; } else { _argsType = null ; } _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 ) { _argsType = new Vector ( 2 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Type arg1 , Type arg2 , Type arg3 ) { _argsType = new Vector ( 3 ) ; _argsType . addElement ( arg1 ) ; _argsType . addElement ( arg2 ) ; _argsType . addElement ( arg3 ) ; _resultType = resultType ; } public MethodType ( Type resultType , Vector argsType ) { _resultType = resultType ; _argsType = argsType . size ( ) > 0 ? argsType : null ; } public String toString ( ) { StringBuffer result = new StringBuffer ( "method{" ) ; if ( _argsType != null ) { final int count = _argsType . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { result . append ( _argsType . elementAt ( i ) ) ; if ( i != ( count - 1 ) ) result . append ( ',' ) ; } } else { result . append ( "void" ) ; } result . append ( '}' ) ; return result . toString ( ) ; } public String toSignature ( ) { return toSignature ( "" ) ; } public String toSignature ( String lastArgSig ) { final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( '(' ) ; if ( _argsType != null ) { final int n = _argsType . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { buffer . append ( ( ( Type ) _argsType . elementAt ( i ) ) . toSignature ( ) ) ; } } return buffer . append ( lastArgSig ) . append ( ')' ) . append ( _resultType . toSignature ( ) ) . toString ( ) ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public boolean identicalTo ( Type other ) { boolean result = false ; if ( other instanceof MethodType ) { final MethodType temp = ( MethodType ) other ; if ( _resultType . identicalTo ( temp . _resultType ) ) { final int len = argsCount ( ) ; result = len == temp . argsCount ( ) ; for ( int i = 0 ; i < len && result ; i ++ ) { final Type arg1 = ( Type ) _argsType . elementAt ( i ) ; final Type arg2 = ( Type ) temp . _argsType . elementAt ( i ) ; result = arg1 . identicalTo ( arg2 ) ; } } } return result ; } public int distanceTo ( Type other ) { int result = Integer . MAX_VALUE ; if ( other instanceof MethodType ) { final MethodType mtype = ( MethodType ) other ; if ( _argsType != null ) { final int len = _argsType . size ( ) ; if ( len == mtype . _argsType . size ( ) ) { result = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Type arg1 = ( Type ) _argsType . elementAt ( i ) ; Type arg2 = ( Type ) mtype . _argsType . elementAt ( i ) ; final int temp = arg1 . distanceTo ( arg2 ) ; if ( temp == Integer . MAX_VALUE ) { result = temp ; break ; } else { result += arg1 . distanceTo ( arg2 ) ; } } } } else if ( mtype . _argsType == null ) { result = 0 ; } } return result ; } public Type resultType ( ) { return _resultType ; } public Vector argsType ( ) { return _argsType ; } public int argsCount ( ) { return _argsType == null ? 0 : _argsType . size ( ) ; } } 	0	['14', '2', '0', '11', '29', '0', '9', '2', '14', '0.269230769', '332', '1', '1', '0.785714286', '0.410714286', '1', '1', '22.57142857', '6', '1.6429', '0']
package org . apache . xalan . templates ; public class Constants extends org . apache . xml . utils . Constants { public static final int ELEMNAME_UNDEFINED = - 1 , ELEMNAME_WITHPARAM = 2 , ELEMNAME_ADDATTRIBUTE = 4 , ELEMNAME_ANCHOR = 22 , ELEMNAME_APPLY_TEMPLATES = 50 , ELEMNAME_USE = 34 , ELEMNAME_CHILDREN = 6 , ELEMNAME_CHOOSE = 37 , ELEMNAME_COMMENT = 59 , ELEMNAME_CONSTRUCT = 7 , ELEMNAME_CONTENTS = 8 , ELEMNAME_COPY = 9 , ELEMNAME_COPY_OF = 74 , ELEMNAME_DECIMALFORMAT = 83 , ELEMNAME_DEFINEATTRIBUTESET = 40 , ELEMNAME_DEFINESCRIPT = 11 , ELEMNAME_DISPLAYIF = 12 , ELEMNAME_EMPTY = 14 , ELEMNAME_EVAL = 15 , ELEMNAME_EXPECTEDCHILDREN = 16 , ELEMNAME_EXTENSION = 54 , ELEMNAME_EXTENSIONHANDLER = 63 , ELEMNAME_FOREACH = 28 , ELEMNAME_KEY = 31 , ELEMNAME_IF = 36 , ELEMNAME_IMPORT = 26 , ELEMNAME_INCLUDE = 27 , ELEMNAME_CALLTEMPLATE = 17 , ELEMNAME_PARAMVARIABLE = 41 , ELEMNAME_NUMBER = 35 , ELEMNAME_NSALIAS = 84 , ELEMNAME_OTHERWISE = 39 , ELEMNAME_PI = 58 , ELEMNAME_PRESERVESPACE = 33 , ELEMNAME_REMOVEATTRIBUTE = 5 , ELEMNAME_TEMPLATE = 19 , ELEMNAME_SORT = 64 , ELEMNAME_STRIPSPACE = 32 , ELEMNAME_STYLESHEET = 25 , ELEMNAME_TEXT = 42 , ELEMNAME_VALUEOF = 30 , ELEMNAME_WHEN = 38 , ELEMNAME_ROOT = 44 , ELEMNAME_ANY = 45 , ELEMNAME_ELEMENT = 46 , ELEMNAME_TARGETELEMENT = 47 , ELEMNAME_ATTRIBUTE = 48 , ELEMNAME_TARGETATTRIBUTE = 49 , ELEMNAME_URL = 52 , ELEMNAME_CALL = 55 , ELEMNAME_FALLBACK = 57 , ELEMNAME_TARGETPI = 60 , ELEMNAME_TARGETCOMMENT = 61 , ELEMNAME_TARGETTEXT = 62 , ELEMNAME_CSSSTYLECONVERSION = 65 , ELEMNAME_COUNTER = 66 , ELEMNAME_COUNTERS = 67 , ELEMNAME_COUNTERINCREMENT = 68 , ELEMNAME_COUNTERRESET = 69 , ELEMNAME_COUNTERSCOPE = 71 , ELEMNAME_APPLY_IMPORTS = 72 , ELEMNAME_VARIABLE = 73 , ELEMNAME_MESSAGE = 75 , ELEMNAME_LOCALE = 76 , ELEMNAME_LITERALRESULT = 77 , ELEMNAME_TEXTLITERALRESULT = 78 , ELEMNAME_EXTENSIONCALL = 79 , ELEMNAME_EXTENSIONDECL = 85 , ELEMNAME_EXTENSIONSCRIPT = 86 , ELEMNAME_OUTPUT = 80 , ELEMNAME_COMPONENT = 81 , ELEMNAME_SCRIPT = 82 ; public static final String ELEMNAME_ANCHOR_STRING = "anchor" , ELEMNAME_ANY_STRING = "any" , ELEMNAME_APPLY_IMPORTS_STRING = "apply-imports" , ELEMNAME_APPLY_TEMPLATES_STRING = "apply-templates" , ELEMNAME_ARG_STRING = "arg" , ELEMNAME_ATTRIBUTESET_STRING = "attribute-set" , ELEMNAME_ATTRIBUTE_STRING = "attribute" , ELEMNAME_CALLTEMPLATEARG_STRING = "invoke-arg" , ELEMNAME_CALLTEMPLATE_STRING = "call-template" , ELEMNAME_CALL_STRING = "call" , ELEMNAME_CHILDREN_STRING = "children" , ELEMNAME_CHOOSE_STRING = "choose" , ELEMNAME_COMMENT_STRING = "comment" , ELEMNAME_COMPONENT_STRING = "component" , ELEMNAME_CONSTRUCT_STRING = "construct" , ELEMNAME_CONTENTS_STRING = "contents" , ELEMNAME_COPY_OF_STRING = "copy-of" , ELEMNAME_COPY_STRING = "copy" , ELEMNAME_COUNTERINCREMENT_STRING = "counter-increment" , ELEMNAME_COUNTERRESET_STRING = "counter-reset" , ELEMNAME_COUNTERSCOPE_STRING = "counter-scope" , ELEMNAME_COUNTERS_STRING = "counters" , ELEMNAME_COUNTER_STRING = "counter" , ELEMNAME_CSSSTYLECONVERSION_STRING = "css-style-conversion" , ELEMNAME_DECIMALFORMAT_STRING = "decimal-format" , ELEMNAME_DISPLAYIF_STRING = "display-if" , ELEMNAME_ELEMENT_STRING = "element" , ELEMNAME_EMPTY_STRING = "empty" , ELEMNAME_EVAL_STRING = "eval" , ELEMNAME_EXPECTEDCHILDREN_STRING = "expectedchildren" , ELEMNAME_EXTENSIONHANDLER_STRING = "code-dispatcher" , ELEMNAME_EXTENSION_STRING = "functions" , ELEMNAME_FALLBACK_STRING = "fallback" , ELEMNAME_FOREACH_STRING = "for-each" , ELEMNAME_IF_STRING = "if" , ELEMNAME_IMPORT_STRING = "import" , ELEMNAME_INCLUDE_STRING = "include" , ELEMNAME_KEY_STRING = "key" , ELEMNAME_LOCALE_STRING = "locale" , ELEMNAME_MESSAGE_STRING = "message" , ELEMNAME_NSALIAS_STRING = "namespace-alias" , ELEMNAME_NUMBER_STRING = "number" , ELEMNAME_OTHERWISE_STRING = "otherwise" , ELEMNAME_OUTPUT_STRING = "output" , ELEMNAME_PARAMVARIABLE_STRING = "param" , ELEMNAME_PI_OLD_STRING = "pi" , ELEMNAME_PI_STRING = "processing-instruction" , ELEMNAME_PRESERVESPACE_STRING = "preserve-space" , ELEMNAME_ROOT_STRING = "root" , ELEMNAME_SCRIPT_STRING = "script" , ELEMNAME_SORT_STRING = "sort" , ELEMNAME_STRIPSPACE_STRING = "strip-space" , ELEMNAME_STYLESHEET_STRING = "stylesheet" , ELEMNAME_TARGETATTRIBUTE_STRING = "target-attribute" , ELEMNAME_TARGETCOMMENT_STRING = "target-comment" , ELEMNAME_TARGETELEMENT_STRING = "target-element" , ELEMNAME_TARGETPI_STRING = "target-pi" , ELEMNAME_TARGETTEXT_STRING = "target-text" , ELEMNAME_TEMPLATE_STRING = "template" , ELEMNAME_TEXT_STRING = "text" , ELEMNAME_TRANSFORM_STRING = "transform" , ELEMNAME_URL_STRING = "uri" , ELEMNAME_USE_STRING = "use" , ELEMNAME_VALUEOF_STRING = "value-of" , ELEMNAME_VARIABLE_STRING = "variable" , ELEMNAME_WHEN_STRING = "when" , ELEMNAME_WITHPARAM_STRING = "with-param" ; public static final String EXSLT_ELEMNAME_FUNCTION_STRING = "function" , EXSLT_ELEMNAME_FUNCRESULT_STRING = "result" ; public static final int EXSLT_ELEMNAME_FUNCTION = 88 , EXSLT_ELEMNAME_FUNCRESULT = 89 ; public static final String ATTRNAME_AMOUNT = "amount" , ATTRNAME_ANCESTOR = "ancestor" , ATTRNAME_ARCHIVE = "archive" , ATTRNAME_ATTRIBUTE = "attribute" , ATTRNAME_ATTRIBUTE_SET = "attribute-set" , ATTRNAME_CASEORDER = "case-order" , ATTRNAME_CLASS = "class" , ATTRNAME_CLASSID = "classid" , ATTRNAME_CODEBASE = "codebase" , ATTRNAME_CODETYPE = "type" , ATTRNAME_CONDITION = "condition" , ATTRNAME_COPYTYPE = "copy-type" , ATTRNAME_COUNT = "count" , ATTRNAME_DATATYPE = "data-type" , ATTRNAME_DECIMALSEPARATOR = "decimal-separator" , ATTRNAME_DEFAULT = "default" , ATTRNAME_DEFAULTSPACE = "default-space" , ATTRNAME_DEPTH = "with-children" , ATTRNAME_DIGIT = "digit" , ATTRNAME_DIGITGROUPSEP = "digit-group-sep" , ATTRNAME_DISABLE_OUTPUT_ESCAPING = "disable-output-escaping" , ATTRNAME_ELEMENT = "element" , ATTRNAME_ELEMENTS = "elements" , ATTRNAME_EXCLUDE_RESULT_PREFIXES = "exclude-result-prefixes" , ATTRNAME_EXPR = "expr" , ATTRNAME_EXTENSIONELEMENTPREFIXES = "extension-element-prefixes" , ATTRNAME_FORMAT = "format" , ATTRNAME_FROM = "from" , ATTRNAME_GROUPINGSEPARATOR = "grouping-separator" , ATTRNAME_GROUPINGSIZE = "grouping-size" , ATTRNAME_HREF = "href" , ATTRNAME_ID = "id" , ATTRNAME_IMPORTANCE = "importance" , ATTRNAME_INDENTRESULT = "indent-result" , ATTRNAME_INFINITY = "infinity" , ATTRNAME_LANG = "lang" , ATTRNAME_LETTERVALUE = "letter-value" , ATTRNAME_LEVEL = "level" , ATTRNAME_MATCH = "match" , ATTRNAME_METHOD = "calls" , ATTRNAME_MINUSSIGN = "minus-sign" , ATTRNAME_MODE = "mode" , ATTRNAME_NAME = "name" , ATTRNAME_NAMESPACE = "namespace" , ATTRNAME_NAN = "NaN" , ATTRNAME_NDIGITSPERGROUP = "n-digits-per-group" , ATTRNAME_NS = "ns" , ATTRNAME_ONLY = "only" , ATTRNAME_ORDER = "order" , ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = "cdata-section-elements" , ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = "doctype-public" , ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = "doctype-system" , ATTRNAME_OUTPUT_ENCODING = "encoding" , ATTRNAME_OUTPUT_INDENT = "indent" , ATTRNAME_OUTPUT_MEDIATYPE = "media-type" , ATTRNAME_OUTPUT_METHOD = "method" , ATTRNAME_OUTPUT_OMITXMLDECL = "omit-xml-declaration" , ATTRNAME_OUTPUT_STANDALONE = "standalone" , ATTRNAME_OUTPUT_VERSION = "version" , ATTRNAME_PATTERNSEPARATOR = "pattern-separator" , ATTRNAME_PERCENT = "percent" , ATTRNAME_PERMILLE = "per-mille" , ATTRNAME_PRIORITY = "priority" , ATTRNAME_REFID = "refID" , ATTRNAME_RESULTNS = "result-ns" , ATTRNAME_RESULT_PREFIX = "result-prefix" , ATTRNAME_SELECT = "select" , ATTRNAME_SEQUENCESRC = "sequence-src" , ATTRNAME_STYLE = "style" , ATTRNAME_STYLESHEET_PREFIX = "stylesheet-prefix" , ATTRNAME_TERMINATE = "terminate" , ATTRNAME_TEST = "test" , ATTRNAME_TOSTRING = "to-string" , ATTRNAME_TYPE = "type" , ATTRNAME_USE = "use" , ATTRNAME_USEATTRIBUTESETS = "use-attribute-sets" , ATTRNAME_VALUE = "value" , ATTRNAME_VERSION = "version" , ATTRNAME_XMLNS = "xmlns:" , ATTRNAME_XMLNSDEF = "xmlns" , ATTRNAME_XMLSPACE = "xml:space" , ATTRNAME_ZERODIGIT = "zero-digit" ; public static final int TATTRNAME_OUTPUT_METHOD = 1 , TATTRNAME_AMOUNT = 2 , TATTRNAME_ANCESTOR = 3 , TATTRNAME_ARCHIVE = 4 , TATTRNAME_ATTRIBUTE = 5 , TATTRNAME_ATTRIBUTE_SET = 6 , TATTRNAME_CASEORDER = 7 , TATTRNAME_CLASS = 8 , TATTRNAME_CLASSID = 9 , TATTRNAME_CODEBASE = 10 , TATTRNAME_CODETYPE = 11 , TATTRNAME_CONDITION = 12 , TATTRNAME_COPYTYPE = 13 , TATTRNAME_COUNT = 14 , TATTRNAME_DATATYPE = 15 , TATTRNAME_DEFAULT = 16 , TATTRNAME_DEFAULTSPACE = 17 , TATTRNAME_DEPTH = 18 , TATTRNAME_DIGITGROUPSEP = 19 , TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20 , TATTRNAME_ELEMENT = 21 , TATTRNAME_ELEMENTS = 22 , TATTRNAME_EXPR = 23 , TATTRNAME_EXTENSIONELEMENTPREFIXES = 24 , TATTRNAME_FORMAT = 25 , TATTRNAME_FROM = 26 , TATTRNAME_GROUPINGSEPARATOR = 27 , TATTRNAME_GROUPINGSIZE = 28 , TATTRNAME_HREF = 29 , TATTRNAME_ID = 30 , TATTRNAME_IMPORTANCE = 31 , TATTRNAME_INDENTRESULT = 32 , TATTRNAME_LANG = 33 , TATTRNAME_LETTERVALUE = 34 , TATTRNAME_LEVEL = 35 , TATTRNAME_MATCH = 36 , TATTRNAME_METHOD = 37 , TATTRNAME_MODE = 38 , TATTRNAME_NAME = 39 , TATTRNAME_NAMESPACE = 40 , TATTRNAME_NDIGITSPERGROUP = 41 , TATTRNAME_NS = 42 , TATTRNAME_ONLY = 43 , TATTRNAME_ORDER = 44 , TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45 , TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46 , TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47 , TATTRNAME_OUTPUT_ENCODING = 48 , TATTRNAME_OUTPUT_INDENT = 49 , TATTRNAME_OUTPUT_MEDIATYPE = 50 , TATTRNAME_OUTPUT_STANDALONE = 51 , TATTRNAME_OUTPUT_VERSION = 52 , TATTRNAME_OUTPUT_OMITXMLDECL = 53 , TATTRNAME_PRIORITY = 54 , TATTRNAME_REFID = 55 , TATTRNAME_RESULTNS = 56 , TATTRNAME_SELECT = 57 , TATTRNAME_SEQUENCESRC = 58 , TATTRNAME_STYLE = 59 , TATTRNAME_TEST = 60 , TATTRNAME_TOSTRING = 61 , TATTRNAME_TYPE = 62 , TATTRNAME_USE = 63 , TATTRNAME_USEATTRIBUTESETS = 64 , TATTRNAME_VALUE = 65 , TATTRNAME_XMLNSDEF = 66 , TATTRNAME_XMLNS = 67 , TATTRNAME_XMLSPACE = 68 , TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69 ; public static final String ATTRVAL_OUTPUT_METHOD_HTML = "html" , ATTRVAL_OUTPUT_METHOD_XML = "xml" , ATTRVAL_OUTPUT_METHOD_TEXT = "text" ; public static final int ATTRVAL_PRESERVE = 1 , ATTRVAL_STRIP = 2 ; public static final boolean ATTRVAL_YES = true , ATTRVAL_NO = false ; public static final String ATTRVAL_ALPHABETIC = "alphabetic" , ATTRVAL_OTHER = "other" , ATTRVAL_TRADITIONAL = "traditional" ; public static final String ATTRVAL_SINGLE = "single" , ATTRVAL_MULTI = "multiple" , ATTRVAL_ANY = "any" ; public static final String ATTRVAL_DEFAULT_PREFIX = "#default" ; public static final int NUMBERLETTER_ALPHABETIC = 1 , NUMBERLETTER_TRADITIONAL = 2 ; public static final int NUMBERLEVEL_SINGLE = 1 , NUMBERLEVEL_MULTI = 2 , NUMBERLEVEL_ANY = 3 , MAX_MULTI_COUNTING_DEPTH = 32 ; public static final String ATTRVAL_THIS = "." , ATTRVAL_PARENT = ".." , ATTRVAL_ANCESTOR = "ancestor" , ATTRVAL_ID = "id" ; public static final String ATTRVAL_DATATYPE_TEXT = "text" , ATTRVAL_DATATYPE_NUMBER = "number" , ATTRVAL_ORDER_ASCENDING = "ascending" , ATTRVAL_ORDER_DESCENDING = "descending" , ATTRVAL_CASEORDER_UPPER = "upper-first" , ATTRVAL_CASEORDER_LOWER = "lower-first" ; public static final int SORTDATATYPE_TEXT = 1 , SORTDATATYPE_NUMBER = 2 ; public static final int SORTORDER_ASCENDING = 1 , SORTORDER_DESCENDING = 2 ; public static final int SORTCASEORDER_UPPERFIRST = 1 , SORTCASEORDER_LOWERFIRST = 2 ; public static final String ATTRVAL_INFINITY = "Infinity" , ATTRVAL_NAN = "NaN" , DEFAULT_DECIMAL_FORMAT = "#default" ; public static final String ATTRNAME_XXXX = "XXXX" ; } 	0	['1', '2', '0', '1', '2', '0', '0', '1', '1', '2', '338', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ForEach extends Instruction { private Expression _select ; private Type _type ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ForEach" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; parseChildren ( parser ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType || _type instanceof NodeType ) { _select = new CastExpr ( _select , Type . NodeSet ) ; typeCheckContents ( stable ) ; return Type . Void ; } if ( _type instanceof NodeSetType || _type instanceof ResultTreeType ) { typeCheckContents ( stable ) ; return Type . Void ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; final Vector sortObjects = new Vector ( ) ; Enumeration children = elements ( ) ; while ( children . hasMoreElements ( ) ) { final Object child = children . nextElement ( ) ; if ( child instanceof Sort ) { sortObjects . addElement ( child ) ; } } if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . loadDOM ( ) ) ; if ( sortObjects . size ( ) > 0 ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . RESULT_TREE_SORT_ERR , this ) ; getParser ( ) . reportError ( WARNING , msg ) ; } _select . translate ( classGen , methodGen ) ; _type . translateTo ( classGen , methodGen , Type . NodeSet ) ; il . append ( SWAP ) ; il . append ( methodGen . storeDOM ( ) ) ; } else { if ( sortObjects . size ( ) > 0 ) { Sort . translateSortIterator ( classGen , methodGen , _select , sortObjects ) ; } else { _select . translate ( classGen , methodGen ) ; } if ( _type instanceof ReferenceType == false ) { il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; } } il . append ( methodGen . storeIterator ( ) ) ; initializeVariables ( classGen , methodGen ) ; final BranchHandle nextNode = il . append ( new GOTO ( null ) ) ; final InstructionHandle loop = il . append ( NOP ) ; translateContents ( classGen , methodGen ) ; nextNode . setTarget ( il . append ( methodGen . loadIterator ( ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; il . append ( DUP ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; il . append ( new IFGT ( loop ) ) ; if ( ( _type != null ) && ( _type instanceof ResultTreeType ) ) { il . append ( methodGen . storeDOM ( ) ) ; } il . append ( methodGen . storeIterator ( ) ) ; il . append ( methodGen . storeCurrentNode ( ) ) ; } public void initializeVariables ( ClassGenerator classGen , MethodGenerator methodGen ) { final int n = elementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Object child = getContents ( ) . elementAt ( i ) ; if ( child instanceof Variable ) { Variable var = ( Variable ) child ; var . initialize ( classGen , methodGen ) ; } } } } 	0	['6', '3', '0', '28', '55', '3', '2', '27', '5', '0.6', '318', '1', '2', '0.918032787', '0.361111111', '1', '6', '51.66666667', '9', '2.6667', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xpath . XPathContext ; public class ReverseAxesWalker extends AxesWalker { ReverseAxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator , axis ) ; } public void setRoot ( int root ) { super . setRoot ( root ) ; m_iterator = getDTM ( root ) . getAxisIterator ( m_axis ) ; m_iterator . setStartNode ( root ) ; } public void detach ( ) { m_iterator = null ; super . detach ( ) ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next = m_iterator . next ( ) ; if ( m_isFresh ) m_isFresh = false ; if ( DTM . NULL == next ) this . m_foundLast = true ; return next ; } public boolean isReverseAxes ( ) { return true ; } protected int getProximityPosition ( int predicateIndex ) { if ( predicateIndex < 0 ) return - 1 ; int count = m_proximityPositions [ predicateIndex ] ; if ( count <= 0 ) { AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( predicateIndex ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; count ++ ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } m_proximityPositions [ predicateIndex ] = count ; } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } } return count ; } protected void countProximityPosition ( int i ) { if ( i < m_proximityPositions . length ) m_proximityPositions [ i ] -- ; } public int getLastPos ( XPathContext xctxt ) { int count = 0 ; AxesWalker savedWalker = wi ( ) . getLastUsedWalker ( ) ; try { ReverseAxesWalker clone = ( ReverseAxesWalker ) this . clone ( ) ; clone . setRoot ( this . getRoot ( ) ) ; clone . setPredicateCount ( this . getPredicateCount ( ) - 1 ) ; clone . setPrevWalker ( null ) ; clone . setNextWalker ( null ) ; wi ( ) . setLastUsedWalker ( clone ) ; int next ; while ( DTM . NULL != ( next = clone . nextNode ( ) ) ) { count ++ ; } } catch ( CloneNotSupportedException cnse ) { } finally { wi ( ) . setLastUsedWalker ( savedWalker ) ; } return count ; } public boolean isDocOrdered ( ) { return false ; } protected DTMAxisIterator m_iterator ; } 	0	['9', '5', '0', '7', '26', '28', '1', '6', '5', '0.5', '207', '1', '1', '0.927927928', '0.416666667', '2', '8', '21.88888889', '4', '1.7778', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xpath . compiler . Compiler ; public abstract class BasicTestIterator extends LocPathIterator { protected BasicTestIterator ( ) { } protected BasicTestIterator ( PrefixResolver nscontext ) { super ( nscontext ) ; } protected BasicTestIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; int firstStepPos = compiler . getFirstChildPos ( opPos ) ; int whatToShow = compiler . getWhatToShow ( firstStepPos ) ; if ( ( 0 == ( whatToShow & ( DTMFilter . SHOW_ATTRIBUTE | DTMFilter . SHOW_NAMESPACE | DTMFilter . SHOW_ELEMENT | DTMFilter . SHOW_PROCESSING_INSTRUCTION ) ) ) || ( whatToShow == DTMFilter . SHOW_ALL ) ) initNodeTest ( whatToShow ) ; else { initNodeTest ( whatToShow , compiler . getStepNS ( firstStepPos ) , compiler . getStepLocalName ( firstStepPos ) ) ; } initPredicateInfo ( compiler , firstStepPos ) ; } protected BasicTestIterator ( Compiler compiler , int opPos , int analysis , boolean shouldLoadWalkers ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , shouldLoadWalkers ) ; } protected abstract int getNextNode ( ) ; public int nextNode ( ) { if ( m_foundLast ) { m_lastFetched = DTM . NULL ; return DTM . NULL ; } if ( DTM . NULL == m_lastFetched ) { resetProximityPositions ( ) ; } int next ; org . apache . xpath . VariableStack vars ; int savedStart ; if ( - 1 != m_stackFrame ) { vars = m_execContext . getVarStack ( ) ; savedStart = vars . getStackFrame ( ) ; vars . setStackFrame ( m_stackFrame ) ; } else { vars = null ; savedStart = 0 ; } try { do { next = getNextNode ( ) ; if ( DTM . NULL != next ) { if ( DTMIterator . FILTER_ACCEPT == acceptNode ( next ) ) break ; else continue ; } else break ; } while ( next != DTM . NULL ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } finally { if ( - 1 != m_stackFrame ) { vars . setStackFrame ( savedStart ) ; } } } public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException { ChildTestIterator clone = ( ChildTestIterator ) super . cloneWithReset ( ) ; clone . resetProximityPositions ( ) ; return clone ; } } 	0	['7', '5', '2', '8', '24', '21', '2', '7', '2', '2', '163', '0', '0', '0.9765625', '0.371428571', '2', '4', '22.28571429', '11', '1.8571', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class UnsupportedElement extends SyntaxTreeNode { private Vector _fallbacks = null ; private ErrorMsg _message = null ; private boolean _isExtension = false ; public UnsupportedElement ( String uri , String prefix , String local , boolean isExtension ) { super ( uri , prefix , local ) ; _isExtension = isExtension ; } public void setErrorMessage ( ErrorMsg message ) { _message = message ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Unsupported element = " + _qname . getNamespace ( ) + ":" + _qname . getLocalPart ( ) ) ; displayContents ( indent + IndentIncrement ) ; } private void processFallbacks ( Parser parser ) { Vector children = getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; if ( child instanceof Fallback ) { Fallback fallback = ( Fallback ) child ; fallback . activate ( ) ; fallback . parseContents ( parser ) ; if ( _fallbacks == null ) { _fallbacks = new Vector ( ) ; } _fallbacks . addElement ( child ) ; } } } } public void parseContents ( Parser parser ) { processFallbacks ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _fallbacks != null ) { int count = _fallbacks . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Fallback fallback = ( Fallback ) _fallbacks . elementAt ( i ) ; fallback . typeCheck ( stable ) ; } } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _fallbacks != null ) { int count = _fallbacks . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Fallback fallback = ( Fallback ) _fallbacks . elementAt ( i ) ; fallback . translate ( classGen , methodGen ) ; } } else { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; final int unsupportedElem = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "unsupported_ElementF" , "(" + STRING_SIG + "Z)V" ) ; il . append ( new PUSH ( cpg , getQName ( ) . toString ( ) ) ) ; il . append ( new PUSH ( cpg , _isExtension ) ) ; il . append ( new INVOKESTATIC ( unsupportedElem ) ) ; } } } 	0	['7', '2', '0', '18', '35', '7', '1', '18', '6', '0.666666667', '196', '1', '1', '0.9', '0.253968254', '1', '5', '26.57142857', '5', '1.5714', '0']
package org . apache . xalan . xsltc . compiler ; public interface Closure { public boolean inInnerClass ( ) ; public Closure getParentClosure ( ) ; public String getInnerClassName ( ) ; public void addVariable ( VariableRefBase variableRef ) ; } 	0	['4', '1', '0', '6', '4', '6', '6', '1', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; public abstract class Hashtree2Node { public static void appendHashToNode ( Hashtable hash , String name , Node container , Document factory ) { if ( ( null == container ) || ( null == factory ) || ( null == hash ) ) { return ; } String elemName = null ; if ( ( null == name ) || ( "" . equals ( name ) ) ) elemName = "appendHashToNode" ; else elemName = name ; try { Element hashNode = factory . createElement ( elemName ) ; container . appendChild ( hashNode ) ; Enumeration keys = hash . keys ( ) ; Vector v = new Vector ( ) ; while ( keys . hasMoreElements ( ) ) { Object key = keys . nextElement ( ) ; String keyStr = key . toString ( ) ; Object item = hash . get ( key ) ; if ( item instanceof Hashtable ) { v . addElement ( keyStr ) ; v . addElement ( ( Hashtable ) item ) ; } else { try { Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( ( String ) item ) ) ; hashNode . appendChild ( node ) ; } catch ( Exception e ) { Element node = factory . createElement ( "item" ) ; node . setAttribute ( "key" , keyStr ) ; node . appendChild ( factory . createTextNode ( "ERROR: Reading " + key + " threw: " + e . toString ( ) ) ) ; hashNode . appendChild ( node ) ; } } } keys = v . elements ( ) ; while ( keys . hasMoreElements ( ) ) { String n = ( String ) keys . nextElement ( ) ; Hashtable h = ( Hashtable ) keys . nextElement ( ) ; appendHashToNode ( h , n , hashNode , factory ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } } 	0	['2', '1', '0', '1', '23', '1', '1', '0', '2', '2', '145', '0', '0', '0', '0.5', '0', '0', '71.5', '8', '4', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTMAxisIterator ; public interface CurrentNodeListFilter { public abstract boolean test ( int node , int position , int last , int current , AbstractTranslet translet , DTMAxisIterator iter ) ; } 	0	['1', '1', '0', '3', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Minus extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) - m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . Type ; public final class MatchGenerator extends MethodGenerator { private static int CURRENT_INDEX = 1 ; private int _iteratorIndex = INVALID_INDEX ; private final Instruction _iloadCurrent ; private final Instruction _istoreCurrent ; private Instruction _aloadDom ; public MatchGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_INDEX ) ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public Instruction loadDOM ( ) { return _aloadDom ; } public void setDomIndex ( int domIndex ) { _aloadDom = new ALOAD ( domIndex ) ; } public int getIteratorIndex ( ) { return _iteratorIndex ; } public void setIteratorIndex ( int iteratorIndex ) { _iteratorIndex = iteratorIndex ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	0	['10', '5', '0', '9', '16', '27', '1', '8', '9', '0.844444444', '79', '1', '0', '0.945205479', '0.263888889', '2', '5', '6.4', '2', '0.9', '0']
package org . apache . xpath . compiler ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . ObjectVector ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . res . XPATHErrorResources ; public class OpMap { protected String m_currentPattern ; public String toString ( ) { return m_currentPattern ; } public String getPatternString ( ) { return m_currentPattern ; } static final int MAXTOKENQUEUESIZE = 500 ; static final int BLOCKTOKENQUEUESIZE = 500 ; ObjectVector m_tokenQueue = new ObjectVector ( MAXTOKENQUEUESIZE , BLOCKTOKENQUEUESIZE ) ; public ObjectVector getTokenQueue ( ) { return m_tokenQueue ; } public Object getToken ( int pos ) { return m_tokenQueue . elementAt ( pos ) ; } public int getTokenQueueSize ( ) { return m_tokenQueue . size ( ) ; } OpMapVector m_opMap = null ; public OpMapVector getOpMap ( ) { return m_opMap ; } public static final int MAPINDEX_LENGTH = 1 ; void shrink ( ) { int n = m_opMap . elementAt ( MAPINDEX_LENGTH ) ; m_opMap . setToSize ( n + 4 ) ; m_opMap . setElementAt ( 0 , n ) ; m_opMap . setElementAt ( 0 , n + 1 ) ; m_opMap . setElementAt ( 0 , n + 2 ) ; n = m_tokenQueue . size ( ) ; m_tokenQueue . setToSize ( n + 4 ) ; m_tokenQueue . setElementAt ( null , n ) ; m_tokenQueue . setElementAt ( null , n + 1 ) ; m_tokenQueue . setElementAt ( null , n + 2 ) ; } public int getOp ( int opPos ) { return m_opMap . elementAt ( opPos ) ; } public void setOp ( int opPos , int value ) { m_opMap . setElementAt ( value , opPos ) ; } public int getNextOpPos ( int opPos ) { return opPos + m_opMap . elementAt ( opPos + 1 ) ; } public int getNextStepPos ( int opPos ) { int stepType = getOp ( opPos ) ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return getNextOpPos ( opPos ) ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { int newOpPos = getNextOpPos ( opPos ) ; while ( OpCodes . OP_PREDICATE == getOp ( newOpPos ) ) { newOpPos = getNextOpPos ( newOpPos ) ; } stepType = getOp ( newOpPos ) ; if ( ! ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) ) { return OpCodes . ENDOP ; } return newOpPos ; } else { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_UNKNOWN_STEP , new Object [ ] { new Integer ( stepType ) . toString ( ) } ) ) ; } } public static int getNextOpPos ( int [ ] opMap , int opPos ) { return opPos + opMap [ opPos + 1 ] ; } public int getFirstPredicateOpPos ( int opPos ) throws javax . xml . transform . TransformerException { int stepType = m_opMap . elementAt ( opPos ) ; if ( ( stepType >= OpCodes . AXES_START_TYPES ) && ( stepType <= OpCodes . AXES_END_TYPES ) ) { return opPos + m_opMap . elementAt ( opPos + 2 ) ; } else if ( ( stepType >= OpCodes . FIRST_NODESET_OP ) && ( stepType <= OpCodes . LAST_NODESET_OP ) ) { return opPos + m_opMap . elementAt ( opPos + 1 ) ; } else if ( - 2 == stepType ) { return - 2 ; } else { error ( org . apache . xpath . res . XPATHErrorResources . ER_UNKNOWN_OPCODE , new Object [ ] { String . valueOf ( stepType ) } ) ; return - 1 ; } } public void error ( String msg , Object [ ] args ) throws javax . xml . transform . TransformerException { java . lang . String fmsg = org . apache . xalan . res . XSLMessages . createXPATHMessage ( msg , args ) ; throw new javax . xml . transform . TransformerException ( fmsg ) ; } public static int getFirstChildPos ( int opPos ) { return opPos + 2 ; } public int getArgLength ( int opPos ) { return m_opMap . elementAt ( opPos + MAPINDEX_LENGTH ) ; } public int getArgLengthOfStep ( int opPos ) { return m_opMap . elementAt ( opPos + MAPINDEX_LENGTH + 1 ) - 3 ; } public static int getFirstChildPosOfStep ( int opPos ) { return opPos + 3 ; } public int getStepTestType ( int opPosOfStep ) { return m_opMap . elementAt ( opPosOfStep + 3 ) ; } public String getStepNS ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; if ( argLenOfStep == 3 ) { int index = m_opMap . elementAt ( opPosOfStep + 4 ) ; if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } else return null ; } public String getStepLocalName ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; int index ; switch ( argLenOfStep ) { case 0 : index = OpCodes . EMPTY ; break ; case 1 : index = OpCodes . ELEMWILDCARD ; break ; case 2 : index = m_opMap . elementAt ( opPosOfStep + 4 ) ; break ; case 3 : index = m_opMap . elementAt ( opPosOfStep + 5 ) ; break ; default : index = OpCodes . EMPTY ; break ; } if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) . toString ( ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } } 	0	['22', '1', '1', '5', '38', '67', '2', '3', '21', '0.873015873', '384', '0.166666667', '2', '0', '0.327272727', '0', '0', '16.18181818', '8', '1.5455', '0']
package org . apache . xml . dtm ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xml . utils ; public class StopParseException extends org . xml . sax . SAXException { StopParseException ( ) { super ( "Stylesheet PIs found, stop the parse" ) ; } } 	0	['1', '4', '0', '3', '2', '0', '3', '0', '0', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Enumeration ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; final class Import extends TopLevelElement { private Stylesheet _imported = null ; public Stylesheet getImportedStylesheet ( ) { return _imported ; } public void parseContents ( final Parser parser ) { final XSLTC xsltc = parser . getXSLTC ( ) ; final Stylesheet context = parser . getCurrentStylesheet ( ) ; try { String docToLoad = getAttribute ( "href" ) ; if ( context . checkForLoop ( docToLoad ) ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CIRCULAR_INCLUDE_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } InputSource input = null ; XMLReader reader = null ; String currLoadedDoc = context . getSystemId ( ) ; SourceLoader loader = context . getSourceLoader ( ) ; if ( loader != null ) { input = loader . loadSource ( docToLoad , currLoadedDoc , xsltc ) ; if ( input != null ) { docToLoad = input . getSystemId ( ) ; reader = xsltc . getXMLReader ( ) ; } } if ( input == null ) { docToLoad = SystemIDResolver . getAbsoluteURI ( docToLoad , currLoadedDoc ) ; input = new InputSource ( docToLoad ) ; } if ( input == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } final SyntaxTreeNode root ; if ( reader != null ) { root = parser . parse ( reader , input ) ; } else { root = parser . parse ( input ) ; } if ( root == null ) return ; _imported = parser . makeStylesheet ( root ) ; if ( _imported == null ) return ; _imported . setSourceLoader ( loader ) ; _imported . setSystemId ( docToLoad ) ; _imported . setParentStylesheet ( context ) ; _imported . setImportingStylesheet ( context ) ; final int currPrecedence = parser . getCurrentImportPrecedence ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _imported . setImportPrecedence ( currPrecedence ) ; context . setImportPrecedence ( nextPrecedence ) ; parser . setCurrentStylesheet ( _imported ) ; _imported . parseContents ( parser ) ; final Enumeration elements = _imported . elements ( ) ; final Stylesheet topStylesheet = parser . getTopLevelStylesheet ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof TopLevelElement ) { if ( element instanceof Variable ) { topStylesheet . addVariable ( ( Variable ) element ) ; } else if ( element instanceof Param ) { topStylesheet . addParam ( ( Param ) element ) ; } else { topStylesheet . addElement ( ( TopLevelElement ) element ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { parser . setCurrentStylesheet ( context ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['5', '3', '0', '15', '39', '4', '0', '15', '4', '0.5', '225', '1', '1', '0.9375', '0.36', '2', '5', '43.8', '12', '3', '0']
package org . apache . xml . dtm ; public interface DTMWSFilter { public static final short NOTSTRIP = 1 ; public static final short STRIP = 2 ; public static final short INHERIT = 3 ; public short getShouldStripSpace ( int elementHandle , DTM dtm ) ; } 	0	['1', '1', '0', '27', '1', '0', '26', '1', '1', '2', '4', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import java . util . Vector ; import org . apache . xalan . templates . Stylesheet ; import org . apache . xalan . templates . WhiteSpaceInfo ; import org . apache . xpath . XPath ; import org . xml . sax . Attributes ; class ProcessorStripSpace extends ProcessorPreserveSpace { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { Stylesheet thisSheet = handler . getStylesheet ( ) ; WhitespaceInfoPaths paths = new WhitespaceInfoPaths ( thisSheet ) ; setPropertiesFromAttributes ( handler , rawName , attributes , paths ) ; Vector xpaths = paths . getElements ( ) ; for ( int i = 0 ; i < xpaths . size ( ) ; i ++ ) { WhiteSpaceInfo wsi = new WhiteSpaceInfo ( ( XPath ) xpaths . elementAt ( i ) , true , thisSheet ) ; wsi . setUid ( handler . nextUid ( ) ) ; thisSheet . setStripSpaces ( wsi ) ; } paths . clearElements ( ) ; } } 	0	['2', '5', '0', '8', '14', '1', '1', '7', '1', '2', '50', '0', '0', '0.995283019', '0.625', '2', '2', '24', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . FileNotFoundException ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; final class Include extends TopLevelElement { private Stylesheet _included = null ; public Stylesheet getIncludedStylesheet ( ) { return _included ; } public void parseContents ( final Parser parser ) { XSLTC xsltc = parser . getXSLTC ( ) ; Stylesheet context = parser . getCurrentStylesheet ( ) ; String docToLoad = getAttribute ( "href" ) ; try { if ( context . checkForLoop ( docToLoad ) ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . CIRCULAR_INCLUDE_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } InputSource input = null ; XMLReader reader = null ; String currLoadedDoc = context . getSystemId ( ) ; SourceLoader loader = context . getSourceLoader ( ) ; if ( loader != null ) { input = loader . loadSource ( docToLoad , currLoadedDoc , xsltc ) ; if ( input != null ) { docToLoad = input . getSystemId ( ) ; reader = xsltc . getXMLReader ( ) ; } } if ( input == null ) { docToLoad = SystemIDResolver . getAbsoluteURI ( docToLoad , currLoadedDoc ) ; input = new InputSource ( docToLoad ) ; } if ( input == null ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . FILE_NOT_FOUND_ERR , docToLoad , this ) ; parser . reportError ( Constants . FATAL , msg ) ; return ; } final SyntaxTreeNode root ; if ( reader != null ) { root = parser . parse ( reader , input ) ; } else { root = parser . parse ( input ) ; } if ( root == null ) return ; _included = parser . makeStylesheet ( root ) ; if ( _included == null ) return ; _included . setSourceLoader ( loader ) ; _included . setSystemId ( docToLoad ) ; _included . setParentStylesheet ( context ) ; _included . setIncludingStylesheet ( context ) ; _included . setTemplateInlining ( context . getTemplateInlining ( ) ) ; final int precedence = context . getImportPrecedence ( ) ; _included . setImportPrecedence ( precedence ) ; parser . setCurrentStylesheet ( _included ) ; _included . parseContents ( parser ) ; final Enumeration elements = _included . elements ( ) ; final Stylesheet topStylesheet = parser . getTopLevelStylesheet ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof TopLevelElement ) { if ( element instanceof Variable ) { topStylesheet . addVariable ( ( Variable ) element ) ; } else if ( element instanceof Param ) { topStylesheet . addParam ( ( Param ) element ) ; } else { topStylesheet . addElement ( ( TopLevelElement ) element ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { parser . setCurrentStylesheet ( context ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { } } 	0	['5', '3', '0', '15', '40', '4', '1', '15', '4', '0.5', '224', '1', '1', '0.9375', '0.36', '2', '5', '43.6', '12', '3', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . SQLException ; public class PooledConnection { private Connection connection = null ; private boolean inuse = false ; public PooledConnection ( Connection value ) { if ( value != null ) { connection = value ; } } public Connection getConnection ( ) { return connection ; } public void setInUse ( boolean value ) { inuse = value ; } public boolean inUse ( ) { return inuse ; } public void close ( ) { try { connection . close ( ) ; } catch ( SQLException sqle ) { System . err . println ( sqle . getMessage ( ) ) ; } } } 	0	['5', '1', '0', '1', '9', '0', '1', '0', '5', '0.5', '41', '1', '0', '0', '0.466666667', '0', '0', '6.8', '1', '0.8', '0']
package org . apache . xalan . transformer ; public class ResultNameSpace { public ResultNameSpace m_next = null ; public String m_prefix ; public String m_uri ; public ResultNameSpace ( String prefix , String uri ) { m_prefix = prefix ; m_uri = uri ; } } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '16', '0', '1', '0', '1', '0', '0', '12', '0', '0', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Gte extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . greaterThanOrEqual ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTM ; public final class EmptyIterator implements DTMAxisIterator { private static final EmptyIterator INSTANCE = new EmptyIterator ( ) ; public static DTMAxisIterator getInstance ( ) { return INSTANCE ; } private EmptyIterator ( ) { } public final int next ( ) { return END ; } public final DTMAxisIterator reset ( ) { return this ; } public final int getLast ( ) { return 0 ; } public final int getPosition ( ) { return 1 ; } public final void setMark ( ) { } public final void gotoMark ( ) { } public final DTMAxisIterator setStartNode ( int node ) { return this ; } public final int getStartNode ( ) { return END ; } public final boolean isReverse ( ) { return false ; } public final DTMAxisIterator cloneIterator ( ) { return this ; } public final void setRestartable ( boolean isRestartable ) { } public final int getNodeByPosition ( int position ) { return END ; } } 	0	['15', '1', '0', '3', '16', '103', '2', '1', '13', '0.928571429', '47', '1', '1', '0', '0.380952381', '0', '0', '2.066666667', '1', '0.8667', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . operations . Variable ; public class VarNameCollector extends XPathVisitor { Vector m_refs = new Vector ( ) ; public void reset ( ) { m_refs . removeAllElements ( ) ; } public int getVarCount ( ) { return m_refs . size ( ) ; } boolean doesOccur ( QName refName ) { return m_refs . contains ( refName ) ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { m_refs . addElement ( var . getQName ( ) ) ; return true ; } } 	0	['5', '2', '0', '5', '12', '0', '1', '4', '4', '0', '34', '0', '0', '0.75', '0.4', '0', '0', '5.6', '1', '0.8', '0']
package org . apache . xml . utils ; import java . io . Serializable ; import org . xml . sax . Attributes ; import org . xml . sax . helpers . AttributesImpl ; public class MutableAttrListImpl extends AttributesImpl implements Serializable { public MutableAttrListImpl ( ) { super ( ) ; } public MutableAttrListImpl ( Attributes atts ) { super ( atts ) ; } public void addAttribute ( String uri , String localName , String qName , String type , String value ) { if ( null == uri ) uri = "" ; int index = this . getIndex ( qName ) ; if ( index >= 0 ) this . setAttribute ( index , uri , localName , qName , type , value ) ; else super . addAttribute ( uri , localName , qName , type , value ) ; } public void addAttributes ( Attributes atts ) { int nAtts = atts . getLength ( ) ; for ( int i = 0 ; i < nAtts ; i ++ ) { String uri = atts . getURI ( i ) ; if ( null == uri ) uri = "" ; String localName = atts . getLocalName ( i ) ; String qname = atts . getQName ( i ) ; int index = this . getIndex ( uri , localName ) ; if ( index >= 0 ) this . setAttribute ( index , uri , localName , qname , atts . getType ( i ) , atts . getValue ( i ) ) ; else addAttribute ( uri , localName , qname , atts . getType ( i ) , atts . getValue ( i ) ) ; } } public boolean contains ( String name ) { return getValue ( name ) != null ; } } 	0	['5', '2', '0', '1', '18', '10', '1', '0', '5', '2', '107', '0', '0', '0.888888889', '0.6', '1', '2', '20.4', '4', '1.8', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class ClonedNodeListIterator extends DTMAxisIteratorBase { private CachedNodeListIterator _source ; private int _index = 0 ; public ClonedNodeListIterator ( CachedNodeListIterator source ) { _source = source ; } public void setRestartable ( boolean isRestartable ) { } public DTMAxisIterator setStartNode ( int node ) { return this ; } public int next ( ) { return _source . getNode ( _index ++ ) ; } public int getPosition ( ) { return _index == 0 ? 1 : _index ; } public int getNodeByPosition ( int pos ) { return _source . getNode ( pos ) ; } public DTMAxisIterator cloneIterator ( ) { return _source . cloneIterator ( ) ; } public DTMAxisIterator reset ( ) { _index = 0 ; return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['10', '2', '0', '3', '15', '5', '1', '3', '10', '0.555555556', '65', '1', '1', '0.590909091', '0.35', '1', '6', '5.3', '2', '1', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . Axis ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . OneStepIterator ; public class XObjectFactory { static public XObject create ( Object val ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Double ) { result = new XNumber ( ( ( Double ) val ) ) ; } else { result = new XObject ( val ) ; } return result ; } static public XObject create ( Object val , XPathContext xctxt ) { XObject result ; if ( val instanceof XObject ) { result = ( XObject ) val ; } else if ( val instanceof String ) { result = new XString ( ( String ) val ) ; } else if ( val instanceof Boolean ) { result = new XBoolean ( ( Boolean ) val ) ; } else if ( val instanceof Number ) { result = new XNumber ( ( ( Number ) val ) ) ; } else if ( val instanceof DTM ) { DTM dtm = ( DTM ) val ; try { int dtmRoot = dtm . getDocument ( ) ; DTMAxisIterator iter = dtm . getAxisIterator ( Axis . SELF ) ; iter . setStartNode ( dtmRoot ) ; DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( dtmRoot , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) val ; try { DTMIterator iterator = new OneStepIterator ( iter , Axis . SELF ) ; iterator . setRoot ( iter . getStartNode ( ) , xctxt ) ; result = new XNodeSet ( iterator ) ; } catch ( Exception ex ) { throw new org . apache . xml . utils . WrappedRuntimeException ( ex ) ; } } else if ( val instanceof DTMIterator ) { result = new XNodeSet ( ( DTMIterator ) val ) ; } else if ( val instanceof org . w3c . dom . Node ) { result = new XNodeSetForDOM ( ( org . w3c . dom . Node ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . NodeList ) { result = new XNodeSetForDOM ( ( org . w3c . dom . NodeList ) val , xctxt ) ; } else if ( val instanceof org . w3c . dom . traversal . NodeIterator ) { result = new XNodeSetForDOM ( ( org . w3c . dom . traversal . NodeIterator ) val , xctxt ) ; } else { result = new XObject ( val ) ; } return result ; } } 	0	['3', '1', '0', '13', '19', '3', '1', '13', '3', '2', '207', '0', '0', '0', '0.444444444', '0', '0', '68', '11', '5.3333', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Number extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { if ( XObject . CLASS_NUMBER == right . getType ( ) ) return right ; else return new XNumber ( right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_right . num ( xctxt ) ; } } 	0	['3', '3', '0', '7', '8', '3', '2', '5', '3', '2', '23', '0', '0', '0.952380952', '0.555555556', '1', '1', '6.666666667', '1', '0.6667', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mult extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) * right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) * m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xml . utils . MutableAttrListImpl ; public abstract class QueuedEvents { protected int m_eventCount = 0 ; public boolean m_docPending = false ; protected boolean m_docEnded = false ; public boolean m_elemIsPending = false ; public boolean m_elemIsEnded = false ; protected MutableAttrListImpl m_attributes = new MutableAttrListImpl ( ) ; protected boolean m_nsDeclsHaveBeenAdded = false ; protected String m_name ; protected String m_url ; protected String m_localName ; protected Vector m_namespaces = null ; protected void reInitEvents ( ) { } public void reset ( ) { pushDocumentEvent ( ) ; reInitEvents ( ) ; } void pushDocumentEvent ( ) { m_docPending = true ; m_eventCount ++ ; } void popEvent ( ) { m_elemIsPending = false ; m_attributes . clear ( ) ; m_nsDeclsHaveBeenAdded = false ; m_name = null ; m_url = null ; m_localName = null ; m_namespaces = null ; m_eventCount -- ; } private org . apache . xml . serializer . Serializer m_serializer ; void setSerializer ( org . apache . xml . serializer . Serializer s ) { m_serializer = s ; } org . apache . xml . serializer . Serializer getSerializer ( ) { return m_serializer ; } } 	0	['7', '1', '0', '2', '10', '13', '0', '2', '2', '0.861111111', '99', '0.75', '2', '0', '0.571428571', '0', '0', '11.42857143', '1', '0.8571', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . xml . sax . ContentHandler ; public class FuncNormalizeSpace extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = getArg0AsString ( xctxt ) ; return ( XString ) s1 . fixWhiteSpace ( true , true , false ) ; } public void executeCharsToContentHandler ( XPathContext xctxt , ContentHandler handler ) throws javax . xml . transform . TransformerException , org . xml . sax . SAXException { if ( Arg0IsNodesetExpr ( ) ) { int node = getArg0AsNode ( xctxt ) ; if ( DTM . NULL != node ) { DTM dtm = xctxt . getDTM ( node ) ; dtm . dispatchCharactersEvents ( node , handler , true ) ; } } else { XObject obj = execute ( xctxt ) ; obj . dispatchCharactersEvents ( handler ) ; } } } 	0	['3', '5', '0', '6', '11', '3', '0', '6', '3', '2', '45', '0', '0', '0.964912281', '0.666666667', '2', '7', '14', '1', '0.6667', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class NthIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final int _position ; private boolean _ready ; public NthIterator ( DTMAxisIterator source , int n ) { _source = source ; _position = n ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final NthIterator clone = ( NthIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { if ( _ready ) { _ready = false ; return _source . getNodeByPosition ( _position ) ; } return DTMAxisIterator . END ; } public DTMAxisIterator setStartNode ( final int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _ready = true ; } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; _ready = true ; return this ; } public int getLast ( ) { return 1 ; } public int getPosition ( ) { return 1 ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['10', '2', '0', '3', '21', '0', '0', '3', '10', '0.62962963', '99', '1', '1', '0.590909091', '0.35', '1', '7', '8.6', '2', '1.1', '0']
package org . apache . xalan . templates ; import java . util . Vector ; import javax . xml . transform . TransformerException ; public class StylesheetComposed extends Stylesheet { public StylesheetComposed ( Stylesheet parent ) { super ( parent ) ; } public boolean isAggregatedType ( ) { return true ; } public void recompose ( Vector recomposableElements ) throws TransformerException { int n = getIncludeCountComposed ( ) ; for ( int i = - 1 ; i < n ; i ++ ) { Stylesheet included = getIncludeComposed ( i ) ; int s = included . getOutputCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getOutput ( j ) ) ; } s = included . getAttributeSetCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getAttributeSet ( j ) ) ; } s = included . getDecimalFormatCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getDecimalFormat ( j ) ) ; } s = included . getKeyCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getKey ( j ) ) ; } s = included . getNamespaceAliasCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getNamespaceAlias ( j ) ) ; } s = included . getTemplateCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getTemplate ( j ) ) ; } s = included . getVariableOrParamCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getVariableOrParam ( j ) ) ; } s = included . getStripSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getStripSpace ( j ) ) ; } s = included . getPreserveSpaceCount ( ) ; for ( int j = 0 ; j < s ; j ++ ) { recomposableElements . addElement ( included . getPreserveSpace ( j ) ) ; } } } private int m_importNumber = - 1 ; private int m_importCountComposed ; private int m_endImportCountComposed ; void recomposeImports ( ) { m_importNumber = getStylesheetRoot ( ) . getImportNumber ( this ) ; StylesheetRoot root = getStylesheetRoot ( ) ; int globalImportCount = root . getGlobalImportCount ( ) ; m_importCountComposed = ( globalImportCount - m_importNumber ) - 1 ; int count = getImportCount ( ) ; if ( count > 0 ) { m_endImportCountComposed += count ; while ( count > 0 ) m_endImportCountComposed += this . getImport ( -- count ) . getEndImportCountComposed ( ) ; } count = getIncludeCountComposed ( ) ; while ( count > 0 ) { int imports = getIncludeComposed ( -- count ) . getImportCount ( ) ; m_endImportCountComposed += imports ; while ( imports > 0 ) m_endImportCountComposed += getIncludeComposed ( count ) . getImport ( -- imports ) . getEndImportCountComposed ( ) ; } } public StylesheetComposed getImportComposed ( int i ) throws ArrayIndexOutOfBoundsException { StylesheetRoot root = getStylesheetRoot ( ) ; return root . getGlobalImport ( 1 + m_importNumber + i ) ; } public int getImportCountComposed ( ) { return m_importCountComposed ; } public int getEndImportCountComposed ( ) { return m_endImportCountComposed ; } private transient Vector m_includesComposed ; void recomposeIncludes ( Stylesheet including ) { int n = including . getIncludeCount ( ) ; if ( n > 0 ) { if ( null == m_includesComposed ) m_includesComposed = new Vector ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Stylesheet included = including . getInclude ( i ) ; m_includesComposed . addElement ( included ) ; recomposeIncludes ( included ) ; } } } public Stylesheet getIncludeComposed ( int i ) throws ArrayIndexOutOfBoundsException { if ( - 1 == i ) return this ; if ( null == m_includesComposed ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( Stylesheet ) m_includesComposed . elementAt ( i ) ; } public int getIncludeCountComposed ( ) { return ( null != m_includesComposed ) ? m_includesComposed . size ( ) : 0 ; } public void recomposeTemplates ( boolean flushFirst ) throws TransformerException { } } 	0	['11', '4', '1', '16', '45', '39', '9', '10', '9', '0.8', '333', '1', '0', '0.964285714', '0.309090909', '1', '2', '28.90909091', '4', '1.5455', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class And extends Operation { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject expr1 = m_left . execute ( xctxt ) ; if ( expr1 . bool ( ) ) { XObject expr2 = m_right . execute ( xctxt ) ; return expr2 . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } else return XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . bool ( xctxt ) && m_right . bool ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '1', '1', '5', '3', '2', '42', '0', '0', '0.953488372', '0.833333333', '1', '6', '13', '1', '0.6667', '0']
package org . apache . xalan . extensions ; import java . util . Vector ; import org . apache . xalan . templates . Constants ; public class ExtensionNamespacesManager { private Vector m_extensions = new Vector ( ) ; private Vector m_predefExtensions = new Vector ( 7 ) ; private Vector m_unregisteredExtensions = new Vector ( ) ; public ExtensionNamespacesManager ( ) { setPredefinedNamespaces ( ) ; } public void registerExtension ( String namespace ) { if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { int predef = namespaceIndex ( namespace , m_predefExtensions ) ; if ( predef != - 1 ) m_extensions . addElement ( m_predefExtensions . elementAt ( predef ) ) ; else if ( ! ( m_unregisteredExtensions . contains ( namespace ) ) ) m_unregisteredExtensions . addElement ( namespace ) ; } } public void registerExtension ( ExtensionNamespaceSupport extNsSpt ) { String namespace = extNsSpt . getNamespace ( ) ; if ( namespaceIndex ( namespace , m_extensions ) == - 1 ) { m_extensions . addElement ( extNsSpt ) ; if ( m_unregisteredExtensions . contains ( namespace ) ) m_unregisteredExtensions . removeElement ( namespace ) ; } } public int namespaceIndex ( String namespace , Vector extensions ) { for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { if ( ( ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ) . getNamespace ( ) . equals ( namespace ) ) return i ; } return - 1 ; } public Vector getExtensions ( ) { return m_extensions ; } public void registerUnregisteredNamespaces ( ) { for ( int i = 0 ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . elementAt ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . addElement ( extNsSpt ) ; } } public ExtensionNamespaceSupport defineJavaNamespace ( String ns ) { return defineJavaNamespace ( ns , ns ) ; } public ExtensionNamespaceSupport defineJavaNamespace ( String ns , String classOrPackage ) { if ( null == ns || ns . trim ( ) . length ( ) == 0 ) return null ; String className = classOrPackage ; if ( className . startsWith ( "class:" ) ) className = className . substring ( 6 ) ; int lastSlash = className . lastIndexOf ( "/" ) ; if ( - 1 != lastSlash ) className = className . substring ( lastSlash + 1 ) ; if ( null == className || className . trim ( ) . length ( ) == 0 ) return null ; try { ExtensionHandler . getClassForName ( className ) ; return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaClass" , new Object [ ] { ns , "javaclass" , className } ) ; } catch ( ClassNotFoundException e ) { return new ExtensionNamespaceSupport ( ns , "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" , new Object [ ] { ns , "javapackage" , className + "." } ) ; } } private void setPredefinedNamespaces ( ) { String uri = Constants . S_EXTENSIONS_JAVA_URL ; String handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaPackage" ; String lang = "javapackage" ; String lib = "" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_OLD_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_LOTUSXSL_JAVA_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_BUILTIN_EXTENSIONS_URL ; handlerClassName = "org.apache.xalan.extensions.ExtensionHandlerJavaClass" ; lang = "javaclass" ; lib = "org.apache.xalan.lib.Extensions" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_BUILTIN_OLD_EXTENSIONS_URL ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_REDIRECT_URL ; lib = "org.apache.xalan.lib.Redirect" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_PIPE_URL ; lib = "org.apache.xalan.lib.PipeDocument" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXTENSIONS_SQL_URL ; lib = "org.apache.xalan.lib.sql.XConnection" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_COMMON_URL ; lib = "org.apache.xalan.lib.ExsltCommon" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_MATH_URL ; lib = "org.apache.xalan.lib.ExsltMath" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_SETS_URL ; lib = "org.apache.xalan.lib.ExsltSets" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DATETIME_URL ; lib = "org.apache.xalan.lib.ExsltDatetime" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_DYNAMIC_URL ; lib = "org.apache.xalan.lib.ExsltDynamic" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; uri = Constants . S_EXSLT_STRINGS_URL ; lib = "org.apache.xalan.lib.ExsltStrings" ; m_predefExtensions . addElement ( new ExtensionNamespaceSupport ( uri , handlerClassName , new Object [ ] { uri , lang , lib } ) ) ; } } 	0	['9', '1', '0', '7', '29', '12', '5', '2', '8', '0.625', '605', '1', '0', '0', '0.416666667', '0', '0', '65.88888889', '7', '2.5556', '0']
package org . apache . xalan . xsltc . dom ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; public interface ExtendedSAX extends ContentHandler , LexicalHandler , DTDHandler , DeclHandler { } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . processor ; import java . util . Hashtable ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemApplyImport ; import org . apache . xalan . templates . ElemApplyTemplates ; import org . apache . xalan . templates . ElemAttribute ; import org . apache . xalan . templates . ElemCallTemplate ; import org . apache . xalan . templates . ElemChoose ; import org . apache . xalan . templates . ElemComment ; import org . apache . xalan . templates . ElemCopy ; import org . apache . xalan . templates . ElemCopyOf ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemExtensionDecl ; import org . apache . xalan . templates . ElemExtensionScript ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemForEach ; import org . apache . xalan . templates . ElemIf ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemMessage ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xalan . templates . ElemOtherwise ; import org . apache . xalan . templates . ElemPI ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemSort ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemUnknown ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . ElemWhen ; import org . apache . xalan . templates . ElemWithParam ; import org . apache . xml . utils . QName ; public class XSLTSchema extends XSLTElementDef { XSLTSchema ( ) { build ( ) ; } void build ( ) { XSLTAttributeDef hrefAttr = new XSLTAttributeDef ( null , "href" , XSLTAttributeDef . T_URL , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef elementsAttr = new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_SIMPLEPATTERNLIST , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef methodAttr = new XSLTAttributeDef ( null , "method" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef versionAttr = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef encodingAttr = new XSLTAttributeDef ( null , "encoding" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef omitXmlDeclarationAttr = new XSLTAttributeDef ( null , "omit-xml-declaration" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef standaloneAttr = new XSLTAttributeDef ( null , "standalone" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypePublicAttr = new XSLTAttributeDef ( null , "doctype-public" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef doctypeSystemAttr = new XSLTAttributeDef ( null , "doctype-system" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef cdataSectionElementsAttr = new XSLTAttributeDef ( null , "cdata-section-elements" , XSLTAttributeDef . T_QNAMES_RESOLVE_NULL , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef indentAttr = new XSLTAttributeDef ( null , "indent" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef mediaTypeAttr = new XSLTAttributeDef ( null , "media-type" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAttrRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef nameAVTRequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_AVT_QNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAVT_NCNAMERequired = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_NCNAME , true , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef nameAttrOpt_ERROR = new XSLTAttributeDef ( null , "name" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef useAttr = new XSLTAttributeDef ( null , "use" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef namespaceAVTOpt = new XSLTAttributeDef ( null , "namespace" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef decimalSeparatorAttr = new XSLTAttributeDef ( null , "decimal-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef infinityAttr = new XSLTAttributeDef ( null , "infinity" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "Infinity" ) ; XSLTAttributeDef minusSignAttr = new XSLTAttributeDef ( null , "minus-sign" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "-" ) ; XSLTAttributeDef NaNAttr = new XSLTAttributeDef ( null , "NaN" , XSLTAttributeDef . T_CDATA , false , XSLTAttributeDef . ERROR , "NaN" ) ; XSLTAttributeDef percentAttr = new XSLTAttributeDef ( null , "percent" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "%" ) ; XSLTAttributeDef perMilleAttr = new XSLTAttributeDef ( null , "per-mille" , XSLTAttributeDef . T_CHAR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef zeroDigitAttr = new XSLTAttributeDef ( null , "zero-digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "0" ) ; XSLTAttributeDef digitAttr = new XSLTAttributeDef ( null , "digit" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "#" ) ; XSLTAttributeDef patternSeparatorAttr = new XSLTAttributeDef ( null , "pattern-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , ";" ) ; XSLTAttributeDef groupingSeparatorAttr = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , XSLTAttributeDef . ERROR , "," ) ; XSLTAttributeDef useAttributeSetsAttr = new XSLTAttributeDef ( null , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef testAttrRequired = new XSLTAttributeDef ( null , "test" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrRequired = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrOpt = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef selectAttrDefNode = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "node()" ) ; XSLTAttributeDef selectAttrDefDot = new XSLTAttributeDef ( null , "select" , XSLTAttributeDef . T_EXPR , false , XSLTAttributeDef . ERROR , "." ) ; XSLTAttributeDef matchAttrRequired = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef matchAttrOpt = new XSLTAttributeDef ( null , "match" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef priorityAttr = new XSLTAttributeDef ( null , "priority" , XSLTAttributeDef . T_NUMBER , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef modeAttr = new XSLTAttributeDef ( null , "mode" , XSLTAttributeDef . T_QNAME , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef spaceAttr = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , false , false , false , XSLTAttributeDef . WARNING , "default" , Constants . ATTRVAL_STRIP , "preserve" , Constants . ATTRVAL_PRESERVE ) ; XSLTAttributeDef spaceAttrLiteral = new XSLTAttributeDef ( Constants . S_XMLNAMESPACEURI , "space" , XSLTAttributeDef . T_URL , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef stylesheetPrefixAttr = new XSLTAttributeDef ( null , "stylesheet-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef resultPrefixAttr = new XSLTAttributeDef ( null , "result-prefix" , XSLTAttributeDef . T_CDATA , true , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef disableOutputEscapingAttr = new XSLTAttributeDef ( null , "disable-output-escaping" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef levelAttr = new XSLTAttributeDef ( null , "level" , false , false , false , XSLTAttributeDef . ERROR , "single" , Constants . NUMBERLEVEL_SINGLE , "multiple" , Constants . NUMBERLEVEL_MULTI , "any" , Constants . NUMBERLEVEL_ANY ) ; levelAttr . setDefault ( "single" ) ; XSLTAttributeDef countAttr = new XSLTAttributeDef ( null , "count" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef fromAttr = new XSLTAttributeDef ( null , "from" , XSLTAttributeDef . T_PATTERN , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef valueAttr = new XSLTAttributeDef ( null , "value" , XSLTAttributeDef . T_EXPR , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef formatAttr = new XSLTAttributeDef ( null , "format" , XSLTAttributeDef . T_CDATA , false , true , XSLTAttributeDef . ERROR ) ; formatAttr . setDefault ( "1" ) ; XSLTAttributeDef langAttr = new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef letterValueAttr = new XSLTAttributeDef ( null , "letter-value" , false , true , false , XSLTAttributeDef . ERROR , "alphabetic" , Constants . NUMBERLETTER_ALPHABETIC , "traditional" , Constants . NUMBERLETTER_TRADITIONAL ) ; XSLTAttributeDef groupingSeparatorAVT = new XSLTAttributeDef ( null , "grouping-separator" , XSLTAttributeDef . T_CHAR , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef groupingSizeAttr = new XSLTAttributeDef ( null , "grouping-size" , XSLTAttributeDef . T_NUMBER , false , true , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef dataTypeAttr = new XSLTAttributeDef ( null , "data-type" , false , true , true , XSLTAttributeDef . ERROR , "text" , Constants . SORTDATATYPE_TEXT , "number" , Constants . SORTDATATYPE_TEXT ) ; dataTypeAttr . setDefault ( "text" ) ; XSLTAttributeDef orderAttr = new XSLTAttributeDef ( null , "order" , false , true , false , XSLTAttributeDef . ERROR , "ascending" , Constants . SORTORDER_ASCENDING , "descending" , Constants . SORTORDER_DESCENDING ) ; orderAttr . setDefault ( "ascending" ) ; XSLTAttributeDef caseOrderAttr = new XSLTAttributeDef ( null , "case-order" , false , true , false , XSLTAttributeDef . ERROR , "upper-first" , Constants . SORTCASEORDER_UPPERFIRST , "lower-first" , Constants . SORTCASEORDER_LOWERFIRST ) ; XSLTAttributeDef terminateAttr = new XSLTAttributeDef ( null , "terminate" , XSLTAttributeDef . T_YESNO , false , false , XSLTAttributeDef . ERROR ) ; terminateAttr . setDefault ( "no" ) ; XSLTAttributeDef xslExcludeResultPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "exclude-result-prefixes" , XSLTAttributeDef . T_PREFIXLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslExtensionElementPrefixesAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslUseAttributeSetsAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "use-attribute-sets" , XSLTAttributeDef . T_QNAMES , false , false , XSLTAttributeDef . ERROR ) ; XSLTAttributeDef xslVersionAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "version" , XSLTAttributeDef . T_NMTOKEN , false , false , XSLTAttributeDef . ERROR ) ; XSLTElementDef charData = new XSLTElementDef ( this , null , "text()" , null , null , null , new ProcessorCharacters ( ) , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTElementDef whiteSpaceOnly = new XSLTElementDef ( this , null , "text()" , null , null , null , null , ElemTextLiteral . class ) ; charData . setType ( XSLTElementDef . T_PCDATA ) ; XSLTAttributeDef resultAttr = new XSLTAttributeDef ( null , "*" , XSLTAttributeDef . T_AVT , false , true , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef xslResultAttr = new XSLTAttributeDef ( Constants . S_XSLNAMESPACEURL , "*" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef [ ] templateElements = new XSLTElementDef [ 23 ] ; XSLTElementDef [ ] templateElementsAndParams = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] templateElementsAndSort = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] exsltFunctionElements = new XSLTElementDef [ 24 ] ; XSLTElementDef [ ] charTemplateElements = new XSLTElementDef [ 15 ] ; XSLTElementDef resultElement = new XSLTElementDef ( this , null , "*" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttrLiteral , xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorLRE ( ) , ElemLiteralResult . class , 20 , true ) ; XSLTElementDef unknownElement = new XSLTElementDef ( this , "*" , "unknown" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { xslExcludeResultPrefixesAttr , xslExtensionElementPrefixesAttr , xslUseAttributeSetsAttr , xslVersionAttr , xslResultAttr , resultAttr } , new ProcessorUnknown ( ) , ElemUnknown . class , 20 , true ) ; XSLTElementDef xslValueOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "value-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired , disableOutputEscapingAttr } , new ProcessorTemplateElem ( ) , ElemValueOf . class , 20 , true ) ; XSLTElementDef xslCopyOf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy-of" , null , null , new XSLTAttributeDef [ ] { selectAttrRequired } , new ProcessorTemplateElem ( ) , ElemCopyOf . class , 20 , true ) ; XSLTElementDef xslNumber = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "number" , null , null , new XSLTAttributeDef [ ] { levelAttr , countAttr , fromAttr , valueAttr , formatAttr , langAttr , letterValueAttr , groupingSeparatorAVT , groupingSizeAttr } , new ProcessorTemplateElem ( ) , ElemNumber . class , 20 , true ) ; XSLTElementDef xslSort = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "sort" , null , null , new XSLTAttributeDef [ ] { selectAttrDefDot , langAttr , dataTypeAttr , orderAttr , caseOrderAttr } , new ProcessorTemplateElem ( ) , ElemSort . class , 19 , true ) ; XSLTElementDef xslWithParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "with-param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemWithParam . class , 19 , true ) ; XSLTElementDef xslApplyTemplates = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-templates" , null , new XSLTElementDef [ ] { xslSort , xslWithParam } , new XSLTAttributeDef [ ] { selectAttrDefNode , modeAttr } , new ProcessorTemplateElem ( ) , ElemApplyTemplates . class , 20 , true ) ; XSLTElementDef xslApplyImports = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "apply-imports" , null , null , new XSLTAttributeDef [ ] { } , new ProcessorTemplateElem ( ) , ElemApplyImport . class ) ; XSLTElementDef xslForEach = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "for-each" , null , templateElementsAndSort , new XSLTAttributeDef [ ] { selectAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemForEach . class , true , false , true , 20 , true ) ; XSLTElementDef xslIf = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "if" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemIf . class , 20 , true ) ; XSLTElementDef xslWhen = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "when" , null , templateElements , new XSLTAttributeDef [ ] { testAttrRequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemWhen . class , false , true , 1 , true ) ; XSLTElementDef xslOtherwise = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "otherwise" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemOtherwise . class , false , false , 2 , false ) ; XSLTElementDef xslChoose = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "choose" , null , new XSLTElementDef [ ] { xslWhen , xslOtherwise } , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemChoose . class , true , false , true , 20 , true ) ; XSLTElementDef xslAttribute = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , spaceAttr } , new ProcessorTemplateElem ( ) , ElemAttribute . class , 20 , true ) ; XSLTElementDef xslCallTemplate = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "call-template" , null , new XSLTElementDef [ ] { xslWithParam } , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorTemplateElem ( ) , ElemCallTemplate . class , 20 , true ) ; XSLTElementDef xslVariable = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemVariable . class , 20 , true ) ; XSLTElementDef xslParam = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorTemplateElem ( ) , ElemParam . class , 19 , true ) ; XSLTElementDef xslText = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "text" , null , new XSLTElementDef [ ] { charData } , new XSLTAttributeDef [ ] { disableOutputEscapingAttr } , new ProcessorText ( ) , ElemText . class , 20 , true ) ; XSLTElementDef xslProcessingInstruction = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "processing-instruction" , null , charTemplateElements , new XSLTAttributeDef [ ] { nameAVT_NCNAMERequired , spaceAttr } , new ProcessorTemplateElem ( ) , ElemPI . class , 20 , true ) ; XSLTElementDef xslElement = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "element" , null , templateElements , new XSLTAttributeDef [ ] { nameAVTRequired , namespaceAVTOpt , useAttributeSetsAttr , spaceAttr } , new ProcessorTemplateElem ( ) , ElemElement . class , 20 , true ) ; XSLTElementDef xslComment = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "comment" , null , charTemplateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemComment . class , 20 , true ) ; XSLTElementDef xslCopy = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "copy" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr , useAttributeSetsAttr } , new ProcessorTemplateElem ( ) , ElemCopy . class , 20 , true ) ; XSLTElementDef xslMessage = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "message" , null , templateElements , new XSLTAttributeDef [ ] { terminateAttr } , new ProcessorTemplateElem ( ) , ElemMessage . class , 20 , true ) ; XSLTElementDef xslFallback = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "fallback" , null , templateElements , new XSLTAttributeDef [ ] { spaceAttr } , new ProcessorTemplateElem ( ) , ElemFallback . class , 20 , true ) ; XSLTElementDef exsltFunction = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "function" , null , exsltFunctionElements , new XSLTAttributeDef [ ] { nameAttrRequired } , new ProcessorExsltFunction ( ) , ElemExsltFunction . class ) ; XSLTElementDef exsltResult = new XSLTElementDef ( this , Constants . S_EXSLT_FUNCTIONS_URL , "result" , null , templateElements , new XSLTAttributeDef [ ] { selectAttrOpt } , new ProcessorExsltFuncResult ( ) , ElemExsltFuncResult . class ) ; int i = 0 ; templateElements [ i ++ ] = charData ; templateElements [ i ++ ] = xslApplyTemplates ; templateElements [ i ++ ] = xslCallTemplate ; templateElements [ i ++ ] = xslApplyImports ; templateElements [ i ++ ] = xslForEach ; templateElements [ i ++ ] = xslValueOf ; templateElements [ i ++ ] = xslCopyOf ; templateElements [ i ++ ] = xslNumber ; templateElements [ i ++ ] = xslChoose ; templateElements [ i ++ ] = xslIf ; templateElements [ i ++ ] = xslText ; templateElements [ i ++ ] = xslCopy ; templateElements [ i ++ ] = xslVariable ; templateElements [ i ++ ] = xslMessage ; templateElements [ i ++ ] = xslFallback ; templateElements [ i ++ ] = xslProcessingInstruction ; templateElements [ i ++ ] = xslComment ; templateElements [ i ++ ] = xslElement ; templateElements [ i ++ ] = xslAttribute ; templateElements [ i ++ ] = resultElement ; templateElements [ i ++ ] = unknownElement ; templateElements [ i ++ ] = exsltFunction ; templateElements [ i ++ ] = exsltResult ; int k ; for ( k = 0 ; k < i ; k ++ ) { templateElementsAndParams [ k ] = templateElements [ k ] ; templateElementsAndSort [ k ] = templateElements [ k ] ; exsltFunctionElements [ k ] = templateElements [ k ] ; } templateElementsAndParams [ k ] = xslParam ; templateElementsAndSort [ k ] = xslSort ; exsltFunctionElements [ k ] = xslParam ; i = 0 ; charTemplateElements [ i ++ ] = charData ; charTemplateElements [ i ++ ] = xslApplyTemplates ; charTemplateElements [ i ++ ] = xslCallTemplate ; charTemplateElements [ i ++ ] = xslApplyImports ; charTemplateElements [ i ++ ] = xslForEach ; charTemplateElements [ i ++ ] = xslValueOf ; charTemplateElements [ i ++ ] = xslCopyOf ; charTemplateElements [ i ++ ] = xslNumber ; charTemplateElements [ i ++ ] = xslChoose ; charTemplateElements [ i ++ ] = xslIf ; charTemplateElements [ i ++ ] = xslText ; charTemplateElements [ i ++ ] = xslCopy ; charTemplateElements [ i ++ ] = xslVariable ; charTemplateElements [ i ++ ] = xslMessage ; charTemplateElements [ i ++ ] = xslFallback ; XSLTElementDef importDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "import" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorImport ( ) , null , 1 , true ) ; XSLTElementDef includeDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "include" , null , null , new XSLTAttributeDef [ ] { hrefAttr } , new ProcessorInclude ( ) , null , 20 , true ) ; XSLTAttributeDef [ ] scriptAttrs = new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "lang" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "src" , XSLTAttributeDef . T_URL , false , false , XSLTAttributeDef . WARNING ) } ; XSLTAttributeDef [ ] componentAttrs = new XSLTAttributeDef [ ] { new XSLTAttributeDef ( null , "prefix" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "elements" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) , new XSLTAttributeDef ( null , "functions" , XSLTAttributeDef . T_STRINGLIST , false , false , XSLTAttributeDef . WARNING ) } ; XSLTElementDef [ ] topLevelElements = new XSLTElementDef [ ] { includeDef , importDef , whiteSpaceOnly , unknownElement , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "strip-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorStripSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "preserve-space" , null , null , new XSLTAttributeDef [ ] { elementsAttr } , new ProcessorPreserveSpace ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "output" , null , null , new XSLTAttributeDef [ ] { methodAttr , versionAttr , encodingAttr , omitXmlDeclarationAttr , standaloneAttr , doctypePublicAttr , doctypeSystemAttr , cdataSectionElementsAttr , indentAttr , mediaTypeAttr , XSLTAttributeDef . m_foreignAttr } , new ProcessorOutputElem ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "key" , null , null , new XSLTAttributeDef [ ] { nameAttrRequired , matchAttrRequired , useAttr } , new ProcessorKey ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "decimal-format" , null , null , new XSLTAttributeDef [ ] { nameAttrOpt_ERROR , decimalSeparatorAttr , groupingSeparatorAttr , infinityAttr , minusSignAttr , NaNAttr , percentAttr , perMilleAttr , zeroDigitAttr , digitAttr , patternSeparatorAttr } , new ProcessorDecimalFormat ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "attribute-set" , null , new XSLTElementDef [ ] { xslAttribute } , new XSLTAttributeDef [ ] { nameAttrRequired , useAttributeSetsAttr } , new ProcessorAttributeSet ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "variable" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalVariableDecl ( ) , ElemVariable . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "param" , null , templateElements , new XSLTAttributeDef [ ] { nameAttrRequired , selectAttrOpt } , new ProcessorGlobalParamDecl ( ) , ElemParam . class , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "template" , null , templateElementsAndParams , new XSLTAttributeDef [ ] { matchAttrOpt , nameAttrOpt_ERROR , priorityAttr , modeAttr , spaceAttr } , new ProcessorTemplate ( ) , ElemTemplate . class , true , 20 , true ) , new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "namespace-alias" , null , null , new XSLTAttributeDef [ ] { stylesheetPrefixAttr , resultPrefixAttr } , new ProcessorNamespaceAlias ( ) , null , 20 , true ) , new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "component" , null , new XSLTElementDef [ ] { new XSLTElementDef ( this , Constants . S_BUILTIN_EXTENSIONS_URL , "script" , null , new XSLTElementDef [ ] { charData } , scriptAttrs , new ProcessorLRE ( ) , ElemExtensionScript . class , 20 , true ) } , componentAttrs , new ProcessorLRE ( ) , ElemExtensionDecl . class ) , new XSLTElementDef ( this , Constants . S_BUILTIN_OLD_EXTENSIONS_URL , "component" , null , new XSLTElementDef [ ] { new XSLTElementDef ( this , Constants . S_BUILTIN_OLD_EXTENSIONS_URL , "script" , null , new XSLTElementDef [ ] { charData } , scriptAttrs , new ProcessorLRE ( ) , ElemExtensionScript . class , 20 , true ) } , componentAttrs , new ProcessorLRE ( ) , ElemExtensionDecl . class ) , exsltFunction } ; XSLTAttributeDef excludeResultPrefixesAttr = new XSLTAttributeDef ( null , "exclude-result-prefixes" , XSLTAttributeDef . T_PREFIXLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef extensionElementPrefixesAttr = new XSLTAttributeDef ( null , "extension-element-prefixes" , XSLTAttributeDef . T_PREFIX_URLLIST , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef idAttr = new XSLTAttributeDef ( null , "id" , XSLTAttributeDef . T_CDATA , false , false , XSLTAttributeDef . WARNING ) ; XSLTAttributeDef versionAttrRequired = new XSLTAttributeDef ( null , "version" , XSLTAttributeDef . T_NMTOKEN , true , false , XSLTAttributeDef . WARNING ) ; XSLTElementDef stylesheetElemDef = new XSLTElementDef ( this , Constants . S_XSLNAMESPACEURL , "stylesheet" , "transform" , topLevelElements , new XSLTAttributeDef [ ] { extensionElementPrefixesAttr , excludeResultPrefixesAttr , idAttr , versionAttrRequired , spaceAttr } , new ProcessorStylesheetElement ( ) , null , true , - 1 , false ) ; importDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; includeDef . setElements ( new XSLTElementDef [ ] { stylesheetElemDef , resultElement , unknownElement } ) ; build ( null , null , null , new XSLTElementDef [ ] { stylesheetElemDef , whiteSpaceOnly , resultElement , unknownElement } , null , new ProcessorStylesheetDoc ( ) , null ) ; } private Hashtable m_availElems = new Hashtable ( ) ; public Hashtable getElemsAvailable ( ) { return m_availElems ; } void addAvailableElement ( QName elemName ) { m_availElems . put ( elemName , elemName ) ; } public boolean elementAvailable ( QName elemName ) { return m_availElems . containsKey ( elemName ) ; } } 	0	['5', '2', '0', '27', '43', '0', '5', '25', '2', '0.25', '2423', '1', '0', '0.875', '0.7', '1', '1', '483.4', '2', '1', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemVariable ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFuncResult extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; super . startElement ( handler , uri , localName , rawName , attributes ) ; ElemTemplateElement ancestor = handler . getElemTemplateElement ( ) . getParentElem ( ) ; while ( ancestor != null && ! ( ancestor instanceof ElemExsltFunction ) ) { if ( ancestor instanceof ElemVariable || ancestor instanceof ElemParam || ancestor instanceof ElemExsltFuncResult ) { msg = "func:result cannot appear within a variable, parameter, or another func:result." ; handler . error ( msg , new SAXException ( msg ) ) ; } ancestor = ancestor . getParentElem ( ) ; } if ( ancestor == null ) { msg = "func:result must appear in a func:function element" ; handler . error ( msg , new SAXException ( msg ) ) ; } } } 	0	['2', '5', '0', '8', '8', '1', '1', '7', '2', '2', '57', '0', '0', '0.995327103', '0.625', '1', '1', '27.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . trax ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . Driver ; import java . sql . DriverManager ; import java . sql . SQLException ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class DefaultConnectionPool implements ConnectionPool { private Driver m_Driver = null ; private static final boolean DEBUG = false ; private String m_driver = new String ( "" ) ; private String m_url = new String ( "" ) ; private int m_PoolMinSize = 1 ; private Properties m_ConnectionProtocol = new Properties ( ) ; private Vector m_pool = new Vector ( ) ; private boolean m_IsActive = false ; public DefaultConnectionPool ( ) { } public boolean isEnabled ( ) { return m_IsActive ; } public void setDriver ( String d ) { m_driver = d ; } public void setURL ( String url ) { m_url = url ; } public void freeUnused ( ) { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { if ( DEBUG ) { System . err . println ( "Closing JDBC Connection " + x ) ; } pcon . close ( ) ; } } } public boolean hasActiveConnections ( ) { return ( m_pool . size ( ) > 0 ) ; } public void setPassword ( String p ) { m_ConnectionProtocol . put ( "password" , p ) ; } public void setUser ( String u ) { m_ConnectionProtocol . put ( "user" , u ) ; } public void setProtocol ( Properties p ) { Enumeration e = p . keys ( ) ; while ( e . hasMoreElements ( ) ) { String key = ( String ) e . nextElement ( ) ; m_ConnectionProtocol . put ( key , p . getProperty ( key ) ) ; } } public void setMinConnections ( int n ) { m_PoolMinSize = n ; } public boolean testConnection ( ) { try { if ( DEBUG ) { System . out . println ( "Testing Connection" ) ; } Connection conn = getConnection ( ) ; if ( DEBUG ) { DatabaseMetaData dma = conn . getMetaData ( ) ; System . out . println ( "\nConnected to " + dma . getURL ( ) ) ; System . out . println ( "Driver   " + dma . getDriverName ( ) ) ; System . out . println ( "Version  " + dma . getDriverVersion ( ) ) ; System . out . println ( "" ) ; } if ( conn == null ) return false ; releaseConnection ( conn ) ; if ( DEBUG ) { System . out . println ( "Testing Connection, SUCCESS" ) ; } return true ; } catch ( Exception e ) { if ( DEBUG ) { System . out . println ( "Testing Connection, FAILED" ) ; e . printStackTrace ( ) ; } return false ; } } public synchronized Connection getConnection ( ) throws IllegalArgumentException , SQLException { PooledConnection pcon = null ; if ( m_pool . size ( ) < m_PoolMinSize ) { initializePool ( ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . setInUse ( true ) ; return pcon . getConnection ( ) ; } } Connection con = createConnection ( ) ; pcon = new PooledConnection ( con ) ; pcon . setInUse ( true ) ; m_pool . addElement ( pcon ) ; return pcon . getConnection ( ) ; } public synchronized void releaseConnection ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection " + x ) ; } if ( ! isEnabled ( ) ) { con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } } else { pcon . setInUse ( false ) ; } break ; } } } public synchronized void releaseConnectionOnError ( Connection con ) throws SQLException { for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . getConnection ( ) == con ) { if ( DEBUG ) { System . out . println ( "Releasing Connection On Error" + x ) ; } con . close ( ) ; m_pool . removeElementAt ( x ) ; if ( DEBUG ) { System . out . println ( "-->Inactive Pool, Closing connection" ) ; } break ; } } } private Connection createConnection ( ) throws SQLException { Connection con = null ; con = m_Driver . connect ( m_url , m_ConnectionProtocol ) ; return con ; } public synchronized void initializePool ( ) throws IllegalArgumentException , SQLException { if ( m_driver == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_DRIVER_NAME_SPECIFIED , null ) ) ; } if ( m_url == null ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_URL_SPECIFIED , null ) ) ; } if ( m_PoolMinSize < 1 ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_POOLSIZE_LESS_THAN_ONE , null ) ) ; } try { m_Driver = ( Driver ) ObjectFactory . newInstance ( m_driver , ObjectFactory . findClassLoader ( ) , true ) ; DriverManager . registerDriver ( m_Driver ) ; } catch ( ObjectFactory . ConfigurationError e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_DRIVER_NAME , null ) ) ; } if ( ! m_IsActive ) return ; do { Connection con = createConnection ( ) ; if ( con != null ) { PooledConnection pcon = new PooledConnection ( con ) ; addConnection ( pcon ) ; if ( DEBUG ) System . out . println ( "Adding DB Connection to the Pool" ) ; } } while ( m_pool . size ( ) < m_PoolMinSize ) ; } private void addConnection ( PooledConnection value ) { m_pool . addElement ( value ) ; } protected void finalize ( ) throws Throwable { if ( DEBUG ) { System . out . println ( "In Default Connection Pool, Finalize" ) ; } for ( int x = 0 ; x < m_pool . size ( ) ; x ++ ) { if ( DEBUG ) { System . out . println ( "Closing JDBC Connection " + x ) ; } PooledConnection pcon = ( PooledConnection ) m_pool . elementAt ( x ) ; if ( pcon . inUse ( ) == false ) { pcon . close ( ) ; } else { if ( DEBUG ) { System . out . println ( "--> Force close" ) ; } try { java . lang . Thread . sleep ( 30000 ) ; pcon . close ( ) ; } catch ( InterruptedException ie ) { if ( DEBUG ) System . err . println ( ie . getMessage ( ) ) ; } } } if ( DEBUG ) { System . out . println ( "Exit Default Connection Pool, Finalize" ) ; } super . finalize ( ) ; } public void setPoolEnabled ( boolean flag ) { m_IsActive = flag ; if ( ! flag ) freeUnused ( ) ; } } 	0	['19', '1', '0', '6', '46', '51', '1', '5', '16', '0.763888889', '405', '1', '0', '0', '0.218045113', '0', '0', '19.89473684', '3', '1.2632', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . SyntaxTreeNode ; public class TypeCheckError extends Exception { ErrorMsg _error = null ; SyntaxTreeNode _node = null ; public TypeCheckError ( SyntaxTreeNode node ) { super ( ) ; _node = node ; } public TypeCheckError ( ErrorMsg error ) { super ( ) ; _error = error ; } public TypeCheckError ( String code , Object param ) { super ( ) ; _error = new ErrorMsg ( code , param ) ; } public TypeCheckError ( String code , Object param1 , Object param2 ) { super ( ) ; _error = new ErrorMsg ( code , param1 , param2 ) ; } public ErrorMsg getErrorMsg ( ) { return _error ; } public String getMessage ( ) { return toString ( ) ; } public String toString ( ) { String result ; if ( _error == null ) { if ( _node != null ) { _error = new ErrorMsg ( ErrorMsg . TYPE_CHECK_ERR , _node . toString ( ) ) ; } else { _error = new ErrorMsg ( ErrorMsg . TYPE_CHECK_UNK_LOC_ERR ) ; } } return _error . toString ( ) ; } } 	0	['7', '3', '0', '89', '13', '0', '88', '2', '7', '0.083333333', '98', '0', '2', '0.85', '0.371428571', '1', '2', '12.71428571', '3', '0.7143', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NameCall extends NameBase { public NameCall ( QName fname ) { super ( fname ) ; } public NameCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getName = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_NAME , GET_NODE_NAME_SIG ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getName , 2 ) ) ; } } 	0	['3', '5', '0', '9', '11', '3', '0', '9', '3', '2', '37', '0', '0', '0.99', '0.533333333', '3', '5', '11.33333333', '1', '0.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . Translet ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . utils . LocaleUtility ; import java . util . Locale ; import java . text . Collator ; public class NodeSortRecordFactory { private static int DESCENDING = "descending" . length ( ) ; private static int NUMBER = "number" . length ( ) ; private final DOM _dom ; private final String _className ; private Class _class ; private SortSettings _sortSettings ; protected Collator _collator ; public NodeSortRecordFactory ( DOM dom , String className , Translet translet , String order [ ] , String type [ ] ) throws TransletException { this ( dom , className , translet , order , type , null , null ) ; } public NodeSortRecordFactory ( DOM dom , String className , Translet translet , String order [ ] , String type [ ] , String lang [ ] , String caseOrder [ ] ) throws TransletException { try { _dom = dom ; _className = className ; _class = translet . getAuxiliaryClass ( className ) ; if ( _class == null ) { _class = ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; } int levels = order . length ; int [ ] iOrder = new int [ levels ] ; int [ ] iType = new int [ levels ] ; for ( int i = 0 ; i < levels ; i ++ ) { if ( order [ i ] . length ( ) == DESCENDING ) { iOrder [ i ] = NodeSortRecord . COMPARE_DESCENDING ; } if ( type [ i ] . length ( ) == NUMBER ) { iType [ i ] = NodeSortRecord . COMPARE_NUMERIC ; } } String [ ] emptyStringArray = null ; if ( lang == null || caseOrder == null ) { int numSortKeys = order . length ; emptyStringArray = new String [ numSortKeys ] ; for ( int i = 0 ; i < numSortKeys ; i ++ ) { emptyStringArray [ i ] = "" ; } } if ( lang == null ) { lang = emptyStringArray ; } if ( caseOrder == null ) { caseOrder = emptyStringArray ; } final int length = lang . length ; Locale [ ] locales = new Locale [ length ] ; Collator [ ] collators = new Collator [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { locales [ i ] = LocaleUtility . langToLocale ( lang [ i ] ) ; collators [ i ] = Collator . getInstance ( locales [ i ] ) ; } _sortSettings = new SortSettings ( ( AbstractTranslet ) translet , iOrder , iType , locales , collators , caseOrder ) ; } catch ( ClassNotFoundException e ) { throw new TransletException ( e ) ; } } public NodeSortRecord makeNodeSortRecord ( int node , int last ) throws ExceptionInInitializerError , LinkageError , IllegalAccessException , InstantiationException , SecurityException , TransletException { final NodeSortRecord sortRecord = ( NodeSortRecord ) _class . newInstance ( ) ; sortRecord . initialize ( node , last , _dom , _sortSettings ) ; return sortRecord ; } public String getClassName ( ) { return _className ; } private final void setLang ( final String lang [ ] ) { } } 	0	['6', '1', '0', '9', '17', '9', '1', '8', '4', '0.685714286', '188', '1', '2', '0', '0.5', '0', '0', '29.16666667', '1', '0.5', '0']
package org . apache . xml . utils ; public class Constants { public static final String S_XMLNAMESPACEURI = "http://www.w3.org/XML/1998/namespace" , S_XSLNAMESPACEURL = "http://www.w3.org/1999/XSL/Transform" , S_OLDXSLNAMESPACEURL = "http://www.w3.org/XSL/Transform/1.0" ; public static final String S_VENDOR = "Apache Software Foundation" , S_VENDORURL = "http://xml.apache.org" ; public static final String S_BUILTIN_EXTENSIONS_URL = "http://xml.apache.org/xalan" ; public static final String S_BUILTIN_OLD_EXTENSIONS_URL = "http://xml.apache.org/xslt" ; public static final String S_EXTENSIONS_OLD_JAVA_URL = "http://xml.apache.org/xslt/java" , S_EXTENSIONS_JAVA_URL = "http://xml.apache.org/xalan/java" , S_EXTENSIONS_LOTUSXSL_JAVA_URL = "http://xsl.lotus.com/java" , S_EXTENSIONS_XALANLIB_URL = "http://xml.apache.org/xalan" , S_EXTENSIONS_REDIRECT_URL = "http://xml.apache.org/xalan/redirect" , S_EXTENSIONS_PIPE_URL = "http://xml.apache.org/xalan/PipeDocument" , S_EXTENSIONS_SQL_URL = "http://xml.apache.org/xalan/sql" ; public static final String S_EXSLT_COMMON_URL = "http://exslt.org/common" , S_EXSLT_MATH_URL = "http://exslt.org/math" , S_EXSLT_SETS_URL = "http://exslt.org/sets" , S_EXSLT_DATETIME_URL = "http://exslt.org/dates-and-times" , S_EXSLT_FUNCTIONS_URL = "http://exslt.org/functions" , S_EXSLT_DYNAMIC_URL = "http://exslt.org/dynamic" , S_EXSLT_STRINGS_URL = "http://exslt.org/strings" ; public static final double XSLTVERSUPPORTED = 1.0 ; } 	0	['1', '1', '1', '1', '2', '0', '1', '0', '1', '2', '26', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; final class StringLengthCall extends FunctionCall { public StringLengthCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) > 0 ) { argument ( ) . translate ( classGen , methodGen ) ; } else { il . append ( methodGen . loadContextNode ( ) ) ; Type . Node . translateTo ( classGen , methodGen , Type . String ) ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ) ) ; } } 	0	['2', '4', '0', '11', '13', '1', '0', '11', '2', '2', '44', '0', '0', '0.989690722', '0.6', '2', '4', '21', '2', '1', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Vector ; public class AttributeList implements org . xml . sax . Attributes { private final static String EMPTYSTRING = "" ; private final static String CDATASTRING = "CDATA" ; private Hashtable _attributes ; private Vector _names ; private Vector _qnames ; private Vector _values ; private Vector _uris ; private int _length ; public AttributeList ( ) { _length = 0 ; } public AttributeList ( org . xml . sax . Attributes attributes ) { this ( ) ; if ( attributes != null ) { final int count = attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { add ( attributes . getQName ( i ) , attributes . getValue ( i ) ) ; } } } private void alloc ( ) { _attributes = new Hashtable ( ) ; _names = new Vector ( ) ; _values = new Vector ( ) ; _qnames = new Vector ( ) ; _uris = new Vector ( ) ; } public int getLength ( ) { return ( _length ) ; } public String getURI ( int index ) { if ( index < _length ) return ( ( String ) _uris . elementAt ( index ) ) ; else return ( null ) ; } public String getLocalName ( int index ) { if ( index < _length ) return ( ( String ) _names . elementAt ( index ) ) ; else return ( null ) ; } public String getQName ( int pos ) { if ( pos < _length ) return ( ( String ) _qnames . elementAt ( pos ) ) ; else return ( null ) ; } public String getType ( int index ) { return ( CDATASTRING ) ; } public int getIndex ( String namespaceURI , String localPart ) { return ( - 1 ) ; } public int getIndex ( String qname ) { return ( - 1 ) ; } public String getType ( String uri , String localName ) { return ( CDATASTRING ) ; } public String getType ( String qname ) { return ( CDATASTRING ) ; } public String getValue ( int pos ) { if ( pos < _length ) return ( ( String ) _values . elementAt ( pos ) ) ; else return ( null ) ; } public String getValue ( String qname ) { if ( _attributes != null ) { final Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) return null ; return ( getValue ( obj . intValue ( ) ) ) ; } else return null ; } public String getValue ( String uri , String localName ) { return ( getValue ( uri + ':' + localName ) ) ; } public void add ( String qname , String value ) { if ( _attributes == null ) alloc ( ) ; Integer obj = ( Integer ) _attributes . get ( qname ) ; if ( obj == null ) { _attributes . put ( qname , obj = new Integer ( _length ++ ) ) ; _qnames . addElement ( qname ) ; _values . addElement ( value ) ; int col = qname . lastIndexOf ( ':' ) ; if ( col > - 1 ) { _uris . addElement ( qname . substring ( 0 , col ) ) ; _names . addElement ( qname . substring ( col + 1 ) ) ; } else { _uris . addElement ( EMPTYSTRING ) ; _names . addElement ( qname ) ; } } else { final int index = obj . intValue ( ) ; _values . set ( index , value ) ; } } public void clear ( ) { _length = 0 ; if ( _attributes != null ) { _attributes . clear ( ) ; _names . removeAllElements ( ) ; _values . removeAllElements ( ) ; _qnames . removeAllElements ( ) ; _uris . removeAllElements ( ) ; } } } 	0	['17', '1', '0', '3', '39', '62', '2', '1', '16', '0.7578125', '276', '1', '1', '0', '0.441176471', '0', '0', '14.76470588', '4', '1.4706', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LiteralExpr extends Expression { private final String _value ; private final String _namespace ; public LiteralExpr ( String value ) { _value = value ; _namespace = null ; } public LiteralExpr ( String value , String namespace ) { _value = value ; _namespace = namespace . equals ( Constants . EMPTYSTRING ) ? null : namespace ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return "literal-expr(" + _value + ')' ; } protected boolean contextDependent ( ) { return false ; } protected String getValue ( ) { return _value ; } protected String getNamespace ( ) { return _namespace ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['8', '3', '0', '18', '18', '4', '7', '11', '5', '0.571428571', '75', '1', '0', '0.922077922', '0.325', '2', '8', '8.125', '1', '0.75', '0']
package org . apache . xml . utils ; public final class BoolStack implements Cloneable { private boolean m_values [ ] ; private int m_allocatedSize ; private int m_index ; public BoolStack ( ) { this ( 32 ) ; } public BoolStack ( int size ) { m_allocatedSize = size ; m_values = new boolean [ size ] ; m_index = - 1 ; } public final int size ( ) { return m_index + 1 ; } public final void clear ( ) { m_index = - 1 ; } public final boolean push ( boolean val ) { if ( m_index == m_allocatedSize - 1 ) grow ( ) ; return ( m_values [ ++ m_index ] = val ) ; } public final boolean pop ( ) { return m_values [ m_index -- ] ; } public final boolean popAndTop ( ) { m_index -- ; return ( m_index >= 0 ) ? m_values [ m_index ] : false ; } public final void setTop ( boolean b ) { m_values [ m_index ] = b ; } public final boolean peek ( ) { return m_values [ m_index ] ; } public final boolean peekOrFalse ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : false ; } public final boolean peekOrTrue ( ) { return ( m_index > - 1 ) ? m_values [ m_index ] : true ; } public boolean isEmpty ( ) { return ( m_index == - 1 ) ; } private void grow ( ) { m_allocatedSize *= 2 ; boolean newVector [ ] = new boolean [ m_allocatedSize ] ; System . arraycopy ( m_values , 0 , newVector , 0 , m_index + 1 ) ; m_values = newVector ; } public Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; } } 	0	['14', '1', '0', '7', '17', '0', '7', '0', '13', '0.384615385', '165', '1', '0', '0', '0.404761905', '0', '0', '10.57142857', '2', '1.2143', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncDoclocation extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int whereNode = getArg0AsNode ( xctxt ) ; String fileLocation = null ; if ( DTM . NULL != whereNode ) { DTM dtm = xctxt . getDTM ( whereNode ) ; if ( DTM . DOCUMENT_FRAGMENT_NODE == dtm . getNodeType ( whereNode ) ) { whereNode = dtm . getFirstChild ( whereNode ) ; } if ( DTM . NULL != whereNode ) { fileLocation = dtm . getDocumentBaseURI ( ) ; } } return new XString ( ( null != fileLocation ) ? fileLocation : "" ) ; } } 	0	['2', '5', '0', '5', '9', '1', '0', '5', '2', '2', '43', '0', '0', '0.982142857', '0.75', '2', '7', '20.5', '1', '0.5', '0']
package org . apache . xalan . processor ; import org . apache . xalan . res . XSLTErrorResources ; class ProcessorImport extends ProcessorInclude { protected int getStylesheetType ( ) { return StylesheetHandler . STYPE_IMPORT ; } protected String getStylesheetInclErr ( ) { return XSLTErrorResources . ER_IMPORTING_ITSELF ; } } 	0	['3', '5', '0', '2', '4', '3', '1', '1', '0', '2', '10', '0', '0', '0.990950226', '1', '1', '1', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . dom ; import java . io . Externalizable ; import java . io . IOException ; import java . io . ObjectInput ; import java . io . ObjectOutput ; import org . apache . xml . dtm . DTMAxisIterator ; public class BitArray implements Externalizable { private int [ ] _bits ; private int _bitSize ; private int _intSize ; private int _mask ; private final static int [ ] _masks = { 0x80000000 , 0x40000000 , 0x20000000 , 0x10000000 , 0x08000000 , 0x04000000 , 0x02000000 , 0x01000000 , 0x00800000 , 0x00400000 , 0x00200000 , 0x00100000 , 0x00080000 , 0x00040000 , 0x00020000 , 0x00010000 , 0x00008000 , 0x00004000 , 0x00002000 , 0x00001000 , 0x00000800 , 0x00000400 , 0x00000200 , 0x00000100 , 0x00000080 , 0x00000040 , 0x00000020 , 0x00000010 , 0x00000008 , 0x00000004 , 0x00000002 , 0x00000001 } ; private final static boolean DEBUG_ASSERTIONS = false ; public BitArray ( ) { this ( 32 ) ; } public BitArray ( int size ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = new int [ _intSize + 1 ] ; } public BitArray ( int size , int [ ] bits ) { if ( size < 32 ) size = 32 ; _bitSize = size ; _intSize = ( _bitSize > > > 5 ) + 1 ; _bits = bits ; } public void setMask ( int mask ) { _mask = mask ; } public int getMask ( ) { return ( _mask ) ; } public final int size ( ) { return ( _bitSize ) ; } public final boolean getBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } return ( ( _bits [ bit > > > 5 ] & _masks [ bit % 32 ] ) != 0 ) ; } public final int getNextBit ( int startBit ) { for ( int i = ( startBit > > > 5 ) ; i <= _intSize ; i ++ ) { int bits = _bits [ i ] ; if ( bits != 0 ) { for ( int b = ( startBit % 32 ) ; b < 32 ; b ++ ) { if ( ( bits & _masks [ b ] ) != 0 ) { return ( ( i << 5 ) + b ) ; } } } startBit = 0 ; } return ( DTMAxisIterator . END ) ; } private int _pos = Integer . MAX_VALUE ; private int _node = 0 ; private int _int = 0 ; private int _bit = 0 ; public final int getBitNumber ( int pos ) { if ( pos == _pos ) return ( _node ) ; if ( pos < _pos ) { _int = _bit = _pos = 0 ; } for ( ; _int <= _intSize ; _int ++ ) { int bits = _bits [ _int ] ; if ( bits != 0 ) { for ( ; _bit < 32 ; _bit ++ ) { if ( ( bits & _masks [ _bit ] ) != 0 ) { if ( ++ _pos == pos ) { _node = ( ( _int << 5 ) + _bit ) - 1 ; return ( _node ) ; } } } _bit = 0 ; } } return ( 0 ) ; } public final int [ ] data ( ) { return ( _bits ) ; } int _first = Integer . MAX_VALUE ; int _last = Integer . MIN_VALUE ; public final void setBit ( int bit ) { if ( DEBUG_ASSERTIONS ) { if ( bit >= _bitSize ) { throw new Error ( "Programmer's assertion in  BitArray.getBit" ) ; } } if ( bit >= _bitSize ) return ; final int i = ( bit > > > 5 ) ; if ( i < _first ) _first = i ; if ( i > _last ) _last = i ; _bits [ i ] |= _masks [ bit % 32 ] ; } public final BitArray merge ( BitArray other ) { if ( _last == - 1 ) { _bits = other . _bits ; } else if ( other . _last != - 1 ) { int start = ( _first < other . _first ) ? _first : other . _first ; int stop = ( _last > other . _last ) ? _last : other . _last ; if ( other . _intSize > _intSize ) { if ( stop > _intSize ) stop = _intSize ; for ( int i = start ; i <= stop ; i ++ ) other . _bits [ i ] |= _bits [ i ] ; _bits = other . _bits ; } else { if ( stop > other . _intSize ) stop = other . _intSize ; for ( int i = start ; i <= stop ; i ++ ) _bits [ i ] |= other . _bits [ i ] ; } } return ( this ) ; } public final void resize ( int newSize ) { if ( newSize > _bitSize ) { _intSize = ( newSize > > > 5 ) + 1 ; final int [ ] newBits = new int [ _intSize + 1 ] ; System . arraycopy ( _bits , 0 , newBits , 0 , ( _bitSize > > > 5 ) + 1 ) ; _bits = newBits ; _bitSize = newSize ; } } public BitArray cloneArray ( ) { return ( new BitArray ( _intSize , _bits ) ) ; } public void writeExternal ( ObjectOutput out ) throws IOException { out . writeInt ( _bitSize ) ; out . writeInt ( _mask ) ; out . writeObject ( _bits ) ; out . flush ( ) ; } public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _bitSize = in . readInt ( ) ; _intSize = ( _bitSize > > > 5 ) + 1 ; _mask = in . readInt ( ) ; _bits = ( int [ ] ) in . readObject ( ) ; } } 	0	['17', '1', '0', '2', '24', '0', '2', '0', '16', '0.6875', '622', '0.833333333', '0', '0', '0.291666667', '0', '0', '34.88235294', '10', '2.2353', '0']
package org . apache . xalan . xsltc . runtime ; public class MessageHandler { public void displayMessage ( String msg ) { System . err . println ( msg ) ; } } 	0	['2', '1', '1', '3', '4', '1', '3', '0', '2', '2', '9', '0', '0', '0', '0.75', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime . output ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . Writer ; class WriterOutputBuffer implements OutputBuffer { private static final int KB = 1024 ; private static int BUFFER_SIZE = 4 * KB ; static { final String osName = System . getProperty ( "os.name" ) ; if ( osName . equalsIgnoreCase ( "solaris" ) ) { BUFFER_SIZE = 32 * KB ; } } private Writer _writer ; public WriterOutputBuffer ( Writer writer ) { _writer = new BufferedWriter ( writer , BUFFER_SIZE ) ; } public String close ( ) { try { _writer . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return "" ; } public OutputBuffer append ( String s ) { try { _writer . write ( s ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char [ ] s , int from , int to ) { try { _writer . write ( s , from , to ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } public OutputBuffer append ( char ch ) { try { _writer . write ( ch ) ; } catch ( IOException e ) { throw new RuntimeException ( e . toString ( ) ) ; } return this ; } } 	0	['6', '1', '0', '1', '16', '0', '0', '1', '5', '0.733333333', '88', '1', '0', '0', '0.333333333', '0', '0', '13.16666667', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTMAxisIterator ; public abstract class DTMAxisIteratorBase implements DTMAxisIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = DTMAxisIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public int getStartNode ( ) { return _startNode ; } public DTMAxisIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _startNode ) ; _isRestartable = temp ; return this ; } public DTMAxisIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public DTMAxisIterator cloneIterator ( ) { try { final DTMAxisIteratorBase clone = ( DTMAxisIteratorBase ) super . clone ( ) ; clone . _isRestartable = false ; return clone ; } catch ( CloneNotSupportedException e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final DTMAxisIterator resetPosition ( ) { _position = 0 ; return this ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return - 1 ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } public int getNodeByPosition ( int position ) { if ( position > 0 ) { final int pos = isReverse ( ) ? getLast ( ) - position + 1 : position ; int node ; while ( ( node = next ( ) ) != DTMAxisIterator . END ) { if ( pos == getPosition ( ) ) { return node ; } } } return END ; } } 	0	['14', '1', '20', '22', '21', '53', '20', '2', '12', '0.794871795', '166', '1', '0', '0', '0.404761905', '0', '0', '10.42857143', '5', '1.4286', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . FilterGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LangCall extends FunctionCall { private Expression _lang ; private Type _langType ; public LangCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _lang = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _langType = _lang . typeCheck ( stable ) ; if ( ! ( _langType instanceof StringType ) ) { _lang = new CastExpr ( _lang , Type . String ) ; } return Type . Boolean ; } public Type getType ( ) { return ( Type . Boolean ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int tst = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "testLanguage" , "(" + STRING_SIG + DOM_INTF_SIG + "I)Z" ) ; _lang . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( classGen instanceof FilterGenerator ) il . append ( new ILOAD ( 1 ) ) ; else il . append ( methodGen . loadContextNode ( ) ) ; il . append ( new INVOKESTATIC ( tst ) ) ; } } 	0	['4', '4', '0', '17', '17', '0', '0', '17', '4', '0.666666667', '84', '1', '2', '0.96969697', '0.375', '3', '8', '19.5', '2', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class FilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private final DTMFilter _filter ; private final boolean _isReverse ; public FilterIterator ( DTMAxisIterator source , DTMFilter filter ) { _source = source ; _filter = filter ; _isReverse = source . isReverse ( ) ; } public boolean isReverse ( ) { return _isReverse ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public DTMAxisIterator cloneIterator ( ) { try { final FilterIterator clone = ( FilterIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public int next ( ) { int node ; while ( ( node = _source . next ( ) ) != END ) { if ( _filter . acceptNode ( node , DTMFilter . SHOW_ALL ) == DTMIterator . FILTER_ACCEPT ) { return returnNode ( node ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; return resetPosition ( ) ; } return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['9', '2', '0', '4', '24', '0', '0', '4', '9', '0.625', '109', '1', '2', '0.619047619', '0.288888889', '1', '6', '10.77777778', '3', '1.2222', '0']
package org . apache . xalan . xsltc . compiler ; abstract class RelativePathPattern extends LocationPathPattern { } 	0	['1', '5', '3', '7', '2', '0', '6', '1', '0', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisTraverser ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . Expression ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathContext ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . res . XPATHErrorResources ; public class AxesWalker extends PredicatedNodeTest implements Cloneable , PathComponent , ExpressionOwner { public AxesWalker ( LocPathIterator locPathIterator , int axis ) { super ( locPathIterator ) ; m_axis = axis ; } public final WalkingIterator wi ( ) { return ( WalkingIterator ) m_lpi ; } public void init ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { initPredicateInfo ( compiler , opPos ) ; } public Object clone ( ) throws CloneNotSupportedException { AxesWalker clone = ( AxesWalker ) super . clone ( ) ; return clone ; } AxesWalker cloneDeep ( WalkingIterator cloneOwner , Vector cloneList ) throws CloneNotSupportedException { AxesWalker clone = findClone ( this , cloneList ) ; if ( null != clone ) return clone ; clone = ( AxesWalker ) this . clone ( ) ; clone . setLocPathIterator ( cloneOwner ) ; if ( null != cloneList ) { cloneList . addElement ( this ) ; cloneList . addElement ( clone ) ; } if ( wi ( ) . m_lastUsedWalker == this ) cloneOwner . m_lastUsedWalker = clone ; if ( null != m_nextWalker ) clone . m_nextWalker = m_nextWalker . cloneDeep ( cloneOwner , cloneList ) ; if ( null != cloneList ) { if ( null != m_prevWalker ) clone . m_prevWalker = m_prevWalker . cloneDeep ( cloneOwner , cloneList ) ; } else { if ( null != m_nextWalker ) clone . m_nextWalker . m_prevWalker = clone ; } return clone ; } static AxesWalker findClone ( AxesWalker key , Vector cloneList ) { if ( null != cloneList ) { int n = cloneList . size ( ) ; for ( int i = 0 ; i < n ; i += 2 ) { if ( key == cloneList . elementAt ( i ) ) return ( AxesWalker ) cloneList . elementAt ( i + 1 ) ; } } return null ; } public void detach ( ) { m_currentNode = DTM . NULL ; m_dtm = null ; m_traverser = null ; m_isFresh = true ; m_root = DTM . NULL ; } public int getRoot ( ) { return m_root ; } public int getAnalysisBits ( ) { int axis = getAxis ( ) ; int bit = WalkerFactory . getAnalysisBitFromAxes ( axis ) ; return bit ; } public void setRoot ( int root ) { XPathContext xctxt = wi ( ) . getXPathContext ( ) ; m_dtm = xctxt . getDTM ( root ) ; m_traverser = m_dtm . getAxisTraverser ( m_axis ) ; m_isFresh = true ; m_foundLast = false ; m_root = root ; m_currentNode = root ; if ( DTM . NULL == root ) { throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_SETTING_WALKER_ROOT_TO_NULL , null ) ) ; } resetProximityPositions ( ) ; } public final int getCurrentNode ( ) { return m_currentNode ; } public void setNextWalker ( AxesWalker walker ) { m_nextWalker = walker ; } public AxesWalker getNextWalker ( ) { return m_nextWalker ; } public void setPrevWalker ( AxesWalker walker ) { m_prevWalker = walker ; } public AxesWalker getPrevWalker ( ) { return m_prevWalker ; } private int returnNextNode ( int n ) { return n ; } protected int getNextNode ( ) { if ( m_foundLast ) return DTM . NULL ; if ( m_isFresh ) { m_currentNode = m_traverser . first ( m_root ) ; m_isFresh = false ; } else if ( DTM . NULL != m_currentNode ) { m_currentNode = m_traverser . next ( m_root , m_currentNode ) ; } if ( DTM . NULL == m_currentNode ) this . m_foundLast = true ; return m_currentNode ; } public int nextNode ( ) { int nextNode = DTM . NULL ; AxesWalker walker = wi ( ) . getLastUsedWalker ( ) ; while ( true ) { if ( null == walker ) break ; nextNode = walker . getNextNode ( ) ; if ( DTM . NULL == nextNode ) { walker = walker . m_prevWalker ; } else { if ( walker . acceptNode ( nextNode ) != DTMIterator . FILTER_ACCEPT ) { continue ; } if ( null == walker . m_nextWalker ) { wi ( ) . setLastUsedWalker ( walker ) ; break ; } else { AxesWalker prev = walker ; walker = walker . m_nextWalker ; walker . setRoot ( nextNode ) ; walker . m_prevWalker = prev ; continue ; } } } return nextNode ; } public int getLastPos ( XPathContext xctxt ) { int pos = getProximityPosition ( ) ; AxesWalker walker ; try { walker = ( AxesWalker ) clone ( ) ; } catch ( CloneNotSupportedException cnse ) { return - 1 ; } walker . setPredicateCount ( walker . getPredicateCount ( ) - 1 ) ; walker . setNextWalker ( null ) ; walker . setPrevWalker ( null ) ; WalkingIterator lpi = wi ( ) ; AxesWalker savedWalker = lpi . getLastUsedWalker ( ) ; try { lpi . setLastUsedWalker ( walker ) ; int next ; while ( DTM . NULL != ( next = walker . nextNode ( ) ) ) { pos ++ ; } } finally { lpi . setLastUsedWalker ( savedWalker ) ; } return pos ; } private DTM m_dtm ; public void setDefaultDTM ( DTM dtm ) { m_dtm = dtm ; } public DTM getDTM ( int node ) { return wi ( ) . getXPathContext ( ) . getDTM ( node ) ; } public boolean isDocOrdered ( ) { return true ; } public int getAxis ( ) { return m_axis ; } public void callVisitors ( ExpressionOwner owner , XPathVisitor visitor ) { if ( visitor . visitStep ( owner , this ) ) { callPredicateVisitors ( visitor ) ; if ( null != m_nextWalker ) { m_nextWalker . callVisitors ( this , visitor ) ; } } } public Expression getExpression ( ) { return m_nextWalker ; } public void setExpression ( Expression exp ) { exp . exprSetParent ( this ) ; m_nextWalker = ( AxesWalker ) exp ; } public boolean deepEquals ( Expression expr ) { if ( ! super . deepEquals ( expr ) ) return false ; AxesWalker walker = ( AxesWalker ) expr ; if ( this . m_axis != walker . m_axis ) return false ; return true ; } transient int m_root = DTM . NULL ; private transient int m_currentNode = DTM . NULL ; transient boolean m_isFresh ; protected AxesWalker m_nextWalker ; AxesWalker m_prevWalker ; protected int m_axis = - 1 ; protected DTMAxisTraverser m_traverser ; } 	0	['27', '4', '2', '21', '53', '257', '8', '15', '23', '0.802884615', '454', '0.625', '4', '0.747572816', '0.138888889', '1', '4', '15.51851852', '5', '1.5926', '0']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; abstract public class EntryPoint implements Member { protected Object realep ; private org . apache . xml . utils . synthetic . Class declaringclass = null ; protected org . apache . xml . utils . synthetic . Class returntype = null ; private String [ ] parameternames = new String [ 0 ] ; private org . apache . xml . utils . synthetic . Class [ ] parametertypes = new org . apache . xml . utils . synthetic . Class [ 0 ] ; private org . apache . xml . utils . synthetic . Class [ ] exceptiontypes = new org . apache . xml . utils . synthetic . Class [ 0 ] ; ; private int modifiers ; protected String name = null ; private StringBuffer body = null ; private String language = null ; Class [ ] realE , realP ; public EntryPoint ( org . apache . xml . utils . synthetic . Class declaringclass ) { this . declaringclass = declaringclass ; } protected EntryPoint ( Object ep , org . apache . xml . utils . synthetic . Class declaringclass ) throws IllegalArgumentException { realep = ep ; this . declaringclass = declaringclass ; if ( ep instanceof java . lang . reflect . Method ) { java . lang . reflect . Method m = ( java . lang . reflect . Method ) ep ; if ( declaringclass == null ) { declaringclass = org . apache . xml . utils . synthetic . Class . forClass ( m . getDeclaringClass ( ) ) ; } name = m . getName ( ) ; modifiers = m . getModifiers ( ) ; returntype = org . apache . xml . utils . synthetic . Class . forClass ( m . getReturnType ( ) ) ; realP = m . getParameterTypes ( ) ; realE = m . getExceptionTypes ( ) ; } else if ( ep instanceof java . lang . reflect . Constructor ) { java . lang . reflect . Constructor c = ( java . lang . reflect . Constructor ) ep ; if ( declaringclass == null ) { declaringclass = org . apache . xml . utils . synthetic . Class . forClass ( c . getDeclaringClass ( ) ) ; } name = declaringclass . getShortName ( ) ; modifiers = c . getModifiers ( ) ; returntype = declaringclass ; realP = c . getParameterTypes ( ) ; realE = c . getExceptionTypes ( ) ; } else throw new IllegalArgumentException ( ) ; } protected EntryPoint ( Object ep ) throws IllegalArgumentException { this ( ep , null ) ; } public boolean equals ( Object obj ) { EntryPoint otherep = null ; if ( obj instanceof EntryPoint ) otherep = ( EntryPoint ) obj ; else if ( obj instanceof java . lang . reflect . Constructor || obj instanceof java . lang . reflect . Method ) otherep = ( EntryPoint ) obj ; return ( otherep != null && ( ( this instanceof Constructor && otherep instanceof Constructor ) || ( this instanceof Method && otherep instanceof Method && this . getName ( ) . equals ( otherep . getName ( ) ) ) ) && otherep . getDeclaringClass ( ) . equals ( declaringclass ) && otherep . getParameterTypes ( ) . equals ( parametertypes ) ) ; } public org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) { return declaringclass ; } public org . apache . xml . utils . synthetic . Class getReturnType ( ) { return returntype ; } public org . apache . xml . utils . synthetic . Class [ ] getExceptionTypes ( ) { if ( realep != null && exceptiontypes == null ) { exceptiontypes = new org . apache . xml . utils . synthetic . Class [ realE . length ] ; for ( int i = 0 ; i < realE . length ; ++ i ) { exceptiontypes [ i ] = org . apache . xml . utils . synthetic . Class . forClass ( realE [ i ] ) ; } realE = null ; } return exceptiontypes ; } public void addExceptionType ( org . apache . xml . utils . synthetic . Class exception ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; org . apache . xml . utils . synthetic . Class [ ] e = new org . apache . xml . utils . synthetic . Class [ exceptiontypes . length + 1 ] ; System . arraycopy ( exceptiontypes , 0 , e , 0 , exceptiontypes . length ) ; e [ exceptiontypes . length ] = exception ; exceptiontypes = e ; } public int getModifiers ( ) { return modifiers ; } public java . lang . String getName ( ) { if ( this instanceof Constructor ) return declaringclass . getShortName ( ) ; return name ; } public void setName ( String name ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . name = name ; } public org . apache . xml . utils . synthetic . Class [ ] getParameterTypes ( ) { if ( realep != null && parametertypes == null ) { parametertypes = new org . apache . xml . utils . synthetic . Class [ realP . length ] ; for ( int i = 0 ; i < realP . length ; ++ i ) { parametertypes [ i ] = org . apache . xml . utils . synthetic . Class . forClass ( realP [ i ] ) ; } realP = null ; } return parametertypes ; } public String [ ] getParameterNames ( ) { return parameternames ; } public void addParameter ( org . apache . xml . utils . synthetic . Class type , String name ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; org . apache . xml . utils . synthetic . Class [ ] types = new org . apache . xml . utils . synthetic . Class [ parametertypes . length + 1 ] ; System . arraycopy ( parametertypes , 0 , types , 0 , parametertypes . length ) ; types [ parametertypes . length ] = type ; parametertypes = types ; String [ ] names = new String [ parameternames . length + 1 ] ; System . arraycopy ( parameternames , 0 , names , 0 , parameternames . length ) ; names [ parameternames . length ] = name ; parameternames = names ; } abstract public int hashCode ( ) ; public void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . declaringclass = declaringClass ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) sb . append ( ' ' ) . append ( getReturnType ( ) ) . append ( getDeclaringClass ( ) . getName ( ) ) . append ( '.' ) . append ( getName ( ) ) ; else sb . append ( getDeclaringClass ( ) . getName ( ) ) ; sb . append ( '(' ) ; org . apache . xml . utils . synthetic . Class [ ] p = getParameterTypes ( ) ; if ( p != null && p . length > 0 ) { sb . append ( p [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < p . length ; ++ i ) { sb . append ( ',' ) . append ( p [ i ] . getName ( ) ) ; } } sb . append ( ')' ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) { p = getExceptionTypes ( ) ; if ( p != null && p . length > 0 ) { sb . append ( " throws " ) . append ( p [ 0 ] . getName ( ) ) ; for ( int i = 1 ; i < p . length ; ++ i ) { sb . append ( ',' ) . append ( p [ i ] . getName ( ) ) ; } } } return sb . toString ( ) ; } public void setBody ( String language , StringBuffer body ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . language = language ; this . body = body ; } public StringBuffer getBody ( ) { if ( body == null ) body = new StringBuffer ( ) ; return body ; } public String getLanguage ( ) { return language ; } public String toSource ( String basetab ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( basetab ) . append ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) ; if ( this instanceof org . apache . xml . utils . synthetic . reflection . Method ) { if ( returntype != null ) sb . append ( " " ) . append ( getReturnType ( ) . getJavaName ( ) ) ; else sb . append ( " void" ) ; } sb . append ( " " ) . append ( getName ( ) ) . append ( "(" ) ; org . apache . xml . utils . synthetic . Class [ ] types = getParameterTypes ( ) ; if ( types != null & types . length > 0 ) { sb . append ( types [ 0 ] . getJavaName ( ) ) ; if ( parameternames != null ) sb . append ( ' ' ) . append ( parameternames [ 0 ] ) ; for ( int i = 1 ; i < types . length ; ++ i ) { sb . append ( ',' ) . append ( types [ i ] . getJavaName ( ) ) ; if ( parameternames != null ) sb . append ( ' ' ) . append ( parameternames [ i ] ) ; } } sb . append ( ')' ) ; types = getExceptionTypes ( ) ; if ( types != null & types . length > 0 ) { sb . append ( " throws " ) . append ( types [ 0 ] . getJavaName ( ) ) ; for ( int i = 1 ; i < types . length ; ++ i ) { sb . append ( ',' ) . append ( types [ i ] . getJavaName ( ) ) ; } } if ( body == null ) sb . append ( "; // No method body available\n" ) ; else { sb . append ( "\n" + basetab + "{\n" ) ; if ( language == null || "java" . equals ( language ) ) { sb . append ( basetab + "// ***** Should prettyprint this code...\n" ) ; sb . append ( basetab + body + "\n" ) ; } else { sb . append ( basetab + "// ***** Generate BSF invocation!?\n" ) ; } sb . append ( basetab + "}\n" ) ; } return sb . toString ( ) ; } } 	0	['22', '1', '2', '5', '53', '71', '2', '5', '20', '0.706349206', '827', '0.833333333', '4', '0', '0.272727273', '1', '1', '36.04545455', '16', '2.7727', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class NotEquals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return ( left . notEquals ( right ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . patterns . NodeTest ; public class UnionChildIterator extends ChildTestIterator { private PredicatedNodeTest [ ] m_nodeTests = null ; public UnionChildIterator ( ) { super ( null ) ; } public void addNodeTest ( PredicatedNodeTest test ) { if ( null == m_nodeTests ) { m_nodeTests = new PredicatedNodeTest [ 1 ] ; m_nodeTests [ 0 ] = test ; } else { PredicatedNodeTest [ ] tests = m_nodeTests ; int len = m_nodeTests . length ; m_nodeTests = new PredicatedNodeTest [ len + 1 ] ; System . arraycopy ( tests , 0 , m_nodeTests , 0 , len ) ; m_nodeTests [ len ] = test ; } test . exprSetParent ( this ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( m_nodeTests != null ) { for ( int i = 0 ; i < m_nodeTests . length ; i ++ ) { m_nodeTests [ i ] . fixupVariables ( vars , globalsSize ) ; } } } public short acceptNode ( int n ) { XPathContext xctxt = getXPathContext ( ) ; try { xctxt . pushCurrentNode ( n ) ; for ( int i = 0 ; i < m_nodeTests . length ; i ++ ) { PredicatedNodeTest pnt = m_nodeTests [ i ] ; XObject score = pnt . execute ( xctxt , n ) ; if ( score != NodeTest . SCORE_NONE ) { if ( pnt . getPredicateCount ( ) > 0 ) { if ( pnt . executePredicates ( n , xctxt ) ) return DTMIterator . FILTER_ACCEPT ; } else return DTMIterator . FILTER_ACCEPT ; } } } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; } return DTMIterator . FILTER_SKIP ; } } 	0	['4', '7', '0', '9', '17', '0', '1', '8', '4', '0', '144', '1', '0', '0.977941176', '0.5', '3', '4', '34.75', '5', '2.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class LocalNameCall extends NameBase { public LocalNameCall ( QName fname ) { super ( fname ) ; } public LocalNameCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int getNodeName = cpg . addInterfaceMethodref ( DOM_INTF , "getNodeName" , "(I)" + STRING_SIG ) ; final int getLocalName = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "getLocalName" , "(Ljava/lang/String;)" + "Ljava/lang/String;" ) ; super . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( getNodeName , 2 ) ) ; il . append ( new INVOKESTATIC ( getLocalName ) ) ; } } 	0	['3', '5', '0', '10', '13', '3', '0', '10', '3', '2', '50', '0', '0', '0.99', '0.533333333', '3', '5', '15.66666667', '1', '0.3333', '0']
package org . apache . xml . serializer ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncGenerateId extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int which = getArg0AsNode ( xctxt ) ; if ( DTM . NULL != which ) { return new XString ( "N" + Integer . toHexString ( which ) . toUpperCase ( ) ) ; } else return XString . EMPTYSTRING ; } } 	0	['2', '5', '0', '4', '10', '1', '0', '4', '2', '2', '28', '0', '0', '0.982142857', '0.75', '2', '7', '13', '1', '0.5', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . compiler . Compiler ; public class AttributeIterator extends ChildTestIterator { AttributeIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; } protected int getNextNode ( ) { m_lastFetched = ( DTM . NULL == m_lastFetched ) ? m_cdtm . getFirstAttribute ( m_context ) : m_cdtm . getNextAttribute ( m_lastFetched ) ; return m_lastFetched ; } public int getAxis ( ) { return org . apache . xml . dtm . Axis . ATTRIBUTE ; } } 	0	['3', '7', '0', '4', '6', '3', '1', '3', '1', '2', '31', '0', '0', '0.985185185', '0.555555556', '3', '5', '9.333333333', '2', '1', '0']
package org . apache . xalan . transformer ; public interface TransformerClient { void setTransformState ( TransformState ts ) ; } 	0	['1', '1', '0', '2', '1', '0', '1', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncStartsWith extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . xstr ( ) . startsWith ( m_arg1 . execute ( xctxt ) . xstr ( ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '5', '0', '6', '6', '1', '0', '6', '2', '2', '21', '0', '0', '0.98245614', '0.75', '1', '6', '9.5', '1', '0.5', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class String extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return ( XString ) right . xstr ( ) ; } } 	0	['2', '3', '0', '5', '4', '1', '1', '4', '2', '2', '9', '0', '0', '0.975609756', '0.75', '1', '1', '3.5', '1', '0.5', '0']
package org . apache . xml . dtm ; public interface DTMIterator { public static final short FILTER_ACCEPT = 1 ; public static final short FILTER_REJECT = 2 ; public static final short FILTER_SKIP = 3 ; public DTM getDTM ( int nodeHandle ) ; public DTMManager getDTMManager ( ) ; public int getRoot ( ) ; public void setRoot ( int nodeHandle , Object environment ) ; public void reset ( ) ; public int getWhatToShow ( ) ; public boolean getExpandEntityReferences ( ) ; public int nextNode ( ) ; public int previousNode ( ) ; public void detach ( ) ; public void allowDetachToRelease ( boolean allowRelease ) ; public int getCurrentNode ( ) ; public boolean isFresh ( ) ; public void setShouldCacheNodes ( boolean b ) ; public boolean isMutable ( ) ; public int getCurrentPos ( ) ; public void runTo ( int index ) ; public void setCurrentPos ( int i ) ; public int item ( int index ) ; public void setItem ( int node , int index ) ; public int getLength ( ) ; public DTMIterator cloneWithReset ( ) throws CloneNotSupportedException ; public Object clone ( ) throws CloneNotSupportedException ; public boolean isDocOrdered ( ) ; public int getAxis ( ) ; } 	0	['25', '1', '0', '49', '25', '300', '48', '2', '25', '1.041666667', '28', '0', '0', '0', '0.34', '0', '0', '0', '1', '1', '0']
package org . apache . xpath ; import org . apache . xml . utils . QName ; import org . apache . xpath . objects . XObject ; public class Arg { private QName m_qname ; public final QName getQName ( ) { return m_qname ; } public final void setQName ( QName name ) { m_qname = name ; } private XObject m_val ; public final XObject getVal ( ) { return m_val ; } public final void setVal ( XObject val ) { m_val = val ; } public void detach ( ) { if ( null != m_val ) { m_val . allowDetachToRelease ( true ) ; m_val . detach ( ) ; } } private String m_expression ; public String getExpression ( ) { return m_expression ; } public void setExpression ( String expr ) { m_expression = expr ; } private boolean m_isFromWithParam ; public boolean isFromWithParam ( ) { return m_isFromWithParam ; } private boolean m_isVisible ; public boolean isVisible ( ) { return m_isVisible ; } public void setIsVisible ( boolean b ) { m_isVisible = b ; } public Arg ( ) { m_qname = new QName ( "" ) ; ; m_val = null ; m_expression = null ; m_isVisible = true ; m_isFromWithParam = false ; } public Arg ( QName qname , String expression , boolean isFromWithParam ) { m_qname = qname ; m_val = null ; m_expression = expression ; m_isFromWithParam = isFromWithParam ; m_isVisible = ! isFromWithParam ; } public Arg ( QName qname , XObject val ) { m_qname = qname ; m_val = val ; m_isVisible = true ; m_isFromWithParam = false ; m_expression = null ; } public boolean equals ( Object obj ) { if ( obj instanceof QName ) { return m_qname . equals ( obj ) ; } else return super . equals ( obj ) ; } public Arg ( QName qname , XObject val , boolean isFromWithParam ) { m_qname = qname ; m_val = val ; m_isFromWithParam = isFromWithParam ; m_isVisible = ! isFromWithParam ; m_expression = null ; } } 	0	['15', '1', '0', '3', '21', '0', '1', '2', '15', '0.628571429', '158', '1', '2', '0', '0.311111111', '0', '0', '9.2', '2', '0.8667', '0']
package org . apache . xalan . extensions ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class ElementAvailableCall extends FunctionCall { public ElementAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argument ( ) instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "element-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } public boolean getResult ( ) { try { final LiteralExpr arg = ( LiteralExpr ) argument ( ) ; final String qname = arg . getValue ( ) ; final int index = qname . indexOf ( ':' ) ; final String localName = ( index > 0 ) ? qname . substring ( index + 1 ) : qname ; return getParser ( ) . elementSupported ( arg . getNamespace ( ) , localName ) ; } catch ( ClassCastException e ) { return false ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final boolean result = getResult ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , result ) ) ; } } 	0	['5', '4', '0', '17', '19', '10', '0', '17', '5', '2', '85', '0', '0', '0.96', '0.333333333', '3', '12', '16', '2', '1.2', '0']
package org . apache . xalan . xsltc . dom ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMDefaultBase ; import org . apache . xml . dtm . DTMException ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . DTMManagerDefault ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xalan . xsltc . trax . DOM2SAX ; import org . xml . sax . InputSource ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class XSLTCDTMManager extends DTMManagerDefault { private static final String DEFAULT_CLASS_NAME = "org.apache.xalan.xsltc.dom.XSLTCDTMManager" ; private static final String DEFAULT_PROP_NAME = "org.apache.xalan.xsltc.dom.XSLTCDTMManager" ; private static final boolean DUMPTREE = false ; private static final boolean DEBUG = false ; public XSLTCDTMManager ( ) { super ( ) ; } public static XSLTCDTMManager newInstance ( ) { return new XSLTCDTMManager ( ) ; } public static Class getDTMManagerClass ( ) { Class mgrClass = ObjectFactory . lookUpFactoryClass ( DEFAULT_PROP_NAME , null , DEFAULT_CLASS_NAME ) ; return ( mgrClass != null ) ? mgrClass : XSLTCDTMManager . class ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , false , 0 , true , false ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean buildIdIndex ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , false , 0 , buildIdIndex , false ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean buildIdIndex , boolean newNameTable ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , false , 0 , buildIdIndex , newNameTable ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean hasUserReader , int size , boolean buildIdIndex ) { return getDTM ( source , unique , whiteSpaceFilter , incremental , doIndexing , hasUserReader , size , buildIdIndex , false ) ; } public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing , boolean hasUserReader , int size , boolean buildIdIndex , boolean newNameTable ) { if ( DEBUG && null != source ) { System . out . println ( "Starting " + ( unique ? "UNIQUE" : "shared" ) + " source: " + source . getSystemId ( ) ) ; } int dtmPos = getFirstFreeDTMID ( ) ; int documentID = dtmPos << IDENT_DTM_NODE_BITS ; if ( ( null != source ) && source instanceof DOMSource ) { final DOMSource domsrc = ( DOMSource ) source ; final org . w3c . dom . Node node = domsrc . getNode ( ) ; final DOM2SAX dom2sax = new DOM2SAX ( node ) ; SAXImpl dtm ; if ( size <= 0 ) { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , DTMDefaultBase . DEFAULT_BLOCKSIZE , buildIdIndex , newNameTable ) ; } else { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , size , buildIdIndex , newNameTable ) ; } dtm . setDocumentURI ( source . getSystemId ( ) ) ; addDTM ( dtm , dtmPos , 0 ) ; dom2sax . setContentHandler ( dtm ) ; try { dom2sax . parse ( ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } return dtm ; } else { boolean isSAXSource = ( null != source ) ? ( source instanceof SAXSource ) : true ; boolean isStreamSource = ( null != source ) ? ( source instanceof StreamSource ) : false ; if ( isSAXSource || isStreamSource ) { XMLReader reader ; InputSource xmlSource ; if ( null == source ) { xmlSource = null ; reader = null ; hasUserReader = false ; } else { reader = getXMLReader ( source ) ; xmlSource = SAXSource . sourceToInputSource ( source ) ; String urlOfSource = xmlSource . getSystemId ( ) ; if ( null != urlOfSource ) { try { urlOfSource = SystemIDResolver . getAbsoluteURI ( urlOfSource ) ; } catch ( Exception e ) { System . err . println ( "Can not absolutize URL: " + urlOfSource ) ; } xmlSource . setSystemId ( urlOfSource ) ; } } SAXImpl dtm ; if ( size <= 0 ) { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , DTMDefaultBase . DEFAULT_BLOCKSIZE , buildIdIndex , newNameTable ) ; } else { dtm = new SAXImpl ( this , source , documentID , whiteSpaceFilter , null , doIndexing , size , buildIdIndex , newNameTable ) ; } addDTM ( dtm , dtmPos , 0 ) ; if ( null == reader ) { return dtm ; } reader . setContentHandler ( dtm . getBuilder ( ) ) ; if ( ! hasUserReader || null == reader . getDTDHandler ( ) ) { reader . setDTDHandler ( dtm ) ; } if ( ! hasUserReader || null == reader . getErrorHandler ( ) ) { reader . setErrorHandler ( dtm ) ; } try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , dtm ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } try { reader . parse ( xmlSource ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception e ) { throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } finally { if ( ! hasUserReader ) { releaseXMLReader ( reader ) ; } } if ( DUMPTREE ) { System . out . println ( "Dumping SAX2DOM" ) ; dtm . dumpDTM ( System . err ) ; } return dtm ; } else { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NOT_SUPPORTED , new Object [ ] { source } ) ) ; } } } } 	0	['8', '3', '0', '22', '40', '28', '11', '12', '8', '1.142857143', '327', '1', '0', '0.833333333', '0.575', '1', '5', '39.375', '18', '3.125', '0']
package org . apache . xalan . xsltc . trax ; import java . util . Stack ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . apache . xalan . xsltc . runtime . Constants ; import org . w3c . dom . Comment ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . LexicalHandler ; public class SAX2DOM implements ContentHandler , LexicalHandler , Constants { private Node _root = null ; private Document _document = null ; private Stack _nodeStk = new Stack ( ) ; private Vector _namespaceDecls = null ; public SAX2DOM ( ) throws ParserConfigurationException { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _document = factory . newDocumentBuilder ( ) . newDocument ( ) ; _root = _document ; } public SAX2DOM ( Node root ) throws ParserConfigurationException { _root = root ; if ( root instanceof Document ) { _document = ( Document ) root ; } else if ( root != null ) { _document = root . getOwnerDocument ( ) ; } else { final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; _document = factory . newDocumentBuilder ( ) . newDocument ( ) ; _root = _document ; } } public Node getDOM ( ) { return _root ; } public void characters ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; if ( last != _document ) { final String text = new String ( ch , start , length ) ; last . appendChild ( _document . createTextNode ( text ) ) ; } } public void startDocument ( ) { _nodeStk . push ( _root ) ; } public void endDocument ( ) { _nodeStk . pop ( ) ; } public void startElement ( String namespace , String localName , String qName , Attributes attrs ) { final Element tmp = ( Element ) _document . createElementNS ( namespace , qName ) ; if ( _namespaceDecls != null ) { final int nDecls = _namespaceDecls . size ( ) ; for ( int i = 0 ; i < nDecls ; i ++ ) { final String prefix = ( String ) _namespaceDecls . elementAt ( i ++ ) ; if ( prefix == null || prefix . equals ( EMPTYSTRING ) ) { tmp . setAttributeNS ( XMLNS_URI , XMLNS_PREFIX , ( String ) _namespaceDecls . elementAt ( i ) ) ; } else { tmp . setAttributeNS ( XMLNS_URI , XMLNS_STRING + prefix , ( String ) _namespaceDecls . elementAt ( i ) ) ; } } _namespaceDecls . clear ( ) ; } final int nattrs = attrs . getLength ( ) ; for ( int i = 0 ; i < nattrs ; i ++ ) { if ( attrs . getLocalName ( i ) == null ) { tmp . setAttribute ( attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } else { tmp . setAttributeNS ( attrs . getURI ( i ) , attrs . getQName ( i ) , attrs . getValue ( i ) ) ; } } Node last = ( Node ) _nodeStk . peek ( ) ; last . appendChild ( tmp ) ; _nodeStk . push ( tmp ) ; } public void endElement ( String namespace , String localName , String qName ) { _nodeStk . pop ( ) ; } public void startPrefixMapping ( String prefix , String uri ) { if ( _namespaceDecls == null ) { _namespaceDecls = new Vector ( 2 ) ; } _namespaceDecls . addElement ( prefix ) ; _namespaceDecls . addElement ( uri ) ; } public void endPrefixMapping ( String prefix ) { } public void ignorableWhitespace ( char [ ] ch , int start , int length ) { } public void processingInstruction ( String target , String data ) { final Node last = ( Node ) _nodeStk . peek ( ) ; ProcessingInstruction pi = _document . createProcessingInstruction ( target , data ) ; if ( pi != null ) last . appendChild ( pi ) ; } public void setDocumentLocator ( Locator locator ) { } public void skippedEntity ( String name ) { } public void comment ( char [ ] ch , int start , int length ) { final Node last = ( Node ) _nodeStk . peek ( ) ; Comment comment = _document . createComment ( new String ( ch , start , length ) ) ; if ( comment != null ) last . appendChild ( comment ) ; } public void startCDATA ( ) { } public void endCDATA ( ) { } public void startEntity ( java . lang . String name ) { } public void endDTD ( ) { } public void endEntity ( String name ) { } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { } } 	0	['21', '1', '0', '2', '52', '126', '1', '1', '21', '0.7625', '322', '1', '0', '0', '0.265306122', '0', '0', '14.14285714', '7', '1.381', '0']
package org . apache . xalan . xsltc . dom ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '5', '44', '64', '3', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Mod extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) % right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) % m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Message extends Instruction { private boolean _terminate = false ; public void parseContents ( Parser parser ) { String termstr = getAttribute ( "terminate" ) ; if ( termstr != null ) { _terminate = termstr . equals ( "yes" ) ; } parseChildren ( parser ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( classGen . loadTranslet ( ) ) ; switch ( elementCount ( ) ) { case 0 : il . append ( new PUSH ( cpg , "" ) ) ; break ; case 1 : SyntaxTreeNode child = ( SyntaxTreeNode ) elementAt ( 0 ) ; if ( child instanceof Text ) { il . append ( new PUSH ( cpg , ( ( Text ) child ) . getText ( ) ) ) ; break ; } default : il . append ( methodGen . loadHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STREAM_XML_OUTPUT ) ) ) ; il . append ( methodGen . storeHandler ( ) ) ; il . append ( new NEW ( cpg . addClass ( STRING_WRITER ) ) ) ; il . append ( DUP ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STRING_WRITER , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( STREAM_XML_OUTPUT , "<init>" , "()V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setWriter" , "(" + WRITER_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , "UTF-8" ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setEncoding" , "(" + STRING_SIG + ")V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( ICONST_1 ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "setOmitXMLDeclaration" , "(Z)V" ) ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "startDocument" , "()V" ) ) ) ; translateContents ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( OUTPUT_BASE , "endDocument" , "()V" ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_WRITER , "toString" , "()" + STRING_SIG ) ) ) ; il . append ( SWAP ) ; il . append ( methodGen . storeHandler ( ) ) ; break ; } il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "displayMessage" , "(" + STRING_SIG + ")V" ) ) ) ; if ( _terminate == true ) { final int einit = cpg . addMethodref ( "java.lang.RuntimeException" , "<init>" , "(Ljava/lang/String;)V" ) ; il . append ( new NEW ( cpg . addClass ( "java.lang.RuntimeException" ) ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , "Termination forced by an " + "xsl:message instruction" ) ) ; il . append ( new INVOKESPECIAL ( einit ) ) ; il . append ( ATHROW ) ; } } } 	0	['4', '3', '0', '19', '26', '0', '0', '19', '3', '0.333333333', '311', '1', '0', '0.949152542', '0.4', '2', '6', '76.5', '6', '2.25', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; public final class VoidType extends Type { protected VoidType ( ) { } public String toString ( ) { return "void" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "V" ; } public org . apache . bcel . generic . Type toJCType ( ) { return null ; } public Instruction POP ( ) { return NOP ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( ! clazz . getName ( ) . equals ( "void" ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } } 	0	['9', '2', '0', '13', '20', '36', '1', '13', '8', '2', '85', '0', '0', '0.804878049', '0.351851852', '2', '3', '8.444444444', '2', '1.2222', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncNumber extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsNumber ( xctxt ) ) ; } } 	0	['2', '5', '0', '4', '5', '1', '0', '4', '2', '2', '12', '0', '0', '0.982142857', '0.75', '2', '7', '5', '1', '0.5', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncFalse extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return XBoolean . S_FALSE ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['3', '3', '0', '4', '4', '3', '0', '4', '3', '2', '9', '0', '0', '0.95', '0.5', '1', '6', '2', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xml . serializer . ElemDesc ; import org . apache . xml . serializer . ToHTMLStream ; final class LiteralElement extends Instruction { private String _name ; private LiteralElement _literalElemParent ; private Vector _attributeElements = null ; private Hashtable _accessedPrefixes = null ; private boolean _allAttributesUnique = false ; private final static String XMLNS_STRING = "xmlns" ; public QName getName ( ) { return _qname ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "LiteralElement name = " + _name ) ; displayContents ( indent + IndentIncrement ) ; } private String accessedNamespace ( String prefix ) { if ( _accessedPrefixes == null ) return ( null ) ; else return ( ( String ) _accessedPrefixes . get ( prefix ) ) ; } public void registerNamespace ( String prefix , String uri , SymbolTable stable , boolean declared ) { if ( _literalElemParent != null ) { final String parentUri = _literalElemParent . accessedNamespace ( prefix ) ; if ( parentUri == null ) { _literalElemParent . registerNamespace ( prefix , uri , stable , declared ) ; return ; } if ( parentUri . equals ( uri ) ) return ; } if ( _accessedPrefixes == null ) { _accessedPrefixes = new Hashtable ( ) ; } else { if ( ! declared ) { final String old = ( String ) _accessedPrefixes . get ( prefix ) ; if ( old != null ) { if ( old . equals ( uri ) ) return ; else prefix = stable . generateNamespacePrefix ( ) ; } } } if ( ! prefix . equals ( "xml" ) ) { _accessedPrefixes . put ( prefix , uri ) ; } } private String translateQName ( QName qname , SymbolTable stable ) { String localname = qname . getLocalPart ( ) ; String prefix = qname . getPrefix ( ) ; if ( prefix == null ) prefix = Constants . EMPTYSTRING ; else if ( prefix . equals ( XMLNS_STRING ) ) return ( XMLNS_STRING ) ; final String alternative = stable . lookupPrefixAlias ( prefix ) ; if ( alternative != null ) { stable . excludeNamespaces ( prefix ) ; prefix = alternative ; } String uri = lookupNamespace ( prefix ) ; if ( uri == null ) return ( localname ) ; registerNamespace ( prefix , uri , stable , false ) ; if ( prefix != Constants . EMPTYSTRING ) return ( prefix + ":" + localname ) ; else return ( localname ) ; } public void addAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . add ( attribute ) ; } public void setFirstAttribute ( SyntaxTreeNode attribute ) { if ( _attributeElements == null ) { _attributeElements = new Vector ( 2 ) ; } _attributeElements . insertElementAt ( attribute , 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; node . typeCheck ( stable ) ; } } typeCheckContents ( stable ) ; return Type . Void ; } public Enumeration getNamespaceScope ( SyntaxTreeNode node ) { Hashtable all = new Hashtable ( ) ; while ( node != null ) { Hashtable mapping = node . getPrefixMapping ( ) ; if ( mapping != null ) { Enumeration prefixes = mapping . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; if ( ! all . containsKey ( prefix ) ) { all . put ( prefix , mapping . get ( prefix ) ) ; } } } node = node . getParent ( ) ; } return ( all . keys ( ) ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; stable . setCurrentNode ( this ) ; SyntaxTreeNode _literalElemParent = getParent ( ) ; while ( _literalElemParent != null && ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = _literalElemParent . getParent ( ) ; } if ( ! ( _literalElemParent instanceof LiteralElement ) ) { _literalElemParent = null ; } _name = translateQName ( _qname , stable ) ; final int count = _attributes . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String uri = qname . getNamespace ( ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getUseAttributeSets ( ) ) { if ( ! Util . isValidQNames ( val ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , val , this ) ; parser . reportError ( Constants . ERROR , err ) ; } setFirstAttribute ( new UseAttributeSets ( val , parser ) ) ; } else if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . excludeNamespaces ( val ) ; } else { final String prefix = qname . getPrefix ( ) ; if ( prefix != null && prefix . equals ( XMLNS_PREFIX ) || prefix == null && qname . getLocalPart ( ) . equals ( "xmlns" ) || uri != null && uri . equals ( XSLT_URI ) ) { continue ; } final String name = translateQName ( qname , stable ) ; LiteralAttribute attr = new LiteralAttribute ( name , val , parser ) ; addAttribute ( attr ) ; attr . setParent ( this ) ; attr . parseContents ( parser ) ; } } final Enumeration include = getNamespaceScope ( this ) ; while ( include . hasMoreElements ( ) ) { final String prefix = ( String ) include . nextElement ( ) ; if ( ! prefix . equals ( "xml" ) ) { final String uri = lookupNamespace ( prefix ) ; if ( uri != null && ! stable . isExcludedNamespace ( uri ) ) { registerNamespace ( prefix , uri , stable , true ) ; } } } parseChildren ( parser ) ; for ( int i = 0 ; i < count ; i ++ ) { final QName qname = parser . getQName ( _attributes . getQName ( i ) ) ; final String val = _attributes . getValue ( i ) ; if ( qname == parser . getExtensionElementPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } else if ( qname == parser . getExcludeResultPrefixes ( ) ) { stable . unExcludeNamespaces ( val ) ; } } } protected boolean contextDependent ( ) { return dependentContents ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _allAttributesUnique = checkAttributesUnique ( ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , _name ) ) ; il . append ( DUP2 ) ; il . append ( methodGen . startElement ( ) ) ; int j = 0 ; while ( j < elementCount ( ) ) { final SyntaxTreeNode item = ( SyntaxTreeNode ) elementAt ( j ) ; if ( item instanceof Variable ) { item . translate ( classGen , methodGen ) ; removeElement ( item ) ; } else j ++ ; } if ( _accessedPrefixes != null ) { boolean declaresDefaultNS = false ; Enumeration e = _accessedPrefixes . keys ( ) ; while ( e . hasMoreElements ( ) ) { final String prefix = ( String ) e . nextElement ( ) ; final String uri = ( String ) _accessedPrefixes . get ( prefix ) ; if ( uri != Constants . EMPTYSTRING || prefix != Constants . EMPTYSTRING ) { if ( prefix == Constants . EMPTYSTRING ) { declaresDefaultNS = true ; } il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , prefix ) ) ; il . append ( new PUSH ( cpg , uri ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( ! declaresDefaultNS && ( _parent instanceof XslElement ) && ( ( XslElement ) _parent ) . declaresDefaultNS ( ) ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( new PUSH ( cpg , Constants . EMPTYSTRING ) ) ; il . append ( methodGen . namespace ( ) ) ; } } if ( _attributeElements != null ) { final int count = _attributeElements . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; if ( ! ( node instanceof XslAttribute ) ) { node . translate ( classGen , methodGen ) ; } } } translateContents ( classGen , methodGen ) ; il . append ( methodGen . endElement ( ) ) ; } private boolean isHTMLOutput ( ) { return getStylesheet ( ) . getOutputMethod ( ) == Stylesheet . HTML_OUTPUT ; } public ElemDesc getElemDesc ( ) { if ( isHTMLOutput ( ) ) { return ToHTMLStream . getElemDesc ( _name ) ; } else return null ; } public boolean allAttributesUnique ( ) { return _allAttributesUnique ; } private boolean checkAttributesUnique ( ) { boolean hasHiddenXslAttribute = canProduceAttributeNodes ( this , true ) ; if ( hasHiddenXslAttribute ) return false ; if ( _attributeElements != null ) { int numAttrs = _attributeElements . size ( ) ; Hashtable attrsTable = null ; for ( int i = 0 ; i < numAttrs ; i ++ ) { SyntaxTreeNode node = ( SyntaxTreeNode ) _attributeElements . elementAt ( i ) ; if ( node instanceof UseAttributeSets ) { return false ; } else if ( node instanceof XslAttribute ) { if ( attrsTable == null ) { attrsTable = new Hashtable ( ) ; for ( int k = 0 ; k < i ; k ++ ) { SyntaxTreeNode n = ( SyntaxTreeNode ) _attributeElements . elementAt ( k ) ; if ( n instanceof LiteralAttribute ) { LiteralAttribute literalAttr = ( LiteralAttribute ) n ; attrsTable . put ( literalAttr . getName ( ) , literalAttr ) ; } } } XslAttribute xslAttr = ( XslAttribute ) node ; AttributeValue attrName = xslAttr . getName ( ) ; if ( attrName instanceof AttributeValueTemplate ) { return false ; } else if ( attrName instanceof SimpleAttributeValue ) { SimpleAttributeValue simpleAttr = ( SimpleAttributeValue ) attrName ; String name = simpleAttr . toString ( ) ; if ( name != null && attrsTable . get ( name ) != null ) return false ; else if ( name != null ) { attrsTable . put ( name , xslAttr ) ; } } } } } return true ; } private boolean canProduceAttributeNodes ( SyntaxTreeNode node , boolean ignoreXslAttribute ) { Vector contents = node . getContents ( ) ; int size = contents . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( child instanceof Text ) { Text text = ( Text ) child ; if ( text . isIgnore ( ) ) continue ; else return false ; } else if ( child instanceof LiteralElement || child instanceof ValueOf || child instanceof XslElement || child instanceof Comment || child instanceof Number || child instanceof ProcessingInstruction ) return false ; else if ( child instanceof XslAttribute ) { if ( ignoreXslAttribute ) continue ; else return true ; } else if ( child instanceof CallTemplate || child instanceof ApplyTemplates || child instanceof Copy || child instanceof CopyOf ) return true ; else if ( ( child instanceof If || child instanceof ForEach ) && canProduceAttributeNodes ( child , false ) ) { return true ; } else if ( child instanceof Choose ) { Vector chooseContents = child . getContents ( ) ; int num = chooseContents . size ( ) ; for ( int k = 0 ; k < num ; k ++ ) { SyntaxTreeNode chooseChild = ( SyntaxTreeNode ) chooseContents . elementAt ( k ) ; if ( chooseChild instanceof When || chooseChild instanceof Otherwise ) { if ( canProduceAttributeNodes ( chooseChild , false ) ) return true ; } } } } return false ; } } 	0	['18', '3', '0', '44', '93', '95', '6', '43', '11', '0.833333333', '943', '1', '1', '0.767123288', '0.188888889', '2', '9', '51.05555556', '24', '5.7778', '0']
package org . apache . xalan . extensions ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . templates . StylesheetRoot ; import org . apache . xpath . XPathProcessorException ; import org . apache . xpath . functions . FuncExtFunction ; public class ExtensionsTable { public Hashtable m_extensionFunctionNamespaces = new Hashtable ( ) ; private StylesheetRoot m_sroot ; public ExtensionsTable ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { m_sroot = sroot ; Vector extensions = m_sroot . getExtensions ( ) ; for ( int i = 0 ; i < extensions . size ( ) ; i ++ ) { ExtensionNamespaceSupport extNamespaceSpt = ( ExtensionNamespaceSupport ) extensions . elementAt ( i ) ; ExtensionHandler extHandler = extNamespaceSpt . launch ( ) ; if ( extHandler != null ) addExtensionNamespace ( extNamespaceSpt . getNamespace ( ) , extHandler ) ; } } public ExtensionHandler get ( String extns ) { return ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( extns ) ; } public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; } public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isFunctionAvailable ( funcName ) ; } return isAvailable ; } public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { boolean isAvailable = false ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isElementAvailable ( elemName ) ; } return isAvailable ; } public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; } public Object extFunction ( FuncExtFunction extFunction , Vector argVec , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; String ns = extFunction . getNamespace ( ) ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( extFunction , argVec , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , extFunction . getFunctionName ( ) } ) ) ; } } return result ; } } 	0	['7', '1', '0', '9', '25', '0', '2', '7', '7', '0.5', '199', '0.5', '1', '0', '0.357142857', '0', '0', '27.14285714', '1', '0.8571', '0']
package org . apache . xml . utils . synthetic ; import java . io . IOException ; public class JavaUtils { private static boolean cantLoadCompiler = false ; private static boolean debug = false ; public static void setDebug ( boolean newDebug ) { debug = newDebug ; } public static boolean JDKcompile ( String fileName , String classPath ) { String moreClassPath = System . getProperty ( "org.apache.xml.utils.synthetic.moreclasspath" , "" ) . trim ( ) ; if ( moreClassPath . length ( ) > 0 ) classPath = moreClassPath + ';' + classPath ; if ( debug ) { System . err . println ( "JavaEngine: Compiling " + fileName ) ; System . err . println ( "JavaEngine: Classpath is " + classPath ) ; } String code_option = debug ? "-g" : "-O" ; if ( ! cantLoadCompiler ) { String args [ ] = { code_option , "-classpath" , classPath , fileName } ; } String javac_command = System . getProperty ( "org.apache.xml.utils.synthetic.javac" , "javac" ) ; String args [ ] = { javac_command , code_option , "-classpath" , classPath , fileName } ; try { Process p = java . lang . Runtime . getRuntime ( ) . exec ( args ) ; int compileOK = waitHardFor ( p ) ; return compileOK == 0 ; } catch ( IOException e ) { System . err . println ( "ERROR: IO exception during exec(javac)." ) ; } catch ( SecurityException e ) { System . err . println ( "ERROR: Unable to create subprocess to exec(javac)." ) ; } return false ; } static int waitHardFor ( java . lang . Process p ) { boolean done = false ; while ( ! done ) try { p . waitFor ( ) ; done = true ; } catch ( InterruptedException e ) { System . err . println ( "(Compiler process wait interrupted and resumed)" ) ; } int ev = p . exitValue ( ) ; return ev ; } } 	0	['5', '1', '0', '0', '18', '4', '0', '0', '3', '0.625', '157', '1', '0', '0', '0.25', '0', '0', '30', '6', '1.8', '0']
package org . apache . xml . utils ; public class StringToStringTable { private int m_blocksize ; private String m_map [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToStringTable ( ) { m_blocksize = 16 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; } public StringToStringTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , String value ) { if ( ( m_firstFree + 2 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = key ; m_firstFree ++ ; m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) return m_map [ i + 1 ] ; } return null ; } public final void remove ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) { if ( ( i + 2 ) < m_firstFree ) System . arraycopy ( m_map , i + 2 , m_map , i , m_firstFree - ( i + 2 ) ) ; m_firstFree -= 2 ; m_map [ m_firstFree ] = null ; m_map [ m_firstFree + 1 ] = null ; break ; } } } public final String getIgnoreCase ( String key ) { if ( null == key ) return null ; for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_map [ i + 1 ] ; } return null ; } public final String getByValue ( String val ) { for ( int i = 1 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( val ) ) return m_map [ i - 1 ] ; } return null ; } public final String elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final boolean containsValue ( String val ) { for ( int i = 1 ; i < m_firstFree ; i += 2 ) { if ( m_map [ i ] . equals ( val ) ) return true ; } return false ; } } 	0	['11', '1', '0', '1', '15', '0', '1', '0', '11', '0.45', '286', '1', '0', '0', '0.606060606', '0', '0', '24.63636364', '4', '2.1818', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnparsedEntityUriCall extends FunctionCall { private Expression _entity ; public UnparsedEntityUriCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _entity = argument ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type entity = _entity . typeCheck ( stable ) ; if ( entity instanceof StringType == false ) { _entity = new CastExpr ( _entity , Type . String ) ; } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; _entity . translate ( classGen , methodGen ) ; il . append ( new INVOKEINTERFACE ( cpg . addInterfaceMethodref ( DOM_INTF , GET_UNPARSED_ENTITY_URI , GET_UNPARSED_ENTITY_URI_SIG ) , 2 ) ) ; } } 	0	['3', '4', '0', '15', '14', '0', '0', '15', '3', '0', '63', '1', '1', '0.979591837', '0.444444444', '3', '13', '19.66666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; public interface Translet { public void transform ( DOM document , SerializationHandler handler ) throws TransletException ; public void transform ( DOM document , SerializationHandler [ ] handlers ) throws TransletException ; public void transform ( DOM document , DTMAxisIterator iterator , SerializationHandler handler ) throws TransletException ; public Object addParameter ( String name , Object value ) ; public void buildKeys ( DOM document , DTMAxisIterator iterator , SerializationHandler handler , int root ) throws TransletException ; public void addAuxiliaryClass ( Class auxClass ) ; public Class getAuxiliaryClass ( String className ) ; public String [ ] getNamesArray ( ) ; public String [ ] getUrisArray ( ) ; public int [ ] getTypesArray ( ) ; public String [ ] getNamespaceArray ( ) ; } 	0	['11', '1', '0', '19', '11', '55', '15', '4', '11', '2', '11', '0', '0', '0', '0.262626263', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . operations ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class VariableSafeAbsRef extends Variable { public XObject execute ( XPathContext xctxt , boolean destructiveOK ) throws javax . xml . transform . TransformerException { XNodeSet xns = ( XNodeSet ) super . execute ( xctxt , destructiveOK ) ; DTMManager dtmMgr = xctxt . getDTMManager ( ) ; int context = xctxt . getContextNode ( ) ; if ( dtmMgr . getDTM ( xns . getRoot ( ) ) . getDocument ( ) != dtmMgr . getDTM ( context ) . getDocument ( ) ) { Expression expr = ( Expression ) xns . getContainedIter ( ) ; xns = ( XNodeSet ) expr . asIterator ( xctxt , context ) ; } return xns ; } } 	0	['2', '3', '0', '9', '11', '1', '1', '8', '2', '2', '39', '0', '0', '0.97826087', '0.666666667', '1', '1', '18.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNULL ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Copy extends Instruction { private UseAttributeSets _useSets ; public void parseContents ( Parser parser ) { final String useSets = getAttribute ( "use-attribute-sets" ) ; if ( useSets . length ( ) > 0 ) { if ( ! Util . isValidQNames ( useSets ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . INVALID_QNAME_ERR , useSets , this ) ; parser . reportError ( Constants . ERROR , err ) ; } _useSets = new UseAttributeSets ( useSets , parser ) ; } parseChildren ( parser ) ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Copy" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _useSets != null ) { _useSets . typeCheck ( stable ) ; } typeCheckContents ( stable ) ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen name = methodGen . addLocalVariable2 ( "name" , Util . getJCRefType ( STRING_SIG ) , il . getEnd ( ) ) ; final LocalVariableGen length = methodGen . addLocalVariable2 ( "length" , Util . getJCRefType ( "I" ) , il . getEnd ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final int cpy = cpg . addInterfaceMethodref ( DOM_INTF , "shallowCopy" , "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( cpy , 3 ) ) ; il . append ( DUP ) ; il . append ( new ASTORE ( name . getIndex ( ) ) ) ; final BranchHandle ifBlock1 = il . append ( new IFNULL ( null ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; final int lengthMethod = cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ; il . append ( new INVOKEVIRTUAL ( lengthMethod ) ) ; il . append ( new ISTORE ( length . getIndex ( ) ) ) ; if ( _useSets != null ) { final SyntaxTreeNode parent = getParent ( ) ; if ( ( parent instanceof LiteralElement ) || ( parent instanceof LiteralElement ) ) { _useSets . translate ( classGen , methodGen ) ; } else { il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock2 = il . append ( new IFEQ ( null ) ) ; _useSets . translate ( classGen , methodGen ) ; ifBlock2 . setTarget ( il . append ( NOP ) ) ; } } translateContents ( classGen , methodGen ) ; il . append ( new ILOAD ( length . getIndex ( ) ) ) ; final BranchHandle ifBlock3 = il . append ( new IFEQ ( null ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new ALOAD ( name . getIndex ( ) ) ) ; il . append ( methodGen . endElement ( ) ) ; final InstructionHandle end = il . append ( NOP ) ; ifBlock1 . setTarget ( end ) ; ifBlock3 . setTarget ( end ) ; methodGen . removeLocalVariable ( name ) ; methodGen . removeLocalVariable ( length ) ; } } 	0	['5', '3', '0', '29', '45', '4', '1', '29', '4', '0.5', '267', '1', '1', '0.933333333', '0.333333333', '1', '6', '52.2', '4', '1.8', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; public interface StripWhitespaceFilter { public boolean stripSpace ( DOM dom , int node , int type ) ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; import java . util . Vector ; import java . text . Collator ; import java . text . RuleBasedCollator ; import java . text . CollationElementIterator ; import java . util . Locale ; import java . text . CollationKey ; public class StringComparable implements Comparable { public final static int UNKNOWN_CASE = - 1 ; public final static int UPPER_CASE = 1 ; public final static int LOWER_CASE = 2 ; private String m_text ; private Locale m_locale ; private RuleBasedCollator m_collator ; private String m_caseOrder ; private int m_mask = 0xFFFFFFFF ; public StringComparable ( final String text , final Locale locale , final Collator collator , final String caseOrder ) { m_text = text ; m_locale = locale ; m_collator = ( RuleBasedCollator ) collator ; m_caseOrder = caseOrder ; m_mask = getMask ( m_collator . getStrength ( ) ) ; } public final static Comparable getComparator ( final String text , final Locale locale , final Collator collator , final String caseOrder ) { if ( ( caseOrder == null ) || ( caseOrder . length ( ) == 0 ) ) { return ( ( RuleBasedCollator ) collator ) . getCollationKey ( text ) ; } else { return new StringComparable ( text , locale , collator , caseOrder ) ; } } public final String toString ( ) { return m_text ; } public int compareTo ( Object o ) { final String pattern = ( ( StringComparable ) o ) . toString ( ) ; if ( m_text . equals ( pattern ) ) { return 0 ; } final int savedStrength = m_collator . getStrength ( ) ; int comp = 0 ; if ( ( ( savedStrength == Collator . PRIMARY ) || ( savedStrength == Collator . SECONDARY ) ) ) { comp = m_collator . compare ( m_text , pattern ) ; } else { m_collator . setStrength ( Collator . SECONDARY ) ; comp = m_collator . compare ( m_text , pattern ) ; m_collator . setStrength ( savedStrength ) ; } if ( comp != 0 ) { return comp ; } comp = getCaseDiff ( m_text , pattern ) ; if ( comp != 0 ) { return comp ; } else { return m_collator . compare ( m_text , pattern ) ; } } private final int getCaseDiff ( final String text , final String pattern ) { final int savedStrength = m_collator . getStrength ( ) ; final int savedDecomposition = m_collator . getDecomposition ( ) ; m_collator . setStrength ( Collator . TERTIARY ) ; m_collator . setDecomposition ( Collator . CANONICAL_DECOMPOSITION ) ; final int diff [ ] = getFirstCaseDiff ( text , pattern , m_locale ) ; m_collator . setStrength ( savedStrength ) ; m_collator . setDecomposition ( savedDecomposition ) ; if ( diff != null ) { if ( ( m_caseOrder ) . equals ( "upper-first" ) ) { if ( diff [ 0 ] == UPPER_CASE ) { return - 1 ; } else { return 1 ; } } else { if ( diff [ 0 ] == LOWER_CASE ) { return - 1 ; } else { return 1 ; } } } else { return 0 ; } } private final int [ ] getFirstCaseDiff ( final String text , final String pattern , final Locale locale ) { final CollationElementIterator targIter = m_collator . getCollationElementIterator ( text ) ; final CollationElementIterator patIter = m_collator . getCollationElementIterator ( pattern ) ; int startTarg = - 1 ; int endTarg = - 1 ; int startPatt = - 1 ; int endPatt = - 1 ; final int done = getElement ( CollationElementIterator . NULLORDER ) ; int patternElement = 0 , targetElement = 0 ; boolean getPattern = true , getTarget = true ; while ( true ) { if ( getPattern ) { startPatt = patIter . getOffset ( ) ; patternElement = getElement ( patIter . next ( ) ) ; endPatt = patIter . getOffset ( ) ; } if ( ( getTarget ) ) { startTarg = targIter . getOffset ( ) ; targetElement = getElement ( targIter . next ( ) ) ; endTarg = targIter . getOffset ( ) ; } getTarget = getPattern = true ; if ( ( patternElement == done ) || ( targetElement == done ) ) { return null ; } else if ( targetElement == 0 ) { getPattern = false ; } else if ( patternElement == 0 ) { getTarget = false ; } else if ( targetElement != patternElement ) { if ( ( startPatt < endPatt ) && ( startTarg < endTarg ) ) { final String subText = text . substring ( startTarg , endTarg ) ; final String subPatt = pattern . substring ( startPatt , endPatt ) ; final String subTextUp = subText . toUpperCase ( locale ) ; final String subPattUp = subPatt . toUpperCase ( locale ) ; if ( m_collator . compare ( subTextUp , subPattUp ) != 0 ) { continue ; } int diff [ ] = { UNKNOWN_CASE , UNKNOWN_CASE } ; if ( m_collator . compare ( subText , subTextUp ) == 0 ) { diff [ 0 ] = UPPER_CASE ; } else if ( m_collator . compare ( subText , subText . toLowerCase ( locale ) ) == 0 ) { diff [ 0 ] = LOWER_CASE ; } if ( m_collator . compare ( subPatt , subPattUp ) == 0 ) { diff [ 1 ] = UPPER_CASE ; } else if ( m_collator . compare ( subPatt , subPatt . toLowerCase ( locale ) ) == 0 ) { diff [ 1 ] = LOWER_CASE ; } if ( ( ( diff [ 0 ] == UPPER_CASE ) && ( diff [ 1 ] == LOWER_CASE ) ) || ( ( diff [ 0 ] == LOWER_CASE ) && ( diff [ 1 ] == UPPER_CASE ) ) ) { return diff ; } else { continue ; } } else { continue ; } } } } private static final int getMask ( final int strength ) { switch ( strength ) { case Collator . PRIMARY : return 0xFFFF0000 ; case Collator . SECONDARY : return 0xFFFFFF00 ; default : return 0xFFFFFFFF ; } } private final int getElement ( int maxStrengthElement ) { return ( maxStrengthElement & m_mask ) ; } } 	0	['8', '1', '0', '1', '23', '10', '1', '0', '4', '0.767857143', '390', '0.625', '0', '0', '0.375', '0', '0', '46.75', '19', '4.875', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xpath ; public interface ExpressionOwner { public Expression getExpression ( ) ; public void setExpression ( Expression exp ) ; } 	0	['2', '1', '0', '55', '2', '1', '54', '1', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . transformer ; import java . util . Hashtable ; import java . util . Vector ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class CountersTable extends Hashtable { public CountersTable ( ) { } Vector getCounters ( ElemNumber numberElem ) { Vector counters = ( Vector ) this . get ( numberElem ) ; return ( null == counters ) ? putElemNumber ( numberElem ) : counters ; } Vector putElemNumber ( ElemNumber numberElem ) { Vector counters = new Vector ( ) ; this . put ( numberElem , counters ) ; return counters ; } transient private NodeSetDTM m_newFound ; void appendBtoFList ( NodeSetDTM flist , NodeSetDTM blist ) { int n = blist . size ( ) ; for ( int i = ( n - 1 ) ; i >= 0 ; i -- ) { flist . addElement ( blist . item ( i ) ) ; } } transient int m_countersMade = 0 ; public int countNode ( XPathContext support , ElemNumber numberElem , int node ) throws TransformerException { int count = 0 ; Vector counters = getCounters ( numberElem ) ; int nCounters = counters . size ( ) ; int target = numberElem . getTargetNode ( support , node ) ; if ( DTM . NULL != target ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; count = counter . getPreviouslyCounted ( support , target ) ; if ( count > 0 ) return count ; } count = 0 ; if ( m_newFound == null ) m_newFound = new NodeSetDTM ( support . getDTMManager ( ) ) ; for ( ; DTM . NULL != target ; target = numberElem . getPreviousNode ( support , target ) ) { if ( 0 != count ) { for ( int i = 0 ; i < nCounters ; i ++ ) { Counter counter = ( Counter ) counters . elementAt ( i ) ; int cacheLen = counter . m_countNodes . size ( ) ; if ( ( cacheLen > 0 ) && ( counter . m_countNodes . elementAt ( cacheLen - 1 ) == target ) ) { count += ( cacheLen + counter . m_countNodesStartCount ) ; if ( cacheLen > 0 ) appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; return count ; } } } m_newFound . addElement ( target ) ; count ++ ; } Counter counter = new Counter ( numberElem , new NodeSetDTM ( support . getDTMManager ( ) ) ) ; m_countersMade ++ ; appendBtoFList ( counter . m_countNodes , m_newFound ) ; m_newFound . removeAllElements ( ) ; counters . addElement ( counter ) ; } return count ; } } 	0	['5', '3', '0', '7', '23', '8', '3', '5', '2', '0.875', '198', '0.5', '1', '0.904761905', '0.44', '0', '0', '38.2', '2', '1.2', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Div extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( left . num ( ) / right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . num ( xctxt ) / m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '7', '7', '3', '2', '5', '3', '2', '25', '0', '0', '0.953488372', '0.555555556', '1', '1', '7.333333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc ; import org . apache . xml . dtm . DTM ; public interface NodeIterator extends Cloneable { public static final int END = DTM . NULL ; public int next ( ) ; public NodeIterator reset ( ) ; public int getLast ( ) ; public int getPosition ( ) ; public void setMark ( ) ; public void gotoMark ( ) ; public NodeIterator setStartNode ( int node ) ; public boolean isReverse ( ) ; public NodeIterator cloneIterator ( ) ; public void setRestartable ( boolean isRestartable ) ; } 	0	['10', '1', '0', '1', '10', '45', '1', '0', '10', '1.111111111', '11', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . runtime . output ; class StringOutputBuffer implements OutputBuffer { private StringBuffer _buffer ; public StringOutputBuffer ( ) { _buffer = new StringBuffer ( ) ; } public String close ( ) { return _buffer . toString ( ) ; } public OutputBuffer append ( String s ) { _buffer . append ( s ) ; return this ; } public OutputBuffer append ( char [ ] s , int from , int to ) { _buffer . append ( s , from , to ) ; return this ; } public OutputBuffer append ( char ch ) { _buffer . append ( ch ) ; return this ; } } 	0	['5', '1', '0', '1', '11', '0', '0', '1', '5', '0', '41', '1', '0', '0', '0.36', '0', '0', '7', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; class NameBase extends FunctionCall { private Expression _param = null ; private Type _paramType = Type . Node ; public NameBase ( QName fname ) { super ( fname ) ; } public NameBase ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _param = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { switch ( argumentCount ( ) ) { case 0 : _paramType = Type . Node ; break ; case 1 : _paramType = _param . typeCheck ( stable ) ; break ; default : throw new TypeCheckError ( this ) ; } if ( ( _paramType != Type . NodeSet ) && ( _paramType != Type . Node ) && ( _paramType != Type . Reference ) ) { throw new TypeCheckError ( this ) ; } return ( _type = Type . String ) ; } public Type getType ( ) { return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else if ( _paramType == Type . Node ) { _param . translate ( classGen , methodGen ) ; } else if ( _paramType == Type . Reference ) { _param . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ) ) ; il . append ( methodGen . nextNode ( ) ) ; } else { _param . translate ( classGen , methodGen ) ; _param . startIterator ( classGen , methodGen ) ; il . append ( methodGen . nextNode ( ) ) ; } } } 	0	['5', '4', '3', '17', '21', '0', '3', '14', '5', '0.25', '149', '1', '2', '0.96969697', '0.366666667', '3', '14', '28.4', '4', '1.2', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncString extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( XString ) getArg0AsString ( xctxt ) ; } } 	0	['2', '5', '0', '5', '4', '1', '0', '5', '2', '2', '10', '0', '0', '0.982142857', '0.75', '2', '7', '4', '1', '0.5', '0']
package org . apache . xalan . transformer ; import java . io . OutputStream ; import java . io . Writer ; import java . util . Properties ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; import org . apache . xml . serializer . Method ; import org . apache . xalan . templates . OutputProperties ; import org . xml . sax . ContentHandler ; public class SerializerSwitcher { public static void switchSerializerIfHTML ( TransformerImpl transformer , String ns , String localName ) throws TransformerException { if ( null == transformer ) return ; if ( ( ( null == ns ) || ( ns . length ( ) == 0 ) ) && localName . equalsIgnoreCase ( "html" ) ) { if ( null != transformer . getOutputPropertyNoDefault ( OutputKeys . METHOD ) ) return ; Properties prevProperties = transformer . getOutputFormat ( ) . getProperties ( ) ; OutputProperties htmlOutputProperties = new OutputProperties ( Method . HTML ) ; htmlOutputProperties . copyFrom ( prevProperties , true ) ; Properties htmlProperties = htmlOutputProperties . getProperties ( ) ; try { Serializer oldSerializer = null ; if ( null != oldSerializer ) { Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; Writer writer = oldSerializer . getWriter ( ) ; if ( null != writer ) serializer . setWriter ( writer ) ; else { OutputStream os = oldSerializer . getOutputStream ( ) ; if ( null != os ) serializer . setOutputStream ( os ) ; } ContentHandler ch = serializer . asContentHandler ( ) ; transformer . setContentHandler ( ch ) ; } } catch ( java . io . IOException e ) { throw new TransformerException ( e ) ; } } } private static String getOutputPropertyNoDefault ( String qnameString , Properties props ) throws IllegalArgumentException { String value = ( String ) props . get ( qnameString ) ; return value ; } public static Serializer switchSerializerIfHTML ( String ns , String localName , Properties props , Serializer oldSerializer ) throws TransformerException { Serializer newSerializer = oldSerializer ; if ( ( ( null == ns ) || ( ns . length ( ) == 0 ) ) && localName . equalsIgnoreCase ( "html" ) ) { if ( null != getOutputPropertyNoDefault ( OutputKeys . METHOD , props ) ) return newSerializer ; Properties prevProperties = props ; OutputProperties htmlOutputProperties = new OutputProperties ( Method . HTML ) ; htmlOutputProperties . copyFrom ( prevProperties , true ) ; Properties htmlProperties = htmlOutputProperties . getProperties ( ) ; { if ( null != oldSerializer ) { Serializer serializer = SerializerFactory . getSerializer ( htmlProperties ) ; Writer writer = oldSerializer . getWriter ( ) ; if ( null != writer ) serializer . setWriter ( writer ) ; else { OutputStream os = serializer . getOutputStream ( ) ; if ( null != os ) serializer . setOutputStream ( os ) ; } newSerializer = serializer ; } } } return newSerializer ; } } 	0	['4', '1', '0', '5', '21', '6', '1', '4', '3', '2', '153', '0', '0', '0', '0.4', '0', '0', '37.25', '1', '0.75', '0']
package org . apache . xalan . lib . sql ; import java . util . Vector ; public class ObjectArray { private int m_minArraySize = 10 ; private Vector m_Arrays = new Vector ( 200 ) ; private _ObjectArray m_currentArray ; private int m_nextSlot ; public ObjectArray ( ) { init ( 10 ) ; } public ObjectArray ( final int minArraySize ) { init ( minArraySize ) ; } private void init ( int size ) { m_minArraySize = size ; m_currentArray = new _ObjectArray ( m_minArraySize ) ; } public Object getAt ( final int idx ) { int arrayIndx = idx / m_minArraySize ; int arrayOffset = idx - ( arrayIndx * m_minArraySize ) ; if ( arrayIndx < m_Arrays . size ( ) ) { _ObjectArray a = ( _ObjectArray ) m_Arrays . elementAt ( arrayIndx ) ; return a . objects [ arrayOffset ] ; } else { return m_currentArray . objects [ arrayOffset ] ; } } public void setAt ( final int idx , final Object obj ) { int arrayIndx = idx / m_minArraySize ; int arrayOffset = idx - ( arrayIndx * m_minArraySize ) ; if ( arrayIndx < m_Arrays . size ( ) ) { _ObjectArray a = ( _ObjectArray ) m_Arrays . elementAt ( arrayIndx ) ; a . objects [ arrayOffset ] = obj ; } else { m_currentArray . objects [ arrayOffset ] = obj ; } } public int append ( Object o ) { if ( m_nextSlot >= m_minArraySize ) { m_Arrays . addElement ( m_currentArray ) ; m_nextSlot = 0 ; m_currentArray = new _ObjectArray ( m_minArraySize ) ; } m_currentArray . objects [ m_nextSlot ] = o ; int pos = ( m_Arrays . size ( ) * m_minArraySize ) + m_nextSlot ; m_nextSlot ++ ; return pos ; } class _ObjectArray { public Object [ ] objects ; public _ObjectArray ( int size ) { objects = new Object [ size ] ; } } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; ObjectArray m_ObjectArray = new ObjectArray ( ) ; for ( int x = 0 ; x < word . length ; x ++ ) { System . out . print ( " - " + m_ObjectArray . append ( word [ x ] ) ) ; } System . out . println ( "\n" ) ; for ( int x = 0 ; x < word . length ; x ++ ) { String s = ( String ) m_ObjectArray . getAt ( x ) ; System . out . println ( s ) ; } System . out . println ( ( String ) m_ObjectArray . getAt ( 5 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 10 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 20 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 2 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 15 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 30 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 6 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 8 ) ) ; System . out . println ( ( String ) m_ObjectArray . getAt ( 40 ) ) ; } } 	0	['7', '1', '0', '3', '19', '0', '3', '1', '6', '0.25', '432', '1', '1', '0', '0.464285714', '0', '0', '60.14285714', '3', '1.4286', '0']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; public class Method extends EntryPoint implements Member { public Method ( String name , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; this . name = name ; } public Method ( java . lang . reflect . Method ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Method ( java . lang . reflect . Method realmethod ) { super ( realmethod ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ^ getName ( ) . hashCode ( ) ; } public Object invoke ( Object obj , Object args [ ] ) throws IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Method ) realep ) . invoke ( obj , args ) ; else throw new IllegalAccessException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } public void setReturnType ( org . apache . xml . utils . synthetic . Class returntype ) throws SynthesisException { if ( realep != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . returntype = returntype ; } } 	0	['6', '2', '0', '5', '16', '13', '3', '4', '6', '2', '58', '0', '0', '0.863636364', '0.388888889', '2', '3', '8.666666667', '1', '0.5', '0']
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xml . utils ; import java . io . File ; import org . w3c . dom . Comment ; import org . w3c . dom . Element ; import org . w3c . dom . EntityReference ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; import org . xml . sax . ContentHandler ; import org . xml . sax . Locator ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . LocatorImpl ; public class TreeWalker { private ContentHandler m_contentHandler = null ; protected DOMHelper m_dh ; private LocatorImpl m_locator = new LocatorImpl ( ) ; public ContentHandler getContentHandler ( ) { return m_contentHandler ; } public void setContentHandler ( ContentHandler ch ) { m_contentHandler = ch ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh , String systemId ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; if ( systemId != null ) m_locator . setSystemId ( systemId ) ; else { try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { } } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler , DOMHelper dh ) { this . m_contentHandler = contentHandler ; m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { } m_dh = dh ; } public TreeWalker ( ContentHandler contentHandler ) { this . m_contentHandler = contentHandler ; if ( m_contentHandler != null ) m_contentHandler . setDocumentLocator ( m_locator ) ; try { m_locator . setSystemId ( System . getProperty ( "user.dir" ) + File . separator + "dummy.xsl" ) ; } catch ( SecurityException se ) { } m_dh = new DOM2Helper ( ) ; } public void traverse ( Node pos ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; Node top = pos ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( top . equals ( pos ) ) ) { if ( null != pos ) endNode ( pos ) ; nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } public void traverse ( Node pos , Node top ) throws org . xml . sax . SAXException { this . m_contentHandler . startDocument ( ) ; while ( null != pos ) { startNode ( pos ) ; Node nextNode = pos . getFirstChild ( ) ; while ( null == nextNode ) { endNode ( pos ) ; if ( ( null != top ) && top . equals ( pos ) ) break ; nextNode = pos . getNextSibling ( ) ; if ( null == nextNode ) { pos = pos . getParentNode ( ) ; if ( ( null == pos ) || ( ( null != top ) && top . equals ( pos ) ) ) { nextNode = null ; break ; } } } pos = nextNode ; } this . m_contentHandler . endDocument ( ) ; } boolean nextIsRaw = false ; private final void dispatachChars ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) { ( ( org . apache . xml . dtm . ref . dom2dtm . DOM2DTM . CharacterNodeHandler ) m_contentHandler ) . characters ( node ) ; } else { String data = ( ( Text ) node ) . getData ( ) ; this . m_contentHandler . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } protected void startNode ( Node node ) throws org . xml . sax . SAXException { if ( m_contentHandler instanceof NodeConsumer ) { ( ( NodeConsumer ) m_contentHandler ) . setOriginatingNode ( node ) ; } if ( node instanceof Locator ) { Locator loc = ( Locator ) node ; m_locator . setColumnNumber ( loc . getColumnNumber ( ) ) ; m_locator . setLineNumber ( loc . getLineNumber ( ) ) ; m_locator . setPublicId ( loc . getPublicId ( ) ) ; m_locator . setSystemId ( loc . getSystemId ( ) ) ; } else { m_locator . setColumnNumber ( 0 ) ; m_locator . setLineNumber ( 0 ) ; } switch ( node . getNodeType ( ) ) { case Node . COMMENT_NODE : { String data = ( ( Comment ) node ) . getData ( ) ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . comment ( data . toCharArray ( ) , 0 , data . length ( ) ) ; } } break ; case Node . DOCUMENT_FRAGMENT_NODE : break ; case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . startPrefixMapping ( prefix , attr . getNodeValue ( ) ) ; } } String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . startElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) , new AttList ( atts , m_dh ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : { ProcessingInstruction pi = ( ProcessingInstruction ) node ; String name = pi . getNodeName ( ) ; if ( name . equals ( "xslt-next-is-raw" ) ) { nextIsRaw = true ; } else { this . m_contentHandler . processingInstruction ( pi . getNodeName ( ) , pi . getData ( ) ) ; } } break ; case Node . CDATA_SECTION_NODE : { boolean isLexH = ( m_contentHandler instanceof LexicalHandler ) ; LexicalHandler lh = isLexH ? ( ( LexicalHandler ) this . m_contentHandler ) : null ; if ( isLexH ) { lh . startCDATA ( ) ; } dispatachChars ( node ) ; { if ( isLexH ) { lh . endCDATA ( ) ; } } } break ; case Node . TEXT_NODE : { if ( nextIsRaw ) { nextIsRaw = false ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_DISABLE_OUTPUT_ESCAPING , "" ) ; dispatachChars ( node ) ; m_contentHandler . processingInstruction ( javax . xml . transform . Result . PI_ENABLE_OUTPUT_ESCAPING , "" ) ; } else { dispatachChars ( node ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { ( ( LexicalHandler ) this . m_contentHandler ) . startEntity ( eref . getNodeName ( ) ) ; } else { } } break ; default : } } protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) ) ; NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } } break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( eref . getNodeName ( ) ) ; } } break ; default : } } } 	0	['10', '1', '0', '10', '65', '0', '5', '5', '7', '0.305555556', '611', '0.75', '1', '0', '0.44', '0', '0', '59.7', '1', '0.7', '0']
package org . apache . xalan . xsltc . dom ; public interface DOMBuilder extends ExtendedSAX { } 	0	['0', '1', '0', '4', '0', '0', '3', '1', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . lib . sql ; import java . sql . SQLException ; import java . sql . SQLWarning ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMManager ; public class SQLErrorDocument extends DTMDocument { private static final String S_EXT_ERROR = "ext-error" ; private static final String S_SQL_ERROR = "sql-error" ; private static final String S_MESSAGE = "message" ; private static final String S_CODE = "code" ; private static final String S_STATE = "state" ; private static final String S_SQL_WARNING = "sql-warning" ; private int m_ErrorExt_TypeID = DTM . NULL ; private int m_Message_TypeID = DTM . NULL ; private int m_Code_TypeID = DTM . NULL ; private int m_State_TypeID = DTM . NULL ; private int m_SQLWarning_TypeID = DTM . NULL ; private int m_SQLError_TypeID = DTM . NULL ; private int m_rootID = DTM . NULL ; private int m_extErrorID = DTM . NULL ; private int m_MainMessageID = DTM . NULL ; public SQLErrorDocument ( DTMManager mgr , int ident , SQLException error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; int sqlError = addElement ( 2 , m_SQLError_TypeID , m_extErrorID , m_MainMessageID ) ; int element = DTM . NULL ; element = addElementWithData ( new Integer ( error . getErrorCode ( ) ) , 3 , m_Code_TypeID , sqlError , element ) ; element = addElementWithData ( error . getLocalizedMessage ( ) , 3 , m_Message_TypeID , sqlError , element ) ; } public SQLErrorDocument ( DTMManager mgr , int ident , Exception error ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; } public SQLErrorDocument ( DTMManager mgr , int ident , Exception error , SQLWarning warning , boolean full ) { super ( mgr , ident ) ; createExpandedNameTable ( ) ; buildBasicStructure ( error ) ; SQLException se = null ; int prev = m_MainMessageID ; boolean inWarnings = false ; if ( error != null && error instanceof SQLException ) se = ( SQLException ) error ; else if ( full && warning != null ) { se = warning ; inWarnings = true ; } while ( se != null ) { int sqlError = addElement ( 2 , inWarnings ? m_SQLWarning_TypeID : m_SQLError_TypeID , m_extErrorID , prev ) ; prev = sqlError ; int element = DTM . NULL ; element = addElementWithData ( new Integer ( se . getErrorCode ( ) ) , 3 , m_Code_TypeID , sqlError , element ) ; element = addElementWithData ( se . getLocalizedMessage ( ) , 3 , m_Message_TypeID , sqlError , element ) ; if ( full ) { String state = se . getSQLState ( ) ; if ( state != null && state . length ( ) > 0 ) element = addElementWithData ( state , 3 , m_State_TypeID , sqlError , element ) ; if ( inWarnings ) se = ( ( SQLWarning ) se ) . getNextWarning ( ) ; else se = se . getNextException ( ) ; } else se = null ; } } private void buildBasicStructure ( Exception e ) { m_rootID = addElement ( 0 , m_Document_TypeID , DTM . NULL , DTM . NULL ) ; m_extErrorID = addElement ( 1 , m_ErrorExt_TypeID , m_rootID , DTM . NULL ) ; m_MainMessageID = addElementWithData ( e != null ? e . getLocalizedMessage ( ) : "SQLWarning" , 2 , m_Message_TypeID , m_extErrorID , DTM . NULL ) ; } protected void createExpandedNameTable ( ) { super . createExpandedNameTable ( ) ; m_ErrorExt_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_EXT_ERROR , DTM . ELEMENT_NODE ) ; m_SQLError_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL_ERROR , DTM . ELEMENT_NODE ) ; m_Message_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_MESSAGE , DTM . ELEMENT_NODE ) ; m_Code_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_CODE , DTM . ELEMENT_NODE ) ; m_State_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_STATE , DTM . ELEMENT_NODE ) ; m_SQLWarning_TypeID = m_expandedNameTable . getExpandedTypeID ( S_NAMESPACE , S_SQL_WARNING , DTM . ELEMENT_NODE ) ; } } 	0	['5', '5', '0', '4', '18', '0', '1', '3', '3', '0.616666667', '353', '1', '0', '0.989528796', '0.485714286', '1', '1', '66.6', '2', '0.6', '0']
package org . apache . xalan . templates ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . SAXSourceLocator ; import org . apache . xpath . Expression ; import org . apache . xpath . XPathContext ; import org . apache . xpath . functions . Function3Args ; import org . apache . xpath . functions . WrongNumberArgsException ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncFormatNumb extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { ElemTemplateElement templElem = ( ElemTemplateElement ) xctxt . getNamespaceContext ( ) ; StylesheetRoot ss = templElem . getStylesheetRoot ( ) ; java . text . DecimalFormat formatter = null ; java . text . DecimalFormatSymbols dfs = null ; double num = getArg0 ( ) . execute ( xctxt ) . num ( ) ; String patternStr = getArg1 ( ) . execute ( xctxt ) . str ( ) ; if ( patternStr . indexOf ( 0x00A4 ) > 0 ) ss . error ( XSLTErrorResources . ER_CURRENCY_SIGN_ILLEGAL ) ; try { Expression arg2Expr = getArg2 ( ) ; if ( null != arg2Expr ) { String dfName = arg2Expr . execute ( xctxt ) . str ( ) ; QName qname = new QName ( dfName , xctxt . getNamespaceContext ( ) ) ; dfs = ss . getDecimalFormatComposed ( qname ) ; if ( null == dfs ) { warn ( xctxt , XSLTErrorResources . WG_NO_DECIMALFORMAT_DECLARATION , new Object [ ] { dfName } ) ; } else { formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; formatter . applyLocalizedPattern ( patternStr ) ; } } if ( null == formatter ) { dfs = ss . getDecimalFormatComposed ( new QName ( "" ) ) ; if ( dfs != null ) { formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; formatter . applyLocalizedPattern ( patternStr ) ; } else { dfs = new java . text . DecimalFormatSymbols ( java . util . Locale . US ) ; dfs . setInfinity ( Constants . ATTRVAL_INFINITY ) ; dfs . setNaN ( Constants . ATTRVAL_NAN ) ; formatter = new java . text . DecimalFormat ( ) ; formatter . setDecimalFormatSymbols ( dfs ) ; if ( null != patternStr ) formatter . applyLocalizedPattern ( patternStr ) ; } } return new XString ( formatter . format ( num ) ) ; } catch ( Exception iae ) { templElem . error ( XSLTErrorResources . ER_MALFORMED_FORMAT_STRING , new Object [ ] { patternStr } ) ; return XString . EMPTYSTRING ; } } public void warn ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; errHandler . warning ( new TransformerException ( formattedMsg , ( SAXSourceLocator ) xctxt . getSAXLocator ( ) ) ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( ( argNum > 3 ) || ( argNum < 2 ) ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createMessage ( XSLTErrorResources . ER_TWO_OR_THREE , null ) ) ; } } 	0	['5', '6', '0', '13', '35', '10', '1', '12', '4', '2', '183', '0', '0', '0.941176471', '0.4', '2', '8', '35.6', '1', '0.8', '0']
package org . apache . xml . utils ; public class StringToIntTable { public static final int INVALID_KEY = - 10000 ; private int m_blocksize ; private String m_map [ ] ; private int m_values [ ] ; private int m_firstFree = 0 ; private int m_mapSize ; public StringToIntTable ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; m_values = new int [ m_blocksize ] ; } public StringToIntTable ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; m_values = new int [ m_blocksize ] ; } public final int getLength ( ) { return m_firstFree ; } public final void put ( String key , int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; int newValues [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_values , 0 , newValues , 0 , m_firstFree + 1 ) ; m_values = newValues ; } m_map [ m_firstFree ] = key ; m_values [ m_firstFree ] = value ; m_firstFree ++ ; } public final int get ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final int getIgnoreCase ( String key ) { if ( null == key ) return INVALID_KEY ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( key ) ) return m_values [ i ] ; } return INVALID_KEY ; } public final boolean contains ( String key ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( key ) ) return true ; } return false ; } public final String [ ] keys ( ) { String [ ] keysArr = new String [ m_firstFree ] ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { keysArr [ i ] = m_map [ i ] ; } return keysArr ; } } 	0	['8', '1', '0', '2', '12', '0', '2', '0', '8', '0.523809524', '217', '0.833333333', '0', '0', '0.583333333', '0', '0', '25.375', '4', '1.875', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Equals extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . equals ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject left = m_left . execute ( xctxt , true ) ; XObject right = m_right . execute ( xctxt , true ) ; boolean result = left . equals ( right ) ? true : false ; left . detach ( ) ; right . detach ( ) ; return result ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '40', '0', '0', '0.953488372', '0.555555556', '2', '2', '12.33333333', '1', '0.6667', '0']
package org . apache . xml . utils ; public class ObjectVector implements Cloneable { protected int m_blocksize ; protected Object m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public ObjectVector ( ) { m_blocksize = 32 ; m_mapSize = m_blocksize ; m_map = new Object [ m_blocksize ] ; } public ObjectVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new Object [ blocksize ] ; } public ObjectVector ( int blocksize , int increaseSize ) { m_blocksize = increaseSize ; m_mapSize = blocksize ; m_map = new Object [ blocksize ] ; } public ObjectVector ( ObjectVector v ) { m_map = new Object [ v . m_mapSize ] ; m_mapSize = v . m_mapSize ; m_firstFree = v . m_firstFree ; m_blocksize = v . m_blocksize ; System . arraycopy ( v . m_map , 0 , m_map , 0 , m_firstFree ) ; } public final int size ( ) { return m_firstFree ; } public final void setSize ( int sz ) { m_firstFree = sz ; } public final void addElement ( Object value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final void addElements ( Object value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } public final void addElements ( int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_firstFree += numberOfElements ; } public final void insertElementAt ( Object value , int at ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } if ( at <= ( m_firstFree - 1 ) ) { System . arraycopy ( m_map , at , m_map , at + 1 , m_firstFree - at ) ; } m_map [ at ] = value ; m_firstFree ++ ; } public final void removeAllElements ( ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { m_map [ i ] = null ; } m_firstFree = 0 ; } public final boolean removeElement ( Object s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + 1 ) < m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i - 1 , m_firstFree - i ) ; else m_map [ i ] = null ; m_firstFree -- ; return true ; } } return false ; } public final void removeElementAt ( int i ) { if ( i > m_firstFree ) System . arraycopy ( m_map , i + 1 , m_map , i , m_firstFree ) ; else m_map [ i ] = null ; m_firstFree -- ; } public final void setElementAt ( Object value , int index ) { m_map [ index ] = value ; } public final Object elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( Object s ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) return true ; } return false ; } public final int indexOf ( Object elem , int index ) { for ( int i = index ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int indexOf ( Object elem ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final int lastIndexOf ( Object elem ) { for ( int i = ( m_firstFree - 1 ) ; i >= 0 ; i -- ) { if ( m_map [ i ] == elem ) return i ; } return java . lang . Integer . MIN_VALUE ; } public final void setToSize ( int size ) { Object newMap [ ] = new Object [ size ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree ) ; m_mapSize = size ; m_map = newMap ; } public Object clone ( ) throws CloneNotSupportedException { return new ObjectVector ( this ) ; } } 	0	['21', '1', '1', '5', '23', '0', '5', '0', '21', '0.3375', '516', '1', '0', '0', '0.5', '0', '0', '23.38095238', '4', '1.7143', '0']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncSubstring extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; double start = m_arg1 . execute ( xctxt ) . num ( ) ; int lenOfS1 = s1 . length ( ) ; XMLString substr ; if ( lenOfS1 <= 0 ) return XString . EMPTYSTRING ; else { int startIndex ; if ( Double . isNaN ( start ) ) { start = - 1000000 ; startIndex = 0 ; } else { start = Math . round ( start ) ; startIndex = ( start > 0 ) ? ( int ) start - 1 : 0 ; } if ( null != m_arg2 ) { double len = m_arg2 . num ( xctxt ) ; int end = ( int ) ( Math . round ( len ) + start ) - 1 ; if ( end < 0 ) end = 0 ; else if ( end > lenOfS1 ) end = lenOfS1 ; if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex , end ) ; } else { if ( startIndex > lenOfS1 ) startIndex = lenOfS1 ; substr = s1 . substring ( startIndex ) ; } } return ( XString ) substr ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_TWO_OR_THREE , null ) ) ; } } 	0	['4', '6', '0', '8', '16', '6', '0', '8', '3', '2', '113', '0', '0', '0.955223881', '0.5', '2', '8', '27.25', '1', '0.75', '0']
package org . apache . xalan . lib . sql ; import java . sql . Connection ; import java . sql . SQLException ; import java . util . Properties ; public interface ConnectionPool { public boolean isEnabled ( ) ; public void setDriver ( String d ) ; public void setURL ( String url ) ; public void freeUnused ( ) ; public boolean hasActiveConnections ( ) ; public void setPassword ( String p ) ; public void setUser ( String u ) ; public void setMinConnections ( int n ) ; public boolean testConnection ( ) ; public Connection getConnection ( ) throws SQLException ; public void releaseConnection ( Connection con ) throws SQLException ; public void releaseConnectionOnError ( Connection con ) throws SQLException ; public void setPoolEnabled ( final boolean flag ) ; public void setProtocol ( Properties p ) ; } 	0	['14', '1', '0', '4', '14', '91', '4', '0', '14', '2', '14', '0', '0', '0', '0.273809524', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AttributeValueTemplate extends AttributeValue { public AttributeValueTemplate ( String value , Parser parser , SyntaxTreeNode parent ) { setParent ( parent ) ; setParser ( parser ) ; if ( check ( value , parser ) ) { parseAVTemplate ( 0 , value , parser ) ; } } private void parseAVTemplate ( final int start , String text , Parser parser ) { String str ; if ( text == null ) return ; int open = start - 2 ; do { open = text . indexOf ( '{' , open + 2 ) ; } while ( ( open != - 1 ) && ( open < ( text . length ( ) - 1 ) ) && ( text . charAt ( open + 1 ) == '{' ) ) ; if ( open != - 1 ) { int close = open - 2 ; do { close = text . indexOf ( '}' , close + 2 ) ; } while ( ( close != - 1 ) && ( close < ( text . length ( ) - 1 ) ) && ( text . charAt ( close + 1 ) == '}' ) ) ; if ( open > start ) { str = removeDuplicateBraces ( text . substring ( start , open ) ) ; addElement ( new LiteralExpr ( str ) ) ; } if ( close > open + 1 ) { str = text . substring ( open + 1 , close ) ; str = removeDuplicateBraces ( text . substring ( open + 1 , close ) ) ; addElement ( parser . parseExpression ( this , str ) ) ; } parseAVTemplate ( close + 1 , text , parser ) ; } else if ( start < text . length ( ) ) { str = removeDuplicateBraces ( text . substring ( start ) ) ; addElement ( new LiteralExpr ( str ) ) ; } } public String removeDuplicateBraces ( String orig ) { String result = orig ; int index ; while ( ( index = result . indexOf ( "{{" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } while ( ( index = result . indexOf ( "}}" ) ) != - 1 ) { result = result . substring ( 0 , index ) + result . substring ( index + 1 , result . length ( ) ) ; } return ( result ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Vector contents = getContents ( ) ; final int n = contents . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Expression exp = ( Expression ) contents . elementAt ( i ) ; if ( ! exp . typeCheck ( stable ) . identicalTo ( Type . String ) ) { contents . setElementAt ( new CastExpr ( exp , Type . String ) , i ) ; } } return _type = Type . String ; } public String toString ( ) { final StringBuffer buffer = new StringBuffer ( "AVT:[" ) ; final int count = elementCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { buffer . append ( elementAt ( i ) . toString ( ) ) ; if ( i < count - 1 ) buffer . append ( ' ' ) ; } return buffer . append ( ']' ) . toString ( ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( elementCount ( ) == 1 ) { final Expression exp = ( Expression ) elementAt ( 0 ) ; exp . translate ( classGen , methodGen ) ; } else { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int initBuffer = cpg . addMethodref ( STRING_BUFFER_CLASS , "<init>" , "()V" ) ; final Instruction append = new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_BUFFER_CLASS , "append" , "(" + STRING_SIG + ")" + STRING_BUFFER_SIG ) ) ; final int toString = cpg . addMethodref ( STRING_BUFFER_CLASS , "toString" , "()" + STRING_SIG ) ; il . append ( new NEW ( cpg . addClass ( STRING_BUFFER_CLASS ) ) ) ; il . append ( DUP ) ; il . append ( new INVOKESPECIAL ( initBuffer ) ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { final Expression exp = ( Expression ) elements . nextElement ( ) ; exp . translate ( classGen , methodGen ) ; il . append ( append ) ; } il . append ( new INVOKEVIRTUAL ( toString ) ) ; } } private boolean check ( String value , Parser parser ) { if ( value == null ) return true ; final char [ ] chars = value . toCharArray ( ) ; int level = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case '{' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '{' ) ) ++ level ; else i ++ ; break ; case '}' : if ( ( ( i + 1 ) == ( chars . length ) ) || ( chars [ i + 1 ] != '}' ) ) -- level ; else i ++ ; break ; default : continue ; } switch ( level ) { case 0 : case 1 : continue ; default : reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } } if ( level != 0 ) { reportError ( getParent ( ) , parser , ErrorMsg . ATTR_VAL_TEMPLATE_ERR , value ) ; return false ; } return true ; } } 	0	['7', '4', '0', '23', '51', '21', '5', '19', '5', '2', '452', '0', '0', '0.923076923', '0.339285714', '2', '7', '63.57142857', '14', '5.1429', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeSortRecordFactGenerator extends ClassGenerator { public NodeSortRecordFactGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; } public boolean isExternal ( ) { return true ; } } 	0	['2', '4', '0', '3', '3', '1', '1', '2', '2', '2', '13', '0', '0', '0.987804878', '0.6', '0', '0', '5.5', '1', '0.5', '0']
package org . apache . xml . utils ; import java . util . EmptyStackException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class NamespaceSupport2 extends org . xml . sax . helpers . NamespaceSupport { private Context2 currentContext ; public final static String XMLNS = "http://www.w3.org/XML/1998/namespace" ; public NamespaceSupport2 ( ) { reset ( ) ; } public void reset ( ) { currentContext = new Context2 ( null ) ; currentContext . declarePrefix ( "xml" , XMLNS ) ; } public void pushContext ( ) { Context2 parentContext = currentContext ; currentContext = parentContext . getChild ( ) ; if ( currentContext == null ) { currentContext = new Context2 ( parentContext ) ; } else { currentContext . setParent ( parentContext ) ; } } public void popContext ( ) { Context2 parentContext = currentContext . getParent ( ) ; if ( parentContext == null ) throw new EmptyStackException ( ) ; else currentContext = parentContext ; } public boolean declarePrefix ( String prefix , String uri ) { if ( prefix . equals ( "xml" ) || prefix . equals ( "xmlns" ) ) { return false ; } else { currentContext . declarePrefix ( prefix , uri ) ; return true ; } } public String [ ] processName ( String qName , String [ ] parts , boolean isAttribute ) { String [ ] name = currentContext . processName ( qName , isAttribute ) ; if ( name == null ) return null ; System . arraycopy ( name , 0 , parts , 0 , 3 ) ; return parts ; } public String getURI ( String prefix ) { return currentContext . getURI ( prefix ) ; } public Enumeration getPrefixes ( ) { return currentContext . getPrefixes ( ) ; } public String getPrefix ( String uri ) { return currentContext . getPrefix ( uri ) ; } public Enumeration getPrefixes ( String uri ) { return new PrefixForUriEnumerator ( this , uri , getPrefixes ( ) ) ; } public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } } class PrefixForUriEnumerator implements Enumeration { private Enumeration allPrefixes ; private String uri ; private String lookahead = null ; private NamespaceSupport2 nsup ; PrefixForUriEnumerator ( NamespaceSupport2 nsup , String uri , Enumeration allPrefixes ) { this . nsup = nsup ; this . uri = uri ; this . allPrefixes = allPrefixes ; } public boolean hasMoreElements ( ) { if ( lookahead != null ) return true ; while ( allPrefixes . hasMoreElements ( ) ) { String prefix = ( String ) allPrefixes . nextElement ( ) ; if ( uri . equals ( nsup . getURI ( prefix ) ) ) { lookahead = prefix ; return true ; } } return false ; } public Object nextElement ( ) { if ( hasMoreElements ( ) ) { String tmp = lookahead ; lookahead = null ; return tmp ; } else throw new java . util . NoSuchElementException ( ) ; } } final class Context2 { private final static Enumeration EMPTY_ENUMERATION = new Vector ( ) . elements ( ) ; Hashtable prefixTable ; Hashtable uriTable ; Hashtable elementNameTable ; Hashtable attributeNameTable ; String defaultNS = null ; private Vector declarations = null ; private boolean tablesDirty = false ; private Context2 parent = null ; private Context2 child = null ; Context2 ( Context2 parent ) { if ( parent == null ) { prefixTable = new Hashtable ( ) ; uriTable = new Hashtable ( ) ; elementNameTable = null ; attributeNameTable = null ; } else setParent ( parent ) ; } Context2 getChild ( ) { return child ; } Context2 getParent ( ) { return parent ; } void setParent ( Context2 parent ) { this . parent = parent ; parent . child = this ; declarations = null ; prefixTable = parent . prefixTable ; uriTable = parent . uriTable ; elementNameTable = parent . elementNameTable ; attributeNameTable = parent . attributeNameTable ; defaultNS = parent . defaultNS ; tablesDirty = false ; } void declarePrefix ( String prefix , String uri ) { if ( ! tablesDirty ) { copyTables ( ) ; } if ( declarations == null ) { declarations = new Vector ( ) ; } prefix = prefix . intern ( ) ; uri = uri . intern ( ) ; if ( "" . equals ( prefix ) ) { if ( "" . equals ( uri ) ) { defaultNS = null ; } else { defaultNS = uri ; } } else { prefixTable . put ( prefix , uri ) ; uriTable . put ( uri , prefix ) ; } declarations . addElement ( prefix ) ; } String [ ] processName ( String qName , boolean isAttribute ) { String name [ ] ; Hashtable table ; if ( isAttribute ) { if ( elementNameTable == null ) elementNameTable = new Hashtable ( ) ; table = elementNameTable ; } else { if ( attributeNameTable == null ) attributeNameTable = new Hashtable ( ) ; table = attributeNameTable ; } name = ( String [ ] ) table . get ( qName ) ; if ( name != null ) { return name ; } name = new String [ 3 ] ; int index = qName . indexOf ( ':' ) ; if ( index == - 1 ) { if ( isAttribute || defaultNS == null ) { name [ 0 ] = "" ; } else { name [ 0 ] = defaultNS ; } name [ 1 ] = qName . intern ( ) ; name [ 2 ] = name [ 1 ] ; } else { String prefix = qName . substring ( 0 , index ) ; String local = qName . substring ( index + 1 ) ; String uri ; if ( "" . equals ( prefix ) ) { uri = defaultNS ; } else { uri = ( String ) prefixTable . get ( prefix ) ; } if ( uri == null ) { return null ; } name [ 0 ] = uri ; name [ 1 ] = local . intern ( ) ; name [ 2 ] = qName . intern ( ) ; } table . put ( name [ 2 ] , name ) ; tablesDirty = true ; return name ; } String getURI ( String prefix ) { if ( "" . equals ( prefix ) ) { return defaultNS ; } else if ( prefixTable == null ) { return null ; } else { return ( String ) prefixTable . get ( prefix ) ; } } String getPrefix ( String uri ) { if ( uriTable == null ) { return null ; } else { return ( String ) uriTable . get ( uri ) ; } } Enumeration getDeclaredPrefixes ( ) { if ( declarations == null ) { return EMPTY_ENUMERATION ; } else { return declarations . elements ( ) ; } } Enumeration getPrefixes ( ) { if ( prefixTable == null ) { return EMPTY_ENUMERATION ; } else { return prefixTable . keys ( ) ; } } private void copyTables ( ) { prefixTable = ( Hashtable ) prefixTable . clone ( ) ; uriTable = ( Hashtable ) uriTable . clone ( ) ; if ( elementNameTable != null ) elementNameTable = new Hashtable ( ) ; if ( attributeNameTable != null ) attributeNameTable = new Hashtable ( ) ; tablesDirty = true ; } } 	0	['11', '2', '0', '3', '26', '0', '2', '2', '11', '0.55', '127', '0.5', '1', '0.583333333', '0.409090909', '1', '3', '10.36363636', '3', '1.3636', '0']
package org . apache . xml . serializer ; import java . util . Vector ; public interface XSLOutputAttributes { public String getDoctypePublic ( ) ; public String getDoctypeSystem ( ) ; public String getEncoding ( ) ; public boolean getIndent ( ) ; public int getIndentAmount ( ) ; public String getMediaType ( ) ; public boolean getOmitXMLDeclaration ( ) ; public String getStandalone ( ) ; public String getVersion ( ) ; public void setCdataSectionElements ( Vector URI_and_localNames ) ; public void setDoctype ( String system , String pub ) ; public void setDoctypePublic ( String doctype ) ; public void setDoctypeSystem ( String doctype ) ; public void setEncoding ( String encoding ) ; public void setIndent ( boolean indent ) ; public void setMediaType ( String mediatype ) ; public void setOmitXMLDeclaration ( boolean b ) ; public void setStandalone ( String standalone ) ; public void setVersion ( String version ) ; } 	0	['19', '1', '0', '1', '19', '171', '1', '0', '19', '2', '19', '0', '0', '0', '0.381578947', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . lib ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExpressionContext ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . NodeSet ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPath ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . SAXNotSupportedException ; public class ExsltDynamic extends ExsltBase { public static final String EXSL_URI = "http://exslt.org/common" ; public static double max ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double maxValue = - Double . MAX_VALUE ; for ( int i = 0 ; i < contextNodes . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result > maxValue ) maxValue = result ; } xctxt . popContextNodeList ( ) ; return maxValue ; } public static double min ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double minValue = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; if ( result < minValue ) minValue = result ; } xctxt . popContextNodeList ( ) ; return minValue ; } public static double sum ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return Double . NaN ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; double sum = 0 ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; double result = 0 ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; result = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) . num ( ) ; } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return Double . NaN ; } xctxt . popCurrentNode ( ) ; sum = sum + result ; } xctxt . popContextNodeList ( ) ; return sum ; } public static NodeList map ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; Document lDoc = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( nl , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; NodeSet resultSet = new NodeSet ( ) ; resultSet . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! resultSet . contains ( n ) ) resultSet . addNode ( n ) ; } } else { if ( lDoc == null ) { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; lDoc = db . newDocument ( ) ; } Element element = null ; if ( object instanceof XNumber ) element = lDoc . createElementNS ( EXSL_URI , "exsl:number" ) ; else if ( object instanceof XBoolean ) element = lDoc . createElementNS ( EXSL_URI , "exsl:boolean" ) ; else element = lDoc . createElementNS ( EXSL_URI , "exsl:string" ) ; Text textNode = lDoc . createTextNode ( object . str ( ) ) ; element . appendChild ( textNode ) ; resultSet . addNode ( element ) ; } } catch ( Exception e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; return resultSet ; } public static XObject evaluate ( ExpressionContext myContext , String xpathExpr ) throws SAXNotSupportedException { if ( myContext instanceof XPathContext . XPathExpressionContext ) { XPathContext xctxt = null ; try { xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; XPath dynamicXPath = new XPath ( xpathExpr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; return dynamicXPath . execute ( xctxt , myContext . getContextNode ( ) , xctxt . getNamespaceContext ( ) ) ; } catch ( TransformerException e ) { return new XNodeSet ( xctxt . getDTMManager ( ) ) ; } } else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; } public static NodeList closure ( ExpressionContext myContext , NodeList nl , String expr ) throws SAXNotSupportedException { XPathContext xctxt = null ; if ( myContext instanceof XPathContext . XPathExpressionContext ) xctxt = ( ( XPathContext . XPathExpressionContext ) myContext ) . getXPathContext ( ) ; else throw new SAXNotSupportedException ( XSLMessages . createMessage ( XSLTErrorResources . ER_INVALID_CONTEXT_PASSED , new Object [ ] { myContext } ) ) ; if ( expr == null || expr . length ( ) == 0 ) return new NodeSet ( ) ; NodeSet closureSet = new NodeSet ( ) ; closureSet . setShouldCacheNodes ( true ) ; NodeList iterationList = nl ; do { NodeSet iterationSet = new NodeSet ( ) ; NodeSetDTM contextNodes = new NodeSetDTM ( iterationList , xctxt ) ; xctxt . pushContextNodeList ( contextNodes ) ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { int contextNode = contextNodes . item ( i ) ; xctxt . pushCurrentNode ( contextNode ) ; XObject object = null ; try { XPath dynamicXPath = new XPath ( expr , xctxt . getSAXLocator ( ) , xctxt . getNamespaceContext ( ) , XPath . SELECT ) ; object = dynamicXPath . execute ( xctxt , contextNode , xctxt . getNamespaceContext ( ) ) ; if ( object instanceof XNodeSet ) { NodeList nodelist = null ; nodelist = ( ( XNodeSet ) object ) . nodelist ( ) ; for ( int k = 0 ; k < nodelist . getLength ( ) ; k ++ ) { Node n = nodelist . item ( k ) ; if ( ! iterationSet . contains ( n ) ) iterationSet . addNode ( n ) ; } } else { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } } catch ( TransformerException e ) { xctxt . popCurrentNode ( ) ; xctxt . popContextNodeList ( ) ; return new NodeSet ( ) ; } xctxt . popCurrentNode ( ) ; } xctxt . popContextNodeList ( ) ; iterationList = iterationSet ; for ( int i = 0 ; i < iterationList . getLength ( ) ; i ++ ) { Node n = iterationList . item ( i ) ; if ( ! closureSet . contains ( n ) ) closureSet . addNode ( n ) ; } } while ( iterationList . getLength ( ) > 0 ) ; return closureSet ; } } 	0	['7', '2', '0', '16', '43', '21', '1', '15', '7', '1.166666667', '682', '0', '0', '0.25', '0.642857143', '0', '0', '96.28571429', '1', '0.8571', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class AlternativePattern extends Pattern { private final Pattern _left ; private final Pattern _right ; public AlternativePattern ( Pattern left , Pattern right ) { _left = left ; _right = right ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public Pattern getLeft ( ) { return _left ; } public Pattern getRight ( ) { return _right ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _left . typeCheck ( stable ) ; _right . typeCheck ( stable ) ; return null ; } public double getPriority ( ) { double left = _left . getPriority ( ) ; double right = _right . getPriority ( ) ; if ( left < right ) return ( left ) ; else return ( right ) ; } public String toString ( ) { return "alternative(" + _left + ", " + _right + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _left . translate ( classGen , methodGen ) ; final InstructionHandle gotot = il . append ( new GOTO ( null ) ) ; il . append ( methodGen . loadContextNode ( ) ) ; _right . translate ( classGen , methodGen ) ; _left . _trueList . backPatch ( gotot ) ; _left . _falseList . backPatch ( gotot . getNext ( ) ) ; _trueList . append ( _right . _trueList . add ( gotot ) ) ; _falseList . append ( _right . _falseList ) ; } } 	0	['8', '4', '0', '15', '27', '0', '1', '14', '8', '0.142857143', '135', '1', '2', '0.925531915', '0.270833333', '2', '3', '15.625', '2', '1', '0']
package org . apache . xml . utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . lib ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public abstract class ExsltBase { protected static String toString ( Node n ) { if ( n instanceof DTMNodeProxy ) return ( ( DTMNodeProxy ) n ) . getStringValue ( ) ; else { String value = n . getNodeValue ( ) ; if ( value == null ) { NodeList nodelist = n . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Node childNode = nodelist . item ( i ) ; buf . append ( toString ( childNode ) ) ; } return buf . toString ( ) ; } else return value ; } } protected static double toNumber ( Node n ) { double d = 0.0 ; String str = toString ( n ) ; try { d = Double . valueOf ( str ) . doubleValue ( ) ; } catch ( NumberFormatException e ) { d = Double . NaN ; } return d ; } } 	0	['3', '1', '4', '5', '14', '3', '4', '1', '1', '2', '62', '0', '0', '0', '0.5', '0', '0', '19.66666667', '4', '1.6667', '0']
package org . apache . xalan . lib ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExsltMath extends ExsltBase { private static String PI = "3.1415926535897932384626433832795028841971693993751" ; private static String E = "2.71828182845904523536028747135266249775724709369996" ; private static String SQRRT2 = "1.41421356237309504880168872420969807856967187537694" ; private static String LN2 = "0.69314718055994530941723212145817656807550013436025" ; private static String LN10 = "2.302585092994046" ; private static String LOG2E = "1.4426950408889633" ; private static String SQRT1_2 = "0.7071067811865476" ; public static double max ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = - Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d > m ) m = d ; } return m ; } public static double min ( NodeList nl ) { if ( nl == null || nl . getLength ( ) == 0 ) return Double . NaN ; double m = Double . MAX_VALUE ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( Double . isNaN ( d ) ) return Double . NaN ; else if ( d < m ) m = d ; } return m ; } public static NodeList highest ( NodeList nl ) { double maxValue = max ( nl ) ; NodeSet highNodes = new NodeSet ( ) ; highNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( maxValue ) ) return highNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == maxValue ) highNodes . addElement ( n ) ; } return highNodes ; } public static NodeList lowest ( NodeList nl ) { double minValue = min ( nl ) ; NodeSet lowNodes = new NodeSet ( ) ; lowNodes . setShouldCacheNodes ( true ) ; if ( Double . isNaN ( minValue ) ) return lowNodes ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node n = nl . item ( i ) ; double d = toNumber ( n ) ; if ( d == minValue ) lowNodes . addElement ( n ) ; } return lowNodes ; } public static double abs ( double num ) { return Math . abs ( num ) ; } public static double acos ( double num ) { return Math . acos ( num ) ; } public static double asin ( double num ) { return Math . asin ( num ) ; } public static double atan ( double num ) { return Math . atan ( num ) ; } public static double atan2 ( double num1 , double num2 ) { return Math . atan2 ( num1 , num2 ) ; } public static double cos ( double num ) { return Math . cos ( num ) ; } public static double exp ( double num ) { return Math . exp ( num ) ; } public static double log ( double num ) { return Math . log ( num ) ; } public static double power ( double num1 , double num2 ) { return Math . pow ( num1 , num2 ) ; } public static double random ( ) { return Math . random ( ) ; } public static double sin ( double num ) { return Math . sin ( num ) ; } public static double sqrt ( double num ) { return Math . sqrt ( num ) ; } public static double tan ( double num ) { return Math . tan ( num ) ; } public static double constant ( String name , double precision ) { String value = null ; if ( name . equals ( "PI" ) ) value = PI ; else if ( name . equals ( "E" ) ) value = E ; else if ( name . equals ( "SQRRT2" ) ) value = SQRRT2 ; else if ( name . equals ( "LN2" ) ) value = LN2 ; else if ( name . equals ( "LN10" ) ) value = LN10 ; else if ( name . equals ( "LOG2E" ) ) value = LOG2E ; else if ( name . equals ( "SQRT1_2" ) ) value = SQRT1_2 ; if ( value != null ) { int bits = new Double ( precision ) . intValue ( ) ; if ( bits <= value . length ( ) ) value = value . substring ( 0 , bits ) ; return new Double ( value ) . doubleValue ( ) ; } else return Double . NaN ; } } 	0	['20', '2', '0', '2', '48', '188', '0', '2', '19', '0.947368421', '312', '1', '0', '0.1', '0.25', '0', '0', '14.25', '10', '2.15', '0']
package org . apache . xalan . transformer ; import java . util . Vector ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; public class KeyManager { private transient Vector m_key_tables = null ; public XNodeSet getNodeSetDTMByKey ( XPathContext xctxt , int doc , QName name , XMLString ref , PrefixResolver nscontext ) throws javax . xml . transform . TransformerException { XNodeSet nl = null ; ElemTemplateElement template = ( ElemTemplateElement ) nscontext ; if ( ( null != template ) && null != template . getStylesheetRoot ( ) . getKeysComposed ( ) ) { boolean foundDoc = false ; if ( null == m_key_tables ) { m_key_tables = new Vector ( 4 ) ; } else { int nKeyTables = m_key_tables . size ( ) ; for ( int i = 0 ; i < nKeyTables ; i ++ ) { KeyTable kt = ( KeyTable ) m_key_tables . elementAt ( i ) ; if ( kt . getKeyTableName ( ) . equals ( name ) && doc == kt . getDocKey ( ) ) { nl = kt . getNodeSetDTMByKey ( name , ref ) ; if ( nl != null ) { foundDoc = true ; break ; } } } } if ( ( null == nl ) && ! foundDoc ) { KeyTable kt = new KeyTable ( doc , nscontext , name , template . getStylesheetRoot ( ) . getKeysComposed ( ) , xctxt ) ; m_key_tables . addElement ( kt ) ; if ( doc == kt . getDocKey ( ) ) { foundDoc = true ; nl = kt . getNodeSetDTMByKey ( name , ref ) ; } } } return nl ; } } 	0	['2', '1', '0', '10', '14', '0', '2', '8', '2', '0', '104', '1', '0', '0', '0.583333333', '0', '0', '50.5', '1', '0.5', '0']
package org . apache . xalan . xsltc ; public interface DOMEnhancedForDTM extends DOM { public short [ ] getMapping ( String [ ] names , String [ ] uris , int [ ] types ) ; public int [ ] getReverseMapping ( String [ ] names , String [ ] uris , int [ ] types ) ; public short [ ] getNamespaceMapping ( String [ ] namespaces ) ; public short [ ] getReverseNamespaceMapping ( String [ ] namespaces ) ; public String getDocumentURI ( ) ; public void setDocumentURI ( String uri ) ; public int getExpandedTypeID2 ( int nodeHandle ) ; public boolean hasDOMSource ( ) ; public int getElementById ( String idString ) ; } 	0	['9', '1', '0', '9', '9', '36', '8', '1', '9', '2', '9', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . ObjectType ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; final class Param extends VariableBase { private boolean _isInSimpleNamedTemplate = false ; public String toString ( ) { return "param(" + _name + ")" ; } public Instruction setLoadInstruction ( Instruction instruction ) { Instruction tmp = _loadInstruction ; _loadInstruction = instruction ; return tmp ; } public Instruction setStoreInstruction ( Instruction instruction ) { Instruction tmp = _storeInstruction ; _storeInstruction = instruction ; return tmp ; } public void display ( int indent ) { indent ( indent ) ; System . out . println ( "param " + _name ) ; if ( _select != null ) { indent ( indent + IndentIncrement ) ; System . out . println ( "select " + _select . toString ( ) ) ; } displayContents ( indent + IndentIncrement ) ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; final SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Param param = parser . getSymbolTable ( ) . lookupParam ( _name ) ; if ( param != null ) { final int us = this . getImportPrecedence ( ) ; final int them = param . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { param . disable ( ) ; } } ( ( Stylesheet ) parent ) . addParam ( this ) ; parser . getSymbolTable ( ) . addParam ( this ) ; } else if ( parent instanceof Template ) { Template template = ( Template ) parent ; _isLocal = true ; template . addParameter ( this ) ; if ( template . isSimpleNamedTemplate ( ) ) { _isInSimpleNamedTemplate = true ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; if ( _type instanceof ReferenceType == false && ! ( _type instanceof ObjectType ) ) { _select = new CastExpr ( _select , Type . Reference ) ; } } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; } _type = Type . Reference ; return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _ignore ) return ; _ignore = true ; final String name = BasisLibrary . mapQNameToJavaName ( _name . toString ( ) ) ; final String signature = _type . toSignature ( ) ; final String className = _type . getClassName ( ) ; if ( isLocal ( ) ) { if ( _isInSimpleNamedTemplate ) { il . append ( loadInstruction ( ) ) ; BranchHandle ifBlock = il . append ( new IFNONNULL ( null ) ) ; translateValue ( classGen , methodGen ) ; il . append ( storeInstruction ( ) ) ; ifBlock . setTarget ( il . append ( NOP ) ) ; return ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } _type . translateUnBox ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { _local = methodGen . addLocalVariable2 ( name , _type . toJCType ( ) , il . getEnd ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , name ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUSH ( cpg , true ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , ADD_PARAMETER , ADD_PARAMETER_SIG ) ) ) ; _type . translateUnBox ( classGen , methodGen ) ; if ( className != EMPTYSTRING ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	0	['8', '4', '0', '40', '70', '8', '11', '34', '7', '0.714285714', '435', '1', '0', '0.915662651', '0.267857143', '3', '18', '53.25', '8', '2.625', '0']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . Class ; import org . apache . xml . utils . synthetic . SynthesisException ; public class Field extends Object implements Member { public String name , initializer = null ; int modifiers ; java . lang . reflect . Field realfield = null ; Class declaringClass , type ; public Field ( java . lang . reflect . Field realfield , org . apache . xml . utils . synthetic . Class declaringClass ) { this ( realfield . getName ( ) , declaringClass ) ; this . realfield = realfield ; this . type = org . apache . xml . utils . synthetic . Class . forClass ( realfield . getType ( ) ) ; } public Field ( String name , org . apache . xml . utils . synthetic . Class declaringClass ) { this . name = name ; this . declaringClass = declaringClass ; } public boolean equals ( Object obj ) { if ( realfield != null ) return realfield . equals ( obj ) ; else if ( obj instanceof Field ) { Field objf = ( Field ) obj ; return ( declaringClass . equals ( objf . declaringClass ) && name . equals ( objf . name ) && type . equals ( objf . type ) ) ; } else return false ; } public Object get ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . get ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public boolean getBoolean ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getBoolean ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public byte getByte ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getByte ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public char getChar ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getChar ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) { if ( realfield != null ) return org . apache . xml . utils . synthetic . Class . forClass ( realfield . getDeclaringClass ( ) ) ; throw new java . lang . IllegalStateException ( ) ; } public double getDouble ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getDouble ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public float getFloat ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getFloat ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public int getInt ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getInt ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public long getLong ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getLong ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public int getModifiers ( ) { if ( realfield != null ) modifiers = realfield . getModifiers ( ) ; return modifiers ; } public String getInitializer ( ) { return initializer ; } public void setInitializer ( String i ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; initializer = i ; } public java . lang . String getName ( ) { return name ; } public short getShort ( Object obj ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) return realfield . getShort ( obj ) ; throw new java . lang . IllegalStateException ( ) ; } public Class getType ( ) { if ( realfield != null ) type = Class . forClass ( realfield . getType ( ) ) ; return type ; } public void setType ( org . apache . xml . utils . synthetic . Class type ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . type = type ; } public int hashCode ( ) { if ( realfield != null ) return realfield . hashCode ( ) ; else return declaringClass . getName ( ) . hashCode ( ) ^ name . hashCode ( ) ; } public void set ( Object obj , Object value ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . set ( obj , value ) ; throw new java . lang . IllegalStateException ( ) ; } public void setBoolean ( Object obj , boolean z ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setBoolean ( obj , z ) ; throw new java . lang . IllegalStateException ( ) ; } public void setByte ( Object obj , byte b ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setByte ( obj , b ) ; throw new java . lang . IllegalStateException ( ) ; } public void setChar ( Object obj , char c ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setChar ( obj , c ) ; throw new java . lang . IllegalStateException ( ) ; } public void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) { this . declaringClass = declaringClass ; } public void setDouble ( Object obj , double d ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setDouble ( obj , d ) ; throw new java . lang . IllegalStateException ( ) ; } public void setFloat ( Object obj , float f ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setFloat ( obj , f ) ; throw new java . lang . IllegalStateException ( ) ; } public void setInt ( Object obj , int i ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setInt ( obj , i ) ; throw new java . lang . IllegalStateException ( ) ; } public void setLong ( Object obj , long l ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setLong ( obj , l ) ; throw new java . lang . IllegalStateException ( ) ; } public void setModifiers ( int modifiers ) throws SynthesisException { if ( realfield != null ) throw new SynthesisException ( SynthesisException . REIFIED ) ; this . modifiers = modifiers ; } public void setShort ( Object obj , short s ) throws IllegalArgumentException , IllegalAccessException { if ( realfield != null ) realfield . setShort ( obj , s ) ; throw new java . lang . IllegalStateException ( ) ; } public String toString ( ) { if ( realfield != null ) return realfield . toString ( ) ; throw new java . lang . IllegalStateException ( ) ; } public String toSource ( ) { StringBuffer sb = new StringBuffer ( java . lang . reflect . Modifier . toString ( getModifiers ( ) ) ) . append ( ' ' ) . append ( getType ( ) . getJavaName ( ) ) . append ( ' ' ) . append ( getName ( ) ) ; String i = getInitializer ( ) ; if ( i != null && i . length ( ) > 0 ) sb . append ( '=' ) . append ( i ) ; sb . append ( ';' ) ; return sb . toString ( ) ; } } 	0	['33', '1', '0', '3', '73', '0', '1', '3', '33', '0.75', '469', '0', '2', '0', '0.158508159', '1', '1', '13.03030303', '6', '1.303', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncLocalPart extends FunctionDef1Arg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = getArg0AsNode ( xctxt ) ; if ( DTM . NULL == context ) return XString . EMPTYSTRING ; DTM dtm = xctxt . getDTM ( context ) ; String s = ( context != DTM . NULL ) ? dtm . getLocalName ( context ) : "" ; if ( s . startsWith ( "#" ) || s . equals ( "xmlns" ) ) return XString . EMPTYSTRING ; return new XString ( s ) ; } } 	0	['2', '5', '0', '5', '9', '1', '0', '5', '2', '2', '42', '0', '0', '0.982142857', '0.75', '3', '8', '20', '1', '0.5', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class Neg extends UnaryOperation { public XObject operate ( XObject right ) throws javax . xml . transform . TransformerException { return new XNumber ( - right . num ( ) ) ; } public double num ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return - ( m_right . num ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '3', '1', '5', '3', '2', '19', '0', '0', '0.952380952', '0.555555556', '1', '1', '5.333333333', '1', '0.6667', '0']
package org . apache . xml . dtm . ref ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMDOMException ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeFilter ; public class DTMNodeIterator implements org . w3c . dom . traversal . NodeIterator { private DTMIterator dtm_iter ; private boolean valid = true ; public DTMNodeIterator ( DTMIterator dtmIterator ) { try { dtm_iter = ( DTMIterator ) dtmIterator . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } public DTMIterator getDTMIterator ( ) { return dtm_iter ; } public void detach ( ) { valid = false ; } public boolean getExpandEntityReferences ( ) { return false ; } public NodeFilter getFilter ( ) { throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; } public Node getRoot ( ) { int handle = dtm_iter . getRoot ( ) ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public int getWhatToShow ( ) { return dtm_iter . getWhatToShow ( ) ; } public Node nextNode ( ) throws DOMException { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . nextNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } public Node previousNode ( ) { if ( ! valid ) throw new DTMDOMException ( DOMException . INVALID_STATE_ERR ) ; int handle = dtm_iter . previousNode ( ) ; if ( handle == DTM . NULL ) return null ; return dtm_iter . getDTM ( handle ) . getNode ( handle ) ; } } 	0	['9', '1', '0', '10', '19', '0', '6', '4', '9', '0.5', '106', '1', '1', '0', '0.555555556', '0', '0', '10.55555556', '3', '1.1111', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncFloor extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( java . lang . Math . floor ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xml . utils ; public interface DOMOrder { public int getUid ( ) ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . lib . sql ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . dom ; public final class EmptyFilter implements Filter { public boolean test ( int node ) { return true ; } } 	0	['2', '1', '0', '1', '3', '1', '0', '1', '2', '2', '7', '0', '0', '0', '0.75', '0', '0', '2.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . cmdline ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncCeiling extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( Math . ceil ( m_arg0 . execute ( xctxt ) . num ( ) ) ) ; } } 	0	['2', '4', '0', '5', '7', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime ; import org . apache . xalan . xsltc . DOM ; import org . xml . sax . AttributeList ; public final class Attributes implements AttributeList { private int _element ; private DOM _document ; public Attributes ( DOM document , int element ) { _element = element ; _document = document ; } public int getLength ( ) { return 0 ; } public String getName ( int i ) { return null ; } public String getType ( int i ) { return null ; } public String getType ( String name ) { return null ; } public String getValue ( int i ) { return null ; } public String getValue ( String name ) { return null ; } } 	0	['7', '1', '0', '1', '8', '21', '0', '1', '7', '1', '30', '1', '1', '0', '0.5', '0', '0', '3', '1', '0.8571', '0']
package org . apache . xpath . compiler ; public class XPathDumper { } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . dtm . ref ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . transform . Source ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . sax . SAXSource ; import javax . xml . transform . stream . StreamSource ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMException ; import org . apache . xml . dtm . DTMFilter ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . dtm . DTMManager ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . dtm . ref . dom2dtm . DOM2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2DTM ; import org . apache . xml . dtm . ref . sax2dtm . SAX2RTFDTM ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; import org . apache . xml . utils . PrefixResolver ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xml . utils . XMLReaderManager ; import org . apache . xml . utils . XMLStringFactory ; import org . w3c . dom . Document ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; public class DTMManagerDefault extends DTMManager { private static final boolean DUMPTREE = false ; private static final boolean DEBUG = false ; protected DTM m_dtms [ ] = new DTM [ 256 ] ; int m_dtm_offsets [ ] = new int [ 256 ] ; protected XMLReaderManager m_readerManager = null ; synchronized public void addDTM ( DTM dtm , int id ) { addDTM ( dtm , id , 0 ) ; } synchronized public void addDTM ( DTM dtm , int id , int offset ) { if ( id >= IDENT_MAX_DTMS ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_DTMIDS_AVAIL , null ) ) ; } int oldlen = m_dtms . length ; if ( oldlen <= id ) { int newlen = Math . min ( ( id + 256 ) , IDENT_MAX_DTMS ) ; DTM new_m_dtms [ ] = new DTM [ newlen ] ; System . arraycopy ( m_dtms , 0 , new_m_dtms , 0 , oldlen ) ; m_dtms = new_m_dtms ; int new_m_dtm_offsets [ ] = new int [ newlen ] ; System . arraycopy ( m_dtm_offsets , 0 , new_m_dtm_offsets , 0 , oldlen ) ; m_dtm_offsets = new_m_dtm_offsets ; } m_dtms [ id ] = dtm ; m_dtm_offsets [ id ] = offset ; dtm . documentRegistration ( ) ; } synchronized public int getFirstFreeDTMID ( ) { int n = m_dtms . length ; for ( int i = 1 ; i < n ; i ++ ) { if ( null == m_dtms [ i ] ) { return i ; } } return n ; } private ExpandedNameTable m_expandedNameTable = new ExpandedNameTable ( ) ; public DTMManagerDefault ( ) { } synchronized public DTM getDTM ( Source source , boolean unique , DTMWSFilter whiteSpaceFilter , boolean incremental , boolean doIndexing ) { if ( DEBUG && null != source ) System . out . println ( "Starting " + ( unique ? "UNIQUE" : "shared" ) + " source: " + source . getSystemId ( ) ) ; XMLStringFactory xstringFactory = m_xsf ; int dtmPos = getFirstFreeDTMID ( ) ; int documentID = dtmPos << IDENT_DTM_NODE_BITS ; if ( ( null != source ) && source instanceof DOMSource ) { DOM2DTM dtm = new DOM2DTM ( this , ( DOMSource ) source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; addDTM ( dtm , dtmPos , 0 ) ; return dtm ; } else { boolean isSAXSource = ( null != source ) ? ( source instanceof SAXSource ) : true ; boolean isStreamSource = ( null != source ) ? ( source instanceof StreamSource ) : false ; if ( isSAXSource || isStreamSource ) { XMLReader reader = null ; try { InputSource xmlSource ; if ( null == source ) { xmlSource = null ; } else { reader = getXMLReader ( source ) ; xmlSource = SAXSource . sourceToInputSource ( source ) ; String urlOfSource = xmlSource . getSystemId ( ) ; if ( null != urlOfSource ) { try { urlOfSource = SystemIDResolver . getAbsoluteURI ( urlOfSource ) ; } catch ( Exception e ) { System . err . println ( "Can not absolutize URL: " + urlOfSource ) ; } xmlSource . setSystemId ( urlOfSource ) ; } } SAX2DTM dtm ; if ( source == null && unique && ! incremental && ! doIndexing ) { dtm = new SAX2RTFDTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } else { dtm = new SAX2DTM ( this , source , documentID , whiteSpaceFilter , xstringFactory , doIndexing ) ; } addDTM ( dtm , dtmPos , 0 ) ; boolean haveXercesParser = ( null != reader ) && ( reader . getClass ( ) . getName ( ) . equals ( "org.apache.xerces.parsers.SAXParser" ) ) ; if ( haveXercesParser ) { incremental = true ; } if ( m_incremental && incremental ) { IncrementalSAXSource coParser = null ; if ( haveXercesParser ) { try { coParser = ( IncrementalSAXSource ) Class . forName ( "org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces" ) . newInstance ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; coParser = null ; } } if ( coParser == null ) { if ( null == reader ) { coParser = new IncrementalSAXSource_Filter ( ) ; } else { IncrementalSAXSource_Filter filter = new IncrementalSAXSource_Filter ( ) ; filter . setXMLReader ( reader ) ; coParser = filter ; } } dtm . setIncrementalSAXSource ( coParser ) ; if ( null == xmlSource ) { return dtm ; } if ( null == reader . getErrorHandler ( ) ) { reader . setErrorHandler ( dtm ) ; } reader . setDTDHandler ( dtm ) ; try { coParser . startParse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } else { if ( null == reader ) { return dtm ; } reader . setContentHandler ( dtm ) ; reader . setDTDHandler ( dtm ) ; if ( null == reader . getErrorHandler ( ) ) { reader . setErrorHandler ( dtm ) ; } try { reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , dtm ) ; } catch ( SAXNotRecognizedException e ) { } catch ( SAXNotSupportedException e ) { } try { reader . parse ( xmlSource ) ; } catch ( RuntimeException re ) { dtm . clearCoRoutine ( ) ; throw re ; } catch ( Exception e ) { dtm . clearCoRoutine ( ) ; throw new org . apache . xml . utils . WrappedRuntimeException ( e ) ; } } if ( DUMPTREE ) { System . out . println ( "Dumping SAX2DOM" ) ; dtm . dumpDTM ( System . err ) ; } return dtm ; } finally { releaseXMLReader ( reader ) ; } } else { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NOT_SUPPORTED , new Object [ ] { source } ) ) ; } } } synchronized public int getDTMHandleFromNode ( org . w3c . dom . Node node ) { if ( null == node ) throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NODE_NON_NULL , null ) ) ; if ( node instanceof org . apache . xml . dtm . ref . DTMNodeProxy ) return ( ( org . apache . xml . dtm . ref . DTMNodeProxy ) node ) . getDTMNodeNumber ( ) ; else { int max = m_dtms . length ; for ( int i = 0 ; i < max ; i ++ ) { DTM thisDTM = m_dtms [ i ] ; if ( ( null != thisDTM ) && thisDTM instanceof DOM2DTM ) { int handle = ( ( DOM2DTM ) thisDTM ) . getHandleOfNode ( node ) ; if ( handle != DTM . NULL ) return handle ; } } Node root = node ; Node p = ( root . getNodeType ( ) == Node . ATTRIBUTE_NODE ) ? ( ( org . w3c . dom . Attr ) root ) . getOwnerElement ( ) : root . getParentNode ( ) ; for ( ; p != null ; p = p . getParentNode ( ) ) { root = p ; } DOM2DTM dtm = ( DOM2DTM ) getDTM ( new javax . xml . transform . dom . DOMSource ( root ) , false , null , true , true ) ; int handle ; if ( node instanceof org . apache . xml . dtm . ref . dom2dtm . DOM2DTMdefaultNamespaceDeclarationNode ) { handle = dtm . getHandleOfNode ( ( ( org . w3c . dom . Attr ) node ) . getOwnerElement ( ) ) ; handle = dtm . getAttributeNode ( handle , node . getNamespaceURI ( ) , node . getLocalName ( ) ) ; } else handle = ( ( DOM2DTM ) dtm ) . getHandleOfNode ( node ) ; if ( DTM . NULL == handle ) throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_COULD_NOT_RESOLVE_NODE , null ) ) ; return handle ; } } synchronized public XMLReader getXMLReader ( Source inputSource ) { try { XMLReader reader = ( inputSource instanceof SAXSource ) ? ( ( SAXSource ) inputSource ) . getXMLReader ( ) : null ; if ( null == reader ) { if ( m_readerManager == null ) { m_readerManager = XMLReaderManager . getInstance ( ) ; } reader = m_readerManager . getXMLReader ( ) ; } return reader ; } catch ( SAXException se ) { throw new DTMException ( se . getMessage ( ) , se ) ; } } synchronized public void releaseXMLReader ( XMLReader reader ) { if ( m_readerManager != null ) { m_readerManager . releaseXMLReader ( reader ) ; } } synchronized public DTM getDTM ( int nodeHandle ) { try { return m_dtms [ nodeHandle > > > IDENT_DTM_NODE_BITS ] ; } catch ( java . lang . ArrayIndexOutOfBoundsException e ) { if ( nodeHandle == DTM . NULL ) return null ; else throw e ; } } synchronized public int getDTMIdentity ( DTM dtm ) { if ( dtm instanceof DTMDefaultBase ) { DTMDefaultBase dtmdb = ( DTMDefaultBase ) dtm ; if ( dtmdb . getManager ( ) == this ) return dtmdb . getDTMIDs ( ) . elementAt ( 0 ) ; else return - 1 ; } int n = m_dtms . length ; for ( int i = 0 ; i < n ; i ++ ) { DTM tdtm = m_dtms [ i ] ; if ( tdtm == dtm && m_dtm_offsets [ i ] == 0 ) return i << IDENT_DTM_NODE_BITS ; } return - 1 ; } synchronized public boolean release ( DTM dtm , boolean shouldHardDelete ) { if ( DEBUG ) { System . out . println ( "Releasing " + ( shouldHardDelete ? "HARD" : "soft" ) + " dtm=" + dtm . getDocumentBaseURI ( ) ) ; } if ( dtm instanceof SAX2DTM ) { ( ( SAX2DTM ) dtm ) . clearCoRoutine ( ) ; } if ( dtm instanceof DTMDefaultBase ) { org . apache . xml . utils . SuballocatedIntVector ids = ( ( DTMDefaultBase ) dtm ) . getDTMIDs ( ) ; for ( int i = ids . size ( ) - 1 ; i >= 0 ; -- i ) m_dtms [ ids . elementAt ( i ) > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } else { int i = getDTMIdentity ( dtm ) ; if ( i >= 0 ) { m_dtms [ i > > > DTMManager . IDENT_DTM_NODE_BITS ] = null ; } } dtm . documentRelease ( ) ; return true ; } synchronized public DTM createDocumentFragment ( ) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . newDocument ( ) ; Node df = doc . createDocumentFragment ( ) ; return getDTM ( new DOMSource ( df ) , true , null , false , false ) ; } catch ( Exception e ) { throw new DTMException ( e ) ; } } synchronized public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return null ; } synchronized public DTMIterator createDTMIterator ( String xpathString , PrefixResolver presolver ) { return null ; } synchronized public DTMIterator createDTMIterator ( int node ) { return null ; } synchronized public DTMIterator createDTMIterator ( Object xpathCompiler , int pos ) { return null ; } public ExpandedNameTable getExpandedNameTable ( DTM dtm ) { return m_expandedNameTable ; } } 	0	['17', '2', '1', '26', '81', '86', '7', '22', '17', '0.791666667', '736', '0.833333333', '3', '0.542857143', '0.196078431', '1', '1', '41.94117647', '25', '3.9412', '0']
package org . apache . xalan . processor ; import org . xml . sax . Attributes ; public class ProcessorUnknown extends ProcessorLRE { } 	0	['1', '6', '0', '2', '2', '0', '1', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . dtm ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import javax . xml . transform . SourceLocator ; import org . apache . xml . res . XMLErrorResources ; import org . apache . xml . res . XMLMessages ; public class DTMException extends RuntimeException { SourceLocator locator ; public SourceLocator getLocator ( ) { return locator ; } public void setLocator ( SourceLocator location ) { locator = location ; } Throwable containedException ; public Throwable getException ( ) { return containedException ; } public Throwable getCause ( ) { return ( ( containedException == this ) ? null : containedException ) ; } public synchronized Throwable initCause ( Throwable cause ) { if ( ( this . containedException == null ) && ( cause != null ) ) { throw new IllegalStateException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CANNOT_OVERWRITE_CAUSE , null ) ) ; } if ( cause == this ) { throw new IllegalArgumentException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_SELF_CAUSATION_NOT_PERMITTED , null ) ) ; } this . containedException = cause ; return this ; } public DTMException ( String message ) { super ( message ) ; this . containedException = null ; this . locator = null ; } public DTMException ( Throwable e ) { super ( e . getMessage ( ) ) ; this . containedException = e ; this . locator = null ; } public DTMException ( String message , Throwable e ) { super ( ( ( message == null ) || ( message . length ( ) == 0 ) ) ? e . getMessage ( ) : message ) ; this . containedException = e ; this . locator = null ; } public DTMException ( String message , SourceLocator locator ) { super ( message ) ; this . containedException = null ; this . locator = locator ; } public DTMException ( String message , SourceLocator locator , Throwable e ) { super ( message ) ; this . containedException = e ; this . locator = locator ; } public String getMessageAndLocation ( ) { StringBuffer sbuffer = new StringBuffer ( ) ; String message = super . getMessage ( ) ; if ( null != message ) { sbuffer . append ( message ) ; } if ( null != locator ) { String systemID = locator . getSystemId ( ) ; int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; if ( null != systemID ) { sbuffer . append ( "; SystemID: " ) ; sbuffer . append ( systemID ) ; } if ( 0 != line ) { sbuffer . append ( "; Line#: " ) ; sbuffer . append ( line ) ; } if ( 0 != column ) { sbuffer . append ( "; Column#: " ) ; sbuffer . append ( column ) ; } } return sbuffer . toString ( ) ; } public String getLocationAsString ( ) { if ( null != locator ) { StringBuffer sbuffer = new StringBuffer ( ) ; String systemID = locator . getSystemId ( ) ; int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; if ( null != systemID ) { sbuffer . append ( "; SystemID: " ) ; sbuffer . append ( systemID ) ; } if ( 0 != line ) { sbuffer . append ( "; Line#: " ) ; sbuffer . append ( line ) ; } if ( 0 != column ) { sbuffer . append ( "; Column#: " ) ; sbuffer . append ( column ) ; } return sbuffer . toString ( ) ; } else { return null ; } } public void printStackTrace ( ) { printStackTrace ( new java . io . PrintWriter ( System . err , true ) ) ; } public void printStackTrace ( java . io . PrintStream s ) { printStackTrace ( new java . io . PrintWriter ( s ) ) ; } public void printStackTrace ( java . io . PrintWriter s ) { if ( s == null ) { s = new java . io . PrintWriter ( System . err , true ) ; } try { String locInfo = getLocationAsString ( ) ; if ( null != locInfo ) { s . println ( locInfo ) ; } super . printStackTrace ( s ) ; } catch ( Throwable e ) { } Throwable exception = getException ( ) ; for ( int i = 0 ; ( i < 10 ) && ( null != exception ) ; i ++ ) { s . println ( "---------" ) ; try { if ( exception instanceof DTMException ) { String locInfo = ( ( DTMException ) exception ) . getLocationAsString ( ) ; if ( null != locInfo ) { s . println ( locInfo ) ; } } exception . printStackTrace ( s ) ; } catch ( Throwable e ) { s . println ( "Could not print stack trace..." ) ; } try { Method meth = ( ( Object ) exception ) . getClass ( ) . getMethod ( "getException" , null ) ; if ( null != meth ) { Throwable prev = exception ; exception = ( Throwable ) meth . invoke ( exception , null ) ; if ( prev == exception ) { break ; } } else { exception = null ; } } catch ( InvocationTargetException ite ) { exception = null ; } catch ( IllegalAccessException iae ) { exception = null ; } catch ( NoSuchMethodException nsme ) { exception = null ; } } } } 	0	['15', '4', '1', '12', '37', '0', '11', '1', '15', '0.392857143', '357', '0', '0', '0.62962963', '0.311111111', '1', '2', '22.66666667', '8', '2', '0']
package org . apache . xalan . xslt ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . runtime ; public class Node { public int node ; public int type ; public Node ( int n , int t ) { node = n ; type = t ; } } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . apache . xalan . xsltc . runtime ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . transformer ; public class DecimalToRoman { public DecimalToRoman ( long postValue , String postLetter , long preValue , String preLetter ) { this . m_postValue = postValue ; this . m_postLetter = postLetter ; this . m_preValue = preValue ; this . m_preLetter = preLetter ; } public long m_postValue ; public String m_postLetter ; public long m_preValue ; public String m_preLetter ; } 	0	['1', '1', '0', '2', '2', '0', '2', '0', '1', '2', '20', '0', '0', '0', '1', '0', '0', '15', '0', '0', '0']
package org . apache . xalan . xsltc . dom ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xml . dtm . ref ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BooleanExpr extends Expression { private boolean _value ; public BooleanExpr ( boolean value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _type = Type . Boolean ; return _type ; } public String toString ( ) { return _value ? "true()" : "false()" ; } public boolean getValue ( ) { return _value ; } public boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( _value ) { il . append ( NOP ) ; } else { _falseList . add ( il . append ( new GOTO ( null ) ) ) ; } } } 	0	['7', '3', '0', '17', '16', '1', '1', '16', '7', '0.333333333', '70', '1', '0', '0.922077922', '0.371428571', '2', '8', '8.857142857', '2', '1.1429', '0']
package org . apache . xalan . templates ; import org . apache . xpath . ExpressionOwner ; import org . apache . xpath . XPathVisitor ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . functions . FuncCurrent ; import org . apache . xpath . functions . FuncExtFunction ; import org . apache . xpath . functions . Function ; import org . apache . xpath . operations . Variable ; public class AbsPathChecker extends XPathVisitor { private boolean m_isAbs = true ; public boolean checkAbsolute ( LocPathIterator path ) { m_isAbs = true ; path . callVisitors ( null , this ) ; return m_isAbs ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { if ( ( func instanceof FuncCurrent ) || ( func instanceof FuncExtFunction ) ) m_isAbs = false ; return true ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { m_isAbs = false ; return true ; } } 	0	['4', '2', '0', '8', '6', '0', '1', '7', '4', '0', '37', '1', '0', '0.8', '0.45', '0', '0', '8', '3', '1.25', '0']
package org . apache . xml . dtm . ref ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . MethodType ; final class SymbolTable { private final Hashtable _stylesheets = new Hashtable ( ) ; private final Hashtable _primops = new Hashtable ( ) ; private Hashtable _variables = null ; private Hashtable _templates = null ; private Hashtable _attributeSets = null ; private Hashtable _aliases = null ; private Hashtable _excludedURI = null ; private Hashtable _decimalFormats = null ; public DecimalFormatting getDecimalFormatting ( QName name ) { if ( _decimalFormats == null ) return null ; return ( ( DecimalFormatting ) _decimalFormats . get ( name ) ) ; } public void addDecimalFormatting ( QName name , DecimalFormatting symbols ) { if ( _decimalFormats == null ) _decimalFormats = new Hashtable ( ) ; _decimalFormats . put ( name , symbols ) ; } public Stylesheet addStylesheet ( QName name , Stylesheet node ) { return ( Stylesheet ) _stylesheets . put ( name , node ) ; } public Stylesheet lookupStylesheet ( QName name ) { return ( Stylesheet ) _stylesheets . get ( name ) ; } public Template addTemplate ( Template template ) { final QName name = template . getName ( ) ; if ( _templates == null ) _templates = new Hashtable ( ) ; return ( Template ) _templates . put ( name , template ) ; } public Template lookupTemplate ( QName name ) { if ( _templates == null ) return null ; return ( Template ) _templates . get ( name ) ; } public Variable addVariable ( Variable variable ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = variable . getName ( ) . getStringRep ( ) ; return ( Variable ) _variables . put ( name , variable ) ; } public Param addParam ( Param parameter ) { if ( _variables == null ) _variables = new Hashtable ( ) ; final String name = parameter . getName ( ) . getStringRep ( ) ; return ( Param ) _variables . put ( name , parameter ) ; } public Variable lookupVariable ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Variable ? ( Variable ) obj : null ; } public Param lookupParam ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; final Object obj = _variables . get ( name ) ; return obj instanceof Param ? ( Param ) obj : null ; } public SyntaxTreeNode lookupName ( QName qname ) { if ( _variables == null ) return null ; final String name = qname . getStringRep ( ) ; return ( SyntaxTreeNode ) _variables . get ( name ) ; } public AttributeSet addAttributeSet ( AttributeSet atts ) { if ( _attributeSets == null ) _attributeSets = new Hashtable ( ) ; return ( AttributeSet ) _attributeSets . put ( atts . getName ( ) , atts ) ; } public AttributeSet lookupAttributeSet ( QName name ) { if ( _attributeSets == null ) return null ; return ( AttributeSet ) _attributeSets . get ( name ) ; } public void addPrimop ( String name , MethodType mtype ) { Vector methods = ( Vector ) _primops . get ( name ) ; if ( methods == null ) { _primops . put ( name , methods = new Vector ( ) ) ; } methods . addElement ( mtype ) ; } public Vector lookupPrimop ( String name ) { return ( Vector ) _primops . get ( name ) ; } private int _nsCounter = 0 ; public String generateNamespacePrefix ( ) { return ( new String ( "ns" + ( _nsCounter ++ ) ) ) ; } private SyntaxTreeNode _current = null ; public void setCurrentNode ( SyntaxTreeNode node ) { _current = node ; } public String lookupNamespace ( String prefix ) { if ( _current == null ) return ( Constants . EMPTYSTRING ) ; return ( _current . lookupNamespace ( prefix ) ) ; } public void addPrefixAlias ( String prefix , String alias ) { if ( _aliases == null ) _aliases = new Hashtable ( ) ; _aliases . put ( prefix , alias ) ; } public String lookupPrefixAlias ( String prefix ) { if ( _aliases == null ) return null ; return ( String ) _aliases . get ( prefix ) ; } public void excludeURI ( String uri ) { if ( uri == null ) return ; if ( _excludedURI == null ) _excludedURI = new Hashtable ( ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt == null ) refcnt = new Integer ( 1 ) ; else refcnt = new Integer ( refcnt . intValue ( ) + 1 ) ; _excludedURI . put ( uri , refcnt ) ; } public void excludeNamespaces ( String prefixes ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; if ( uri != null ) excludeURI ( uri ) ; } } } public boolean isExcludedNamespace ( String uri ) { if ( uri != null && _excludedURI != null ) { final Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; return ( refcnt != null && refcnt . intValue ( ) > 0 ) ; } return false ; } public void unExcludeNamespaces ( String prefixes ) { if ( _excludedURI == null ) return ; if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri ; if ( prefix . equals ( "#default" ) ) uri = lookupNamespace ( Constants . EMPTYSTRING ) ; else uri = lookupNamespace ( prefix ) ; Integer refcnt = ( Integer ) _excludedURI . get ( uri ) ; if ( refcnt != null ) _excludedURI . put ( uri , new Integer ( refcnt . intValue ( ) - 1 ) ) ; } } } } 	0	['25', '1', '0', '90', '48', '214', '88', '9', '24', '0.891666667', '494', '1', '1', '0', '0.185454545', '0', '0', '18.36', '5', '2.2', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class NodeSortRecordGenerator extends ClassGenerator { private static final int TRANSLET_INDEX = 4 ; private final Instruction _aloadTranslet ; public NodeSortRecordGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; } public Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['3', '4', '0', '5', '5', '1', '1', '4', '3', '1', '25', '1', '0', '0.975903614', '0.466666667', '0', '0', '6.666666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class GenerateIdCall extends FunctionCall { public GenerateIdCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; } else { argument ( ) . translate ( classGen , methodGen ) ; } final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "generate_idF" , GET_NODE_NAME_SIG ) ) ) ; } } 	0	['2', '4', '0', '10', '12', '1', '0', '10', '2', '2', '39', '0', '0', '0.989690722', '0.6', '2', '4', '18.5', '2', '1', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; public class XNull extends XNodeSet { public XNull ( ) { super ( ) ; } public int getType ( ) { return CLASS_NULL ; } public String getTypeString ( ) { return "#CLASS_NULL" ; } public double num ( ) { return 0.0 ; } public boolean bool ( ) { return false ; } public String str ( ) { return "" ; } public int rtf ( XPathContext support ) { return DTM . NULL ; } public boolean equals ( XObject obj2 ) { return obj2 . getType ( ) == CLASS_NULL ; } } 	0	['8', '5', '0', '4', '10', '28', '1', '3', '8', '2', '31', '0', '0', '0.951048951', '0.416666667', '3', '19', '2.875', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . ObjectType ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class CastCall extends FunctionCall { private String _className ; private Expression _right ; public CastCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) != 2 ) { throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , getName ( ) , this ) ) ; } Expression exp = argument ( 0 ) ; if ( exp instanceof LiteralExpr ) { _className = ( ( LiteralExpr ) exp ) . getValue ( ) ; _type = Type . newObjectType ( _className ) ; } else { throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , getName ( ) , this ) ) ; } _right = argument ( 1 ) ; Type tright = _right . typeCheck ( stable ) ; if ( tright != Type . Reference && tright instanceof ObjectType == false ) { throw new TypeCheckError ( new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , tright , _type , this ) ) ; } return _type ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _right . translate ( classGen , methodGen ) ; il . append ( new CHECKCAST ( cpg . addClass ( _className ) ) ) ; } } 	0	['3', '4', '0', '17', '19', '1', '0', '17', '3', '0.5', '107', '1', '1', '0.979591837', '0.444444444', '3', '14', '34', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class When extends Instruction { private Expression _test ; private boolean _ignore = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "When" ) ; indent ( indent + IndentIncrement ) ; System . out . print ( "test " ) ; Util . println ( _test . toString ( ) ) ; displayContents ( indent + IndentIncrement ) ; } public Expression getTest ( ) { return _test ; } public boolean ignore ( ) { return ( _ignore ) ; } public void parseContents ( Parser parser ) { _test = parser . parseExpression ( this , "test" , null ) ; Object result = _test . evaluateAtCompileTime ( ) ; if ( result != null && result instanceof Boolean ) { _ignore = ! ( ( Boolean ) result ) . booleanValue ( ) ; } parseChildren ( parser ) ; if ( _test . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "test" ) ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _test . typeCheck ( stable ) instanceof BooleanType == false ) { _test = new CastExpr ( _test , Type . Boolean ) ; } if ( ! _ignore ) { typeCheckContents ( stable ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ErrorMsg msg = new ErrorMsg ( ErrorMsg . STRAY_WHEN_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , msg ) ; } } 	0	['7', '3', '0', '15', '25', '0', '3', '13', '6', '0.5', '118', '1', '1', '0.903225806', '0.285714286', '1', '6', '15.57142857', '5', '1.4286', '0']
package org . apache . xalan . xsltc . compiler ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '5', '44', '64', '3', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xml . utils ; import java . util . EmptyStackException ; public class ObjectStack extends ObjectVector { public ObjectStack ( ) { super ( ) ; } public ObjectStack ( int blocksize ) { super ( blocksize ) ; } public ObjectStack ( ObjectStack v ) { super ( v ) ; } public Object push ( Object i ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = i ; m_firstFree ++ ; return i ; } public Object pop ( ) { Object val = m_map [ -- m_firstFree ] ; m_map [ m_firstFree ] = null ; return val ; } public void quickPop ( int n ) { m_firstFree -= n ; } public Object peek ( ) { try { return m_map [ m_firstFree - 1 ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public Object peek ( int n ) { try { return m_map [ m_firstFree - ( 1 + n ) ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public void setTop ( Object val ) { try { m_map [ m_firstFree - 1 ] = val ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new EmptyStackException ( ) ; } } public boolean empty ( ) { return m_firstFree == 0 ; } public int search ( Object o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } public Object clone ( ) throws CloneNotSupportedException { return ( ObjectStack ) super . clone ( ) ; } } 	0	['12', '2', '0', '5', '20', '24', '4', '1', '12', '2', '161', '0', '0', '0.653846154', '0.395833333', '1', '14', '12.41666667', '2', '1', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncTrue extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return XBoolean . S_TRUE ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['3', '3', '0', '4', '4', '3', '0', '4', '3', '2', '9', '0', '0', '0.95', '0.5', '1', '6', '2', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class LogicalExpr extends Expression { public static final int OR = 0 ; public static final int AND = 1 ; private final int _op ; private Expression _left ; private Expression _right ; private static final String [ ] Ops = { "or" , "and" } ; public LogicalExpr ( int op , Expression left , Expression right ) { _op = op ; ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public boolean hasPositionCall ( ) { return ( _left . hasPositionCall ( ) || _right . hasPositionCall ( ) ) ; } public boolean hasLastCall ( ) { return ( _left . hasLastCall ( ) || _right . hasLastCall ( ) ) ; } public Object evaluateAtCompileTime ( ) { final Object leftb = _left . evaluateAtCompileTime ( ) ; final Object rightb = _right . evaluateAtCompileTime ( ) ; if ( leftb == null || rightb == null ) { return null ; } if ( _op == AND ) { return ( leftb == Boolean . TRUE && rightb == Boolean . TRUE ) ? Boolean . TRUE : Boolean . FALSE ; } else { return ( leftb == Boolean . TRUE || rightb == Boolean . TRUE ) ? Boolean . TRUE : Boolean . FALSE ; } } public int getOp ( ) { return ( _op ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public String toString ( ) { return Ops [ _op ] + '(' + _left + ", " + _right + ')' ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type tleft = _left . typeCheck ( stable ) ; Type tright = _right . typeCheck ( stable ) ; MethodType wantType = new MethodType ( Type . Void , tleft , tright ) ; MethodType haveType = lookupPrimop ( stable , Ops [ _op ] , wantType ) ; if ( haveType != null ) { Type arg1 = ( Type ) haveType . argsType ( ) . elementAt ( 0 ) ; if ( ! arg1 . identicalTo ( tleft ) ) _left = new CastExpr ( _left , arg1 ) ; Type arg2 = ( Type ) haveType . argsType ( ) . elementAt ( 1 ) ; if ( ! arg2 . identicalTo ( tright ) ) _right = new CastExpr ( _right , arg1 ) ; return _type = haveType . resultType ( ) ; } throw new TypeCheckError ( this ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translateDesynthesized ( classGen , methodGen ) ; synthesize ( classGen , methodGen ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final SyntaxTreeNode parent = getParent ( ) ; if ( _op == AND ) { _left . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle middle = il . append ( NOP ) ; _right . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle after = il . append ( NOP ) ; _falseList . append ( _right . _falseList . append ( _left . _falseList ) ) ; if ( ( _left instanceof LogicalExpr ) && ( ( ( LogicalExpr ) _left ) . getOp ( ) == OR ) ) { _left . backPatchTrueList ( middle ) ; } else if ( _left instanceof NotCall ) { _left . backPatchTrueList ( middle ) ; } else { _trueList . append ( _left . _trueList ) ; } if ( ( _right instanceof LogicalExpr ) && ( ( ( LogicalExpr ) _right ) . getOp ( ) == OR ) ) { _right . backPatchTrueList ( after ) ; } else if ( _right instanceof NotCall ) { _right . backPatchTrueList ( after ) ; } else { _trueList . append ( _right . _trueList ) ; } } else { _left . translateDesynthesized ( classGen , methodGen ) ; InstructionHandle ih = il . append ( new GOTO ( null ) ) ; _right . translateDesynthesized ( classGen , methodGen ) ; _left . _trueList . backPatch ( ih ) ; _left . _falseList . backPatch ( ih . getNext ( ) ) ; _falseList . append ( _right . _falseList ) ; _trueList . add ( ih ) . append ( _right . _trueList ) ; } } } 	0	['11', '3', '0', '18', '43', '0', '0', '18', '10', '0.633333333', '375', '0.666666667', '2', '0.8875', '0.257142857', '2', '9', '32.54545455', '8', '2.4545', '0']
package org . apache . xpath . res ; public class XPATHErrorResources_en extends XPATHErrorResources { } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . runtime ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . transformer ; import org . apache . xalan . serialize . SerializerUtils ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMTreeWalker ; import org . apache . xml . serializer . SerializationHandler ; import org . apache . xpath . XPathContext ; public class TreeWalker2Result extends DTMTreeWalker { TransformerImpl m_transformer ; SerializationHandler m_handler ; int m_startNode ; public TreeWalker2Result ( TransformerImpl transformer , SerializationHandler handler ) { super ( handler , null ) ; m_transformer = transformer ; m_handler = handler ; } public void traverse ( int pos ) throws org . xml . sax . SAXException { m_dtm = m_transformer . getXPathContext ( ) . getDTM ( pos ) ; m_startNode = pos ; super . traverse ( pos ) ; } protected void endNode ( int node ) throws org . xml . sax . SAXException { super . endNode ( node ) ; if ( DTM . ELEMENT_NODE == m_dtm . getNodeType ( node ) ) { m_transformer . getXPathContext ( ) . popCurrentNode ( ) ; } } protected void startNode ( int node ) throws org . xml . sax . SAXException { XPathContext xcntxt = m_transformer . getXPathContext ( ) ; try { if ( DTM . ELEMENT_NODE == m_dtm . getNodeType ( node ) ) { xcntxt . pushCurrentNode ( node ) ; if ( m_startNode != node ) { super . startNode ( node ) ; } else { String elemName = m_dtm . getNodeName ( node ) ; String localName = m_dtm . getLocalName ( node ) ; String namespace = m_dtm . getNamespaceURI ( node ) ; m_handler . startElement ( namespace , localName , elemName ) ; boolean hasNSDecls = false ; DTM dtm = m_dtm ; for ( int ns = dtm . getFirstNamespaceNode ( node , true ) ; DTM . NULL != ns ; ns = dtm . getNextNamespaceNode ( node , ns , true ) ) { SerializerUtils . ensureNamespaceDeclDeclared ( m_handler , dtm , ns ) ; } for ( int attr = dtm . getFirstAttribute ( node ) ; DTM . NULL != attr ; attr = dtm . getNextAttribute ( attr ) ) { SerializerUtils . addAttribute ( m_handler , attr ) ; } } } else { xcntxt . pushCurrentNode ( node ) ; super . startNode ( node ) ; xcntxt . popCurrentNode ( ) ; } } catch ( javax . xml . transform . TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } } 	0	['4', '2', '0', '7', '24', '0', '1', '6', '2', '0.444444444', '146', '0', '2', '0.727272727', '0.5625', '1', '4', '34.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public class StepIterator extends DTMAxisIteratorBase { protected DTMAxisIterator _source ; protected DTMAxisIterator _iterator ; private int _pos = - 1 ; public StepIterator ( DTMAxisIterator source , DTMAxisIterator iterator ) { _source = source ; _iterator = iterator ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; _iterator . setRestartable ( true ) ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final StepIterator clone = ( StepIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _iterator = _iterator . cloneIterator ( ) ; clone . _iterator . setRestartable ( true ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; _iterator . setStartNode ( _includeSelf ? _startNode : _source . next ( ) ) ; return resetPosition ( ) ; } public int next ( ) { for ( int node ; ; ) { if ( ( node = _iterator . next ( ) ) != END ) { return returnNode ( node ) ; } else if ( ( node = _source . next ( ) ) == END ) { return END ; } else { _iterator . setStartNode ( node ) ; } } } public void setMark ( ) { _source . setMark ( ) ; _iterator . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _iterator . gotoMark ( ) ; } } 	0	['8', '2', '1', '4', '21', '0', '2', '3', '8', '0.333333333', '158', '1', '2', '0.65', '0.34375', '1', '5', '18.375', '3', '1.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class IntExpr extends Expression { private final int _value ; public IntExpr ( int value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . Int ; } public String toString ( ) { return "int-expr(" + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['4', '3', '0', '11', '14', '0', '0', '11', '4', '0.333333333', '44', '1', '0', '0.959459459', '0.4', '2', '7', '9.75', '1', '0.75', '0']
package org . apache . xalan . processor ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . templates . ElemApplyImport ; import org . apache . xalan . templates . ElemApplyTemplates ; import org . apache . xalan . templates . ElemAttribute ; import org . apache . xalan . templates . ElemCallTemplate ; import org . apache . xalan . templates . ElemComment ; import org . apache . xalan . templates . ElemCopy ; import org . apache . xalan . templates . ElemCopyOf ; import org . apache . xalan . templates . ElemElement ; import org . apache . xalan . templates . ElemExsltFuncResult ; import org . apache . xalan . templates . ElemExsltFunction ; import org . apache . xalan . templates . ElemFallback ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xalan . templates . ElemPI ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemText ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xalan . templates . ElemValueOf ; import org . apache . xalan . templates . ElemVariable ; import org . apache . xalan . templates . ElemMessage ; import org . apache . xalan . templates . Stylesheet ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; public class ProcessorExsltFunction extends ProcessorTemplateElem { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws SAXException { String msg = "" ; if ( ! ( handler . getElemTemplateElement ( ) instanceof Stylesheet ) ) { msg = "func:function element must be top level." ; handler . error ( msg , new SAXException ( msg ) ) ; } super . startElement ( handler , uri , localName , rawName , attributes ) ; String val = attributes . getValue ( "name" ) ; int indexOfColon = val . indexOf ( ":" ) ; if ( indexOfColon > 0 ) { String prefix = val . substring ( 0 , indexOfColon ) ; String localVal = val . substring ( indexOfColon + 1 ) ; String ns = handler . getNamespaceSupport ( ) . getURI ( prefix ) ; } else { msg = "func:function name must have namespace" ; handler . error ( msg , new SAXException ( msg ) ) ; } } protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws SAXException { ElemTemplateElement function = handler . getElemTemplateElement ( ) ; SourceLocator locator = handler . getLocator ( ) ; validate ( function , handler ) ; super . endElement ( handler , uri , localName , rawName ) ; } public void validate ( ElemTemplateElement elem , StylesheetHandler handler ) throws SAXException { String msg = "" ; while ( elem != null ) { if ( elem instanceof ElemExsltFuncResult && elem . getNextSiblingElem ( ) != null && ! ( elem . getNextSiblingElem ( ) instanceof ElemFallback ) ) { msg = "func:result has an illegal following sibling (only xsl:fallback allowed)" ; handler . error ( msg , new SAXException ( msg ) ) ; } if ( ( elem instanceof ElemApplyImport || elem instanceof ElemApplyTemplates || elem instanceof ElemAttribute || elem instanceof ElemCallTemplate || elem instanceof ElemComment || elem instanceof ElemCopy || elem instanceof ElemCopyOf || elem instanceof ElemElement || elem instanceof ElemLiteralResult || elem instanceof ElemNumber || elem instanceof ElemPI || elem instanceof ElemText || elem instanceof ElemTextLiteral || elem instanceof ElemValueOf ) && ! ( ancestorIsOk ( elem ) ) ) { msg = "misplaced literal result in a func:function container." ; handler . error ( msg , new SAXException ( msg ) ) ; } ElemTemplateElement nextElem = elem . getFirstChildElem ( ) ; while ( nextElem == null ) { nextElem = elem . getNextSiblingElem ( ) ; if ( nextElem == null ) elem = elem . getParentElem ( ) ; if ( elem == null || elem instanceof ElemExsltFunction ) return ; } elem = nextElem ; } } boolean ancestorIsOk ( ElemTemplateElement child ) { while ( child . getParentElem ( ) != null && ! ( child . getParentElem ( ) instanceof ElemExsltFunction ) ) { ElemTemplateElement parent = child . getParentElem ( ) ; if ( parent instanceof ElemExsltFuncResult || parent instanceof ElemVariable || parent instanceof ElemParam || parent instanceof ElemMessage ) return true ; child = parent ; } return false ; } } 	0	['6', '5', '0', '27', '27', '15', '1', '26', '4', '2', '229', '0', '0', '0.97706422', '0.533333333', '2', '4', '37.16666667', '7', '1.8333', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class NumberCall extends FunctionCall { public NumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) > 0 ) { argument ( ) . typeCheck ( stable ) ; } return _type = Type . Real ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; Type targ ; if ( argumentCount ( ) == 0 ) { il . append ( methodGen . loadContextNode ( ) ) ; targ = Type . Node ; } else { final Expression arg = argument ( ) ; arg . translate ( classGen , methodGen ) ; arg . startIterator ( classGen , methodGen ) ; targ = arg . getType ( ) ; } if ( ! targ . identicalTo ( Type . Real ) ) { targ . translateTo ( classGen , methodGen , Type . Real ) ; } } } 	0	['3', '4', '0', '11', '15', '3', '0', '11', '3', '2', '59', '0', '0', '0.979591837', '0.444444444', '3', '13', '18.66666667', '3', '1.3333', '0']
package org . apache . xalan . xsltc ; import java . text . Collator ; import java . util . Locale ; public interface CollatorFactory { public Collator getCollator ( String lang , String country ) ; public Collator getCollator ( Locale locale ) ; } 	0	['2', '1', '0', '2', '2', '1', '2', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . NamespaceAlias ; import org . xml . sax . Attributes ; class ProcessorNamespaceAlias extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { NamespaceAlias na = new NamespaceAlias ( handler . nextUid ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , na ) ; String prefix = na . getStylesheetPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setStylesheetPrefix ( prefix ) ; } String stylesheetNS = handler . getNamespaceForPrefix ( prefix ) ; na . setStylesheetNamespace ( stylesheetNS ) ; prefix = na . getResultPrefix ( ) ; if ( prefix . equals ( "#default" ) ) { prefix = "" ; na . setResultPrefix ( prefix ) ; } String resultNS = handler . getNamespaceForPrefix ( prefix ) ; na . setResultNamespace ( resultNS ) ; handler . getStylesheet ( ) . setNamespaceAlias ( na ) ; handler . getStylesheet ( ) . appendChild ( na ) ; } } 	0	['2', '4', '0', '6', '17', '1', '1', '5', '1', '2', '65', '0', '0', '0.995260664', '0.625', '3', '4', '31.5', '1', '0.5', '0']
package org . apache . xpath . axes ; public interface PathComponent { public int getAnalysisBits ( ) ; } 	0	['1', '1', '0', '8', '1', '0', '8', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . lib ; import java . util . Hashtable ; import org . apache . xml . utils . DOMHelper ; import org . apache . xpath . NodeSet ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class ExsltSets extends ExsltBase { public static NodeList leading ( NodeList nl1 , NodeList nl2 ) { if ( nl2 . getLength ( ) == 0 ) return nl1 ; NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet leadNodes = new NodeSet ( ) ; Node endNode = nl2 . item ( 0 ) ; if ( ! ns1 . contains ( endNode ) ) return leadNodes ; for ( int i = 0 ; i < nl1 . getLength ( ) ; i ++ ) { Node testNode = nl1 . item ( i ) ; if ( DOMHelper . isNodeAfter ( testNode , endNode ) && ! DOMHelper . isNodeTheSame ( testNode , endNode ) ) leadNodes . addElement ( testNode ) ; } return leadNodes ; } public static NodeList trailing ( NodeList nl1 , NodeList nl2 ) { if ( nl2 . getLength ( ) == 0 ) return nl1 ; NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet trailNodes = new NodeSet ( ) ; Node startNode = nl2 . item ( 0 ) ; if ( ! ns1 . contains ( startNode ) ) return trailNodes ; for ( int i = 0 ; i < nl1 . getLength ( ) ; i ++ ) { Node testNode = nl1 . item ( i ) ; if ( DOMHelper . isNodeAfter ( startNode , testNode ) && ! DOMHelper . isNodeTheSame ( startNode , testNode ) ) trailNodes . addElement ( testNode ) ; } return trailNodes ; } public static NodeList intersection ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; NodeSet inter = new NodeSet ( ) ; inter . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ns2 . contains ( n ) ) inter . addElement ( n ) ; } return inter ; } public static NodeList difference ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; NodeSet diff = new NodeSet ( ) ; diff . setShouldCacheNodes ( true ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { Node n = ns1 . elementAt ( i ) ; if ( ! ns2 . contains ( n ) ) diff . addElement ( n ) ; } return diff ; } public static NodeList distinct ( NodeList nl ) { NodeSet dist = new NodeSet ( ) ; dist . setShouldCacheNodes ( true ) ; Hashtable stringTable = new Hashtable ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node currNode = nl . item ( i ) ; String key = toString ( currNode ) ; if ( key == null ) dist . addElement ( currNode ) ; else if ( ! stringTable . containsKey ( key ) ) { stringTable . put ( key , currNode ) ; dist . addElement ( currNode ) ; } } return dist ; } public static boolean hasSameNode ( NodeList nl1 , NodeList nl2 ) { NodeSet ns1 = new NodeSet ( nl1 ) ; NodeSet ns2 = new NodeSet ( nl2 ) ; for ( int i = 0 ; i < ns1 . getLength ( ) ; i ++ ) { if ( ns2 . contains ( ns1 . elementAt ( i ) ) ) return true ; } return false ; } } 	0	['7', '2', '0', '4', '23', '21', '1', '3', '7', '2', '258', '0', '0', '0.25', '0.5', '0', '0', '35.85714286', '6', '3.5714', '0']
package org . apache . xalan . xsltc . trax ; import java . util . Properties ; public final class OutputSettings { private String _cdata_section_elements = null ; private String _doctype_public = null ; private String _encoding = null ; private String _indent = null ; private String _media_type = null ; private String _method = null ; private String _omit_xml_declaration = null ; private String _standalone = null ; private String _version = null ; public Properties getProperties ( ) { Properties properties = new Properties ( ) ; return ( properties ) ; } } 	0	['2', '1', '0', '0', '4', '1', '0', '0', '2', '1', '47', '1', '0', '0', '1', '0', '0', '18', '1', '0.5', '0']
package org . apache . xpath . functions ; import org . apache . xalan . res . XSLMessages ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncConcat extends FunctionMultiArgs { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( m_arg0 . execute ( xctxt ) . str ( ) ) ; sb . append ( m_arg1 . execute ( xctxt ) . str ( ) ) ; if ( null != m_arg2 ) sb . append ( m_arg2 . execute ( xctxt ) . str ( ) ) ; if ( null != m_args ) { for ( int i = 0 ; i < m_args . length ; i ++ ) { sb . append ( m_args [ i ] . execute ( xctxt ) . str ( ) ) ; } } return new XString ( sb . toString ( ) ) ; } public void checkNumberArgs ( int argNum ) throws WrongNumberArgsException { if ( argNum < 2 ) reportWrongNumberArgs ( ) ; } protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "gtone" , null ) ) ; } } 	0	['4', '7', '0', '7', '13', '6', '0', '7', '3', '2', '81', '0', '0', '0.96', '0.5', '3', '8', '19.25', '1', '0.75', '0']
package org . apache . xpath . functions ; import java . util . StringTokenizer ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . StringVector ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . res . XPATHErrorResources ; public class FuncId extends FunctionOneArg { private StringVector getNodesByID ( XPathContext xctxt , int docContext , String refval , StringVector usedrefs , NodeSetDTM nodeSet , boolean mayBeMore ) { if ( null != refval ) { String ref = null ; StringTokenizer tokenizer = new StringTokenizer ( refval ) ; boolean hasMore = tokenizer . hasMoreTokens ( ) ; DTM dtm = xctxt . getDTM ( docContext ) ; while ( hasMore ) { ref = tokenizer . nextToken ( ) ; hasMore = tokenizer . hasMoreTokens ( ) ; if ( ( null != usedrefs ) && usedrefs . contains ( ref ) ) { ref = null ; continue ; } int node = dtm . getElementById ( ref ) ; if ( DTM . NULL != node ) nodeSet . addNodeInDocOrder ( node , xctxt ) ; if ( ( null != ref ) && ( hasMore || mayBeMore ) ) { if ( null == usedrefs ) usedrefs = new StringVector ( ) ; usedrefs . addElement ( ref ) ; } } } return usedrefs ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocument ( ) ; if ( DTM . NULL == docContext ) error ( xctxt , XPATHErrorResources . ER_CONTEXT_HAS_NO_OWNERDOC , null ) ; XObject arg = m_arg0 . execute ( xctxt ) ; int argType = arg . getType ( ) ; XNodeSet nodes = new XNodeSet ( xctxt . getDTMManager ( ) ) ; NodeSetDTM nodeSet = nodes . mutableNodeset ( ) ; if ( XObject . CLASS_NODESET == argType ) { DTMIterator ni = arg . iter ( ) ; StringVector usedrefs = null ; int pos = ni . nextNode ( ) ; while ( DTM . NULL != pos ) { DTM ndtm = ni . getDTM ( pos ) ; String refval = ndtm . getStringValue ( pos ) . toString ( ) ; pos = ni . nextNode ( ) ; usedrefs = getNodesByID ( xctxt , docContext , refval , usedrefs , nodeSet , DTM . NULL != pos ) ; } } else if ( XObject . CLASS_NULL == argType ) { return nodes ; } else { String refval = arg . str ( ) ; getNodesByID ( xctxt , docContext , refval , null , nodeSet , false ) ; } return nodes ; } } 	0	['3', '4', '0', '11', '27', '3', '0', '11', '2', '2', '169', '0', '0', '0.96', '0.476190476', '1', '7', '55.33333333', '8', '3', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemParam ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorGlobalParamDecl extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { handler . pushElemTemplateElement ( elem ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { ElemParam v = ( ElemParam ) handler . getElemTemplateElement ( ) ; handler . getStylesheet ( ) . appendChild ( v ) ; handler . getStylesheet ( ) . setParam ( v ) ; super . endElement ( handler , uri , localName , rawName ) ; } } 	0	['3', '5', '0', '6', '10', '3', '1', '5', '1', '2', '30', '0', '0', '0.990697674', '0.583333333', '1', '2', '9', '1', '0.6667', '0']
package org . apache . xalan . processor ; public class XSLProcessorVersion { public static void main ( String argv [ ] ) { System . out . println ( S_VERSION ) ; } public static final String PRODUCT = "Xalan" ; public static final String LANGUAGE = "Java" ; public static final int VERSION = 2 ; public static final int RELEASE = 6 ; public static final int MAINTENANCE = 0 ; public static final int DEVELOPMENT = 0 ; public static final String S_VERSION = PRODUCT + " " + LANGUAGE + " " + VERSION + "." + RELEASE + "." + ( DEVELOPMENT > 0 ? ( "D" + DEVELOPMENT ) : ( "" + MAINTENANCE ) ) ; } 	0	['2', '1', '0', '0', '4', '1', '0', '0', '2', '2', '16', '0', '0', '0', '0.5', '0', '0', '3.5', '1', '0.5', '0']
package org . apache . xml . dtm . ref ; import java . util . Vector ; import org . apache . xml . utils . IntVector ; public class DTMStringPool { Vector m_intToString ; static final int HASHPRIME = 101 ; int [ ] m_hashStart = new int [ HASHPRIME ] ; IntVector m_hashChain ; public static final int NULL = - 1 ; public DTMStringPool ( int chainSize ) { m_intToString = new Vector ( ) ; m_hashChain = new IntVector ( chainSize ) ; removeAllElements ( ) ; stringToIndex ( "" ) ; } public DTMStringPool ( ) { this ( 512 ) ; } public void removeAllElements ( ) { m_intToString . removeAllElements ( ) ; for ( int i = 0 ; i < HASHPRIME ; ++ i ) m_hashStart [ i ] = NULL ; m_hashChain . removeAllElements ( ) ; } public String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { if ( i == NULL ) return null ; return ( String ) m_intToString . elementAt ( i ) ; } public int stringToIndex ( String s ) { if ( s == null ) return NULL ; int hashslot = s . hashCode ( ) % HASHPRIME ; if ( hashslot < 0 ) hashslot = - hashslot ; int hashlast = m_hashStart [ hashslot ] ; int hashcandidate = hashlast ; while ( hashcandidate != NULL ) { if ( m_intToString . elementAt ( hashcandidate ) . equals ( s ) ) return hashcandidate ; hashlast = hashcandidate ; hashcandidate = m_hashChain . elementAt ( hashcandidate ) ; } int newIndex = m_intToString . size ( ) ; m_intToString . addElement ( s ) ; m_hashChain . addElement ( NULL ) ; if ( hashlast == NULL ) m_hashStart [ hashslot ] = newIndex ; else m_hashChain . setElementAt ( newIndex , hashlast ) ; return newIndex ; } public static void main ( String [ ] args ) { String [ ] word = { "Zero" , "One" , "Two" , "Three" , "Four" , "Five" , "Six" , "Seven" , "Eight" , "Nine" , "Ten" , "Eleven" , "Twelve" , "Thirteen" , "Fourteen" , "Fifteen" , "Sixteen" , "Seventeen" , "Eighteen" , "Nineteen" , "Twenty" , "Twenty-One" , "Twenty-Two" , "Twenty-Three" , "Twenty-Four" , "Twenty-Five" , "Twenty-Six" , "Twenty-Seven" , "Twenty-Eight" , "Twenty-Nine" , "Thirty" , "Thirty-One" , "Thirty-Two" , "Thirty-Three" , "Thirty-Four" , "Thirty-Five" , "Thirty-Six" , "Thirty-Seven" , "Thirty-Eight" , "Thirty-Nine" } ; DTMStringPool pool = new DTMStringPool ( ) ; System . out . println ( "If no complaints are printed below, we passed initial test." ) ; for ( int pass = 0 ; pass <= 1 ; ++ pass ) { int i ; for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch populating pool: assigned " + j + " for create " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { int j = pool . stringToIndex ( word [ i ] ) ; if ( j != i ) System . out . println ( "\tMismatch in stringToIndex: returned " + j + " for lookup " + i ) ; } for ( i = 0 ; i < word . length ; ++ i ) { String w = pool . indexToString ( i ) ; if ( ! word [ i ] . equals ( w ) ) System . out . println ( "\tMismatch in indexToString: returned" + w + " for lookup " + i ) ; } pool . removeAllElements ( ) ; System . out . println ( "\nPass " + pass + " complete\n" ) ; } } } 	0	['6', '1', '2', '6', '25', '3', '5', '1', '6', '0.56', '424', '0', '1', '0', '0.375', '0', '0', '68.83333333', '8', '2.8333', '0']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xpath . XPath ; import org . w3c . dom . DOMException ; import org . w3c . dom . Node ; public class ElemSort extends ElemTemplateElement { private XPath m_selectExpression = null ; public void setSelect ( XPath v ) { if ( v . getPatternString ( ) . indexOf ( "{" ) < 0 ) m_selectExpression = v ; else error ( XSLTErrorResources . ER_NO_CURLYBRACE , null ) ; } public XPath getSelect ( ) { return m_selectExpression ; } private AVT m_lang_avt = null ; public void setLang ( AVT v ) { m_lang_avt = v ; } public AVT getLang ( ) { return m_lang_avt ; } private AVT m_dataType_avt = null ; public void setDataType ( AVT v ) { m_dataType_avt = v ; } public AVT getDataType ( ) { return m_dataType_avt ; } private AVT m_order_avt = null ; public void setOrder ( AVT v ) { m_order_avt = v ; } public AVT getOrder ( ) { return m_order_avt ; } private AVT m_caseorder_avt = null ; public void setCaseOrder ( AVT v ) { m_caseorder_avt = v ; } public AVT getCaseOrder ( ) { return m_caseorder_avt ; } public int getXSLToken ( ) { return Constants . ELEMNAME_SORT ; } public String getNodeName ( ) { return Constants . ELEMNAME_SORT_STRING ; } public Node appendChild ( Node newChild ) throws DOMException { error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; return null ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; StylesheetRoot . ComposeState cstate = sroot . getComposeState ( ) ; java . util . Vector vnames = cstate . getVariableNames ( ) ; if ( null != m_caseorder_avt ) m_caseorder_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_dataType_avt ) m_dataType_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_lang_avt ) m_lang_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_order_avt ) m_order_avt . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; if ( null != m_selectExpression ) m_selectExpression . fixupVariables ( vnames , cstate . getGlobalsSize ( ) ) ; } } 	0	['15', '3', '0', '7', '26', '53', '2', '5', '15', '0.785714286', '164', '1', '5', '0.933333333', '0.293333333', '2', '6', '9.6', '2', '1', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncNot extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . bool ( ) ? XBoolean . S_FALSE : XBoolean . S_TRUE ; } } 	0	['2', '4', '0', '5', '5', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xalan . templates ; import javax . xml . transform . TransformerException ; import org . apache . xalan . extensions . ExtensionNamespaceSupport ; import org . apache . xalan . extensions . ExtensionNamespacesManager ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . StringVector ; public class ElemExtensionDecl extends ElemTemplateElement { public ElemExtensionDecl ( ) { } private String m_prefix = null ; public void setPrefix ( String v ) { m_prefix = v ; } public String getPrefix ( ) { return m_prefix ; } private StringVector m_functions = new StringVector ( ) ; public void setFunctions ( StringVector v ) { m_functions = v ; } public StringVector getFunctions ( ) { return m_functions ; } public String getFunction ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_functions ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( String ) m_functions . elementAt ( i ) ; } public int getFunctionCount ( ) { return ( null != m_functions ) ? m_functions . size ( ) : 0 ; } private StringVector m_elements = null ; public void setElements ( StringVector v ) { m_elements = v ; } public StringVector getElements ( ) { return m_elements ; } public String getElement ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_elements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( String ) m_elements . elementAt ( i ) ; } public int getElementCount ( ) { return ( null != m_elements ) ? m_elements . size ( ) : 0 ; } public int getXSLToken ( ) { return Constants . ELEMNAME_EXTENSIONDECL ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; String prefix = getPrefix ( ) ; String declNamespace = getNamespaceForPrefix ( prefix ) ; String lang = null ; String srcURL = null ; String scriptSrc = null ; if ( null == declNamespace ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_NO_NAMESPACE_DECL , new Object [ ] { prefix } ) ) ; for ( ElemTemplateElement child = getFirstChildElem ( ) ; child != null ; child = child . getNextSiblingElem ( ) ) { if ( Constants . ELEMNAME_EXTENSIONSCRIPT == child . getXSLToken ( ) ) { ElemExtensionScript sdecl = ( ElemExtensionScript ) child ; lang = sdecl . getLang ( ) ; srcURL = sdecl . getSrc ( ) ; ElemTemplateElement childOfSDecl = sdecl . getFirstChildElem ( ) ; if ( null != childOfSDecl ) { if ( Constants . ELEMNAME_TEXTLITERALRESULT == childOfSDecl . getXSLToken ( ) ) { ElemTextLiteral tl = ( ElemTextLiteral ) childOfSDecl ; char [ ] chars = tl . getChars ( ) ; scriptSrc = new String ( chars ) ; if ( scriptSrc . trim ( ) . length ( ) == 0 ) scriptSrc = null ; } } } } if ( null == lang ) lang = "javaclass" ; if ( lang . equals ( "javaclass" ) && ( scriptSrc != null ) ) throw new TransformerException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ELEM_CONTENT_NOT_ALLOWED , new Object [ ] { scriptSrc } ) ) ; ExtensionNamespaceSupport extNsSpt = null ; ExtensionNamespacesManager extNsMgr = sroot . getExtensionNamespacesManager ( ) ; if ( extNsMgr . namespaceIndex ( declNamespace , extNsMgr . getExtensions ( ) ) == - 1 ) { if ( lang . equals ( "javaclass" ) ) { if ( null == srcURL ) { extNsSpt = extNsMgr . defineJavaNamespace ( declNamespace ) ; } else if ( extNsMgr . namespaceIndex ( srcURL , extNsMgr . getExtensions ( ) ) == - 1 ) { extNsSpt = extNsMgr . defineJavaNamespace ( declNamespace , srcURL ) ; } } else { String handler = "org.apache.xalan.extensions.ExtensionHandlerGeneral" ; Object [ ] args = { declNamespace , this . m_elements , this . m_functions , lang , srcURL , scriptSrc , getSystemId ( ) } ; extNsSpt = new ExtensionNamespaceSupport ( declNamespace , handler , args ) ; } } if ( extNsSpt != null ) extNsMgr . registerExtension ( extNsSpt ) ; } public void runtimeInit ( TransformerImpl transformer ) throws TransformerException { } } 	0	['14', '3', '0', '10', '42', '27', '1', '9', '14', '0.666666667', '290', '1', '2', '0.937799043', '0.25', '3', '4', '19.5', '2', '1.0714', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; class ProcessorTemplate extends ProcessorTemplateElem { protected void appendAndPush ( StylesheetHandler handler , ElemTemplateElement elem ) throws org . xml . sax . SAXException { super . appendAndPush ( handler , elem ) ; elem . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; handler . getStylesheet ( ) . setTemplate ( ( ElemTemplate ) elem ) ; } } 	0	['2', '5', '0', '6', '8', '1', '1', '5', '0', '2', '19', '0', '0', '0.995327103', '0.666666667', '1', '1', '8.5', '1', '0.5', '0']
package org . apache . xalan . processor ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemAttributeSet ; import org . apache . xalan . templates . ElemTemplateElement ; import org . xml . sax . Attributes ; class ProcessorAttributeSet extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { ElemAttributeSet eat = new ElemAttributeSet ( ) ; eat . setLocaterInfo ( handler . getLocator ( ) ) ; try { eat . setPrefixes ( handler . getNamespaceSupport ( ) ) ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } eat . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , eat ) ; handler . getStylesheet ( ) . setAttributeSet ( eat ) ; ElemTemplateElement parent = handler . getElemTemplateElement ( ) ; parent . appendChild ( eat ) ; handler . pushElemTemplateElement ( eat ) ; } public void endElement ( StylesheetHandler handler , String uri , String localName , String rawName ) throws org . xml . sax . SAXException { handler . popElemTemplateElement ( ) ; } } 	0	['3', '4', '0', '7', '19', '3', '1', '6', '2', '2', '54', '0', '0', '0.990566038', '0.666666667', '2', '3', '17', '1', '0.6667', '0']
package org . apache . xpath . functions ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncSubstringAfter extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XMLString s1 = m_arg0 . execute ( xctxt ) . xstr ( ) ; XMLString s2 = m_arg1 . execute ( xctxt ) . xstr ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : ( XString ) s1 . substring ( index + s2 . length ( ) ) ; } } 	0	['2', '5', '0', '6', '8', '1', '0', '6', '2', '2', '34', '0', '0', '0.98245614', '0.75', '1', '6', '16', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; final class IdPattern extends IdKeyPattern { public IdPattern ( String id ) { super ( "##id" , id ) ; } } 	0	['1', '6', '0', '1', '2', '0', '1', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xalan . extensions ; import javax . xml . transform . ErrorListener ; import org . apache . xpath . objects . XObject ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface ExpressionContext { public Node getContextNode ( ) ; public NodeIterator getContextNodes ( ) ; public ErrorListener getErrorListener ( ) ; public double toNumber ( Node n ) ; public String toString ( Node n ) ; public XObject getVariableOrParam ( org . apache . xml . utils . QName qname ) throws javax . xml . transform . TransformerException ; public org . apache . xpath . XPathContext getXPathContext ( ) throws javax . xml . transform . TransformerException ; } 	0	['7', '1', '0', '19', '7', '21', '17', '3', '7', '2', '7', '0', '0', '0', '0.476190476', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . templates ; import org . apache . xpath . XPath ; public class ElemWhen extends ElemTemplateElement { private XPath m_test ; public void setTest ( XPath v ) { m_test = v ; } public XPath getTest ( ) { return m_test ; } public int getXSLToken ( ) { return Constants . ELEMNAME_WHEN ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_test ) m_test . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_WHEN_STRING ; } public ElemWhen ( ) { } protected void callChildVisitors ( XSLTVisitor visitor , boolean callAttrs ) { if ( callAttrs ) m_test . getExpression ( ) . callVisitors ( m_test , visitor ) ; super . callChildVisitors ( visitor , callAttrs ) ; } } 	0	['7', '3', '0', '9', '16', '9', '1', '8', '6', '0.5', '55', '1', '1', '0.97029703', '0.314285714', '2', '5', '6.714285714', '2', '1', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . NodeIterator ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; public abstract class NodeIteratorBase implements NodeIterator { protected int _last = - 1 ; protected int _position = 0 ; protected int _markedNode ; protected int _startNode = NodeIterator . END ; protected boolean _includeSelf = false ; protected boolean _isRestartable = true ; public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; } abstract public NodeIterator setStartNode ( int node ) ; public NodeIterator reset ( ) { final boolean temp = _isRestartable ; _isRestartable = true ; setStartNode ( _includeSelf ? _startNode + 1 : _startNode ) ; _isRestartable = temp ; return this ; } public NodeIterator includeSelf ( ) { _includeSelf = true ; return this ; } public int getLast ( ) { if ( _last == - 1 ) { final int temp = _position ; setMark ( ) ; reset ( ) ; do { _last ++ ; } while ( next ( ) != END ) ; gotoMark ( ) ; _position = temp ; } return _last ; } public int getPosition ( ) { return _position == 0 ? 1 : _position ; } public boolean isReverse ( ) { return false ; } public NodeIterator cloneIterator ( ) { try { final NodeIteratorBase clone = ( NodeIteratorBase ) super . clone ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } protected final int returnNode ( final int node ) { _position ++ ; return node ; } protected final NodeIterator resetPosition ( ) { _position = 0 ; return this ; } } 	0	['11', '1', '0', '2', '18', '19', '0', '2', '9', '0.75', '138', '1', '0', '0', '0.424242424', '0', '0', '11', '3', '1.2727', '0']
package org . apache . xml . utils ; import java . io . Serializable ; import javax . xml . transform . SourceLocator ; import org . xml . sax . Locator ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . LocatorImpl ; public class SAXSourceLocator extends LocatorImpl implements SourceLocator , Serializable { Locator m_locator ; public SAXSourceLocator ( ) { } public SAXSourceLocator ( Locator locator ) { m_locator = locator ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( javax . xml . transform . SourceLocator locator ) { m_locator = null ; this . setColumnNumber ( locator . getColumnNumber ( ) ) ; this . setLineNumber ( locator . getLineNumber ( ) ) ; this . setPublicId ( locator . getPublicId ( ) ) ; this . setSystemId ( locator . getSystemId ( ) ) ; } public SAXSourceLocator ( SAXParseException spe ) { this . setLineNumber ( spe . getLineNumber ( ) ) ; this . setColumnNumber ( spe . getColumnNumber ( ) ) ; this . setPublicId ( spe . getPublicId ( ) ) ; this . setSystemId ( spe . getSystemId ( ) ) ; } public String getPublicId ( ) { return ( null == m_locator ) ? super . getPublicId ( ) : m_locator . getPublicId ( ) ; } public String getSystemId ( ) { return ( null == m_locator ) ? super . getSystemId ( ) : m_locator . getSystemId ( ) ; } public int getLineNumber ( ) { return ( null == m_locator ) ? super . getLineNumber ( ) : m_locator . getLineNumber ( ) ; } public int getColumnNumber ( ) { return ( null == m_locator ) ? super . getColumnNumber ( ) : m_locator . getColumnNumber ( ) ; } } 	0	['8', '2', '0', '17', '29', '0', '17', '0', '8', '0.285714286', '119', '0', '0', '0.666666667', '0.34375', '0', '0', '13.75', '2', '1', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . ErrorListener ; import javax . xml . transform . SourceLocator ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . w3c . dom . Node ; public class MsgMgr { public MsgMgr ( TransformerImpl transformer ) { m_transformer = transformer ; } private TransformerImpl m_transformer ; public void message ( SourceLocator srcLctr , String msg , boolean terminate ) throws TransformerException { ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) { errHandler . warning ( new TransformerException ( msg , srcLctr ) ) ; } else { if ( terminate ) throw new TransformerException ( msg , srcLctr ) ; else System . out . println ( msg ) ; } } public void warn ( SourceLocator srcLctr , String msg ) throws TransformerException { warn ( srcLctr , null , null , msg , null ) ; } public void warn ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { warn ( srcLctr , null , null , msg , args ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { warn ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void warn ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createWarning ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . warning ( new TransformerException ( formattedMsg , srcLctr ) ) ; else System . out . println ( formattedMsg ) ; } public void error ( SourceLocator srcLctr , String msg ) throws TransformerException { error ( srcLctr , null , null , msg , null ) ; } public void error ( SourceLocator srcLctr , String msg , Object [ ] args ) throws TransformerException { error ( srcLctr , null , null , msg , args ) ; } public void error ( SourceLocator srcLctr , String msg , Exception e ) throws TransformerException { error ( srcLctr , msg , null , e ) ; } public void error ( SourceLocator srcLctr , String msg , Object args [ ] , Exception e ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg ) throws TransformerException { error ( srcLctr , styleNode , sourceNode , msg , null ) ; } public void error ( SourceLocator srcLctr , Node styleNode , Node sourceNode , String msg , Object args [ ] ) throws TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = m_transformer . getErrorListener ( ) ; if ( null != errHandler ) errHandler . fatalError ( new TransformerException ( formattedMsg , srcLctr ) ) ; else throw new TransformerException ( formattedMsg , srcLctr ) ; } } 	0	['12', '1', '0', '12', '20', '46', '11', '2', '12', '0', '176', '1', '1', '0', '0.489583333', '0', '0', '13.58333333', '1', '0.9167', '0']
package org . apache . xalan . transformer ; import java . util . Locale ; import java . util . NoSuchElementException ; import org . w3c . dom . Element ; class NumeratorFormatter { protected Element m_xslNumberElement ; NumberFormatStringTokenizer m_formatTokenizer ; Locale m_locale ; java . text . NumberFormat m_formatter ; TransformerImpl m_processor ; private final static DecimalToRoman m_romanConvertTable [ ] = { new DecimalToRoman ( 1000 , "M" , 900 , "CM" ) , new DecimalToRoman ( 500 , "D" , 400 , "CD" ) , new DecimalToRoman ( 100L , "C" , 90L , "XC" ) , new DecimalToRoman ( 50L , "L" , 40L , "XL" ) , new DecimalToRoman ( 10L , "X" , 9L , "IX" ) , new DecimalToRoman ( 5L , "V" , 4L , "IV" ) , new DecimalToRoman ( 1L , "I" , 1L , "I" ) } ; private final static char [ ] m_alphaCountTable = { 'Z' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' } ; NumeratorFormatter ( Element xslNumberElement , TransformerImpl processor ) { m_xslNumberElement = xslNumberElement ; m_processor = processor ; } protected String int2alphaCount ( int val , char [ ] table ) { int radix = table . length ; char buf [ ] = new char [ 100 ] ; int charPos = buf . length - 1 ; int lookupIndex = 1 ; int correction = 0 ; do { correction = ( ( lookupIndex == 0 ) || ( correction != 0 && lookupIndex == radix - 1 ) ) ? ( radix - 1 ) : 0 ; lookupIndex = ( val + correction ) % radix ; val = ( val / radix ) ; if ( lookupIndex == 0 && val == 0 ) break ; buf [ charPos -- ] = table [ lookupIndex ] ; } while ( val > 0 ) ; return new String ( buf , charPos + 1 , ( buf . length - charPos - 1 ) ) ; } String long2roman ( long val , boolean prefixesAreOK ) { if ( val <= 0 ) { return "#E(" + val + ")" ; } String roman = "" ; int place = 0 ; if ( val <= 3999L ) { do { while ( val >= m_romanConvertTable [ place ] . m_postValue ) { roman += m_romanConvertTable [ place ] . m_postLetter ; val -= m_romanConvertTable [ place ] . m_postValue ; } if ( prefixesAreOK ) { if ( val >= m_romanConvertTable [ place ] . m_preValue ) { roman += m_romanConvertTable [ place ] . m_preLetter ; val -= m_romanConvertTable [ place ] . m_preValue ; } } place ++ ; } while ( val > 0 ) ; } else { roman = "#error" ; } return roman ; } class NumberFormatStringTokenizer { private int currentPosition ; private int maxPosition ; private String str ; NumberFormatStringTokenizer ( String str ) { this . str = str ; maxPosition = str . length ( ) ; } void reset ( ) { currentPosition = 0 ; } String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } boolean hasMoreTokens ( ) { return ( currentPosition >= maxPosition ) ? false : true ; } int countTokens ( ) { int count = 0 ; int currpos = currentPosition ; while ( currpos < maxPosition ) { int start = currpos ; while ( ( currpos < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currpos ) ) ) { currpos ++ ; } if ( ( start == currpos ) && ( Character . isLetterOrDigit ( str . charAt ( currpos ) ) == false ) ) { currpos ++ ; } count ++ ; } return count ; } } } 	0	['4', '1', '0', '3', '11', '4', '1', '3', '0', '1.095238095', '357', '0.428571429', '3', '0', '0.428571429', '0', '0', '86.5', '7', '3.5', '0']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Result ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerException ; import javax . xml . transform . sax . TransformerHandler ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTMWSFilter ; import org . apache . xml . serializer . SerializationHandler ; import org . xml . sax . Attributes ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . ext . DeclHandler ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . DefaultHandler ; public class TransformerHandlerImpl implements TransformerHandler , DeclHandler { private TransformerImpl _transformer ; private AbstractTranslet _translet = null ; private String _systemId ; private SAXImpl _dom = null ; private ContentHandler _handler = null ; private LexicalHandler _lexHandler = null ; private DTDHandler _dtdHandler = null ; private DeclHandler _declHandler = null ; private Result _result = null ; private Locator _locator = null ; private boolean _done = false ; private boolean _isIdentity = false ; public TransformerHandlerImpl ( TransformerImpl transformer ) { _transformer = transformer ; if ( transformer . isIdentity ( ) ) { _handler = new DefaultHandler ( ) ; _isIdentity = true ; } else { _translet = _transformer . getTranslet ( ) ; } } public String getSystemId ( ) { return _systemId ; } public void setSystemId ( String id ) { _systemId = id ; } public Transformer getTransformer ( ) { return _transformer ; } public void setResult ( Result result ) throws IllegalArgumentException { _result = result ; if ( null == result ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ER_RESULT_NULL ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } if ( _isIdentity ) { try { SerializationHandler outputHandler = _transformer . getOutputHandler ( result ) ; _transformer . transferOutputProperties ( outputHandler ) ; _handler = outputHandler ; _lexHandler = outputHandler ; } catch ( TransformerException e ) { _result = null ; } } else if ( _done ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { _handler . characters ( ch , start , length ) ; } public void startDocument ( ) throws SAXException { if ( _result == null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_SET_RESULT_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } if ( ! _isIdentity ) { boolean hasIdCall = ( _translet != null ) ? _translet . hasIdCall ( ) : false ; XSLTCDTMManager dtmManager = null ; try { dtmManager = ( XSLTCDTMManager ) _transformer . getTransformerFactory ( ) . getDTMManagerClass ( ) . newInstance ( ) ; } catch ( Exception e ) { throw new SAXException ( e ) ; } DTMWSFilter wsFilter ; if ( _translet != null && _translet instanceof StripFilter ) { wsFilter = new DOMWSFilter ( _translet ) ; } else { wsFilter = null ; } _dom = ( SAXImpl ) dtmManager . getDTM ( null , false , wsFilter , true , false , hasIdCall ) ; _handler = _dom . getBuilder ( ) ; _lexHandler = ( LexicalHandler ) _handler ; _dtdHandler = ( DTDHandler ) _handler ; _declHandler = ( DeclHandler ) _handler ; _dom . setDocumentURI ( _systemId ) ; if ( _locator != null ) { _handler . setDocumentLocator ( _locator ) ; } } _handler . startDocument ( ) ; } public void endDocument ( ) throws SAXException { _handler . endDocument ( ) ; if ( ! _isIdentity ) { if ( _result != null ) { try { _transformer . setDOM ( _dom ) ; _transformer . transform ( null , _result ) ; } catch ( TransformerException e ) { throw new SAXException ( e ) ; } } _done = true ; _transformer . setDOM ( _dom ) ; } } public void startElement ( String uri , String localName , String qname , Attributes attributes ) throws SAXException { _handler . startElement ( uri , localName , qname , attributes ) ; } public void endElement ( String namespaceURI , String localName , String qname ) throws SAXException { _handler . endElement ( namespaceURI , localName , qname ) ; } public void processingInstruction ( String target , String data ) throws SAXException { _handler . processingInstruction ( target , data ) ; } public void startCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startCDATA ( ) ; } } public void endCDATA ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endCDATA ( ) ; } } public void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . comment ( ch , start , length ) ; } } public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { _handler . ignorableWhitespace ( ch , start , length ) ; } public void setDocumentLocator ( Locator locator ) { _locator = locator ; if ( _handler != null ) { _handler . setDocumentLocator ( locator ) ; } } public void skippedEntity ( String name ) throws SAXException { _handler . skippedEntity ( name ) ; } public void startPrefixMapping ( String prefix , String uri ) throws SAXException { _handler . startPrefixMapping ( prefix , uri ) ; } public void endPrefixMapping ( String prefix ) throws SAXException { _handler . endPrefixMapping ( prefix ) ; } public void startDTD ( String name , String publicId , String systemId ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startDTD ( name , publicId , systemId ) ; } } public void endDTD ( ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endDTD ( ) ; } } public void startEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . startEntity ( name ) ; } } public void endEntity ( String name ) throws SAXException { if ( _lexHandler != null ) { _lexHandler . endEntity ( name ) ; } } public void unparsedEntityDecl ( String name , String publicId , String systemId , String notationName ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . unparsedEntityDecl ( name , publicId , systemId , notationName ) ; } } public void notationDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _dtdHandler != null ) { _dtdHandler . notationDecl ( name , publicId , systemId ) ; } } public void attributeDecl ( String eName , String aName , String type , String valueDefault , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . attributeDecl ( eName , aName , type , valueDefault , value ) ; } } public void elementDecl ( String name , String model ) throws SAXException { if ( _declHandler != null ) { _declHandler . elementDecl ( name , model ) ; } } public void externalEntityDecl ( String name , String publicId , String systemId ) throws SAXException { if ( _declHandler != null ) { _declHandler . externalEntityDecl ( name , publicId , systemId ) ; } } public void internalEntityDecl ( String name , String value ) throws SAXException { if ( _declHandler != null ) { _declHandler . internalEntityDecl ( name , value ) ; } } } 	0	['29', '1', '0', '14', '75', '114', '2', '13', '29', '0.854166667', '490', '1', '3', '0', '0.237068966', '0', '0', '15.48275862', '2', '1', '0']
package org . apache . xalan . templates ; import java . util . Hashtable ; import org . apache . xalan . transformer . KeyManager ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . QName ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . functions . Function2Args ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; public class FuncKey extends Function2Args { static private Boolean ISTRUE = new Boolean ( true ) ; public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; XNodeSet nodes = null ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int docContext = dtm . getDocumentRoot ( context ) ; if ( DTM . NULL == docContext ) { } String xkeyname = getArg0 ( ) . execute ( xctxt ) . str ( ) ; QName keyname = new QName ( xkeyname , xctxt . getNamespaceContext ( ) ) ; XObject arg = getArg1 ( ) . execute ( xctxt ) ; boolean argIsNodeSetDTM = ( XObject . CLASS_NODESET == arg . getType ( ) ) ; KeyManager kmgr = transformer . getKeyManager ( ) ; if ( argIsNodeSetDTM ) { XNodeSet ns = ( XNodeSet ) arg ; ns . setShouldCacheNodes ( true ) ; int len = ns . getLength ( ) ; if ( len <= 1 ) argIsNodeSetDTM = false ; } if ( argIsNodeSetDTM ) { Hashtable usedrefs = null ; DTMIterator ni = arg . iter ( ) ; int pos ; UnionPathIterator upi = new UnionPathIterator ( ) ; upi . exprSetParent ( this ) ; while ( DTM . NULL != ( pos = ni . nextNode ( ) ) ) { dtm = xctxt . getDTM ( pos ) ; XMLString ref = dtm . getStringValue ( pos ) ; if ( null == ref ) continue ; if ( null == usedrefs ) usedrefs = new Hashtable ( ) ; if ( usedrefs . get ( ref ) != null ) { continue ; } else { usedrefs . put ( ref , ISTRUE ) ; } XNodeSet nl = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nl . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; upi . addIterator ( nl ) ; } int current = xctxt . getCurrentNode ( ) ; upi . setRoot ( current , xctxt ) ; nodes = new XNodeSet ( upi ) ; } else { XMLString ref = arg . xstr ( ) ; nodes = kmgr . getNodeSetDTMByKey ( xctxt , docContext , keyname , ref , xctxt . getNamespaceContext ( ) ) ; nodes . setRoot ( xctxt . getCurrentNode ( ) , xctxt ) ; } return nodes ; } } 	0	['3', '5', '0', '14', '33', '1', '0', '14', '2', '0.5', '177', '1', '0', '0.98245614', '0.75', '1', '7', '57.66666667', '1', '0.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xalan . xsltc . util . IntegerArray ; public final class CachedNodeListIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _numCachedNodes = 0 ; private int _index = 0 ; private boolean _isEnded = false ; public CachedNodeListIterator ( DTMAxisIterator source ) { _source = source ; } public void setRestartable ( boolean isRestartable ) { } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; _source . setStartNode ( node ) ; resetPosition ( ) ; _isRestartable = false ; } return this ; } public int next ( ) { return getNode ( _index ++ ) ; } public int getPosition ( ) { return _index == 0 ? 1 : _index ; } public int getNodeByPosition ( int pos ) { return getNode ( pos ) ; } public int getNode ( int index ) { if ( index < _numCachedNodes ) { return _nodes . at ( index ) ; } else if ( ! _isEnded ) { int node = _source . next ( ) ; if ( node != END ) { _nodes . add ( node ) ; _numCachedNodes ++ ; } else { _isEnded = true ; } return node ; } else return END ; } public DTMAxisIterator cloneIterator ( ) { ClonedNodeListIterator clone = new ClonedNodeListIterator ( this ) ; return clone ; } public DTMAxisIterator reset ( ) { _index = 0 ; return this ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['11', '2', '0', '4', '21', '23', '1', '4', '11', '0.64', '135', '1', '2', '0.565217391', '0.363636364', '1', '6', '10.81818182', '4', '1.3636', '0']
package org . apache . xalan . extensions ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '4', '44', '64', '2', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; import org . apache . xml . utils . PrefixResolver ; public interface XPathFactory { XPath create ( String exprString , SourceLocator locator , PrefixResolver prefixResolver , int type ) ; } 	0	['1', '1', '0', '3', '1', '0', '1', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm . ref ; public final class ExtendedType { private int nodetype ; private String namespace ; private String localName ; private int hash ; public ExtendedType ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } public ExtendedType ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } protected void redefine ( int nodetype , String namespace , String localName ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = nodetype + namespace . hashCode ( ) + localName . hashCode ( ) ; } protected void redefine ( int nodetype , String namespace , String localName , int hash ) { this . nodetype = nodetype ; this . namespace = namespace ; this . localName = localName ; this . hash = hash ; } public int hashCode ( ) { return hash ; } public boolean equals ( ExtendedType other ) { try { return other . nodetype == this . nodetype && other . localName . equals ( this . localName ) && other . namespace . equals ( this . namespace ) ; } catch ( NullPointerException e ) { return false ; } } public int getNodeType ( ) { return nodetype ; } public String getLocalName ( ) { return localName ; } public String getNamespace ( ) { return namespace ; } } 	0	['9', '1', '0', '8', '12', '0', '8', '0', '7', '0.40625', '117', '1', '0', '0', '0.5', '1', '2', '11.55555556', '4', '1.1111', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . Instruction ; import org . apache . xalan . xsltc . compiler . Stylesheet ; public final class FilterGenerator extends ClassGenerator { private static int TRANSLET_INDEX = 5 ; private final Instruction _aloadTranslet ; public FilterGenerator ( String className , String superClassName , String fileName , int accessFlags , String [ ] interfaces , Stylesheet stylesheet ) { super ( className , superClassName , fileName , accessFlags , interfaces , stylesheet ) ; _aloadTranslet = new ALOAD ( TRANSLET_INDEX ) ; } public final Instruction loadTranslet ( ) { return _aloadTranslet ; } public boolean isExternal ( ) { return true ; } } 	0	['4', '4', '0', '6', '6', '2', '2', '4', '3', '0.666666667', '29', '1', '0', '0.975903614', '0.466666667', '0', '0', '5.75', '1', '0.5', '0']
package org . apache . xalan . lib ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . Templates ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . sax . SAXResult ; import javax . xml . transform . sax . SAXTransformerFactory ; import javax . xml . transform . sax . TransformerHandler ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . extensions . XSLProcessorContext ; import org . apache . xalan . templates . AVT ; import org . apache . xalan . templates . ElemExtensionCall ; import org . apache . xalan . templates . ElemLiteralResult ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . XMLReaderFactory ; import org . apache . xml . serializer . Serializer ; import org . apache . xml . serializer . SerializerFactory ; public class PipeDocument { public void pipeDocument ( XSLProcessorContext context , ElemExtensionCall elem ) throws TransformerException , TransformerConfigurationException , SAXException , IOException , FileNotFoundException { try { SAXTransformerFactory saxTFactory = ( SAXTransformerFactory ) TransformerFactory . newInstance ( ) ; String source = elem . getAttribute ( "source" , context . getContextNode ( ) , context . getTransformer ( ) ) ; TransformerImpl transImpl = context . getTransformer ( ) ; String baseURLOfSource = transImpl . getBaseURLOfSource ( ) ; String absSourceURL = SystemIDResolver . getAbsoluteURI ( source , baseURLOfSource ) ; String target = elem . getAttribute ( "target" , context . getContextNode ( ) , context . getTransformer ( ) ) ; XPathContext xctxt = context . getTransformer ( ) . getXPathContext ( ) ; int xt = xctxt . getDTMHandleFromNode ( context . getContextNode ( ) ) ; String sysId = elem . getSystemId ( ) ; NodeList ssNodes = null ; NodeList paramNodes = null ; Node ssNode = null ; Node paramNode = null ; if ( elem . hasChildNodes ( ) ) { ssNodes = elem . getChildNodes ( ) ; Vector vTHandler = new Vector ( ssNodes . getLength ( ) ) ; for ( int i = 0 ; i < ssNodes . getLength ( ) ; i ++ ) { ssNode = ssNodes . item ( i ) ; if ( ssNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) ssNode ) . getTagName ( ) . equals ( "stylesheet" ) && ssNode instanceof ElemLiteralResult ) { AVT avt = ( ( ElemLiteralResult ) ssNode ) . getLiteralResultAttribute ( "href" ) ; String href = avt . evaluate ( xctxt , xt , elem ) ; String absURI = SystemIDResolver . getAbsoluteURI ( href , sysId ) ; Templates tmpl = saxTFactory . newTemplates ( new StreamSource ( absURI ) ) ; TransformerHandler tHandler = saxTFactory . newTransformerHandler ( tmpl ) ; Transformer trans = tHandler . getTransformer ( ) ; vTHandler . addElement ( tHandler ) ; paramNodes = ssNode . getChildNodes ( ) ; for ( int j = 0 ; j < paramNodes . getLength ( ) ; j ++ ) { paramNode = paramNodes . item ( j ) ; if ( paramNode . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) paramNode ) . getTagName ( ) . equals ( "param" ) && paramNode instanceof ElemLiteralResult ) { avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "name" ) ; String pName = avt . evaluate ( xctxt , xt , elem ) ; avt = ( ( ElemLiteralResult ) paramNode ) . getLiteralResultAttribute ( "value" ) ; String pValue = avt . evaluate ( xctxt , xt , elem ) ; trans . setParameter ( pName , pValue ) ; } } } } usePipe ( vTHandler , absSourceURL , target ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } public void usePipe ( Vector vTHandler , String source , String target ) throws TransformerException , TransformerConfigurationException , FileNotFoundException , IOException , SAXException , SAXNotRecognizedException { XMLReader reader = XMLReaderFactory . createXMLReader ( ) ; TransformerHandler tHFirst = ( TransformerHandler ) vTHandler . firstElement ( ) ; reader . setContentHandler ( tHFirst ) ; reader . setProperty ( "http://xml.org/sax/properties/lexical-handler" , tHFirst ) ; for ( int i = 1 ; i < vTHandler . size ( ) ; i ++ ) { TransformerHandler tHFrom = ( TransformerHandler ) vTHandler . elementAt ( i - 1 ) ; TransformerHandler tHTo = ( TransformerHandler ) vTHandler . elementAt ( i ) ; tHFrom . setResult ( new SAXResult ( tHTo ) ) ; } TransformerHandler tHLast = ( TransformerHandler ) vTHandler . lastElement ( ) ; Transformer trans = tHLast . getTransformer ( ) ; Properties outputProps = trans . getOutputProperties ( ) ; Serializer serializer = SerializerFactory . getSerializer ( outputProps ) ; FileOutputStream out = new FileOutputStream ( target ) ; try { serializer . setOutputStream ( out ) ; tHLast . setResult ( new SAXResult ( serializer . asContentHandler ( ) ) ) ; reader . parse ( source ) ; } finally { if ( out != null ) out . close ( ) ; } } } 	0	['3', '1', '0', '10', '47', '3', '0', '10', '3', '2', '271', '0', '0', '0', '0.466666667', '0', '0', '89.33333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DCONST ; import org . apache . bcel . generic . ICONST ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . IntType ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class Variable extends VariableBase { public int getIndex ( ) { return ( _local != null ) ? _local . getIndex ( ) : - 1 ; } public void parseContents ( Parser parser ) { super . parseContents ( parser ) ; SyntaxTreeNode parent = getParent ( ) ; if ( parent instanceof Stylesheet ) { _isLocal = false ; Variable var = parser . getSymbolTable ( ) . lookupVariable ( _name ) ; if ( var != null ) { final int us = this . getImportPrecedence ( ) ; final int them = var . getImportPrecedence ( ) ; if ( us == them ) { final String name = _name . toString ( ) ; reportError ( this , parser , ErrorMsg . VARIABLE_REDEF_ERR , name ) ; } else if ( them > us ) { _ignore = true ; return ; } else { var . disable ( ) ; } } ( ( Stylesheet ) parent ) . addVariable ( this ) ; parser . getSymbolTable ( ) . addVariable ( this ) ; } else { _isLocal = true ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _select != null ) { _type = _select . typeCheck ( stable ) ; } else if ( hasContents ( ) ) { typeCheckContents ( stable ) ; _type = Type . ResultTree ; } else { _type = Type . Reference ; } return Type . Void ; } public void initialize ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( isLocal ( ) && ! _refs . isEmpty ( ) ) { if ( _local == null ) { _local = methodGen . addLocalVariable2 ( getEscapedName ( ) , _type . toJCType ( ) , il . getEnd ( ) ) ; } if ( ( _type instanceof IntType ) || ( _type instanceof NodeType ) || ( _type instanceof BooleanType ) ) il . append ( new ICONST ( 0 ) ) ; else if ( _type instanceof RealType ) il . append ( new DCONST ( 0 ) ) ; else il . append ( new ACONST_NULL ( ) ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String name = getEscapedName ( ) ; if ( _ignore ) return ; _ignore = true ; if ( isLocal ( ) ) { translateValue ( classGen , methodGen ) ; if ( _refs . isEmpty ( ) ) { il . append ( _type . POP ( ) ) ; _local = null ; } else { if ( _local == null ) mapRegister ( methodGen ) ; il . append ( _type . STORE ( _local . getIndex ( ) ) ) ; } } else { String signature = _type . toSignature ( ) ; if ( classGen . containsField ( name ) == null ) { classGen . addField ( new Field ( ACC_PUBLIC , cpg . addUtf8 ( name ) , cpg . addUtf8 ( signature ) , null , cpg . getConstantPool ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; translateValue ( classGen , methodGen ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( classGen . getClassName ( ) , name , signature ) ) ) ; } } } } 	0	['6', '4', '0', '35', '47', '3', '11', '28', '5', '2', '281', '0', '0', '0.938271605', '0.4', '2', '13', '45.83333333', '8', '3.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . DLOAD ; import org . apache . bcel . generic . DSTORE ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class RealType extends NumberType { protected RealType ( ) { } public String toString ( ) { return "real" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "D" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . DOUBLE ; } public int distanceTo ( Type type ) { if ( type == this ) { return 0 ; } else if ( type == Type . Int ) { return 1 ; } else { return Integer . MAX_VALUE ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Int ) { translateTo ( classGen , methodGen , ( IntType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToString" , "(D)" + STRING_SIG ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , IntType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "realToInt" , "(D)I" ) ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { LocalVariableGen local ; final FlowList flowlist = new FlowList ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP2 ) ; local = methodGen . addLocalVariable ( "real_to_boolean_tmp" , org . apache . bcel . generic . Type . DOUBLE , il . getEnd ( ) , null ) ; il . append ( new DSTORE ( local . getIndex ( ) ) ) ; il . append ( DCONST_0 ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFEQ ( null ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( new DLOAD ( local . getIndex ( ) ) ) ; il . append ( DCMPG ) ; flowlist . add ( il . append ( new IFNE ( null ) ) ) ; return flowlist ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( DUP_X2 ) ; il . append ( DUP_X2 ) ; il . append ( POP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( DOUBLE_CLASS , "<init>" , "(D)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , final Class clazz ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE ) { il . append ( D2I ) ; il . append ( I2C ) ; } else if ( clazz == Byte . TYPE ) { il . append ( D2I ) ; il . append ( I2B ) ; } else if ( clazz == Short . TYPE ) { il . append ( D2I ) ; il . append ( I2S ) ; } else if ( clazz == Integer . TYPE ) { il . append ( D2I ) ; } else if ( clazz == Long . TYPE ) { il . append ( D2L ) ; } else if ( clazz == Float . TYPE ) { il . append ( D2F ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else if ( clazz . isAssignableFrom ( java . lang . Double . class ) ) { translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE || clazz == Byte . TYPE || clazz == Short . TYPE || clazz == Integer . TYPE ) { il . append ( I2D ) ; } else if ( clazz == Long . TYPE ) { il . append ( L2D ) ; } else if ( clazz == Float . TYPE ) { il . append ( F2D ) ; } else if ( clazz == Double . TYPE ) { il . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( DOUBLE_CLASS ) ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( DOUBLE_CLASS , DOUBLE_VALUE , DOUBLE_VALUE_SIG ) ) ) ; } public Instruction ADD ( ) { return InstructionConstants . DADD ; } public Instruction SUB ( ) { return InstructionConstants . DSUB ; } public Instruction MUL ( ) { return InstructionConstants . DMUL ; } public Instruction DIV ( ) { return InstructionConstants . DDIV ; } public Instruction REM ( ) { return InstructionConstants . DREM ; } public Instruction NEG ( ) { return InstructionConstants . DNEG ; } public Instruction LOAD ( int slot ) { return new DLOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new DSTORE ( slot ) ; } public Instruction POP ( ) { return POP2 ; } public Instruction CMP ( boolean less ) { return less ? InstructionConstants . DCMPG : InstructionConstants . DCMPL ; } public Instruction DUP ( ) { return DUP2 ; } } 	0	['27', '3', '0', '42', '57', '343', '13', '34', '26', '2', '514', '0', '0', '0.573770492', '0.202020202', '1', '3', '18.03703704', '9', '1.8148', '0']
package org . apache . xpath . operations ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Or extends Operation { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XObject expr1 = m_left . execute ( xctxt ) ; if ( ! expr1 . bool ( ) ) { XObject expr2 = m_right . execute ( xctxt ) ; return expr2 . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } else return XBoolean . S_TRUE ; } public boolean bool ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return ( m_left . bool ( xctxt ) || m_right . bool ( xctxt ) ) ; } } 	0	['3', '3', '0', '6', '7', '1', '1', '5', '3', '2', '42', '0', '0', '0.953488372', '0.833333333', '1', '6', '13', '1', '0.6667', '0']
package org . apache . xalan . xsltc ; import org . xml . sax . SAXException ; public final class TransletException extends SAXException { public TransletException ( ) { super ( "Translet error" ) ; } public TransletException ( Exception e ) { super ( e . toString ( ) ) ; } public TransletException ( String message ) { super ( message ) ; } } 	0	['3', '4', '0', '13', '5', '3', '13', '0', '3', '2', '16', '0', '0', '1', '0.555555556', '0', '0', '4.333333333', '0', '0', '0']
package org . apache . xalan . xsltc . runtime ; import java . util . Enumeration ; class HashtableEntry { int hash ; Object key ; Object value ; HashtableEntry next ; protected Object clone ( ) { HashtableEntry entry = new HashtableEntry ( ) ; entry . hash = hash ; entry . key = key ; entry . value = value ; entry . next = ( next != null ) ? ( HashtableEntry ) next . clone ( ) : null ; return entry ; } } public class Hashtable { private transient HashtableEntry table [ ] ; private transient int count ; private int threshold ; private float loadFactor ; public Hashtable ( int initialCapacity , float loadFactor ) { if ( initialCapacity <= 0 ) initialCapacity = 11 ; if ( loadFactor <= 0.0 ) loadFactor = 0.75f ; this . loadFactor = loadFactor ; table = new HashtableEntry [ initialCapacity ] ; threshold = ( int ) ( initialCapacity * loadFactor ) ; } public Hashtable ( int initialCapacity ) { this ( initialCapacity , 0.75f ) ; } public Hashtable ( ) { this ( 101 , 0.75f ) ; } public int size ( ) { return count ; } public boolean isEmpty ( ) { return count == 0 ; } public Enumeration keys ( ) { return new HashtableEnumerator ( table , true ) ; } public Enumeration elements ( ) { return new HashtableEnumerator ( table , false ) ; } public boolean contains ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; int i ; HashtableEntry e ; HashtableEntry tab [ ] = table ; for ( i = tab . length ; i -- > 0 ; ) { for ( e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value . equals ( value ) ) { return true ; } } } return false ; } public boolean containsKey ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return true ; return false ; } public Object get ( Object key ) { HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) if ( ( e . hash == hash ) && e . key . equals ( key ) ) return e . value ; return null ; } protected void rehash ( ) { HashtableEntry e , old ; int i , index ; int oldCapacity = table . length ; HashtableEntry oldTable [ ] = table ; int newCapacity = oldCapacity * 2 + 1 ; HashtableEntry newTable [ ] = new HashtableEntry [ newCapacity ] ; threshold = ( int ) ( newCapacity * loadFactor ) ; table = newTable ; for ( i = oldCapacity ; i -- > 0 ; ) { for ( old = oldTable [ i ] ; old != null ; ) { e = old ; old = old . next ; index = ( e . hash & 0x7FFFFFFF ) % newCapacity ; e . next = newTable [ index ] ; newTable [ index ] = e ; } } } public Object put ( Object key , Object value ) { if ( value == null ) throw new NullPointerException ( ) ; HashtableEntry e ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] ; e != null ; e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { Object old = e . value ; e . value = value ; return old ; } } if ( count >= threshold ) { rehash ( ) ; return put ( key , value ) ; } e = new HashtableEntry ( ) ; e . hash = hash ; e . key = key ; e . value = value ; e . next = tab [ index ] ; tab [ index ] = e ; count ++ ; return null ; } public Object remove ( Object key ) { HashtableEntry e , prev ; HashtableEntry tab [ ] = table ; int hash = key . hashCode ( ) ; int index = ( hash & 0x7FFFFFFF ) % tab . length ; for ( e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && e . key . equals ( key ) ) { if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; return e . value ; } } return null ; } public void clear ( ) { HashtableEntry tab [ ] = table ; for ( int index = tab . length ; -- index >= 0 ; ) tab [ index ] = null ; count = 0 ; } public String toString ( ) { int i ; int max = size ( ) - 1 ; StringBuffer buf = new StringBuffer ( ) ; Enumeration k = keys ( ) ; Enumeration e = elements ( ) ; buf . append ( "{" ) ; for ( i = 0 ; i <= max ; i ++ ) { String s1 = k . nextElement ( ) . toString ( ) ; String s2 = e . nextElement ( ) . toString ( ) ; buf . append ( s1 + "=" + s2 ) ; if ( i < max ) buf . append ( ", " ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } class HashtableEnumerator implements Enumeration { boolean keys ; int index ; HashtableEntry table [ ] ; HashtableEntry entry ; HashtableEnumerator ( HashtableEntry table [ ] , boolean keys ) { this . table = table ; this . keys = keys ; this . index = table . length ; } public boolean hasMoreElements ( ) { if ( entry != null ) { return true ; } while ( index -- > 0 ) { if ( ( entry = table [ index ] ) != null ) { return true ; } } return false ; } public Object nextElement ( ) { if ( entry == null ) { while ( ( index -- > 0 ) && ( ( entry = table [ index ] ) == null ) ) ; } if ( entry != null ) { HashtableEntry e = entry ; entry = e . next ; return keys ? e . key : e . value ; } return null ; } } } 	0	['15', '1', '0', '14', '29', '1', '13', '2', '14', '0.553571429', '477', '1', '1', '0', '0.383333333', '0', '0', '30.53333333', '6', '2.4667', '0']
package org . apache . xml . utils ; import java . io . IOException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . xml . sax . InputSource ; public class DOM2Helper extends DOMHelper { public DOM2Helper ( ) { } public void checkNode ( Node node ) throws TransformerException { } public boolean supportsSAX ( ) { return true ; } private Document m_doc ; public void setDocument ( Document doc ) { m_doc = doc ; } public Document getDocument ( ) { return m_doc ; } public void parse ( InputSource source ) throws TransformerException { try { DocumentBuilderFactory builderFactory = DocumentBuilderFactory . newInstance ( ) ; builderFactory . setNamespaceAware ( true ) ; builderFactory . setValidating ( true ) ; DocumentBuilder parser = builderFactory . newDocumentBuilder ( ) ; parser . setErrorHandler ( new org . apache . xml . utils . DefaultErrorHandler ( ) ) ; setDocument ( parser . parse ( source ) ) ; } catch ( org . xml . sax . SAXException se ) { throw new TransformerException ( se ) ; } catch ( ParserConfigurationException pce ) { throw new TransformerException ( pce ) ; } catch ( IOException ioe ) { throw new TransformerException ( ioe ) ; } } public Element getElementByID ( String id , Document doc ) { return doc . getElementById ( id ) ; } public static boolean isNodeAfter ( Node node1 , Node node2 ) { if ( node1 instanceof DOMOrder && node2 instanceof DOMOrder ) { int index1 = ( ( DOMOrder ) node1 ) . getUid ( ) ; int index2 = ( ( DOMOrder ) node2 ) . getUid ( ) ; return index1 <= index2 ; } else { return DOMHelper . isNodeAfter ( node1 , node2 ) ; } } public static Node getParentOfNode ( Node node ) { Node parent = node . getParentNode ( ) ; if ( parent == null && ( Node . ATTRIBUTE_NODE == node . getNodeType ( ) ) ) parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } public String getLocalNameOfNode ( Node n ) { String name = n . getLocalName ( ) ; return ( null == name ) ? super . getLocalNameOfNode ( n ) : name ; } public String getNamespaceOfNode ( Node n ) { return n . getNamespaceURI ( ) ; } } 	0	['11', '2', '0', '9', '29', '53', '6', '3', '11', '0.8', '125', '1', '0', '0.714285714', '0.327272727', '1', '5', '10.27272727', '4', '1.4545', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . DOMEnhancedForDTM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . TransletException ; import org . apache . xalan . xsltc . runtime . Hashtable ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . serializer . SerializationHandler ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public final class DOMAdapter implements DOM { private DOMEnhancedForDTM _enhancedDOM ; private DOM _dom ; private String [ ] _namesArray ; private String [ ] _urisArray ; private int [ ] _typesArray ; private String [ ] _namespaceArray ; private short [ ] _mapping = null ; private int [ ] _reverse = null ; private short [ ] _NSmapping = null ; private short [ ] _NSreverse = null ; private StripFilter _filter = null ; private int _multiDOMMask ; public DOMAdapter ( DOM dom , String [ ] namesArray , String [ ] urisArray , int [ ] typesArray , String [ ] namespaceArray ) { if ( dom instanceof DOMEnhancedForDTM ) { _enhancedDOM = ( DOMEnhancedForDTM ) dom ; } _dom = dom ; _namesArray = namesArray ; _urisArray = urisArray ; _typesArray = typesArray ; _namespaceArray = namespaceArray ; } public void setupMapping ( String [ ] names , String [ ] urisArray , int [ ] typesArray , String [ ] namespaces ) { _namesArray = names ; _urisArray = urisArray ; _typesArray = typesArray ; _namespaceArray = namespaces ; } public String [ ] getNamesArray ( ) { return _namesArray ; } public String [ ] getUrisArray ( ) { return _urisArray ; } public int [ ] getTypesArray ( ) { return _typesArray ; } public String [ ] getNamespaceArray ( ) { return _namespaceArray ; } public DOM getDOMImpl ( ) { return _dom ; } private short [ ] getMapping ( ) { if ( _mapping == null ) { if ( _enhancedDOM != null ) { _mapping = _enhancedDOM . getMapping ( _namesArray , _urisArray , _typesArray ) ; } } return _mapping ; } private int [ ] getReverse ( ) { if ( _reverse == null ) { if ( _enhancedDOM != null ) { _reverse = _enhancedDOM . getReverseMapping ( _namesArray , _urisArray , _typesArray ) ; } } return _reverse ; } private short [ ] getNSMapping ( ) { if ( _NSmapping == null ) { if ( _enhancedDOM != null ) { _NSmapping = _enhancedDOM . getNamespaceMapping ( _namespaceArray ) ; } } return _NSmapping ; } private short [ ] getNSReverse ( ) { if ( _NSreverse == null ) { if ( _enhancedDOM != null ) { _NSreverse = _enhancedDOM . getReverseNamespaceMapping ( _namespaceArray ) ; } } return _NSreverse ; } public DTMAxisIterator getIterator ( ) { return _dom . getIterator ( ) ; } public String getStringValue ( ) { return _dom . getStringValue ( ) ; } public DTMAxisIterator getChildren ( final int node ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getChildren ( node ) ; } else { DTMAxisIterator iterator = _dom . getChildren ( node ) ; return iterator . setStartNode ( node ) ; } } public void setFilter ( StripFilter filter ) { _filter = filter ; } public DTMAxisIterator getTypedChildren ( final int type ) { final int [ ] reverse = getReverse ( ) ; if ( _enhancedDOM != null ) { return _enhancedDOM . getTypedChildren ( reverse [ type ] ) ; } else { return _dom . getTypedChildren ( type ) ; } } public DTMAxisIterator getNamespaceAxisIterator ( final int axis , final int ns ) { return _dom . getNamespaceAxisIterator ( axis , getNSReverse ( ) [ ns ] ) ; } public DTMAxisIterator getAxisIterator ( final int axis ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getAxisIterator ( axis ) ; } else { return _dom . getAxisIterator ( axis ) ; } } public DTMAxisIterator getTypedAxisIterator ( final int axis , final int type ) { final int [ ] reverse = getReverse ( ) ; if ( _enhancedDOM != null ) { return _enhancedDOM . getTypedAxisIterator ( axis , reverse [ type ] ) ; } else { return _dom . getTypedAxisIterator ( axis , type ) ; } } public int getMultiDOMMask ( ) { return _multiDOMMask ; } public void setMultiDOMMask ( int mask ) { _multiDOMMask = mask ; } public DTMAxisIterator getNthDescendant ( int type , int n , boolean includeself ) { return _dom . getNthDescendant ( getReverse ( ) [ type ] , n , includeself ) ; } public DTMAxisIterator getNodeValueIterator ( DTMAxisIterator iterator , int type , String value , boolean op ) { return _dom . getNodeValueIterator ( iterator , type , value , op ) ; } public DTMAxisIterator orderNodes ( DTMAxisIterator source , int node ) { return _dom . orderNodes ( source , node ) ; } public int getExpandedTypeID ( final int node ) { if ( _enhancedDOM != null ) { return getMapping ( ) [ _enhancedDOM . getExpandedTypeID2 ( node ) ] ; } else { return getMapping ( ) [ _dom . getExpandedTypeID ( node ) ] ; } } public int getNamespaceType ( final int node ) { return getNSMapping ( ) [ _dom . getNSType ( node ) ] ; } public int getNSType ( int node ) { return _dom . getNSType ( node ) ; } public int getParent ( final int node ) { return _dom . getParent ( node ) ; } public int getAttributeNode ( final int type , final int element ) { return _dom . getAttributeNode ( getReverse ( ) [ type ] , element ) ; } public String getNodeName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeName ( node ) ; } public String getNodeNameX ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNodeNameX ( node ) ; } public String getNamespaceName ( final int node ) { if ( node == DTM . NULL ) { return "" ; } return _dom . getNamespaceName ( node ) ; } public String getStringValueX ( final int node ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getStringValueX ( node ) ; } else { if ( node == DTM . NULL ) { return "" ; } return _dom . getStringValueX ( node ) ; } } public void copy ( final int node , SerializationHandler handler ) throws TransletException { _dom . copy ( node , handler ) ; } public void copy ( DTMAxisIterator nodes , SerializationHandler handler ) throws TransletException { _dom . copy ( nodes , handler ) ; } public String shallowCopy ( final int node , SerializationHandler handler ) throws TransletException { if ( _enhancedDOM != null ) { return _enhancedDOM . shallowCopy ( node , handler ) ; } else { return _dom . shallowCopy ( node , handler ) ; } } public boolean lessThan ( final int node1 , final int node2 ) { return _dom . lessThan ( node1 , node2 ) ; } public void characters ( final int textNode , SerializationHandler handler ) throws TransletException { if ( _enhancedDOM != null ) { _enhancedDOM . characters ( textNode , handler ) ; } else { _dom . characters ( textNode , handler ) ; } } public Node makeNode ( int index ) { return _dom . makeNode ( index ) ; } public Node makeNode ( DTMAxisIterator iter ) { return _dom . makeNode ( iter ) ; } public NodeList makeNodeList ( int index ) { return _dom . makeNodeList ( index ) ; } public NodeList makeNodeList ( DTMAxisIterator iter ) { return _dom . makeNodeList ( iter ) ; } public String getLanguage ( int node ) { return _dom . getLanguage ( node ) ; } public int getSize ( ) { return _dom . getSize ( ) ; } public void setDocumentURI ( String uri ) { if ( _enhancedDOM != null ) { _enhancedDOM . setDocumentURI ( uri ) ; } } public String getDocumentURI ( ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getDocumentURI ( ) ; } else { return "" ; } } public String getDocumentURI ( int node ) { return _dom . getDocumentURI ( node ) ; } public int getDocument ( ) { return _dom . getDocument ( ) ; } public boolean isElement ( final int node ) { return ( _dom . isElement ( node ) ) ; } public boolean isAttribute ( final int node ) { return ( _dom . isAttribute ( node ) ) ; } public int getNodeIdent ( int nodeHandle ) { return _dom . getNodeIdent ( nodeHandle ) ; } public int getNodeHandle ( int nodeId ) { return _dom . getNodeHandle ( nodeId ) ; } public DOM getResultTreeFrag ( int initSize , int rtfType ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getResultTreeFrag ( initSize , rtfType ) ; } else { return _dom . getResultTreeFrag ( initSize , rtfType ) ; } } public DOM getResultTreeFrag ( int initSize , int rtfType , boolean addToManager ) { if ( _enhancedDOM != null ) { return _enhancedDOM . getResultTreeFrag ( initSize , rtfType , addToManager ) ; } else { return _dom . getResultTreeFrag ( initSize , rtfType , addToManager ) ; } } public SerializationHandler getOutputDomBuilder ( ) { return _dom . getOutputDomBuilder ( ) ; } public String lookupNamespace ( int node , String prefix ) throws TransletException { return _dom . lookupNamespace ( node , prefix ) ; } public String getUnparsedEntityURI ( String entity ) { return _dom . getUnparsedEntityURI ( entity ) ; } public Hashtable getElementsWithIDs ( ) { return _dom . getElementsWithIDs ( ) ; } } 	0	['58', '1', '0', '12', '117', '0', '5', '7', '54', '0.840643275', '598', '1', '3', '0', '0.194827586', '0', '0', '9.103448276', '3', '1.3621', '0']
package org . apache . xml . dtm . ref . dom2dtm ; import org . apache . xml . dtm . DTMException ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; public class DOM2DTMdefaultNamespaceDeclarationNode implements Attr { final String NOT_SUPPORTED_ERR = "Unsupported operation on pseudonode" ; Element pseudoparent ; String prefix , uri , nodename ; int handle ; DOM2DTMdefaultNamespaceDeclarationNode ( Element pseudoparent , String prefix , String uri , int handle ) { this . pseudoparent = pseudoparent ; this . prefix = prefix ; this . uri = uri ; this . handle = handle ; this . nodename = "xmlns:" + prefix ; } public String getNodeName ( ) { return nodename ; } public String getName ( ) { return nodename ; } public String getNamespaceURI ( ) { return "http://www.w3.org/2000/xmlns/" ; } public String getPrefix ( ) { return prefix ; } public String getLocalName ( ) { return prefix ; } public String getNodeValue ( ) { return uri ; } public String getValue ( ) { return uri ; } public Element getOwnerElement ( ) { return pseudoparent ; } public boolean isSupported ( String feature , String version ) { return false ; } public boolean hasChildNodes ( ) { return false ; } public boolean hasAttributes ( ) { return false ; } public Node getParentNode ( ) { return null ; } public Node getFirstChild ( ) { return null ; } public Node getLastChild ( ) { return null ; } public Node getPreviousSibling ( ) { return null ; } public Node getNextSibling ( ) { return null ; } public boolean getSpecified ( ) { return false ; } public void normalize ( ) { return ; } public NodeList getChildNodes ( ) { return null ; } public NamedNodeMap getAttributes ( ) { return null ; } public short getNodeType ( ) { return Node . ATTRIBUTE_NODE ; } public void setNodeValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setValue ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public void setPrefix ( String value ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node insertBefore ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node replaceChild ( Node a , Node b ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node appendChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Node removeChild ( Node a ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public Document getOwnerDocument ( ) { return pseudoparent . getOwnerDocument ( ) ; } public Node cloneNode ( boolean deep ) { throw new DTMException ( NOT_SUPPORTED_ERR ) ; } public int getHandleOfNode ( ) { return handle ; } } 	0	['46', '1', '0', '3', '53', '1009', '2', '1', '45', '0.966666667', '245', '0', '0', '0', '0.190217391', '0', '0', '4.195652174', '1', '0.9783', '0']
package org . apache . xml . serializer ; class ElemContext { final int m_currentElemDepth ; ElemDesc m_elementDesc = null ; String m_elementLocalName = null ; String m_elementName = null ; String m_elementURI = null ; boolean m_isCdataSection ; boolean m_isRaw = false ; private ElemContext m_next ; final ElemContext m_prev ; boolean m_startTagOpen = false ; ElemContext ( ) { m_prev = this ; m_currentElemDepth = 0 ; } private ElemContext ( final ElemContext previous ) { m_prev = previous ; m_currentElemDepth = previous . m_currentElemDepth + 1 ; } final ElemContext pop ( ) { return this . m_prev ; } final ElemContext push ( ) { ElemContext frame = this . m_next ; if ( frame == null ) { frame = new ElemContext ( this ) ; this . m_next = frame ; } frame . m_startTagOpen = true ; return frame ; } final ElemContext push ( final String uri , final String localName , final String qName ) { ElemContext frame = this . m_next ; if ( frame == null ) { frame = new ElemContext ( this ) ; this . m_next = frame ; } frame . m_elementName = qName ; frame . m_elementLocalName = localName ; frame . m_elementURI = uri ; frame . m_isCdataSection = false ; frame . m_startTagOpen = true ; return frame ; } } 	0	['5', '1', '0', '8', '6', '0', '7', '1', '0', '0.35', '123', '0.1', '3', '0', '0.466666667', '0', '0', '21.6', '2', '1', '0']
package org . apache . xml . utils ; import java . util . Locale ; public class LocaleUtility { public final static char IETF_SEPARATOR = '-' ; public final static String EMPTY_STRING = "" ; public static Locale langToLocale ( String lang ) { if ( ( lang == null ) || lang . equals ( EMPTY_STRING ) ) { return Locale . getDefault ( ) ; } String language = EMPTY_STRING ; String country = EMPTY_STRING ; String variant = EMPTY_STRING ; int i1 = lang . indexOf ( IETF_SEPARATOR ) ; if ( i1 < 0 ) { language = lang ; } else { language = lang . substring ( 0 , i1 ) ; ++ i1 ; int i2 = lang . indexOf ( IETF_SEPARATOR , i1 ) ; if ( i2 < 0 ) { country = lang . substring ( i1 ) ; } else { country = lang . substring ( i1 , i2 ) ; variant = lang . substring ( i2 + 1 ) ; } } if ( language . length ( ) == 2 ) { language = language . toLowerCase ( ) ; } else { language = EMPTY_STRING ; } if ( country . length ( ) == 2 ) { country = country . toUpperCase ( ) ; } else { country = EMPTY_STRING ; } if ( ( variant . length ( ) > 0 ) && ( ( language . length ( ) == 2 ) || ( country . length ( ) == 2 ) ) ) { variant = variant . toUpperCase ( ) ; } else { variant = EMPTY_STRING ; } return new Locale ( language , country , variant ) ; } } 	0	['2', '1', '0', '1', '13', '1', '1', '0', '2', '2', '103', '0', '0', '0', '0.5', '0', '0', '49.5', '10', '5', '0']
package org . apache . xalan . trace ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import javax . xml . transform . SourceLocator ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xalan . templates . ElemTextLiteral ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . ref . DTMNodeProxy ; import org . apache . xml . serializer . SerializerTrace ; import org . w3c . dom . Node ; public class PrintTraceListener implements TraceListenerEx3 { public PrintTraceListener ( java . io . PrintWriter pw ) { m_pw = pw ; } java . io . PrintWriter m_pw ; public boolean m_traceTemplates = false ; public boolean m_traceElements = false ; public boolean m_traceGeneration = false ; public boolean m_traceSelection = false ; public boolean m_traceExtension = false ; public void _trace ( TracerEvent ev ) { switch ( ev . m_styleNode . getXSLToken ( ) ) { case Constants . ELEMNAME_TEXTLITERALRESULT : if ( m_traceElements ) { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + " -- " + ev . m_styleNode . getNodeName ( ) + ": " ) ; ElemTextLiteral etl = ( ElemTextLiteral ) ev . m_styleNode ; String chars = new String ( etl . getChars ( ) , 0 , etl . getChars ( ) . length ) ; m_pw . println ( "    " + chars . trim ( ) ) ; } break ; case Constants . ELEMNAME_TEMPLATE : if ( m_traceTemplates || m_traceElements ) { ElemTemplate et = ( ElemTemplate ) ev . m_styleNode ; m_pw . print ( et . getSystemId ( ) + " Line #" + et . getLineNumber ( ) + ", " + "Column #" + et . getColumnNumber ( ) + ": " + et . getNodeName ( ) + " " ) ; if ( null != et . getMatch ( ) ) { m_pw . print ( "match='" + et . getMatch ( ) . getPatternString ( ) + "' " ) ; } if ( null != et . getName ( ) ) { m_pw . print ( "name='" + et . getName ( ) + "' " ) ; } m_pw . println ( ) ; } break ; default : if ( m_traceElements ) { m_pw . println ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ev . m_styleNode . getNodeName ( ) ) ; } } } int m_indent = 0 ; public void trace ( TracerEvent ev ) { _trace ( ev ) ; } public void traceEnd ( TracerEvent ev ) { } public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException { if ( m_traceSelection ) { ElemTemplateElement ete = ( ElemTemplateElement ) ev . m_styleNode ; Node sourceNode = ev . m_sourceNode ; SourceLocator locator = null ; if ( sourceNode instanceof DTMNodeProxy ) { int nodeHandler = ( ( DTMNodeProxy ) sourceNode ) . getDTMNodeNumber ( ) ; locator = ( ( DTMNodeProxy ) sourceNode ) . getDTM ( ) . getSourceLocatorFor ( nodeHandler ) ; } if ( locator != null ) m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "', at " + locator ) ; else m_pw . println ( "Selected source node '" + sourceNode . getNodeName ( ) + "'" ) ; if ( ev . m_styleNode . getLineNumber ( ) == 0 ) { ElemTemplateElement parent = ( ElemTemplateElement ) ete . getParentElem ( ) ; if ( parent == ete . getStylesheetRoot ( ) . getDefaultRootRule ( ) ) { m_pw . print ( "(default root rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultTextRule ( ) ) { m_pw . print ( "(default text rule) " ) ; } else if ( parent == ete . getStylesheetRoot ( ) . getDefaultRule ( ) ) { m_pw . print ( "(default rule) " ) ; } m_pw . print ( ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } else { m_pw . print ( ev . m_styleNode . getSystemId ( ) + " Line #" + ev . m_styleNode . getLineNumber ( ) + ", " + "Column #" + ev . m_styleNode . getColumnNumber ( ) + ": " + ete . getNodeName ( ) + ", " + ev . m_attributeName + "='" + ev . m_xpath . getPatternString ( ) + "': " ) ; } if ( ev . m_selection . getType ( ) == ev . m_selection . CLASS_NODESET ) { m_pw . println ( ) ; org . apache . xml . dtm . DTMIterator nl = ev . m_selection . iter ( ) ; int currentPos = DTM . NULL ; currentPos = nl . getCurrentPos ( ) ; nl . setShouldCacheNodes ( true ) ; org . apache . xml . dtm . DTMIterator clone = null ; try { clone = nl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { m_pw . println ( "     [Can't trace nodelist because it it threw a CloneNotSupportedException]" ) ; return ; } int pos = clone . nextNode ( ) ; if ( DTM . NULL == pos ) { m_pw . println ( "     [empty node list]" ) ; } else { while ( DTM . NULL != pos ) { DTM dtm = ev . m_processor . getXPathContext ( ) . getDTM ( pos ) ; m_pw . print ( "     " ) ; m_pw . print ( Integer . toHexString ( pos ) ) ; m_pw . print ( ": " ) ; m_pw . println ( dtm . getNodeName ( pos ) ) ; pos = clone . nextNode ( ) ; } } nl . runTo ( - 1 ) ; nl . setCurrentPos ( currentPos ) ; } else { m_pw . println ( ev . m_selection . str ( ) ) ; } } } public void selectEnd ( EndSelectionEvent ev ) throws javax . xml . transform . TransformerException { } public void generated ( GenerateEvent ev ) { if ( m_traceGeneration ) { switch ( ev . m_eventtype ) { case SerializerTrace . EVENTTYPE_STARTDOCUMENT : m_pw . println ( "STARTDOCUMENT" ) ; break ; case SerializerTrace . EVENTTYPE_ENDDOCUMENT : m_pw . println ( "ENDDOCUMENT" ) ; break ; case SerializerTrace . EVENTTYPE_STARTELEMENT : m_pw . println ( "STARTELEMENT: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_ENDELEMENT : m_pw . println ( "ENDELEMENT: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_CHARACTERS : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CHARACTERS: " + chars ) ; } break ; case SerializerTrace . EVENTTYPE_CDATA : { String chars = new String ( ev . m_characters , ev . m_start , ev . m_length ) ; m_pw . println ( "CDATA: " + chars ) ; } break ; case SerializerTrace . EVENTTYPE_COMMENT : m_pw . println ( "COMMENT: " + ev . m_data ) ; break ; case SerializerTrace . EVENTTYPE_PI : m_pw . println ( "PI: " + ev . m_name + ", " + ev . m_data ) ; break ; case SerializerTrace . EVENTTYPE_ENTITYREF : m_pw . println ( "ENTITYREF: " + ev . m_name ) ; break ; case SerializerTrace . EVENTTYPE_IGNORABLEWHITESPACE : m_pw . println ( "IGNORABLEWHITESPACE" ) ; break ; } } } public void extension ( ExtensionEvent ev ) { if ( m_traceExtension ) { switch ( ev . m_callType ) { case ExtensionEvent . DEFAULT_CONSTRUCTOR : m_pw . println ( "EXTENSION: " + ( ( Class ) ev . m_method ) . getName ( ) + "#<init>" ) ; break ; case ExtensionEvent . METHOD : m_pw . println ( "EXTENSION: " + ( ( Method ) ev . m_method ) . getDeclaringClass ( ) . getName ( ) + "#" + ( ( Method ) ev . m_method ) . getName ( ) ) ; break ; case ExtensionEvent . CONSTRUCTOR : m_pw . println ( "EXTENSION: " + ( ( Constructor ) ev . m_method ) . getDeclaringClass ( ) . getName ( ) + "#<init>" ) ; break ; } } } public void extensionEnd ( ExtensionEvent ev ) { } } 	0	['9', '1', '0', '19', '59', '16', '1', '18', '9', '0.785714286', '680', '0', '0', '0', '0.285714286', '0', '0', '73.77777778', '10', '2.3333', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UnresolvedRef extends VariableRefBase { private QName _variableName = null ; private VariableRefBase _ref = null ; private VariableBase _var = null ; private Stylesheet _sheet = null ; public UnresolvedRef ( QName name ) { super ( ) ; _variableName = name ; _sheet = getStylesheet ( ) ; } public QName getName ( ) { return ( _variableName ) ; } private ErrorMsg reportError ( ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . VARIABLE_UNDEF_ERR , _variableName , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( err ) ; } private VariableRefBase resolve ( Parser parser , SymbolTable stable ) { VariableBase ref = parser . lookupVariable ( _variableName ) ; if ( ref == null ) ref = ( VariableBase ) stable . lookupName ( _variableName ) ; if ( ref == null ) { reportError ( ) ; return null ; } if ( ( _var = findParentVariable ( ) ) != null ) _var . addDependency ( ref ) ; if ( ref instanceof Variable ) return ( new VariableRef ( ( Variable ) ref ) ) ; else if ( ref instanceof Param ) return ( new ParameterRef ( ( Param ) ref ) ) ; else return null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _ref != null ) { final String name = _variableName . toString ( ) ; ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , name , this ) ; } if ( ( _ref = resolve ( getParser ( ) , stable ) ) != null ) { return ( _type = _ref . typeCheck ( stable ) ) ; } throw new TypeCheckError ( reportError ( ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _ref != null ) _ref . translate ( classGen , methodGen ) ; else reportError ( ) ; } public String toString ( ) { return "unresolved-ref()" ; } } 	0	['7', '4', '0', '16', '22', '0', '0', '16', '5', '0.625', '153', '1', '4', '0.926829268', '0.30952381', '2', '4', '20.28571429', '6', '1.7143', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Lt extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . lessThan ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xml . serializer ; import java . util . Hashtable ; class Utils { static private class CacheHolder { static final Hashtable cache ; static { cache = new Hashtable ( ) ; } } static Class ClassForName ( String classname ) throws ClassNotFoundException { Class c ; Object o = CacheHolder . cache . get ( classname ) ; if ( o == null ) { c = Class . forName ( classname ) ; CacheHolder . cache . put ( classname , c ) ; } else { c = ( Class ) o ; } return c ; } } 	0	['2', '1', '0', '1', '6', '1', '0', '1', '0', '2', '25', '0', '0', '0', '0.5', '0', '0', '11.5', '1', '0.5', '0']
package org . apache . xml . dtm . ref ; import org . xml . sax . ContentHandler ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public interface IncrementalSAXSource { public void setContentHandler ( ContentHandler handler ) ; public void setLexicalHandler ( org . xml . sax . ext . LexicalHandler handler ) ; public void setDTDHandler ( org . xml . sax . DTDHandler handler ) ; public Object deliverMoreNodes ( boolean parsemore ) ; public void startParse ( InputSource source ) throws SAXException ; } 	0	['5', '1', '0', '6', '5', '10', '6', '0', '5', '2', '5', '0', '0', '0', '0.333333333', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO_W ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . BooleanType ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodType ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; abstract class Expression extends SyntaxTreeNode { protected Type _type ; protected FlowList _trueList = new FlowList ( ) ; protected FlowList _falseList = new FlowList ( ) ; public Type getType ( ) { return _type ; } public abstract String toString ( ) ; public boolean hasPositionCall ( ) { return false ; } public boolean hasLastCall ( ) { return false ; } public Object evaluateAtCompileTime ( ) { return null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ErrorMsg msg = new ErrorMsg ( ErrorMsg . NOT_IMPLEMENTED_ERR , getClass ( ) , this ) ; getParser ( ) . reportError ( FATAL , msg ) ; } public final InstructionList compile ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList result , save = methodGen . getInstructionList ( ) ; methodGen . setInstructionList ( result = new InstructionList ( ) ) ; translate ( classGen , methodGen ) ; methodGen . setInstructionList ( save ) ; return result ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( classGen , methodGen ) ; if ( _type instanceof BooleanType ) { desynthesize ( classGen , methodGen ) ; } } public void startIterator ( ClassGenerator classGen , MethodGenerator methodGen ) { if ( _type instanceof NodeSetType == false ) { return ; } Expression expr = this ; if ( expr instanceof CastExpr ) { expr = ( ( CastExpr ) expr ) . getExpr ( ) ; } if ( expr instanceof VariableRefBase == false ) { final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadContextNode ( ) ) ; il . append ( methodGen . setStartNode ( ) ) ; } } public void synthesize ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _trueList . backPatch ( il . append ( ICONST_1 ) ) ; final BranchHandle truec = il . append ( new GOTO_W ( null ) ) ; _falseList . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void desynthesize ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } public FlowList getFalseList ( ) { return _falseList ; } public FlowList getTrueList ( ) { return _trueList ; } public void backPatchFalseList ( InstructionHandle ih ) { _falseList . backPatch ( ih ) ; } public void backPatchTrueList ( InstructionHandle ih ) { _trueList . backPatch ( ih ) ; } public MethodType lookupPrimop ( SymbolTable stable , String op , MethodType ctype ) { MethodType result = null ; final Vector primop = stable . lookupPrimop ( op ) ; if ( primop != null ) { final int n = primop . size ( ) ; int minDistance = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { final MethodType ptype = ( MethodType ) primop . elementAt ( i ) ; if ( ptype . argsCount ( ) != ctype . argsCount ( ) ) { continue ; } if ( result == null ) { result = ptype ; } final int distance = ctype . distanceTo ( ptype ) ; if ( distance < minDistance ) { minDistance = distance ; result = ptype ; } } } return result ; } } 	0	['18', '2', '21', '83', '44', '117', '64', '22', '17', '0.803921569', '233', '1', '3', '0.76056338', '0.285714286', '1', '2', '11.77777778', '6', '1.4444', '0']
package org . apache . xalan . lib . sql ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . xsltc . compiler ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class FunctionAvailableCall extends FunctionCall { private Expression _arg ; private String _nameOfFunct = null ; private String _namespaceOfFunct = null ; private boolean _isFunctionAvailable = false ; public FunctionAvailableCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _arg = ( Expression ) arguments . elementAt ( 0 ) ; _type = null ; if ( _arg instanceof LiteralExpr ) { LiteralExpr arg = ( LiteralExpr ) _arg ; _namespaceOfFunct = arg . getNamespace ( ) ; _nameOfFunct = arg . getValue ( ) ; if ( ! isInternalNamespace ( ) ) { _isFunctionAvailable = hasMethods ( ) ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _type != null ) { return _type ; } if ( _arg instanceof LiteralExpr ) { return _type = Type . Boolean ; } ErrorMsg err = new ErrorMsg ( ErrorMsg . NEED_LITERAL_ERR , "function-available" , this ) ; throw new TypeCheckError ( err ) ; } public Object evaluateAtCompileTime ( ) { return getResult ( ) ? Boolean . TRUE : Boolean . FALSE ; } private boolean hasMethods ( ) { LiteralExpr arg = ( LiteralExpr ) _arg ; String className = getClassNameFromUri ( _namespaceOfFunct ) ; String methodName = null ; int colonIndex = _nameOfFunct . indexOf ( ":" ) ; if ( colonIndex > 0 ) { String functionName = _nameOfFunct . substring ( colonIndex + 1 ) ; int lastDotIndex = functionName . lastIndexOf ( '.' ) ; if ( lastDotIndex > 0 ) { methodName = functionName . substring ( lastDotIndex + 1 ) ; if ( className != null && ! className . equals ( "" ) ) className = className + "." + functionName . substring ( 0 , lastDotIndex ) ; else className = functionName . substring ( 0 , lastDotIndex ) ; } else methodName = functionName ; } else methodName = _nameOfFunct ; if ( className == null || methodName == null ) { return false ; } if ( methodName . indexOf ( '-' ) > 0 ) methodName = replaceDash ( methodName ) ; try { final Class clazz = ObjectFactory . findProviderClass ( className , ObjectFactory . findClassLoader ( ) , true ) ; if ( clazz == null ) { return false ; } final Method [ ] methods = clazz . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final int mods = methods [ i ] . getModifiers ( ) ; if ( Modifier . isPublic ( mods ) && Modifier . isStatic ( mods ) && methods [ i ] . getName ( ) . equals ( methodName ) ) { return true ; } } } catch ( ClassNotFoundException e ) { return false ; } return false ; } public boolean getResult ( ) { if ( _nameOfFunct == null ) { return false ; } if ( isInternalNamespace ( ) ) { final Parser parser = getParser ( ) ; _isFunctionAvailable = parser . functionSupported ( Util . getLocalName ( _nameOfFunct ) ) ; } return _isFunctionAvailable ; } private boolean isInternalNamespace ( ) { return ( _namespaceOfFunct == null || _namespaceOfFunct . equals ( EMPTYSTRING ) || _namespaceOfFunct . equals ( TRANSLET_URI ) ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; methodGen . getInstructionList ( ) . append ( new PUSH ( cpg , getResult ( ) ) ) ; } } 	0	['7', '4', '0', '19', '38', '7', '0', '19', '5', '0.458333333', '272', '1', '1', '0.941176471', '0.285714286', '3', '13', '37.28571429', '12', '3.2857', '0']
package org . apache . xalan . templates ; import java . text . DecimalFormatSymbols ; import org . apache . xml . utils . QName ; public class DecimalFormatProperties extends ElemTemplateElement { DecimalFormatSymbols m_dfs ; public DecimalFormatProperties ( int docOrderNumber ) { m_dfs = new java . text . DecimalFormatSymbols ( ) ; m_dfs . setInfinity ( Constants . ATTRVAL_INFINITY ) ; m_dfs . setNaN ( Constants . ATTRVAL_NAN ) ; m_docOrderNumber = docOrderNumber ; } public DecimalFormatSymbols getDecimalFormatSymbols ( ) { return m_dfs ; } private QName m_qname = null ; public void setName ( QName qname ) { m_qname = qname ; } public QName getName ( ) { if ( m_qname == null ) return new QName ( "" ) ; else return m_qname ; } public void setDecimalSeparator ( char ds ) { m_dfs . setDecimalSeparator ( ds ) ; } public char getDecimalSeparator ( ) { return m_dfs . getDecimalSeparator ( ) ; } public void setGroupingSeparator ( char gs ) { m_dfs . setGroupingSeparator ( gs ) ; } public char getGroupingSeparator ( ) { return m_dfs . getGroupingSeparator ( ) ; } public void setInfinity ( String inf ) { m_dfs . setInfinity ( inf ) ; } public String getInfinity ( ) { return m_dfs . getInfinity ( ) ; } public void setMinusSign ( char v ) { m_dfs . setMinusSign ( v ) ; } public char getMinusSign ( ) { return m_dfs . getMinusSign ( ) ; } public void setNaN ( String v ) { m_dfs . setNaN ( v ) ; } public String getNaN ( ) { return m_dfs . getNaN ( ) ; } public String getNodeName ( ) { return Constants . ELEMNAME_DECIMALFORMAT_STRING ; } public void setPercent ( char v ) { m_dfs . setPercent ( v ) ; } public char getPercent ( ) { return m_dfs . getPercent ( ) ; } public void setPerMille ( char v ) { m_dfs . setPerMill ( v ) ; } public char getPerMille ( ) { return m_dfs . getPerMill ( ) ; } public int getXSLToken ( ) { return Constants . ELEMNAME_DECIMALFORMAT ; } public void setZeroDigit ( char v ) { m_dfs . setZeroDigit ( v ) ; } public char getZeroDigit ( ) { return m_dfs . getZeroDigit ( ) ; } public void setDigit ( char v ) { m_dfs . setDigit ( v ) ; } public char getDigit ( ) { return m_dfs . getDigit ( ) ; } public void setPatternSeparator ( char v ) { m_dfs . setPatternSeparator ( v ) ; } public char getPatternSeparator ( ) { return m_dfs . getPatternSeparator ( ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeDecimalFormats ( this ) ; } } 	0	['27', '3', '0', '6', '51', '0', '4', '3', '27', '0.557692308', '167', '0.5', '1', '0.882882883', '0.24691358', '2', '5', '5.111111111', '2', '1', '0']
package org . apache . xalan . transformer ; import java . util . Enumeration ; import java . util . Stack ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . BoolStack ; import org . apache . xml . utils . IntStack ; import org . apache . xml . utils . NamespaceSupport2 ; import org . apache . xml . utils . NodeVector ; import org . apache . xml . utils . ObjectStack ; import org . apache . xpath . VariableStack ; import org . apache . xpath . XPathContext ; import org . xml . sax . helpers . NamespaceSupport ; import org . apache . xml . serializer . NamespaceMappings ; import org . apache . xml . serializer . SerializationHandler ; class TransformSnapshotImpl implements TransformSnapshot { private VariableStack m_variableStacks ; private IntStack m_currentNodes ; private IntStack m_currentExpressionNodes ; private Stack m_contextNodeLists ; private DTMIterator m_contextNodeList ; private Stack m_axesIteratorStack ; private BoolStack m_currentTemplateRuleIsNull ; private ObjectStack m_currentTemplateElements ; private Stack m_currentMatchTemplates ; private NodeVector m_currentMatchNodes ; private CountersTable m_countersTable ; private Stack m_attrSetStack ; boolean m_nsContextPushed ; private NamespaceMappings m_nsSupport ; TransformSnapshotImpl ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; { m_nsSupport = ( NamespaceMappings ) rtf . getNamespaceMappings ( ) . clone ( ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; m_variableStacks = ( VariableStack ) xpc . getVarStack ( ) . clone ( ) ; m_currentNodes = ( IntStack ) xpc . getCurrentNodeStack ( ) . clone ( ) ; m_currentExpressionNodes = ( IntStack ) xpc . getCurrentExpressionNodeStack ( ) . clone ( ) ; m_contextNodeLists = ( Stack ) xpc . getContextNodeListsStack ( ) . clone ( ) ; if ( ! m_contextNodeLists . empty ( ) ) m_contextNodeList = ( DTMIterator ) xpc . getContextNodeList ( ) . clone ( ) ; m_axesIteratorStack = ( Stack ) xpc . getAxesIteratorStackStacks ( ) . clone ( ) ; m_currentTemplateRuleIsNull = ( BoolStack ) transformer . m_currentTemplateRuleIsNull . clone ( ) ; m_currentTemplateElements = ( ObjectStack ) transformer . m_currentTemplateElements . clone ( ) ; m_currentMatchTemplates = ( Stack ) transformer . m_currentMatchTemplates . clone ( ) ; m_currentMatchNodes = ( NodeVector ) transformer . m_currentMatchedNodes . clone ( ) ; m_countersTable = ( CountersTable ) transformer . getCountersTable ( ) . clone ( ) ; if ( transformer . m_attrSetStack != null ) m_attrSetStack = ( Stack ) transformer . m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } void apply ( TransformerImpl transformer ) { try { SerializationHandler rtf = transformer . getResultTreeHandler ( ) ; if ( rtf != null ) { rtf . setNamespaceMappings ( ( NamespaceMappings ) m_nsSupport . clone ( ) ) ; } XPathContext xpc = transformer . getXPathContext ( ) ; xpc . setVarStack ( ( VariableStack ) m_variableStacks . clone ( ) ) ; xpc . setCurrentNodeStack ( ( IntStack ) m_currentNodes . clone ( ) ) ; xpc . setCurrentExpressionNodeStack ( ( IntStack ) m_currentExpressionNodes . clone ( ) ) ; xpc . setContextNodeListsStack ( ( Stack ) m_contextNodeLists . clone ( ) ) ; if ( m_contextNodeList != null ) xpc . pushContextNodeList ( ( DTMIterator ) m_contextNodeList . clone ( ) ) ; xpc . setAxesIteratorStackStacks ( ( Stack ) m_axesIteratorStack . clone ( ) ) ; transformer . m_currentTemplateRuleIsNull = ( BoolStack ) m_currentTemplateRuleIsNull . clone ( ) ; transformer . m_currentTemplateElements = ( ObjectStack ) m_currentTemplateElements . clone ( ) ; transformer . m_currentMatchTemplates = ( Stack ) m_currentMatchTemplates . clone ( ) ; transformer . m_currentMatchedNodes = ( NodeVector ) m_currentMatchNodes . clone ( ) ; transformer . m_countersTable = ( CountersTable ) m_countersTable . clone ( ) ; if ( m_attrSetStack != null ) transformer . m_attrSetStack = ( Stack ) m_attrSetStack . clone ( ) ; } catch ( CloneNotSupportedException cnse ) { throw new org . apache . xml . utils . WrappedRuntimeException ( cnse ) ; } } } 	0	['2', '1', '0', '13', '31', '0', '1', '13', '0', '0.142857143', '217', '0.928571429', '9', '0', '1', '0', '0', '100.5', '3', '1.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . RealType ; import org . apache . xalan . xsltc . compiler . util . StringType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class FormatNumberCall extends FunctionCall { private Expression _value ; private Expression _format ; private Expression _name ; private QName _resolvedQName = null ; public FormatNumberCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _value = argument ( 0 ) ; _format = argument ( 1 ) ; _name = argumentCount ( ) == 3 ? argument ( 2 ) : null ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { getStylesheet ( ) . numberFormattingUsed ( ) ; final Type tvalue = _value . typeCheck ( stable ) ; if ( tvalue instanceof RealType == false ) { _value = new CastExpr ( _value , Type . Real ) ; } final Type tformat = _format . typeCheck ( stable ) ; if ( tformat instanceof StringType == false ) { _format = new CastExpr ( _format , Type . String ) ; } if ( argumentCount ( ) == 3 ) { final Type tname = _name . typeCheck ( stable ) ; if ( _name instanceof LiteralExpr ) { final LiteralExpr literal = ( LiteralExpr ) _name ; _resolvedQName = getParser ( ) . getQNameIgnoreDefaultNs ( literal . getValue ( ) ) ; } else if ( tname instanceof StringType == false ) { _name = new CastExpr ( _name , Type . String ) ; } } return _type = Type . String ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _value . translate ( classGen , methodGen ) ; _format . translate ( classGen , methodGen ) ; final int fn3arg = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "formatNumber" , "(DLjava/lang/String;" + "Ljava/text/DecimalFormat;)" + "Ljava/lang/String;" ) ; final int get = cpg . addMethodref ( TRANSLET_CLASS , "getDecimalFormat" , "(Ljava/lang/String;)" + "Ljava/text/DecimalFormat;" ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( _name == null ) { il . append ( new PUSH ( cpg , EMPTYSTRING ) ) ; } else if ( _resolvedQName != null ) { il . append ( new PUSH ( cpg , _resolvedQName . toString ( ) ) ) ; } else { _name . translate ( classGen , methodGen ) ; } il . append ( new INVOKEVIRTUAL ( get ) ) ; il . append ( new INVOKESTATIC ( fn3arg ) ) ; } } 	0	['3', '4', '0', '22', '24', '0', '0', '22', '3', '0', '191', '1', '4', '0.979591837', '0.444444444', '3', '13', '61.33333333', '3', '1.3333', '0']
package org . apache . xpath . axes ; import java . util . Vector ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . WrappedRuntimeException ; public class IteratorPool implements java . io . Serializable { private final DTMIterator m_orig ; private final Vector m_freeStack ; public IteratorPool ( DTMIterator original ) { m_orig = original ; m_freeStack = new Vector ( ) ; } public synchronized DTMIterator getInstanceOrThrow ( ) throws CloneNotSupportedException { if ( m_freeStack . isEmpty ( ) ) { return ( DTMIterator ) m_orig . clone ( ) ; } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized DTMIterator getInstance ( ) { if ( m_freeStack . isEmpty ( ) ) { try { return ( DTMIterator ) m_orig . clone ( ) ; } catch ( Exception ex ) { throw new WrappedRuntimeException ( ex ) ; } } else { DTMIterator result = ( DTMIterator ) m_freeStack . lastElement ( ) ; m_freeStack . setSize ( m_freeStack . size ( ) - 1 ) ; return result ; } } public synchronized void freeInstance ( DTMIterator obj ) { m_freeStack . addElement ( obj ) ; } } 	0	['4', '1', '0', '4', '13', '0', '2', '2', '4', '0.166666667', '76', '1', '1', '0', '0.75', '0', '0', '17.5', '2', '1', '0']
package org . apache . xalan . xsltc ; public interface DOMCache { public DOM retrieveDocument ( String baseURI , String href , Translet translet ) ; } 	0	['1', '1', '0', '6', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xpath ; import java . util . Vector ; import org . apache . xpath . functions . FuncExtFunction ; public interface ExtensionsProvider { public boolean functionAvailable ( String ns , String funcName ) throws javax . xml . transform . TransformerException ; public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException ; public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey ) throws javax . xml . transform . TransformerException ; public Object extFunction ( FuncExtFunction extFunction , Vector argVec ) throws javax . xml . transform . TransformerException ; } 	0	['4', '1', '0', '4', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.55', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . xsltc . compiler . util ; import java . util . Stack ; public final class StringStack extends Stack { public String peekString ( ) { return ( String ) super . peek ( ) ; } public String popString ( ) { return ( String ) super . pop ( ) ; } public String pushString ( String val ) { return ( String ) super . push ( val ) ; } } 	0	['4', '5', '0', '0', '8', '6', '0', '0', '4', '2', '20', '0', '0', '0.963855422', '0.625', '0', '0', '4', '1', '0.75', '0']
package org . apache . xalan . templates ; public interface XSLTVisitable { public void callVisitors ( XSLTVisitor visitor ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . processor ; import org . apache . xalan . templates . DecimalFormatProperties ; import org . xml . sax . Attributes ; class ProcessorDecimalFormat extends XSLTElementProcessor { public void startElement ( StylesheetHandler handler , String uri , String localName , String rawName , Attributes attributes ) throws org . xml . sax . SAXException { DecimalFormatProperties dfp = new DecimalFormatProperties ( handler . nextUid ( ) ) ; dfp . setDOMBackPointer ( handler . getOriginatingNode ( ) ) ; dfp . setLocaterInfo ( handler . getLocator ( ) ) ; setPropertiesFromAttributes ( handler , rawName , attributes , dfp ) ; handler . getStylesheet ( ) . setDecimalFormat ( dfp ) ; handler . getStylesheet ( ) . appendChild ( dfp ) ; } } 	0	['2', '4', '0', '7', '13', '1', '1', '6', '1', '2', '35', '0', '0', '0.995260664', '0.625', '2', '3', '16.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class SortingIterator extends DTMAxisIteratorBase { private final static int INIT_DATA_SIZE = 16 ; private DTMAxisIterator _source ; private NodeSortRecordFactory _factory ; private NodeSortRecord [ ] _data ; private int _free = 0 ; private int _current ; public SortingIterator ( DTMAxisIterator source , NodeSortRecordFactory factory ) { _source = source ; _factory = factory ; } public int next ( ) { return _current < _free ? _data [ _current ++ ] . getNode ( ) : END ; } public DTMAxisIterator setStartNode ( int node ) { try { _source . setStartNode ( _startNode = node ) ; _data = new NodeSortRecord [ INIT_DATA_SIZE ] ; _free = 0 ; while ( ( node = _source . next ( ) ) != END ) { addRecord ( _factory . makeNodeSortRecord ( node , _free ) ) ; } quicksort ( 0 , _free - 1 ) ; _current = 0 ; return this ; } catch ( Exception e ) { return this ; } } public int getPosition ( ) { return _current == 0 ? 1 : _current ; } public int getLast ( ) { return _free ; } public void setMark ( ) { _source . setMark ( ) ; _markedNode = _current ; } public void gotoMark ( ) { _source . gotoMark ( ) ; _current = _markedNode ; } public DTMAxisIterator cloneIterator ( ) { try { final SortingIterator clone = ( SortingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _factory = _factory ; clone . _data = _data ; clone . _free = _free ; clone . _current = _current ; clone . setRestartable ( false ) ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } private void addRecord ( NodeSortRecord record ) { if ( _free == _data . length ) { NodeSortRecord [ ] newArray = new NodeSortRecord [ _data . length * 2 ] ; System . arraycopy ( _data , 0 , newArray , 0 , _free ) ; _data = newArray ; } _data [ _free ++ ] = record ; } private void quicksort ( int p , int r ) { while ( p < r ) { final int q = partition ( p , r ) ; quicksort ( p , q ) ; p = q + 1 ; } } private int partition ( int p , int r ) { final NodeSortRecord x = _data [ ( p + r ) > > > 1 ] ; int i = p - 1 ; int j = r + 1 ; while ( true ) { while ( x . compareTo ( _data [ -- j ] ) < 0 ) ; while ( x . compareTo ( _data [ ++ i ] ) > 0 ) ; if ( i < j ) { final NodeSortRecord t = _data [ i ] ; _data [ i ] = _data [ j ] ; _data [ j ] = t ; } else { return ( j ) ; } } } } 	0	['11', '2', '0', '5', '26', '0', '0', '5', '8', '0.666666667', '272', '1', '3', '0.565217391', '0.309090909', '1', '7', '23.18181818', '4', '1.6364', '0']
package org . apache . xalan . trace ; public interface TraceListener extends java . util . EventListener { public void trace ( TracerEvent ev ) ; public void selected ( SelectionEvent ev ) throws javax . xml . transform . TransformerException ; public void generated ( GenerateEvent ev ) ; } 	0	['3', '1', '0', '6', '3', '3', '3', '3', '3', '2', '3', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm ; public class DTMDOMException extends org . w3c . dom . DOMException { public DTMDOMException ( short code , String message ) { super ( code , message ) ; } public DTMDOMException ( short code ) { super ( code , "" ) ; } } 	0	['2', '5', '0', '3', '3', '1', '3', '0', '2', '2', '12', '0', '0', '1', '0.833333333', '0', '0', '5', '0', '0', '0']
package org . apache . xpath . operations ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class Gt extends Operation { public XObject operate ( XObject left , XObject right ) throws javax . xml . transform . TransformerException { return left . greaterThan ( right ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '3', '0', '4', '4', '1', '1', '3', '2', '2', '13', '0', '0', '0.976190476', '0.75', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xalan . xsltc . compiler . NodeTest ; public final class NodeType extends Type { private final int _type ; protected NodeType ( ) { this ( NodeTest . ANODE ) ; } protected NodeType ( int type ) { _type = type ; } public int getType ( ) { return _type ; } public String toString ( ) { return "node-type" ; } public boolean identicalTo ( Type other ) { return other instanceof NodeType ; } public int hashCode ( ) { return _type ; } public String toSignature ( ) { return "I" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . INT ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; switch ( _type ) { case NodeTest . ROOT : case NodeTest . ELEMENT : il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_ELEMENT_VALUE , GET_ELEMENT_VALUE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; break ; case NodeTest . ANODE : case NodeTest . COMMENT : case NodeTest . ATTRIBUTE : case NodeTest . PI : il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , GET_NODE_VALUE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; break ; default : ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; break ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( SINGLETON_ITERATOR ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; final int init = cpg . addMethodref ( SINGLETON_ITERATOR , "<init>" , "(" + NODE_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( RUNTIME_NODE_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new PUSH ( cpg , _type ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( RUNTIME_NODE_CLASS , "<init>" , "(II)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; String className = clazz . getName ( ) ; if ( className . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; return ; } il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; if ( className . equals ( "org.w3c.dom.Node" ) || className . equals ( "java.lang.Object" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( RUNTIME_NODE_CLASS ) ) ) ; il . append ( new GETFIELD ( cpg . addFieldref ( RUNTIME_NODE_CLASS , NODE_FIELD , NODE_FIELD_SIG ) ) ) ; } public String getClassName ( ) { return ( RUNTIME_NODE_CLASS ) ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } } 	0	['22', '2', '0', '42', '54', '199', '13', '32', '20', '0.571428571', '466', '1', '0', '0.622641509', '0.215909091', '2', '4', '20.13636364', '7', '1.4091', '0']
package org . apache . xalan . xsltc . trax ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '5', '44', '64', '3', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class ForwardPositionIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; public ForwardPositionIterator ( DTMAxisIterator source ) { _source = source ; } public DTMAxisIterator cloneIterator ( ) { try { final ForwardPositionIterator clone = ( ForwardPositionIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public int next ( ) { return returnNode ( _source . next ( ) ) ; } public DTMAxisIterator setStartNode ( int node ) { _source . setStartNode ( node ) ; return this ; } public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; } public void setMark ( ) { _source . setMark ( ) ; } public void gotoMark ( ) { _source . gotoMark ( ) ; } } 	0	['7', '2', '0', '3', '19', '0', '0', '3', '7', '0', '64', '1', '1', '0.684210526', '0.428571429', '1', '5', '8', '1', '0.8571', '0']
package org . apache . xalan . res ; public class XSLTErrorResources_en extends XSLTErrorResources { } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; final class KeyPattern extends IdKeyPattern { public KeyPattern ( String index , String value ) { super ( index , value ) ; } } 	0	['1', '6', '0', '1', '2', '0', '0', '1', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xml . utils . res ; import java . util . ListResourceBundle ; abstract public class XResourceBundleBase extends ListResourceBundle { abstract public String getMessageKey ( int errorCode ) ; abstract public String getWarningKey ( int errorCode ) ; } 	0	['3', '3', '0', '0', '4', '3', '0', '0', '3', '2', '6', '0', '0', '0.95', '0.833333333', '0', '0', '1', '1', '0.6667', '0']
package org . apache . xpath . functions ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; public class RTFIterator extends NodeSetDTM { public RTFIterator ( int root , DTMManager manager ) { super ( root , manager ) ; } } 	0	['1', '3', '0', '4', '2', '0', '2', '2', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . Transformer ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public class XalanTransformState implements TransformState { Node m_node = null ; ElemTemplateElement m_currentElement = null ; ElemTemplate m_currentTemplate = null ; ElemTemplate m_matchedTemplate = null ; int m_currentNodeHandle = DTM . NULL ; Node m_currentNode = null ; int m_matchedNode = DTM . NULL ; DTMIterator m_contextNodeList = null ; boolean m_elemPending = false ; TransformerImpl m_transformer = null ; public void setCurrentNode ( Node n ) { m_node = n ; } public void resetState ( Transformer transformer ) { if ( ( transformer != null ) && ( transformer instanceof TransformerImpl ) ) { m_transformer = ( TransformerImpl ) transformer ; m_currentElement = m_transformer . getCurrentElement ( ) ; m_currentTemplate = m_transformer . getCurrentTemplate ( ) ; m_matchedTemplate = m_transformer . getMatchedTemplate ( ) ; int currentNodeHandle = m_transformer . getCurrentNode ( ) ; DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( currentNodeHandle ) ; m_currentNode = dtm . getNode ( currentNodeHandle ) ; m_matchedNode = m_transformer . getMatchedNode ( ) ; m_contextNodeList = m_transformer . getContextNodeList ( ) ; } } public ElemTemplateElement getCurrentElement ( ) { if ( m_elemPending ) return m_currentElement ; else return m_transformer . getCurrentElement ( ) ; } public Node getCurrentNode ( ) { if ( m_currentNode != null ) { return m_currentNode ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getCurrentNode ( ) ) ; return dtm . getNode ( m_transformer . getCurrentNode ( ) ) ; } } public ElemTemplate getCurrentTemplate ( ) { if ( m_elemPending ) return m_currentTemplate ; else return m_transformer . getCurrentTemplate ( ) ; } public ElemTemplate getMatchedTemplate ( ) { if ( m_elemPending ) return m_matchedTemplate ; else return m_transformer . getMatchedTemplate ( ) ; } public Node getMatchedNode ( ) { if ( m_elemPending ) { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_matchedNode ) ; return dtm . getNode ( m_matchedNode ) ; } else { DTM dtm = m_transformer . getXPathContext ( ) . getDTM ( m_transformer . getMatchedNode ( ) ) ; return dtm . getNode ( m_transformer . getMatchedNode ( ) ) ; } } public NodeIterator getContextNodeList ( ) { if ( m_elemPending ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_contextNodeList ) ; } else { return new org . apache . xml . dtm . ref . DTMNodeIterator ( m_transformer . getContextNodeList ( ) ) ; } } public Transformer getTransformer ( ) { return m_transformer ; } } 	0	['10', '1', '0', '8', '21', '0', '1', '8', '10', '0.711111111', '205', '0', '5', '0', '0.4', '0', '0', '18.5', '3', '1.7', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . BranchInstruction ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFGE ; import org . apache . bcel . generic . IFGT ; import org . apache . bcel . generic . IFLE ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . IF_ICMPGE ; import org . apache . bcel . generic . IF_ICMPGT ; import org . apache . bcel . generic . IF_ICMPLE ; import org . apache . bcel . generic . IF_ICMPLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionConstants ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . NEW ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class IntType extends NumberType { protected IntType ( ) { } public String toString ( ) { return "int" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "I" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . INT ; } public int distanceTo ( Type type ) { if ( type == this ) { return 0 ; } else if ( type == Type . Real ) { return 1 ; } else return Integer . MAX_VALUE ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , final Type type ) { if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { methodGen . getInstructionList ( ) . append ( I2D ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( INTEGER_CLASS , "toString" , "(I)" + STRING_SIG ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; final BranchHandle falsec = il . append ( new IFEQ ( null ) ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new NEW ( cpg . addClass ( INTEGER_CLASS ) ) ) ; il . append ( DUP_X1 ) ; il . append ( SWAP ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( INTEGER_CLASS , "<init>" , "(I)V" ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz == Character . TYPE ) { il . append ( I2C ) ; } else if ( clazz == Byte . TYPE ) { il . append ( I2B ) ; } else if ( clazz == Short . TYPE ) { il . append ( I2S ) ; } else if ( clazz == Integer . TYPE ) { il . append ( NOP ) ; } else if ( clazz == Long . TYPE ) { il . append ( I2L ) ; } else if ( clazz == Float . TYPE ) { il . append ( I2F ) ; } else if ( clazz == Double . TYPE ) { il . append ( I2D ) ; } else if ( clazz . isAssignableFrom ( java . lang . Double . class ) ) { il . append ( I2D ) ; Type . Real . translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new CHECKCAST ( cpg . addClass ( INTEGER_CLASS ) ) ) ; final int index = cpg . addMethodref ( INTEGER_CLASS , INT_VALUE , INT_VALUE_SIG ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; } public Instruction ADD ( ) { return InstructionConstants . IADD ; } public Instruction SUB ( ) { return InstructionConstants . ISUB ; } public Instruction MUL ( ) { return InstructionConstants . IMUL ; } public Instruction DIV ( ) { return InstructionConstants . IDIV ; } public Instruction REM ( ) { return InstructionConstants . IREM ; } public Instruction NEG ( ) { return InstructionConstants . INEG ; } public Instruction LOAD ( int slot ) { return new ILOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ISTORE ( slot ) ; } public BranchInstruction GT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGT ( null ) : ( BranchInstruction ) new IF_ICMPGT ( null ) ; } public BranchInstruction GE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFGE ( null ) : ( BranchInstruction ) new IF_ICMPGE ( null ) ; } public BranchInstruction LT ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLT ( null ) : ( BranchInstruction ) new IF_ICMPLT ( null ) ; } public BranchInstruction LE ( boolean tozero ) { return tozero ? ( BranchInstruction ) new IFLE ( null ) : ( BranchInstruction ) new IF_ICMPLE ( null ) ; } } 	0	['27', '3', '0', '46', '60', '347', '8', '40', '26', '2', '407', '0', '0', '0.573770492', '0.202020202', '1', '3', '14.07407407', '9', '1.6667', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public final class NodeSetType extends Type { protected NodeSetType ( ) { } public String toString ( ) { return "node-set" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return NODE_ITERATOR_SIG ; } public org . apache . bcel . generic . Type toJCType ( ) { return new org . apache . bcel . generic . ObjectType ( NODE_ITERATOR ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { InstructionList il = methodGen . getInstructionList ( ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; if ( clazz . getName ( ) . equals ( "org.w3c.dom.NodeList" ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int convert = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "nodeList2Iterator" , "(" + "Lorg/w3c/dom/NodeList;" + TRANSLET_INTF_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( convert ) ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.Node" ) ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int convert = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "node2Iterator" , "(" + "Lorg/w3c/dom/Node;" + TRANSLET_INTF_SIG + DOM_INTF_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( convert ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; il . append ( DUP ) ; final BranchHandle falsec = il . append ( new IFLT ( null ) ) ; Type . Node . translateTo ( classGen , methodGen , type ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsec . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( classGen . getConstantPool ( ) , "" ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { translateTo ( classGen , methodGen , Type . String ) ; Type . String . translateTo ( classGen , methodGen , Type . Real ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { getFirstNode ( classGen , methodGen ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; getFirstNode ( classGen , methodGen ) ; return new FlowList ( il . append ( new IFLT ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final String className = clazz . getName ( ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) || className . equals ( "java.lang.Object" ) ) { int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.String" ) ) { int next = cpg . addInterfaceMethodref ( NODE_ITERATOR , "next" , "()I" ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , GET_NODE_VALUE , "(I)" + STRING_SIG ) ; il . append ( new INVOKEINTERFACE ( next , 1 ) ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } private void getFirstNode ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKEINTERFACE ( cpg . addInterfaceMethodref ( NODE_ITERATOR , NEXT , NEXT_SIG ) , 1 ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( NODE_ITERATOR ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['21', '2', '0', '42', '49', '190', '16', '29', '19', '2', '470', '0', '0', '0.622641509', '0.238095238', '2', '4', '21.38095238', '7', '1.5714', '0']
package org . apache . xalan . xsltc . dom ; import java . text . Collator ; import java . util . Locale ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; final class SortSettings { private AbstractTranslet _translet ; private int [ ] _sortOrders ; private int [ ] _types ; private Locale [ ] _locales ; private Collator [ ] _collators ; private String [ ] _caseOrders ; SortSettings ( AbstractTranslet translet , int [ ] sortOrders , int [ ] types , Locale [ ] locales , Collator [ ] collators , String [ ] caseOrders ) { _translet = translet ; _sortOrders = sortOrders ; _types = types ; _locales = locales ; _collators = collators ; _caseOrders = caseOrders ; } AbstractTranslet getTranslet ( ) { return _translet ; } int [ ] getSortOrders ( ) { return _sortOrders ; } int [ ] getTypes ( ) { return _types ; } Locale [ ] getLocales ( ) { return _locales ; } Collator [ ] getCollators ( ) { return _collators ; } String [ ] getCaseOrders ( ) { return _caseOrders ; } } 	0	['7', '1', '0', '3', '8', '9', '2', '1', '0', '0.833333333', '52', '1', '1', '0', '0.285714286', '0', '0', '5.571428571', '1', '0.8571', '0']
package org . apache . xalan . xsltc . runtime ; public class Parameter { public String _name ; public Object _value ; public boolean _isDefault ; public Parameter ( String name , Object value ) { _name = name ; _value = value ; _isDefault = true ; } public Parameter ( String name , Object value , boolean isDefault ) { _name = name ; _value = value ; _isDefault = isDefault ; } } 	0	['2', '1', '0', '2', '3', '0', '2', '0', '2', '0', '29', '0', '0', '0', '0.875', '0', '0', '12', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Iterator ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; public final class FlowList { private Vector _elements ; public FlowList ( ) { _elements = null ; } public FlowList ( InstructionHandle bh ) { _elements = new Vector ( ) ; _elements . addElement ( bh ) ; } public FlowList ( FlowList list ) { _elements = list . _elements ; } public FlowList add ( InstructionHandle bh ) { if ( _elements == null ) { _elements = new Vector ( ) ; } _elements . addElement ( bh ) ; return this ; } public FlowList append ( FlowList right ) { if ( _elements == null ) { _elements = right . _elements ; } else { final Vector temp = right . _elements ; if ( temp != null ) { final int n = temp . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { _elements . addElement ( temp . elementAt ( i ) ) ; } } } return this ; } public void backPatch ( InstructionHandle target ) { if ( _elements != null ) { final int n = _elements . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { BranchHandle bh = ( BranchHandle ) _elements . elementAt ( i ) ; bh . setTarget ( target ) ; } _elements . clear ( ) ; } } public FlowList copyAndRedirect ( InstructionList oldList , InstructionList newList ) { final FlowList result = new FlowList ( ) ; if ( _elements == null ) { return result ; } final int n = _elements . size ( ) ; final Iterator oldIter = oldList . iterator ( ) ; final Iterator newIter = newList . iterator ( ) ; while ( oldIter . hasNext ( ) ) { final InstructionHandle oldIh = ( InstructionHandle ) oldIter . next ( ) ; final InstructionHandle newIh = ( InstructionHandle ) newIter . next ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( _elements . elementAt ( i ) == oldIh ) { result . add ( newIh ) ; } } } return result ; } } 	0	['7', '1', '0', '30', '17', '0', '27', '3', '7', '0', '155', '1', '0', '0', '0.464285714', '0', '0', '21', '4', '1.8571', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncSubstringBefore extends Function2Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String s1 = m_arg0 . execute ( xctxt ) . str ( ) ; String s2 = m_arg1 . execute ( xctxt ) . str ( ) ; int index = s1 . indexOf ( s2 ) ; return ( - 1 == index ) ? XString . EMPTYSTRING : new XString ( s1 . substring ( 0 , index ) ) ; } } 	0	['2', '5', '0', '5', '8', '1', '0', '5', '2', '2', '34', '0', '0', '0.98245614', '0.75', '1', '6', '16', '1', '0.5', '0']
package org . apache . xalan . templates ; import java . util . Enumeration ; import java . util . Properties ; import java . util . Vector ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . TransformerException ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; import org . apache . xml . serializer . OutputPropertiesFactory ; import org . apache . xml . serializer . OutputPropertyUtils ; import org . apache . xml . utils . FastStringBuffer ; import org . apache . xml . utils . QName ; public class OutputProperties extends ElemTemplateElement implements Cloneable { public OutputProperties ( ) { this ( org . apache . xml . serializer . Method . XML ) ; } public OutputProperties ( Properties defaults ) { m_properties = new Properties ( defaults ) ; } public OutputProperties ( String method ) { m_properties = new Properties ( OutputPropertiesFactory . getDefaultMethodProperties ( method ) ) ; } public Object clone ( ) { try { OutputProperties cloned = ( OutputProperties ) super . clone ( ) ; cloned . m_properties = ( Properties ) cloned . m_properties . clone ( ) ; return cloned ; } catch ( CloneNotSupportedException e ) { return null ; } } public void setProperty ( QName key , String value ) { setProperty ( key . toNamespacedString ( ) , value ) ; } public void setProperty ( String key , String value ) { if ( key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( value ) ; } if ( key . startsWith ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL ) ) key = OutputPropertiesFactory . S_BUILTIN_EXTENSIONS_UNIVERSAL + key . substring ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN ) ; m_properties . put ( key , value ) ; } public String getProperty ( QName key ) { return m_properties . getProperty ( key . toNamespacedString ( ) ) ; } public String getProperty ( String key ) { if ( key . startsWith ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL ) ) key = OutputPropertiesFactory . S_BUILTIN_EXTENSIONS_UNIVERSAL + key . substring ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN ) ; return m_properties . getProperty ( key ) ; } public void setBooleanProperty ( QName key , boolean value ) { m_properties . put ( key . toNamespacedString ( ) , value ? "yes" : "no" ) ; } public void setBooleanProperty ( String key , boolean value ) { m_properties . put ( key , value ? "yes" : "no" ) ; } public boolean getBooleanProperty ( QName key ) { return getBooleanProperty ( key . toNamespacedString ( ) ) ; } public boolean getBooleanProperty ( String key ) { return OutputPropertyUtils . getBooleanProperty ( key , m_properties ) ; } public void setIntProperty ( QName key , int value ) { setIntProperty ( key . toNamespacedString ( ) , value ) ; } public void setIntProperty ( String key , int value ) { m_properties . put ( key , Integer . toString ( value ) ) ; } public int getIntProperty ( QName key ) { return getIntProperty ( key . toNamespacedString ( ) ) ; } public int getIntProperty ( String key ) { return OutputPropertyUtils . getIntProperty ( key , m_properties ) ; } public void setQNameProperty ( QName key , QName value ) { setQNameProperty ( key . toNamespacedString ( ) , value ) ; } public void setMethodDefaults ( String method ) { String defaultMethod = m_properties . getProperty ( OutputKeys . METHOD ) ; if ( ( null == defaultMethod ) || ! defaultMethod . equals ( method ) || defaultMethod . equals ( "xml" ) ) { Properties savedProps = m_properties ; Properties newDefaults = OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; m_properties = new Properties ( newDefaults ) ; copyFrom ( savedProps , false ) ; } } public void setQNameProperty ( String key , QName value ) { setProperty ( key , value . toNamespacedString ( ) ) ; } public QName getQNameProperty ( QName key ) { return getQNameProperty ( key . toNamespacedString ( ) ) ; } public QName getQNameProperty ( String key ) { return getQNameProperty ( key , m_properties ) ; } public static QName getQNameProperty ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) return QName . getQNameFromString ( s ) ; else return null ; } public void setQNameProperties ( QName key , Vector v ) { setQNameProperties ( key . toNamespacedString ( ) , v ) ; } public void setQNameProperties ( String key , Vector v ) { int s = v . size ( ) ; FastStringBuffer fsb = new FastStringBuffer ( 9 , 9 ) ; for ( int i = 0 ; i < s ; i ++ ) { QName qname = ( QName ) v . elementAt ( i ) ; fsb . append ( qname . toNamespacedString ( ) ) ; if ( i < s - 1 ) fsb . append ( ' ' ) ; } m_properties . put ( key , fsb . toString ( ) ) ; } public Vector getQNameProperties ( QName key ) { return getQNameProperties ( key . toNamespacedString ( ) ) ; } public Vector getQNameProperties ( String key ) { return getQNameProperties ( key , m_properties ) ; } public static Vector getQNameProperties ( String key , Properties props ) { String s = props . getProperty ( key ) ; if ( null != s ) { Vector v = new Vector ( ) ; int l = s . length ( ) ; boolean inCurly = false ; FastStringBuffer buf = new FastStringBuffer ( ) ; for ( int i = 0 ; i < l ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! inCurly ) { if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } continue ; } } else if ( '{' == c ) inCurly = true ; else if ( '}' == c ) inCurly = false ; buf . append ( c ) ; } if ( buf . length ( ) > 0 ) { QName qname = QName . getQNameFromString ( buf . toString ( ) ) ; v . addElement ( qname ) ; buf . reset ( ) ; } return v ; } else return null ; } public void recompose ( StylesheetRoot root ) throws TransformerException { root . recomposeOutput ( this ) ; } public void compose ( StylesheetRoot sroot ) throws TransformerException { super . compose ( sroot ) ; } public Properties getProperties ( ) { return m_properties ; } public void copyFrom ( Properties src ) { copyFrom ( src , true ) ; } public void copyFrom ( Properties src , boolean shouldResetDefaults ) { Enumeration keys = src . keys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = ( String ) keys . nextElement ( ) ; if ( ! isLegalPropertyKey ( key ) ) throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_OUTPUT_PROPERTY_NOT_RECOGNIZED , new Object [ ] { key } ) ) ; Object oldValue = m_properties . get ( key ) ; if ( null == oldValue ) { String val = ( String ) src . get ( key ) ; if ( shouldResetDefaults && key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( val ) ; } m_properties . put ( key , val ) ; } else if ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) ) { m_properties . put ( key , ( String ) oldValue + " " + ( String ) src . get ( key ) ) ; } } } public void copyFrom ( OutputProperties opsrc ) throws TransformerException { copyFrom ( opsrc . getProperties ( ) ) ; } public static boolean isLegalPropertyKey ( String key ) { return ( key . equals ( OutputKeys . CDATA_SECTION_ELEMENTS ) || key . equals ( OutputKeys . DOCTYPE_PUBLIC ) || key . equals ( OutputKeys . DOCTYPE_SYSTEM ) || key . equals ( OutputKeys . ENCODING ) || key . equals ( OutputKeys . INDENT ) || key . equals ( OutputKeys . MEDIA_TYPE ) || key . equals ( OutputKeys . METHOD ) || key . equals ( OutputKeys . OMIT_XML_DECLARATION ) || key . equals ( OutputKeys . STANDALONE ) || key . equals ( OutputKeys . VERSION ) || ( key . length ( ) > 0 ) && ( key . charAt ( 0 ) == '{' ) && ( key . lastIndexOf ( '{' ) == 0 ) && ( key . indexOf ( '}' ) > 0 ) && ( key . lastIndexOf ( '}' ) == key . indexOf ( '}' ) ) ) ; } private Properties m_properties = null ; static public Properties getDefaultMethodProperties ( String method ) { return org . apache . xml . serializer . OutputPropertiesFactory . getDefaultMethodProperties ( method ) ; } } 	0	['35', '3', '0', '14', '77', '323', '8', '7', '35', '0.205882353', '571', '1', '0', '0.859649123', '0.234920635', '0', '0', '15.28571429', '16', '2.0286', '0']
package org . apache . xml . utils ; public class StringVector implements java . io . Serializable { protected int m_blocksize ; protected String m_map [ ] ; protected int m_firstFree = 0 ; protected int m_mapSize ; public StringVector ( ) { m_blocksize = 8 ; m_mapSize = m_blocksize ; m_map = new String [ m_blocksize ] ; } public StringVector ( int blocksize ) { m_blocksize = blocksize ; m_mapSize = blocksize ; m_map = new String [ blocksize ] ; } public int getLength ( ) { return m_firstFree ; } public final int size ( ) { return m_firstFree ; } public final void addElement ( String value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } public final String elementAt ( int i ) { return m_map [ i ] ; } public final boolean contains ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equals ( s ) ) return true ; } return false ; } public final boolean containsIgnoreCase ( String s ) { if ( null == s ) return false ; for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] . equalsIgnoreCase ( s ) ) return true ; } return false ; } public final void push ( String s ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; String newMap [ ] = new String [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = s ; m_firstFree ++ ; } public final String pop ( ) { if ( m_firstFree <= 0 ) return null ; m_firstFree -- ; String s = m_map [ m_firstFree ] ; m_map [ m_firstFree ] = null ; return s ; } public final String peek ( ) { return ( m_firstFree <= 0 ) ? null : m_map [ m_firstFree - 1 ] ; } } 	0	['11', '1', '0', '8', '15', '0', '8', '0', '11', '0.425', '234', '1', '0', '0', '0.515151515', '0', '0', '19.90909091', '4', '1.7273', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; import org . apache . xml . dtm . ref . DTMDefaultBase ; public final class DupFilterIterator extends DTMAxisIteratorBase { private DTMAxisIterator _source ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _current = 0 ; private int _nodesSize = 0 ; private int _lastNext = END ; private int _markedLastNext = END ; public DupFilterIterator ( DTMAxisIterator source ) { _source = source ; if ( source instanceof KeyIndex ) { setStartNode ( DTMDefaultBase . ROOTNODE ) ; } } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { if ( _source instanceof KeyIndex && _startNode == DTMDefaultBase . ROOTNODE ) { return this ; } if ( node != _startNode ) { _source . setStartNode ( _startNode = node ) ; _nodes . clear ( ) ; while ( ( node = _source . next ( ) ) != END ) { _nodes . add ( node ) ; } _nodes . sort ( ) ; _nodesSize = _nodes . cardinality ( ) ; _current = 0 ; _lastNext = END ; resetPosition ( ) ; } } return this ; } public int next ( ) { while ( _current < _nodesSize ) { final int next = _nodes . at ( _current ++ ) ; if ( next != _lastNext ) { return returnNode ( _lastNext = next ) ; } } return END ; } public DTMAxisIterator cloneIterator ( ) { try { final DupFilterIterator clone = ( DupFilterIterator ) super . clone ( ) ; clone . _nodes = ( IntegerArray ) _nodes . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public void setMark ( ) { _markedNode = _current ; _markedLastNext = _lastNext ; } public void gotoMark ( ) { _current = _markedNode ; _lastNext = _markedLastNext ; } public DTMAxisIterator reset ( ) { _current = 0 ; _lastNext = END ; return resetPosition ( ) ; } } 	0	['8', '2', '0', '6', '25', '0', '1', '5', '8', '0.476190476', '195', '1', '2', '0.65', '0.34375', '1', '5', '22.625', '6', '1.625', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ValueOf extends Instruction { private Expression _select ; private boolean _escaping = true ; private boolean _isString = false ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "ValueOf" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } final String str = getAttribute ( "disable-output-escaping" ) ; if ( ( str != null ) && ( str . equals ( "yes" ) ) ) _escaping = false ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { Type type = _select . typeCheck ( stable ) ; if ( type != null && ! type . identicalTo ( Type . Node ) ) { if ( type . identicalTo ( Type . NodeSet ) ) { _select = new CastExpr ( _select , Type . Node ) ; } else { _isString = true ; if ( ! type . identicalTo ( Type . String ) ) { _select = new CastExpr ( _select , Type . String ) ; } _isString = true ; } } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final int setEscaping = cpg . addInterfaceMethodref ( OUTPUT_HANDLER , "setEscaping" , "(Z)Z" ) ; if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , false ) ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; } if ( _isString ) { final int characters = cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( characters ) ) ; } else { final int characters = cpg . addInterfaceMethodref ( DOM_INTF , CHARACTERS , CHARACTERS_SIG ) ; il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( characters , 3 ) ) ; } if ( ! _escaping ) { il . append ( methodGen . loadHandler ( ) ) ; il . append ( SWAP ) ; il . append ( new INVOKEINTERFACE ( setEscaping , 2 ) ) ; il . append ( POP ) ; } } } 	0	['5', '3', '0', '21', '33', '0', '2', '20', '4', '0.416666667', '237', '1', '1', '0.933333333', '0.333333333', '2', '6', '45.8', '4', '2', '0']
package org . apache . xalan . templates ; import org . apache . xalan . res . XSLTErrorResources ; public class ElemText extends ElemTemplateElement { private boolean m_disableOutputEscaping = false ; public void setDisableOutputEscaping ( boolean v ) { m_disableOutputEscaping = v ; } public boolean getDisableOutputEscaping ( ) { return m_disableOutputEscaping ; } public int getXSLToken ( ) { return Constants . ELEMNAME_TEXT ; } public String getNodeName ( ) { return Constants . ELEMNAME_TEXT_STRING ; } public ElemTemplateElement appendChild ( ElemTemplateElement newChild ) { int type = ( ( ElemTemplateElement ) newChild ) . getXSLToken ( ) ; switch ( type ) { case Constants . ELEMNAME_TEXTLITERALRESULT : break ; default : error ( XSLTErrorResources . ER_CANNOT_ADD , new Object [ ] { newChild . getNodeName ( ) , this . getNodeName ( ) } ) ; } return super . appendChild ( newChild ) ; } } 	0	['6', '3', '0', '4', '11', '9', '3', '1', '6', '0.6', '49', '1', '0', '0.975124378', '0.444444444', '2', '6', '7', '3', '1.1667', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class BooleanCall extends FunctionCall { private Expression _arg = null ; public BooleanCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; _arg = argument ( 0 ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _arg . typeCheck ( stable ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { _arg . translate ( classGen , methodGen ) ; final Type targ = _arg . getType ( ) ; if ( ! targ . identicalTo ( Type . Boolean ) ) { _arg . startIterator ( classGen , methodGen ) ; targ . translateTo ( classGen , methodGen , Type . Boolean ) ; } } } 	0	['3', '4', '0', '8', '11', '0', '0', '8', '3', '0', '51', '1', '1', '0.979591837', '0.444444444', '3', '13', '15.66666667', '2', '1', '0']
package org . apache . xpath ; public class XPathProcessorException extends XPathException { public XPathProcessorException ( String message ) { super ( message ) ; } public XPathProcessorException ( String message , Exception e ) { super ( message , e ) ; } } 	0	['2', '5', '0', '4', '4', '1', '3', '1', '2', '2', '11', '0', '0', '1', '0.833333333', '0', '0', '4.5', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . Type ; final class SlotAllocator { private int _firstAvailableSlot ; private int _size = 8 ; private int _free = 0 ; private int [ ] _slotsTaken = new int [ _size ] ; public void initialize ( LocalVariableGen [ ] vars ) { final int length = vars . length ; int slot = 0 , size , index ; for ( int i = 0 ; i < length ; i ++ ) { size = vars [ i ] . getType ( ) . getSize ( ) ; index = vars [ i ] . getIndex ( ) ; slot = Math . max ( slot , index + size ) ; } _firstAvailableSlot = slot ; } public int allocateSlot ( Type type ) { final int size = type . getSize ( ) ; final int limit = _free ; int slot = _firstAvailableSlot , where = 0 ; if ( _free + size > _size ) { final int [ ] array = new int [ _size *= 2 ] ; for ( int j = 0 ; j < limit ; j ++ ) array [ j ] = _slotsTaken [ j ] ; _slotsTaken = array ; } while ( where < limit ) { if ( slot + size <= _slotsTaken [ where ] ) { for ( int j = limit - 1 ; j >= where ; j -- ) _slotsTaken [ j + size ] = _slotsTaken [ j ] ; break ; } else { slot = _slotsTaken [ where ++ ] + 1 ; } } for ( int j = 0 ; j < size ; j ++ ) _slotsTaken [ where + j ] = slot + j ; _free += size ; return slot ; } public void releaseSlot ( LocalVariableGen lvg ) { final int size = lvg . getType ( ) . getSize ( ) ; final int slot = lvg . getIndex ( ) ; final int limit = _free ; for ( int i = 0 ; i < limit ; i ++ ) { if ( _slotsTaken [ i ] == slot ) { int j = i + size ; while ( j < limit ) { _slotsTaken [ i ++ ] = _slotsTaken [ j ++ ] ; } _free -= size ; return ; } } String state = "Variable slot allocation error" + "(size=" + size + ", slot=" + slot + ", limit=" + limit + ")" ; ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , state ) ; throw new Error ( err . toString ( ) ) ; } } 	0	['4', '1', '0', '4', '16', '0', '1', '3', '3', '0.5', '242', '1', '0', '0', '0.4375', '0', '0', '58.5', '6', '3', '0']
package org . apache . xml . utils ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ClassGen ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; public final class AttributeSetMethodGenerator extends MethodGenerator { private static final int DOM_INDEX = 1 ; private static final int ITERATOR_INDEX = 2 ; private static final int HANDLER_INDEX = 3 ; private static final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; private static final String [ ] argNames = new String [ 3 ] ; static { argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argNames [ 0 ] = DOM_PNAME ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argNames [ 1 ] = ITERATOR_PNAME ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; } private final Instruction _aloadDom ; private final Instruction _astoreDom ; private final Instruction _astoreIterator ; private final Instruction _aloadIterator ; private final Instruction _astoreHandler ; private final Instruction _aloadHandler ; public AttributeSetMethodGenerator ( String methodName , ClassGen classGen ) { super ( org . apache . bcel . Constants . ACC_PRIVATE , org . apache . bcel . generic . Type . VOID , argTypes , argNames , methodName , classGen . getClassName ( ) , new InstructionList ( ) , classGen . getConstantPool ( ) ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _astoreDom = new ASTORE ( DOM_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _astoreHandler = new ASTORE ( HANDLER_INDEX ) ; _aloadHandler = new ALOAD ( HANDLER_INDEX ) ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getIteratorIndex ( ) { return ITERATOR_INDEX ; } public Instruction storeHandler ( ) { return _astoreHandler ; } public Instruction loadHandler ( ) { return _aloadHandler ; } public int getLocalIndex ( String name ) { return INVALID_INDEX ; } } 	0	['8', '5', '0', '11', '15', '18', '1', '10', '7', '0.961038961', '120', '1', '0', '0.958333333', '0.476190476', '1', '2', '12.625', '1', '0.75', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . PredicatedNodeTest ; import org . apache . xpath . objects . XNodeSet ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xalan . res . XSLMessages ; import org . apache . xalan . res . XSLTErrorResources ; public class FuncCurrent extends Function { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { SubContextList subContextList = xctxt . getCurrentNodeList ( ) ; int currentNode = DTM . NULL ; if ( null != subContextList ) { if ( subContextList instanceof PredicatedNodeTest ) { LocPathIterator iter = ( ( PredicatedNodeTest ) subContextList ) . getLocPathIterator ( ) ; currentNode = iter . getCurrentContextNode ( ) ; } else if ( subContextList instanceof StepPattern ) { throw new RuntimeException ( XSLMessages . createMessage ( XSLTErrorResources . ER_PROCESSOR_ERROR , null ) ) ; } } else { currentNode = xctxt . getContextNode ( ) ; } return new XNodeSet ( currentNode , xctxt . getDTMManager ( ) ) ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['3', '3', '0', '11', '12', '3', '1', '10', '3', '2', '46', '0', '0', '0.95', '0.5', '1', '6', '14.33333333', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; final class QName { private final String _localname ; private String _prefix ; private String _namespace ; private String _stringRep ; private int _hashCode ; public QName ( String namespace , String prefix , String localname ) { _namespace = namespace ; _prefix = prefix ; _localname = localname ; _stringRep = ( namespace != null && ! namespace . equals ( Constants . EMPTYSTRING ) ) ? ( namespace + ':' + localname ) : localname ; _hashCode = _stringRep . hashCode ( ) + 19 ; } public void clearNamespace ( ) { _namespace = Constants . EMPTYSTRING ; } public String toString ( ) { return _stringRep ; } public String getStringRep ( ) { return _stringRep ; } public boolean equals ( Object other ) { return ( this == other ) ; } public String getLocalPart ( ) { return _localname ; } public String getNamespace ( ) { return _namespace ; } public String getPrefix ( ) { return _prefix ; } public int hashCode ( ) { return _hashCode ; } public String dump ( ) { return new String ( "QName: " + _namespace + "(" + _prefix + "):" + _localname ) ; } } 	0	['10', '1', '0', '57', '18', '17', '57', '0', '10', '0.777777778', '106', '1', '0', '0', '0.4', '1', '1', '9.1', '2', '1', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class UseAttributeSets extends Instruction { private final static String ATTR_SET_NOT_FOUND = "" ; private final Vector _sets = new Vector ( 2 ) ; public UseAttributeSets ( String setNames , Parser parser ) { setParser ( parser ) ; addAttributeSets ( setNames ) ; } public void addAttributeSets ( String setNames ) { if ( ( setNames != null ) && ( ! setNames . equals ( Constants . EMPTYSTRING ) ) ) { final StringTokenizer tokens = new StringTokenizer ( setNames ) ; while ( tokens . hasMoreTokens ( ) ) { final QName qname = getParser ( ) . getQNameIgnoreDefaultNs ( tokens . nextToken ( ) ) ; _sets . add ( qname ) ; } } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final SymbolTable symbolTable = getParser ( ) . getSymbolTable ( ) ; for ( int i = 0 ; i < _sets . size ( ) ; i ++ ) { final QName name = ( QName ) _sets . elementAt ( i ) ; final AttributeSet attrs = symbolTable . lookupAttributeSet ( name ) ; if ( attrs != null ) { final String methodName = attrs . getMethodName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( methodGen . loadIterator ( ) ) ; il . append ( methodGen . loadHandler ( ) ) ; final int method = cpg . addMethodref ( classGen . getClassName ( ) , methodName , ATTR_SET_SIG ) ; il . append ( new INVOKESPECIAL ( method ) ) ; } else { final Parser parser = getParser ( ) ; final String atrs = name . toString ( ) ; reportError ( this , parser , ErrorMsg . ATTRIBSET_UNDEF_ERR , atrs ) ; } } } } 	0	['4', '3', '0', '19', '31', '0', '5', '15', '4', '0.833333333', '132', '1', '0', '0.949152542', '0.416666667', '1', '4', '31.5', '4', '2', '0']
package org . apache . xpath ; public class FoundIndex extends RuntimeException { public FoundIndex ( ) { } } 	0	['1', '4', '0', '0', '2', '0', '0', '0', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xml . utils . synthetic . reflection ; public class Constructor extends EntryPoint implements Member { private org . apache . xml . utils . synthetic . Class declaringclass = null ; private java . lang . reflect . Constructor realconstructor = null ; private org . apache . xml . utils . synthetic . Class [ ] parametertypes ; private String [ ] parameternames ; private org . apache . xml . utils . synthetic . Class [ ] exceptiontypes ; private int modifiers ; public Constructor ( org . apache . xml . utils . synthetic . Class declaringclass ) { super ( declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor ctor , org . apache . xml . utils . synthetic . Class declaringclass ) { super ( ctor , declaringclass ) ; } public Constructor ( java . lang . reflect . Constructor realconstructor ) { super ( realconstructor ) ; } public int hashCode ( ) { return getDeclaringClass ( ) . getName ( ) . hashCode ( ) ; } public Object newInstance ( Object initargs [ ] ) throws InstantiationException , IllegalAccessException , IllegalArgumentException , java . lang . reflect . InvocationTargetException { if ( realep != null ) return ( ( java . lang . reflect . Constructor ) realep ) . newInstance ( initargs ) ; else throw new InstantiationException ( "Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation" ) ; } } 	0	['5', '2', '0', '3', '13', '4', '2', '3', '5', '1', '61', '1', '3', '0.904761905', '0.5', '1', '1', '10', '1', '0.4', '0']
package org . apache . xalan . xsltc . trax ; import java . io . IOException ; import java . util . Hashtable ; import java . util . Stack ; import java . util . Vector ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . xml . sax . ContentHandler ; import org . xml . sax . DTDHandler ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; import org . xml . sax . ext . LexicalHandler ; import org . xml . sax . helpers . AttributesImpl ; import org . apache . xalan . xsltc . dom . SAXImpl ; public class DOM2SAX implements XMLReader , Locator { private final static String EMPTYSTRING = "" ; private static final String XMLNS_PREFIX = "xmlns" ; private Node _dom = null ; private ContentHandler _sax = null ; private LexicalHandler _lex = null ; private SAXImpl _saxImpl = null ; private Hashtable _nsPrefixes = new Hashtable ( ) ; public DOM2SAX ( Node root ) { _dom = root ; } public ContentHandler getContentHandler ( ) { return _sax ; } public void setContentHandler ( ContentHandler handler ) throws NullPointerException { _sax = handler ; if ( handler instanceof LexicalHandler ) { _lex = ( LexicalHandler ) handler ; } if ( handler instanceof SAXImpl ) { _saxImpl = ( SAXImpl ) handler ; } } private boolean startPrefixMapping ( String prefix , String uri ) throws SAXException { boolean pushed = true ; Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { if ( uriStack . isEmpty ( ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { final String lastUri = ( String ) uriStack . peek ( ) ; if ( ! lastUri . equals ( uri ) ) { _sax . startPrefixMapping ( prefix , uri ) ; uriStack . push ( uri ) ; } else { pushed = false ; } } } else { _sax . startPrefixMapping ( prefix , uri ) ; _nsPrefixes . put ( prefix , uriStack = new Stack ( ) ) ; uriStack . push ( uri ) ; } return pushed ; } private void endPrefixMapping ( String prefix ) throws SAXException { final Stack uriStack = ( Stack ) _nsPrefixes . get ( prefix ) ; if ( uriStack != null ) { _sax . endPrefixMapping ( prefix ) ; uriStack . pop ( ) ; } } private static String getLocalName ( Node node ) { final String localName = node . getLocalName ( ) ; if ( localName == null ) { final String qname = node . getNodeName ( ) ; final int col = qname . lastIndexOf ( ':' ) ; return ( col > 0 ) ? qname . substring ( col + 1 ) : qname ; } return localName ; } public void parse ( InputSource unused ) throws IOException , SAXException { parse ( _dom ) ; } public void parse ( ) throws IOException , SAXException { if ( _dom != null ) { boolean isIncomplete = ( _dom . getNodeType ( ) != org . w3c . dom . Node . DOCUMENT_NODE ) ; if ( isIncomplete ) { _sax . startDocument ( ) ; parse ( _dom ) ; _sax . endDocument ( ) ; } else { parse ( _dom ) ; } } } private void parse ( Node node ) throws IOException , SAXException { Node first = null ; if ( node == null ) return ; switch ( node . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . NOTATION_NODE : break ; case Node . CDATA_SECTION_NODE : final String cdata = node . getNodeValue ( ) ; if ( _lex != null ) { _lex . startCDATA ( ) ; _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; _lex . endCDATA ( ) ; } else { _sax . characters ( cdata . toCharArray ( ) , 0 , cdata . length ( ) ) ; } break ; case Node . COMMENT_NODE : if ( _lex != null ) { final String value = node . getNodeValue ( ) ; _lex . comment ( value . toCharArray ( ) , 0 , value . length ( ) ) ; } break ; case Node . DOCUMENT_NODE : _sax . setDocumentLocator ( this ) ; _sax . startDocument ( ) ; Node next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endDocument ( ) ; break ; case Node . ELEMENT_NODE : String prefix ; Vector pushedPrefixes = new Vector ( ) ; final AttributesImpl attrs = new AttributesImpl ( ) ; final NamedNodeMap map = node . getAttributes ( ) ; final int length = map . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNodeValue ( ) ; final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( colon + 1 ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } } for ( int i = 0 ; i < length ; i ++ ) { final Node attr = map . item ( i ) ; final String qnameAttr = attr . getNodeName ( ) ; if ( ! qnameAttr . startsWith ( XMLNS_PREFIX ) ) { final String uriAttr = attr . getNamespaceURI ( ) ; final String localNameAttr = getLocalName ( attr ) ; if ( uriAttr != null ) { final int colon = qnameAttr . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qnameAttr . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uriAttr ) ) { pushedPrefixes . addElement ( prefix ) ; } } attrs . addAttribute ( attr . getNamespaceURI ( ) , getLocalName ( attr ) , qnameAttr , "CDATA" , attr . getNodeValue ( ) ) ; } } final String qname = node . getNodeName ( ) ; final String uri = node . getNamespaceURI ( ) ; final String localName = getLocalName ( node ) ; if ( uri != null ) { final int colon = qname . lastIndexOf ( ':' ) ; prefix = ( colon > 0 ) ? qname . substring ( 0 , colon ) : EMPTYSTRING ; if ( startPrefixMapping ( prefix , uri ) ) { pushedPrefixes . addElement ( prefix ) ; } } if ( _saxImpl != null ) { _saxImpl . startElement ( uri , localName , qname , attrs , node ) ; } else { _sax . startElement ( uri , localName , qname , attrs ) ; } next = node . getFirstChild ( ) ; while ( next != null ) { parse ( next ) ; next = next . getNextSibling ( ) ; } _sax . endElement ( uri , localName , qname ) ; final int nPushedPrefixes = pushedPrefixes . size ( ) ; for ( int i = 0 ; i < nPushedPrefixes ; i ++ ) { endPrefixMapping ( ( String ) pushedPrefixes . elementAt ( i ) ) ; } break ; case Node . PROCESSING_INSTRUCTION_NODE : _sax . processingInstruction ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; break ; case Node . TEXT_NODE : final String data = node . getNodeValue ( ) ; _sax . characters ( data . toCharArray ( ) , 0 , data . length ( ) ) ; break ; } } public DTDHandler getDTDHandler ( ) { return null ; } public ErrorHandler getErrorHandler ( ) { return null ; } public boolean getFeature ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return false ; } public void setFeature ( String name , boolean value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public void parse ( String sysId ) throws IOException , SAXException { throw new IOException ( "This method is not yet implemented." ) ; } public void setDTDHandler ( DTDHandler handler ) throws NullPointerException { } public void setEntityResolver ( EntityResolver resolver ) throws NullPointerException { } public EntityResolver getEntityResolver ( ) { return null ; } public void setErrorHandler ( ErrorHandler handler ) throws NullPointerException { } public void setProperty ( String name , Object value ) throws SAXNotRecognizedException , SAXNotSupportedException { } public Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { return null ; } public int getColumnNumber ( ) { return 0 ; } public int getLineNumber ( ) { return 0 ; } public String getPublicId ( ) { return null ; } public String getSystemId ( ) { return null ; } private String getNodeTypeFromCode ( short code ) { String retval = null ; switch ( code ) { case Node . ATTRIBUTE_NODE : retval = "ATTRIBUTE_NODE" ; break ; case Node . CDATA_SECTION_NODE : retval = "CDATA_SECTION_NODE" ; break ; case Node . COMMENT_NODE : retval = "COMMENT_NODE" ; break ; case Node . DOCUMENT_FRAGMENT_NODE : retval = "DOCUMENT_FRAGMENT_NODE" ; break ; case Node . DOCUMENT_NODE : retval = "DOCUMENT_NODE" ; break ; case Node . DOCUMENT_TYPE_NODE : retval = "DOCUMENT_TYPE_NODE" ; break ; case Node . ELEMENT_NODE : retval = "ELEMENT_NODE" ; break ; case Node . ENTITY_NODE : retval = "ENTITY_NODE" ; break ; case Node . ENTITY_REFERENCE_NODE : retval = "ENTITY_REFERENCE_NODE" ; break ; case Node . NOTATION_NODE : retval = "NOTATION_NODE" ; break ; case Node . PROCESSING_INSTRUCTION_NODE : retval = "PROCESSING_INSTRUCTION_NODE" ; break ; case Node . TEXT_NODE : retval = "TEXT_NODE" ; break ; } return retval ; } } 	0	['25', '1', '0', '4', '71', '254', '3', '1', '20', '0.892857143', '582', '1', '1', '0', '0.152727273', '0', '0', '22', '3', '1.08', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class RoundCall extends FunctionCall { public RoundCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , "roundF" , "(D)D" ) ) ) ; } } 	0	['2', '4', '0', '10', '10', '1', '0', '10', '2', '2', '30', '0', '0', '0.989690722', '0.6', '2', '4', '14', '1', '0.5', '0']
package org . apache . xalan . xsltc . runtime ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; import org . apache . xml . dtm . DTM ; public final class ReferenceType extends Type { protected ReferenceType ( ) { } public String toString ( ) { return "reference" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Ljava/lang/Object;" ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . OBJECT ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . String ) { translateTo ( classGen , methodGen , ( StringType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . NodeSet ) { translateTo ( classGen , methodGen , ( NodeSetType ) type ) ; } else if ( type == Type . Node ) { translateTo ( classGen , methodGen , ( NodeType ) type ) ; } else if ( type == Type . ResultTree ) { translateTo ( classGen , methodGen , ( ResultTreeType ) type ) ; } else if ( type == Type . Object ) { translateTo ( classGen , methodGen , ( ObjectType ) type ) ; } else if ( type == Type . Reference ) { } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . INTERNAL_ERR , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final int current = methodGen . getLocalIndex ( "current" ) ; ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; if ( current < 0 ) { il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; } else { il . append ( new ILOAD ( current ) ) ; } il . append ( methodGen . loadDOM ( ) ) ; final int stringF = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "stringF" , "(" + OBJECT_SIG + NODE_SIG + DOM_INTF_SIG + ")" + STRING_SIG ) ; il . append ( new INVOKESTATIC ( stringF ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( methodGen . loadDOM ( ) ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "numberF" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")D" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "booleanF" , "(" + OBJECT_SIG + ")Z" ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeSetType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeSet" , "(" + OBJECT_SIG + ")" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; index = cpg . addInterfaceMethodref ( NODE_ITERATOR , RESET , RESET_SIG ) ; il . append ( new INVOKEINTERFACE ( index , 1 ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , NodeType type ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; Type . NodeSet . translateTo ( classGen , methodGen , type ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ResultTreeType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToResultTree" , "(" + OBJECT_SIG + ")" + DOM_INTF_SIG ) ; il . append ( new INVOKESTATIC ( index ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; int referenceToLong = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToLong" , "(" + OBJECT_SIG + ")J" ) ; int referenceToDouble = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToDouble" , "(" + OBJECT_SIG + ")D" ) ; int referenceToBoolean = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToBoolean" , "(" + OBJECT_SIG + ")Z" ) ; if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else if ( clazz == Double . TYPE ) { il . append ( new INVOKESTATIC ( referenceToDouble ) ) ; } else if ( clazz . getName ( ) . equals ( "java.lang.Double" ) ) { il . append ( new INVOKESTATIC ( referenceToDouble ) ) ; Type . Real . translateTo ( classGen , methodGen , Type . Reference ) ; } else if ( clazz == Float . TYPE ) { il . append ( new INVOKESTATIC ( referenceToDouble ) ) ; il . append ( D2F ) ; } else if ( clazz . getName ( ) . equals ( "java.lang.String" ) ) { int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToString" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")" + "Ljava/lang/String;" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.Node" ) ) { int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNode" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")" + "Lorg/w3c/dom/Node;" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( clazz . getName ( ) . equals ( "org.w3c.dom.NodeList" ) ) { int index = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "referenceToNodeList" , "(" + OBJECT_SIG + DOM_INTF_SIG + ")" + "Lorg/w3c/dom/NodeList;" ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( new INVOKESTATIC ( index ) ) ; } else if ( clazz . getName ( ) . equals ( "org.apache.xalan.xsltc.DOM" ) ) { translateTo ( classGen , methodGen , Type . ResultTree ) ; } else if ( clazz == Long . TYPE ) { il . append ( new INVOKESTATIC ( referenceToLong ) ) ; } else if ( clazz == Integer . TYPE ) { il . append ( new INVOKESTATIC ( referenceToLong ) ) ; il . append ( L2I ) ; } else if ( clazz == Short . TYPE ) { il . append ( new INVOKESTATIC ( referenceToLong ) ) ; il . append ( L2I ) ; il . append ( I2S ) ; } else if ( clazz == Byte . TYPE ) { il . append ( new INVOKESTATIC ( referenceToLong ) ) ; il . append ( L2I ) ; il . append ( I2B ) ; } else if ( clazz == Character . TYPE ) { il . append ( new INVOKESTATIC ( referenceToLong ) ) ; il . append ( L2I ) ; il . append ( I2C ) ; } else if ( clazz == java . lang . Boolean . TYPE ) { il . append ( new INVOKESTATIC ( referenceToBoolean ) ) ; } else if ( clazz . getName ( ) . equals ( "java.lang.Boolean" ) ) { il . append ( new INVOKESTATIC ( referenceToBoolean ) ) ; Type . Boolean . translateTo ( classGen , methodGen , Type . Reference ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . getName ( ) . equals ( "java.lang.Object" ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { InstructionList il = methodGen . getInstructionList ( ) ; translateTo ( classGen , methodGen , type ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['20', '2', '0', '42', '46', '184', '19', '30', '19', '2', '630', '0', '0', '0.634615385', '0.230769231', '2', '4', '30.5', '16', '2.25', '0']
package org . apache . xalan . xsltc . trax ; import javax . xml . transform . Source ; import javax . xml . transform . stream . StreamSource ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . StripFilter ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . dom . DOMWSFilter ; import org . apache . xalan . xsltc . dom . SAXImpl ; import org . apache . xalan . xsltc . dom . XSLTCDTMManager ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . xml . sax . SAXException ; public final class XSLTCSource implements Source { private String _systemId = null ; private Source _source = null ; private ThreadLocal _dom = new ThreadLocal ( ) ; public XSLTCSource ( String systemId ) { _systemId = systemId ; } public XSLTCSource ( Source source ) { _source = source ; } public void setSystemId ( String systemId ) { _systemId = systemId ; if ( _source != null ) { _source . setSystemId ( systemId ) ; } } public String getSystemId ( ) { if ( _source != null ) { return _source . getSystemId ( ) ; } else { return ( _systemId ) ; } } protected DOM getDOM ( XSLTCDTMManager dtmManager , AbstractTranslet translet ) throws SAXException { SAXImpl idom = ( SAXImpl ) _dom . get ( ) ; if ( idom != null ) { if ( dtmManager != null ) { idom . migrateTo ( dtmManager ) ; } } else { Source source = _source ; if ( source == null ) { if ( _systemId != null && _systemId . length ( ) > 0 ) { source = new StreamSource ( _systemId ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . XSLTC_SOURCE_ERR ) ; throw new SAXException ( err . toString ( ) ) ; } } DOMWSFilter wsfilter = null ; if ( translet != null && translet instanceof StripFilter ) { wsfilter = new DOMWSFilter ( translet ) ; } boolean hasIdCall = ( translet != null ) ? translet . hasIdCall ( ) : false ; if ( dtmManager == null ) { dtmManager = XSLTCDTMManager . newInstance ( ) ; } idom = ( SAXImpl ) dtmManager . getDTM ( source , true , wsfilter , false , false , hasIdCall ) ; String systemId = getSystemId ( ) ; if ( systemId != null ) { idom . setDocumentURI ( systemId ) ; } _dom . set ( idom ) ; } return idom ; } } 	0	['5', '1', '0', '11', '22', '0', '1', '10', '4', '0.166666667', '153', '1', '0', '0', '0.4', '0', '0', '29', '2', '1', '0']
package org . apache . xalan . lib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class StartsWithCall extends FunctionCall { private Expression _base = null ; private Expression _token = null ; public StartsWithCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( argumentCount ( ) != 2 ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . ILLEGAL_ARG_ERR , getName ( ) , this ) ; throw new TypeCheckError ( err ) ; } _base = argument ( 0 ) ; Type baseType = _base . typeCheck ( stable ) ; if ( baseType != Type . String ) _base = new CastExpr ( _base , Type . String ) ; _token = argument ( 1 ) ; Type tokenType = _token . typeCheck ( stable ) ; if ( tokenType != Type . String ) _token = new CastExpr ( _token , Type . String ) ; return _type = Type . Boolean ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; _base . translate ( classGen , methodGen ) ; _token . translate ( classGen , methodGen ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "startsWith" , "(" + STRING_SIG + ")Z" ) ) ) ; } } 	0	['3', '4', '0', '16', '17', '0', '0', '16', '3', '0', '108', '1', '2', '0.979591837', '0.444444444', '3', '13', '34.33333333', '1', '0.6667', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . TransformerException ; import org . apache . xalan . templates . ElemNumber ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; public class Counter { static final int MAXCOUNTNODES = 500 ; int m_countNodesStartCount = 0 ; NodeSetDTM m_countNodes ; int m_fromNode = DTM . NULL ; ElemNumber m_numberElem ; int m_countResult ; Counter ( ElemNumber numberElem , NodeSetDTM countNodes ) throws TransformerException { m_countNodes = countNodes ; m_numberElem = numberElem ; } int getPreviouslyCounted ( XPathContext support , int node ) { int n = m_countNodes . size ( ) ; m_countResult = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int countedNode = m_countNodes . elementAt ( i ) ; if ( node == countedNode ) { m_countResult = i + 1 + m_countNodesStartCount ; break ; } DTM dtm = support . getDTM ( countedNode ) ; if ( dtm . isNodeAfter ( countedNode , node ) ) break ; } return m_countResult ; } int getLast ( ) { int size = m_countNodes . size ( ) ; return ( size > 0 ) ? m_countNodes . elementAt ( size - 1 ) : DTM . NULL ; } } 	0	['3', '1', '0', '5', '8', '0', '1', '4', '0', '0.833333333', '84', '0', '2', '0', '0.466666667', '0', '0', '25', '4', '2', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class NotCall extends FunctionCall { public NotCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( ICONST_1 ) ; il . append ( IXOR ) ; } public void translateDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen ) { final InstructionList il = methodGen . getInstructionList ( ) ; final Expression exp = argument ( ) ; exp . translateDesynthesized ( classGen , methodGen ) ; final BranchHandle gotoh = il . append ( new GOTO ( null ) ) ; _trueList = exp . _falseList ; _falseList = exp . _trueList ; _falseList . add ( gotoh ) ; } } 	0	['3', '4', '0', '14', '12', '3', '1', '13', '3', '2', '56', '0', '0', '0.979591837', '0.6', '2', '6', '17.66666667', '1', '0.6667', '0']
package org . apache . xalan . xsltc . compiler ; public final class CompilerException extends Exception { private String _msg ; public CompilerException ( ) { super ( ) ; } public CompilerException ( Exception e ) { super ( e . toString ( ) ) ; _msg = e . toString ( ) ; } public CompilerException ( String message ) { super ( message ) ; _msg = message ; } public String getMessage ( ) { final int col = _msg . indexOf ( ':' ) ; if ( col > - 1 ) return ( _msg . substring ( col ) ) ; else return ( _msg ) ; } } 	0	['4', '3', '0', '2', '9', '0', '2', '0', '4', '0.333333333', '40', '1', '0', '0.944444444', '0.5', '1', '1', '8.75', '2', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class Choose extends Instruction { public void display ( int indent ) { indent ( indent ) ; Util . println ( "Choose" ) ; indent ( indent + IndentIncrement ) ; displayContents ( indent + IndentIncrement ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final Vector whenElements = new Vector ( ) ; Otherwise otherwise = null ; Enumeration elements = elements ( ) ; ErrorMsg error = null ; final int line = getLineNumber ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof When ) { whenElements . addElement ( element ) ; } else if ( element instanceof Otherwise ) { if ( otherwise == null ) { otherwise = ( Otherwise ) element ; } else { error = new ErrorMsg ( ErrorMsg . MULTIPLE_OTHERWISE_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; } } else if ( element instanceof Text ) { ( ( Text ) element ) . ignore ( ) ; } else { error = new ErrorMsg ( ErrorMsg . WHEN_ELEMENT_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; } } if ( whenElements . size ( ) == 0 ) { error = new ErrorMsg ( ErrorMsg . MISSING_WHEN_ERR , this ) ; getParser ( ) . reportError ( Constants . ERROR , error ) ; return ; } InstructionList il = methodGen . getInstructionList ( ) ; BranchHandle nextElement = null ; Vector exitHandles = new Vector ( ) ; InstructionHandle exit = null ; Enumeration whens = whenElements . elements ( ) ; while ( whens . hasMoreElements ( ) ) { final When when = ( When ) whens . nextElement ( ) ; final Expression test = when . getTest ( ) ; InstructionHandle truec = il . getEnd ( ) ; if ( nextElement != null ) nextElement . setTarget ( il . append ( NOP ) ) ; test . translateDesynthesized ( classGen , methodGen ) ; if ( test instanceof FunctionCall ) { FunctionCall call = ( FunctionCall ) test ; try { Type type = call . typeCheck ( getParser ( ) . getSymbolTable ( ) ) ; if ( type != Type . Boolean ) { test . _falseList . add ( il . append ( new IFEQ ( null ) ) ) ; } } catch ( TypeCheckError e ) { } } truec = il . getEnd ( ) ; if ( ! when . ignore ( ) ) when . translateContents ( classGen , methodGen ) ; exitHandles . addElement ( il . append ( new GOTO ( null ) ) ) ; if ( whens . hasMoreElements ( ) || otherwise != null ) { nextElement = il . append ( new GOTO ( null ) ) ; test . backPatchFalseList ( nextElement ) ; } else test . backPatchFalseList ( exit = il . append ( NOP ) ) ; test . backPatchTrueList ( truec . getNext ( ) ) ; } if ( otherwise != null ) { nextElement . setTarget ( il . append ( NOP ) ) ; otherwise . translateContents ( classGen , methodGen ) ; exit = il . append ( NOP ) ; } Enumeration exitGotos = exitHandles . elements ( ) ; while ( exitGotos . hasMoreElements ( ) ) { BranchHandle gotoExit = ( BranchHandle ) exitGotos . nextElement ( ) ; gotoExit . setTarget ( exit ) ; } } } 	0	['3', '3', '0', '25', '37', '3', '3', '23', '2', '2', '245', '0', '0', '0.965517241', '0.5', '2', '4', '80.66666667', '15', '5.3333', '0']
package org . apache . xalan . transformer ; import javax . xml . transform . Transformer ; import org . apache . xalan . templates . ElemTemplate ; import org . apache . xalan . templates . ElemTemplateElement ; import org . apache . xml . serializer . TransformStateSetter ; import org . w3c . dom . Node ; import org . w3c . dom . traversal . NodeIterator ; public interface TransformState extends TransformStateSetter { ElemTemplateElement getCurrentElement ( ) ; Node getCurrentNode ( ) ; ElemTemplate getCurrentTemplate ( ) ; ElemTemplate getMatchedTemplate ( ) ; Node getMatchedNode ( ) ; NodeIterator getContextNodeList ( ) ; Transformer getTransformer ( ) ; } 	0	['7', '1', '0', '6', '7', '21', '3', '3', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xalan . templates ; public class ElemEmpty extends ElemTemplateElement { public ElemEmpty ( ) { } } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xml . utils . XMLString ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncSum extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { DTMIterator nodes = m_arg0 . asIterator ( xctxt , xctxt . getCurrentNode ( ) ) ; double sum = 0.0 ; int pos ; while ( DTM . NULL != ( pos = nodes . nextNode ( ) ) ) { DTM dtm = nodes . getDTM ( pos ) ; XMLString s = dtm . getStringValue ( pos ) ; if ( null != s ) sum += s . toDouble ( ) ; } nodes . detach ( ) ; return new XNumber ( sum ) ; } } 	0	['2', '4', '0', '8', '11', '1', '0', '8', '2', '2', '44', '0', '0', '0.979591837', '0.75', '1', '6', '21', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import java . util . Vector ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; final class FloorCall extends FunctionCall { public FloorCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { argument ( ) . translate ( classGen , methodGen ) ; methodGen . getInstructionList ( ) . append ( new INVOKESTATIC ( classGen . getConstantPool ( ) . addMethodref ( MATH_CLASS , "floor" , "(D)D" ) ) ) ; } } 	0	['2', '4', '0', '10', '10', '1', '0', '10', '2', '2', '26', '0', '0', '0.989690722', '0.6', '2', '4', '12', '1', '0.5', '0']
package org . apache . xalan . templates ; import org . apache . xml . utils . QName ; import org . apache . xpath . XPath ; public class KeyDeclaration extends ElemTemplateElement { public KeyDeclaration ( Stylesheet parentNode , int docOrderNumber ) { m_parentNode = parentNode ; setUid ( docOrderNumber ) ; } private QName m_name ; public void setName ( QName name ) { m_name = name ; } public QName getName ( ) { return m_name ; } public String getNodeName ( ) { return Constants . ELEMNAME_KEY_STRING ; } private XPath m_matchPattern = null ; public void setMatch ( XPath v ) { m_matchPattern = v ; } public XPath getMatch ( ) { return m_matchPattern ; } private XPath m_use ; public void setUse ( XPath v ) { m_use = v ; } public XPath getUse ( ) { return m_use ; } public int getXSLToken ( ) { return Constants . ELEMNAME_KEY ; } public void compose ( StylesheetRoot sroot ) throws javax . xml . transform . TransformerException { super . compose ( sroot ) ; java . util . Vector vnames = sroot . getComposeState ( ) . getVariableNames ( ) ; if ( null != m_matchPattern ) m_matchPattern . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; if ( null != m_use ) m_use . fixupVariables ( vnames , sroot . getComposeState ( ) . getGlobalsSize ( ) ) ; } public void recompose ( StylesheetRoot root ) { root . recomposeKeys ( this ) ; } } 	0	['11', '3', '0', '11', '19', '35', '7', '6', '11', '0.8', '85', '1', '3', '0.951456311', '0.272727273', '2', '6', '6.454545455', '1', '0.9091', '0']
package org . apache . xalan . lib . sql ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . Properties ; class SecuritySupport12 extends SecuritySupport { ClassLoader getContextClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getSystemClassLoader ( ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader cl = null ; try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( SecurityException ex ) { } return cl ; } } ) ; } ClassLoader getParentClassLoader ( final ClassLoader cl ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { ClassLoader parent = null ; try { parent = cl . getParent ( ) ; } catch ( SecurityException ex ) { } return ( parent == cl ) ? null : parent ; } } ) ; } String getSystemProperty ( final String propName ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( propName ) ; } } ) ; } FileInputStream getFileInputStream ( final File file ) throws FileNotFoundException { try { return ( FileInputStream ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws FileNotFoundException { return new FileInputStream ( file ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( FileNotFoundException ) e . getException ( ) ; } } InputStream getResourceAsStream ( final ClassLoader cl , final String name ) { return ( InputStream ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } } ) ; } boolean getFileExists ( final File f ) { return ( ( Boolean ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Boolean ( f . exists ( ) ) ; } } ) ) . booleanValue ( ) ; } long getLastModified ( final File f ) { return ( ( Long ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return new Long ( f . lastModified ( ) ) ; } } ) ) . longValue ( ) ; } } 	0	['9', '2', '0', '9', '23', '36', '9', '9', '0', '2', '82', '0', '0', '0.529411765', '0.444444444', '0', '0', '8.111111111', '1', '0.8889', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncTranslate extends Function3Args { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String theFirstString = m_arg0 . execute ( xctxt ) . str ( ) ; String theSecondString = m_arg1 . execute ( xctxt ) . str ( ) ; String theThirdString = m_arg2 . execute ( xctxt ) . str ( ) ; int theFirstStringLength = theFirstString . length ( ) ; int theThirdStringLength = theThirdString . length ( ) ; StringBuffer sbuffer = new StringBuffer ( ) ; for ( int i = 0 ; i < theFirstStringLength ; i ++ ) { char theCurrentChar = theFirstString . charAt ( i ) ; int theIndex = theSecondString . indexOf ( theCurrentChar ) ; if ( theIndex < 0 ) { sbuffer . append ( theCurrentChar ) ; } else if ( theIndex < theThirdStringLength ) { sbuffer . append ( theThirdString . charAt ( theIndex ) ) ; } else { } } return new XString ( sbuffer . toString ( ) ) ; } } 	0	['2', '6', '0', '5', '12', '1', '0', '5', '2', '2', '70', '0', '0', '0.984615385', '0.75', '1', '6', '34', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler . util ; public abstract class NumberType extends Type { public boolean isNumber ( ) { return true ; } public boolean isSimple ( ) { return true ; } } 	0	['3', '2', '2', '5', '4', '3', '4', '1', '3', '2', '10', '0', '0', '0.942857143', '1', '0', '0', '2.333333333', '1', '0.6667', '0']
package org . apache . xalan . extensions ; import java . lang . reflect . Constructor ; import javax . xml . transform . TransformerException ; public class ExtensionNamespaceSupport { String m_namespace = null ; String m_handlerClass = null ; Class [ ] m_sig = null ; Object [ ] m_args = null ; public ExtensionNamespaceSupport ( String namespace , String handlerClass , Object [ ] constructorArgs ) { m_namespace = namespace ; m_handlerClass = handlerClass ; m_args = constructorArgs ; m_sig = new Class [ m_args . length ] ; for ( int i = 0 ; i < m_args . length ; i ++ ) { if ( m_args [ i ] != null ) m_sig [ i ] = m_args [ i ] . getClass ( ) ; else { m_sig = null ; break ; } } } public String getNamespace ( ) { return m_namespace ; } public ExtensionHandler launch ( ) throws TransformerException { ExtensionHandler handler = null ; try { Class cl = ExtensionHandler . getClassForName ( m_handlerClass ) ; Constructor con = null ; if ( m_sig != null ) con = cl . getConstructor ( m_sig ) ; else { Constructor [ ] cons = cl . getConstructors ( ) ; for ( int i = 0 ; i < cons . length ; i ++ ) { if ( cons [ i ] . getParameterTypes ( ) . length == m_args . length ) { con = cons [ i ] ; break ; } } } if ( con != null ) handler = ( ExtensionHandler ) con . newInstance ( m_args ) ; else throw new TransformerException ( "ExtensionHandler constructor not found" ) ; } catch ( Exception e ) { throw new TransformerException ( e ) ; } return handler ; } } 	0	['3', '1', '0', '5', '12', '0', '4', '1', '3', '0.5', '133', '0', '0', '0', '0.555555556', '0', '0', '42', '1', '0.6667', '0']
package org . apache . xalan . lib ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFLT ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class AncestorPattern extends RelativePathPattern { private final Pattern _left ; private final RelativePathPattern _right ; private InstructionHandle _loop ; public AncestorPattern ( RelativePathPattern right ) { this ( null , right ) ; } public AncestorPattern ( Pattern left , RelativePathPattern right ) { _left = left ; ( _right = right ) . setParent ( this ) ; if ( left != null ) { left . setParent ( this ) ; } } public InstructionHandle getLoopHandle ( ) { return _loop ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; if ( _left != null ) { _left . setParser ( parser ) ; } _right . setParser ( parser ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _right . getKernelPattern ( ) ; } public void reduceKernelPattern ( ) { _right . reduceKernelPattern ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { if ( _left != null ) { _left . typeCheck ( stable ) ; } return _right . typeCheck ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { InstructionHandle parent ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen local = methodGen . addLocalVariable2 ( "app" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; final org . apache . bcel . generic . Instruction loadLocal = new ILOAD ( local . getIndex ( ) ) ; final org . apache . bcel . generic . Instruction storeLocal = new ISTORE ( local . getIndex ( ) ) ; if ( _right instanceof StepPattern ) { il . append ( DUP ) ; il . append ( storeLocal ) ; _right . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; il . append ( loadLocal ) ; } else { _right . translate ( classGen , methodGen ) ; if ( _right instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } } if ( _left != null ) { final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; parent = il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; il . append ( DUP ) ; il . append ( storeLocal ) ; _falseList . add ( il . append ( new IFLT ( null ) ) ) ; il . append ( loadLocal ) ; _left . translate ( classGen , methodGen ) ; final SyntaxTreeNode p = getParent ( ) ; if ( p == null || p instanceof Instruction || p instanceof TopLevelElement ) { } else { il . append ( loadLocal ) ; } final BranchHandle exit = il . append ( new GOTO ( null ) ) ; _loop = il . append ( methodGen . loadDOM ( ) ) ; il . append ( loadLocal ) ; local . setEnd ( _loop ) ; il . append ( new GOTO ( parent ) ) ; exit . setTarget ( il . append ( NOP ) ) ; _left . backPatchFalseList ( _loop ) ; _trueList . append ( _left . _trueList ) ; } else { il . append ( POP2 ) ; } if ( _right instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _right ; _falseList . backPatch ( ancestor . getLoopHandle ( ) ) ; } _trueList . append ( _right . _trueList ) ; _falseList . append ( _right . _falseList ) ; } public String toString ( ) { return "AncestorPattern(" + _left + ", " + _right + ')' ; } } 	0	['10', '6', '0', '30', '48', '1', '2', '28', '10', '0.518518519', '302', '1', '2', '0.925233645', '0.242857143', '4', '5', '28.9', '8', '1.6', '0']
package org . apache . xml . utils ; public class WrappedRuntimeException extends RuntimeException { private Exception m_exception ; public WrappedRuntimeException ( Exception e ) { super ( e . getMessage ( ) ) ; m_exception = e ; } public WrappedRuntimeException ( String msg , Exception e ) { super ( msg ) ; m_exception = e ; } public Exception getException ( ) { return m_exception ; } } 	0	['3', '4', '0', '40', '5', '0', '40', '0', '3', '0', '22', '1', '0', '0.944444444', '0.666666667', '0', '0', '6', '1', '0.3333', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xalan . xsltc . util . IntegerArray ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class CurrentNodeListIterator extends DTMAxisIteratorBase { private boolean _docOrder ; private DTMAxisIterator _source ; private final CurrentNodeListFilter _filter ; private IntegerArray _nodes = new IntegerArray ( ) ; private int _currentIndex ; private final int _currentNode ; private AbstractTranslet _translet ; public CurrentNodeListIterator ( DTMAxisIterator source , CurrentNodeListFilter filter , int currentNode , AbstractTranslet translet ) { this ( source , ! source . isReverse ( ) , filter , currentNode , translet ) ; } public CurrentNodeListIterator ( DTMAxisIterator source , boolean docOrder , CurrentNodeListFilter filter , int currentNode , AbstractTranslet translet ) { _source = source ; _filter = filter ; _translet = translet ; _docOrder = docOrder ; _currentNode = currentNode ; } public DTMAxisIterator forceNaturalOrder ( ) { _docOrder = true ; return this ; } public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; } public boolean isReverse ( ) { return ! _docOrder ; } public DTMAxisIterator cloneIterator ( ) { try { final CurrentNodeListIterator clone = ( CurrentNodeListIterator ) super . clone ( ) ; clone . _nodes = ( IntegerArray ) _nodes . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public DTMAxisIterator reset ( ) { _currentIndex = 0 ; return resetPosition ( ) ; } public int next ( ) { final int last = _nodes . cardinality ( ) ; final int currentNode = _currentNode ; final AbstractTranslet translet = _translet ; for ( int index = _currentIndex ; index < last ; ) { final int position = _docOrder ? index + 1 : last - index ; final int node = _nodes . at ( index ++ ) ; if ( _filter . test ( node , position , last , currentNode , translet , this ) ) { _currentIndex = index ; return returnNode ( node ) ; } } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( _startNode = node ) ; _nodes . clear ( ) ; while ( ( node = _source . next ( ) ) != END ) { _nodes . add ( node ) ; } _currentIndex = 0 ; resetPosition ( ) ; } return this ; } public int getLast ( ) { if ( _last == - 1 ) { _last = computePositionOfLast ( ) ; } return _last ; } public void setMark ( ) { _markedNode = _currentIndex ; } public void gotoMark ( ) { _currentIndex = _markedNode ; } private int computePositionOfLast ( ) { final int last = _nodes . cardinality ( ) ; final int currNode = _currentNode ; final AbstractTranslet translet = _translet ; int lastPosition = _position ; for ( int index = _currentIndex ; index < last ; ) { final int position = _docOrder ? index + 1 : last - index ; int nodeIndex = _nodes . at ( index ++ ) ; if ( _filter . test ( nodeIndex , position , last , currNode , translet , this ) ) { lastPosition ++ ; } } return lastPosition ; } } 	0	['13', '2', '0', '6', '31', '14', '0', '6', '12', '0.583333333', '268', '1', '4', '0.541666667', '0.307692308', '1', '8', '19.07692308', '3', '1.4615', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncLang extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String lang = m_arg0 . execute ( xctxt ) . str ( ) ; int parent = xctxt . getCurrentNode ( ) ; boolean isLang = false ; DTM dtm = xctxt . getDTM ( parent ) ; while ( DTM . NULL != parent ) { if ( DTM . ELEMENT_NODE == dtm . getNodeType ( parent ) ) { int langAttr = dtm . getAttributeNode ( parent , "http://www.w3.org/XML/1998/namespace" , "lang" ) ; if ( DTM . NULL != langAttr ) { String langVal = dtm . getNodeValue ( langAttr ) ; if ( langVal . toLowerCase ( ) . startsWith ( lang . toLowerCase ( ) ) ) { int valLen = lang . length ( ) ; if ( ( langVal . length ( ) == valLen ) || ( langVal . charAt ( valLen ) == '-' ) ) { isLang = true ; } } break ; } } parent = dtm . getParent ( parent ) ; } return isLang ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '4', '0', '6', '15', '1', '0', '6', '2', '2', '73', '0', '0', '0.979591837', '0.75', '1', '6', '35.5', '1', '0.5', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XObject ; import org . apache . xpath . objects . XString ; public class FuncUnparsedEntityURI extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String name = m_arg0 . execute ( xctxt ) . str ( ) ; int context = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( context ) ; int doc = dtm . getDocument ( ) ; String uri = dtm . getUnparsedEntityURI ( name ) ; return new XString ( uri ) ; } } 	0	['2', '4', '0', '6', '10', '1', '0', '6', '2', '2', '30', '0', '0', '0.979591837', '0.75', '1', '6', '14', '1', '0.5', '0']
package org . apache . xalan . xsltc . dom ; import org . apache . xalan . xsltc . DOM ; import org . apache . xalan . xsltc . runtime . BasisLibrary ; import org . apache . xml . dtm . DTMAxisIterator ; import org . apache . xml . dtm . ref . DTMAxisIteratorBase ; public final class UnionIterator extends DTMAxisIteratorBase { final private DOM _dom ; private final static class LookAheadIterator { public int node , markedNode ; public DTMAxisIterator iterator ; public boolean isStartSet = false ; public LookAheadIterator ( DTMAxisIterator iterator ) { this . iterator = iterator ; } public int step ( ) { node = iterator . next ( ) ; return node ; } public LookAheadIterator cloneIterator ( ) { final LookAheadIterator clone = new LookAheadIterator ( iterator . cloneIterator ( ) ) ; clone . node = node ; clone . markedNode = node ; return clone ; } public void setMark ( ) { markedNode = node ; iterator . setMark ( ) ; } public void gotoMark ( ) { node = markedNode ; iterator . gotoMark ( ) ; } } private static final int InitSize = 8 ; private int _heapSize = 0 ; private int _size = InitSize ; private LookAheadIterator [ ] _heap = new LookAheadIterator [ InitSize ] ; private int _free = 0 ; private int _returnedLast ; private int _cachedReturnedLast = END ; private int _cachedHeapSize ; public UnionIterator ( DOM dom ) { _dom = dom ; } public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; final LookAheadIterator [ ] heapCopy = new LookAheadIterator [ _heap . length ] ; try { final UnionIterator clone = ( UnionIterator ) super . clone ( ) ; for ( int i = 0 ; i < _free ; i ++ ) { heapCopy [ i ] = _heap [ i ] . cloneIterator ( ) ; } clone . setRestartable ( false ) ; clone . _heap = heapCopy ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } } public UnionIterator addIterator ( DTMAxisIterator iterator ) { if ( _free == _size ) { LookAheadIterator [ ] newArray = new LookAheadIterator [ _size *= 2 ] ; System . arraycopy ( _heap , 0 , newArray , 0 , _free ) ; _heap = newArray ; } _heapSize ++ ; _heap [ _free ++ ] = new LookAheadIterator ( iterator ) ; return this ; } public int next ( ) { while ( _heapSize > 0 ) { final int smallest = _heap [ 0 ] . node ; if ( smallest == END ) { if ( _heapSize > 1 ) { final LookAheadIterator temp = _heap [ 0 ] ; _heap [ 0 ] = _heap [ -- _heapSize ] ; _heap [ _heapSize ] = temp ; } else { return END ; } } else if ( smallest == _returnedLast ) { _heap [ 0 ] . step ( ) ; } else { _heap [ 0 ] . step ( ) ; heapify ( 0 ) ; return returnNode ( _returnedLast = smallest ) ; } heapify ( 0 ) ; } return END ; } public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _startNode = node ; for ( int i = 0 ; i < _free ; i ++ ) { if ( ! _heap [ i ] . isStartSet ) { _heap [ i ] . iterator . setStartNode ( node ) ; _heap [ i ] . step ( ) ; _heap [ i ] . isStartSet = true ; } } for ( int i = ( _heapSize = _free ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = END ; return resetPosition ( ) ; } return this ; } private void heapify ( int i ) { for ( int r , l , smallest ; ; ) { r = ( i + 1 ) << 1 ; l = r - 1 ; smallest = l < _heapSize && _dom . lessThan ( _heap [ l ] . node , _heap [ i ] . node ) ? l : i ; if ( r < _heapSize && _dom . lessThan ( _heap [ r ] . node , _heap [ smallest ] . node ) ) { smallest = r ; } if ( smallest != i ) { final LookAheadIterator temp = _heap [ smallest ] ; _heap [ smallest ] = _heap [ i ] ; _heap [ i ] = temp ; i = smallest ; } else break ; } } public void setMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . setMark ( ) ; } _cachedReturnedLast = _returnedLast ; _cachedHeapSize = _heapSize ; } public void gotoMark ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . gotoMark ( ) ; } for ( int i = ( _heapSize = _cachedHeapSize ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = _cachedReturnedLast ; } public DTMAxisIterator reset ( ) { for ( int i = 0 ; i < _free ; i ++ ) { _heap [ i ] . iterator . reset ( ) ; _heap [ i ] . step ( ) ; } for ( int i = ( _heapSize = _free ) / 2 ; i >= 0 ; i -- ) { heapify ( i ) ; } _returnedLast = END ; return resetPosition ( ) ; } } 	0	['9', '2', '0', '6', '25', '0', '1', '5', '8', '0.513888889', '445', '1', '2', '0.619047619', '0.361111111', '1', '6', '47.44444444', '6', '3.1111', '0']
package org . apache . xalan . xsltc . runtime ; import org . apache . xml . dtm . DTM ; public interface Constants { final static int ANY = - 1 ; final static int ATTRIBUTE = - 2 ; final static int ROOT = DTM . ROOT_NODE ; final static int TEXT = DTM . TEXT_NODE ; final static int ELEMENT = DTM . ELEMENT_NODE ; final static int COMMENT = DTM . COMMENT_NODE ; final static int PROCESSING_INSTRUCTION = DTM . PROCESSING_INSTRUCTION_NODE ; public static final String XSLT_URI = "http://www.w3.org/1999/XSL/Transform" ; public static final String NAMESPACE_FEATURE = "http://xml.org/sax/features/namespaces" ; public static final String EMPTYSTRING = "" ; public static final String XML_PREFIX = "xml" ; public static final String XMLNS_PREFIX = "xmlns" ; public static final String XMLNS_STRING = "xmlns:" ; public static final String XMLNS_URI = "http://www.w3.org/2000/xmlns/" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '14', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class ParentPattern extends RelativePathPattern { private final Pattern _left ; private final RelativePathPattern _right ; public ParentPattern ( Pattern left , RelativePathPattern right ) { ( _left = left ) . setParent ( this ) ; ( _right = right ) . setParent ( this ) ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _left . setParser ( parser ) ; _right . setParser ( parser ) ; } public boolean isWildcard ( ) { return false ; } public StepPattern getKernelPattern ( ) { return _right . getKernelPattern ( ) ; } public void reduceKernelPattern ( ) { _right . reduceKernelPattern ( ) ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { _left . typeCheck ( stable ) ; return _right . typeCheck ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final LocalVariableGen local = methodGen . addLocalVariable2 ( "ppt" , Util . getJCRefType ( NODE_SIG ) , il . getEnd ( ) ) ; final org . apache . bcel . generic . Instruction loadLocal = new ILOAD ( local . getIndex ( ) ) ; final org . apache . bcel . generic . Instruction storeLocal = new ISTORE ( local . getIndex ( ) ) ; if ( _right . isWildcard ( ) ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } else if ( _right instanceof StepPattern ) { il . append ( DUP ) ; il . append ( storeLocal ) ; _right . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( loadLocal ) ) ; } else { _right . translate ( classGen , methodGen ) ; if ( _right instanceof AncestorPattern ) { il . append ( methodGen . loadDOM ( ) ) ; il . append ( SWAP ) ; } } final int getParent = cpg . addInterfaceMethodref ( DOM_INTF , GET_PARENT , GET_PARENT_SIG ) ; il . append ( new INVOKEINTERFACE ( getParent , 2 ) ) ; final SyntaxTreeNode p = getParent ( ) ; if ( p == null || p instanceof Instruction || p instanceof TopLevelElement ) { _left . translate ( classGen , methodGen ) ; } else { il . append ( DUP ) ; il . append ( storeLocal ) ; _left . translate ( classGen , methodGen ) ; il . append ( methodGen . loadDOM ( ) ) ; local . setEnd ( il . append ( loadLocal ) ) ; } methodGen . removeLocalVariable ( local ) ; if ( _right instanceof AncestorPattern ) { final AncestorPattern ancestor = ( AncestorPattern ) _right ; _left . backPatchFalseList ( ancestor . getLoopHandle ( ) ) ; } _trueList . append ( _right . _trueList . append ( _left . _trueList ) ) ; _falseList . append ( _right . _falseList . append ( _left . _falseList ) ) ; } public String toString ( ) { return "Parent(" + _left + ", " + _right + ')' ; } } 	0	['8', '6', '0', '26', '43', '0', '1', '25', '8', '0.285714286', '253', '1', '2', '0.933962264', '0.25', '4', '5', '30.375', '8', '1.75', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . BranchHandle ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GOTO ; import org . apache . bcel . generic . IFEQ ; import org . apache . bcel . generic . IFNONNULL ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . Constants ; import org . apache . xalan . xsltc . compiler . FlowList ; public class StringType extends Type { protected StringType ( ) { } public String toString ( ) { return "string" ; } public boolean identicalTo ( Type other ) { return this == other ; } public String toSignature ( ) { return "Ljava/lang/String;" ; } public boolean isSimple ( ) { return true ; } public org . apache . bcel . generic . Type toJCType ( ) { return org . apache . bcel . generic . Type . STRING ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Type type ) { if ( type == Type . Boolean ) { translateTo ( classGen , methodGen , ( BooleanType ) type ) ; } else if ( type == Type . Real ) { translateTo ( classGen , methodGen , ( RealType ) type ) ; } else if ( type == Type . Reference ) { translateTo ( classGen , methodGen , ( ReferenceType ) type ) ; } else if ( type == Type . ObjectString ) { } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , type . toString ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final InstructionList il = methodGen . getInstructionList ( ) ; FlowList falsel = translateToDesynthesized ( classGen , methodGen , type ) ; il . append ( ICONST_1 ) ; final BranchHandle truec = il . append ( new GOTO ( null ) ) ; falsel . backPatch ( il . append ( ICONST_0 ) ) ; truec . setTarget ( il . append ( NOP ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , RealType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , STRING_TO_REAL , STRING_TO_REAL_SIG ) ) ) ; } public FlowList translateToDesynthesized ( ClassGenerator classGen , MethodGenerator methodGen , BooleanType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( STRING_CLASS , "length" , "()I" ) ) ) ; return new FlowList ( il . append ( new IFEQ ( null ) ) ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ReferenceType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { if ( clazz . isAssignableFrom ( java . lang . String . class ) ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateFrom ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( clazz . getName ( ) . equals ( "java.lang.String" ) ) { il . append ( DUP ) ; final BranchHandle ifNonNull = il . append ( new IFNONNULL ( null ) ) ; il . append ( POP ) ; il . append ( new PUSH ( cpg , "" ) ) ; ifNonNull . setTarget ( il . append ( NOP ) ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , clazz . getName ( ) ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } public void translateBox ( ClassGenerator classGen , MethodGenerator methodGen ) { translateTo ( classGen , methodGen , Type . Reference ) ; } public void translateUnBox ( ClassGenerator classGen , MethodGenerator methodGen ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } public String getClassName ( ) { return ( STRING_CLASS ) ; } public Instruction LOAD ( int slot ) { return new ALOAD ( slot ) ; } public Instruction STORE ( int slot ) { return new ASTORE ( slot ) ; } } 	0	['18', '2', '0', '41', '43', '133', '18', '27', '17', '2', '271', '0', '0', '0.66', '0.283950617', '2', '4', '14.05555556', '5', '1.3333', '0']
package org . apache . xml . utils . synthetic . reflection ; import org . apache . xml . utils . synthetic . SynthesisException ; public interface Member { public abstract org . apache . xml . utils . synthetic . Class getDeclaringClass ( ) ; public abstract int getModifiers ( ) ; public abstract void setDeclaringClass ( org . apache . xml . utils . synthetic . Class declaringClass ) throws SynthesisException ; public abstract void setModifiers ( int modifiers ) throws SynthesisException ; } 	0	['4', '1', '0', '6', '4', '6', '4', '2', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . xpath . functions ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncBoolean extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return m_arg0 . execute ( xctxt ) . bool ( ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } 	0	['2', '4', '0', '5', '5', '1', '0', '5', '2', '2', '15', '0', '0', '0.979591837', '0.75', '1', '6', '6.5', '1', '0.5', '0']
package org . apache . xpath . patterns ; public interface NodeTestFilter { void setNodeTest ( NodeTest nodeTest ) ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . xml . dtm . ref ; import java . util . Hashtable ; public class CustomStringPool extends DTMStringPool { final Hashtable m_stringToInt = new Hashtable ( ) ; public static final int NULL = - 1 ; public CustomStringPool ( ) { super ( ) ; } public void removeAllElements ( ) { m_intToString . removeAllElements ( ) ; if ( m_stringToInt != null ) m_stringToInt . clear ( ) ; } public String indexToString ( int i ) throws java . lang . ArrayIndexOutOfBoundsException { return ( String ) m_intToString . elementAt ( i ) ; } public int stringToIndex ( String s ) { if ( s == null ) return NULL ; Integer iobj = ( Integer ) m_stringToInt . get ( s ) ; if ( iobj == null ) { m_intToString . addElement ( s ) ; iobj = new Integer ( m_intToString . size ( ) ) ; m_stringToInt . put ( s , iobj ) ; } return iobj . intValue ( ) ; } } 	0	['4', '2', '0', '1', '15', '0', '0', '1', '4', '0.833333333', '62', '0', '0', '0.571428571', '0.5', '1', '4', '14', '3', '1.5', '0']
package org . apache . xalan . xsltc . compiler ; class IllegalCharException extends Exception { public IllegalCharException ( String s ) { super ( s ) ; } } 	0	['1', '3', '0', '0', '2', '0', '0', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xalan . xsltc . compiler ; import java . net . URL ; import java . net . MalformedURLException ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Properties ; import java . util . StringTokenizer ; import org . apache . xml . utils . SystemIDResolver ; import org . apache . bcel . generic . ANEWARRAY ; import org . apache . bcel . generic . BasicType ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . FieldGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . GETSTATIC ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESPECIAL ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . InstructionHandle ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . NEW ; import org . apache . bcel . generic . NEWARRAY ; import org . apache . bcel . generic . PUSH ; import org . apache . bcel . generic . PUTFIELD ; import org . apache . bcel . generic . PUTSTATIC ; import org . apache . bcel . generic . TargetLostException ; import org . apache . bcel . util . InstructionFinder ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; import org . apache . xalan . xsltc . runtime . AbstractTranslet ; import org . apache . xml . dtm . DTM ; public final class Stylesheet extends SyntaxTreeNode { private String _version ; private QName _name ; private String _systemId ; private Stylesheet _parentStylesheet ; private Vector _globals = new Vector ( ) ; private Boolean _hasLocalParams = null ; private String _className ; private final Vector _templates = new Vector ( ) ; private Vector _allValidTemplates = null ; private int _nextModeSerial = 1 ; private final Hashtable _modes = new Hashtable ( ) ; private Mode _defaultMode ; private final Hashtable _extensions = new Hashtable ( ) ; public Stylesheet _importedFrom = null ; public Stylesheet _includedFrom = null ; private Vector _includedStylesheets = null ; private int _importPrecedence = 1 ; private Hashtable _keys = new Hashtable ( ) ; private SourceLoader _loader = null ; private boolean _numberFormattingUsed = false ; private boolean _simplified = false ; private boolean _multiDocument = false ; private boolean _callsNodeset = false ; private boolean _hasIdCall = false ; private boolean _templateInlining = true ; private Output _lastOutputElement = null ; private Properties _outputProperties = null ; private int _outputMethod = UNKNOWN_OUTPUT ; public static final int UNKNOWN_OUTPUT = 0 ; public static final int XML_OUTPUT = 1 ; public static final int HTML_OUTPUT = 2 ; public static final int TEXT_OUTPUT = 3 ; public int getOutputMethod ( ) { return _outputMethod ; } private void checkOutputMethod ( ) { if ( _lastOutputElement != null ) { String method = _lastOutputElement . getOutputMethod ( ) ; if ( method != null ) { if ( method . equals ( "xml" ) ) _outputMethod = XML_OUTPUT ; else if ( method . equals ( "html" ) ) _outputMethod = HTML_OUTPUT ; else if ( method . equals ( "text" ) ) _outputMethod = TEXT_OUTPUT ; } } } public boolean getTemplateInlining ( ) { return _templateInlining ; } public void setTemplateInlining ( boolean flag ) { _templateInlining = flag ; } public boolean isSimplified ( ) { return ( _simplified ) ; } public void setSimplified ( ) { _simplified = true ; } public void setHasIdCall ( boolean flag ) { _hasIdCall = flag ; } public void setOutputProperty ( String key , String value ) { if ( _outputProperties == null ) { _outputProperties = new Properties ( ) ; } _outputProperties . setProperty ( key , value ) ; } public void setOutputProperties ( Properties props ) { _outputProperties = props ; } public Properties getOutputProperties ( ) { return _outputProperties ; } public Output getLastOutputElement ( ) { return _lastOutputElement ; } public void setMultiDocument ( boolean flag ) { _multiDocument = flag ; } public boolean isMultiDocument ( ) { return _multiDocument ; } public void setCallsNodeset ( boolean flag ) { if ( flag ) setMultiDocument ( flag ) ; _callsNodeset = flag ; } public boolean callsNodeset ( ) { return _callsNodeset ; } public void numberFormattingUsed ( ) { _numberFormattingUsed = true ; Stylesheet parent = getParentStylesheet ( ) ; if ( null != parent ) parent . numberFormattingUsed ( ) ; } public void setImportPrecedence ( final int precedence ) { _importPrecedence = precedence ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { SyntaxTreeNode child = ( SyntaxTreeNode ) elements . nextElement ( ) ; if ( child instanceof Include ) { Stylesheet included = ( ( Include ) child ) . getIncludedStylesheet ( ) ; if ( included != null && included . _includedFrom == this ) { included . setImportPrecedence ( precedence ) ; } } } if ( _importedFrom != null ) { if ( _importedFrom . getImportPrecedence ( ) < precedence ) { final Parser parser = getParser ( ) ; final int nextPrecedence = parser . getNextImportPrecedence ( ) ; _importedFrom . setImportPrecedence ( nextPrecedence ) ; } } else if ( _includedFrom != null ) { if ( _includedFrom . getImportPrecedence ( ) != precedence ) _includedFrom . setImportPrecedence ( precedence ) ; } } public int getImportPrecedence ( ) { return _importPrecedence ; } public boolean checkForLoop ( String systemId ) { if ( _systemId != null && _systemId . equals ( systemId ) ) { return true ; } if ( _parentStylesheet != null ) return _parentStylesheet . checkForLoop ( systemId ) ; return false ; } public void setParser ( Parser parser ) { super . setParser ( parser ) ; _name = makeStylesheetName ( "__stylesheet_" ) ; } public void setParentStylesheet ( Stylesheet parent ) { _parentStylesheet = parent ; } public Stylesheet getParentStylesheet ( ) { return _parentStylesheet ; } public void setImportingStylesheet ( Stylesheet parent ) { _importedFrom = parent ; parent . addIncludedStylesheet ( this ) ; } public void setIncludingStylesheet ( Stylesheet parent ) { _includedFrom = parent ; parent . addIncludedStylesheet ( this ) ; } public void addIncludedStylesheet ( Stylesheet child ) { if ( _includedStylesheets == null ) { _includedStylesheets = new Vector ( ) ; } _includedStylesheets . addElement ( child ) ; } public void setSystemId ( String systemId ) { if ( systemId != null ) { _systemId = SystemIDResolver . getAbsoluteURI ( systemId ) ; } } public String getSystemId ( ) { return _systemId ; } public void setSourceLoader ( SourceLoader loader ) { _loader = loader ; } public SourceLoader getSourceLoader ( ) { return _loader ; } private QName makeStylesheetName ( String prefix ) { return getParser ( ) . getQName ( prefix + getXSLTC ( ) . nextStylesheetSerial ( ) ) ; } public boolean hasGlobals ( ) { return _globals . size ( ) > 0 ; } public boolean hasLocalParams ( ) { if ( _hasLocalParams == null ) { Vector templates = getAllValidTemplates ( ) ; final int n = templates . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final Template template = ( Template ) templates . elementAt ( i ) ; if ( template . hasParams ( ) ) { _hasLocalParams = new Boolean ( true ) ; return true ; } } _hasLocalParams = new Boolean ( false ) ; return false ; } else { return _hasLocalParams . booleanValue ( ) ; } } protected void addPrefixMapping ( String prefix , String uri ) { if ( prefix . equals ( EMPTYSTRING ) && uri . equals ( XHTML_URI ) ) return ; super . addPrefixMapping ( prefix , uri ) ; } private void extensionURI ( String prefixes , SymbolTable stable ) { if ( prefixes != null ) { StringTokenizer tokens = new StringTokenizer ( prefixes ) ; while ( tokens . hasMoreTokens ( ) ) { final String prefix = tokens . nextToken ( ) ; final String uri = lookupNamespace ( prefix ) ; if ( uri != null ) { _extensions . put ( uri , prefix ) ; } } } } public boolean isExtension ( String uri ) { return ( _extensions . get ( uri ) != null ) ; } public void excludeExtensionPrefixes ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; final String excludePrefixes = getAttribute ( "exclude-result-prefixes" ) ; final String extensionPrefixes = getAttribute ( "extension-element-prefixes" ) ; stable . excludeURI ( Constants . XSLT_URI ) ; stable . excludeNamespaces ( excludePrefixes ) ; stable . excludeNamespaces ( extensionPrefixes ) ; extensionURI ( extensionPrefixes , stable ) ; } public void parseContents ( Parser parser ) { final SymbolTable stable = parser . getSymbolTable ( ) ; addPrefixMapping ( "xml" , "http://www.w3.org/XML/1998/namespace" ) ; final Stylesheet sheet = stable . addStylesheet ( _name , this ) ; if ( sheet != null ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . MULTIPLE_STYLESHEET_ERR , this ) ; parser . reportError ( Constants . ERROR , err ) ; } if ( _simplified ) { stable . excludeURI ( XSLT_URI ) ; Template template = new Template ( ) ; template . parseSimplified ( this , parser ) ; } else { parseOwnChildren ( parser ) ; } } public final void parseOwnChildren ( Parser parser ) { final Vector contents = getContents ( ) ; final int count = contents . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ( child instanceof VariableBase ) || ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } } for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) contents . elementAt ( i ) ; if ( ! ( child instanceof VariableBase ) && ! ( child instanceof NamespaceAlias ) ) { parser . getSymbolTable ( ) . setCurrentNode ( child ) ; child . parseContents ( parser ) ; } if ( ! _templateInlining && ( child instanceof Template ) ) { Template template = ( Template ) child ; String name = "template$dot$" + template . getPosition ( ) ; template . setName ( parser . getQName ( name ) ) ; } } } public void processModes ( ) { if ( _defaultMode == null ) _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; _defaultMode . processPatterns ( _keys ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . processPatterns ( _keys ) ; } } private void compileModes ( ClassGenerator classGen ) { _defaultMode . compileApplyTemplates ( classGen ) ; final Enumeration modes = _modes . elements ( ) ; while ( modes . hasMoreElements ( ) ) { final Mode mode = ( Mode ) modes . nextElement ( ) ; mode . compileApplyTemplates ( classGen ) ; } } public Mode getMode ( QName modeName ) { if ( modeName == null ) { if ( _defaultMode == null ) { _defaultMode = new Mode ( null , this , Constants . EMPTYSTRING ) ; } return _defaultMode ; } else { Mode mode = ( Mode ) _modes . get ( modeName ) ; if ( mode == null ) { final String suffix = Integer . toString ( _nextModeSerial ++ ) ; _modes . put ( modeName , mode = new Mode ( modeName , this , suffix ) ) ; } return mode ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . typeCheck ( stable ) ; } return typeCheckContents ( stable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { translate ( ) ; } private void addDOMField ( ClassGenerator classGen ) { final FieldGen fgen = new FieldGen ( ACC_PUBLIC , Util . getJCRefType ( DOM_INTF_SIG ) , DOM_FIELD , classGen . getConstantPool ( ) ) ; classGen . addField ( fgen . getField ( ) ) ; } private void addStaticField ( ClassGenerator classGen , String type , String name ) { final FieldGen fgen = new FieldGen ( ACC_PROTECTED | ACC_STATIC , Util . getJCRefType ( type ) , name , classGen . getConstantPool ( ) ) ; classGen . addField ( fgen . getField ( ) ) ; } public void translate ( ) { _className = getXSLTC ( ) . getClassName ( ) ; final ClassGenerator classGen = new ClassGenerator ( _className , TRANSLET_CLASS , Constants . EMPTYSTRING , ACC_PUBLIC | ACC_SUPER , null , this ) ; addDOMField ( classGen ) ; compileTransform ( classGen ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { Object element = elements . nextElement ( ) ; if ( element instanceof Template ) { final Template template = ( Template ) element ; getMode ( template . getModeName ( ) ) . addTemplate ( template ) ; } else if ( element instanceof AttributeSet ) { ( ( AttributeSet ) element ) . translate ( classGen , null ) ; } else if ( element instanceof Output ) { Output output = ( Output ) element ; if ( output . enabled ( ) ) _lastOutputElement = output ; } else { } } checkOutputMethod ( ) ; processModes ( ) ; compileModes ( classGen ) ; compileStaticInitializer ( classGen ) ; compileConstructor ( classGen , _lastOutputElement ) ; if ( ! getParser ( ) . errorsFound ( ) ) { getXSLTC ( ) . dumpClass ( classGen . getJavaClass ( ) ) ; } } private void compileStaticInitializer ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator staticConst = new MethodGenerator ( ACC_PUBLIC | ACC_STATIC , org . apache . bcel . generic . Type . VOID , null , null , "<clinit>" , _className , il , cpg ) ; addStaticField ( classGen , "[" + STRING_SIG , STATIC_NAMES_ARRAY_FIELD ) ; addStaticField ( classGen , "[" + STRING_SIG , STATIC_URIS_ARRAY_FIELD ) ; addStaticField ( classGen , "[I" , STATIC_TYPES_ARRAY_FIELD ) ; addStaticField ( classGen , "[" + STRING_SIG , STATIC_NAMESPACE_ARRAY_FIELD ) ; final int charDataFieldCount = getXSLTC ( ) . getCharacterDataCount ( ) ; for ( int i = 0 ; i < charDataFieldCount ; i ++ ) { addStaticField ( classGen , STATIC_CHAR_DATA_FIELD_SIG , STATIC_CHAR_DATA_FIELD + i ) ; } final Vector namesIndex = getXSLTC ( ) . getNamesIndex ( ) ; int size = namesIndex . size ( ) ; String [ ] namesArray = new String [ size ] ; String [ ] urisArray = new String [ size ] ; int [ ] typesArray = new int [ size ] ; int index ; for ( int i = 0 ; i < size ; i ++ ) { String encodedName = ( String ) namesIndex . elementAt ( i ) ; if ( ( index = encodedName . lastIndexOf ( ':' ) ) > - 1 ) { urisArray [ i ] = encodedName . substring ( 0 , index ) ; } index = index + 1 ; if ( encodedName . charAt ( index ) == '@' ) { typesArray [ i ] = DTM . ATTRIBUTE_NODE ; index ++ ; } else if ( encodedName . charAt ( index ) == '?' ) { typesArray [ i ] = DTM . NAMESPACE_NODE ; index ++ ; } else { typesArray [ i ] = DTM . ELEMENT_NODE ; } if ( index == 0 ) { namesArray [ i ] = encodedName ; } else { namesArray [ i ] = encodedName . substring ( index ) ; } } il . append ( new PUSH ( cpg , size ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final String name = namesArray [ i ] ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , name ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTSTATIC ( cpg . addFieldref ( _className , STATIC_NAMES_ARRAY_FIELD , NAMES_INDEX_SIG ) ) ) ; il . append ( new PUSH ( cpg , size ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final String uri = urisArray [ i ] ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , uri ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTSTATIC ( cpg . addFieldref ( _className , STATIC_URIS_ARRAY_FIELD , URIS_INDEX_SIG ) ) ) ; il . append ( new PUSH ( cpg , size ) ) ; il . append ( new NEWARRAY ( BasicType . INT ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final int nodeType = typesArray [ i ] ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , nodeType ) ) ; il . append ( IASTORE ) ; } il . append ( new PUTSTATIC ( cpg . addFieldref ( _className , STATIC_TYPES_ARRAY_FIELD , TYPES_INDEX_SIG ) ) ) ; final Vector namespaces = getXSLTC ( ) . getNamespaceIndex ( ) ; il . append ( new PUSH ( cpg , namespaces . size ( ) ) ) ; il . append ( new ANEWARRAY ( cpg . addClass ( STRING ) ) ) ; for ( int i = 0 ; i < namespaces . size ( ) ; i ++ ) { final String ns = ( String ) namespaces . elementAt ( i ) ; il . append ( DUP ) ; il . append ( new PUSH ( cpg , i ) ) ; il . append ( new PUSH ( cpg , ns ) ) ; il . append ( AASTORE ) ; } il . append ( new PUTSTATIC ( cpg . addFieldref ( _className , STATIC_NAMESPACE_ARRAY_FIELD , NAMESPACE_INDEX_SIG ) ) ) ; final int charDataCount = getXSLTC ( ) . getCharacterDataCount ( ) ; final int toCharArray = cpg . addMethodref ( STRING , "toCharArray" , "()[C" ) ; for ( int i = 0 ; i < charDataCount ; i ++ ) { il . append ( new PUSH ( cpg , getXSLTC ( ) . getCharacterData ( i ) ) ) ; il . append ( new INVOKEVIRTUAL ( toCharArray ) ) ; il . append ( new PUTSTATIC ( cpg . addFieldref ( _className , STATIC_CHAR_DATA_FIELD + i , STATIC_CHAR_DATA_FIELD_SIG ) ) ) ; } il . append ( RETURN ) ; staticConst . stripAttributes ( true ) ; staticConst . setMaxLocals ( ) ; staticConst . setMaxStack ( ) ; classGen . addMethod ( staticConst . getMethod ( ) ) ; } private void compileConstructor ( ClassGenerator classGen , Output output ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator constructor = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , null , null , "<init>" , _className , il , cpg ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKESPECIAL ( cpg . addMethodref ( TRANSLET_CLASS , "<init>" , "()V" ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( _className , STATIC_NAMES_ARRAY_FIELD , NAMES_INDEX_SIG ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMES_INDEX , NAMES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( _className , STATIC_URIS_ARRAY_FIELD , URIS_INDEX_SIG ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , URIS_INDEX , URIS_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( _className , STATIC_TYPES_ARRAY_FIELD , TYPES_INDEX_SIG ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , TYPES_INDEX , TYPES_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETSTATIC ( cpg . addFieldref ( _className , STATIC_NAMESPACE_ARRAY_FIELD , NAMESPACE_INDEX_SIG ) ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , NAMESPACE_INDEX , NAMESPACE_INDEX_SIG ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , AbstractTranslet . CURRENT_TRANSLET_VERSION ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , TRANSLET_VERSION_INDEX , TRANSLET_VERSION_INDEX_SIG ) ) ) ; if ( _hasIdCall ) { il . append ( classGen . loadTranslet ( ) ) ; il . append ( new PUSH ( cpg , Boolean . TRUE ) ) ; il . append ( new PUTFIELD ( cpg . addFieldref ( TRANSLET_CLASS , HASIDCALL_INDEX , HASIDCALL_INDEX_SIG ) ) ) ; } if ( output != null ) { output . translate ( classGen , constructor ) ; } if ( _numberFormattingUsed ) DecimalFormatting . translateDefaultDFS ( classGen , constructor ) ; il . append ( RETURN ) ; constructor . stripAttributes ( true ) ; constructor . setMaxLocals ( ) ; constructor . setMaxStack ( ) ; classGen . addMethod ( constructor . getMethod ( ) ) ; } private String compileTopLevel ( ClassGenerator classGen , Enumeration elements ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator toplevel = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "topLevel" , _className , il , classGen . getConstantPool ( ) ) ; toplevel . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = toplevel . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final int setFilter = cpg . addInterfaceMethodref ( DOM_INTF , "setFilter" , "(Lorg/apache/xalan/xsltc/StripFilter;)V" ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; _globals = resolveReferences ( _globals ) ; final int count = _globals . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final VariableBase var = ( VariableBase ) _globals . elementAt ( i ) ; var . translate ( classGen , toplevel ) ; } Vector whitespaceRules = new Vector ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof DecimalFormatting ) { ( ( DecimalFormatting ) element ) . translate ( classGen , toplevel ) ; } else if ( element instanceof Whitespace ) { whitespaceRules . addAll ( ( ( Whitespace ) element ) . getRules ( ) ) ; } } if ( whitespaceRules . size ( ) > 0 ) { Whitespace . translateRules ( whitespaceRules , classGen ) ; } if ( classGen . containsMethod ( STRIP_SPACE , STRIP_SPACE_PARAMS ) != null ) { il . append ( toplevel . loadDOM ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new INVOKEINTERFACE ( setFilter , 2 ) ) ; } il . append ( RETURN ) ; toplevel . stripAttributes ( true ) ; toplevel . setMaxLocals ( ) ; toplevel . setMaxStack ( ) ; toplevel . removeNOPs ( ) ; classGen . addMethod ( toplevel . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ) ; } private Vector resolveReferences ( Vector input ) { for ( int i = 0 ; i < input . size ( ) ; i ++ ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; final int depSize = ( dep != null ) ? dep . size ( ) : 0 ; for ( int j = 0 ; j < depSize ; j ++ ) { final VariableBase depVar = ( VariableBase ) dep . elementAt ( j ) ; if ( ! input . contains ( depVar ) ) { input . addElement ( depVar ) ; } } } Vector result = new Vector ( ) ; while ( input . size ( ) > 0 ) { boolean changed = false ; for ( int i = 0 ; i < input . size ( ) ; ) { final VariableBase var = ( VariableBase ) input . elementAt ( i ) ; final Vector dep = var . getDependencies ( ) ; if ( dep == null || result . containsAll ( dep ) ) { result . addElement ( var ) ; input . remove ( i ) ; changed = true ; } else { i ++ ; } } if ( ! changed ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . CIRCULAR_VARIABLE_ERR , input . toString ( ) , this ) ; getParser ( ) . reportError ( Constants . ERROR , err ) ; return ( result ) ; } } return result ; } private String compileBuildKeys ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = { Util . getJCRefType ( DOM_INTF_SIG ) , Util . getJCRefType ( NODE_ITERATOR_SIG ) , Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) , org . apache . bcel . generic . Type . INT } ; final String [ ] argNames = { DOCUMENT_PNAME , ITERATOR_PNAME , TRANSLET_OUTPUT_PNAME , "current" } ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator buildKeys = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "buildKeys" , _className , il , classGen . getConstantPool ( ) ) ; buildKeys . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final Enumeration elements = elements ( ) ; while ( elements . hasMoreElements ( ) ) { final Object element = elements . nextElement ( ) ; if ( element instanceof Key ) { final Key key = ( Key ) element ; key . translate ( classGen , buildKeys ) ; _keys . put ( key . getName ( ) , key ) ; } } il . append ( RETURN ) ; buildKeys . stripAttributes ( true ) ; buildKeys . setMaxLocals ( ) ; buildKeys . setMaxStack ( ) ; buildKeys . removeNOPs ( ) ; classGen . addMethod ( buildKeys . getMethod ( ) ) ; return ( "(" + DOM_INTF_SIG + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + "I)V" ) ; } private void compileTransform ( ClassGenerator classGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final org . apache . bcel . generic . Type [ ] argTypes = new org . apache . bcel . generic . Type [ 3 ] ; argTypes [ 0 ] = Util . getJCRefType ( DOM_INTF_SIG ) ; argTypes [ 1 ] = Util . getJCRefType ( NODE_ITERATOR_SIG ) ; argTypes [ 2 ] = Util . getJCRefType ( TRANSLET_OUTPUT_SIG ) ; final String [ ] argNames = new String [ 3 ] ; argNames [ 0 ] = DOCUMENT_PNAME ; argNames [ 1 ] = ITERATOR_PNAME ; argNames [ 2 ] = TRANSLET_OUTPUT_PNAME ; final InstructionList il = new InstructionList ( ) ; final MethodGenerator transf = new MethodGenerator ( ACC_PUBLIC , org . apache . bcel . generic . Type . VOID , argTypes , argNames , "transform" , _className , il , classGen . getConstantPool ( ) ) ; transf . addException ( "org.apache.xalan.xsltc.TransletException" ) ; final LocalVariableGen current = transf . addLocalVariable ( "current" , org . apache . bcel . generic . Type . INT , il . getEnd ( ) , null ) ; final String applyTemplatesSig = classGen . getApplyTemplatesSig ( ) ; final int applyTemplates = cpg . addMethodref ( getClassName ( ) , "applyTemplates" , applyTemplatesSig ) ; final int domField = cpg . addFieldref ( getClassName ( ) , DOM_FIELD , DOM_INTF_SIG ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( isMultiDocument ( ) ) { il . append ( new NEW ( cpg . addClass ( MULTI_DOM_CLASS ) ) ) ; il . append ( DUP ) ; } il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadDOM ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , "makeDOMAdapter" , "(" + DOM_INTF_SIG + ")" + DOM_ADAPTER_SIG ) ) ) ; if ( isMultiDocument ( ) ) { final int init = cpg . addMethodref ( MULTI_DOM_CLASS , "<init>" , "(" + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESPECIAL ( init ) ) ; } il . append ( new PUTFIELD ( domField ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new ISTORE ( current . getIndex ( ) ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( transf . loadHandler ( ) ) ; final int index = cpg . addMethodref ( TRANSLET_CLASS , "transferOutputSettings" , "(" + OUTPUT_HANDLER_SIG + ")V" ) ; il . append ( new INVOKEVIRTUAL ( index ) ) ; final String keySig = compileBuildKeys ( classGen ) ; final int keyIdx = cpg . addMethodref ( getClassName ( ) , "buildKeys" , keySig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new PUSH ( cpg , DTM . ROOT_NODE ) ) ; il . append ( new INVOKEVIRTUAL ( keyIdx ) ) ; final Enumeration toplevel = elements ( ) ; if ( ( _globals . size ( ) > 0 ) || ( toplevel . hasMoreElements ( ) ) ) { final String topLevelSig = compileTopLevel ( classGen , toplevel ) ; final int topLevelIdx = cpg . addMethodref ( getClassName ( ) , "topLevel" , topLevelSig ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( topLevelIdx ) ) ; } il . append ( transf . loadHandler ( ) ) ; il . append ( transf . startDocument ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( classGen . loadTranslet ( ) ) ; il . append ( new GETFIELD ( domField ) ) ; il . append ( transf . loadIterator ( ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( applyTemplates ) ) ; il . append ( transf . loadHandler ( ) ) ; il . append ( transf . endDocument ( ) ) ; il . append ( RETURN ) ; transf . stripAttributes ( true ) ; transf . setMaxLocals ( ) ; transf . setMaxStack ( ) ; transf . removeNOPs ( ) ; classGen . addMethod ( transf . getMethod ( ) ) ; } private void peepHoleOptimization ( MethodGenerator methodGen ) { final String pattern = "`ALOAD'`POP'`Instruction'" ; final InstructionList il = methodGen . getInstructionList ( ) ; final InstructionFinder find = new InstructionFinder ( il ) ; for ( Iterator iter = find . search ( pattern ) ; iter . hasNext ( ) ; ) { InstructionHandle [ ] match = ( InstructionHandle [ ] ) iter . next ( ) ; try { il . delete ( match [ 0 ] , match [ 1 ] ) ; } catch ( TargetLostException e ) { } } } public int addParam ( Param param ) { _globals . addElement ( param ) ; return _globals . size ( ) - 1 ; } public int addVariable ( Variable global ) { _globals . addElement ( global ) ; return _globals . size ( ) - 1 ; } public void display ( int indent ) { indent ( indent ) ; Util . println ( "Stylesheet" ) ; displayContents ( indent + IndentIncrement ) ; } public String getNamespace ( String prefix ) { return lookupNamespace ( prefix ) ; } public String getClassName ( ) { return _className ; } public Vector getTemplates ( ) { return _templates ; } public Vector getAllValidTemplates ( ) { if ( _includedStylesheets == null ) { return _templates ; } if ( _allValidTemplates == null ) { Vector templates = new Vector ( ) ; int size = _includedStylesheets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Stylesheet included = ( Stylesheet ) _includedStylesheets . elementAt ( i ) ; templates . addAll ( included . getAllValidTemplates ( ) ) ; } templates . addAll ( _templates ) ; if ( _parentStylesheet != null ) { return templates ; } _allValidTemplates = templates ; } return _allValidTemplates ; } protected void addTemplate ( Template template ) { _templates . addElement ( template ) ; } } 	0	['62', '2', '0', '70', '204', '1655', '28', '54', '47', '0.957991803', '2554', '0.8125', '7', '0.469565217', '0.095878136', '2', '6', '39.67741935', '12', '2.3387', '0']
package org . apache . xalan . xsltc . cmdline ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . FileInputStream ; import java . util . Properties ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class ObjectFactory { private static final String DEFAULT_PROPERTIES_FILENAME = "xalan.properties" ; private static final String SERVICES_PATH = "META-INF/services/" ; private static final boolean DEBUG = false ; private static Properties fXalanProperties = null ; private static long fLastModified = - 1 ; static Object createObject ( String factoryId , String fallbackClassName ) throws ConfigurationError { return createObject ( factoryId , null , fallbackClassName ) ; } static Object createObject ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { Class factoryClass = lookUpFactoryClass ( factoryId , propertiesFilename , fallbackClassName ) ; if ( factoryClass == null ) { throw new ConfigurationError ( "Provider for " + factoryId + " cannot be found" , null ) ; } try { Object instance = factoryClass . newInstance ( ) ; debugPrintln ( "created new instance of factory " + factoryId ) ; return instance ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider for factory " + factoryId + " could not be instantiated: " + x , x ) ; } } static Class lookUpFactoryClass ( String factoryId ) throws ConfigurationError { return lookUpFactoryClass ( factoryId , null , null ) ; } static Class lookUpFactoryClass ( String factoryId , String propertiesFilename , String fallbackClassName ) throws ConfigurationError { String factoryClassName = lookUpFactoryClassName ( factoryId , propertiesFilename , fallbackClassName ) ; ClassLoader cl = findClassLoader ( ) ; if ( factoryClassName == null ) { factoryClassName = fallbackClassName ; } try { Class providerClass = findProviderClass ( factoryClassName , cl , true ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return providerClass ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + factoryClassName + " could not be instantiated: " + x , x ) ; } } static String lookUpFactoryClassName ( String factoryId , String propertiesFilename , String fallbackClassName ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; try { String systemProp = ss . getSystemProperty ( factoryId ) ; if ( systemProp != null ) { debugPrintln ( "found system property, value=" + systemProp ) ; return systemProp ; } } catch ( SecurityException se ) { } String factoryClassName = null ; if ( propertiesFilename == null ) { File propertiesFile = null ; boolean propertiesFileExists = false ; try { String javah = ss . getSystemProperty ( "java.home" ) ; propertiesFilename = javah + File . separator + "lib" + File . separator + DEFAULT_PROPERTIES_FILENAME ; propertiesFile = new File ( propertiesFilename ) ; propertiesFileExists = ss . getFileExists ( propertiesFile ) ; } catch ( SecurityException e ) { fLastModified = - 1 ; fXalanProperties = null ; } synchronized ( ObjectFactory . class ) { boolean loadProperties = false ; try { if ( fLastModified >= 0 ) { if ( propertiesFileExists && ( fLastModified < ( fLastModified = ss . getLastModified ( propertiesFile ) ) ) ) { loadProperties = true ; } else { if ( ! propertiesFileExists ) { fLastModified = - 1 ; fXalanProperties = null ; } } } else { if ( propertiesFileExists ) { loadProperties = true ; fLastModified = ss . getLastModified ( propertiesFile ) ; } } if ( loadProperties ) { fXalanProperties = new Properties ( ) ; FileInputStream fis = ss . getFileInputStream ( propertiesFile ) ; fXalanProperties . load ( fis ) ; fis . close ( ) ; } } catch ( Exception x ) { fXalanProperties = null ; fLastModified = - 1 ; } } if ( fXalanProperties != null ) { factoryClassName = fXalanProperties . getProperty ( factoryId ) ; } } else { try { FileInputStream fis = ss . getFileInputStream ( new File ( propertiesFilename ) ) ; Properties props = new Properties ( ) ; props . load ( fis ) ; fis . close ( ) ; factoryClassName = props . getProperty ( factoryId ) ; } catch ( Exception x ) { } } if ( factoryClassName != null ) { debugPrintln ( "found in " + propertiesFilename + ", value=" + factoryClassName ) ; return factoryClassName ; } return findJarServiceProviderName ( factoryId ) ; } private static void debugPrintln ( String msg ) { if ( DEBUG ) { System . err . println ( "JAXP: " + msg ) ; } } static ClassLoader findClassLoader ( ) throws ConfigurationError { SecuritySupport ss = SecuritySupport . getInstance ( ) ; ClassLoader context = ss . getContextClassLoader ( ) ; ClassLoader system = ss . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = ss . getParentClassLoader ( chain ) ; } ; return context ; } static Object newInstance ( String className , ClassLoader cl , boolean doFallback ) throws ConfigurationError { try { Class providerClass = findProviderClass ( className , cl , doFallback ) ; Object instance = providerClass . newInstance ( ) ; debugPrintln ( "created new instance of " + providerClass + " using ClassLoader: " + cl ) ; return instance ; } catch ( ClassNotFoundException x ) { throw new ConfigurationError ( "Provider " + className + " not found" , x ) ; } catch ( Exception x ) { throw new ConfigurationError ( "Provider " + className + " could not be instantiated: " + x , x ) ; } } static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { security . checkPackageAccess ( className ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } private static String findJarServiceProviderName ( String factoryId ) { SecuritySupport ss = SecuritySupport . getInstance ( ) ; String serviceId = SERVICES_PATH + factoryId ; InputStream is = null ; ClassLoader cl = findClassLoader ( ) ; is = ss . getResourceAsStream ( cl , serviceId ) ; if ( is == null ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( cl != current ) { cl = current ; is = ss . getResourceAsStream ( cl , serviceId ) ; } } if ( is == null ) { return null ; } debugPrintln ( "found jar resource=" + serviceId + " using ClassLoader: " + cl ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) ) ; } String factoryClassName = null ; try { factoryClassName = rd . readLine ( ) ; rd . close ( ) ; } catch ( IOException x ) { return null ; } if ( factoryClassName != null && ! "" . equals ( factoryClassName ) ) { debugPrintln ( "found in resource, value=" + factoryClassName ) ; return factoryClassName ; } return null ; } static class ConfigurationError extends Error { private Exception exception ; ConfigurationError ( String msg , Exception x ) { super ( msg ) ; this . exception = x ; } Exception getException ( ) { return exception ; } } } 	0	['12', '1', '0', '3', '44', '64', '1', '2', '0', '0.981818182', '586', '1', '0', '0', '0.318181818', '0', '0', '47.41666667', '8', '1.8333', '0']
package org . apache . xpath . functions ; import org . apache . xml . dtm . DTMIterator ; import org . apache . xpath . XPathContext ; import org . apache . xpath . axes . SubContextList ; import org . apache . xpath . compiler . Compiler ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XObject ; public class FuncLast extends Function { private boolean m_isTopLevel ; public void postCompileStep ( Compiler compiler ) { m_isTopLevel = compiler . getLocationPathDepth ( ) == - 1 ; } public int getCountOfContextNodeList ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { SubContextList iter = m_isTopLevel ? null : xctxt . getSubContextList ( ) ; if ( null != iter ) return iter . getLastPos ( xctxt ) ; DTMIterator cnl = xctxt . getContextNodeList ( ) ; int count ; if ( null != cnl ) { count = cnl . getLength ( ) ; } else count = 0 ; return count ; } public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { XNumber xnum = new XNumber ( ( double ) getCountOfContextNodeList ( xctxt ) ) ; return xnum ; } public void fixupVariables ( java . util . Vector vars , int globalsSize ) { } } 	0	['5', '3', '0', '8', '12', '8', '1', '7', '5', '0.5', '59', '1', '0', '0.904761905', '0.4', '1', '6', '10.6', '2', '1', '0']
package org . apache . xpath ; import org . apache . xpath . axes . LocPathIterator ; import org . apache . xpath . axes . UnionPathIterator ; import org . apache . xpath . functions . Function ; import org . apache . xpath . objects . XNumber ; import org . apache . xpath . objects . XString ; import org . apache . xpath . operations . Operation ; import org . apache . xpath . operations . UnaryOperation ; import org . apache . xpath . operations . Variable ; import org . apache . xpath . patterns . NodeTest ; import org . apache . xpath . patterns . StepPattern ; import org . apache . xpath . patterns . UnionPattern ; public class XPathVisitor { public boolean visitLocationPath ( ExpressionOwner owner , LocPathIterator path ) { return true ; } public boolean visitUnionPath ( ExpressionOwner owner , UnionPathIterator path ) { return true ; } public boolean visitStep ( ExpressionOwner owner , NodeTest step ) { return true ; } public boolean visitPredicate ( ExpressionOwner owner , Expression pred ) { return true ; } public boolean visitBinaryOperation ( ExpressionOwner owner , Operation op ) { return true ; } public boolean visitUnaryOperation ( ExpressionOwner owner , UnaryOperation op ) { return true ; } public boolean visitVariableRef ( ExpressionOwner owner , Variable var ) { return true ; } public boolean visitFunction ( ExpressionOwner owner , Function func ) { return true ; } public boolean visitMatchPattern ( ExpressionOwner owner , StepPattern pattern ) { return true ; } public boolean visitUnionPattern ( ExpressionOwner owner , UnionPattern pattern ) { return true ; } public boolean visitStringLiteral ( ExpressionOwner owner , XString str ) { return true ; } public boolean visitNumberLiteral ( ExpressionOwner owner , XNumber num ) { return true ; } } 	0	['13', '1', '5', '43', '14', '78', '40', '13', '13', '2', '40', '0', '0', '0', '0.203296703', '0', '0', '2.076923077', '1', '0.9231', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; public class GetOptsException extends Exception { public GetOptsException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '2', '3', '2', '0', '3', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xpath . functions ; import org . apache . xalan . templates . Constants ; import org . apache . xalan . transformer . TransformerImpl ; import org . apache . xml . utils . QName ; import org . apache . xpath . ExtensionsProvider ; import org . apache . xpath . XPathContext ; import org . apache . xpath . objects . XBoolean ; import org . apache . xpath . objects . XObject ; public class FuncExtElementAvailable extends FunctionOneArg { public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { String prefix ; String namespace ; String methName ; String fullName = m_arg0 . execute ( xctxt ) . str ( ) ; int indexOfNSSep = fullName . indexOf ( ':' ) ; if ( indexOfNSSep < 0 ) { prefix = "" ; namespace = Constants . S_XSLNAMESPACEURL ; methName = fullName ; } else { prefix = fullName . substring ( 0 , indexOfNSSep ) ; namespace = xctxt . getNamespaceContext ( ) . getNamespaceForPrefix ( prefix ) ; if ( null == namespace ) return XBoolean . S_FALSE ; methName = fullName . substring ( indexOfNSSep + 1 ) ; } if ( namespace . equals ( Constants . S_XSLNAMESPACEURL ) || namespace . equals ( Constants . S_BUILTIN_EXTENSIONS_URL ) ) { try { TransformerImpl transformer = ( TransformerImpl ) xctxt . getOwnerObject ( ) ; return transformer . getStylesheet ( ) . getAvailableElements ( ) . containsKey ( new QName ( namespace , methName ) ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } catch ( Exception e ) { return XBoolean . S_FALSE ; } } else { ExtensionsProvider extProvider = ( ExtensionsProvider ) xctxt . getOwnerObject ( ) ; return extProvider . elementAvailable ( namespace , methName ) ? XBoolean . S_TRUE : XBoolean . S_FALSE ; } } } 	0	['2', '4', '0', '10', '17', '1', '0', '10', '2', '2', '87', '0', '0', '0.979591837', '0.75', '2', '7', '42.5', '1', '0.5', '0']
package org . apache . xalan . xsltc ; public class ProcessorVersion { private static int MAJOR = 1 ; private static int MINOR = 0 ; private static int DELTA = 0 ; public static void main ( String [ ] args ) { System . out . println ( "XSLTC version " + MAJOR + "." + MINOR + ( ( DELTA > 0 ) ? ( "." + DELTA ) : ( "" ) ) ) ; } } 	0	['3', '1', '0', '0', '9', '1', '0', '0', '2', '0.5', '44', '1', '0', '0', '0.5', '0', '0', '12.66666667', '2', '0.6667', '0']
package org . apache . xalan . xsltc . cmdline ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . util . Properties ; class SecuritySupport { private static final Object securitySupport ; static { SecuritySupport ss = null ; try { Class c = Class . forName ( "java.security.AccessController" ) ; ss = new SecuritySupport12 ( ) ; } catch ( Exception ex ) { } finally { if ( ss == null ) ss = new SecuritySupport ( ) ; securitySupport = ss ; } } static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } ClassLoader getContextClassLoader ( ) { return null ; } ClassLoader getSystemClassLoader ( ) { return null ; } ClassLoader getParentClassLoader ( ClassLoader cl ) { return null ; } String getSystemProperty ( String propName ) { return System . getProperty ( propName ) ; } FileInputStream getFileInputStream ( File file ) throws FileNotFoundException { return new FileInputStream ( file ) ; } InputStream getResourceAsStream ( ClassLoader cl , String name ) { InputStream ris ; if ( cl == null ) { ris = ClassLoader . getSystemResourceAsStream ( name ) ; } else { ris = cl . getResourceAsStream ( name ) ; } return ris ; } boolean getFileExists ( File f ) { return f . exists ( ) ; } long getLastModified ( File f ) { return f . lastModified ( ) ; } } 	0	['11', '1', '1', '2', '20', '53', '2', '1', '0', '0.9', '90', '1', '0', '0', '0.4', '0', '0', '7.090909091', '2', '0.9091', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . INVOKESTATIC ; import org . apache . bcel . generic . INVOKEVIRTUAL ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . ErrorMsg ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; import org . apache . xalan . xsltc . compiler . util . NodeType ; import org . apache . xalan . xsltc . compiler . util . ReferenceType ; import org . apache . xalan . xsltc . compiler . util . ResultTreeType ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; import org . apache . xalan . xsltc . compiler . util . Util ; final class CopyOf extends Instruction { private Expression _select ; public void display ( int indent ) { indent ( indent ) ; Util . println ( "CopyOf" ) ; indent ( indent + IndentIncrement ) ; Util . println ( "select " + _select . toString ( ) ) ; } public void parseContents ( Parser parser ) { _select = parser . parseExpression ( this , "select" , null ) ; if ( _select . isDummy ( ) ) { reportError ( this , parser , ErrorMsg . REQUIRED_ATTR_ERR , "select" ) ; return ; } } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type tselect = _select . typeCheck ( stable ) ; if ( tselect instanceof NodeType || tselect instanceof NodeSetType || tselect instanceof ReferenceType || tselect instanceof ResultTreeType ) { } else { _select = new CastExpr ( _select , Type . String ) ; } return Type . Void ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; final Type tselect = _select . getType ( ) ; final String CPY1_SIG = "(" + NODE_ITERATOR_SIG + TRANSLET_OUTPUT_SIG + ")V" ; final int cpy1 = cpg . addInterfaceMethodref ( DOM_INTF , "copy" , CPY1_SIG ) ; final String CPY2_SIG = "(" + NODE_SIG + TRANSLET_OUTPUT_SIG + ")V" ; final int cpy2 = cpg . addInterfaceMethodref ( DOM_INTF , "copy" , CPY2_SIG ) ; final String getDoc_SIG = "()" + NODE_SIG ; final int getDoc = cpg . addInterfaceMethodref ( DOM_INTF , "getDocument" , getDoc_SIG ) ; if ( tselect instanceof NodeSetType ) { il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; _select . startIterator ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy1 , 3 ) ) ; } else if ( tselect instanceof NodeType ) { il . append ( methodGen . loadDOM ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy2 , 3 ) ) ; } else if ( tselect instanceof ResultTreeType ) { _select . translate ( classGen , methodGen ) ; il . append ( DUP ) ; il . append ( new INVOKEINTERFACE ( getDoc , 1 ) ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEINTERFACE ( cpy2 , 3 ) ) ; } else if ( tselect instanceof ReferenceType ) { _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( methodGen . loadCurrentNode ( ) ) ; il . append ( methodGen . loadDOM ( ) ) ; final int copy = cpg . addMethodref ( BASIS_LIBRARY_CLASS , "copy" , "(" + OBJECT_SIG + TRANSLET_OUTPUT_SIG + NODE_SIG + DOM_INTF_SIG + ")V" ) ; il . append ( new INVOKESTATIC ( copy ) ) ; } else { il . append ( classGen . loadTranslet ( ) ) ; _select . translate ( classGen , methodGen ) ; il . append ( methodGen . loadHandler ( ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( TRANSLET_CLASS , CHARACTERSW , CHARACTERSW_SIG ) ) ) ; } } } 	0	['5', '3', '0', '25', '32', '0', '2', '23', '4', '0.25', '269', '1', '1', '0.933333333', '0.333333333', '1', '4', '52.6', '5', '1.8', '0']
package org . apache . xpath ; public class SourceTree { public SourceTree ( int root , String url ) { m_root = root ; m_url = url ; } public String m_url ; public int m_root ; } 	0	['1', '1', '0', '1', '2', '0', '1', '0', '1', '2', '12', '0', '0', '0', '1', '0', '0', '9', '0', '0', '0']
package org . apache . xalan . xsltc . compiler . util ; import org . apache . bcel . generic . ACONST_NULL ; import org . apache . bcel . generic . ALOAD ; import org . apache . bcel . generic . ASTORE ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . ILOAD ; import org . apache . bcel . generic . ISTORE ; import org . apache . bcel . generic . Instruction ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . LocalVariableGen ; import org . apache . bcel . generic . Type ; import org . apache . xalan . xsltc . compiler . Constants ; public final class CompareGenerator extends MethodGenerator { private static int DOM_INDEX = 1 ; private static int CURRENT_INDEX = 2 ; private static int LEVEL_INDEX = 3 ; private static int TRANSLET_INDEX = 4 ; private static int LAST_INDEX = 5 ; private int ITERATOR_INDEX = 6 ; private final Instruction _iloadCurrent ; private final Instruction _istoreCurrent ; private final Instruction _aloadDom ; private final Instruction _iloadLast ; private final Instruction _aloadIterator ; private final Instruction _astoreIterator ; public CompareGenerator ( int access_flags , Type return_type , Type [ ] arg_types , String [ ] arg_names , String method_name , String class_name , InstructionList il , ConstantPoolGen cp ) { super ( access_flags , return_type , arg_types , arg_names , method_name , class_name , il , cp ) ; _iloadCurrent = new ILOAD ( CURRENT_INDEX ) ; _istoreCurrent = new ISTORE ( CURRENT_INDEX ) ; _aloadDom = new ALOAD ( DOM_INDEX ) ; _iloadLast = new ILOAD ( LAST_INDEX ) ; LocalVariableGen iterator = addLocalVariable ( "iterator" , Util . getJCRefType ( Constants . NODE_ITERATOR_SIG ) , null , null ) ; ITERATOR_INDEX = iterator . getIndex ( ) ; _aloadIterator = new ALOAD ( ITERATOR_INDEX ) ; _astoreIterator = new ASTORE ( ITERATOR_INDEX ) ; il . append ( new ACONST_NULL ( ) ) ; il . append ( storeIterator ( ) ) ; } public Instruction loadLastNode ( ) { return _iloadLast ; } public Instruction loadCurrentNode ( ) { return _iloadCurrent ; } public Instruction storeCurrentNode ( ) { return _istoreCurrent ; } public Instruction loadDOM ( ) { return _aloadDom ; } public int getHandlerIndex ( ) { return INVALID_INDEX ; } public int getIteratorIndex ( ) { return INVALID_INDEX ; } public Instruction storeIterator ( ) { return _astoreIterator ; } public Instruction loadIterator ( ) { return _aloadIterator ; } public int getLocalIndex ( String name ) { if ( name . equals ( "current" ) ) { return CURRENT_INDEX ; } return super . getLocalIndex ( name ) ; } } 	0	['11', '5', '0', '16', '23', '37', '3', '13', '10', '0.916666667', '141', '1', '0', '0.93877551', '0.225', '2', '5', '10.72727273', '2', '0.9091', '0']
package org . apache . xpath . axes ; import org . apache . xml . dtm . DTM ; import org . apache . xpath . XPathContext ; import org . apache . xpath . compiler . Compiler ; public class ChildIterator extends LocPathIterator { ChildIterator ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis , false ) ; } public int asNode ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { int current = xctxt . getCurrentNode ( ) ; DTM dtm = xctxt . getDTM ( current ) ; return dtm . getFirstChild ( current ) ; } public int nextNode ( ) { if ( m_foundLast ) return DTM . NULL ; int next ; m_lastFetched = next = ( DTM . NULL == m_lastFetched ) ? m_cdtm . getFirstChild ( m_context ) : m_cdtm . getNextSibling ( m_lastFetched ) ; if ( DTM . NULL != next ) { m_pos ++ ; return next ; } else { m_foundLast = true ; return DTM . NULL ; } } public int getAxis ( ) { return org . apache . xml . dtm . Axis . CHILD ; } } 	0	['4', '5', '0', '5', '9', '6', '1', '4', '3', '2', '64', '0', '0', '0.9765625', '0.4375', '1', '6', '15', '4', '1.5', '0']
package org . apache . xml . utils ; public class StringBufferPool { private static ObjectPool m_stringBufPool = new ObjectPool ( org . apache . xml . utils . FastStringBuffer . class ) ; public synchronized static FastStringBuffer get ( ) { return ( FastStringBuffer ) m_stringBufPool . getInstance ( ) ; } public synchronized static void free ( FastStringBuffer sb ) { sb . setLength ( 0 ) ; m_stringBufPool . freeInstance ( sb ) ; } } 	0	['4', '1', '0', '7', '9', '0', '5', '2', '3', '0.333333333', '25', '1', '1', '0', '0.333333333', '0', '0', '5', '1', '0.5', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class RealExpr extends Expression { private double _value ; public RealExpr ( double value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . Real ; } public String toString ( ) { return "real-expr(" + _value + ')' ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { ConstantPoolGen cpg = classGen . getConstantPool ( ) ; InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['4', '3', '0', '11', '14', '0', '0', '11', '4', '0.333333333', '44', '1', '0', '0.959459459', '0.4', '2', '7', '9.75', '1', '0.75', '0']
package org . apache . xalan . xsltc . cmdline . getopt ; class MissingOptArgException extends GetOptsException { public MissingOptArgException ( String msg ) { super ( msg ) ; } } 	0	['1', '4', '0', '2', '2', '0', '1', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . xpath ; import javax . xml . transform . SourceLocator ; public interface ExpressionNode extends SourceLocator { public void exprSetParent ( ExpressionNode n ) ; public ExpressionNode exprGetParent ( ) ; public void exprAddChild ( ExpressionNode n , int i ) ; public ExpressionNode exprGetChild ( int i ) ; public int exprGetNumChildren ( ) ; } 	0	['5', '1', '0', '44', '5', '10', '44', '0', '5', '2', '5', '0', '0', '0', '0.6', '0', '0', '0', '1', '1', '0']
package org . apache . xml . utils ; public class SerializableLocatorImpl implements org . xml . sax . Locator , java . io . Serializable { public SerializableLocatorImpl ( ) { } public SerializableLocatorImpl ( org . xml . sax . Locator locator ) { setPublicId ( locator . getPublicId ( ) ) ; setSystemId ( locator . getSystemId ( ) ) ; setLineNumber ( locator . getLineNumber ( ) ) ; setColumnNumber ( locator . getColumnNumber ( ) ) ; } public String getPublicId ( ) { return publicId ; } public String getSystemId ( ) { return systemId ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setSystemId ( String systemId ) { this . systemId = systemId ; } public void setLineNumber ( int lineNumber ) { this . lineNumber = lineNumber ; } public void setColumnNumber ( int columnNumber ) { this . columnNumber = columnNumber ; } private String publicId ; private String systemId ; private int lineNumber ; private int columnNumber ; } 	0	['10', '1', '0', '0', '15', '37', '0', '0', '10', '0.777777778', '64', '1', '0', '0', '0.375', '0', '0', '5', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . InstructionList ; import org . apache . bcel . generic . PUSH ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . Type ; import org . apache . xalan . xsltc . compiler . util . TypeCheckError ; final class SimpleAttributeValue extends AttributeValue { private String _value ; public SimpleAttributeValue ( String value ) { _value = value ; } public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { return _type = Type . String ; } public String toString ( ) { return _value ; } protected boolean contextDependent ( ) { return false ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( new PUSH ( cpg , _value ) ) ; } } 	0	['5', '4', '0', '14', '10', '4', '4', '11', '4', '0.5', '38', '1', '0', '0.947368421', '0.36', '2', '8', '6.4', '1', '0.8', '0']
package org . apache . xalan . xsltc . compiler ; import org . apache . bcel . generic . CHECKCAST ; import org . apache . bcel . generic . ConstantPoolGen ; import org . apache . bcel . generic . GETFIELD ; import org . apache . bcel . generic . INVOKEINTERFACE ; import org . apache . bcel . generic . InstructionList ; import org . apache . xalan . xsltc . compiler . util . ClassGenerator ; import org . apache . xalan . xsltc . compiler . util . MethodGenerator ; import org . apache . xalan . xsltc . compiler . util . NodeSetType ; final class VariableRef extends VariableRefBase { public VariableRef ( Variable variable ) { super ( variable ) ; } public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( _type . implementedAsMethod ( ) ) return ; final String name = _variable . getEscapedName ( ) ; final String signature = _type . toSignature ( ) ; if ( _variable . isLocal ( ) ) { if ( classGen . isExternal ( ) ) { Closure variableClosure = _closure ; while ( variableClosure != null ) { if ( variableClosure . inInnerClass ( ) ) break ; variableClosure = variableClosure . getParentClosure ( ) ; } if ( variableClosure != null ) { il . append ( ALOAD_0 ) ; il . append ( new GETFIELD ( cpg . addFieldref ( variableClosure . getInnerClassName ( ) , name , signature ) ) ) ; } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { il . append ( _variable . loadInstruction ( ) ) ; _variable . removeReference ( this ) ; } } else { final String className = classGen . getClassName ( ) ; il . append ( classGen . loadTranslet ( ) ) ; if ( classGen . isExternal ( ) ) { il . append ( new CHECKCAST ( cpg . addClass ( className ) ) ) ; } il . append ( new GETFIELD ( cpg . addFieldref ( className , name , signature ) ) ) ; } if ( _variable . getType ( ) instanceof NodeSetType ) { final int clone = cpg . addInterfaceMethodref ( NODE_ITERATOR , "cloneIterator" , "()" + NODE_ITERATOR_SIG ) ; il . append ( new INVOKEINTERFACE ( clone , 1 ) ) ; } } } 	0	['2', '4', '0', '17', '25', '1', '1', '16', '2', '2', '137', '0', '0', '0.987012987', '0.625', '2', '3', '67.5', '9', '4.5', '0']
package org . apache . xpath . objects ; import org . apache . xml . dtm . DTMManager ; import org . apache . xpath . NodeSetDTM ; import org . apache . xpath . XPathContext ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . traversal . NodeIterator ; public class XNodeSetForDOM extends XNodeSet { Object m_origObj ; public XNodeSetForDOM ( Node node , DTMManager dtmMgr ) { m_dtmMgr = dtmMgr ; m_origObj = node ; int dtmHandle = dtmMgr . getDTMHandleFromNode ( node ) ; m_obj = new NodeSetDTM ( dtmMgr ) ; ( ( NodeSetDTM ) m_obj ) . addNode ( dtmHandle ) ; } public XNodeSetForDOM ( XNodeSet val ) { super ( val ) ; if ( val instanceof XNodeSetForDOM ) m_origObj = ( ( XNodeSetForDOM ) val ) . m_origObj ; } public XNodeSetForDOM ( NodeList nodeList , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeList ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeList , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public XNodeSetForDOM ( NodeIterator nodeIter , XPathContext xctxt ) { m_dtmMgr = xctxt . getDTMManager ( ) ; m_origObj = nodeIter ; org . apache . xpath . NodeSetDTM nsdtm = new org . apache . xpath . NodeSetDTM ( nodeIter , xctxt ) ; m_last = nsdtm . getLength ( ) ; m_obj = nsdtm ; } public Object object ( ) { return m_origObj ; } public NodeIterator nodeset ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeIterator ) ? ( NodeIterator ) m_origObj : super . nodeset ( ) ; } public NodeList nodelist ( ) throws javax . xml . transform . TransformerException { return ( m_origObj instanceof NodeList ) ? ( NodeList ) m_origObj : super . nodelist ( ) ; } } 	0	['7', '5', '0', '5', '18', '0', '1', '4', '7', '0', '115', '0', '0', '0.978417266', '0.285714286', '3', '14', '15.28571429', '1', '0.4286', '0']
package org . apache . xpath . compiler ; public class PsuedoNames { public static final String PSEUDONAME_ANY = "*" ; public static final String PSEUDONAME_ROOT = "/" ; public static final String PSEUDONAME_TEXT = "#text" ; public static final String PSEUDONAME_COMMENT = "#comment" ; public static final String PSEUDONAME_PI = "#pi" ; public static final String PSEUDONAME_OTHER = "*" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '10', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
