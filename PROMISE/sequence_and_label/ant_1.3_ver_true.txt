package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . util . Vector ; import java . io . File ; import java . io . IOException ; public class ExecuteOn extends ExecTask { protected Vector filesets = new Vector ( ) ; private boolean parallel = false ; protected String type = "file" ; protected Commandline . Marker srcFilePos = null ; public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void setParallel ( boolean parallel ) { this . parallel = parallel ; } public void setType ( FileDirBoth type ) { this . type = type . getValue ( ) ; } public Commandline . Marker createSrcfile ( ) { if ( srcFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple srcfile elements." , location ) ; } srcFilePos = cmdl . createMarker ( ) ; return srcFilePos ; } protected void checkConfiguration ( ) { super . checkConfiguration ( ) ; if ( filesets . size ( ) == 0 ) { throw new BuildException ( "no filesets specified" , location ) ; } } protected void runExec ( Execute exe ) throws BuildException { try { for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { Vector v = new Vector ( ) ; FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; File base = fs . getDir ( project ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; if ( ! "dir" . equals ( type ) ) { String [ ] s = getFiles ( base , ds ) ; for ( int j = 0 ; j < s . length ; j ++ ) { v . addElement ( s [ j ] ) ; } } if ( ! "file" . equals ( type ) ) { String [ ] s = getDirs ( base , ds ) ; ; for ( int j = 0 ; j < s . length ; j ++ ) { v . addElement ( s [ j ] ) ; } } String [ ] s = new String [ v . size ( ) ] ; v . copyInto ( s ) ; int err = - 1 ; if ( parallel ) { String [ ] command = getCommandline ( s , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } else { for ( int j = 0 ; j < s . length ; j ++ ) { String [ ] command = getCommandline ( s [ j ] , base ) ; log ( "Executing " + Commandline . toString ( command ) , Project . MSG_VERBOSE ) ; exe . setCommandline ( command ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } } } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected String [ ] getCommandline ( String [ ] srcFiles , File baseDir ) { String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length ] ; int index = orig . length ; if ( srcFilePos != null ) { index = srcFilePos . getPosition ( ) ; } System . arraycopy ( orig , 0 , result , 0 , index ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ index + i ] = ( new File ( baseDir , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } System . arraycopy ( orig , index , result , index + srcFiles . length , orig . length - index ) ; return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , baseDir ) ; } protected String [ ] getFiles ( File basedir , DirectoryScanner ds ) { return ds . getIncludedFiles ( ) ; } protected String [ ] getDirs ( File basedir , DirectoryScanner ds ) { return ds . getIncludedDirectories ( ) ; } public static class FileDirBoth extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "file" , "dir" , "both" } ; } } } 	0	['11', '4', '2', '14', '42', '29', '2', '12', '5', '0.725', '395', '1', '1', '0.885057471', '0.232323232', '3', '4', '34.54545455', '3', '1.2727', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '9', '0', '0', '1', '1', '0', '58', '1', '1', '0.714285714', '0.666666667', '1', '1', '17.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; public class Cvs extends Task { private Commandline cmd = new Commandline ( ) ; private String cvsRoot ; private String pack ; private String command = "checkout" ; private boolean quiet = false ; private boolean noexec = false ; private File dest ; private File output ; private File error ; public void execute ( ) throws BuildException { Commandline toExecute = new Commandline ( ) ; toExecute . setExecutable ( "cvs" ) ; if ( cvsRoot != null ) { toExecute . createArgument ( ) . setValue ( "-d" ) ; toExecute . createArgument ( ) . setValue ( cvsRoot ) ; } if ( noexec ) { toExecute . createArgument ( ) . setValue ( "-n" ) ; } if ( quiet ) { toExecute . createArgument ( ) . setValue ( "-q" ) ; } toExecute . createArgument ( ) . setLine ( command ) ; toExecute . addArguments ( cmd . getCommandline ( ) ) ; if ( pack != null ) { toExecute . createArgument ( ) . setLine ( pack ) ; } ExecuteStreamHandler streamhandler = null ; OutputStream outputstream = null ; OutputStream errorstream = null ; if ( error == null && output == null ) { streamhandler = new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } else { if ( output != null ) { try { outputstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { outputstream = new LogOutputStream ( this , Project . MSG_INFO ) ; } if ( error != null ) { try { errorstream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( error ) ) ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } else { errorstream = new LogOutputStream ( this , Project . MSG_WARN ) ; } streamhandler = new PumpStreamHandler ( outputstream , errorstream ) ; } Execute exe = new Execute ( streamhandler , null ) ; exe . setAntRun ( project ) ; if ( dest == null ) dest = project . getBaseDir ( ) ; exe . setWorkingDirectory ( dest ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } finally { if ( output != null ) { try { outputstream . close ( ) ; } catch ( IOException e ) { } } if ( error != null ) { try { errorstream . close ( ) ; } catch ( IOException e ) { } } } } public void setCvsRoot ( String root ) { if ( root != null ) { if ( root . trim ( ) . equals ( "" ) ) root = null ; } this . cvsRoot = root ; } public void setDest ( File dest ) { this . dest = dest ; } public void setPackage ( String p ) { this . pack = p ; } public void setTag ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-r" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setDate ( String p ) { if ( p != null && p . trim ( ) . length ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-D" ) ; cmd . createArgument ( ) . setValue ( p ) ; } } public void setCommand ( String c ) { this . command = c ; } public void setQuiet ( boolean q ) { quiet = q ; } public void setNoexec ( boolean ne ) { noexec = ne ; } public void setOutput ( File output ) { this . output = output ; } public void setError ( File error ) { this . error = error ; } } 	0	['12', '3', '0', '12', '37', '32', '0', '12', '12', '0.858585859', '310', '1', '1', '0.770833333', '0.458333333', '0', '0', '24.08333333', '3', '1.4167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , location ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , location ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , location ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { project . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '4', '21', '1', '0', '4', '6', '0.7', '136', '1', '0', '0.880952381', '0.416666667', '2', '2', '21', '1', '0.8333', '0']
package org . apache . tools . ant . util ; public class GlobPatternMapper implements FileNameMapper { protected String fromPrefix = null ; protected String fromPostfix = null ; protected int prefixLength ; protected int postfixLength ; protected String toPrefix = null ; protected String toPostfix = null ; public void setFrom ( String from ) { int index = from . lastIndexOf ( "*" ) ; if ( index == - 1 ) { fromPrefix = from ; fromPostfix = "" ; } else { fromPrefix = from . substring ( 0 , index ) ; fromPostfix = from . substring ( index + 1 ) ; } prefixLength = fromPrefix . length ( ) ; postfixLength = fromPostfix . length ( ) ; } public void setTo ( String to ) { int index = to . lastIndexOf ( "*" ) ; if ( index == - 1 ) { toPrefix = to ; toPostfix = "" ; } else { toPrefix = to . substring ( 0 , index ) ; toPostfix = to . substring ( index + 1 ) ; } } public String [ ] mapFileName ( String sourceFileName ) { if ( fromPrefix == null || ! sourceFileName . startsWith ( fromPrefix ) || ! sourceFileName . endsWith ( fromPostfix ) ) { return null ; } return new String [ ] { toPrefix + extractVariablePart ( sourceFileName ) + toPostfix } ; } protected String extractVariablePart ( String name ) { return name . substring ( prefixLength , name . length ( ) - postfixLength ) ; } } 	0	['5', '1', '0', '3', '15', '0', '2', '1', '4', '0.5', '137', '1', '0', '0', '0.9', '0', '0', '25.2', '4', '1.8', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Move extends Copy { public Move ( ) { super ( ) ; forceOverwrite = true ; } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Moving " + fileCopyMap . size ( ) + " files to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; try { log ( "Moving " + fromFile + " to " + toFile , verbosity ) ; project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; File f = new File ( fromFile ) ; if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Moved " + count + " empty directories to " + destDir . getAbsolutePath ( ) ) ; } } if ( filesets . size ( ) > 0 ) { Enumeration e = filesets . elements ( ) ; while ( e . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; File dir = fs . getDir ( project ) ; if ( okToDelete ( dir ) ) { deleteDir ( dir ) ; } } } } protected boolean okToDelete ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return false ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { if ( ! okToDelete ( f ) ) return false ; } else { return false ; } } return true ; } protected void deleteDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) return ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { deleteDir ( f ) ; } else { throw new BuildException ( "UNEXPECTED ERROR - The file " + f . getAbsolutePath ( ) + " should not exist!" ) ; } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + d . getAbsolutePath ( ) ) ; } } } 	0	['4', '4', '0', '6', '32', '6', '0', '6', '1', '2', '325', '0', '0', '0.963855422', '0.75', '3', '5', '80.25', '11', '5.25', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarInputStream extends FilterInputStream { protected boolean debug ; protected boolean hasHitEOF ; protected int entrySize ; protected int entryOffset ; protected byte [ ] oneBuf ; protected byte [ ] readBuf ; protected TarBuffer buffer ; protected TarEntry currEntry ; public TarInputStream ( InputStream is ) { this ( is , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize ) { this ( is , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarInputStream ( InputStream is , int blockSize , int recordSize ) { super ( is ) ; this . buffer = new TarBuffer ( is , blockSize , recordSize ) ; this . readBuf = null ; this . oneBuf = new byte [ 1 ] ; this . debug = false ; this . hasHitEOF = false ; } public void setDebug ( boolean debug ) { this . debug = debug ; this . buffer . setDebug ( debug ) ; } public void close ( ) throws IOException { this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public int available ( ) throws IOException { return this . entrySize - this . entryOffset ; } public void skip ( int numToSkip ) throws IOException { byte [ ] skipBuf = new byte [ 8 * 1024 ] ; for ( int num = numToSkip ; num > 0 ; ) { int numRead = this . read ( skipBuf , 0 , ( num > skipBuf . length ? skipBuf . length : num ) ) ; if ( numRead == - 1 ) { break ; } num -= numRead ; } } public boolean markSupported ( ) { return false ; } public void mark ( int markLimit ) { } public void reset ( ) { } public TarEntry getNextEntry ( ) throws IOException { if ( this . hasHitEOF ) { return null ; } if ( this . currEntry != null ) { int numToSkip = this . entrySize - this . entryOffset ; if ( this . debug ) { System . err . println ( "TarInputStream: SKIP currENTRY '" + this . currEntry . getName ( ) + "' SZ " + this . entrySize + " OFF " + this . entryOffset + "  skipping " + numToSkip + " bytes" ) ; } if ( numToSkip > 0 ) { this . skip ( numToSkip ) ; } this . readBuf = null ; } byte [ ] headerBuf = this . buffer . readRecord ( ) ; if ( headerBuf == null ) { if ( this . debug ) { System . err . println ( "READ NULL RECORD" ) ; } this . hasHitEOF = true ; } else if ( this . buffer . isEOFRecord ( headerBuf ) ) { if ( this . debug ) { System . err . println ( "READ EOF RECORD" ) ; } this . hasHitEOF = true ; } if ( this . hasHitEOF ) { this . currEntry = null ; } else { this . currEntry = new TarEntry ( headerBuf ) ; if ( ! ( headerBuf [ 257 ] == 'u' && headerBuf [ 258 ] == 's' && headerBuf [ 259 ] == 't' && headerBuf [ 260 ] == 'a' && headerBuf [ 261 ] == 'r' ) ) { this . entrySize = 0 ; this . entryOffset = 0 ; this . currEntry = null ; throw new IOException ( "bad header in block " + this . buffer . getCurrentBlockNum ( ) + " record " + this . buffer . getCurrentRecordNum ( ) + ", " + "header magic is not 'ustar', but '" + headerBuf [ 257 ] + headerBuf [ 258 ] + headerBuf [ 259 ] + headerBuf [ 260 ] + headerBuf [ 261 ] + "', or (dec) " + ( ( int ) headerBuf [ 257 ] ) + ", " + ( ( int ) headerBuf [ 258 ] ) + ", " + ( ( int ) headerBuf [ 259 ] ) + ", " + ( ( int ) headerBuf [ 260 ] ) + ", " + ( ( int ) headerBuf [ 261 ] ) ) ; } if ( this . debug ) { System . err . println ( "TarInputStream: SET CURRENTRY '" + this . currEntry . getName ( ) + "' size = " + this . currEntry . getSize ( ) ) ; } this . entryOffset = 0 ; this . entrySize = ( int ) this . currEntry . getSize ( ) ; } if ( this . currEntry != null && this . currEntry . isGNULongNameEntry ( ) ) { StringBuffer longName = new StringBuffer ( ) ; byte [ ] buffer = new byte [ 256 ] ; int length = 0 ; while ( ( length = read ( buffer ) ) >= 0 ) { longName . append ( new String ( buffer , 0 , length ) ) ; } getNextEntry ( ) ; this . currEntry . setName ( longName . toString ( ) ) ; } return this . currEntry ; } public int read ( ) throws IOException { int num = this . read ( this . oneBuf , 0 , 1 ) ; if ( num == - 1 ) { return num ; } else { return ( int ) this . oneBuf [ 0 ] ; } } public int read ( byte [ ] buf ) throws IOException { return this . read ( buf , 0 , buf . length ) ; } public int read ( byte [ ] buf , int offset , int numToRead ) throws IOException { int totalRead = 0 ; if ( this . entryOffset >= this . entrySize ) { return - 1 ; } if ( ( numToRead + this . entryOffset ) > this . entrySize ) { numToRead = ( this . entrySize - this . entryOffset ) ; } if ( this . readBuf != null ) { int sz = ( numToRead > this . readBuf . length ) ? this . readBuf . length : numToRead ; System . arraycopy ( this . readBuf , 0 , buf , offset , sz ) ; if ( sz >= this . readBuf . length ) { this . readBuf = null ; } else { int newLen = this . readBuf . length - sz ; byte [ ] newBuf = new byte [ newLen ] ; System . arraycopy ( this . readBuf , sz , newBuf , 0 , newLen ) ; this . readBuf = newBuf ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } while ( numToRead > 0 ) { byte [ ] rec = this . buffer . readRecord ( ) ; if ( rec == null ) { throw new IOException ( "unexpected EOF with " + numToRead + " bytes unread" ) ; } int sz = numToRead ; int recLen = rec . length ; if ( recLen > sz ) { System . arraycopy ( rec , 0 , buf , offset , sz ) ; this . readBuf = new byte [ recLen - sz ] ; System . arraycopy ( rec , sz , this . readBuf , 0 , recLen - sz ) ; } else { sz = recLen ; System . arraycopy ( rec , 0 , buf , offset , recLen ) ; } totalRead += sz ; numToRead -= sz ; offset += sz ; } this . entryOffset += totalRead ; return totalRead ; } public void copyEntryContents ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 32 * 1024 ] ; while ( true ) { int numRead = this . read ( buf , 0 , buf . length ) ; if ( numRead == - 1 ) { break ; } out . write ( buf , 0 , numRead ) ; } } } 	0	['16', '3', '0', '3', '40', '84', '1', '2', '16', '0.658333333', '604', '1', '2', '0.580645161', '0.291666667', '2', '7', '36.25', '1', '0.8125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . PatternSet ; import java . util . * ; public class CompileTask extends Javac { protected Vector taskList = new Vector ( ) ; public Taskdef createTaskdef ( ) { Taskdef task = new Taskdef ( ) ; taskList . addElement ( task ) ; return task ; } public void init ( ) { log ( "!! CompileTask is deprecated. !!" ) ; log ( "Use <taskdef> elements nested into <target>s instead" ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; String source = task . getClassname ( ) . replace ( '.' , '/' ) + ".java" ; PatternSet . NameEntry include = super . createInclude ( ) ; include . setName ( "**/" + source ) ; } super . init ( ) ; super . execute ( ) ; for ( Enumeration e = taskList . elements ( ) ; e . hasMoreElements ( ) ; ) { Taskdef task = ( Taskdef ) e . nextElement ( ) ; task . init ( ) ; } } public void execute ( ) { } } 	0	['4', '5', '0', '5', '21', '0', '0', '5', '4', '0.333333333', '87', '1', '0', '0.98089172', '1', '1', '1', '20.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; import java . io . File ; import java . io . IOException ; public class Patch extends Task { private File originalFile ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , location ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , location ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , location ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } } 	0	['9', '3', '0', '9', '29', '0', '0', '9', '9', '0.583333333', '168', '1', '1', '0.822222222', '0.444444444', '0', '0', '17.33333333', '2', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; private static final int BUFFER_SIZE = 512 ; public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) dir = project . getBaseDir ( ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( project . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) { throw new BuildException ( "Property 'ant.home' not found" , location ) ; } String antRun = project . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = project . getProperty ( "ant.home" ) ; if ( ant == null ) throw new BuildException ( "Property 'ant.home' not found" , location ) ; String antRun = project . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO , this ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN , this ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , location ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = project . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } ; protected void logFlush ( ) { if ( fos != null ) fos . close ( ) ; } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private int SLEEP_TIME = 5 ; private Exec parent ; public StreamPumper ( InputStream is , int messageLevel , Exec parent ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; this . parent = parent ; } public void pumpStream ( ) throws IOException { byte [ ] buf = new byte [ BUFFER_SIZE ] ; if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '5', '41', '21', '1', '5', '7', '0.793650794', '360', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; public abstract String [ ] getValues ( ) ; public EnumeratedAttribute ( ) { } public final void setValue ( String value ) throws BuildException { if ( ! containsValue ( value ) ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . value = value ; } public final boolean containsValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return false ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return true ; } } return false ; } public final String getValue ( ) { return value ; } } 	0	['5', '1', '5', '12', '11', '8', '11', '1', '5', '0.75', '59', '1', '0', '0', '0.7', '0', '0', '10.6', '5', '1.6', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; import javax . xml . parsers . * ; import org . w3c . dom . * ; import org . apache . tools . ant . util . DOMElementWriter ; public class XmlLogger implements BuildListener { private static final DocumentBuilder builder = getDocumentBuilder ( ) ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String BUILD_TAG = "build" ; private static final String TARGET_TAG = "target" ; private static final String TASK_TAG = "task" ; private static final String MESSAGE_TAG = "message" ; private static final String NAME_ATTR = "name" ; private static final String TIME_ATTR = "time" ; private static final String PRIORITY_ATTR = "priority" ; private static final String LOCATION_ATTR = "location" ; private static final String ERROR_ATTR = "error" ; private Document doc ; private Element buildElement ; private Element targetElement ; private Element taskElement ; private long buildStartTime ; private long targetStartTime ; private long taskStartTime ; private Stack targetTimeStack = new Stack ( ) ; private Stack targetStack = new Stack ( ) ; private Stack taskTimeStack = new Stack ( ) ; private Stack taskStack = new Stack ( ) ; public XmlLogger ( ) { } public void buildStarted ( BuildEvent event ) { buildStartTime = System . currentTimeMillis ( ) ; doc = builder . newDocument ( ) ; buildElement = doc . createElement ( BUILD_TAG ) ; } public void buildFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - buildStartTime ; buildElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( event . getException ( ) != null ) { buildElement . setAttribute ( ERROR_ATTR , event . getException ( ) . toString ( ) ) ; } try { String outFilename = event . getProject ( ) . getProperty ( "XmlLogger.file" ) ; if ( outFilename == null ) { outFilename = "log.xml" ; } Writer out = new FileWriter ( outFilename ) ; out . write ( "<?xml:stylesheet type=\"text/xsl\" href=\"log.xsl\"?>\n\n" ) ; ( new DOMElementWriter ( ) ) . write ( buildElement , out , 0 , "\t" ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to close log file" , exc ) ; } buildElement = null ; } public void targetStarted ( BuildEvent event ) { if ( targetElement != null ) { targetTimeStack . push ( new Long ( targetStartTime ) ) ; targetStack . push ( targetElement ) ; } targetStartTime = System . currentTimeMillis ( ) ; targetElement = doc . createElement ( TARGET_TAG ) ; targetElement . setAttribute ( NAME_ATTR , event . getTarget ( ) . getName ( ) ) ; } public void targetFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - targetStartTime ; targetElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; if ( taskElement == null ) { buildElement . appendChild ( targetElement ) ; } else { taskElement . appendChild ( targetElement ) ; } targetElement = null ; if ( ! targetStack . isEmpty ( ) ) { targetStartTime = ( ( Long ) targetTimeStack . pop ( ) ) . longValue ( ) ; targetElement = ( Element ) targetStack . pop ( ) ; } } public void taskStarted ( BuildEvent event ) { if ( taskElement != null ) { taskTimeStack . push ( new Long ( taskStartTime ) ) ; taskStack . push ( taskElement ) ; } taskStartTime = System . currentTimeMillis ( ) ; taskElement = doc . createElement ( TASK_TAG ) ; String name = event . getTask ( ) . getClass ( ) . getName ( ) ; int pos = name . lastIndexOf ( "." ) ; if ( pos != - 1 ) { name = name . substring ( pos + 1 ) ; } taskElement . setAttribute ( NAME_ATTR , name ) ; taskElement . setAttribute ( LOCATION_ATTR , event . getTask ( ) . getLocation ( ) . toString ( ) ) ; } public void taskFinished ( BuildEvent event ) { long totalTime = System . currentTimeMillis ( ) - taskStartTime ; taskElement . setAttribute ( TIME_ATTR , DefaultLogger . formatTime ( totalTime ) ) ; targetElement . appendChild ( taskElement ) ; taskElement = null ; if ( ! taskStack . isEmpty ( ) ) { taskStartTime = ( ( Long ) taskTimeStack . pop ( ) ) . longValue ( ) ; taskElement = ( Element ) taskStack . pop ( ) ; } } public void messageLogged ( BuildEvent event ) { Element messageElement = doc . createElement ( MESSAGE_TAG ) ; String name = "debug" ; switch ( event . getPriority ( ) ) { case Project . MSG_ERR : name = "error" ; break ; case Project . MSG_WARN : name = "warn" ; break ; case Project . MSG_INFO : name = "info" ; break ; default : name = "debug" ; break ; } messageElement . setAttribute ( PRIORITY_ATTR , name ) ; Text messageText = doc . createTextNode ( event . getMessage ( ) ) ; messageElement . appendChild ( messageText ) ; if ( taskElement != null ) { taskElement . appendChild ( messageElement ) ; } else if ( targetElement != null ) { targetElement . appendChild ( messageElement ) ; } else { buildElement . appendChild ( messageElement ) ; } } } 	0	['10', '1', '0', '9', '49', '1', '0', '9', '8', '0.920634921', '382', '1', '0', '0', '0.833333333', '0', '0', '35.1', '4', '1.9', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . regexp . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaRegexpMatcher implements RegexpMatcher { protected RE reg = null ; private String pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = pattern ; reg = new RE ( pattern ) ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern ; } public boolean matches ( String argument ) { return reg . match ( argument ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < reg . getParenCount ( ) ; i ++ ) { v . addElement ( reg . getParen ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '4', '13', '0', '0', '4', '5', '0.5', '65', '1', '0', '0', '0.8', '0', '0', '11.6', '3', '1.2', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . * ; public interface BuildLogger extends BuildListener { public void setMessageOutputLevel ( int level ) ; public void setOutputPrintStream ( PrintStream output ) ; public void setEmacsMode ( boolean emacsMode ) ; public void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '3', '4', '6', '2', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public abstract class DataType { protected String description = null ; protected Reference ref = null ; protected boolean checked = true ; public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public boolean isReference ( ) { return ref != null ; } public void setRefid ( Reference ref ) { this . ref = ref ; checked = false ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( p ) ; if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } checked = true ; } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one attribute" + " when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular reference." ) ; } } 	0	['9', '1', '4', '8', '15', '18', '5', '3', '5', '0.708333333', '98', '1', '1', '0', '0.288888889', '0', '0', '9.555555556', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . net . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Get extends Task { private URL source ; private File dest ; private boolean verbose = false ; private boolean useTimestamp = false ; private boolean ignoreErrors = false ; public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( dest . exists ( ) && dest . isDirectory ( ) ) { throw new BuildException ( "The specified destination is a directory" , location ) ; } if ( dest . exists ( ) && ! dest . canWrite ( ) ) { throw new BuildException ( "Can't write to " + dest . getAbsolutePath ( ) , location ) ; } try { log ( "Getting: " + source ) ; long timestamp = 0 ; boolean hasTimestamp = false ; if ( useTimestamp && dest . exists ( ) ) { timestamp = dest . lastModified ( ) ; if ( verbose ) { Date t = new Date ( timestamp ) ; log ( "local file date : " + t . toString ( ) ) ; } hasTimestamp = true ; } URLConnection connection = source . openConnection ( ) ; if ( useTimestamp && hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; if ( httpConnection . getResponseCode ( ) == HttpURLConnection . HTTP_NOT_MODIFIED ) { log ( "Not modified - so not downloaded" ) ; return ; } } FileOutputStream fos = new FileOutputStream ( dest ) ; InputStream is = null ; for ( int i = 0 ; i < 3 ; i ++ ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { log ( "Error opening connection " + ex ) ; } } if ( is == null ) { log ( "Can't get " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( "Can't get " + source + " to " + dest , location ) ; } byte [ ] buffer = new byte [ 100 * 1024 ] ; int length ; while ( ( length = is . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; if ( verbose ) System . out . print ( "." ) ; } if ( verbose ) System . out . println ( ) ; fos . close ( ) ; is . close ( ) ; if ( useTimestamp ) { long remoteTimestamp = connection . getLastModified ( ) ; if ( verbose ) { Date t = new Date ( remoteTimestamp ) ; log ( "last modified = " + t . toString ( ) + ( ( remoteTimestamp == 0 ) ? " - using current time instead" : "" ) ) ; } if ( remoteTimestamp != 0 ) touchFile ( dest , remoteTimestamp ) ; } } catch ( IOException ioe ) { log ( "Error getting " + source + " to " + dest ) ; if ( ignoreErrors ) return ; throw new BuildException ( ioe , location ) ; } } protected boolean touchFile ( File file , long timemillis ) throws BuildException { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; touch . setFile ( file ) ; touch . setMillis ( timemillis ) ; touch . touch ( ) ; return true ; } else { return false ; } } public void setSrc ( URL u ) { this . source = u ; } public void setDest ( File dest ) { this . dest = dest ; } public void setVerbose ( boolean v ) { verbose = v ; } public void setIgnoreErrors ( boolean v ) { ignoreErrors = v ; } public void setUseTimestamp ( boolean v ) { if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { useTimestamp = v ; } } } 	0	['8', '3', '0', '6', '46', '10', '0', '6', '7', '0.771428571', '394', '1', '0', '0.840909091', '0.375', '1', '1', '47.625', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { public void setJavac ( Javac attributes ) ; public boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . IOException ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; public class LogOutputStream extends OutputStream { private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; private Task task ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this . task = task ; this . level = level ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) processBuffer ( ) ; } else buffer . write ( cc ) ; skip = ( c == '\r' ) ; } protected void processBuffer ( ) { processLine ( buffer . toString ( ) ) ; buffer . reset ( ) ; } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { task . log ( line , level ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) processBuffer ( ) ; super . close ( ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['7', '2', '1', '8', '15', '1', '7', '1', '4', '0.583333333', '92', '1', '1', '0.454545455', '0.464285714', '1', '1', '11.57142857', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamPumper implements Runnable { private final static int SLEEP = 5 ; private final static int SIZE = 128 ; private InputStream is ; private OutputStream os ; public StreamPumper ( InputStream is , OutputStream os ) { this . is = is ; this . os = os ; } public void run ( ) { final byte [ ] buf = new byte [ SIZE ] ; int length ; try { while ( ( length = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , length ) ; try { Thread . sleep ( SLEEP ) ; } catch ( InterruptedException e ) { } } } catch ( IOException e ) { } } } 	0	['2', '1', '0', '1', '6', '0', '1', '0', '2', '1', '39', '1', '0', '0', '0.666666667', '0', '0', '16.5', '2', '1', '0']
package org . apache . tools . ant ; import java . io . * ; import java . util . * ; public class DirectoryScanner implements FileScanner { protected final static String [ ] DEFAULTEXCLUDES = { "**/*~" , "**/#*#" , "**/%*%" , "**/CVS" , "**/CVS/**" , "**/.cvsignore" } ; protected File basedir ; protected String [ ] includes ; protected String [ ] excludes ; protected Vector filesIncluded ; protected Vector filesNotIncluded ; protected Vector filesExcluded ; protected Vector dirsIncluded ; protected Vector dirsNotIncluded ; protected Vector dirsExcluded ; protected boolean haveSlowResults = false ; public DirectoryScanner ( ) { } protected static boolean matchPatternStart ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { return true ; } else if ( patIdxStart > patIdxEnd ) { return false ; } else { return true ; } } protected static boolean matchPath ( String pattern , String str ) { if ( str . startsWith ( File . separator ) != pattern . startsWith ( File . separator ) ) { return false ; } Vector patDirs = new Vector ( ) ; StringTokenizer st = new StringTokenizer ( pattern , File . separator ) ; while ( st . hasMoreTokens ( ) ) { patDirs . addElement ( st . nextToken ( ) ) ; } Vector strDirs = new Vector ( ) ; st = new StringTokenizer ( str , File . separator ) ; while ( st . hasMoreTokens ( ) ) { strDirs . addElement ( st . nextToken ( ) ) ; } int patIdxStart = 0 ; int patIdxEnd = patDirs . size ( ) - 1 ; int strIdxStart = 0 ; int strIdxEnd = strDirs . size ( ) - 1 ; while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxStart ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxStart ) ) ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } else { if ( patIdxStart > patIdxEnd ) { return false ; } } while ( patIdxStart <= patIdxEnd && strIdxStart <= strIdxEnd ) { String patDir = ( String ) patDirs . elementAt ( patIdxEnd ) ; if ( patDir . equals ( "**" ) ) { break ; } if ( ! match ( patDir , ( String ) strDirs . elementAt ( strIdxEnd ) ) ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patDirs . elementAt ( i ) . equals ( "**" ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { String subPat = ( String ) patDirs . elementAt ( patIdxStart + j + 1 ) ; String subStr = ( String ) strDirs . elementAt ( strIdxStart + i + j ) ; if ( ! match ( subPat , subStr ) ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( ! patDirs . elementAt ( i ) . equals ( "**" ) ) { return false ; } } return true ; } protected static boolean match ( String pattern , String str ) { char [ ] patArr = pattern . toCharArray ( ) ; char [ ] strArr = str . toCharArray ( ) ; int patIdxStart = 0 ; int patIdxEnd = patArr . length - 1 ; int strIdxStart = 0 ; int strIdxEnd = strArr . length - 1 ; char ch ; boolean containsStar = false ; for ( int i = 0 ; i < patArr . length ; i ++ ) { if ( patArr [ i ] == '*' ) { containsStar = true ; break ; } } if ( ! containsStar ) { if ( patIdxEnd != strIdxEnd ) { return false ; } for ( int i = 0 ; i <= patIdxEnd ; i ++ ) { ch = patArr [ i ] ; if ( ch != '?' && ch != strArr [ i ] ) { return false ; } } return true ; } if ( patIdxEnd == 0 ) { return true ; } while ( ( ch = patArr [ patIdxStart ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxStart ] ) { return false ; } patIdxStart ++ ; strIdxStart ++ ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( ( ch = patArr [ patIdxEnd ] ) != '*' && strIdxStart <= strIdxEnd ) { if ( ch != '?' && ch != strArr [ strIdxEnd ] ) { return false ; } patIdxEnd -- ; strIdxEnd -- ; } if ( strIdxStart > strIdxEnd ) { for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } while ( patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd ) { int patIdxTmp = - 1 ; for ( int i = patIdxStart + 1 ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] == '*' ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patIdxStart + 1 ) { patIdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patIdxStart - 1 ) ; int strLength = ( strIdxEnd - strIdxStart + 1 ) ; int foundIdx = - 1 ; strLoop : for ( int i = 0 ; i <= strLength - patLength ; i ++ ) { for ( int j = 0 ; j < patLength ; j ++ ) { ch = patArr [ patIdxStart + j + 1 ] ; if ( ch != '?' && ch != strArr [ strIdxStart + i + j ] ) { continue strLoop ; } } foundIdx = strIdxStart + i ; break ; } if ( foundIdx == - 1 ) { return false ; } patIdxStart = patIdxTmp ; strIdxStart = foundIdx + patLength ; } for ( int i = patIdxStart ; i <= patIdxEnd ; i ++ ) { if ( patArr [ i ] != '*' ) { return false ; } } return true ; } public void setBasedir ( String basedir ) { setBasedir ( new File ( basedir . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ) ) ; } public void setBasedir ( File basedir ) { this . basedir = basedir ; } public File getBasedir ( ) { return basedir ; } public void setIncludes ( String [ ] includes ) { if ( includes == null ) { this . includes = null ; } else { this . includes = new String [ includes . length ] ; for ( int i = 0 ; i < includes . length ; i ++ ) { String pattern ; pattern = includes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . includes [ i ] = pattern ; } } } public void setExcludes ( String [ ] excludes ) { if ( excludes == null ) { this . excludes = null ; } else { this . excludes = new String [ excludes . length ] ; for ( int i = 0 ; i < excludes . length ; i ++ ) { String pattern ; pattern = excludes [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . excludes [ i ] = pattern ; } } } public void scan ( ) { if ( basedir == null ) { throw new IllegalStateException ( "No basedir set" ) ; } if ( ! basedir . exists ( ) ) { throw new IllegalStateException ( "basedir does not exist" ) ; } if ( ! basedir . isDirectory ( ) ) { throw new IllegalStateException ( "basedir is not a directory" ) ; } if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } filesIncluded = new Vector ( ) ; filesNotIncluded = new Vector ( ) ; filesExcluded = new Vector ( ) ; dirsIncluded = new Vector ( ) ; dirsNotIncluded = new Vector ( ) ; dirsExcluded = new Vector ( ) ; scandir ( basedir , "" , true ) ; } protected void slowScan ( ) { if ( haveSlowResults ) { return ; } String [ ] excl = new String [ dirsExcluded . size ( ) ] ; dirsExcluded . copyInto ( excl ) ; String [ ] notIncl = new String [ dirsNotIncluded . size ( ) ] ; dirsNotIncluded . copyInto ( notIncl ) ; for ( int i = 0 ; i < excl . length ; i ++ ) { scandir ( new File ( basedir , excl [ i ] ) , excl [ i ] + File . separator , false ) ; } for ( int i = 0 ; i < notIncl . length ; i ++ ) { if ( ! couldHoldIncluded ( notIncl [ i ] ) ) { scandir ( new File ( basedir , notIncl [ i ] ) , notIncl [ i ] + File . separator , false ) ; } } haveSlowResults = true ; } protected void scandir ( File dir , String vpath , boolean fast ) { String [ ] newfiles = dir . list ( ) ; if ( newfiles == null ) { throw new BuildException ( "IO error scanning directory " + dir . getAbsolutePath ( ) ) ; } for ( int i = 0 ; i < newfiles . length ; i ++ ) { String name = vpath + newfiles [ i ] ; File file = new File ( dir , newfiles [ i ] ) ; if ( file . isDirectory ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { dirsIncluded . addElement ( name ) ; if ( fast ) { scandir ( file , name + File . separator , fast ) ; } } else { dirsExcluded . addElement ( name ) ; } } else { dirsNotIncluded . addElement ( name ) ; if ( fast && couldHoldIncluded ( name ) ) { scandir ( file , name + File . separator , fast ) ; } } if ( ! fast ) { scandir ( file , name + File . separator , fast ) ; } } else if ( file . isFile ( ) ) { if ( isIncluded ( name ) ) { if ( ! isExcluded ( name ) ) { filesIncluded . addElement ( name ) ; } else { filesExcluded . addElement ( name ) ; } } else { filesNotIncluded . addElement ( name ) ; } } } } protected boolean isIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPath ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean couldHoldIncluded ( String name ) { for ( int i = 0 ; i < includes . length ; i ++ ) { if ( matchPatternStart ( includes [ i ] , name ) ) { return true ; } } return false ; } protected boolean isExcluded ( String name ) { for ( int i = 0 ; i < excludes . length ; i ++ ) { if ( matchPath ( excludes [ i ] , name ) ) { return true ; } } return false ; } public String [ ] getIncludedFiles ( ) { int count = filesIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesIncluded . elementAt ( i ) ; } return files ; } public String [ ] getNotIncludedFiles ( ) { slowScan ( ) ; int count = filesNotIncluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesNotIncluded . elementAt ( i ) ; } return files ; } public String [ ] getExcludedFiles ( ) { slowScan ( ) ; int count = filesExcluded . size ( ) ; String [ ] files = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { files [ i ] = ( String ) filesExcluded . elementAt ( i ) ; } return files ; } public String [ ] getIncludedDirectories ( ) { int count = dirsIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getNotIncludedDirectories ( ) { slowScan ( ) ; int count = dirsNotIncluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsNotIncluded . elementAt ( i ) ; } return directories ; } public String [ ] getExcludedDirectories ( ) { slowScan ( ) ; int count = dirsExcluded . size ( ) ; String [ ] directories = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { directories [ i ] = ( String ) dirsExcluded . elementAt ( i ) ; } return directories ; } public void addDefaultExcludes ( ) { int excludesLength = excludes == null ? 0 : excludes . length ; String [ ] newExcludes ; newExcludes = new String [ excludesLength + DEFAULTEXCLUDES . length ] ; if ( excludesLength > 0 ) { System . arraycopy ( excludes , 0 , newExcludes , 0 , excludesLength ) ; } for ( int i = 0 ; i < DEFAULTEXCLUDES . length ; i ++ ) { newExcludes [ i + excludesLength ] = DEFAULTEXCLUDES [ i ] . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } excludes = newExcludes ; } } 	0	['23', '1', '1', '22', '51', '181', '20', '2', '14', '0.731404959', '1407', '1', '0', '0', '0.290909091', '0', '0', '59.69565217', '35', '5.8696', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors , warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) parseEmacsOutput ( reader ) ; else parseStandardOutput ( reader ) ; } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) continue ; if ( lower . indexOf ( "error" ) != - 1 ) setError ( true ) ; else if ( lower . indexOf ( "warning" ) != - 1 ) setError ( false ) ; else { if ( emacsMode ) setError ( true ) ; } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) errorFlag = true ; } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '21', '44', '1', '2', '5', '0.805194805', '147', '1', '1', '0', '0.261904762', '0', '0', '10.66666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; import java . text . * ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; project . setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; project . setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; project . setProperty ( "TODAY" , today . format ( d ) ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( project , d , location ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } public class CustomFormat { private String propertyName ; private String pattern ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { if ( unit . equalsIgnoreCase ( "millisecond" ) ) { field = Calendar . MILLISECOND ; } else if ( unit . equalsIgnoreCase ( "second" ) ) { field = Calendar . SECOND ; } else if ( unit . equalsIgnoreCase ( "minute" ) ) { field = Calendar . MINUTE ; } else if ( unit . equalsIgnoreCase ( "hour" ) ) { field = Calendar . HOUR_OF_DAY ; } else if ( unit . equalsIgnoreCase ( "day" ) ) { field = Calendar . DATE ; } else if ( unit . equalsIgnoreCase ( "week" ) ) { field = Calendar . WEEK_OF_YEAR ; } else if ( unit . equalsIgnoreCase ( "month" ) ) { field = Calendar . MONTH ; } else if ( unit . equalsIgnoreCase ( "year" ) ) { field = Calendar . YEAR ; } else { throw new BuildException ( unit + " is not a unit supported by the tstamp task" ) ; } } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf = new SimpleDateFormat ( pattern ) ; if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } project . setProperty ( propertyName , sdf . format ( date ) ) ; } } } 	0	['3', '3', '0', '5', '17', '0', '1', '5', '3', '0', '91', '1', '0', '0.948717949', '1', '0', '0', '29', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '2', '5', '6', '1', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class CompilerAdapterFactory { private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { return new Javac12 ( ) ; } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) ) { try { Class . forName ( "com.sun.tools.javac.Main" ) ; } catch ( ClassNotFoundException cnfe ) { task . log ( "Modern compiler is not available - using " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } return new Javac13 ( ) ; } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } return resolveClassName ( compilerType ) ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { try { Class c = Class . forName ( className ) ; Object o = c . newInstance ( ) ; return ( CompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	0	['3', '1', '0', '8', '16', '3', '1', '7', '1', '2', '125', '0', '0', '0', '0.444444444', '0', '0', '40.66666667', '1', '0.6667', '0']
package org . apache . tools . ant ; interface Constants { } 	0	['0', '1', '0', '0', '0', '0', '0', '0', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import java . io . * ; import java . util . Vector ; import java . util . zip . * ; public class War extends Jar { private File deploymentDescriptor ; private boolean descriptorAdded ; public War ( ) { super ( ) ; archiveType = "war" ; emptyBehavior = "create" ; } public void setWarfile ( File warFile ) { super . setZipfile ( warFile ) ; } public void setWebxml ( File descr ) { deploymentDescriptor = descr ; if ( ! deploymentDescriptor . exists ( ) ) throw new BuildException ( "Deployment descriptor: " + deploymentDescriptor + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( deploymentDescriptor . getParent ( ) ) ) ; fs . setIncludes ( deploymentDescriptor . getName ( ) ) ; fs . setFullpath ( "WEB-INF/web.xml" ) ; super . addFileset ( fs ) ; } public void addLib ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/lib/" ) ; super . addFileset ( fs ) ; } public void addClasses ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/classes/" ) ; super . addFileset ( fs ) ; } public void addWebinf ( ZipFileSet fs ) { fs . setPrefix ( "WEB-INF/" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( deploymentDescriptor == null ) { throw new BuildException ( "webxml attribute is required" , location ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "WEB-INF/web.xml" ) ) { if ( deploymentDescriptor == null || ! deploymentDescriptor . equals ( file ) || descriptorAdded ) { log ( "Warning: selected " + archiveType + " files include a WEB-INF/web.xml which will be ignored " + "(please use webxml attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; descriptorAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { descriptorAdded = false ; super . cleanUp ( ) ; } } 	0	['9', '6', '0', '7', '33', '28', '0', '7', '6', '0.8125', '163', '1', '0', '0.950617284', '0.4', '4', '6', '16.88888889', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . * ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { FileWriter out = null ; try { out = new FileWriter ( file . getAbsolutePath ( ) , append ) ; out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += ProjectHelper . replaceProperties ( project , msg , project . getProperties ( ) ) ; } public void setLevel ( EchoLevel echoLevel ) { String option = echoLevel . getValue ( ) ; if ( option . equals ( "error" ) ) { logLevel = Project . MSG_ERR ; } else if ( option . equals ( "warning" ) ) { logLevel = Project . MSG_WARN ; } else if ( option . equals ( "info" ) ) { logLevel = Project . MSG_INFO ; } else if ( option . equals ( "verbose" ) ) { logLevel = Project . MSG_VERBOSE ; } else { logLevel = Project . MSG_DEBUG ; } } public static class EchoLevel extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "error" , "warning" , "info" , "verbose" , "debug" } ; } } } 	0	['7', '3', '0', '7', '22', '0', '0', '7', '7', '0.625', '147', '1', '0', '0.860465116', '0.342857143', '1', '1', '19.42857143', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; public class Available extends Task { private String property ; private String classname ; private File file ; private String resource ; private Path classpath ; private AntClassLoader loader ; private String value = "true" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public void setClassname ( String classname ) { if ( ! "" . equals ( classname ) ) { this . classname = classname ; } } public void setFile ( File file ) { this . file = file ; } public void setResource ( String resource ) { this . resource = resource ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute is required" , location ) ; } if ( classname == null && file == null && resource == null ) { throw new BuildException ( "At least one of (classname|file|resource) is required" , location ) ; } if ( classpath != null ) { this . loader = new AntClassLoader ( project , classpath , false ) ; } if ( ( classname != null ) && ! checkClass ( classname ) ) { log ( "Unable to load class " + classname + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } if ( ( file != null ) && ! checkFile ( file ) ) { log ( "Unable to find file " + file + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } if ( ( resource != null ) && ! checkResource ( resource ) ) { log ( "Unable to load resource " + resource + " to set property " + property , Project . MSG_VERBOSE ) ; return ; } this . project . setProperty ( property , value ) ; } private boolean checkFile ( File file ) { return file . exists ( ) ; } private boolean checkResource ( String resource ) { if ( loader != null ) { return ( loader . getResourceAsStream ( resource ) != null ) ; } else { ClassLoader cL = this . getClass ( ) . getClassLoader ( ) ; if ( cL != null ) { return ( cL . getResourceAsStream ( resource ) != null ) ; } else { return ( ClassLoader . getSystemResourceAsStream ( resource ) != null ) ; } } } private boolean checkClass ( String classname ) { try { if ( loader != null ) { loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { l . loadClass ( classname ) ; } else { Class . forName ( classname ) ; } } return true ; } catch ( ClassNotFoundException e ) { return false ; } catch ( NoClassDefFoundError e ) { return false ; } } } 	0	['13', '3', '0', '7', '35', '52', '0', '7', '10', '0.869047619', '273', '1', '2', '0.755102041', '0.353846154', '1', '1', '19.46153846', '6', '1.6923', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; public class Transform extends ExecuteOn { protected Commandline . Marker targetFilePos = null ; protected Mapper mapperElement = null ; protected FileNameMapper mapper = null ; protected File destDir = null ; protected boolean srcIsFirst = true ; public void setDest ( File destDir ) { this . destDir = destDir ; } public Commandline . Marker createTargetfile ( ) { if ( targetFilePos != null ) { throw new BuildException ( taskType + " doesn\'t support multiple targetfile elements." , location ) ; } targetFilePos = cmdl . createMarker ( ) ; srcIsFirst = ( srcFilePos != null ) ; return targetFilePos ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } protected void checkConfiguration ( ) { super . checkConfiguration ( ) ; if ( mapperElement == null ) { throw new BuildException ( "no mapper specified" , location ) ; } if ( destDir == null ) { throw new BuildException ( "no dest attribute specified" , location ) ; } mapper = mapperElement . getImplementation ( ) ; } protected String [ ] getFiles ( File baseDir , DirectoryScanner ds ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedFiles ( ) , baseDir , destDir , mapper ) ; } protected String [ ] getDirs ( File baseDir , DirectoryScanner ds ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; return sfs . restrict ( ds . getIncludedDirectories ( ) , baseDir , destDir , mapper ) ; } protected String [ ] getCommandline ( String [ ] srcFiles , File baseDir ) { if ( targetFilePos == null ) { return super . getCommandline ( srcFiles , baseDir ) ; } Vector targets = new Vector ( ) ; Hashtable addedFiles = new Hashtable ( ) ; for ( int i = 0 ; i < srcFiles . length ; i ++ ) { String [ ] subTargets = mapper . mapFileName ( srcFiles [ i ] ) ; if ( subTargets != null ) { for ( int j = 0 ; j < subTargets . length ; j ++ ) { String name = ( new File ( destDir , subTargets [ j ] ) ) . getAbsolutePath ( ) ; if ( ! addedFiles . contains ( name ) ) { targets . addElement ( name ) ; addedFiles . put ( name , name ) ; } } } } String [ ] targetFiles = new String [ targets . size ( ) ] ; targets . copyInto ( targetFiles ) ; String [ ] orig = cmdl . getCommandline ( ) ; String [ ] result = new String [ orig . length + srcFiles . length + targetFiles . length ] ; int srcIndex = orig . length ; if ( srcFilePos != null ) { srcIndex = srcFilePos . getPosition ( ) ; } int targetIndex = targetFilePos . getPosition ( ) ; if ( srcIndex < targetIndex || ( srcIndex == targetIndex && srcIsFirst ) ) { System . arraycopy ( orig , 0 , result , 0 , srcIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length , targetIndex - srcIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex + srcFiles . length , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + srcFiles . length + targetFiles . length , orig . length - targetIndex ) ; } else { System . arraycopy ( orig , 0 , result , 0 , targetIndex ) ; System . arraycopy ( targetFiles , 0 , result , targetIndex , targetFiles . length ) ; System . arraycopy ( orig , targetIndex , result , targetIndex + targetFiles . length , srcIndex - targetIndex ) ; System . arraycopy ( orig , srcIndex , result , srcIndex + srcFiles . length + targetFiles . length , orig . length - srcIndex ) ; srcIndex += targetFiles . length ; } for ( int i = 0 ; i < srcFiles . length ; i ++ ) { result [ srcIndex + i ] = ( new File ( baseDir , srcFiles [ i ] ) ) . getAbsolutePath ( ) ; } return result ; } protected String [ ] getCommandline ( String srcFile , File baseDir ) { return getCommandline ( new String [ ] { srcFile } , baseDir ) ; } } 	0	['9', '5', '0', '12', '36', '0', '0', '12', '4', '0.525', '375', '1', '3', '0.930434783', '0.4', '2', '4', '40.11111111', '11', '2.4444', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import java . io . File ; public class Rename extends Task { private File src ; private File dest ; private boolean replace = true ; public void setSrc ( String src ) { this . src = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void setReplace ( String replace ) { this . replace = project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , location ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , location ) ; } if ( replace && dest . exists ( ) ) { if ( ! dest . delete ( ) ) { throw new BuildException ( "Unable to remove existing file " + dest ) ; } } if ( ! src . renameTo ( dest ) ) { throw new BuildException ( "Unable to rename " + src + " to " + dest ) ; } } } 	0	['5', '3', '0', '4', '18', '0', '0', '4', '5', '0.666666667', '107', '1', '0', '0.902439024', '0.8', '1', '1', '19.8', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { String systemDefault = System . getProperty ( "ant.regexp.matcherimpl" ) ; if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { } try { return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { } throw new BuildException ( "No supported regular expression matcher found" ) ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { try { Class implClass = Class . forName ( className ) ; return ( RegexpMatcher ) implClass . newInstance ( ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['3', '1', '0', '3', '9', '3', '1', '2', '2', '2', '43', '0', '0', '0', '0.666666667', '0', '0', '13.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class Ant extends Task { private File dir = null ; private String antFile = null ; private String target = null ; private String output = null ; Vector properties = new Vector ( ) ; Project p1 ; public void init ( ) { p1 = new Project ( ) ; p1 . setJavaVersionProperty ( ) ; p1 . addTaskDefinition ( "property" , ( Class ) project . getTaskDefinitions ( ) . get ( "property" ) ) ; } private void reinit ( ) { init ( ) ; for ( int i = 0 ; i < properties . size ( ) ; i ++ ) { Property p = ( Property ) properties . elementAt ( i ) ; Property newP = ( Property ) p1 . createTask ( "property" ) ; newP . setName ( p . getName ( ) ) ; if ( p . getValue ( ) != null ) { newP . setValue ( p . getValue ( ) ) ; } if ( p . getFile ( ) != null ) { newP . setFile ( p . getFile ( ) ) ; } if ( p . getResource ( ) != null ) { newP . setResource ( p . getResource ( ) ) ; } properties . setElementAt ( newP , i ) ; } } private void initializeProject ( ) { Vector listeners = project . getBuildListeners ( ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { p1 . addBuildListener ( ( BuildListener ) listeners . elementAt ( i ) ) ; } if ( output != null ) { try { PrintStream out = new PrintStream ( new FileOutputStream ( output ) ) ; DefaultLogger logger = new DefaultLogger ( ) ; logger . setMessageOutputLevel ( Project . MSG_INFO ) ; logger . setOutputPrintStream ( out ) ; logger . setErrorPrintStream ( out ) ; p1 . addBuildListener ( logger ) ; } catch ( IOException ex ) { log ( "Ant: Can't set output to " + output ) ; } } Hashtable taskdefs = project . getTaskDefinitions ( ) ; Enumeration et = taskdefs . keys ( ) ; while ( et . hasMoreElements ( ) ) { String taskName = ( String ) et . nextElement ( ) ; Class taskClass = ( Class ) taskdefs . get ( taskName ) ; p1 . addTaskDefinition ( taskName , taskClass ) ; } Hashtable typedefs = project . getDataTypeDefinitions ( ) ; Enumeration e = typedefs . keys ( ) ; while ( e . hasMoreElements ( ) ) { String typeName = ( String ) e . nextElement ( ) ; Class typeClass = ( Class ) typedefs . get ( typeName ) ; p1 . addDataTypeDefinition ( typeName , typeClass ) ; } Hashtable prop1 = project . getProperties ( ) ; e = prop1 . keys ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; String value = ( String ) prop1 . get ( arg ) ; p1 . setProperty ( arg , value ) ; } } public void execute ( ) throws BuildException { try { if ( p1 == null ) { reinit ( ) ; } if ( dir == null ) dir = project . getBaseDir ( ) ; initializeProject ( ) ; p1 . setBaseDir ( dir ) ; p1 . setUserProperty ( "basedir" , dir . getAbsolutePath ( ) ) ; Enumeration e = properties . elements ( ) ; while ( e . hasMoreElements ( ) ) { Property p = ( Property ) e . nextElement ( ) ; p . execute ( ) ; } if ( antFile == null ) antFile = "build.xml" ; File file = new File ( antFile ) ; if ( ! file . isAbsolute ( ) ) { antFile = ( new File ( dir , antFile ) ) . getAbsolutePath ( ) ; file = ( new File ( antFile ) ) ; if ( ! file . isFile ( ) ) { throw new BuildException ( "Build file " + file + " not found." ) ; } } p1 . setUserProperty ( "ant.file" , antFile ) ; ProjectHelper . configureProject ( p1 , new File ( antFile ) ) ; if ( target == null ) { target = p1 . getDefaultTarget ( ) ; } if ( p1 . getBaseDir ( ) . equals ( project . getBaseDir ( ) ) && p1 . getProperty ( "ant.file" ) . equals ( project . getProperty ( "ant.file" ) ) && target . equals ( this . getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "ant task calling its own parent target" ) ; } p1 . executeTarget ( target ) ; } finally { p1 = null ; } } public void setDir ( File d ) { this . dir = d ; } public void setAntfile ( String s ) { this . antFile = s ; } public void setTarget ( String s ) { this . target = s ; } public void setOutput ( String s ) { this . output = s ; } public Property createProperty ( ) { if ( p1 == null ) { reinit ( ) ; } Property p = ( Property ) p1 . createTask ( "property" ) ; p . setUserProperty ( true ) ; properties . addElement ( p ) ; return p ; } } 	0	['10', '3', '0', '9', '70', '1', '1', '8', '8', '0.703703704', '440', '0.666666667', '1', '0.804347826', '0.466666667', '1', '1', '42.4', '6', '1.9', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . PathTokenizer ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Stack ; import java . util . Vector ; import java . text . CharacterIterator ; import java . text . StringCharacterIterator ; public class Path extends DataType implements Cloneable { private Vector elements ; private Project project ; public static Path systemClasspath = new Path ( null , System . getProperty ( "java.class.path" ) ) ; public class PathElement { private String [ ] parts ; public void setLocation ( File loc ) { try { parts = new String [ ] { translateFile ( loc . getCanonicalPath ( ) ) } ; } catch ( IOException e ) { if ( project != null ) { project . log ( e . getMessage ( ) , Project . MSG_WARN ) ; } parts = new String [ ] { translateFile ( loc . getAbsolutePath ( ) ) } ; } } public void setPath ( String path ) { parts = Path . translatePath ( project , path ) ; } public String [ ] getParts ( ) { return parts ; } } public Path ( Project p , String path ) { this ( p ) ; createPathElement ( ) . setPath ( path ) ; } public Path ( Project project ) { this . project = project ; elements = new Vector ( ) ; } public void setLocation ( File location ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setLocation ( location ) ; } public void setPath ( String path ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createPathElement ( ) . setPath ( path ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } elements . addElement ( r ) ; super . setRefid ( r ) ; } public PathElement createPathElement ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } PathElement pe = new PathElement ( ) ; elements . addElement ( pe ) ; return pe ; } public void addFileset ( FileSet fs ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } elements . addElement ( fs ) ; checked = false ; } public Path createPath ( ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path p = new Path ( project ) ; elements . addElement ( p ) ; checked = false ; return p ; } public void append ( Path other ) { if ( other == null ) return ; String [ ] l = other . list ( ) ; for ( int i = 0 ; i < l . length ; i ++ ) { if ( elements . indexOf ( l [ i ] ) == - 1 ) { elements . addElement ( l [ i ] ) ; } } } public void addExisting ( Path source ) { String [ ] list = source . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File f = null ; if ( project != null ) { f = project . resolveFile ( list [ i ] ) ; } else { f = new File ( list [ i ] ) ; } if ( f . exists ( ) ) { setLocation ( f ) ; } } } public String [ ] list ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , project ) ; } Vector result = new Vector ( 2 * elements . size ( ) ) ; for ( int i = 0 ; i < elements . size ( ) ; i ++ ) { Object o = elements . elementAt ( i ) ; if ( o instanceof Reference ) { Reference r = ( Reference ) o ; o = r . getReferencedObject ( project ) ; if ( ! ( o instanceof Path ) ) { String msg = r . getRefId ( ) + " doesn\'t denote a path" ; throw new BuildException ( msg ) ; } } if ( o instanceof String ) { addUnlessPresent ( result , ( String ) o ) ; } else if ( o instanceof PathElement ) { String [ ] parts = ( ( PathElement ) o ) . getParts ( ) ; if ( parts == null ) { throw new BuildException ( "You must either set location or path on <pathelement>" ) ; } for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof Path ) { String [ ] parts = ( ( Path ) o ) . list ( ) ; for ( int j = 0 ; j < parts . length ; j ++ ) { addUnlessPresent ( result , parts [ j ] ) ; } } else if ( o instanceof FileSet ) { FileSet fs = ( FileSet ) o ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] s = ds . getIncludedFiles ( ) ; File dir = fs . getDir ( project ) ; for ( int j = 0 ; j < s . length ; j ++ ) { String canonicalPath ; File f = new File ( dir , s [ j ] ) ; try { canonicalPath = f . getCanonicalPath ( ) ; } catch ( IOException e ) { canonicalPath = f . getAbsolutePath ( ) ; } addUnlessPresent ( result , translateFile ( canonicalPath ) ) ; } } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { final String [ ] list = list ( ) ; if ( list . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( list [ 0 ] . toString ( ) ) ; for ( int i = 1 ; i < list . length ; i ++ ) { result . append ( File . pathSeparatorChar ) ; result . append ( list [ i ] ) ; } return result . toString ( ) ; } public static String [ ] translatePath ( Project project , String source ) { final Vector result = new Vector ( ) ; if ( source == null ) return new String [ 0 ] ; PathTokenizer tok = new PathTokenizer ( source ) ; StringBuffer element = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { element . setLength ( 0 ) ; element . append ( resolveFile ( project , tok . nextToken ( ) ) ) ; for ( int i = 0 ; i < element . length ( ) ; i ++ ) { translateFileSep ( element , i ) ; } result . addElement ( element . toString ( ) ) ; } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public static String translateFile ( String source ) { if ( source == null ) return "" ; final StringBuffer result = new StringBuffer ( source ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { translateFileSep ( result , i ) ; } return result . toString ( ) ; } protected static boolean translateFileSep ( StringBuffer buffer , int pos ) { if ( buffer . charAt ( pos ) == '/' || buffer . charAt ( pos ) == '\\' ) { buffer . setCharAt ( pos , File . separatorChar ) ; return true ; } return false ; } public int size ( ) { return list ( ) . length ; } public Object clone ( ) { Path p = new Path ( project ) ; p . append ( this ) ; return p ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( checked ) { return ; } Enumeration enum = elements . elements ( ) ; while ( enum . hasMoreElements ( ) ) { Object o = enum . nextElement ( ) ; if ( o instanceof Reference ) { o = ( ( Reference ) o ) . getReferencedObject ( p ) ; } if ( o instanceof DataType ) { if ( stk . contains ( o ) ) { throw circularReference ( ) ; } else { stk . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } checked = true ; } private static String resolveFile ( Project project , String relativeName ) { if ( project != null ) { File f = project . resolveFile ( relativeName ) ; try { return f . getCanonicalPath ( ) ; } catch ( IOException e ) { project . log ( e . getMessage ( ) , Project . MSG_WARN ) ; return f . getAbsolutePath ( ) ; } } return relativeName ; } private static void addUnlessPresent ( Vector v , String s ) { if ( v . indexOf ( s ) == - 1 ) { v . addElement ( s ) ; } } public Path concatSystemClasspath ( ) { return concatSystemClasspath ( "last" ) ; } public Path concatSystemClasspath ( String defValue ) { Path result = new Path ( project ) ; String order = project . getProperty ( "build.sysclasspath" ) ; if ( order == null ) order = defValue ; if ( order . equals ( "only" ) ) { result . addExisting ( Path . systemClasspath ) ; } else if ( order . equals ( "first" ) ) { result . addExisting ( Path . systemClasspath ) ; result . addExisting ( this ) ; } else if ( order . equals ( "ignore" ) ) { result . addExisting ( this ) ; } else { if ( ! order . equals ( "last" ) ) { project . log ( "invalid value for build.sysclasspath: " + order , Project . MSG_WARN ) ; } result . addExisting ( this ) ; result . addExisting ( Path . systemClasspath ) ; } return result ; } } 	0	['24', '3', '0', '27', '80', '182', '20', '8', '18', '0.565217391', '693', '0.666666667', '2', '0.588235294', '0.154150198', '2', '5', '27.75', '13', '2.2917', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; public class ZipScanner extends DirectoryScanner { protected File srcFile ; public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public String [ ] getIncludedFiles ( ) { String [ ] result = new String [ 1 ] ; result [ 0 ] = srcFile . getAbsolutePath ( ) ; return result ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public void init ( ) { if ( includes == null ) { includes = new String [ 1 ] ; includes [ 0 ] = "**" ; } if ( excludes == null ) { excludes = new String [ 0 ] ; } } public boolean match ( String path ) { String vpath = path . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; return isIncluded ( vpath ) && ! isExcluded ( vpath ) ; } } 	0	['6', '2', '0', '3', '11', '13', '2', '1', '6', '0.8', '68', '1', '0', '0.924242424', '0.444444444', '1', '5', '10.16666667', '3', '1.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class SignJar extends Task { protected String jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigfile ; protected String signedjar ; protected boolean verbose ; protected boolean internalsf ; protected boolean sectionsonly ; public void setJar ( final String jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigfile ( final String sigfile ) { this . sigfile = sigfile ; } public void setSignedjar ( final String signedjar ) { this . signedjar = signedjar ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void setInternalsf ( final boolean internalsf ) { this . internalsf = internalsf ; } public void setSectionsonly ( final boolean sectionsonly ) { this . sectionsonly = sectionsonly ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The signjar task is only available on JDK versions 1.2 or greater" ) ; } if ( null == jar ) { throw new BuildException ( "jar attribute must be set" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( isUpToDate ( ) ) return ; final StringBuffer sb = new StringBuffer ( ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setExecutable ( "jarsigner" ) ; if ( null != keystore ) { cmd . createArg ( ) . setValue ( "-keystore" ) ; cmd . createArg ( ) . setValue ( keystore ) ; } if ( null != storepass ) { cmd . createArg ( ) . setValue ( "-storepass" ) ; cmd . createArg ( ) . setValue ( storepass ) ; } if ( null != storetype ) { cmd . createArg ( ) . setValue ( "-storetype" ) ; cmd . createArg ( ) . setValue ( storetype ) ; } if ( null != keypass ) { cmd . createArg ( ) . setValue ( "-keypass" ) ; cmd . createArg ( ) . setValue ( keypass ) ; } if ( null != sigfile ) { cmd . createArg ( ) . setValue ( "-sigfile" ) ; cmd . createArg ( ) . setValue ( sigfile ) ; } if ( null != signedjar ) { cmd . createArg ( ) . setValue ( "-signedjar" ) ; cmd . createArg ( ) . setValue ( signedjar ) ; } if ( verbose ) { cmd . createArg ( ) . setValue ( "-verbose" ) ; } if ( internalsf ) { cmd . createArg ( ) . setValue ( "-internalsf" ) ; } if ( sectionsonly ) { cmd . createArg ( ) . setValue ( "-sectionsonly" ) ; } cmd . createArg ( ) . setValue ( jar ) ; cmd . createArg ( ) . setValue ( alias ) ; log ( "Signing Jar : " + ( new File ( jar ) ) . getAbsolutePath ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } protected boolean isUpToDate ( ) { if ( null != jar && null != signedjar ) { final File jarFile = new File ( jar ) ; final File signedjarFile = new File ( signedjar ) ; if ( ! jarFile . exists ( ) ) return false ; if ( ! signedjarFile . exists ( ) ) return false ; if ( jarFile . equals ( signedjarFile ) ) return false ; if ( signedjarFile . lastModified ( ) > jarFile . lastModified ( ) ) return true ; } return false ; } } 	0	['14', '3', '0', '5', '35', '63', '0', '5', '13', '0.909090909', '307', '1', '0', '0.74', '0.595238095', '2', '3', '20.14285714', '7', '1.3571', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import org . apache . tools . ant . * ; import java . util . Random ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { tmpFile = new File ( "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( Throwable t ) { } } } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '5', '29', '0', '0', '5', '0', '0', '176', '1', '2', '0', '0.6', '0', '0', '85.5', '10', '5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jikes" ) ; if ( deprecation == true ) cmd . createArgument ( ) . setValue ( "-deprecation" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null && ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '23', '1', '1', '8', '2', '2', '204', '0', '0', '0.958333333', '1', '1', '1', '101', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public interface ExecuteStreamHandler { public void setProcessInputStream ( OutputStream os ) throws IOException ; public void setProcessErrorStream ( InputStream is ) throws IOException ; public void setProcessOutputStream ( InputStream is ) throws IOException ; public void start ( ) throws IOException ; public void stop ( ) ; } 	0	['5', '1', '0', '10', '5', '10', '10', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . * ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class JakartaOroMatcher implements RegexpMatcher { protected Perl5Matcher reg = new Perl5Matcher ( ) ; protected Perl5Compiler comp = new Perl5Compiler ( ) ; private Pattern pattern ; public void setPattern ( String pattern ) throws BuildException { try { this . pattern = comp . compile ( pattern ) ; } catch ( MalformedPatternException e ) { throw new BuildException ( e ) ; } } public String getPattern ( ) { return pattern . getPattern ( ) ; } public boolean matches ( String argument ) { return reg . contains ( argument , pattern ) ; } public Vector getGroups ( String argument ) { if ( ! matches ( argument ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = reg . getMatch ( ) ; for ( int i = 0 ; i < mr . groups ( ) ; i ++ ) { v . addElement ( mr . group ( i ) ) ; } return v ; } } 	0	['5', '1', '0', '7', '17', '0', '0', '7', '5', '0.5', '75', '1', '0', '0', '0.8', '0', '0', '13.4', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public abstract class MatchingTask extends Task { protected boolean useDefaultExcludes = true ; protected FileSet fileset = new FileSet ( ) ; public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { Vector tmpExcludes = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; fileset . setDefaultexcludes ( useDefaultExcludes ) ; return fileset . getDirectoryScanner ( project ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } } 	0	['12', '3', '11', '18', '37', '0', '12', '6', '11', '0.454545455', '164', '1', '1', '0.770833333', '0.416666667', '0', '0', '12.5', '6', '1.5833', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . lang . reflect . Method ; import java . io . * ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; PrintStream err = System . err ; PrintStream out = System . out ; try { PrintStream logstr = new PrintStream ( new LogOutputStream ( attributes , Project . MSG_WARN ) ) ; System . setOut ( logstr ) ; System . setErr ( logstr ) ; Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } finally { System . setErr ( err ) ; System . setOut ( out ) ; } } } 	0	['2', '2', '0', '8', '17', '1', '1', '7', '2', '2', '97', '1', '0', '0.958333333', '1', '0', '0', '47', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . OutputStream ; import java . io . InputStream ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { super ( new LogOutputStream ( task , outlevel ) , new LogOutputStream ( task , errlevel ) ) ; } } 	0	['1', '2', '0', '9', '3', '0', '6', '3', '1', '2', '14', '0', '0', '1', '1', '0', '0', '13', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Delete extends MatchingTask { protected File file = null ; protected File dir = null ; protected Vector filesets = new Vector ( ) ; protected boolean usedMatchingTask = false ; protected boolean includeEmpty = false ; private int verbosity = Project . MSG_VERBOSE ; private boolean quiet = false ; public void setFile ( File file ) { this . file = file ; } public void setDir ( File dir ) { this . dir = dir ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public PatternSet . NameEntry createInclude ( ) { usedMatchingTask = true ; return super . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { usedMatchingTask = true ; return super . createExclude ( ) ; } public PatternSet createPatternSet ( ) { usedMatchingTask = true ; return super . createPatternSet ( ) ; } public void setIncludes ( String includes ) { usedMatchingTask = true ; super . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { usedMatchingTask = true ; super . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { usedMatchingTask = true ; super . setDefaultexcludes ( useDefaultExcludes ) ; } public void setIncludesfile ( File includesfile ) { usedMatchingTask = true ; super . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { usedMatchingTask = true ; super . setExcludesfile ( excludesfile ) ; } public void execute ( ) throws BuildException { if ( usedMatchingTask ) { log ( "DEPRECATED - Use of the implicit FileSet is deprecated.  Use a nested fileset element instead." ) ; } if ( file == null && dir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "At least one of the file or dir attributes, or a fileset element, must be set." ) ; } if ( file != null ) { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { log ( "Directory " + file . getAbsolutePath ( ) + " cannot be removed using the file attribute.  Use dir instead." ) ; } else { log ( "Deleting: " + file . getAbsolutePath ( ) ) ; if ( ! file . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + file . getAbsolutePath ( ) ) ; } } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to delete." ) ; } } if ( dir != null && dir . exists ( ) && dir . isDirectory ( ) && ! usedMatchingTask ) { if ( verbosity == Project . MSG_VERBOSE ) { log ( "Deleting directory " + dir . getAbsolutePath ( ) ) ; } removeDir ( dir ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( fs . getDir ( project ) , files , dirs ) ; } if ( usedMatchingTask && dir != null ) { DirectoryScanner ds = super . getDirectoryScanner ( dir ) ; String [ ] files = ds . getIncludedFiles ( ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; removeFiles ( dir , files , dirs ) ; } } protected void removeDir ( File d ) { String [ ] list = d . list ( ) ; if ( list == null ) list = new String [ 0 ] ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( d , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } log ( "Deleting directory " + d . getAbsolutePath ( ) , verbosity ) ; if ( ! d . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } protected void removeFiles ( File d , String [ ] files , String [ ] dirs ) { if ( files . length > 0 ) { log ( "Deleting " + files . length + " files from " + d . getAbsolutePath ( ) ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File f = new File ( d , files [ j ] ) ; log ( "Deleting " + f . getAbsolutePath ( ) , verbosity ) ; if ( ! f . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( dirs . length > 0 && includeEmpty ) { int dirCount = 0 ; for ( int j = 0 ; j < dirs . length ; j ++ ) { File dir = new File ( d , dirs [ j ] ) ; String [ ] dirFiles = dir . list ( ) ; if ( dirFiles == null || dirFiles . length == 0 ) { log ( "Deleting " + dir . getAbsolutePath ( ) , verbosity ) ; if ( ! dir . delete ( ) && ! quiet ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } else { dirCount ++ ; } } } if ( dirCount > 0 ) { log ( "Deleted " + dirCount + " director" + ( dirCount == 1 ? "y" : "ies" ) + " from " + d . getAbsolutePath ( ) ) ; } } } } 	0	['18', '4', '0', '8', '49', '19', '0', '8', '16', '0.773109244', '579', '1', '0', '0.821052632', '0.296296296', '2', '3', '30.77777778', '14', '2.1111', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Properties ; import java . util . zip . * ; import java . sql . * ; public class SQLExec extends Task { private int goodSql = 0 , totalSql = 0 ; private Path classpath ; private AntClassLoader loader ; private Connection conn = null ; private boolean autocommit = false ; private Statement statement = null ; private String driver = null ; private String url = null ; private String userId = null ; private String password = null ; private File srcFile = null ; private String sqlCommand = "" ; private Vector transactions = new Vector ( ) ; private boolean print = false ; private boolean showheaders = true ; private File output = null ; private String rdbms = null ; private String version = null ; private String onError = "abort" ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setSrc ( File srcFile ) { this . srcFile = srcFile ; } public void addText ( String sql ) { this . sqlCommand += sql ; } public Transaction createTransaction ( ) { Transaction t = new Transaction ( ) ; transactions . addElement ( t ) ; return t ; } public void setDriver ( String driver ) { this . driver = driver ; } public void setUrl ( String url ) { this . url = url ; } public void setUserid ( String userId ) { this . userId = userId ; } public void setPassword ( String password ) { this . password = password ; } public void setAutocommit ( boolean autocommit ) { this . autocommit = autocommit ; } public void setPrint ( boolean print ) { this . print = print ; } public void setShowheaders ( boolean showheaders ) { this . showheaders = showheaders ; } public void setOutput ( File output ) { this . output = output ; } public void setRdbms ( String vendor ) { this . rdbms = vendor . toLowerCase ( ) ; } public void setVersion ( String version ) { this . version = version . toLowerCase ( ) ; } public void setOnerror ( OnError action ) { this . onError = action . getValue ( ) ; } public void execute ( ) throws BuildException { sqlCommand = sqlCommand . trim ( ) ; if ( srcFile == null && sqlCommand . length ( ) == 0 ) { if ( transactions . size ( ) == 0 ) { throw new BuildException ( "Source file, transactions or sql statement must be set!" , location ) ; } } else { Transaction t = createTransaction ( ) ; t . setSrc ( srcFile ) ; t . addText ( sqlCommand ) ; } if ( driver == null ) { throw new BuildException ( "Driver attribute must be set!" , location ) ; } if ( userId == null ) { throw new BuildException ( "User Id attribute must be set!" , location ) ; } if ( password == null ) { throw new BuildException ( "Password attribute must be set!" , location ) ; } if ( url == null ) { throw new BuildException ( "Url attribute must be set!" , location ) ; } if ( srcFile != null && ! srcFile . exists ( ) ) { throw new BuildException ( "Source file does not exist!" , location ) ; } Driver driverInstance = null ; try { Class dc ; if ( classpath != null ) { log ( "Loading " + driver + " using AntClassLoader with classpath " + classpath , Project . MSG_VERBOSE ) ; loader = new AntClassLoader ( project , classpath , false ) ; dc = loader . loadClass ( driver ) ; } else { log ( "Loading " + driver + " using system loader." , Project . MSG_VERBOSE ) ; dc = Class . forName ( driver ) ; } driverInstance = ( Driver ) dc . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class Not Found: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Illegal Access: JDBC driver " + driver + " could not be loaded" , location ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Instantiation Exception: JDBC driver " + driver + " could not be loaded" , location ) ; } try { log ( "connecting to " + url , Project . MSG_VERBOSE ) ; Properties info = new Properties ( ) ; info . put ( "user" , userId ) ; info . put ( "password" , password ) ; conn = driverInstance . connect ( url , info ) ; if ( conn == null ) { throw new SQLException ( "No suitable Driver for " + url ) ; } if ( ! isValidRdbms ( conn ) ) return ; conn . setAutoCommit ( autocommit ) ; statement = conn . createStatement ( ) ; PrintStream out = System . out ; try { if ( output != null ) { log ( "Opening PrintStream to output file " + output , Project . MSG_VERBOSE ) ; out = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( output ) ) ) ; } for ( Enumeration e = transactions . elements ( ) ; e . hasMoreElements ( ) ; ) { ( ( Transaction ) e . nextElement ( ) ) . runTransaction ( out ) ; if ( ! autocommit ) { log ( "Commiting transaction" , Project . MSG_VERBOSE ) ; conn . commit ( ) ; } } } finally { if ( out != null && out != System . out ) { out . close ( ) ; } } } catch ( IOException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } catch ( SQLException e ) { if ( ! autocommit && conn != null && onError . equals ( "abort" ) ) { try { conn . rollback ( ) ; } catch ( SQLException ex ) { } } throw new BuildException ( e , location ) ; } finally { try { if ( statement != null ) { statement . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { } } log ( goodSql + " of " + totalSql + " SQL statements executed successfully" ) ; } protected void runStatements ( Reader reader , PrintStream out ) throws SQLException , IOException { String sql = "" ; String line = "" ; BufferedReader in = new BufferedReader ( reader ) ; try { while ( ( line = in . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "//" ) ) continue ; if ( line . trim ( ) . startsWith ( "--" ) ) continue ; sql += " " + line ; sql = sql . trim ( ) ; if ( line . indexOf ( "--" ) >= 0 ) sql += "\n" ; if ( sql . endsWith ( ";" ) ) { log ( "SQL: " + sql , Project . MSG_VERBOSE ) ; execSQL ( sql . substring ( 0 , sql . length ( ) - 1 ) , out ) ; sql = "" ; } } if ( ! sql . equals ( "" ) ) { execSQL ( sql , out ) ; } } catch ( SQLException e ) { throw e ; } } protected boolean isValidRdbms ( Connection conn ) { if ( rdbms == null && version == null ) return true ; try { DatabaseMetaData dmd = conn . getMetaData ( ) ; if ( rdbms != null ) { String theVendor = dmd . getDatabaseProductName ( ) . toLowerCase ( ) ; log ( "RDBMS = " + theVendor , Project . MSG_VERBOSE ) ; if ( theVendor == null || theVendor . indexOf ( rdbms ) < 0 ) { log ( "Not the required RDBMS: " + rdbms , Project . MSG_VERBOSE ) ; return false ; } } if ( version != null ) { String theVersion = dmd . getDatabaseProductVersion ( ) . toLowerCase ( ) ; log ( "Version = " + theVersion , Project . MSG_VERBOSE ) ; if ( theVersion == null || ! ( theVersion . startsWith ( version ) || theVersion . indexOf ( " " + version ) >= 0 ) ) { log ( "Not the required version: \"" + version + "\"" , Project . MSG_VERBOSE ) ; return false ; } } } catch ( SQLException e ) { log ( "Failed to obtain required RDBMS information" , Project . MSG_ERR ) ; return false ; } return true ; } protected void execSQL ( String sql , PrintStream out ) throws SQLException { if ( "" . equals ( sql . trim ( ) ) ) return ; try { totalSql ++ ; if ( ! statement . execute ( sql ) ) { log ( statement . getUpdateCount ( ) + " rows affected" , Project . MSG_VERBOSE ) ; } if ( print ) { printResults ( out ) ; } SQLWarning warning = conn . getWarnings ( ) ; while ( warning != null ) { log ( warning + " sql warning" , Project . MSG_VERBOSE ) ; warning = warning . getNextWarning ( ) ; } conn . clearWarnings ( ) ; goodSql ++ ; } catch ( SQLException e ) { log ( "Failed to execute: " + sql , Project . MSG_ERR ) ; if ( ! onError . equals ( "continue" ) ) throw e ; log ( e . toString ( ) , Project . MSG_ERR ) ; } } protected void printResults ( PrintStream out ) throws java . sql . SQLException { ResultSet rs = null ; do { rs = statement . getResultSet ( ) ; if ( rs != null ) { log ( "Processing new result set." , Project . MSG_VERBOSE ) ; ResultSetMetaData md = rs . getMetaData ( ) ; int columnCount = md . getColumnCount ( ) ; StringBuffer line = new StringBuffer ( ) ; if ( showheaders ) { for ( int col = 1 ; col < columnCount ; col ++ ) { line . append ( md . getColumnName ( col ) ) ; line . append ( "," ) ; } line . append ( md . getColumnName ( columnCount ) ) ; out . println ( line ) ; line . setLength ( 0 ) ; } while ( rs . next ( ) ) { boolean first = true ; for ( int col = 1 ; col <= columnCount ; col ++ ) { String columnValue = rs . getString ( col ) ; if ( columnValue != null ) { columnValue = columnValue . trim ( ) ; } if ( first ) { first = false ; } else { line . append ( "," ) ; } line . append ( columnValue ) ; } out . println ( line ) ; line . setLength ( 0 ) ; } } } while ( statement . getMoreResults ( ) ) ; out . println ( ) ; } public static class OnError extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "continue" , "stop" , "abort" } ; } } public class Transaction { private File tSrcFile = null ; private String tSqlCommand = "" ; public void setSrc ( File src ) { this . tSrcFile = src ; } public void addText ( String sql ) { this . tSqlCommand += sql ; } private void runTransaction ( PrintStream out ) throws IOException , SQLException { if ( tSqlCommand . length ( ) != 0 ) { log ( "Executing commands" , Project . MSG_INFO ) ; runStatements ( new StringReader ( tSqlCommand ) , out ) ; } if ( tSrcFile != null ) { log ( "Executing file: " + tSrcFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; FileReader reader = new FileReader ( tSrcFile ) ; runStatements ( reader , out ) ; reader . close ( ) ; } } } } 	0	['23', '3', '0', '10', '96', '175', '1', '10', '19', '0.886363636', '1034', '1', '2', '0.627118644', '0.191304348', '3', '3', '43.08695652', '7', '1.3043', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . ant . taskdefs . compilers . * ; import java . io . File ; public class Javac extends MatchingTask { private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; private Path src ; private File destDir ; private Path compileClasspath ; private String encoding ; private boolean debug = false ; private boolean optimize = false ; private boolean deprecation = false ; private boolean depend = false ; private boolean verbose = false ; private String target ; private Path bootclasspath ; private Path extdirs ; private boolean includeAntRuntime = true ; private boolean includeJavaRuntime = false ; protected boolean failOnError = true ; protected File [ ] compileList = new File [ 0 ] ; public Path createSrc ( ) { if ( src == null ) { src = new Path ( project ) ; } return src . createPath ( ) ; } public void setSrcdir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcdir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( project ) ; } return compileClasspath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path bootclasspath ) { if ( this . bootclasspath == null ) { this . bootclasspath = bootclasspath ; } else { this . bootclasspath . append ( bootclasspath ) ; } } public Path getBootclasspath ( ) { return bootclasspath ; } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( Path extdirs ) { if ( this . extdirs == null ) { this . extdirs = extdirs ; } else { this . extdirs . append ( extdirs ) ; } } public Path getExtdirs ( ) { return extdirs ; } public Path createExtdirs ( ) { if ( extdirs == null ) { extdirs = new Path ( project ) ; } return extdirs . createPath ( ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setProceed ( boolean proceed ) { failOnError = ! proceed ; } public boolean getFailonerror ( ) { return failOnError ; } public void setDeprecation ( boolean deprecation ) { this . deprecation = deprecation ; } public boolean getDeprecation ( ) { return deprecation ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean getDebug ( ) { return debug ; } public void setOptimize ( boolean optimize ) { this . optimize = optimize ; } public boolean getOptimize ( ) { return optimize ; } public void setDepend ( boolean depend ) { this . depend = depend ; } public boolean getDepend ( ) { return depend ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setTarget ( String target ) { this . target = target ; } public String getTarget ( ) { return target ; } public void setIncludeantruntime ( boolean include ) { includeAntRuntime = include ; } public boolean getIncludeantruntime ( ) { return includeAntRuntime ; } public void setIncludejavaruntime ( boolean include ) { includeJavaRuntime = include ; } public boolean getIncludejavaruntime ( ) { return includeJavaRuntime ; } public void execute ( ) throws BuildException { if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , location ) ; } if ( destDir != null && ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , location ) ; } resetFileLists ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = ( File ) project . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , location ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir != null ? destDir : srcDir , files ) ; } String compiler = project . getProperty ( "build.compiler" ) ; if ( compiler == null ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.3" ) ) { compiler = "modern" ; } else { compiler = "classic" ; } } if ( compileList . length > 0 ) { CompilerAdapter adapter = CompilerAdapterFactory . getCompiler ( compiler , this ) ; log ( "Compiling " + compileList . length + " source file" + ( compileList . length == 1 ? "" : "s" ) + ( destDir != null ? " to " + destDir : "" ) ) ; adapter . setJavac ( this ) ; if ( ! adapter . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , location ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } } protected void resetFileLists ( ) { compileList = new File [ 0 ] ; } protected void scanDir ( File srcDir , File destDir , String files [ ] ) { GlobPatternMapper m = new GlobPatternMapper ( ) ; m . setFrom ( "*.java" ) ; m . setTo ( "*.class" ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; File [ ] newFiles = sfs . restrictAsFiles ( files , srcDir , destDir , m ) ; if ( newFiles . length > 0 ) { File [ ] newCompileList = new File [ compileList . length + newFiles . length ] ; System . arraycopy ( compileList , 0 , newCompileList , 0 , compileList . length ) ; System . arraycopy ( newFiles , 0 , newCompileList , compileList . length , newFiles . length ) ; compileList = newCompileList ; } } public File [ ] getFileList ( ) { return compileList ; } } 	0	['42', '4', '1', '19', '74', '741', '7', '13', '40', '0.948350072', '550', '1', '4', '0.655462185', '0.210884354', '3', '3', '11.69047619', '2', '1.2143', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; import java . util . Enumeration ; import java . util . Vector ; public class RegexpPatternMapper implements FileNameMapper { protected RegexpMatcher reg = null ; protected char [ ] to = null ; protected StringBuffer result = new StringBuffer ( ) ; public RegexpPatternMapper ( ) throws BuildException { reg = ( new RegexpMatcherFactory ( ) ) . newRegexpMatcher ( ) ; } public void setFrom ( String from ) throws BuildException { try { reg . setPattern ( from ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Cannot load regular expression matcher" , e ) ; } } public void setTo ( String to ) { this . to = to . toCharArray ( ) ; } public String [ ] mapFileName ( String sourceFileName ) { if ( reg == null || to == null || ! reg . matches ( sourceFileName ) ) { return null ; } return new String [ ] { replaceReferences ( sourceFileName ) } ; } protected String replaceReferences ( String source ) { Vector v = reg . getGroups ( source ) ; result . setLength ( 0 ) ; for ( int i = 0 ; i < to . length ; i ++ ) { if ( to [ i ] == '\\' ) { if ( ++ i < to . length ) { int value = Character . digit ( to [ i ] , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( to [ i ] ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( to [ i ] ) ; } } return result . toString ( ) ; } } 	0	['5', '1', '0', '4', '20', '0', '0', '4', '4', '0.333333333', '144', '1', '1', '0', '0.9', '0', '0', '27.2', '5', '2.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class Exit extends Task { private String message ; public void setMessage ( String value ) { this . message = value ; } public void execute ( ) throws BuildException { if ( message != null && message . length ( ) > 0 ) { throw new BuildException ( message ) ; } else { throw new BuildException ( "No message" ) ; } } } 	0	['3', '3', '0', '2', '6', '1', '0', '2', '3', '0.5', '29', '1', '0', '0.948717949', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant ; import java . util . EventListener ; public interface BuildListener extends EventListener { public void buildStarted ( BuildEvent event ) ; public void buildFinished ( BuildEvent event ) ; public void targetStarted ( BuildEvent event ) ; public void targetFinished ( BuildEvent event ) ; public void taskStarted ( BuildEvent event ) ; public void taskFinished ( BuildEvent event ) ; public void messageLogged ( BuildEvent event ) ; } 	0	['7', '1', '0', '6', '7', '21', '5', '1', '7', '2', '7', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { public void setFrom ( String from ) ; public void setTo ( String to ) ; public String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '15', '3', '3', '15', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . * ; import java . util . Properties ; import java . util . Stack ; public class Mapper extends DataType { protected Project p ; protected MapperType type = null ; public Mapper ( Project p ) { this . p = p ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } protected String classname = null ; public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } protected Path classpath = null ; public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( p ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } protected String from = null ; public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } protected String to = null ; public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null ) { throw new BuildException ( "one of the attributes type or classname is required" ) ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { if ( type != null ) { classname = type . getImplementation ( ) ; } Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = new AntClassLoader ( p , classpath ) ; c = al . loadClass ( classname ) ; } FileNameMapper m = ( FileNameMapper ) c . newInstance ( ) ; m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } finally { if ( type != null ) { classname = null ; } } } protected Mapper getRef ( ) { if ( ! checked ) { Stack stk = new Stack ( ) ; stk . push ( this ) ; dieOnCircularReference ( stk , p ) ; } Object o = ref . getReferencedObject ( p ) ; if ( ! ( o instanceof Mapper ) ) { String msg = ref . getRefId ( ) + " doesn\'t denote a mapper" ; throw new BuildException ( msg ) ; } else { return ( Mapper ) o ; } } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['11', '3', '0', '11', '37', '11', '3', '8', '10', '0.683333333', '285', '1', '3', '0.75', '0.287878788', '1', '1', '24.36363636', '3', '1.9091', '0']
package org . apache . tools . ant ; public class Location { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { this . fileName = fileName ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } } 	0	['5', '1', '0', '51', '10', '8', '51', '0', '3', '0.3125', '69', '0.75', '1', '0', '0.583333333', '0', '0', '12', '3', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GUnzip extends Task { private File source ; private File dest ; public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void execute ( ) throws BuildException { if ( source == null ) { throw new BuildException ( "No source for gunzip specified" , location ) ; } if ( ! source . exists ( ) ) { throw new BuildException ( "source doesn't exist" , location ) ; } if ( source . isDirectory ( ) ) { throw new BuildException ( "Cannot expand a directory" , location ) ; } if ( dest == null ) { dest = new File ( source . getParent ( ) ) ; } if ( dest . isDirectory ( ) ) { String sourceName = source . getName ( ) ; int len = sourceName . length ( ) ; if ( len > 3 && ".gz" . equalsIgnoreCase ( sourceName . substring ( len - 3 ) ) ) { dest = new File ( dest , sourceName . substring ( 0 , len - 3 ) ) ; } else { dest = new File ( dest , sourceName ) ; } } if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; try { out = new FileOutputStream ( dest ) ; zIn = new GZIPInputStream ( new FileInputStream ( source ) ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException ioex ) { } } if ( zIn != null ) { try { zIn . close ( ) ; } catch ( IOException ioex ) { } } } } } } 	0	['4', '3', '0', '4', '32', '2', '0', '4', '4', '0.666666667', '215', '1', '0', '0.925', '0.75', '1', '1', '52.25', '1', '0.75', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '7', '15', '13', '5', '3', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; class JavacOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private boolean errorFlag = false ; JavacOutputStream ( Task task ) { this . task = task ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; if ( s . indexOf ( "error" ) > - 1 ) { errorFlag = true ; } task . log ( s ) ; line = new StringBuffer ( ) ; } boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['4', '2', '0', '1', '11', '0', '0', '1', '1', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; public class Reference { private String refid ; public Reference ( ) { super ( ) ; } public Reference ( String id ) { this ( ) ; setRefId ( id ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public Object getReferencedObject ( Project project ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project . getReferences ( ) . get ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } } 	0	['5', '1', '0', '16', '12', '4', '14', '2', '5', '0.25', '55', '1', '0', '0', '0.533333333', '0', '0', '9.8', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; import org . apache . tools . ant . util . * ; import org . apache . tools . tar . * ; import org . apache . tools . ant . types . * ; public class Tar extends MatchingTask { static public final String WARN = "warn" ; static public final String FAIL = "fail" ; static public final String TRUNCATE = "truncate" ; static public final String GNU = "gnu" ; static public final String OMIT = "omit" ; private String [ ] validModes = new String [ ] { WARN , FAIL , TRUNCATE , GNU , OMIT } ; File tarFile ; File baseDir ; String longFileMode = WARN ; Vector filesets = new Vector ( ) ; Vector fileSetFiles = new Vector ( ) ; private boolean longWarningGiven = false ; public TarFileSet createTarFileSet ( ) { TarFileSet fileset = new TarFileSet ( ) ; filesets . addElement ( fileset ) ; return fileset ; } public void setTarfile ( File tarFile ) { this . tarFile = tarFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setLongfile ( String mode ) { for ( int i = 0 ; i < validModes . length ; ++ i ) { if ( mode . equalsIgnoreCase ( validModes [ i ] ) ) { this . longFileMode = mode ; return ; } } throw new BuildException ( "The longfile value " + mode + " is not a valid value" ) ; } public void execute ( ) throws BuildException { if ( tarFile == null ) { throw new BuildException ( "tarfile attribute must be set!" , location ) ; } if ( tarFile . exists ( ) && tarFile . isDirectory ( ) ) { throw new BuildException ( "tarfile is a directory!" , location ) ; } if ( tarFile . exists ( ) && ! tarFile . canWrite ( ) ) { throw new BuildException ( "Can not write to the specified tarfile!" , location ) ; } if ( baseDir != null ) { if ( ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , location ) ; } TarFileSet mainFileSet = new TarFileSet ( fileset ) ; mainFileSet . setDir ( baseDir ) ; mainFileSet . setDefaultexcludes ( useDefaultExcludes ) ; filesets . addElement ( mainFileSet ) ; } if ( filesets . size ( ) == 0 ) { throw new BuildException ( "You must supply either a basdir attribute or some nested filesets." , location ) ; } boolean upToDate = true ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; if ( ! archiveIsUpToDate ( files ) ) { upToDate = false ; } for ( int i = 0 ; i < files . length ; ++ i ) { if ( tarFile . equals ( new File ( fs . getDir ( project ) , files [ i ] ) ) ) { throw new BuildException ( "A tar file cannot include itself" , location ) ; } } } if ( upToDate ) { log ( "Nothing to do: " + tarFile . getAbsolutePath ( ) + " is up to date." , Project . MSG_INFO ) ; return ; } log ( "Building tar: " + tarFile . getAbsolutePath ( ) , Project . MSG_INFO ) ; TarOutputStream tOut = null ; try { tOut = new TarOutputStream ( new FileOutputStream ( tarFile ) ) ; tOut . setDebug ( true ) ; if ( longFileMode . equalsIgnoreCase ( TRUNCATE ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_TRUNCATE ) ; } else if ( longFileMode . equalsIgnoreCase ( FAIL ) || longFileMode . equalsIgnoreCase ( OMIT ) ) { tOut . setLongFileMode ( TarOutputStream . LONGFILE_ERROR ) ; } else { tOut . setLongFileMode ( TarOutputStream . LONGFILE_GNU ) ; } longWarningGiven = false ; for ( Enumeration e = filesets . elements ( ) ; e . hasMoreElements ( ) ; ) { TarFileSet fs = ( TarFileSet ) e . nextElement ( ) ; String [ ] files = fs . getFiles ( project ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( baseDir , files [ i ] ) ; String name = files [ i ] . replace ( File . separatorChar , '/' ) ; tarFile ( f , tOut , name , fs ) ; } } } catch ( IOException ioe ) { String msg = "Problem creating TAR: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( tOut != null ) { try { tOut . close ( ) ; } catch ( IOException e ) { } } } } protected void tarFile ( File file , TarOutputStream tOut , String vPath , TarFileSet tarFileSet ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { if ( vPath . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode . equalsIgnoreCase ( OMIT ) ) { log ( "Omitting: " + vPath , Project . MSG_INFO ) ; return ; } else if ( longFileMode . equalsIgnoreCase ( WARN ) ) { log ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + " characters." , Project . MSG_WARN ) ; if ( ! longWarningGiven ) { log ( "Resulting tar file can only be processed successfully" + " by GNU compatible tar commands" , Project . MSG_WARN ) ; longWarningGiven = true ; } } else if ( longFileMode . equalsIgnoreCase ( FAIL ) ) { throw new BuildException ( "Entry: " + vPath + " longer than " + TarConstants . NAMELEN + "characters." , location ) ; } } TarEntry te = new TarEntry ( vPath ) ; te . setSize ( file . length ( ) ) ; te . setModTime ( file . lastModified ( ) ) ; if ( ! file . isDirectory ( ) ) { te . setMode ( tarFileSet . getMode ( ) ) ; } te . setUserName ( tarFileSet . getUserName ( ) ) ; te . setGroupName ( tarFileSet . getGroup ( ) ) ; tOut . putNextEntry ( te ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { tOut . write ( buffer , 0 , count ) ; count = fIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; tOut . closeEntry ( ) ; } finally { fIn . close ( ) ; } } protected boolean archiveIsUpToDate ( String [ ] files ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( tarFile . getAbsolutePath ( ) ) ; return sfs . restrict ( files , baseDir , null , mm ) . length == 0 ; } static public class TarFileSet extends FileSet { private String [ ] files = null ; private int mode = 0100644 ; private String userName = "" ; private String groupName = "" ; public TarFileSet ( FileSet fileset ) { super ( fileset ) ; } public TarFileSet ( ) { super ( ) ; } public String [ ] getFiles ( Project p ) { if ( files == null ) { DirectoryScanner ds = getDirectoryScanner ( p ) ; files = ds . getIncludedFiles ( ) ; } return files ; } public void setMode ( String octalString ) { this . mode = 0100000 | Integer . parseInt ( octalString , 8 ) ; } public int getMode ( ) { return mode ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getUserName ( ) { return userName ; } public void setGroup ( String groupName ) { this . groupName = groupName ; } public String getGroup ( ) { return groupName ; } } } 	0	['8', '4', '0', '12', '65', '2', '0', '12', '6', '0.916666667', '583', '0.166666667', '0', '0.917647059', '0.333333333', '3', '3', '70.375', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . * ; public class XSLTProcess extends MatchingTask { private File destDir = null ; private File baseDir = null ; private File xslFile = null ; private String targetExtension = ".html" ; private Vector params = new Vector ( ) ; private File inFile = null ; private File outFile = null ; private XSLTLiaison liaison ; public XSLTProcess ( ) { } public void execute ( ) throws BuildException { DirectoryScanner scanner ; String [ ] list ; String [ ] dirs ; if ( baseDir == null ) { baseDir = project . resolveFile ( "." ) ; } if ( destDir == null ) { String msg = "destdir attributes must be set!" ; throw new BuildException ( msg ) ; } scanner = getDirectoryScanner ( baseDir ) ; log ( "Transforming into " + destDir , Project . MSG_INFO ) ; if ( liaison == null ) { try { setProcessor ( "trax" ) ; } catch ( Throwable e1 ) { try { setProcessor ( "xslp" ) ; } catch ( Throwable e2 ) { try { setProcessor ( "xalan" ) ; } catch ( Throwable e3 ) { throw new BuildException ( e1 ) ; } } } } log ( "Using " + liaison . getClass ( ) . toString ( ) , Project . MSG_VERBOSE ) ; long styleSheetLastModified = 0 ; if ( xslFile != null ) { try { File file = new File ( baseDir , xslFile . toString ( ) ) ; styleSheetLastModified = file . lastModified ( ) ; log ( "Loading stylesheet " + file , Project . MSG_INFO ) ; liaison . setStylesheet ( file . toString ( ) ) ; for ( Enumeration e = params . elements ( ) ; e . hasMoreElements ( ) ; ) { Param p = ( Param ) e . nextElement ( ) ; liaison . addParam ( p . getName ( ) , p . getExpression ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to read stylesheet " + xslFile , Project . MSG_INFO ) ; throw new BuildException ( ex ) ; } } if ( inFile != null && outFile != null ) { process ( inFile , outFile , styleSheetLastModified ) ; return ; } list = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) { process ( baseDir , list [ i ] , destDir , styleSheetLastModified ) ; } dirs = scanner . getIncludedDirectories ( ) ; for ( int j = 0 ; j < dirs . length ; ++ j ) { list = new File ( baseDir , dirs [ j ] ) . list ( ) ; for ( int i = 0 ; i < list . length ; ++ i ) process ( baseDir , list [ i ] , destDir , styleSheetLastModified ) ; } } public void setBasedir ( File dir ) { baseDir = dir ; } public void setDestdir ( File dir ) { destDir = dir ; } public void setExtension ( String name ) { targetExtension = name ; } public void setStyle ( String xslFile ) { this . xslFile = new File ( xslFile ) ; } public void setProcessor ( String processor ) throws Exception { if ( processor . equals ( "trax" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.TraXLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( processor . equals ( "xslp" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.XslpLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else if ( processor . equals ( "xalan" ) ) { final Class clazz = Class . forName ( "org.apache.tools.ant.taskdefs.optional.XalanLiaison" ) ; liaison = ( XSLTLiaison ) clazz . newInstance ( ) ; } else { liaison = ( XSLTLiaison ) Class . forName ( processor ) . newInstance ( ) ; } } public void setOut ( File outFile ) { this . outFile = outFile ; } public void setIn ( File inFile ) { this . inFile = inFile ; } private void process ( File baseDir , String xmlFile , File destDir , long styleSheetLastModified ) throws BuildException { String fileExt = targetExtension ; File outFile = null ; File inFile = null ; try { inFile = new File ( baseDir , xmlFile ) ; int dotPos = xmlFile . lastIndexOf ( '.' ) ; if ( dotPos > 0 ) { outFile = new File ( destDir , xmlFile . substring ( 0 , xmlFile . lastIndexOf ( '.' ) ) + fileExt ) ; } else { outFile = new File ( destDir , xmlFile + fileExt ) ; } if ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Transforming into " + destDir ) ; liaison . transform ( inFile . toString ( ) , outFile . toString ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) { outFile . delete ( ) ; } throw new BuildException ( ex ) ; } } private void process ( File inFile , File outFile , long styleSheetLastModified ) throws BuildException { try { log ( "In file " + inFile + " time: " + inFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Out file " + outFile + " time: " + outFile . lastModified ( ) , Project . MSG_DEBUG ) ; log ( "Style file " + xslFile + " time: " + styleSheetLastModified , Project . MSG_DEBUG ) ; if ( inFile . lastModified ( ) > outFile . lastModified ( ) || styleSheetLastModified > outFile . lastModified ( ) ) { ensureDirectoryFor ( outFile ) ; log ( "Processing " + inFile + " to " + outFile , Project . MSG_INFO ) ; liaison . transform ( inFile . toString ( ) , outFile . toString ( ) ) ; } } catch ( Exception ex ) { log ( "Failed to process " + inFile , Project . MSG_INFO ) ; if ( outFile != null ) outFile . delete ( ) ; throw new BuildException ( ex ) ; } } private void ensureDirectoryFor ( File targetFile ) throws BuildException { File directory = new File ( targetFile . getParent ( ) ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new BuildException ( "Unable to create directory: " + directory . getAbsolutePath ( ) ) ; } } } public Param createParam ( ) { Param p = new Param ( ) ; params . addElement ( p ) ; return p ; } public class Param { private String name = null ; private String expression = null ; public void setName ( String name ) { this . name = name ; } public void setExpression ( String expression ) { this . expression = expression ; } public String getName ( ) throws BuildException { if ( name == null ) throw new BuildException ( "Name attribute is missing." ) ; return name ; } public String getExpression ( ) throws BuildException { if ( expression == null ) throw new BuildException ( "Expression attribute is missing." ) ; return expression ; } } } 	0	['13', '4', '0', '7', '55', '30', '1', '7', '10', '0.802083333', '590', '1', '1', '0.866666667', '0.5', '2', '2', '43.76923077', '1', '0.9231', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . * ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + CopyDir instead. !!" ) ; log ( "Performing Substitions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; int length ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } public void setSrc ( String s ) { this . source = project . resolveFile ( s ) ; } public void setDest ( String dest ) { this . dest = project . resolveFile ( dest ) ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '3', '40', '10', '0', '3', '8', '0.714285714', '271', '1', '0', '0.840909091', '0.40625', '1', '1', '32.375', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . io . * ; public class ExecuteJava { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private PrintStream out ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setOutput ( PrintStream out ) { this . out = out ; } public void execute ( Project project ) throws BuildException { PrintStream sOut = System . out ; PrintStream sErr = System . err ; final String classname = javaCommand . getExecutable ( ) ; final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } if ( out != null ) { System . setErr ( out ) ; System . setOut ( out ) ; } final Class [ ] param = { Class . forName ( "[Ljava.lang.String;" ) } ; Class target = null ; if ( classpath == null ) { target = Class . forName ( classname ) ; } else { AntClassLoader loader = new AntClassLoader ( project , classpath , false ) ; loader . setIsolated ( true ) ; target = loader . forceLoadClass ( classname ) ; } final Method main = target . getMethod ( "main" , param ) ; main . invoke ( null , argument ) ; } catch ( NullPointerException e ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + ". Make sure you have it in your classpath" ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof SecurityException ) ) { throw new BuildException ( t ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } finally { if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } if ( out != null ) { System . setOut ( sOut ) ; System . setErr ( sErr ) ; out . close ( ) ; } } } } 	0	['6', '1', '0', '7', '26', '0', '1', '6', '6', '0.65', '185', '1', '3', '0', '0.305555556', '0', '0', '29.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public interface RegexpMatcher { public void setPattern ( String pattern ) throws BuildException ; public String getPattern ( ) ; public boolean matches ( String argument ) ; public Vector getGroups ( String argument ) ; } 	0	['4', '1', '0', '5', '4', '6', '4', '1', '4', '2', '4', '0', '0', '0', '0.875', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . ZipFileSet ; import java . io . * ; import java . util . zip . * ; public class Jar extends Zip { private File manifest ; private boolean manifestAdded ; public Jar ( ) { super ( ) ; archiveType = "jar" ; emptyBehavior = "create" ; } public void setJarfile ( File jarFile ) { super . setZipfile ( jarFile ) ; } public void setManifest ( File manifestFile ) { manifest = manifestFile ; if ( ! manifest . exists ( ) ) throw new BuildException ( "Manifest file: " + manifest + " does not exist." ) ; ZipFileSet fs = new ZipFileSet ( ) ; fs . setDir ( new File ( manifest . getParent ( ) ) ) ; fs . setIncludes ( manifest . getName ( ) ) ; fs . setFullpath ( "META-INF/MANIFEST.MF" ) ; super . addFileset ( fs ) ; } protected void initZipOutputStream ( ZipOutputStream zOut ) throws IOException , BuildException { if ( manifest == null ) { String s = "/org/apache/tools/ant/defaultManifest.mf" ; InputStream in = this . getClass ( ) . getResourceAsStream ( s ) ; if ( in == null ) throw new BuildException ( "Could not find: " + s ) ; zipDir ( null , zOut , "META-INF/" ) ; zipFile ( in , zOut , "META-INF/MANIFEST.MF" , System . currentTimeMillis ( ) ) ; } super . initZipOutputStream ( zOut ) ; } protected void zipFile ( File file , ZipOutputStream zOut , String vPath ) throws IOException { if ( vPath . equalsIgnoreCase ( "META-INF/MANIFEST.MF" ) ) { if ( manifest == null || ! manifest . equals ( file ) || manifestAdded ) { log ( "Warning: selected " + archiveType + " files include a META-INF/MANIFEST.MF which will be ignored " + "(please use manifest attribute to " + archiveType + " task)" , Project . MSG_WARN ) ; } else { super . zipFile ( file , zOut , vPath ) ; manifestAdded = true ; } } else { super . zipFile ( file , zOut , vPath ) ; } } protected void cleanUp ( ) { manifestAdded = false ; super . cleanUp ( ) ; } } 	0	['6', '5', '1', '6', '33', '7', '1', '5', '3', '0.7', '164', '1', '0', '0.961538462', '0.5', '3', '6', '26', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public class CallTarget extends Task { private Ant callee ; private String subTarget ; public void init ( ) { callee = ( Ant ) project . createTask ( "ant" ) ; callee . setOwningTarget ( target ) ; callee . setTaskName ( getTaskName ( ) ) ; callee . setLocation ( location ) ; callee . init ( ) ; } public void execute ( ) { if ( subTarget == null ) { throw new BuildException ( "Attribute target is required." , location ) ; } callee . setDir ( project . getBaseDir ( ) ) ; callee . setAntfile ( project . getProperty ( "ant.file" ) ) ; callee . setTarget ( subTarget ) ; callee . execute ( ) ; } public Property createParam ( ) { return callee . createProperty ( ) ; } public void setTarget ( String target ) { subTarget = target ; } } 	0	['5', '3', '0', '7', '20', '2', '0', '7', '5', '0.625', '76', '1', '1', '0.902439024', '0.6', '2', '2', '13.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , location ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , location ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , location ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '17', '4', '0', '3', '3', '0.666666667', '152', '1', '0', '0.925', '0.75', '1', '1', '36.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; public class ExecuteWatchdog implements Runnable { private Process process ; private int timeout ; private boolean watch = false ; private Exception caught = null ; private boolean killedProcess = false ; public ExecuteWatchdog ( int timeout ) { if ( timeout < 1 ) { throw new IllegalArgumentException ( "timeout lesser than 1." ) ; } this . timeout = timeout ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; final Thread thread = new Thread ( this , "WATCHDOG" ) ; thread . setDaemon ( true ) ; thread . start ( ) ; } public synchronized void stop ( ) { watch = false ; notifyAll ( ) ; } public synchronized void run ( ) { try { final long until = System . currentTimeMillis ( ) + timeout ; long now ; while ( watch && until > ( now = System . currentTimeMillis ( ) ) ) { try { wait ( until - now ) ; } catch ( InterruptedException e ) { } } try { process . exitValue ( ) ; } catch ( IllegalThreadStateException e ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected void cleanUp ( ) { watch = false ; process = null ; } public void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['8', '1', '0', '6', '25', '0', '5', '1', '7', '0.6', '169', '1', '0', '0', '0.416666667', '0', '0', '19.5', '7', '1.875', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import java . io . File ; import java . util . Vector ; public class SourceFileScanner { protected Task task ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { long now = ( new java . util . Date ( ) ) . getTime ( ) ; StringBuffer targetList = new StringBuffer ( ) ; String osname = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osname . indexOf ( "windows" ) >= 0 ) { now += 2000 ; } Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String [ ] targets = mapper . mapFileName ( files [ i ] ) ; if ( targets == null || targets . length == 0 ) { task . log ( files [ i ] + " skipped - don\'t know how to handle it" , Project . MSG_VERBOSE ) ; continue ; } File src = new File ( srcDir , files [ i ] ) ; if ( src . lastModified ( ) > now ) { task . log ( "Warning: " + files [ i ] + " modified in the future." , Project . MSG_WARN ) ; } boolean added = false ; targetList . setLength ( 0 ) ; for ( int j = 0 ; ! added && j < targets . length ; j ++ ) { File dest = null ; if ( destDir == null ) { dest = new File ( targets [ j ] ) ; } else { dest = new File ( destDir , targets [ j ] ) ; } if ( ! dest . exists ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " doesn\'t exist." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else if ( src . lastModified ( ) > dest . lastModified ( ) ) { task . log ( files [ i ] + " added as " + dest . getAbsolutePath ( ) + " is outdated." , Project . MSG_VERBOSE ) ; v . addElement ( files [ i ] ) ; added = true ; } else { if ( targetList . length ( ) > 0 ) { targetList . append ( ", " ) ; } targetList . append ( dest . getAbsolutePath ( ) ) ; } } if ( ! added ) { task . log ( files [ i ] + " omitted as " + targetList . toString ( ) + ( targets . length == 1 ? " is" : " are " ) + " up to date." , Project . MSG_VERBOSE ) ; } } String [ ] result = new String [ v . size ( ) ] ; v . copyInto ( result ) ; return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { String [ ] res = restrict ( files , srcDir , destDir , mapper ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } } 	0	['3', '1', '0', '9', '25', '1', '7', '2', '3', '0', '277', '1', '1', '0', '0.666666667', '0', '0', '91', '14', '5.3333', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class ZipFileSet extends FileSet { private File srcFile = null ; private String prefix = "" ; private String fullpath = "" ; private boolean hasDir = false ; public void setDir ( File dir ) throws BuildException { if ( srcFile != null ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } else { super . setDir ( dir ) ; hasDir = true ; } } public void setSrc ( File srcFile ) { if ( hasDir ) { throw new BuildException ( "Cannot set both dir and src attributes" ) ; } this . srcFile = srcFile ; } public File getSrc ( ) { return srcFile ; } public void setPrefix ( String prefix ) { this . prefix = prefix ; } public String getPrefix ( ) { return prefix ; } public void setFullpath ( String fullpath ) { this . fullpath = fullpath ; } public String getFullpath ( ) { return fullpath ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } if ( srcFile != null ) { ZipScanner zs = new ZipScanner ( ) ; zs . setSrc ( srcFile ) ; super . setDir ( new File ( "." ) ) ; setupDirectoryScanner ( zs , p ) ; zs . init ( ) ; return zs ; } else { return super . getDirectoryScanner ( p ) ; } } } 	0	['9', '5', '0', '10', '20', '4', '3', '7', '9', '0.6875', '110', '1', '0', '0.919191919', '0.388888889', '2', '7', '10.77777778', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . * ; public class Copy extends Task { protected File file = null ; protected File destFile = null ; protected File destDir = null ; protected Vector filesets = new Vector ( ) ; protected boolean filtering = false ; protected boolean preserveLastModified = false ; protected boolean forceOverwrite = false ; protected boolean flatten = false ; protected int verbosity = Project . MSG_VERBOSE ; protected boolean includeEmpty = true ; protected Hashtable fileCopyMap = new Hashtable ( ) ; protected Hashtable dirCopyMap = new Hashtable ( ) ; protected Mapper mapperElement = null ; public void setFile ( File file ) { this . file = file ; } public void setTofile ( File destFile ) { this . destFile = destFile ; } public void setTodir ( File destDir ) { this . destDir = destDir ; } public void setPreserveLastModified ( String preserve ) { preserveLastModified = Project . toBoolean ( preserve ) ; } public void setFiltering ( boolean filtering ) { this . filtering = filtering ; } public void setOverwrite ( boolean overwrite ) { this . forceOverwrite = overwrite ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { this . verbosity = Project . MSG_INFO ; } else { this . verbosity = Project . MSG_VERBOSE ; } } public void setIncludeEmptyDirs ( boolean includeEmpty ) { this . includeEmpty = includeEmpty ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { validateAttributes ( ) ; if ( file != null ) { if ( file . exists ( ) ) { if ( destFile == null ) { destFile = new File ( destDir , file . getName ( ) ) ; } if ( forceOverwrite || ( file . lastModified ( ) > destFile . lastModified ( ) ) ) { fileCopyMap . put ( file . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } else { log ( "Could not find file " + file . getAbsolutePath ( ) + " to copy." ) ; } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; File fromDir = fs . getDir ( project ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; String [ ] srcDirs = ds . getIncludedDirectories ( ) ; scan ( fromDir , destDir , srcFiles , srcDirs ) ; } doFileOperations ( ) ; if ( destFile != null ) { destDir = null ; } } protected void validateAttributes ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( destFile != null && destDir != null ) { throw new BuildException ( "Only one of destfile and destdir may be set." ) ; } if ( destFile == null && destDir == null ) { throw new BuildException ( "One of destfile or destdir must be set." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "Use a fileset to copy directories." ) ; } if ( destFile != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Cannot concatenate multple files into a single file." ) ; } if ( destFile != null ) { destDir = new File ( destFile . getParent ( ) ) ; } } protected void scan ( File fromDir , File toDir , String [ ] files , String [ ] dirs ) { FileNameMapper mapper = null ; if ( mapperElement != null ) { mapper = mapperElement . getImplementation ( ) ; } else if ( flatten ) { mapper = new FlatFileNameMapper ( ) ; } else { mapper = new IdentityMapper ( ) ; } buildMap ( fromDir , toDir , files , mapper , fileCopyMap ) ; if ( includeEmpty ) { buildMap ( fromDir , toDir , dirs , mapper , dirCopyMap ) ; } } protected void buildMap ( File fromDir , File toDir , String [ ] names , FileNameMapper mapper , Hashtable map ) { String [ ] toCopy = null ; if ( forceOverwrite ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( mapper . mapFileName ( names [ i ] ) != null ) { v . addElement ( names [ i ] ) ; } } toCopy = new String [ v . size ( ) ] ; v . copyInto ( toCopy ) ; } else { SourceFileScanner ds = new SourceFileScanner ( this ) ; toCopy = ds . restrict ( names , fromDir , toDir , mapper ) ; } for ( int i = 0 ; i < toCopy . length ; i ++ ) { File src = new File ( fromDir , toCopy [ i ] ) ; File dest = new File ( toDir , mapper . mapFileName ( toCopy [ i ] ) [ 0 ] ) ; map . put ( src . getAbsolutePath ( ) , dest . getAbsolutePath ( ) ) ; } } protected void doFileOperations ( ) { if ( fileCopyMap . size ( ) > 0 ) { log ( "Copying " + fileCopyMap . size ( ) + " file" + ( fileCopyMap . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = fileCopyMap . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) fileCopyMap . get ( fromFile ) ; if ( fromFile . equals ( toFile ) ) { log ( "Skipping self-copy of " + fromFile , verbosity ) ; continue ; } try { log ( "Copying " + fromFile + " to " + toFile , verbosity ) ; project . copyFile ( fromFile , toFile , filtering , forceOverwrite , preserveLastModified ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } if ( includeEmpty ) { Enumeration e = dirCopyMap . elements ( ) ; int count = 0 ; while ( e . hasMoreElements ( ) ) { File d = new File ( ( String ) e . nextElement ( ) ) ; if ( ! d . exists ( ) ) { if ( ! d . mkdirs ( ) ) { log ( "Unable to create directory " + d . getAbsolutePath ( ) , Project . MSG_ERR ) ; } else { count ++ ; } } } if ( count > 0 ) { log ( "Copied " + count + " empty director" + ( count == 1 ? "y" : "ies" ) + " to " + destDir . getAbsolutePath ( ) ) ; } } } } 	0	['17', '3', '1', '12', '64', '52', '1', '11', '13', '0.793269231', '642', '1', '1', '0.698113208', '0.242647059', '1', '1', '36', '11', '2', '0']
package org . apache . tools . tar ; public interface TarConstants { public static final int NAMELEN = 100 ; public static final int MODELEN = 8 ; public static final int UIDLEN = 8 ; public static final int GIDLEN = 8 ; public static final int CHKSUMLEN = 8 ; public static final int SIZELEN = 12 ; public static final int MAGICLEN = 8 ; public static final int MODTIMELEN = 12 ; public static final int UNAMELEN = 32 ; public static final int GNAMELEN = 32 ; public static final int DEVLEN = 8 ; public static final byte LF_OLDNORM = 0 ; public static final byte LF_NORMAL = ( byte ) '0' ; public static final byte LF_LINK = ( byte ) '1' ; public static final byte LF_SYMLINK = ( byte ) '2' ; public static final byte LF_CHR = ( byte ) '3' ; public static final byte LF_BLK = ( byte ) '4' ; public static final byte LF_DIR = ( byte ) '5' ; public static final byte LF_FIFO = ( byte ) '6' ; public static final byte LF_CONTIG = ( byte ) '7' ; public static final String TMAGIC = "ustar" ; public static final String GNU_TMAGIC = "ustar  " ; public static final String GNU_LONGLINK = "././@LongLink" ; public static final byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '24', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . tar ; import java . io . * ; import java . util . * ; public class TarEntry implements TarConstants { private StringBuffer name ; private int mode ; private int userId ; private int groupId ; private long size ; private long modTime ; private int checkSum ; private byte linkFlag ; private StringBuffer linkName ; private StringBuffer magic ; private StringBuffer userName ; private StringBuffer groupName ; private int devMajor ; private int devMinor ; private File file ; private TarEntry ( ) { this . magic = new StringBuffer ( TMAGIC ) ; this . name = new StringBuffer ( ) ; this . linkName = new StringBuffer ( ) ; String user = System . getProperty ( "user.name" , "" ) ; if ( user . length ( ) > 31 ) { user = user . substring ( 0 , 31 ) ; } this . userId = 0 ; this . groupId = 0 ; this . userName = new StringBuffer ( user ) ; this . groupName = new StringBuffer ( "" ) ; this . file = null ; } public TarEntry ( String name ) { this ( ) ; boolean isDir = name . endsWith ( "/" ) ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; this . name = new StringBuffer ( name ) ; this . mode = isDir ? 040755 : 0100644 ; this . linkFlag = isDir ? LF_DIR : LF_NORMAL ; this . userId = 0 ; this . groupId = 0 ; this . size = 0 ; this . checkSum = 0 ; this . modTime = ( new Date ( ) ) . getTime ( ) / 1000 ; this . linkName = new StringBuffer ( "" ) ; this . userName = new StringBuffer ( "" ) ; this . groupName = new StringBuffer ( "" ) ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( String name , byte linkFlag ) { this ( name ) ; this . linkFlag = linkFlag ; } public TarEntry ( File file ) { this ( ) ; this . file = file ; String name = file . getPath ( ) ; String osname = System . getProperty ( "os.name" ) ; if ( osname != null ) { String Win32Prefix = "Windows" ; String prefix = osname . substring ( 0 , Win32Prefix . length ( ) ) ; if ( prefix . equalsIgnoreCase ( Win32Prefix ) ) { if ( name . length ( ) > 2 ) { char ch1 = name . charAt ( 0 ) ; char ch2 = name . charAt ( 1 ) ; if ( ch2 == ':' && ( ( ch1 >= 'a' && ch1 <= 'z' ) || ( ch1 >= 'A' && ch1 <= 'Z' ) ) ) { name = name . substring ( 2 ) ; } } } } name = name . replace ( File . separatorChar , '/' ) ; while ( name . startsWith ( "/" ) ) { name = name . substring ( 1 ) ; } this . linkName = new StringBuffer ( "" ) ; this . name = new StringBuffer ( name ) ; if ( file . isDirectory ( ) ) { this . mode = 040755 ; this . linkFlag = LF_DIR ; if ( this . name . charAt ( this . name . length ( ) - 1 ) != '/' ) { this . name . append ( "/" ) ; } } else { this . mode = 0100644 ; this . linkFlag = LF_NORMAL ; } this . size = file . length ( ) ; this . modTime = file . lastModified ( ) / 1000 ; this . checkSum = 0 ; this . devMajor = 0 ; this . devMinor = 0 ; } public TarEntry ( byte [ ] headerBuf ) { this ( ) ; this . parseTarHeader ( headerBuf ) ; } public boolean equals ( TarEntry it ) { return this . getName ( ) . equals ( it . getName ( ) ) ; } public boolean isDescendent ( TarEntry desc ) { return desc . getName ( ) . startsWith ( this . getName ( ) ) ; } public String getName ( ) { return this . name . toString ( ) ; } public void setName ( String name ) { this . name = new StringBuffer ( name ) ; } public void setMode ( int mode ) { this . mode = mode ; } public int getUserId ( ) { return this . userId ; } public void setUserId ( int userId ) { this . userId = userId ; } public int getGroupId ( ) { return this . groupId ; } public void setGroupId ( int groupId ) { this . groupId = groupId ; } public String getUserName ( ) { return this . userName . toString ( ) ; } public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } public String getGroupName ( ) { return this . groupName . toString ( ) ; } public void setGroupName ( String groupName ) { this . groupName = new StringBuffer ( groupName ) ; } public void setIds ( int userId , int groupId ) { this . setUserId ( userId ) ; this . setGroupId ( groupId ) ; } public void setNames ( String userName , String groupName ) { this . setUserName ( userName ) ; this . setGroupName ( groupName ) ; } public void setModTime ( long time ) { this . modTime = time / 1000 ; } public void setModTime ( Date time ) { this . modTime = time . getTime ( ) / 1000 ; } public Date getModTime ( ) { return new Date ( this . modTime * 1000 ) ; } public File getFile ( ) { return this . file ; } public long getSize ( ) { return this . size ; } public void setSize ( long size ) { this . size = size ; } public boolean isGNULongNameEntry ( ) { return linkFlag == LF_GNUTYPE_LONGNAME && name . toString ( ) . equals ( GNU_LONGLINK ) ; } public boolean isDirectory ( ) { if ( this . file != null ) { return this . file . isDirectory ( ) ; } if ( this . linkFlag == LF_DIR ) { return true ; } if ( this . getName ( ) . endsWith ( "/" ) ) { return true ; } return false ; } public TarEntry [ ] getDirectoryEntries ( ) { if ( this . file == null || ! this . file . isDirectory ( ) ) { return new TarEntry [ 0 ] ; } String [ ] list = this . file . list ( ) ; TarEntry [ ] result = new TarEntry [ list . length ] ; for ( int i = 0 ; i < list . length ; ++ i ) { result [ i ] = new TarEntry ( new File ( this . file , list [ i ] ) ) ; } return result ; } public void writeEntryHeader ( byte [ ] outbuf ) { int offset = 0 ; offset = TarUtils . getNameBytes ( this . name , outbuf , offset , NAMELEN ) ; offset = TarUtils . getOctalBytes ( this . mode , outbuf , offset , MODELEN ) ; offset = TarUtils . getOctalBytes ( this . userId , outbuf , offset , UIDLEN ) ; offset = TarUtils . getOctalBytes ( this . groupId , outbuf , offset , GIDLEN ) ; offset = TarUtils . getLongOctalBytes ( this . size , outbuf , offset , SIZELEN ) ; offset = TarUtils . getLongOctalBytes ( this . modTime , outbuf , offset , MODTIMELEN ) ; int csOffset = offset ; for ( int c = 0 ; c < CHKSUMLEN ; ++ c ) { outbuf [ offset ++ ] = ( byte ) ' ' ; } outbuf [ offset ++ ] = this . linkFlag ; offset = TarUtils . getNameBytes ( this . linkName , outbuf , offset , NAMELEN ) ; offset = TarUtils . getNameBytes ( this . magic , outbuf , offset , MAGICLEN ) ; offset = TarUtils . getNameBytes ( this . userName , outbuf , offset , UNAMELEN ) ; offset = TarUtils . getNameBytes ( this . groupName , outbuf , offset , GNAMELEN ) ; offset = TarUtils . getOctalBytes ( this . devMajor , outbuf , offset , DEVLEN ) ; offset = TarUtils . getOctalBytes ( this . devMinor , outbuf , offset , DEVLEN ) ; while ( offset < outbuf . length ) { outbuf [ offset ++ ] = 0 ; } long checkSum = TarUtils . computeCheckSum ( outbuf ) ; TarUtils . getCheckSumOctalBytes ( checkSum , outbuf , csOffset , CHKSUMLEN ) ; } public void parseTarHeader ( byte [ ] header ) { int offset = 0 ; this . name = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . mode = ( int ) TarUtils . parseOctal ( header , offset , MODELEN ) ; offset += MODELEN ; this . userId = ( int ) TarUtils . parseOctal ( header , offset , UIDLEN ) ; offset += UIDLEN ; this . groupId = ( int ) TarUtils . parseOctal ( header , offset , GIDLEN ) ; offset += GIDLEN ; this . size = TarUtils . parseOctal ( header , offset , SIZELEN ) ; offset += SIZELEN ; this . modTime = TarUtils . parseOctal ( header , offset , MODTIMELEN ) ; offset += MODTIMELEN ; this . checkSum = ( int ) TarUtils . parseOctal ( header , offset , CHKSUMLEN ) ; offset += CHKSUMLEN ; this . linkFlag = header [ offset ++ ] ; this . linkName = TarUtils . parseName ( header , offset , NAMELEN ) ; offset += NAMELEN ; this . magic = TarUtils . parseName ( header , offset , MAGICLEN ) ; offset += MAGICLEN ; this . userName = TarUtils . parseName ( header , offset , UNAMELEN ) ; offset += UNAMELEN ; this . groupName = TarUtils . parseName ( header , offset , GNAMELEN ) ; offset += GNAMELEN ; this . devMajor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; offset += DEVLEN ; this . devMinor = ( int ) TarUtils . parseOctal ( header , offset , DEVLEN ) ; } } 	0	['31', '1', '0', '6', '65', '243', '4', '2', '30', '0.726666667', '747', '1', '0', '0', '0.182795699', '1', '1', '22.61290323', '4', '1.1613', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarBuffer { public static final int DEFAULT_RCDSIZE = ( 512 ) ; public static final int DEFAULT_BLKSIZE = ( DEFAULT_RCDSIZE * 20 ) ; private InputStream inStream ; private OutputStream outStream ; private byte [ ] blockBuffer ; private int currBlkIdx ; private int currRecIdx ; private int blockSize ; private int recordSize ; private int recsPerBlock ; private boolean debug ; public TarBuffer ( InputStream inStream ) { this ( inStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize ) { this ( inStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( InputStream inStream , int blockSize , int recordSize ) { this . inStream = inStream ; this . outStream = null ; this . initialize ( blockSize , recordSize ) ; } public TarBuffer ( OutputStream outStream ) { this ( outStream , TarBuffer . DEFAULT_BLKSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize ) { this ( outStream , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarBuffer ( OutputStream outStream , int blockSize , int recordSize ) { this . inStream = null ; this . outStream = outStream ; this . initialize ( blockSize , recordSize ) ; } private void initialize ( int blockSize , int recordSize ) { this . debug = false ; this . blockSize = blockSize ; this . recordSize = recordSize ; this . recsPerBlock = ( this . blockSize / this . recordSize ) ; this . blockBuffer = new byte [ this . blockSize ] ; if ( this . inStream != null ) { this . currBlkIdx = - 1 ; this . currRecIdx = this . recsPerBlock ; } else { this . currBlkIdx = 0 ; this . currRecIdx = 0 ; } } public int getBlockSize ( ) { return this . blockSize ; } public int getRecordSize ( ) { return this . recordSize ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public boolean isEOFRecord ( byte [ ] record ) { for ( int i = 0 , sz = this . getRecordSize ( ) ; i < sz ; ++ i ) { if ( record [ i ] != 0 ) { return false ; } } return true ; } public void skipRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "SkipRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading (via skip) from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return ; } } this . currRecIdx ++ ; } public byte [ ] readRecord ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { if ( ! this . readBlock ( ) ) { return null ; } } byte [ ] result = new byte [ this . recordSize ] ; System . arraycopy ( this . blockBuffer , ( this . currRecIdx * this . recordSize ) , result , 0 , this . recordSize ) ; this . currRecIdx ++ ; return result ; } private boolean readBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "ReadBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . inStream == null ) { throw new IOException ( "reading from an output buffer" ) ; } this . currRecIdx = 0 ; int offset = 0 ; int bytesNeeded = this . blockSize ; while ( bytesNeeded > 0 ) { long numBytes = this . inStream . read ( this . blockBuffer , offset , bytesNeeded ) ; if ( numBytes == - 1 ) { break ; } offset += numBytes ; bytesNeeded -= numBytes ; if ( numBytes != this . blockSize ) { if ( this . debug ) { System . err . println ( "ReadBlock: INCOMPLETE READ " + numBytes + " of " + this . blockSize + " bytes read." ) ; } } } this . currBlkIdx ++ ; return true ; } public int getCurrentBlockNum ( ) { return this . currBlkIdx ; } public int getCurrentRecordNum ( ) { return this . currRecIdx - 1 ; } public void writeRecord ( byte [ ] record ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( record . length != this . recordSize ) { throw new IOException ( "record to write has length '" + record . length + "' which is not the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( record , 0 , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } public void writeRecord ( byte [ ] buf , int offset ) throws IOException { if ( this . debug ) { System . err . println ( "WriteRecord: recIdx = " + this . currRecIdx + " blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( ( offset + this . recordSize ) > buf . length ) { throw new IOException ( "record has length '" + buf . length + "' with offset '" + offset + "' which is less than the record size of '" + this . recordSize + "'" ) ; } if ( this . currRecIdx >= this . recsPerBlock ) { this . writeBlock ( ) ; } System . arraycopy ( buf , offset , this . blockBuffer , ( this . currRecIdx * this . recordSize ) , this . recordSize ) ; this . currRecIdx ++ ; } private void writeBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "WriteBlock: blkIdx = " + this . currBlkIdx ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } this . outStream . write ( this . blockBuffer , 0 , this . blockSize ) ; this . outStream . flush ( ) ; this . currRecIdx = 0 ; this . currBlkIdx ++ ; } private void flushBlock ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.flushBlock() called." ) ; } if ( this . outStream == null ) { throw new IOException ( "writing to an input buffer" ) ; } if ( this . currRecIdx > 0 ) { this . writeBlock ( ) ; } } public void close ( ) throws IOException { if ( this . debug ) { System . err . println ( "TarBuffer.closeBuffer()." ) ; } if ( this . outStream != null ) { this . flushBlock ( ) ; if ( this . outStream != System . out && this . outStream != System . err ) { this . outStream . close ( ) ; this . outStream = null ; } } else if ( this . inStream != null ) { if ( this . inStream != System . in ) { this . inStream . close ( ) ; this . inStream = null ; } } } } 	0	['21', '1', '0', '2', '35', '38', '2', '0', '17', '0.631818182', '617', '0.818181818', '0', '0', '0.293650794', '0', '0', '27.85714286', '3', '0.8571', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . util . Vector ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified for environment variables." ) ; } StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } } 	0	['3', '1', '1', '5', '9', '0', '3', '2', '3', '0', '47', '1', '0', '0', '0.666666667', '0', '0', '14.33333333', '1', '0.6667', '0']
package org . apache . tools . tar ; import java . io . * ; public class TarOutputStream extends FilterOutputStream { static public final int LONGFILE_ERROR = 0 ; static public final int LONGFILE_TRUNCATE = 1 ; static public final int LONGFILE_GNU = 2 ; protected boolean debug ; protected int currSize ; protected int currBytes ; protected byte [ ] oneBuf ; protected byte [ ] recordBuf ; protected int assemLen ; protected byte [ ] assemBuf ; protected TarBuffer buffer ; protected int longFileMode = LONGFILE_ERROR ; public TarOutputStream ( OutputStream os ) { this ( os , TarBuffer . DEFAULT_BLKSIZE , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize ) { this ( os , blockSize , TarBuffer . DEFAULT_RCDSIZE ) ; } public TarOutputStream ( OutputStream os , int blockSize , int recordSize ) { super ( os ) ; this . buffer = new TarBuffer ( os , blockSize , recordSize ) ; this . debug = false ; this . assemLen = 0 ; this . assemBuf = new byte [ recordSize ] ; this . recordBuf = new byte [ recordSize ] ; this . oneBuf = new byte [ 1 ] ; } public void setLongFileMode ( int longFileMode ) { this . longFileMode = longFileMode ; } public void setDebug ( boolean debugF ) { this . debug = debugF ; } public void setBufferDebug ( boolean debug ) { this . buffer . setDebug ( debug ) ; } public void finish ( ) throws IOException { this . writeEOFRecord ( ) ; } public void close ( ) throws IOException { this . finish ( ) ; this . buffer . close ( ) ; } public int getRecordSize ( ) { return this . buffer . getRecordSize ( ) ; } public void putNextEntry ( TarEntry entry ) throws IOException { if ( entry . getName ( ) . length ( ) >= TarConstants . NAMELEN ) { if ( longFileMode == LONGFILE_GNU ) { TarEntry longLinkEntry = new TarEntry ( TarConstants . GNU_LONGLINK , TarConstants . LF_GNUTYPE_LONGNAME ) ; longLinkEntry . setSize ( entry . getName ( ) . length ( ) + 1 ) ; putNextEntry ( longLinkEntry ) ; write ( entry . getName ( ) . getBytes ( ) ) ; write ( 0 ) ; closeEntry ( ) ; } else if ( longFileMode != LONGFILE_TRUNCATE ) { throw new RuntimeException ( "file name '" + entry . getName ( ) + "' is too long ( > " + TarConstants . NAMELEN + " bytes)" ) ; } } entry . writeEntryHeader ( this . recordBuf ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes = 0 ; if ( entry . isDirectory ( ) ) { this . currSize = 0 ; } else { this . currSize = ( int ) entry . getSize ( ) ; } } public void closeEntry ( ) throws IOException { if ( this . assemLen > 0 ) { for ( int i = this . assemLen ; i < this . assemBuf . length ; ++ i ) { this . assemBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . assemBuf ) ; this . currBytes += this . assemLen ; this . assemLen = 0 ; } if ( this . currBytes < this . currSize ) { throw new IOException ( "entry closed at '" + this . currBytes + "' before the '" + this . currSize + "' bytes specified in the header were written" ) ; } } public void write ( int b ) throws IOException { this . oneBuf [ 0 ] = ( byte ) b ; this . write ( this . oneBuf , 0 , 1 ) ; } public void write ( byte [ ] wBuf ) throws IOException { this . write ( wBuf , 0 , wBuf . length ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( this . currBytes + numToWrite ) > this . currSize ) { throw new IOException ( "request to write '" + numToWrite + "' bytes exceeds size in header of '" + this . currSize + "' bytes" ) ; } if ( this . assemLen > 0 ) { if ( ( this . assemLen + numToWrite ) >= this . recordBuf . length ) { int aLen = this . recordBuf . length - this . assemLen ; System . arraycopy ( this . assemBuf , 0 , this . recordBuf , 0 , this . assemLen ) ; System . arraycopy ( wBuf , wOffset , this . recordBuf , this . assemLen , aLen ) ; this . buffer . writeRecord ( this . recordBuf ) ; this . currBytes += this . recordBuf . length ; wOffset += aLen ; numToWrite -= aLen ; this . assemLen = 0 ; } else { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; wOffset += numToWrite ; this . assemLen += numToWrite ; numToWrite -= numToWrite ; } } while ( numToWrite > 0 ) { if ( numToWrite < this . recordBuf . length ) { System . arraycopy ( wBuf , wOffset , this . assemBuf , this . assemLen , numToWrite ) ; this . assemLen += numToWrite ; break ; } this . buffer . writeRecord ( wBuf , wOffset ) ; int num = this . recordBuf . length ; this . currBytes += num ; numToWrite -= num ; wOffset += num ; } } private void writeEOFRecord ( ) throws IOException { for ( int i = 0 ; i < this . recordBuf . length ; ++ i ) { this . recordBuf [ i ] = 0 ; } this . buffer . writeRecord ( this . recordBuf ) ; } } 	0	['15', '3', '0', '3', '37', '41', '1', '2', '14', '0.696428571', '437', '0.75', '1', '0.454545455', '0.311111111', '1', '2', '27.33333333', '1', '0.8', '0']
package org . apache . tools . ant ; import java . io . * ; public interface FileScanner { public void addDefaultExcludes ( ) ; public File getBasedir ( ) ; public String [ ] getExcludedDirectories ( ) ; public String [ ] getExcludedFiles ( ) ; public String [ ] getIncludedDirectories ( ) ; public String [ ] getIncludedFiles ( ) ; public String [ ] getNotIncludedDirectories ( ) ; public String [ ] getNotIncludedFiles ( ) ; public void scan ( ) ; public void setBasedir ( String basedir ) ; public void setBasedir ( File basedir ) ; public void setExcludes ( String [ ] excludes ) ; public void setIncludes ( String [ ] includes ) ; } 	0	['13', '1', '0', '4', '13', '78', '4', '0', '13', '2', '13', '0', '0', '0', '0.326923077', '0', '0', '0', '1', '1', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] result = new byte [ length ] ; int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '274', '0', '0', '0', '0.45', '0', '0', '33.25', '7', '2.875', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class GZip extends Task { private File zipFile ; private File source ; public void setZipfile ( String zipFilename ) { zipFile = project . resolveFile ( zipFilename ) ; } public void setSrc ( String src ) { source = project . resolveFile ( src ) ; } public void execute ( ) throws BuildException { if ( zipFile == null ) { throw new BuildException ( "zipfile attribute is required" , location ) ; } if ( source == null ) { throw new BuildException ( "src attribute is required" , location ) ; } log ( "Building gzip: " + zipFile . getAbsolutePath ( ) ) ; GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; if ( source . isDirectory ( ) ) { log ( "Cannot Gzip a directory!" , Project . MSG_ERR ) ; } else { zipFile ( source , zOut ) ; } } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } finally { if ( zOut != null ) { try { zOut . close ( ) ; } catch ( IOException e ) { } } } } private void zipFile ( InputStream in , GZIPOutputStream zOut ) throws IOException { byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { zOut . write ( buffer , 0 , count ) ; count = in . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } private void zipFile ( File file , GZIPOutputStream zOut ) throws IOException { FileInputStream fIn = new FileInputStream ( file ) ; try { zipFile ( fIn , zOut ) ; } finally { fIn . close ( ) ; } } } 	0	['6', '3', '0', '4', '25', '11', '0', '4', '4', '0.8', '157', '1', '0', '0.880952381', '0.4', '2', '2', '24.83333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Date ; import java . util . Locale ; public class Touch extends Task { private File file ; private long millis = - 1 ; private String dateTime ; private static Method setLastModified = null ; private static Object lockReflection = new Object ( ) ; public void setFile ( File file ) { this . file = file ; } public void setMillis ( long millis ) { this . millis = millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; } public void execute ( ) throws BuildException { if ( file . exists ( ) && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( "Cannot change the modification time of " + file + " in JDK 1.1" , Project . MSG_WARN ) ; return ; } if ( dateTime != null ) { DateFormat df = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; } catch ( ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe , location ) ; } } if ( millis >= 0 && project . getJavaVersion ( ) == Project . JAVA_1_1 ) { log ( file + " will be created but its modification time cannot be set in JDK 1.1" , Project . MSG_WARN ) ; } touch ( ) ; } void touch ( ) throws BuildException { if ( ! file . exists ( ) ) { log ( "Creating " + file , Project . MSG_INFO ) ; try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( new byte [ 0 ] ) ; fos . close ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Could not create " + file , ioe , location ) ; } } if ( project . getJavaVersion ( ) == Project . JAVA_1_1 ) { return ; } if ( setLastModified == null ) { synchronized ( lockReflection ) { if ( setLastModified == null ) { try { setLastModified = java . io . File . class . getMethod ( "setLastModified" , new Class [ ] { Long . TYPE } ) ; } catch ( NoSuchMethodException nse ) { throw new BuildException ( "File.setlastModified not in JDK > 1.1?" , nse , location ) ; } } } } Long [ ] times = new Long [ 1 ] ; if ( millis < 0 ) { times [ 0 ] = new Long ( System . currentTimeMillis ( ) ) ; } else { times [ 0 ] = new Long ( millis ) ; } try { log ( "Setting modification time for " + file , Project . MSG_VERBOSE ) ; setLastModified . invoke ( file , times ) ; } catch ( InvocationTargetException ite ) { Throwable nested = ite . getTargetException ( ) ; throw new BuildException ( "Exception setting the modification time of " + file , nested , location ) ; } catch ( Throwable other ) { throw new BuildException ( "Exception setting the modification time of " + file , other , location ) ; } } } 	0	['8', '3', '0', '7', '32', '8', '3', '4', '5', '0.738095238', '300', '0.833333333', '0', '0.860465116', '0.357142857', '1', '1', '35.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . * ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; if ( bootclasspath != null ) { classpath . append ( bootclasspath ) ; } addExtdirsToClasspath ( classpath ) ; if ( ( bootclasspath == null ) || ( bootclasspath . size ( ) == 0 ) ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; classpath . append ( src ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( "jvc" ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '9', '19', '1', '1', '8', '2', '2', '120', '0', '0', '0.958333333', '1', '1', '1', '59', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; public class Taskdef extends Task { private String name ; private String value ; private Path classpath ; public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( project ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { if ( name == null || value == null ) { String msg = "name or classname attributes of taskdef element " + "are undefined" ; throw new BuildException ( msg ) ; } try { ClassLoader loader = null ; if ( classpath != null ) { AntClassLoader al = new AntClassLoader ( project , classpath , false ) ; al . addSystemPackageRoot ( "org.apache.tools.ant" ) ; loader = al ; } else { loader = this . getClass ( ) . getClassLoader ( ) ; } Class taskClass = null ; if ( loader != null ) { taskClass = loader . loadClass ( value ) ; } else { taskClass = Class . forName ( value ) ; } project . addTaskDefinition ( name , taskClass ) ; } catch ( ClassNotFoundException cnfe ) { String msg = "taskdef class " + value + " cannot be found" ; throw new BuildException ( msg , cnfe , location ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "taskdef class " + value + " cannot be found" ; throw new BuildException ( msg , ncdfe , location ) ; } } public void setName ( String name ) { this . name = name ; } public String getClassname ( ) { return value ; } public void setClassname ( String v ) { value = v ; } } 	0	['8', '3', '0', '8', '25', '14', '1', '7', '8', '0.714285714', '157', '1', '1', '0.840909091', '0.375', '0', '0', '18.25', '2', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; public class ExecTask extends Task { private String os ; private File out ; private File dir ; protected boolean failOnError = false ; protected boolean newEnvironment = false ; private Integer timeout = null ; private Environment env = new Environment ( ) ; protected Commandline cmdl = new Commandline ( ) ; private FileOutputStream fos = null ; public void setTimeout ( Integer value ) { timeout = value ; } public void setExecutable ( String value ) { cmdl . setExecutable ( value ) ; } public void setDir ( File d ) { this . dir = d ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( Commandline cmdl ) { log ( "The command attribute is deprecated. " + "Please use the executable attribute and nested arg elements." , Project . MSG_WARN ) ; this . cmdl = cmdl ; } public void setOutput ( File out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public void addEnv ( Environment . Variable var ) { env . addVariable ( var ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; if ( isValidOs ( ) ) { runExec ( prepareExec ( ) ) ; } } protected void checkConfiguration ( ) throws BuildException { if ( cmdl . getExecutable ( ) == null ) { throw new BuildException ( "no executable specified" , location ) ; } if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( "The directory you specified does not exist" ) ; } if ( dir != null && ! dir . isDirectory ( ) ) { throw new BuildException ( "The directory you specified is not a directory" ) ; } } protected boolean isValidOs ( ) { String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return false ; } return true ; } protected Execute prepareExec ( ) throws BuildException { if ( dir == null ) dir = project . getBaseDir ( ) ; log ( cmdl . toString ( ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( createHandler ( ) , createWatchdog ( ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( dir ) ; String [ ] environment = env . getVariables ( ) ; if ( environment != null ) { for ( int i = 0 ; i < environment . length ; i ++ ) { log ( "Setting environment variable: " + environment [ i ] , Project . MSG_VERBOSE ) ; } } exe . setNewenvironment ( newEnvironment ) ; exe . setEnvironment ( environment ) ; return exe ; } protected void runExec ( Execute exe ) throws BuildException { int err = - 1 ; try { exe . setCommandline ( cmdl . getCommandline ( ) ) ; err = exe . execute ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , location ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( "Execute failed: " + e , e , location ) ; } finally { logFlush ( ) ; } } protected ExecuteStreamHandler createHandler ( ) throws BuildException { if ( out != null ) { try { fos = new FileOutputStream ( out ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; return new PumpStreamHandler ( fos ) ; } catch ( FileNotFoundException fne ) { throw new BuildException ( "Cannot write to " + out , fne , location ) ; } catch ( IOException ioe ) { throw new BuildException ( "Cannot write to " + out , ioe , location ) ; } } else { return new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( timeout == null ) return null ; return new ExecuteWatchdog ( timeout . intValue ( ) ) ; } protected void logFlush ( ) { try { if ( fos != null ) fos . close ( ) ; } catch ( IOException io ) { } } } 	0	['19', '3', '1', '18', '56', '97', '5', '13', '12', '0.814814815', '406', '1', '2', '0.672727273', '0.190789474', '0', '0', '19.89473684', '3', '1.0526', '0']
package org . apache . tools . mail ; import java . io . * ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . charAt ( 3 ) == '-' ; } private void append ( String line ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } 	0	['5', '1', '0', '1', '18', '0', '1', '0', '3', '0.5', '96', '1', '0', '0', '0.533333333', '0', '0', '17.8', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . lang . reflect . * ; import java . util . * ; public class Java extends Task { private CommandlineJava cmdl = new CommandlineJava ( ) ; private boolean fork = false ; private File dir = null ; private File out ; private boolean failOnError = false ; public void execute ( ) throws BuildException { int err = - 1 ; if ( ( err = executeJava ( ) ) != 0 ) { if ( failOnError ) { throw new BuildException ( "Java returned: " + err , location ) ; } else { log ( "Java Result: " + err , Project . MSG_ERR ) ; } } } public int executeJava ( ) throws BuildException { String classname = cmdl . getClassname ( ) ; if ( classname == null ) { throw new BuildException ( "Classname must not be null." ) ; } if ( fork ) { log ( "Forking " + cmdl . toString ( ) , Project . MSG_VERBOSE ) ; return run ( cmdl . getCommandline ( ) ) ; } else { if ( cmdl . getVmCommand ( ) . size ( ) > 1 ) { log ( "JVM args ignored when same JVM is used." , Project . MSG_WARN ) ; } if ( dir != null ) { log ( "Working directory ignored when same JVM is used." , Project . MSG_WARN ) ; } log ( "Running in same VM " + cmdl . getJavaCommand ( ) . toString ( ) , Project . MSG_VERBOSE ) ; run ( cmdl ) ; return 0 ; } } public void setClasspath ( Path s ) { createClasspath ( ) . append ( s ) ; } public Path createClasspath ( ) { return cmdl . createClasspath ( project ) . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setClassname ( String s ) { cmdl . setClassname ( s ) ; } public void setArgs ( String s ) { log ( "The args attribute is deprecated. " + "Please use nested arg elements." , Project . MSG_WARN ) ; cmdl . createArgument ( ) . setLine ( s ) ; } public Commandline . Argument createArg ( ) { return cmdl . createArgument ( ) ; } public void setFork ( boolean s ) { this . fork = s ; } public void setJvmargs ( String s ) { log ( "The jvmargs attribute is deprecated. " + "Please use nested jvmarg elements." , Project . MSG_WARN ) ; cmdl . createVmArgument ( ) . setLine ( s ) ; } public Commandline . Argument createJvmarg ( ) { return cmdl . createVmArgument ( ) ; } public void setJvm ( String s ) { cmdl . setVm ( s ) ; } public void addSysproperty ( Environment . Variable sysp ) { cmdl . addSysproperty ( sysp ) ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void setDir ( File d ) { this . dir = d ; } public void setOutput ( File out ) { this . out = out ; } public void setMaxmemory ( String max ) { if ( Project . getJavaVersion ( ) . startsWith ( "1.1" ) ) { createJvmarg ( ) . setValue ( "-mx" + max ) ; } else { createJvmarg ( ) . setValue ( "-Xmx" + max ) ; } } private void run ( CommandlineJava command ) throws BuildException { ExecuteJava exe = new ExecuteJava ( ) ; exe . setJavaCommand ( command . getJavaCommand ( ) ) ; exe . setClasspath ( command . getClasspath ( ) ) ; exe . setSystemProperties ( command . getSystemProperties ( ) ) ; if ( out != null ) { try { exe . setOutput ( new PrintStream ( new FileOutputStream ( out ) ) ) ; } catch ( IOException io ) { throw new BuildException ( io , location ) ; } } exe . execute ( project ) ; } private int run ( String [ ] command ) throws BuildException { FileOutputStream fos = null ; try { Execute exe = null ; if ( out == null ) { exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; } else { fos = new FileOutputStream ( out ) ; exe = new Execute ( new PumpStreamHandler ( fos ) , null ) ; } exe . setAntRun ( project ) ; if ( dir == null ) { dir = project . getBaseDir ( ) ; } else if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new BuildException ( dir . getAbsolutePath ( ) + " is not a valid directory" , location ) ; } exe . setWorkingDirectory ( dir ) ; exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , location ) ; } } catch ( IOException io ) { throw new BuildException ( io , location ) ; } finally { if ( fos != null ) { try { fos . close ( ) ; } catch ( IOException io ) { } } } } protected void run ( String classname , Vector args ) throws BuildException { CommandlineJava cmdj = new CommandlineJava ( ) ; cmdj . setClassname ( classname ) ; for ( int i = 0 ; i < args . size ( ) ; i ++ ) { cmdj . createArgument ( ) . setValue ( ( String ) args . elementAt ( i ) ) ; } run ( cmdj ) ; } public void clearArgs ( ) { cmdl . clearJavaArgs ( ) ; } } 	0	['22', '3', '0', '17', '77', '95', '0', '17', '19', '0.742857143', '439', '1', '1', '0.637931034', '0.172727273', '1', '1', '18.72727273', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . Vector ; import java . util . StringTokenizer ; public class Commandline implements Cloneable { private Vector arguments = new Vector ( ) ; private String executable = null ; public Commandline ( String to_process ) { super ( ) ; String [ ] tmp = translateCommandline ( to_process ) ; if ( tmp != null && tmp . length > 0 ) { setExecutable ( tmp [ 0 ] ) ; for ( int i = 1 ; i < tmp . length ; i ++ ) { createArgument ( ) . setValue ( tmp [ i ] ) ; } } } public Commandline ( ) { super ( ) ; } public class Argument { private String [ ] parts ; public void setValue ( String value ) { parts = new String [ ] { value } ; } public void setLine ( String line ) { parts = translateCommandline ( line ) ; } public void setPath ( Path value ) { parts = new String [ ] { value . toString ( ) } ; } public void setFile ( File value ) { parts = new String [ ] { value . getAbsolutePath ( ) } ; } public String [ ] getParts ( ) { return parts ; } } public class Marker { private int position ; private int realPos = - 1 ; Marker ( int position ) { this . position = position ; } public int getPosition ( ) { if ( realPos == - 1 ) { realPos = ( executable == null ? 0 : 1 ) ; for ( int i = 0 ; i < position ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; realPos += arg . getParts ( ) . length ; } } return realPos ; } } public Argument createArgument ( ) { Argument argument = new Argument ( ) ; arguments . addElement ( argument ) ; return argument ; } public void setExecutable ( String executable ) { if ( executable == null || executable . length ( ) == 0 ) return ; this . executable = executable . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; } public String getExecutable ( ) { return executable ; } public void addArguments ( String [ ] line ) { for ( int i = 0 ; i < line . length ; i ++ ) { createArgument ( ) . setValue ( line [ i ] ) ; } } public String [ ] getCommandline ( ) { final String [ ] args = getArguments ( ) ; if ( executable == null ) return args ; final String [ ] result = new String [ args . length + 1 ] ; result [ 0 ] = executable ; System . arraycopy ( args , 0 , result , 1 , args . length ) ; return result ; } public String [ ] getArguments ( ) { Vector result = new Vector ( arguments . size ( ) * 2 ) ; for ( int i = 0 ; i < arguments . size ( ) ; i ++ ) { Argument arg = ( Argument ) arguments . elementAt ( i ) ; String [ ] s = arg . getParts ( ) ; for ( int j = 0 ; j < s . length ; j ++ ) { result . addElement ( s [ j ] ) ; } } String [ ] res = new String [ result . size ( ) ] ; result . copyInto ( res ) ; return res ; } public String toString ( ) { return toString ( getCommandline ( ) ) ; } public static String quoteArgument ( String argument ) { if ( argument . indexOf ( "\"" ) > - 1 ) { if ( argument . indexOf ( "\'" ) > - 1 ) { throw new BuildException ( "Can\'t handle single and double quotes in same argument" ) ; } else { return '\'' + argument + '\'' ; } } else if ( argument . indexOf ( "\'" ) > - 1 || argument . indexOf ( " " ) > - 1 ) { return '\"' + argument + '\"' ; } else { return argument ; } } public static String toString ( String [ ] line ) { if ( line == null || line . length == 0 ) return "" ; final StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ; i ++ ) { if ( i > 0 ) { result . append ( ' ' ) ; } result . append ( quoteArgument ( line [ i ] ) ) ; } return result . toString ( ) ; } public static String [ ] translateCommandline ( String to_process ) { if ( to_process == null || to_process . length ( ) == 0 ) { return new String [ 0 ] ; } final int normal = 0 ; final int inQuote = 1 ; final int inDoubleQuote = 2 ; int state = normal ; StringTokenizer tok = new StringTokenizer ( to_process , "\"\' " , true ) ; Vector v = new Vector ( ) ; StringBuffer current = new StringBuffer ( ) ; while ( tok . hasMoreTokens ( ) ) { String nextTok = tok . nextToken ( ) ; switch ( state ) { case inQuote : if ( "\'" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; case inDoubleQuote : if ( "\"" . equals ( nextTok ) ) { state = normal ; } else { current . append ( nextTok ) ; } break ; default : if ( "\'" . equals ( nextTok ) ) { state = inQuote ; } else if ( "\"" . equals ( nextTok ) ) { state = inDoubleQuote ; } else if ( " " . equals ( nextTok ) ) { if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; current . setLength ( 0 ) ; } } else { current . append ( nextTok ) ; } break ; } } if ( current . length ( ) != 0 ) { v . addElement ( current . toString ( ) ) ; } if ( state == inQuote || state == inDoubleQuote ) { throw new BuildException ( "unbalanced quotes in " + to_process ) ; } String [ ] args = new String [ v . size ( ) ] ; v . copyInto ( args ) ; return args ; } public int size ( ) { return getCommandline ( ) . length ; } public Object clone ( ) { Commandline c = new Commandline ( ) ; c . setExecutable ( executable ) ; c . addArguments ( getArguments ( ) ) ; return c ; } public void clear ( ) { executable = null ; arguments . removeAllElements ( ) ; } public void clearArgs ( ) { arguments . removeAllElements ( ) ; } public Marker createMarker ( ) { return new Marker ( arguments . size ( ) ) ; } } 	0	['19', '1', '0', '23', '46', '65', '22', '3', '17', '0.416666667', '448', '1', '0', '0', '0.289473684', '0', '0', '22.47368421', '16', '2.4211', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import java . io . * ; import java . util . zip . * ; public class Expand extends MatchingTask { private File dest ; private File source ; public void execute ( ) throws BuildException { if ( "expand" . equals ( taskType ) ) { log ( "!! expand is deprecated. Use unzip instead. !!" ) ; } Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; if ( source == null ) { throw new BuildException ( "Source attribute must be specified" ) ; } if ( dest == null ) { throw new BuildException ( "Dest attribute must be specified" ) ; } if ( source . isDirectory ( ) ) { DirectoryScanner ds = super . getDirectoryScanner ( source ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { File file = new File ( source , files [ i ] ) ; expandFile ( touch , file , dest ) ; } } else { expandFile ( touch , source , dest ) ; } } private void expandFile ( Touch touch , File srcF , File dir ) { ZipInputStream zis = null ; try { log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; zis = new ZipInputStream ( new FileInputStream ( srcF ) ) ; ZipEntry ze = null ; while ( ( ze = zis . getNextEntry ( ) ) != null ) { File f = new File ( dir , project . translatePath ( ze . getName ( ) ) ) ; try { log ( "expand-file " + ze . getName ( ) , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( ze . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = zis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( ze . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "Unable to expand to file " + f . getPath ( ) , Project . MSG_WARN ) ; } } log ( "expand complete" , Project . MSG_VERBOSE ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe ) ; } finally { if ( zis != null ) { try { zis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( File d ) { this . dest = d ; } public void setSrc ( File s ) { this . source = s ; } } 	0	['5', '4', '0', '8', '45', '6', '0', '8', '4', '0.75', '261', '1', '0', '0.951219512', '0.6', '4', '5', '50.8', '7', '2', '0']
package org . apache . tools . ant . util ; import java . io . * ; import org . w3c . dom . * ; public class DOMElementWriter { private static String lSep = System . getProperty ( "line.separator" ) ; private StringBuffer sb = new StringBuffer ( ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } out . write ( ">" ) ; boolean hasChildren = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : if ( ! hasChildren ) { out . write ( lSep ) ; hasChildren = true ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( ( ( Text ) child ) . getData ( ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; } } if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; } public String encode ( String value ) { sb . setLength ( 0 ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '1', '35', '4', '1', '0', '4', '0.583333333', '354', '1', '0', '0', '0.5', '0', '0', '69.2', '8', '3.2', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . tar . * ; import java . io . * ; public class Untar extends Task { private String dest ; private String source ; public void execute ( ) throws BuildException { Touch touch = ( Touch ) project . createTask ( "touch" ) ; touch . setOwningTarget ( target ) ; touch . setTaskName ( getTaskName ( ) ) ; touch . setLocation ( getLocation ( ) ) ; File srcF = project . resolveFile ( source ) ; TarInputStream tis = null ; try { if ( source == null ) { throw new BuildException ( "No source specified" , location ) ; } if ( ! srcF . exists ( ) ) { throw new BuildException ( "source " + srcF + " doesn't exist" , location ) ; } if ( dest == null ) { throw new BuildException ( "No destination specified" , location ) ; } File dir = project . resolveFile ( dest ) ; log ( "Expanding: " + srcF + " into " + dir , Project . MSG_INFO ) ; tis = new TarInputStream ( new FileInputStream ( srcF ) ) ; TarEntry te = null ; while ( ( te = tis . getNextEntry ( ) ) != null ) { try { File f = new File ( dir , project . translatePath ( te . getName ( ) ) ) ; log ( "expand-file " + te . getName ( ) , Project . MSG_VERBOSE ) ; File dirF = new File ( f . getParent ( ) ) ; dirF . mkdirs ( ) ; if ( te . isDirectory ( ) ) { f . mkdirs ( ) ; } else { byte [ ] buffer = new byte [ 1024 ] ; int length = 0 ; FileOutputStream fos = new FileOutputStream ( f ) ; while ( ( length = tis . read ( buffer ) ) >= 0 ) { fos . write ( buffer , 0 , length ) ; } fos . close ( ) ; } if ( project . getJavaVersion ( ) != Project . JAVA_1_1 ) { touch . setFile ( f ) ; touch . setMillis ( te . getModTime ( ) . getTime ( ) ) ; touch . touch ( ) ; } } catch ( FileNotFoundException ex ) { log ( "FileNotFoundException: " + te . getName ( ) , Project . MSG_WARN ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error while expanding " + srcF . getPath ( ) , ioe , location ) ; } finally { if ( tis != null ) { try { tis . close ( ) ; } catch ( IOException e ) { } } } } public void setDest ( String d ) { this . dest = d ; } public void setSrc ( String s ) { this . source = s ; } } 	0	['4', '3', '0', '8', '42', '2', '0', '8', '4', '0.666666667', '242', '1', '0', '0.925', '0.75', '2', '3', '59', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import java . io . * ; public class AntStructure extends Task { private final String lSep = System . getProperty ( "line.separator" ) ; private Hashtable visited = new Hashtable ( ) ; private File output ; public void setOutput ( File output ) { this . output = output ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , location ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "ISO8859_1" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } Enumeration dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; printHead ( out , dataTypes ) ; Vector tasks = new Vector ( ) ; Enumeration enum = project . getTaskDefinitions ( ) . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String taskName = ( String ) enum . nextElement ( ) ; tasks . addElement ( taskName ) ; } printTargetDecl ( out , tasks ) ; dataTypes = project . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printElementDecl ( out , typeName , ( Class ) project . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { String taskName = ( String ) tasks . elementAt ( i ) ; printElementDecl ( out , taskName , ( Class ) project . getTaskDefinitions ( ) . get ( taskName ) ) ; } printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , location ) ; } finally { if ( out != null ) { out . close ( ) ; } } } private void printHead ( PrintWriter out , Enumeration enum ) { out . println ( "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | property | taskdef" ) ; while ( enum . hasMoreElements ( ) ) { String typeName = ( String ) enum . nextElement ( ) ; out . print ( " | " + typeName ) ; } out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #REQUIRED" ) ; out . println ( "          default CDATA #REQUIRED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printTargetDecl ( PrintWriter out , Vector tasks ) { out . print ( "<!ELEMENT target (" ) ; for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { String taskName = ( String ) tasks . elementAt ( i ) ; if ( i > 0 ) { out . print ( " | " ) ; } out . print ( taskName ) ; } out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } private void printElementDecl ( PrintWriter out , String name , Class element ) throws BuildException { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( element ) ; StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( lSep ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; sb . append ( lSep ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } Enumeration enum = ih . getNestedElements ( ) ; while ( enum . hasMoreElements ( ) ) { v . addElement ( ( String ) enum . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( v . size ( ) > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb . setLength ( 0 ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( lSep ) . append ( "          id ID #IMPLIED" ) ; enum = ih . getAttributes ( ) ; while ( enum . hasMoreElements ( ) ) { String attrName = ( String ) enum . nextElement ( ) ; if ( "id" . equals ( attrName ) ) continue ; sb . append ( lSep ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( "%boolean; " ) ; } else if ( org . apache . tools . ant . types . Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( org . apache . tools . ant . types . EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( lSep ) ; out . println ( sb ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) ) { printElementDecl ( out , nestedName , ih . getElementType ( nestedName ) ) ; } } } private void printTail ( PrintWriter out ) { } } 	0	['8', '3', '0', '6', '55', '24', '0', '6', '3', '0.80952381', '643', '0.5', '0', '0.840909091', '0.303571429', '0', '0', '78.625', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; public interface XSLTLiaison { public void setStylesheet ( String fileName ) throws Exception ; public void addParam ( String name , String expression ) throws Exception ; public void transform ( String infile , String outfile ) throws Exception ; } 	0	['3', '1', '0', '1', '3', '3', '1', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; public class PumpStreamHandler implements ExecuteStreamHandler { private Thread inputThread ; private Thread errorThread ; private OutputStream out , err ; public PumpStreamHandler ( OutputStream out , OutputStream err ) { this . out = out ; this . err = err ; } public PumpStreamHandler ( OutputStream outAndErr ) { this ( outAndErr , outAndErr ) ; } public PumpStreamHandler ( ) { this ( System . out , System . err ) ; } public void setProcessOutputStream ( InputStream is ) { createProcessOutputPump ( is , out ) ; } public void setProcessErrorStream ( InputStream is ) { createProcessErrorPump ( is , err ) ; } public void setProcessInputStream ( OutputStream os ) { } public void start ( ) { inputThread . start ( ) ; errorThread . start ( ) ; } public void stop ( ) { try { inputThread . join ( ) ; } catch ( InterruptedException e ) { } try { errorThread . join ( ) ; } catch ( InterruptedException e ) { } } protected void createProcessOutputPump ( InputStream is , OutputStream os ) { inputThread = createPump ( is , os ) ; } protected void createProcessErrorPump ( InputStream is , OutputStream os ) { errorThread = createPump ( is , os ) ; } protected Thread createPump ( InputStream is , OutputStream os ) { final Thread result = new Thread ( new StreamPumper ( is , os ) ) ; result . setDaemon ( true ) ; return result ; } } 	0	['11', '1', '1', '8', '17', '41', '6', '2', '8', '0.7', '93', '1', '0', '0', '0.666666667', '0', '0', '7.090909091', '1', '0.7273', '0']
package org . apache . tools . ant ; import java . util . * ; import java . io . * ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { tokenizer = new StringTokenizer ( path , ":;" , false ) ; dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } return token ; } } 	0	['3', '1', '0', '2', '15', '0', '2', '0', '3', '0.166666667', '100', '1', '0', '0', '0.666666667', '0', '0', '31.33333333', '2', '1', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; public class DesirableFilter implements FilenameFilter { public boolean accept ( File dir , String name ) { if ( name . endsWith ( "~" ) ) { return false ; } if ( name . startsWith ( "#" ) && name . endsWith ( "#" ) ) { return false ; } if ( name . startsWith ( "%" ) && name . endsWith ( "%" ) ) { return false ; } if ( name . equals ( "CVS" ) ) { return false ; } if ( name . equals ( ".cvsignore" ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '0', '6', '1', '0', '0', '2', '2', '45', '0', '0', '0', '0.666666667', '0', '0', '21.5', '8', '4', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . Commandline ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private String name ; private String path ; private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) return string ; final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname both " + "as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( project . getJavaVersion ( ) . equals ( Project . JAVA_1_1 ) ) { throw new BuildException ( "The genkey task is only available on JDK" + " versions 1.2 or greater" ) ; } if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "keytool -genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = ( ExecTask ) project . createTask ( "exec" ) ; cmd . setCommand ( new Commandline ( sb . toString ( ) ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '6', '33', '65', '0', '6', '14', '0.91025641', '404', '1', '1', '0.74', '0.595238095', '2', '3', '27', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . FileInputStream ; import org . apache . tools . ant . * ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or only a filtersFile parameter is required" , location ) ; } if ( isSingleFilter ) { project . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; FileInputStream in = null ; try { Properties props = new Properties ( ) ; in = new FileInputStream ( filtersFile ) ; props . load ( in ) ; Project proj = getProject ( ) ; Enumeration enum = props . propertyNames ( ) ; while ( enum . hasMoreElements ( ) ) { String strPropName = ( String ) enum . nextElement ( ) ; String strValue = props . getProperty ( strPropName ) ; proj . addFilter ( strPropName , strValue ) ; } } catch ( Exception e ) { throw new BuildException ( "Could not read filters from file: " + filtersFile ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( java . io . IOException ioex ) { } } } } } 	0	['6', '3', '0', '4', '24', '5', '0', '4', '5', '0.733333333', '153', '1', '0', '0.880952381', '0.5', '0', '0', '24', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import java . io . * ; import java . util . * ; public class Chmod extends ExecuteOn { private FileSet defaultSet = new FileSet ( ) ; private boolean havePerm = false ; public Chmod ( ) { super . setExecutable ( "chmod" ) ; super . setParallel ( true ) ; } public void setFile ( File src ) { FileSet fs = new FileSet ( ) ; fs . setDir ( new File ( src . getParent ( ) ) ) ; fs . createInclude ( ) . setName ( src . getName ( ) ) ; addFileset ( fs ) ; } public void setDir ( File src ) { defaultSet . setDir ( src ) ; } public void setPerm ( String perm ) { createArg ( ) . setValue ( perm ) ; havePerm = true ; } public PatternSet . NameEntry createInclude ( ) { return defaultSet . createInclude ( ) ; } public PatternSet . NameEntry createExclude ( ) { return defaultSet . createExclude ( ) ; } public PatternSet createPatternSet ( ) { return defaultSet . createPatternSet ( ) ; } public void setIncludes ( String includes ) { defaultSet . setIncludes ( includes ) ; } public void setExcludes ( String excludes ) { defaultSet . setExcludes ( excludes ) ; } public void setDefaultexcludes ( boolean useDefaultExcludes ) { defaultSet . setDefaultexcludes ( useDefaultExcludes ) ; } protected void checkConfiguration ( ) { if ( ! havePerm ) { throw new BuildException ( "Required attribute perm not set in chmod" , location ) ; } if ( defaultSet . getDir ( project ) != null ) { addFileset ( defaultSet ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( taskType + " doesn\'t support the executable attribute" , location ) ; } public void setCommand ( String e ) { throw new BuildException ( taskType + " doesn\'t support the command attribute" , location ) ; } protected boolean isValidOs ( ) { return System . getProperty ( "path.separator" ) . equals ( ":" ) && ( ! System . getProperty ( "os.name" ) . startsWith ( "Mac" ) || System . getProperty ( "os.name" ) . endsWith ( "X" ) ) && super . isValidOs ( ) ; } } 	0	['14', '5', '0', '10', '43', '15', '0', '10', '12', '0.615384615', '168', '1', '1', '0.891666667', '0.392857143', '3', '5', '10.85714286', '5', '1.3571', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; import java . io . * ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; public class Javac12 extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; try { OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; Class c = Class . forName ( "sun.tools.javac.Main" ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler, as it is not available" + " A common solution is to set the environment variable" + " JAVA_HOME to your jdk directory." , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } } } 	0	['3', '2', '0', '8', '18', '3', '1', '7', '2', '1', '132', '0', '0', '0.92', '0.5', '0', '0', '42', '1', '0.6667', '0']
package org . apache . tools . ant ; public abstract class Task { protected Project project = null ; protected Target target = null ; protected String description = null ; protected Location location = Location . UNKNOWN_LOCATION ; protected String taskName = null ; protected String taskType = null ; protected RuntimeConfigurable wrapper ; void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } void setTaskType ( String type ) { this . taskType = type ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { project . log ( this , msg , msgLevel ) ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this ) ; } return wrapper ; } protected void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( wrapper != null ) { wrapper . maybeConfigure ( project ) ; } } } 	0	['19', '1', '34', '78', '23', '119', '75', '5', '16', '0.873015873', '125', '1', '4', '0', '0.218045113', '0', '0', '5.210526316', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . * ; import org . apache . tools . ant . types . * ; import org . apache . tools . ant . util . * ; import java . io . * ; import java . util . Enumeration ; import java . util . Date ; import java . util . Vector ; public class UpToDate extends MatchingTask { private String _property ; private File _targetFile ; private Vector sourceFileSets = new Vector ( ) ; protected Mapper mapperElement = null ; public void setProperty ( String property ) { _property = property ; } public void setTargetFile ( File file ) { _targetFile = file ; } public void addSrcfiles ( FileSet fs ) { sourceFileSets . addElement ( fs ) ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" , location ) ; } mapperElement = new Mapper ( project ) ; return mapperElement ; } public void execute ( ) throws BuildException { if ( sourceFileSets . size ( ) == 0 ) { throw new BuildException ( "At least one <srcfiles> element must be set" ) ; } if ( _targetFile == null && mapperElement == null ) { throw new BuildException ( "The targetfile attribute or a nested mapper element must be set" ) ; } if ( _targetFile != null && ! _targetFile . exists ( ) ) return ; Enumeration enum = sourceFileSets . elements ( ) ; boolean upToDate = true ; while ( upToDate && enum . hasMoreElements ( ) ) { FileSet fs = ( FileSet ) enum . nextElement ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; upToDate = upToDate && scanDir ( fs . getDir ( project ) , ds . getIncludedFiles ( ) ) ; } if ( upToDate ) { this . project . setProperty ( _property , "true" ) ; if ( mapperElement == null ) { log ( "File \"" + _targetFile . getAbsolutePath ( ) + "\" is up to date." , Project . MSG_VERBOSE ) ; } else { log ( "All target files have been up to date." , Project . MSG_VERBOSE ) ; } } } protected boolean scanDir ( File srcDir , String files [ ] ) { SourceFileScanner sfs = new SourceFileScanner ( this ) ; FileNameMapper mapper = null ; if ( mapperElement == null ) { MergingMapper mm = new MergingMapper ( ) ; mm . setTo ( _targetFile . getAbsolutePath ( ) ) ; mapper = mm ; } else { mapper = mapperElement . getImplementation ( ) ; } return sfs . restrict ( files , srcDir , null , mapper ) . length == 0 ; } } 	0	['7', '4', '0', '11', '32', '0', '0', '11', '6', '0.666666667', '189', '1', '1', '0.928571429', '0.342857143', '1', '1', '25.42857143', '3', '1.1429', '0']
package org . apache . tools . ant ; import java . lang . reflect . * ; import java . util . * ; public class TaskAdapter extends Task { Object proxy ; public void execute ( ) throws BuildException { Method executeM = null ; try { Class c = proxy . getClass ( ) ; executeM = c . getMethod ( "execute" , new Class [ 0 ] ) ; if ( executeM == null ) { log ( "No execute in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( "No execute in " + proxy . getClass ( ) ) ; } executeM . invoke ( proxy , null ) ; return ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return this . proxy ; } } 	0	['4', '3', '0', '6', '15', '0', '4', '2', '4', '0.333333333', '82', '0', '0', '0.925', '0.625', '1', '1', '19.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . * ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , location ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , location ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , location ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration enum = filecopyList . keys ( ) ; while ( enum . hasMoreElements ( ) ) { String fromFile = ( String ) enum . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { project . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , location ) ; } } } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '6', '35', '4', '0', '6', '7', '0.714285714', '265', '1', '0', '0.917647059', '0.46875', '3', '3', '31.375', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs ; import java . io . * ; import java . util . * ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . * ; public class Javadoc extends Task { public class DocletParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public class DocletInfo { private String name ; private Path path ; private Vector params = new Vector ( ) ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setPath ( Path path ) { if ( this . path == null ) { this . path = path ; } else { this . path . append ( path ) ; } } public Path getPath ( ) { return path ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public DocletParam createParam ( ) { DocletParam param = new DocletParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } } private Commandline cmd = new Commandline ( ) ; private static boolean javadoc1 = ( Project . getJavaVersion ( ) == Project . JAVA_1_1 ) ; private void addArgIf ( boolean b , String arg ) { if ( b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIfNotEmpty ( String key , String value ) { if ( ! javadoc1 ) { if ( value != null && value . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( key ) ; cmd . createArgument ( ) . setValue ( value ) ; } else { project . log ( this , "Warning: Leaving out empty argument '" + key + "'" , Project . MSG_WARN ) ; } } } private void add11ArgIf ( boolean b , String arg ) { if ( javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private void add12ArgIf ( boolean b , String arg ) { if ( ! javadoc1 && b ) { cmd . createArgument ( ) . setValue ( arg ) ; } } private boolean foundJavaFile = false ; private boolean failOnError = false ; private Path sourcePath = null ; private File destDir = null ; private String sourceFiles = null ; private String packageNames = null ; private String excludePackageNames = null ; private boolean author = true ; private boolean version = true ; private DocletInfo doclet = null ; private Path classpath = null ; private Path bootclasspath = null ; private String group = null ; private Vector compileList = new Vector ( 10 ) ; private String packageList = null ; private Vector links = new Vector ( 2 ) ; private Vector groups = new Vector ( 2 ) ; private boolean useDefaultExcludes = true ; public void setDefaultexcludes ( boolean useDefaultExcludes ) { this . useDefaultExcludes = useDefaultExcludes ; } public void setMaxmemory ( String max ) { if ( javadoc1 ) { cmd . createArgument ( ) . setValue ( "-J-mx" + max ) ; } else { cmd . createArgument ( ) . setValue ( "-J-Xmx" + max ) ; } } public void setAdditionalparam ( String add ) { cmd . createArgument ( ) . setLine ( add ) ; } public void setSourcepath ( Path src ) { if ( sourcePath == null ) { sourcePath = src ; } else { sourcePath . append ( src ) ; } } public Path createSourcepath ( ) { if ( sourcePath == null ) { sourcePath = new Path ( project ) ; } return sourcePath . createPath ( ) ; } public void setSourcepathRef ( Reference r ) { createSourcepath ( ) . setRefid ( r ) ; } public void setDestdir ( File dir ) { destDir = dir ; cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } public void setSourcefiles ( String src ) { sourceFiles = src ; } public void setPackagenames ( String src ) { packageNames = src ; } public void setExcludePackageNames ( String src ) { excludePackageNames = src ; } public void setOverview ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-overview" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setPublic ( boolean b ) { addArgIf ( b , "-public" ) ; } public void setProtected ( boolean b ) { addArgIf ( b , "-protected" ) ; } public void setPackage ( boolean b ) { addArgIf ( b , "-package" ) ; } public void setPrivate ( boolean b ) { addArgIf ( b , "-private" ) ; } public void setDoclet ( String src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setName ( src ) ; } public void setDocletPath ( Path src ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . setPath ( src ) ; } public void setDocletPathRef ( Reference r ) { if ( doclet == null ) { doclet = new DocletInfo ( ) ; } doclet . createPath ( ) . setRefid ( r ) ; } public DocletInfo createDoclet ( ) { doclet = new DocletInfo ( ) ; return doclet ; } public void setOld ( boolean b ) { add12ArgIf ( b , "-1.1" ) ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( project ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( project ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public void setExtdirs ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setVerbose ( boolean b ) { add12ArgIf ( b , "-verbose" ) ; } public void setLocale ( String src ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-locale" ) ; cmd . createArgument ( ) . setValue ( src ) ; } } public void setEncoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setVersion ( boolean src ) { version = src ; } public void setUse ( boolean b ) { add12ArgIf ( b , "-use" ) ; } public void setAuthor ( boolean src ) { author = src ; } public void setSplitindex ( boolean b ) { add12ArgIf ( b , "-splitindex" ) ; } public void setWindowtitle ( String src ) { add12ArgIfNotEmpty ( "-windowtitle" , src ) ; } public void setDoctitle ( String src ) { add12ArgIfNotEmpty ( "-doctitle" , src ) ; } public void setHeader ( String src ) { add12ArgIfNotEmpty ( "-header" , src ) ; } public void setFooter ( String src ) { add12ArgIfNotEmpty ( "-footer" , src ) ; } public void setBottom ( String src ) { add12ArgIfNotEmpty ( "-bottom" , src ) ; } public void setLinkoffline ( String src ) { if ( ! javadoc1 ) { LinkArgument le = createLink ( ) ; le . setOffline ( true ) ; String linkOfflineError = "The linkoffline attribute must include a URL and " + "a package-list file location separated by a space" ; if ( src . trim ( ) . length ( ) == 0 ) { throw new BuildException ( linkOfflineError ) ; } StringTokenizer tok = new StringTokenizer ( src , " " , false ) ; le . setHref ( tok . nextToken ( ) ) ; if ( ! tok . hasMoreTokens ( ) ) { throw new BuildException ( linkOfflineError ) ; } le . setPackagelistLoc ( tok . nextToken ( ) ) ; } } public void setGroup ( String src ) { group = src ; } public void setLink ( String src ) { if ( ! javadoc1 ) { createLink ( ) . setHref ( src ) ; } } public void setNodeprecated ( boolean b ) { addArgIf ( b , "-nodeprecated" ) ; } public void setNodeprecatedlist ( boolean b ) { add12ArgIf ( b , "-nodeprecatedlist" ) ; } public void setNotree ( boolean b ) { addArgIf ( b , "-notree" ) ; } public void setNoindex ( boolean b ) { addArgIf ( b , "-noindex" ) ; } public void setNohelp ( boolean b ) { add12ArgIf ( b , "-nohelp" ) ; } public void setNonavbar ( boolean b ) { add12ArgIf ( b , "-nonavbar" ) ; } public void setSerialwarn ( boolean b ) { add12ArgIf ( b , "-serialwarn" ) ; } public void setStylesheetfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-stylesheetfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setHelpfile ( File f ) { if ( ! javadoc1 ) { cmd . createArgument ( ) . setValue ( "-helpfile" ) ; cmd . createArgument ( ) . setFile ( f ) ; } } public void setDocencoding ( String enc ) { cmd . createArgument ( ) . setValue ( "-docencoding" ) ; cmd . createArgument ( ) . setValue ( enc ) ; } public void setPackageList ( String src ) { packageList = src ; } public LinkArgument createLink ( ) { LinkArgument la = new LinkArgument ( ) ; links . addElement ( la ) ; return la ; } public class LinkArgument { private String href ; private boolean offline = false ; private String packagelistLoc ; public LinkArgument ( ) { } public void setHref ( String hr ) { href = hr ; } public String getHref ( ) { return href ; } public void setPackagelistLoc ( String src ) { packagelistLoc = src ; } public String getPackagelistLoc ( ) { return packagelistLoc ; } public void setOffline ( boolean offline ) { this . offline = offline ; } public boolean isLinkOffline ( ) { return offline ; } } public GroupArgument createGroup ( ) { GroupArgument ga = new GroupArgument ( ) ; groups . addElement ( ga ) ; return ga ; } public class GroupArgument { private String title ; private String packages ; public GroupArgument ( ) { } public void setTitle ( String src ) { title = src ; } public String getTitle ( ) { return title ; } public void setPackages ( String src ) { packages = src ; } public String getPackages ( ) { return packages ; } } public void setCharset ( String src ) { this . add12ArgIfNotEmpty ( "-charset" , src ) ; } public void setFailonerror ( boolean b ) { failOnError = b ; } public void execute ( ) throws BuildException { if ( "javadoc2" . equals ( taskType ) ) { log ( "!! javadoc2 is deprecated. Use javadoc instead. !!" ) ; } if ( sourcePath == null ) { String msg = "sourcePath attribute must be set!" ; throw new BuildException ( msg ) ; } log ( "Generating Javadoc" , Project . MSG_INFO ) ; Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "javadoc" ) ; if ( classpath == null ) classpath = Path . systemClasspath ; else classpath = classpath . concatSystemClasspath ( "ignore" ) ; if ( ! javadoc1 ) { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setPath ( classpath ) ; toExecute . createArgument ( ) . setValue ( "-sourcepath" ) ; toExecute . createArgument ( ) . setPath ( sourcePath ) ; } else { toExecute . createArgument ( ) . setValue ( "-classpath" ) ; toExecute . createArgument ( ) . setValue ( sourcePath . toString ( ) + System . getProperty ( "path.separator" ) + classpath . toString ( ) ) ; } if ( version && doclet == null ) toExecute . createArgument ( ) . setValue ( "-version" ) ; if ( author && doclet == null ) toExecute . createArgument ( ) . setValue ( "-author" ) ; if ( javadoc1 || doclet == null ) { if ( destDir == null ) { String msg = "destDir attribute must be set!" ; throw new BuildException ( msg ) ; } } if ( ! javadoc1 ) { if ( doclet != null ) { if ( doclet . getName ( ) == null ) { throw new BuildException ( "The doclet name must be specified." , location ) ; } else { toExecute . createArgument ( ) . setValue ( "-doclet" ) ; toExecute . createArgument ( ) . setValue ( doclet . getName ( ) ) ; if ( doclet . getPath ( ) != null ) { toExecute . createArgument ( ) . setValue ( "-docletpath" ) ; toExecute . createArgument ( ) . setPath ( doclet . getPath ( ) ) ; } for ( Enumeration e = doclet . getParams ( ) ; e . hasMoreElements ( ) ; ) { DocletParam param = ( DocletParam ) e . nextElement ( ) ; if ( param . getName ( ) == null ) { throw new BuildException ( "Doclet parameters must have a name" ) ; } toExecute . createArgument ( ) . setValue ( param . getName ( ) ) ; if ( param . getValue ( ) != null ) { toExecute . createArgument ( ) . setValue ( param . getValue ( ) ) ; } } } } if ( bootclasspath != null ) { toExecute . createArgument ( ) . setValue ( "-bootclasspath" ) ; toExecute . createArgument ( ) . setPath ( bootclasspath ) ; } if ( links . size ( ) != 0 ) { for ( Enumeration e = links . elements ( ) ; e . hasMoreElements ( ) ; ) { LinkArgument la = ( LinkArgument ) e . nextElement ( ) ; if ( la . getHref ( ) == null ) { throw new BuildException ( "Links must provide the URL to the external class documentation." ) ; } if ( la . isLinkOffline ( ) ) { String packageListLocation = la . getPackagelistLoc ( ) ; if ( packageListLocation == null ) { throw new BuildException ( "The package list location for link " + la . getHref ( ) + " must be provided because the link is offline" ) ; } toExecute . createArgument ( ) . setValue ( "-linkoffline" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; toExecute . createArgument ( ) . setValue ( packageListLocation ) ; } else { toExecute . createArgument ( ) . setValue ( "-link" ) ; toExecute . createArgument ( ) . setValue ( la . getHref ( ) ) ; } } } if ( group != null ) { StringTokenizer tok = new StringTokenizer ( group , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String grp = tok . nextToken ( ) . trim ( ) ; int space = grp . indexOf ( " " ) ; if ( space > 0 ) { String name = grp . substring ( 0 , space ) ; String pkgList = grp . substring ( space + 1 ) ; toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( name ) ; toExecute . createArgument ( ) . setValue ( pkgList ) ; } } } if ( groups . size ( ) != 0 ) { for ( Enumeration e = groups . elements ( ) ; e . hasMoreElements ( ) ; ) { GroupArgument ga = ( GroupArgument ) e . nextElement ( ) ; String title = ga . getTitle ( ) ; String packages = ga . getPackages ( ) ; if ( title == null || packages == null ) { throw new BuildException ( "The title and packages must be specified for group elements." ) ; } toExecute . createArgument ( ) . setValue ( "-group" ) ; toExecute . createArgument ( ) . setValue ( title ) ; toExecute . createArgument ( ) . setValue ( packages ) ; } } } if ( ( packageNames != null ) && ( packageNames . length ( ) > 0 ) ) { Vector packages = new Vector ( ) ; StringTokenizer tok = new StringTokenizer ( packageNames , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { String name = tok . nextToken ( ) . trim ( ) ; if ( name . endsWith ( ".*" ) ) { packages . addElement ( name ) ; } else { toExecute . createArgument ( ) . setValue ( name ) ; } } Vector excludePackages = new Vector ( ) ; if ( ( excludePackageNames != null ) && ( excludePackageNames . length ( ) > 0 ) ) { StringTokenizer exTok = new StringTokenizer ( excludePackageNames , "," , false ) ; while ( exTok . hasMoreTokens ( ) ) { excludePackages . addElement ( exTok . nextToken ( ) . trim ( ) ) ; } } if ( packages . size ( ) > 0 ) { evaluatePackages ( toExecute , sourcePath , packages , excludePackages ) ; } } if ( ( sourceFiles != null ) && ( sourceFiles . length ( ) > 0 ) ) { StringTokenizer tok = new StringTokenizer ( sourceFiles , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { toExecute . createArgument ( ) . setValue ( tok . nextToken ( ) . trim ( ) ) ; } } if ( packageList != null ) { toExecute . createArgument ( ) . setValue ( "@" + packageList ) ; } log ( "Javadoc args: " + toExecute , Project . MSG_VERBOSE ) ; log ( "Javadoc execution" , Project . MSG_INFO ) ; JavadocOutputStream out = new JavadocOutputStream ( Project . MSG_INFO ) ; JavadocOutputStream err = new JavadocOutputStream ( Project . MSG_WARN ) ; Execute exe = new Execute ( new PumpStreamHandler ( out , err ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; try { exe . setCommandline ( toExecute . getCommandline ( ) ) ; int ret = exe . execute ( ) ; if ( ret != 0 && failOnError ) { throw new BuildException ( "Javadoc returned " + ret , location ) ; } } catch ( IOException e ) { throw new BuildException ( "Javadoc failed: " + e , e , location ) ; } finally { out . logFlush ( ) ; err . logFlush ( ) ; try { out . close ( ) ; err . close ( ) ; } catch ( IOException e ) { } } } private void evaluatePackages ( Commandline toExecute , Path sourcePath , Vector packages , Vector excludePackages ) { log ( "Source path = " + sourcePath . toString ( ) , Project . MSG_VERBOSE ) ; log ( "Packages = " + packages , Project . MSG_VERBOSE ) ; log ( "Exclude Packages = " + excludePackages , Project . MSG_VERBOSE ) ; Vector addedPackages = new Vector ( ) ; String [ ] list = sourcePath . list ( ) ; if ( list == null ) list = new String [ 0 ] ; FileSet fs = new FileSet ( ) ; fs . setDefaultexcludes ( useDefaultExcludes ) ; Enumeration e = packages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createInclude ( ) . setName ( pkg ) ; } e = excludePackages . elements ( ) ; while ( e . hasMoreElements ( ) ) { String pkg = ( String ) e . nextElement ( ) ; pkg = pkg . replace ( '.' , '/' ) ; if ( pkg . endsWith ( "*" ) ) { pkg += "*" ; } fs . createExclude ( ) . setName ( pkg ) ; } for ( int j = 0 ; j < list . length ; j ++ ) { File source = project . resolveFile ( list [ j ] ) ; fs . setDir ( source ) ; DirectoryScanner ds = fs . getDirectoryScanner ( project ) ; String [ ] packageDirs = ds . getIncludedDirectories ( ) ; for ( int i = 0 ; i < packageDirs . length ; i ++ ) { File pd = new File ( source , packageDirs [ i ] ) ; String [ ] files = pd . list ( new FilenameFilter ( ) { public boolean accept ( File dir1 , String name ) { if ( name . endsWith ( ".java" ) ) { return true ; } return false ; } } ) ; if ( files . length > 0 ) { String pkgDir = packageDirs [ i ] . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; if ( ! addedPackages . contains ( pkgDir ) ) { toExecute . createArgument ( ) . setValue ( pkgDir ) ; addedPackages . addElement ( pkgDir ) ; } } } } } private class JavadocOutputStream extends LogOutputStream { JavadocOutputStream ( int level ) { super ( Javadoc . this , level ) ; } private String queuedLine = null ; protected void processLine ( String line , int messageLevel ) { if ( messageLevel == Project . MSG_INFO && line . startsWith ( "Generating " ) ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; } queuedLine = line ; } else { if ( queuedLine != null ) { if ( line . startsWith ( "Building " ) ) super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; else super . processLine ( queuedLine , Project . MSG_INFO ) ; queuedLine = null ; } super . processLine ( line , messageLevel ) ; } } protected void logFlush ( ) { if ( queuedLine != null ) { super . processLine ( queuedLine , Project . MSG_VERBOSE ) ; queuedLine = null ; } } } } 	0	['65', '3', '0', '21', '155', '1670', '6', '21', '59', '0.9171875', '1504', '1', '5', '0.37', '0.244140625', '3', '3', '21.83076923', '10', '1.5231', '0']
package org . apache . tools . ant ; import java . io . * ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String msg ) { super ( msg ) ; } public BuildException ( String msg , Throwable cause ) { super ( msg ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String msg , Location location ) { super ( msg ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { ps . println ( this ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { pw . println ( this ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['14', '4', '0', '99', '28', '0', '98', '1', '14', '0.384615385', '153', '1', '1', '0.65', '0.333333333', '1', '2', '9.785714286', '2', '0.6429', '0']
package org . apache . tools . ant ; public class NoBannerLogger extends DefaultLogger { protected String targetName ; public void targetStarted ( BuildEvent event ) { targetName = event . getTarget ( ) . getName ( ) ; } public void targetFinished ( BuildEvent event ) { targetName = null ; } public void messageLogged ( BuildEvent event ) { if ( event . getPriority ( ) > msgOutputLevel || null == event . getMessage ( ) || "" . equals ( event . getMessage ( ) . trim ( ) ) ) { return ; } if ( null != targetName ) { out . println ( lSep + targetName + ":" ) ; targetName = null ; } super . messageLogged ( event ) ; } } 	0	['4', '2', '0', '3', '16', '0', '0', '3', '4', '0.333333333', '59', '1', '0', '0.842105263', '0.875', '1', '1', '13.5', '5', '1.75', '0']
package org . apache . tools . mail ; import java . io . * ; import java . net . * ; import java . util . * ; public class MailMessage { String host ; String from ; Vector to , cc ; Hashtable headers ; MailPrintStream out ; SmtpResponseReader in ; Socket socket ; public MailMessage ( ) throws IOException { this ( "localhost" ) ; } public MailMessage ( String host ) throws IOException { this . host = host ; to = new Vector ( ) ; cc = new Vector ( ) ; headers = new Hashtable ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (jakarta.apache.org)" ) ; connect ( ) ; sendHelo ( ) ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { headers . put ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headers . put ( name , value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setToHeader ( ) { setHeader ( "To" , vectorToList ( to ) ) ; } void setCcHeader ( ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { Enumeration e = headers . keys ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String value = ( String ) headers . get ( name ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { sendDot ( ) ; sendQuit ( ) ; disconnect ( ) ; } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , 25 ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { 220 } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { 250 } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { 250 } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { 250 , 251 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { 354 } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { 250 } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { 221 } ; send ( "QUIT" , ok ) ; } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) out . close ( ) ; if ( in != null ) in . close ( ) ; if ( socket != null ) socket . close ( ) ; } } class MailPrintStream extends PrintStream { int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte buf [ ] , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['27', '1', '0', '3', '63', '297', '1', '2', '10', '0.778846154', '527', '0', '2', '0', '0.37962963', '0', '0', '18.22222222', '11', '1.4444', '0']
