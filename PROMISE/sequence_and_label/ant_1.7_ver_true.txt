package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ClasspathUtils ; import java . util . Locale ; public final class RmicAdapterFactory { public static final String ERROR_UNKNOWN_COMPILER = "Class not found: " ; public static final String ERROR_NOT_RMIC_ADAPTER = "Class of unexpected Type: " ; public static final String DEFAULT_COMPILER = "default" ; private RmicAdapterFactory ( ) { } public static RmicAdapter getRmic ( String rmicType , Task task ) throws BuildException { String compiler = rmicType . toLowerCase ( Locale . ENGLISH ) ; if ( DEFAULT_COMPILER . equals ( compiler ) || compiler . length ( ) == 0 ) { compiler = KaffeRmic . isAvailable ( ) ? KaffeRmic . COMPILER_NAME : SunRmic . COMPILER_NAME ; } if ( SunRmic . COMPILER_NAME . equals ( compiler ) ) { return new SunRmic ( ) ; } else if ( KaffeRmic . COMPILER_NAME . equals ( compiler ) ) { return new KaffeRmic ( ) ; } else if ( WLRmic . COMPILER_NAME . equals ( compiler ) ) { return new WLRmic ( ) ; } else if ( ForkingSunRmic . COMPILER_NAME . equals ( compiler ) ) { return new ForkingSunRmic ( ) ; } else if ( XNewRmic . COMPILER_NAME . equals ( compiler ) ) { return new XNewRmic ( ) ; } return resolveClassName ( rmicType ) ; } private static RmicAdapter resolveClassName ( String className ) throws BuildException { return ( RmicAdapter ) ClasspathUtils . newInstance ( className , RmicAdapterFactory . class . getClassLoader ( ) , RmicAdapter . class ) ; } } 	0	['3', '1', '0', '10', '18', '3', '1', '9', '1', '1.1', '106', '0', '0', '0', '0.444444444', '0', '0', '32.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . oro . text . perl . Perl5Util ; import java . util . ArrayList ; class FStatP4OutputHandler extends P4HandlerAdapter { private P4Fstat parent ; private ArrayList existing = new ArrayList ( ) ; private ArrayList nonExisting = new ArrayList ( ) ; private static Perl5Util util = new Perl5Util ( ) ; public FStatP4OutputHandler ( P4Fstat parent ) { this . parent = parent ; } public void process ( String line ) throws BuildException { if ( util . match ( "/^... clientFile (.+)$/" , line ) ) { String f = util . group ( 1 ) ; existing . add ( f ) ; } else if ( util . match ( "/^(.+) - no such file/" , line ) ) { String f = util . group ( 1 ) ; nonExisting . add ( f ) ; } parent . log ( parent . util . substitute ( "s/^.*: //" , line ) , Project . MSG_VERBOSE ) ; } public ArrayList getExisting ( ) { return existing ; } public ArrayList getNonExisting ( ) { return nonExisting ; } } 	0	['5', '2', '0', '4', '13', '0', '1', '4', '4', '0.625', '76', '1', '1', '0.7', '0.5', '0', '0', '13.4', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; public class OutErrSummaryJUnitResultFormatter extends SummaryJUnitResultFormatter { public OutErrSummaryJUnitResultFormatter ( ) { super ( ) ; setWithOutAndErr ( true ) ; } } 	0	['1', '2', '0', '1', '3', '0', '0', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; public abstract class P4HandlerAdapter implements P4Handler { String p4input = "" ; private PumpStreamHandler myHandler = null ; public void setOutput ( String p4Input ) { this . p4input = p4Input ; } public abstract void process ( String line ) ; public void start ( ) throws BuildException { if ( p4input != null && p4input . length ( ) > 0 ) { myHandler = new PumpStreamHandler ( new P4OutputStream ( this ) , new P4OutputStream ( this ) , new ByteArrayInputStream ( p4input . getBytes ( ) ) ) ; } else { myHandler = new PumpStreamHandler ( new P4OutputStream ( this ) , new P4OutputStream ( this ) ) ; } myHandler . setProcessInputStream ( os ) ; myHandler . setProcessErrorStream ( es ) ; myHandler . setProcessOutputStream ( is ) ; myHandler . start ( ) ; } public void stop ( ) { myHandler . stop ( ) ; } OutputStream os ; InputStream is ; InputStream es ; public void setProcessInputStream ( OutputStream os ) throws IOException { this . os = os ; } public void setProcessErrorStream ( InputStream is ) throws IOException { this . es = is ; } public void setProcessOutputStream ( InputStream is ) throws IOException { this . is = is ; } } 	0	['8', '1', '9', '13', '20', '12', '9', '4', '8', '0.8', '101', '0.2', '1', '0', '0.40625', '0', '0', '11', '1', '0.875', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; public abstract class ConstantCPInfo extends ConstantPoolEntry { private Object value ; protected ConstantCPInfo ( int tagValue , int entries ) { super ( tagValue , entries ) ; } public Object getValue ( ) { return value ; } public void setValue ( Object newValue ) { value = newValue ; } } 	0	['3', '2', '5', '7', '4', '1', '6', '1', '2', '0.5', '16', '1', '0', '0.75', '0.555555556', '0', '0', '4', '1', '0.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . util . FileUtils ; public class Date implements ResourceSelector { private static final String MILLIS_OR_DATETIME = "Either the millis or the datetime attribute must be set." ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Long millis = null ; private String dateTime = null ; private String pattern = null ; private TimeComparison when = TimeComparison . EQUAL ; private long granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; public synchronized void setMillis ( long m ) { millis = new Long ( m ) ; } public synchronized long getMillis ( ) { return millis == null ? - 1L : millis . longValue ( ) ; } public synchronized void setDateTime ( String s ) { dateTime = s ; millis = null ; } public synchronized String getDatetime ( ) { return dateTime ; } public synchronized void setGranularity ( long g ) { granularity = g ; } public synchronized long getGranularity ( ) { return granularity ; } public synchronized void setPattern ( String p ) { pattern = p ; } public synchronized String getPattern ( ) { return pattern ; } public synchronized void setWhen ( TimeComparison c ) { when = c ; } public synchronized TimeComparison getWhen ( ) { return when ; } public synchronized boolean isSelected ( Resource r ) { if ( dateTime == null && millis == null ) { throw new BuildException ( MILLIS_OR_DATETIME ) ; } if ( millis == null ) { DateFormat df = ( ( pattern == null ) ? DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) : new SimpleDateFormat ( pattern ) ) ; try { long m = df . parse ( dateTime ) . getTime ( ) ; if ( m < 0 ) { throw new BuildException ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } setMillis ( m ) ; } catch ( ParseException pe ) { throw new BuildException ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + ( pattern == null ? " MM/DD/YYYY HH:MM AM_PM" : pattern ) + " format." ) ; } } return when . evaluate ( r . getLastModified ( ) , millis . longValue ( ) , granularity ) ; } } 	0	['13', '1', '0', '7', '28', '20', '2', '5', '12', '0.80952381', '183', '1', '2', '0', '0.3', '0', '0', '12.53846154', '7', '1.3846', '0']
package org . apache . tools . ant . util . facade ; import java . util . Enumeration ; import java . util . Vector ; public class FacadeTaskHelper { private Vector args = new Vector ( ) ; private String userChoice ; private String magicValue ; private String defaultValue ; public FacadeTaskHelper ( String defaultValue ) { this ( defaultValue , null ) ; } public FacadeTaskHelper ( String defaultValue , String magicValue ) { this . defaultValue = defaultValue ; this . magicValue = magicValue ; } public void setMagicValue ( String magicValue ) { this . magicValue = magicValue ; } public void setImplementation ( String userChoice ) { this . userChoice = userChoice ; } public String getImplementation ( ) { return userChoice != null ? userChoice : ( magicValue != null ? magicValue : defaultValue ) ; } public String getExplicitChoice ( ) { return userChoice ; } public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . addElement ( arg ) ; } public String [ ] getArgs ( ) { Vector tmp = new Vector ( args . size ( ) ) ; for ( Enumeration e = args . elements ( ) ; e . hasMoreElements ( ) ; ) { ImplementationSpecificArgument arg = ( ( ImplementationSpecificArgument ) e . nextElement ( ) ) ; String [ ] curr = arg . getParts ( getImplementation ( ) ) ; for ( int i = 0 ; i < curr . length ; i ++ ) { tmp . addElement ( curr [ i ] ) ; } } String [ ] res = new String [ tmp . size ( ) ] ; tmp . copyInto ( res ) ; return res ; } public boolean hasBeenSet ( ) { return userChoice != null || magicValue != null ; } } 	0	['9', '1', '0', '5', '19', '8', '4', '1', '9', '0.53125', '119', '1', '0', '0', '0.518518519', '0', '0', '11.77777778', '3', '1.4444', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public class DepthSelector extends BaseExtendSelector { public int min = - 1 ; public int max = - 1 ; public static final String MIN_KEY = "min" ; public static final String MAX_KEY = "max" ; public DepthSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{depthselector min: " ) ; buf . append ( min ) ; buf . append ( " max: " ) ; buf . append ( max ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMin ( int min ) { this . min = min ; } public void setMax ( int max ) { this . max = max ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MIN_KEY . equalsIgnoreCase ( paramname ) ) { try { setMin ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid minimum value " + parameters [ i ] . getValue ( ) ) ; } } else if ( MAX_KEY . equalsIgnoreCase ( paramname ) ) { try { setMax ( Integer . parseInt ( parameters [ i ] . getValue ( ) ) ) ; } catch ( NumberFormatException nfe1 ) { setError ( "Invalid maximum value " + parameters [ i ] . getValue ( ) ) ; } } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( min < 0 && max < 0 ) { setError ( "You must set at least one of the min or the " + "max levels." ) ; } if ( max < min && max > - 1 ) { setError ( "The maximum depth is lower than the minimum." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int depth = - 1 ; String absBase = basedir . getAbsolutePath ( ) ; String absFile = file . getAbsolutePath ( ) ; StringTokenizer tokBase = new StringTokenizer ( absBase , File . separator ) ; StringTokenizer tokFile = new StringTokenizer ( absFile , File . separator ) ; while ( tokFile . hasMoreTokens ( ) ) { String filetoken = tokFile . nextToken ( ) ; if ( tokBase . hasMoreTokens ( ) ) { String basetoken = tokBase . nextToken ( ) ; if ( ! basetoken . equals ( filetoken ) ) { throw new BuildException ( "File " + filename + " does not appear within " + absBase + "directory" ) ; } } else { depth += 1 ; if ( max > - 1 && depth > max ) { return false ; } } } if ( tokBase . hasMoreTokens ( ) ) { throw new BuildException ( "File " + filename + " is outside of " + absBase + "directory tree" ) ; } if ( min > - 1 && depth < min ) { return false ; } return true ; } } 	0	['7', '5', '0', '9', '25', '0', '6', '3', '7', '0.666666667', '255', '0', '0', '0.863636364', '0.342857143', '2', '5', '34.85714286', '9', '3.1429', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; public class JSharp extends DotnetCompile { String baseAddress ; boolean pureJava = true ; boolean secureScoping = false ; public JSharp ( ) { setExecutable ( "vjc" ) ; } public void setBaseAddress ( String baseAddress ) { this . baseAddress = baseAddress ; } public void setPureJava ( boolean pureJava ) { this . pureJava = pureJava ; } public void setSecureScoping ( boolean secureScoping ) { this . secureScoping = secureScoping ; } public String getReferenceDelimiter ( ) { return ";" ; } public String getFileExtension ( ) { return ".java" ; } protected void addCompilerSpecificOptions ( NetCommand command ) { if ( pureJava ) { command . addArgument ( "/x:all" ) ; } if ( secureScoping ) { command . addArgument ( "/securescoping" ) ; } } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , true ) ; } protected void validate ( ) throws BuildException { super . validate ( ) ; if ( getDestFile ( ) == null ) { throw new BuildException ( "DestFile was not specified" ) ; } } } 	0	['9', '6', '0', '5', '17', '26', '0', '5', '6', '0.833333333', '71', '0', '0', '0.949367089', '0.333333333', '1', '4', '6.555555556', '3', '1.1111', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; public class LogStreamHandler extends PumpStreamHandler { public LogStreamHandler ( Task task , int outlevel , int errlevel ) { this ( ( ProjectComponent ) task , outlevel , errlevel ) ; } public LogStreamHandler ( ProjectComponent pc , int outlevel , int errlevel ) { super ( new LogOutputStream ( pc , outlevel ) , new LogOutputStream ( pc , errlevel ) ) ; } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '19', '10', '3', '14', '5', '3', '2', '38', '0', '0', '0.923076923', '0.583333333', '0', '0', '11.66666667', '1', '0.3333', '0']
package org . apache . tools . ant . input ; public interface InputHandler { void handleInput ( InputRequest request ) throws org . apache . tools . ant . BuildException ; } 	0	['1', '1', '0', '10', '1', '0', '8', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public final class JarMarker implements ZipExtraField { private static final ZipShort ID = new ZipShort ( 0xCAFE ) ; private static final ZipShort NULL = new ZipShort ( 0 ) ; private static final byte [ ] NO_BYTES = new byte [ 0 ] ; private static final JarMarker DEFAULT = new JarMarker ( ) ; public JarMarker ( ) { } public static JarMarker getInstance ( ) { return DEFAULT ; } public ZipShort getHeaderId ( ) { return ID ; } public ZipShort getLocalFileDataLength ( ) { return NULL ; } public ZipShort getCentralDirectoryLength ( ) { return NULL ; } public byte [ ] getLocalFileDataData ( ) { return NO_BYTES ; } public byte [ ] getCentralDirectoryData ( ) { return NO_BYTES ; } public void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException { if ( length != 0 ) { throw new ZipException ( "JarMarker doesn't expect any data" ) ; } } } 	0	['9', '1', '0', '3', '12', '20', '1', '2', '8', '0.8125', '54', '1', '3', '0', '0.375', '0', '0', '4.555555556', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkbl extends ClearCase { private String mComment = null ; private String mCfile = null ; private String mBaselineRootName = null ; private boolean mNwarn = false ; private boolean mIdentical = true ; private boolean mFull = false ; private boolean mNlabel = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKBL ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getBaselineRootName ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getIdentical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IDENTICAL ) ; } if ( getFull ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_FULL ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_INCREMENTAL ) ; } if ( getNlabel ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NLABEL ) ; } cmd . createArgument ( ) . setValue ( getBaselineRootName ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setBaselineRootName ( String baselineRootName ) { mBaselineRootName = baselineRootName ; } public String getBaselineRootName ( ) { return mBaselineRootName ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setIdentical ( boolean identical ) { mIdentical = identical ; } public boolean getIdentical ( ) { return mIdentical ; } public void setFull ( boolean full ) { mFull = full ; } public boolean getFull ( ) { return mFull ; } public void setNlabel ( boolean nlabel ) { mNlabel = nlabel ; } public boolean getNlabel ( ) { return mNlabel ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_IDENTICAL = "-identical" ; public static final String FLAG_INCREMENTAL = "-incremental" ; public static final String FLAG_FULL = "-full" ; public static final String FLAG_NLABEL = "-nlabel" ; } 	0	['19', '4', '0', '7', '40', '129', '0', '7', '16', '0.936507937', '252', '0.5', '0', '0.727272727', '0.381578947', '2', '3', '11.52631579', '6', '1.3158', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . types . resources . selectors . ResourceSelectorContainer ; public class Restrict extends ResourceSelectorContainer implements ResourceCollection { private BaseResourceCollectionWrapper w = new BaseResourceCollectionWrapper ( ) { protected Collection getCollection ( ) { ArrayList result = new ArrayList ( ) ; outer : for ( Iterator ri = w . getResourceCollection ( ) . iterator ( ) ; ri . hasNext ( ) ; ) { Resource r = ( Resource ) ri . next ( ) ; for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ! ( ( ResourceSelector ) ( i . next ( ) ) ) . isSelected ( r ) ) { continue outer ; } } result . add ( r ) ; } return result ; } } ; public synchronized void add ( ResourceCollection c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } w . add ( c ) ; } public synchronized void setCache ( boolean b ) { w . setCache ( b ) ; } public synchronized boolean isCache ( ) { return w . isCache ( ) ; } public synchronized void add ( ResourceSelector s ) { if ( s == null ) { return ; } super . add ( s ) ; FailFast . invalidate ( this ) ; } public final synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . iterator ( ) ; } dieOnCircularReference ( ) ; return w . iterator ( ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . size ( ) ; } dieOnCircularReference ( ) ; return w . size ( ) ; } public synchronized boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return ( ( Restrict ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } dieOnCircularReference ( ) ; return w . isFilesystemOnly ( ) ; } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } dieOnCircularReference ( ) ; return w . toString ( ) ; } } 	0	['10', '4', '2', '13', '26', '0', '7', '7', '9', '0.111111111', '110', '1', '1', '0.795454545', '0.26', '1', '1', '9.9', '3', '1.6', '0']
package org . apache . tools . ant ; import java . io . IOException ; import java . io . InputStream ; public class DemuxInputStream extends InputStream { private Project project ; public DemuxInputStream ( Project project ) { this . project = project ; } public int read ( ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; if ( project . demuxInput ( buffer , 0 , 1 ) == - 1 ) { return - 1 ; } return buffer [ 0 ] ; } public int read ( byte [ ] buffer , int offset , int length ) throws IOException { return project . demuxInput ( buffer , offset , length ) ; } } 	0	['3', '2', '0', '2', '5', '0', '1', '1', '3', '0', '34', '1', '1', '0.818181818', '0.5', '1', '2', '10', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . StringTokenizer ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . xml . sax . AttributeList ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class IPlanetEjbc { private static final int MIN_NUM_ARGS = 2 ; private static final int MAX_NUM_ARGS = 8 ; private static final int NUM_CLASSES_WITH_IIOP = 15 ; private static final int NUM_CLASSES_WITHOUT_IIOP = 9 ; private static final String ENTITY_BEAN = "entity" ; private static final String STATELESS_SESSION = "stateless" ; private static final String STATEFUL_SESSION = "stateful" ; private File stdDescriptor ; private File iasDescriptor ; private File destDirectory ; private String classpath ; private String [ ] classpathElements ; private boolean retainSource = false ; private boolean debugOutput = false ; private File iasHomeDir ; private SAXParser parser ; private EjbcHandler handler = new EjbcHandler ( ) ; private Hashtable ejbFiles = new Hashtable ( ) ; private String displayName ; public IPlanetEjbc ( File stdDescriptor , File iasDescriptor , File destDirectory , String classpath , SAXParser parser ) { this . stdDescriptor = stdDescriptor ; this . iasDescriptor = iasDescriptor ; this . destDirectory = destDirectory ; this . classpath = classpath ; this . parser = parser ; List elements = new ArrayList ( ) ; if ( classpath != null ) { StringTokenizer st = new StringTokenizer ( classpath , File . pathSeparator ) ; while ( st . hasMoreTokens ( ) ) { elements . add ( st . nextToken ( ) ) ; } classpathElements = ( String [ ] ) elements . toArray ( new String [ elements . size ( ) ] ) ; } } public void setRetainSource ( boolean retainSource ) { this . retainSource = retainSource ; } public void setDebugOutput ( boolean debugOutput ) { this . debugOutput = debugOutput ; } public void registerDTD ( String publicID , String location ) { handler . registerDTD ( publicID , location ) ; } public void setIasHomeDir ( File iasHomeDir ) { this . iasHomeDir = iasHomeDir ; } public Hashtable getEjbFiles ( ) { return ejbFiles ; } public String getDisplayName ( ) { return displayName ; } public String [ ] getCmpDescriptors ( ) { List returnList = new ArrayList ( ) ; EjbInfo [ ] ejbs = handler . getEjbs ( ) ; for ( int i = 0 ; i < ejbs . length ; i ++ ) { List descriptors = ( List ) ejbs [ i ] . getCmpDescriptors ( ) ; returnList . addAll ( descriptors ) ; } return ( String [ ] ) returnList . toArray ( new String [ returnList . size ( ) ] ) ; } public static void main ( String [ ] args ) { File stdDescriptor ; File iasDescriptor ; File destDirectory = null ; String classpath = null ; SAXParser parser = null ; boolean debug = false ; boolean retainSource = false ; IPlanetEjbc ejbc ; if ( ( args . length < MIN_NUM_ARGS ) || ( args . length > MAX_NUM_ARGS ) ) { usage ( ) ; return ; } stdDescriptor = new File ( args [ args . length - 2 ] ) ; iasDescriptor = new File ( args [ args . length - 1 ] ) ; for ( int i = 0 ; i < args . length - 2 ; i ++ ) { if ( args [ i ] . equals ( "-classpath" ) ) { classpath = args [ ++ i ] ; } else if ( args [ i ] . equals ( "-d" ) ) { destDirectory = new File ( args [ ++ i ] ) ; } else if ( args [ i ] . equals ( "-debug" ) ) { debug = true ; } else if ( args [ i ] . equals ( "-keepsource" ) ) { retainSource = true ; } else { usage ( ) ; return ; } } if ( classpath == null ) { Properties props = System . getProperties ( ) ; classpath = props . getProperty ( "java.class.path" ) ; } if ( destDirectory == null ) { Properties props = System . getProperties ( ) ; destDirectory = new File ( props . getProperty ( "user.dir" ) ) ; } SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; parserFactory . setValidating ( true ) ; try { parser = parserFactory . newSAXParser ( ) ; } catch ( Exception e ) { System . out . println ( "An exception was generated while trying to " ) ; System . out . println ( "create a new SAXParser." ) ; e . printStackTrace ( ) ; return ; } ejbc = new IPlanetEjbc ( stdDescriptor , iasDescriptor , destDirectory , classpath , parser ) ; ejbc . setDebugOutput ( debug ) ; ejbc . setRetainSource ( retainSource ) ; try { ejbc . execute ( ) ; } catch ( IOException e ) { System . out . println ( "An IOException has occurred while reading the " + "XML descriptors (" + e . getMessage ( ) + ")." ) ; return ; } catch ( SAXException e ) { System . out . println ( "A SAXException has occurred while reading the " + "XML descriptors (" + e . getMessage ( ) + ")." ) ; return ; } catch ( IPlanetEjbc . EjbcException e ) { System . out . println ( "An error has occurred while executing the ejbc " + "utility (" + e . getMessage ( ) + ")." ) ; return ; } } private static void usage ( ) { System . out . println ( "java org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbc \\" ) ; System . out . println ( "  [OPTIONS] [EJB 1.1 descriptor] [iAS EJB descriptor]" ) ; System . out . println ( "" ) ; System . out . println ( "Where OPTIONS are:" ) ; System . out . println ( "  -debug -- for additional debugging output" ) ; System . out . println ( "  -keepsource -- to retain Java source files generated" ) ; System . out . println ( "  -classpath [classpath] -- classpath used for compilation" ) ; System . out . println ( "  -d [destination directory] -- directory for compiled classes" ) ; System . out . println ( "" ) ; System . out . println ( "If a classpath is not specified, the system classpath" ) ; System . out . println ( "will be used.  If a destination directory is not specified," ) ; System . out . println ( "the current working directory will be used (classes will" ) ; System . out . println ( "still be placed in subfolders which correspond to their" ) ; System . out . println ( "package name)." ) ; System . out . println ( "" ) ; System . out . println ( "The EJB home interface, remote interface, and implementation" ) ; System . out . println ( "class must be found in the destination directory.  In" ) ; System . out . println ( "addition, the destination will look for the stubs and skeletons" ) ; System . out . println ( "in the destination directory to ensure they are up to date." ) ; } public void execute ( ) throws EjbcException , IOException , SAXException { checkConfiguration ( ) ; EjbInfo [ ] ejbs = getEjbs ( ) ; for ( int i = 0 ; i < ejbs . length ; i ++ ) { log ( "EJBInfo..." ) ; log ( ejbs [ i ] . toString ( ) ) ; } for ( int i = 0 ; i < ejbs . length ; i ++ ) { EjbInfo ejb = ejbs [ i ] ; ejb . checkConfiguration ( destDirectory ) ; if ( ejb . mustBeRecompiled ( destDirectory ) ) { log ( ejb . getName ( ) + " must be recompiled using ejbc." ) ; String [ ] arguments = buildArgumentList ( ejb ) ; callEjbc ( arguments ) ; } else { log ( ejb . getName ( ) + " is up to date." ) ; } } } private void callEjbc ( String [ ] arguments ) { StringBuffer args = new StringBuffer ( ) ; for ( int i = 0 ; i < arguments . length ; i ++ ) { args . append ( arguments [ i ] ) . append ( " " ) ; } String command ; if ( iasHomeDir == null ) { command = "" ; } else { command = iasHomeDir . toString ( ) + File . separator + "bin" + File . separator ; } command += "ejbc " ; log ( command + args ) ; try { Process p = Runtime . getRuntime ( ) . exec ( command + args ) ; RedirectOutput output = new RedirectOutput ( p . getInputStream ( ) ) ; RedirectOutput error = new RedirectOutput ( p . getErrorStream ( ) ) ; output . start ( ) ; error . start ( ) ; p . waitFor ( ) ; p . destroy ( ) ; } catch ( IOException e ) { log ( "An IOException has occurred while trying to execute ejbc." ) ; e . printStackTrace ( ) ; } catch ( InterruptedException e ) { } } protected void checkConfiguration ( ) throws EjbcException { String msg = "" ; if ( stdDescriptor == null ) { msg += "A standard XML descriptor file must be specified.  " ; } if ( iasDescriptor == null ) { msg += "An iAS-specific XML descriptor file must be specified.  " ; } if ( classpath == null ) { msg += "A classpath must be specified.    " ; } if ( parser == null ) { msg += "An XML parser must be specified.    " ; } if ( destDirectory == null ) { msg += "A destination directory must be specified.  " ; } else if ( ! destDirectory . exists ( ) ) { msg += "The destination directory specified does not exist.  " ; } else if ( ! destDirectory . isDirectory ( ) ) { msg += "The destination specified is not a directory.  " ; } if ( msg . length ( ) > 0 ) { throw new EjbcException ( msg ) ; } } private EjbInfo [ ] getEjbs ( ) throws IOException , SAXException { EjbInfo [ ] ejbs = null ; parser . parse ( stdDescriptor , handler ) ; parser . parse ( iasDescriptor , handler ) ; ejbs = handler . getEjbs ( ) ; return ejbs ; } private String [ ] buildArgumentList ( EjbInfo ejb ) { List arguments = new ArrayList ( ) ; if ( debugOutput ) { arguments . add ( "-debug" ) ; } if ( ejb . getBeantype ( ) . equals ( STATELESS_SESSION ) ) { arguments . add ( "-sl" ) ; } else if ( ejb . getBeantype ( ) . equals ( STATEFUL_SESSION ) ) { arguments . add ( "-sf" ) ; } if ( ejb . getIiop ( ) ) { arguments . add ( "-iiop" ) ; } if ( ejb . getCmp ( ) ) { arguments . add ( "-cmp" ) ; } if ( retainSource ) { arguments . add ( "-gs" ) ; } if ( ejb . getHasession ( ) ) { arguments . add ( "-fo" ) ; } arguments . add ( "-classpath" ) ; arguments . add ( classpath ) ; arguments . add ( "-d" ) ; arguments . add ( destDirectory . toString ( ) ) ; arguments . add ( ejb . getHome ( ) . getQualifiedClassName ( ) ) ; arguments . add ( ejb . getRemote ( ) . getQualifiedClassName ( ) ) ; arguments . add ( ejb . getImplementation ( ) . getQualifiedClassName ( ) ) ; return ( String [ ] ) arguments . toArray ( new String [ arguments . size ( ) ] ) ; } private void log ( String msg ) { if ( debugOutput ) { System . out . println ( msg ) ; } } public class EjbcException extends Exception { public EjbcException ( String msg ) { super ( msg ) ; } } private class EjbcHandler extends HandlerBase { private static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; private static final String PUBLICID_IPLANET_EJB_60 = "-//Sun Microsystems, Inc.//DTD iAS Enterprise JavaBeans 1.0//EN" ; private static final String DEFAULT_IAS60_EJB11_DTD_LOCATION = "ejb-jar_1_1.dtd" ; private static final String DEFAULT_IAS60_DTD_LOCATION = "IASEjb_jar_1_0.dtd" ; private Map resourceDtds = new HashMap ( ) ; private Map fileDtds = new HashMap ( ) ; private Map ejbs = new HashMap ( ) ; private EjbInfo currentEjb ; private boolean iasDescriptor = false ; private String currentLoc = "" ; private String currentText ; private String ejbType ; public EjbcHandler ( ) { registerDTD ( PUBLICID_EJB11 , DEFAULT_IAS60_EJB11_DTD_LOCATION ) ; registerDTD ( PUBLICID_IPLANET_EJB_60 , DEFAULT_IAS60_DTD_LOCATION ) ; } public EjbInfo [ ] getEjbs ( ) { return ( EjbInfo [ ] ) ejbs . values ( ) . toArray ( new EjbInfo [ ejbs . size ( ) ] ) ; } public String getDisplayName ( ) { return displayName ; } public void registerDTD ( String publicID , String location ) { log ( "Registering: " + location ) ; if ( ( publicID == null ) || ( location == null ) ) { return ; } if ( ClassLoader . getSystemResource ( location ) != null ) { log ( "Found resource: " + location ) ; resourceDtds . put ( publicID , location ) ; } else { File dtdFile = new File ( location ) ; if ( dtdFile . exists ( ) && dtdFile . isFile ( ) ) { log ( "Found file: " + location ) ; fileDtds . put ( publicID , location ) ; } } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { InputStream inputStream = null ; try { String location = ( String ) resourceDtds . get ( publicId ) ; if ( location != null ) { inputStream = ClassLoader . getSystemResource ( location ) . openStream ( ) ; } else { location = ( String ) fileDtds . get ( publicId ) ; if ( location != null ) { inputStream = new FileInputStream ( location ) ; } } } catch ( IOException e ) { return super . resolveEntity ( publicId , systemId ) ; } if ( inputStream == null ) { return super . resolveEntity ( publicId , systemId ) ; } else { return new InputSource ( inputStream ) ; } } public void startElement ( String name , AttributeList atts ) throws SAXException { currentLoc += "\\" + name ; currentText = "" ; if ( currentLoc . equals ( "\\ejb-jar" ) ) { iasDescriptor = false ; } else if ( currentLoc . equals ( "\\ias-ejb-jar" ) ) { iasDescriptor = true ; } if ( ( name . equals ( "session" ) ) || ( name . equals ( "entity" ) ) ) { ejbType = name ; } } public void characters ( char [ ] ch , int start , int len ) throws SAXException { currentText += new String ( ch ) . substring ( start , start + len ) ; } public void endElement ( String name ) throws SAXException { if ( iasDescriptor ) { iasCharacters ( currentText ) ; } else { stdCharacters ( currentText ) ; } int nameLength = name . length ( ) + 1 ; int locLength = currentLoc . length ( ) ; currentLoc = currentLoc . substring ( 0 , locLength - nameLength ) ; } private void stdCharacters ( String value ) { if ( currentLoc . equals ( "\\ejb-jar\\display-name" ) ) { displayName = value ; return ; } String base = "\\ejb-jar\\enterprise-beans\\" + ejbType ; if ( currentLoc . equals ( base + "\\ejb-name" ) ) { currentEjb = ( EjbInfo ) ejbs . get ( value ) ; if ( currentEjb == null ) { currentEjb = new EjbInfo ( value ) ; ejbs . put ( value , currentEjb ) ; } } else if ( currentLoc . equals ( base + "\\home" ) ) { currentEjb . setHome ( value ) ; } else if ( currentLoc . equals ( base + "\\remote" ) ) { currentEjb . setRemote ( value ) ; } else if ( currentLoc . equals ( base + "\\ejb-class" ) ) { currentEjb . setImplementation ( value ) ; } else if ( currentLoc . equals ( base + "\\prim-key-class" ) ) { currentEjb . setPrimaryKey ( value ) ; } else if ( currentLoc . equals ( base + "\\session-type" ) ) { currentEjb . setBeantype ( value ) ; } else if ( currentLoc . equals ( base + "\\persistence-type" ) ) { currentEjb . setCmp ( value ) ; } } private void iasCharacters ( String value ) { String base = "\\ias-ejb-jar\\enterprise-beans\\" + ejbType ; if ( currentLoc . equals ( base + "\\ejb-name" ) ) { currentEjb = ( EjbInfo ) ejbs . get ( value ) ; if ( currentEjb == null ) { currentEjb = new EjbInfo ( value ) ; ejbs . put ( value , currentEjb ) ; } } else if ( currentLoc . equals ( base + "\\iiop" ) ) { currentEjb . setIiop ( value ) ; } else if ( currentLoc . equals ( base + "\\failover-required" ) ) { currentEjb . setHasession ( value ) ; } else if ( currentLoc . equals ( base + "\\persistence-manager" + "\\properties-file-location" ) ) { currentEjb . addCmpDescriptor ( value ) ; } } } private class EjbInfo { private String name ; private Classname home ; private Classname remote ; private Classname implementation ; private Classname primaryKey ; private String beantype = "entity" ; private boolean cmp = false ; private boolean iiop = false ; private boolean hasession = false ; private List cmpDescriptors = new ArrayList ( ) ; public EjbInfo ( String name ) { this . name = name ; } public String getName ( ) { if ( name == null ) { if ( implementation == null ) { return "[unnamed]" ; } else { return implementation . getClassName ( ) ; } } return name ; } public void setHome ( String home ) { setHome ( new Classname ( home ) ) ; } public void setHome ( Classname home ) { this . home = home ; } public Classname getHome ( ) { return home ; } public void setRemote ( String remote ) { setRemote ( new Classname ( remote ) ) ; } public void setRemote ( Classname remote ) { this . remote = remote ; } public Classname getRemote ( ) { return remote ; } public void setImplementation ( String implementation ) { setImplementation ( new Classname ( implementation ) ) ; } public void setImplementation ( Classname implementation ) { this . implementation = implementation ; } public Classname getImplementation ( ) { return implementation ; } public void setPrimaryKey ( String primaryKey ) { setPrimaryKey ( new Classname ( primaryKey ) ) ; } public void setPrimaryKey ( Classname primaryKey ) { this . primaryKey = primaryKey ; } public Classname getPrimaryKey ( ) { return primaryKey ; } public void setBeantype ( String beantype ) { this . beantype = beantype . toLowerCase ( ) ; } public String getBeantype ( ) { return beantype ; } public void setCmp ( boolean cmp ) { this . cmp = cmp ; } public void setCmp ( String cmp ) { setCmp ( cmp . equals ( "Container" ) ) ; } public boolean getCmp ( ) { return cmp ; } public void setIiop ( boolean iiop ) { this . iiop = iiop ; } public void setIiop ( String iiop ) { setIiop ( iiop . equals ( "true" ) ) ; } public boolean getIiop ( ) { return iiop ; } public void setHasession ( boolean hasession ) { this . hasession = hasession ; } public void setHasession ( String hasession ) { setHasession ( hasession . equals ( "true" ) ) ; } public boolean getHasession ( ) { return hasession ; } public void addCmpDescriptor ( String descriptor ) { cmpDescriptors . add ( descriptor ) ; } public List getCmpDescriptors ( ) { return cmpDescriptors ; } private void checkConfiguration ( File buildDir ) throws EjbcException { if ( home == null ) { throw new EjbcException ( "A home interface was not found " + "for the " + name + " EJB." ) ; } if ( remote == null ) { throw new EjbcException ( "A remote interface was not found " + "for the " + name + " EJB." ) ; } if ( implementation == null ) { throw new EjbcException ( "An EJB implementation class was not " + "found for the " + name + " EJB." ) ; } if ( ( ! beantype . equals ( ENTITY_BEAN ) ) && ( ! beantype . equals ( STATELESS_SESSION ) ) && ( ! beantype . equals ( STATEFUL_SESSION ) ) ) { throw new EjbcException ( "The beantype found (" + beantype + ") " + "isn't valid in the " + name + " EJB." ) ; } if ( cmp && ( ! beantype . equals ( ENTITY_BEAN ) ) ) { System . out . println ( "CMP stubs and skeletons may not be generated" + " for a Session Bean -- the \"cmp\" attribute will be" + " ignoredfor the " + name + " EJB." ) ; } if ( hasession && ( ! beantype . equals ( STATEFUL_SESSION ) ) ) { System . out . println ( "Highly available stubs and skeletons may " + "only be generated for a Stateful Session Bean -- the " + "\"hasession\" attribute will be ignored for the " + name + " EJB." ) ; } if ( ! remote . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The remote interface " + remote . getQualifiedClassName ( ) + " could not be " + "found." ) ; } if ( ! home . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The home interface " + home . getQualifiedClassName ( ) + " could not be " + "found." ) ; } if ( ! implementation . getClassFile ( buildDir ) . exists ( ) ) { throw new EjbcException ( "The EJB implementation class " + implementation . getQualifiedClassName ( ) + " could " + "not be found." ) ; } } public boolean mustBeRecompiled ( File destDir ) { long sourceModified = sourceClassesModified ( destDir ) ; long destModified = destClassesModified ( destDir ) ; return ( destModified < sourceModified ) ; } private long sourceClassesModified ( File buildDir ) { long latestModified ; long modified ; File remoteFile ; File homeFile ; File implFile ; File pkFile ; remoteFile = remote . getClassFile ( buildDir ) ; modified = remoteFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + remote . getQualifiedClassName ( ) + " couldn't " + "be found on the classpath" ) ; return - 1 ; } latestModified = modified ; homeFile = home . getClassFile ( buildDir ) ; modified = homeFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + home . getQualifiedClassName ( ) + " couldn't be " + "found on the classpath" ) ; return - 1 ; } latestModified = Math . max ( latestModified , modified ) ; if ( primaryKey != null ) { pkFile = primaryKey . getClassFile ( buildDir ) ; modified = pkFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + primaryKey . getQualifiedClassName ( ) + "couldn't be " + "found on the classpath" ) ; return - 1 ; } latestModified = Math . max ( latestModified , modified ) ; } else { pkFile = null ; } implFile = implementation . getClassFile ( buildDir ) ; modified = implFile . lastModified ( ) ; if ( modified == - 1 ) { System . out . println ( "The class " + implementation . getQualifiedClassName ( ) + " couldn't be found on the classpath" ) ; return - 1 ; } String pathToFile = remote . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , remoteFile ) ; pathToFile = home . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , homeFile ) ; pathToFile = implementation . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , implFile ) ; if ( pkFile != null ) { pathToFile = primaryKey . getQualifiedClassName ( ) ; pathToFile = pathToFile . replace ( '.' , File . separatorChar ) + ".class" ; ejbFiles . put ( pathToFile , pkFile ) ; } return latestModified ; } private long destClassesModified ( File destDir ) { String [ ] classnames = classesToGenerate ( ) ; long destClassesModified = new Date ( ) . getTime ( ) ; boolean allClassesFound = true ; for ( int i = 0 ; i < classnames . length ; i ++ ) { String pathToClass = classnames [ i ] . replace ( '.' , File . separatorChar ) + ".class" ; File classFile = new File ( destDir , pathToClass ) ; ejbFiles . put ( pathToClass , classFile ) ; allClassesFound = allClassesFound && classFile . exists ( ) ; if ( allClassesFound ) { long fileMod = classFile . lastModified ( ) ; destClassesModified = Math . min ( destClassesModified , fileMod ) ; } } return ( allClassesFound ) ? destClassesModified : - 1 ; } private String [ ] classesToGenerate ( ) { String [ ] classnames = ( iiop ) ? new String [ NUM_CLASSES_WITH_IIOP ] : new String [ NUM_CLASSES_WITHOUT_IIOP ] ; final String remotePkg = remote . getPackageName ( ) + "." ; final String remoteClass = remote . getClassName ( ) ; final String homePkg = home . getPackageName ( ) + "." ; final String homeClass = home . getClassName ( ) ; final String implPkg = implementation . getPackageName ( ) + "." ; final String implFullClass = implementation . getQualifiedWithUnderscores ( ) ; int index = 0 ; classnames [ index ++ ] = implPkg + "ejb_fac_" + implFullClass ; classnames [ index ++ ] = implPkg + "ejb_home_" + implFullClass ; classnames [ index ++ ] = implPkg + "ejb_skel_" + implFullClass ; classnames [ index ++ ] = remotePkg + "ejb_kcp_skel_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_kcp_skel_" + homeClass ; classnames [ index ++ ] = remotePkg + "ejb_kcp_stub_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_kcp_stub_" + homeClass ; classnames [ index ++ ] = remotePkg + "ejb_stub_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_stub_" + homeClass ; if ( ! iiop ) { return classnames ; } classnames [ index ++ ] = "org.omg.stub." + remotePkg + "_" + remoteClass + "_Stub" ; classnames [ index ++ ] = "org.omg.stub." + homePkg + "_" + homeClass + "_Stub" ; classnames [ index ++ ] = "org.omg.stub." + remotePkg + "_ejb_RmiCorbaBridge_" + remoteClass + "_Tie" ; classnames [ index ++ ] = "org.omg.stub." + homePkg + "_ejb_RmiCorbaBridge_" + homeClass + "_Tie" ; classnames [ index ++ ] = remotePkg + "ejb_RmiCorbaBridge_" + remoteClass ; classnames [ index ++ ] = homePkg + "ejb_RmiCorbaBridge_" + homeClass ; return classnames ; } public String toString ( ) { String s = "EJB name: " + name + "\n\r              home:      " + home + "\n\r              remote:    " + remote + "\n\r              impl:      " + implementation + "\n\r              primaryKey: " + primaryKey + "\n\r              beantype:  " + beantype + "\n\r              cmp:       " + cmp + "\n\r              iiop:      " + iiop + "\n\r              hasession: " + hasession ; Iterator i = cmpDescriptors . iterator ( ) ; while ( i . hasNext ( ) ) { s += "\n\r              CMP Descriptor: " + i . next ( ) ; } return s ; } } private static class Classname { private String qualifiedName ; private String packageName ; private String className ; public Classname ( String qualifiedName ) { if ( qualifiedName == null ) { return ; } this . qualifiedName = qualifiedName ; int index = qualifiedName . lastIndexOf ( '.' ) ; if ( index == - 1 ) { className = qualifiedName ; packageName = "" ; } else { packageName = qualifiedName . substring ( 0 , index ) ; className = qualifiedName . substring ( index + 1 ) ; } } public String getQualifiedClassName ( ) { return qualifiedName ; } public String getPackageName ( ) { return packageName ; } public String getClassName ( ) { return className ; } public String getQualifiedWithUnderscores ( ) { return qualifiedName . replace ( '.' , '_' ) ; } public File getClassFile ( File directory ) { String pathToFile = qualifiedName . replace ( '.' , File . separatorChar ) + ".class" ; return new File ( directory , pathToFile ) ; } public String toString ( ) { return getQualifiedClassName ( ) ; } } private static class RedirectOutput extends Thread { private InputStream stream ; public RedirectOutput ( InputStream stream ) { this . stream = stream ; } public void run ( ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; String text ; try { while ( ( text = reader . readLine ( ) ) != null ) { System . out . println ( text ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { reader . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['20', '1', '0', '7', '79', '136', '5', '5', '10', '0.897506925', '835', '1', '1', '0', '0.19375', '0', '0', '39.8', '10', '1.95', '0']
package org . apache . tools . zip ; import java . util . zip . ZipException ; public interface ZipExtraField { ZipShort getHeaderId ( ) ; ZipShort getLocalFileDataLength ( ) ; ZipShort getCentralDirectoryLength ( ) ; byte [ ] getLocalFileDataData ( ) ; byte [ ] getCentralDirectoryData ( ) ; void parseFromLocalFileData ( byte [ ] data , int offset , int length ) throws ZipException ; } 	0	['6', '1', '0', '8', '6', '15', '7', '1', '6', '2', '6', '0', '0', '0', '0.444444444', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . Project ; public class TypeFound extends ProjectComponent implements Condition { private String name ; private String uri ; public void setName ( String name ) { this . name = name ; } public void setURI ( String uri ) { this . uri = uri ; } protected boolean doesTypeExist ( String typename ) { ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( uri , typename ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { return false ; } boolean found = def . getExposedClass ( getProject ( ) ) != null ; if ( ! found ) { String text = helper . diagnoseCreationFailure ( componentName , "type" ) ; log ( text , Project . MSG_VERBOSE ) ; } return found ; } public boolean eval ( ) throws BuildException { if ( name == null ) { throw new BuildException ( "No type specified" ) ; } return doesTypeExist ( name ) ; } } 	0	['5', '2', '0', '7', '14', '6', '0', '7', '4', '0.625', '70', '1', '0', '0.692307692', '0.8', '0', '0', '12.6', '4', '1.4', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public interface P4OutputHandler { void process ( String line ) throws BuildException ; } 	0	['1', '1', '0', '1', '1', '0', '0', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintStream ; import java . io . PrintWriter ; import org . apache . tools . ant . ProjectComponent ; public class Message extends ProjectComponent { private File messageSource = null ; private StringBuffer buffer = new StringBuffer ( ) ; private String mimeType = "text/plain" ; private boolean specified = false ; private String charset = null ; public Message ( ) { } public Message ( String text ) { addText ( text ) ; } public Message ( File file ) { messageSource = file ; } public void addText ( String text ) { buffer . append ( text ) ; } public void setSrc ( File src ) { this . messageSource = src ; } public void setMimeType ( String mimeType ) { this . mimeType = mimeType ; specified = true ; } public String getMimeType ( ) { return mimeType ; } public void print ( PrintStream ps ) throws IOException { PrintWriter out = charset != null ? new PrintWriter ( new OutputStreamWriter ( ps , charset ) ) : new PrintWriter ( ps ) ; if ( messageSource != null ) { FileReader freader = new FileReader ( messageSource ) ; try { BufferedReader in = new BufferedReader ( freader ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( getProject ( ) . replaceProperties ( line ) ) ; } } finally { freader . close ( ) ; } } else { out . println ( getProject ( ) . replaceProperties ( buffer . substring ( 0 ) ) ) ; } out . flush ( ) ; } public boolean isMimeTypeSpecified ( ) { return specified ; } public void setCharset ( String charset ) { this . charset = charset ; } public String getCharset ( ) { return charset ; } } 	0	['11', '2', '0', '7', '26', '0', '5', '2', '11', '0.58', '181', '1', '0', '0.529411765', '0.409090909', '0', '0', '15', '1', '0.7273', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSCP extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CP ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['3', '4', '0', '5', '15', '3', '0', '5', '2', '2', '51', '0', '0', '0.978494624', '0.666666667', '1', '1', '16', '2', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsSet extends ProjectComponent implements Condition { private String property ; public void setProperty ( String p ) { property = p ; } public boolean eval ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "No property specified for isset " + "condition" ) ; } return getProject ( ) . getProperty ( property ) != null ; } } 	0	['3', '2', '0', '5', '7', '1', '1', '4', '3', '0.5', '29', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; public abstract class BaseExtendSelector extends BaseSelector implements ExtendFileSelector { protected Parameter [ ] parameters = null ; public BaseExtendSelector ( ) { } public void setParameters ( Parameter [ ] parameters ) { this . parameters = parameters ; } protected Parameter [ ] getParameters ( ) { return parameters ; } public abstract boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['4', '4', '8', '12', '5', '0', '8', '4', '3', '0.333333333', '18', '1', '1', '0.921052632', '0.4375', '0', '0', '3.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Date ; import java . net . InetAddress ; import java . net . UnknownHostException ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class XMLJUnitResultFormatter implements JUnitResultFormatter , XMLConstants { private static final String UNKNOWN = "unknown" ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private Document doc ; private Element rootElement ; private Hashtable testElements = new Hashtable ( ) ; private Hashtable failedTests = new Hashtable ( ) ; private Hashtable testStarts = new Hashtable ( ) ; private OutputStream out ; public XMLJUnitResultFormatter ( ) { } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { formatOutput ( SYSTEM_OUT , out ) ; } public void setSystemError ( String out ) { formatOutput ( SYSTEM_ERR , out ) ; } public void startTestSuite ( JUnitTest suite ) { doc = getDocumentBuilder ( ) . newDocument ( ) ; rootElement = doc . createElement ( TESTSUITE ) ; String n = suite . getName ( ) ; rootElement . setAttribute ( ATTR_NAME , n == null ? UNKNOWN : n ) ; final String timestamp = DateUtils . format ( new Date ( ) , DateUtils . ISO8601_DATETIME_PATTERN ) ; rootElement . setAttribute ( TIMESTAMP , timestamp ) ; rootElement . setAttribute ( HOSTNAME , getHostname ( ) ) ; Element propsElement = doc . createElement ( PROPERTIES ) ; rootElement . appendChild ( propsElement ) ; Properties props = suite . getProperties ( ) ; if ( props != null ) { Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , name ) ; propElement . setAttribute ( ATTR_VALUE , props . getProperty ( name ) ) ; propsElement . appendChild ( propElement ) ; } } } private String getHostname ( ) { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { return "localhost" ; } } public void endTestSuite ( JUnitTest suite ) throws BuildException { rootElement . setAttribute ( ATTR_TESTS , "" + suite . runCount ( ) ) ; rootElement . setAttribute ( ATTR_FAILURES , "" + suite . failureCount ( ) ) ; rootElement . setAttribute ( ATTR_ERRORS , "" + suite . errorCount ( ) ) ; rootElement . setAttribute ( ATTR_TIME , "" + ( suite . getRunTime ( ) / 1000.0 ) ) ; if ( out != null ) { Writer wri = null ; try { wri = new BufferedWriter ( new OutputStreamWriter ( out , "UTF8" ) ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , 0 , "  " ) ; wri . flush ( ) ; } catch ( IOException exc ) { throw new BuildException ( "Unable to write log file" , exc ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( wri ) ; } } } } public void startTest ( Test t ) { testStarts . put ( t , new Long ( System . currentTimeMillis ( ) ) ) ; } public void endTest ( Test test ) { if ( ! testStarts . containsKey ( test ) ) { startTest ( test ) ; } Element currentTest = null ; if ( ! failedTests . containsKey ( test ) ) { currentTest = doc . createElement ( TESTCASE ) ; String n = JUnitVersionHelper . getTestCaseName ( test ) ; currentTest . setAttribute ( ATTR_NAME , n == null ? UNKNOWN : n ) ; currentTest . setAttribute ( ATTR_CLASSNAME , JUnitVersionHelper . getTestCaseClassName ( test ) ) ; rootElement . appendChild ( currentTest ) ; testElements . put ( test , currentTest ) ; } else { currentTest = ( Element ) testElements . get ( test ) ; } Long l = ( Long ) testStarts . get ( test ) ; currentTest . setAttribute ( ATTR_TIME , "" + ( ( System . currentTimeMillis ( ) - l . longValue ( ) ) / 1000.0 ) ) ; } public void addFailure ( Test test , Throwable t ) { formatError ( FAILURE , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { formatError ( ERROR , test , t ) ; } private void formatError ( String type , Test test , Throwable t ) { if ( test != null ) { endTest ( test ) ; failedTests . put ( test , test ) ; } Element nested = doc . createElement ( type ) ; Element currentTest = null ; if ( test != null ) { currentTest = ( Element ) testElements . get ( test ) ; } else { currentTest = rootElement ; } currentTest . appendChild ( nested ) ; String message = t . getMessage ( ) ; if ( message != null && message . length ( ) > 0 ) { nested . setAttribute ( ATTR_MESSAGE , t . getMessage ( ) ) ; } nested . setAttribute ( ATTR_TYPE , t . getClass ( ) . getName ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( t ) ; Text trace = doc . createTextNode ( strace ) ; nested . appendChild ( trace ) ; } private void formatOutput ( String type , String output ) { Element nested = doc . createElement ( type ) ; rootElement . appendChild ( nested ) ; nested . appendChild ( doc . createCDATASection ( output ) ) ; } } 	0	['15', '1', '0', '11', '65', '75', '0', '11', '11', '0.693877551', '443', '1', '0', '0', '0.295238095', '0', '0', '28.06666667', '5', '1.6', '0']
package org . apache . tools . ant . taskdefs . optional . net ; import java . net . Authenticator ; import java . net . PasswordAuthentication ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ProxySetup ; public class SetProxy extends Task { protected String proxyHost = null ; protected int proxyPort = 80 ; private String socksProxyHost = null ; private int socksProxyPort = 1080 ; private String nonProxyHosts = null ; private String proxyUser = null ; private String proxyPassword = null ; public void setProxyHost ( String hostname ) { proxyHost = hostname ; } public void setProxyPort ( int port ) { proxyPort = port ; } public void setSocksProxyHost ( String host ) { this . socksProxyHost = host ; } public void setSocksProxyPort ( int port ) { this . socksProxyPort = port ; } public void setNonProxyHosts ( String nonProxyHosts ) { this . nonProxyHosts = nonProxyHosts ; } public void setProxyUser ( String proxyUser ) { this . proxyUser = proxyUser ; } public void setProxyPassword ( String proxyPassword ) { this . proxyPassword = proxyPassword ; } public void applyWebProxySettings ( ) { boolean settingsChanged = false ; boolean enablingProxy = false ; Properties sysprops = System . getProperties ( ) ; if ( proxyHost != null ) { settingsChanged = true ; if ( proxyHost . length ( ) != 0 ) { traceSettingInfo ( ) ; enablingProxy = true ; sysprops . put ( ProxySetup . HTTP_PROXY_HOST , proxyHost ) ; String portString = Integer . toString ( proxyPort ) ; sysprops . put ( ProxySetup . HTTP_PROXY_PORT , portString ) ; sysprops . put ( ProxySetup . HTTPS_PROXY_HOST , proxyHost ) ; sysprops . put ( ProxySetup . HTTPS_PROXY_PORT , portString ) ; sysprops . put ( ProxySetup . FTP_PROXY_HOST , proxyHost ) ; sysprops . put ( ProxySetup . FTP_PROXY_PORT , portString ) ; if ( nonProxyHosts != null ) { sysprops . put ( ProxySetup . HTTP_NON_PROXY_HOSTS , nonProxyHosts ) ; sysprops . put ( ProxySetup . HTTPS_NON_PROXY_HOSTS , nonProxyHosts ) ; sysprops . put ( ProxySetup . FTP_NON_PROXY_HOSTS , nonProxyHosts ) ; } if ( proxyUser != null ) { sysprops . put ( ProxySetup . HTTP_PROXY_USERNAME , proxyUser ) ; sysprops . put ( ProxySetup . HTTP_PROXY_PASSWORD , proxyPassword ) ; } } else { log ( "resetting http proxy" , Project . MSG_VERBOSE ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_HOST ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_PORT ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_USERNAME ) ; sysprops . remove ( ProxySetup . HTTP_PROXY_PASSWORD ) ; sysprops . remove ( ProxySetup . HTTPS_PROXY_HOST ) ; sysprops . remove ( ProxySetup . HTTPS_PROXY_PORT ) ; sysprops . remove ( ProxySetup . FTP_PROXY_HOST ) ; sysprops . remove ( ProxySetup . FTP_PROXY_PORT ) ; } } if ( socksProxyHost != null ) { settingsChanged = true ; if ( socksProxyHost . length ( ) != 0 ) { enablingProxy = true ; sysprops . put ( ProxySetup . SOCKS_PROXY_HOST , socksProxyHost ) ; sysprops . put ( ProxySetup . SOCKS_PROXY_PORT , Integer . toString ( socksProxyPort ) ) ; if ( proxyUser != null ) { sysprops . put ( ProxySetup . SOCKS_PROXY_USERNAME , proxyUser ) ; sysprops . put ( ProxySetup . SOCKS_PROXY_PASSWORD , proxyPassword ) ; } } else { log ( "resetting socks proxy" , Project . MSG_VERBOSE ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_HOST ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_PORT ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_USERNAME ) ; sysprops . remove ( ProxySetup . SOCKS_PROXY_PASSWORD ) ; } } if ( proxyUser != null ) { if ( enablingProxy ) { Authenticator . setDefault ( new ProxyAuth ( proxyUser , proxyPassword ) ) ; } else if ( settingsChanged ) { Authenticator . setDefault ( new ProxyAuth ( "" , "" ) ) ; } } } private void traceSettingInfo ( ) { log ( "Setting proxy to " + ( proxyHost != null ? proxyHost : "''" ) + ":" + proxyPort , Project . MSG_VERBOSE ) ; } public void execute ( ) throws BuildException { applyWebProxySettings ( ) ; } private static final class ProxyAuth extends Authenticator { private PasswordAuthentication auth ; private ProxyAuth ( String user , String pass ) { auth = new PasswordAuthentication ( user , pass . toCharArray ( ) ) ; } protected PasswordAuthentication getPasswordAuthentication ( ) { return auth ; } } } 	0	['11', '3', '0', '3', '24', '17', '0', '3', '10', '0.671428571', '309', '1', '0', '0.787234043', '0.545454545', '0', '0', '26.45454545', '11', '1.9091', '0']
package org . apache . tools . ant . util ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; public class KeepAliveInputStream extends FilterInputStream { public KeepAliveInputStream ( InputStream in ) { super ( in ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '1', '3', '1', '1', '0', '2', '2', '7', '0', '0', '0.947368421', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . PropertySet ; public class CallTarget extends Task { private Ant callee ; private boolean inheritAll = true ; private boolean inheritRefs = false ; private boolean targetSet = false ; public void setInheritAll ( boolean inherit ) { inheritAll = inherit ; } public void setInheritRefs ( boolean inheritRefs ) { this . inheritRefs = inheritRefs ; } public void init ( ) { callee = new Ant ( this ) ; callee . init ( ) ; } public void execute ( ) throws BuildException { if ( callee == null ) { init ( ) ; } if ( ! targetSet ) { throw new BuildException ( "Attribute target or at least one nested target is required." , getLocation ( ) ) ; } callee . setAntfile ( getProject ( ) . getProperty ( "ant.file" ) ) ; callee . setInheritAll ( inheritAll ) ; callee . setInheritRefs ( inheritRefs ) ; callee . execute ( ) ; } public Property createParam ( ) { if ( callee == null ) { init ( ) ; } return callee . createProperty ( ) ; } public void addReference ( Ant . Reference r ) { if ( callee == null ) { init ( ) ; } callee . addReference ( r ) ; } public void addPropertyset ( PropertySet ps ) { if ( callee == null ) { init ( ) ; } callee . addPropertyset ( ps ) ; } public void setTarget ( String target ) { if ( callee == null ) { init ( ) ; } callee . setTarget ( target ) ; targetSet = true ; } public void addConfiguredTarget ( Ant . TargetElement t ) { if ( callee == null ) { init ( ) ; } callee . addConfiguredTarget ( t ) ; targetSet = true ; } public void handleOutput ( String output ) { if ( callee != null ) { callee . handleOutput ( output ) ; } else { super . handleOutput ( output ) ; } } public int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { if ( callee != null ) { return callee . handleInput ( buffer , offset , length ) ; } return super . handleInput ( buffer , offset , length ) ; } public void handleFlush ( String output ) { if ( callee != null ) { callee . handleFlush ( output ) ; } else { super . handleFlush ( output ) ; } } public void handleErrorOutput ( String output ) { if ( callee != null ) { callee . handleErrorOutput ( output ) ; } else { super . handleErrorOutput ( output ) ; } } public void handleErrorFlush ( String output ) { if ( callee != null ) { callee . handleErrorFlush ( output ) ; } else { super . handleErrorFlush ( output ) ; } } } 	0	['15', '3', '0', '9', '41', '0', '0', '9', '15', '0.678571429', '204', '1', '1', '0.725490196', '0.225', '1', '2', '12.33333333', '2', '1.5333', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . ClasspathUtils ; public abstract class DefBase extends AntlibDefinition { private ClassLoader createdLoader ; private ClasspathUtils . Delegate cpDelegate ; protected boolean hasCpDelegate ( ) { return cpDelegate != null ; } public void setReverseLoader ( boolean reverseLoader ) { getDelegate ( ) . setReverseLoader ( reverseLoader ) ; log ( "The reverseloader attribute is DEPRECATED. It will be removed" , Project . MSG_WARN ) ; } public Path getClasspath ( ) { return getDelegate ( ) . getClasspath ( ) ; } public boolean isReverseLoader ( ) { return getDelegate ( ) . isReverseLoader ( ) ; } public String getLoaderId ( ) { return getDelegate ( ) . getClassLoadId ( ) ; } public String getClasspathId ( ) { return getDelegate ( ) . getClassLoadId ( ) ; } public void setClasspath ( Path classpath ) { getDelegate ( ) . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return getDelegate ( ) . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { getDelegate ( ) . setClasspathref ( r ) ; } public void setLoaderRef ( Reference r ) { getDelegate ( ) . setLoaderRef ( r ) ; } protected ClassLoader createLoader ( ) { if ( getAntlibClassLoader ( ) != null && cpDelegate == null ) { return getAntlibClassLoader ( ) ; } if ( createdLoader == null ) { createdLoader = getDelegate ( ) . getClassLoader ( ) ; ( ( AntClassLoader ) createdLoader ) . addSystemPackageRoot ( "org.apache.tools.ant" ) ; } return createdLoader ; } public void init ( ) throws BuildException { super . init ( ) ; } private ClasspathUtils . Delegate getDelegate ( ) { if ( cpDelegate == null ) { cpDelegate = ClasspathUtils . getDelegate ( this ) ; } return cpDelegate ; } } 	0	['14', '4', '3', '11', '29', '85', '3', '8', '11', '0.576923077', '108', '1', '1', '0.759259259', '0.321428571', '0', '0', '6.571428571', '4', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . text . SimpleDateFormat ; import java . util . Date ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class P4Label extends P4Base { protected String name ; protected String desc ; protected String lock ; public void setName ( String name ) { this . name = name ; } public void setDesc ( String desc ) { this . desc = desc ; } public void setLock ( String lock ) { this . lock = lock ; } public void execute ( ) throws BuildException { log ( "P4Label exec:" , Project . MSG_INFO ) ; if ( P4View == null || P4View . length ( ) < 1 ) { log ( "View not set, assuming //depot/..." , Project . MSG_WARN ) ; P4View = "//depot/..." ; } else { P4View = StringUtils . replace ( P4View , ":" , "\n\t" ) ; P4View = StringUtils . replace ( P4View , ";" , "\n\t" ) ; } if ( desc == null || desc . length ( ) < 1 ) { log ( "Label Description not set, assuming 'AntLabel'" , Project . MSG_WARN ) ; desc = "AntLabel" ; } if ( lock != null && ! lock . equalsIgnoreCase ( "locked" ) ) { log ( "lock attribute invalid - ignoring" , Project . MSG_WARN ) ; } if ( name == null || name . length ( ) < 1 ) { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy.MM.dd-hh:mm" ) ; Date now = new Date ( ) ; name = "AntLabel-" + formatter . format ( now ) ; log ( "name not set, assuming '" + name + "'" , Project . MSG_WARN ) ; } String newLabel = "Label: " + name + "\nDescription: " + desc + "\nOptions: unlocked" + "\nView: \n\t" + P4View ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ; handler . setOutput ( newLabel ) ; execP4Command ( "label -i" , handler ) ; execP4Command ( "labelsync -l " + name , new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ) ; log ( "Created Label " + name + " (" + desc + ") with view:\n" + P4View , Project . MSG_INFO ) ; if ( lock != null && lock . equalsIgnoreCase ( "locked" ) ) { log ( "Modifying lock status to 'locked'" , Project . MSG_INFO ) ; final StringBuffer labelSpec = new StringBuffer ( ) ; handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; if ( util . match ( "/^Options:/" , line ) ) { line = "Options: " + lock ; } labelSpec . append ( line + "\n" ) ; } } ; execP4Command ( "label -o " + name , handler ) ; log ( labelSpec . toString ( ) , Project . MSG_DEBUG ) ; log ( "Now locking label..." , Project . MSG_VERBOSE ) ; handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( line , Project . MSG_VERBOSE ) ; } } ; handler . setOutput ( labelSpec . toString ( ) ) ; execP4Command ( "label -i" , handler ) ; } } } 	0	['5', '4', '0', '8', '23', '4', '4', '8', '5', '0.75', '249', '1', '0', '0.927272727', '0.8', '2', '2', '48.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; public interface XSLTLiaison { String FILE_PROTOCOL_PREFIX = "file://" ; void setStylesheet ( File stylesheet ) throws Exception ; void addParam ( String name , String expression ) throws Exception ; void transform ( File infile , File outfile ) throws Exception ; } 	0	['3', '1', '0', '2', '3', '3', '2', '0', '3', '1.5', '4', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import org . apache . tools . ant . types . FileSet ; public class BCFileSet extends FileSet { public BCFileSet ( ) { } public BCFileSet ( FileSet fs ) { super ( fs ) ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } FileResourceIterator result = new FileResourceIterator ( getDir ( ) ) ; result . addFiles ( getDirectoryScanner ( ) . getIncludedFiles ( ) ) ; result . addFiles ( getDirectoryScanner ( ) . getIncludedDirectories ( ) ) ; return result ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( ) . getIncludedFilesCount ( ) + getDirectoryScanner ( ) . getIncludedDirsCount ( ) ; } } 	0	['4', '5', '0', '5', '19', '6', '0', '5', '4', '2', '57', '0', '0', '0.978494624', '0.625', '2', '4', '13.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . BuildException ; public class ExtraAttribute { private String name ; private String value ; public void setName ( final String name ) { this . name = name ; } public void setValue ( final String value ) { this . value = value ; } String getName ( ) { return name ; } String getValue ( ) { return value ; } public void validate ( ) throws BuildException { if ( null == name ) { final String message = "Missing name from parameter." ; throw new BuildException ( message ) ; } else if ( null == value ) { final String message = "Missing value from parameter " + name + "." ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '4', '0.6', '53', '1', '0', '0', '0.666666667', '0', '0', '7.5', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . types . EnumeratedAttribute ; import java . io . File ; import java . io . IOException ; import java . text . DateFormat ; import java . text . ParseException ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class MSVSS extends Task implements MSVSSConstants { private String ssDir = null ; private String vssLogin = null ; private String vssPath = null ; private String serverPath = null ; private String version = null ; private String date = null ; private String label = null ; private String autoResponse = null ; private String localPath = null ; private String comment = null ; private String fromLabel = null ; private String toLabel = null ; private String outputFileName = null ; private String user = null ; private String fromDate = null ; private String toDate = null ; private String style = null ; private boolean quiet = false ; private boolean recursive = false ; private boolean writable = false ; private boolean failOnError = true ; private boolean getLocalCopy = true ; private int numDays = Integer . MIN_VALUE ; private DateFormat dateFormat = DateFormat . getDateInstance ( DateFormat . SHORT ) ; private CurrentModUpdated timestamp = null ; private WritableFiles writableFiles = null ; abstract Commandline buildCmdLine ( ) ; public final void setSsdir ( String dir ) { this . ssDir = FileUtils . translatePath ( dir ) ; } public final void setLogin ( final String vssLogin ) { this . vssLogin = vssLogin ; } public final void setVsspath ( final String vssPath ) { String projectPath ; if ( vssPath . startsWith ( "vss://" ) ) { projectPath = vssPath . substring ( 5 ) ; } else { projectPath = vssPath ; } if ( projectPath . startsWith ( PROJECT_PREFIX ) ) { this . vssPath = projectPath ; } else { this . vssPath = PROJECT_PREFIX + projectPath ; } } public final void setServerpath ( final String serverPath ) { this . serverPath = serverPath ; } public final void setFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } public void execute ( ) throws BuildException { int result = 0 ; Commandline commandLine = buildCmdLine ( ) ; result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnError ( ) ) { String msg = "Failed executing: " + formatCommandLine ( commandLine ) + " With a return code of " + result ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected void setInternalComment ( final String comment ) { this . comment = comment ; } protected void setInternalAutoResponse ( final String autoResponse ) { this . autoResponse = autoResponse ; } protected void setInternalDate ( final String date ) { this . date = date ; } protected void setInternalDateFormat ( final DateFormat dateFormat ) { this . dateFormat = dateFormat ; } protected void setInternalFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } protected void setInternalFromDate ( final String fromDate ) { this . fromDate = fromDate ; } protected void setInternalFromLabel ( final String fromLabel ) { this . fromLabel = fromLabel ; } protected void setInternalLabel ( final String label ) { this . label = label ; } protected void setInternalLocalPath ( final String localPath ) { this . localPath = localPath ; } protected void setInternalNumDays ( final int numDays ) { this . numDays = numDays ; } protected void setInternalOutputFilename ( final String outputFileName ) { this . outputFileName = outputFileName ; } protected void setInternalQuiet ( final boolean quiet ) { this . quiet = quiet ; } protected void setInternalRecursive ( final boolean recursive ) { this . recursive = recursive ; } protected void setInternalStyle ( final String style ) { this . style = style ; } protected void setInternalToDate ( final String toDate ) { this . toDate = toDate ; } protected void setInternalToLabel ( final String toLabel ) { this . toLabel = toLabel ; } protected void setInternalUser ( final String user ) { this . user = user ; } protected void setInternalVersion ( final String version ) { this . version = version ; } protected void setInternalWritable ( final boolean writable ) { this . writable = writable ; } protected void setInternalFileTimeStamp ( final CurrentModUpdated timestamp ) { this . timestamp = timestamp ; } protected void setInternalWritableFiles ( final WritableFiles writableFiles ) { this . writableFiles = writableFiles ; } protected void setInternalGetLocalCopy ( final boolean getLocalCopy ) { this . getLocalCopy = getLocalCopy ; } protected String getSSCommand ( ) { if ( ssDir == null ) { return SS_EXE ; } return ssDir . endsWith ( File . separator ) ? ssDir + SS_EXE : ssDir + File . separator + SS_EXE ; } protected String getVsspath ( ) { return vssPath ; } protected String getQuiet ( ) { return quiet ? FLAG_QUIET : "" ; } protected String getRecursive ( ) { return recursive ? FLAG_RECURSION : "" ; } protected String getWritable ( ) { return writable ? FLAG_WRITABLE : "" ; } protected String getLabel ( ) { String shortLabel = "" ; if ( label != null && label . length ( ) > 0 ) { shortLabel = FLAG_LABEL + getShortLabel ( ) ; } return shortLabel ; } private String getShortLabel ( ) { String shortLabel ; if ( label != null && label . length ( ) > 31 ) { shortLabel = this . label . substring ( 0 , 30 ) ; log ( "Label is longer than 31 characters, truncated to: " + shortLabel , Project . MSG_WARN ) ; } else { shortLabel = label ; } return shortLabel ; } protected String getStyle ( ) { return style != null ? style : "" ; } protected String getVersionDateLabel ( ) { String versionDateLabel = "" ; if ( version != null ) { versionDateLabel = FLAG_VERSION + version ; } else if ( date != null ) { versionDateLabel = FLAG_VERSION_DATE + date ; } else { String shortLabel = getShortLabel ( ) ; if ( shortLabel != null && ! shortLabel . equals ( "" ) ) { versionDateLabel = FLAG_VERSION_LABEL + shortLabel ; } } return versionDateLabel ; } protected String getVersion ( ) { return version != null ? FLAG_VERSION + version : "" ; } protected String getLocalpath ( ) { String lclPath = "" ; if ( localPath != null ) { File dir = getProject ( ) . resolveFile ( localPath ) ; if ( ! dir . exists ( ) ) { boolean done = dir . mkdirs ( ) ; if ( ! done ) { String msg = "Directory " + localPath + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } getProject ( ) . log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath ; } return lclPath ; } protected String getComment ( ) { return comment != null ? FLAG_COMMENT + comment : FLAG_COMMENT + "-" ; } protected String getAutoresponse ( ) { if ( autoResponse == null ) { return FLAG_AUTORESPONSE_DEF ; } else if ( autoResponse . equalsIgnoreCase ( "Y" ) ) { return FLAG_AUTORESPONSE_YES ; } else if ( autoResponse . equalsIgnoreCase ( "N" ) ) { return FLAG_AUTORESPONSE_NO ; } else { return FLAG_AUTORESPONSE_DEF ; } } protected String getLogin ( ) { return vssLogin != null ? FLAG_LOGIN + vssLogin : "" ; } protected String getOutput ( ) { return outputFileName != null ? FLAG_OUTPUT + outputFileName : "" ; } protected String getUser ( ) { return user != null ? FLAG_USER + user : "" ; } protected String getVersionLabel ( ) { if ( fromLabel == null && toLabel == null ) { return "" ; } if ( fromLabel != null && toLabel != null ) { if ( fromLabel . length ( ) > 31 ) { fromLabel = fromLabel . substring ( 0 , 30 ) ; log ( "FromLabel is longer than 31 characters, truncated to: " + fromLabel , Project . MSG_WARN ) ; } if ( toLabel . length ( ) > 31 ) { toLabel = toLabel . substring ( 0 , 30 ) ; log ( "ToLabel is longer than 31 characters, truncated to: " + toLabel , Project . MSG_WARN ) ; } return FLAG_VERSION_LABEL + toLabel + VALUE_FROMLABEL + fromLabel ; } else if ( fromLabel != null ) { if ( fromLabel . length ( ) > 31 ) { fromLabel = fromLabel . substring ( 0 , 30 ) ; log ( "FromLabel is longer than 31 characters, truncated to: " + fromLabel , Project . MSG_WARN ) ; } return FLAG_VERSION + VALUE_FROMLABEL + fromLabel ; } else { if ( toLabel . length ( ) > 31 ) { toLabel = toLabel . substring ( 0 , 30 ) ; log ( "ToLabel is longer than 31 characters, truncated to: " + toLabel , Project . MSG_WARN ) ; } return FLAG_VERSION_LABEL + toLabel ; } } protected String getVersionDate ( ) throws BuildException { if ( fromDate == null && toDate == null && numDays == Integer . MIN_VALUE ) { return "" ; } if ( fromDate != null && toDate != null ) { return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE + fromDate ; } else if ( toDate != null && numDays != Integer . MIN_VALUE ) { try { return FLAG_VERSION_DATE + toDate + VALUE_FROMDATE + calcDate ( toDate , numDays ) ; } catch ( ParseException ex ) { String msg = "Error parsing date: " + toDate ; throw new BuildException ( msg , getLocation ( ) ) ; } } else if ( fromDate != null && numDays != Integer . MIN_VALUE ) { try { return FLAG_VERSION_DATE + calcDate ( fromDate , numDays ) + VALUE_FROMDATE + fromDate ; } catch ( ParseException ex ) { String msg = "Error parsing date: " + fromDate ; throw new BuildException ( msg , getLocation ( ) ) ; } } else { return fromDate != null ? FLAG_VERSION + VALUE_FROMDATE + fromDate : FLAG_VERSION_DATE + toDate ; } } protected String getGetLocalCopy ( ) { return ( ! getLocalCopy ) ? FLAG_NO_GET : "" ; } private boolean getFailOnError ( ) { return getWritableFiles ( ) . equals ( WRITABLE_SKIP ) ? false : failOnError ; } public String getFileTimeStamp ( ) { if ( timestamp == null ) { return "" ; } else if ( timestamp . getValue ( ) . equals ( TIME_MODIFIED ) ) { return FLAG_FILETIME_MODIFIED ; } else if ( timestamp . getValue ( ) . equals ( TIME_UPDATED ) ) { return FLAG_FILETIME_UPDATED ; } else { return FLAG_FILETIME_DEF ; } } public String getWritableFiles ( ) { if ( writableFiles == null ) { return "" ; } else if ( writableFiles . getValue ( ) . equals ( WRITABLE_REPLACE ) ) { return FLAG_REPLACE_WRITABLE ; } else if ( writableFiles . getValue ( ) . equals ( WRITABLE_SKIP ) ) { failOnError = false ; return FLAG_SKIP_WRITABLE ; } else { return "" ; } } private int run ( Commandline cmd ) { try { Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; if ( serverPath != null ) { String [ ] env = exe . getEnvironment ( ) ; if ( env == null ) { env = new String [ 0 ] ; } String [ ] newEnv = new String [ env . length + 1 ] ; System . arraycopy ( env , 0 , newEnv , 0 , env . length ) ; newEnv [ env . length ] = "SSDIR=" + serverPath ; exe . setEnvironment ( newEnv ) ; } exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; exe . setVMLauncher ( false ) ; return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } private String calcDate ( String startDate , int daysToAdd ) throws ParseException { Calendar calendar = new GregorianCalendar ( ) ; Date currentDate = dateFormat . parse ( startDate ) ; calendar . setTime ( currentDate ) ; calendar . add ( Calendar . DATE , daysToAdd ) ; return dateFormat . format ( calendar . getTime ( ) ) ; } private String formatCommandLine ( Commandline cmd ) { StringBuffer sBuff = new StringBuffer ( cmd . toString ( ) ) ; int indexUser = sBuff . substring ( 0 ) . indexOf ( FLAG_LOGIN ) ; if ( indexUser > 0 ) { int indexPass = sBuff . substring ( 0 ) . indexOf ( "," , indexUser ) ; int indexAfterPass = sBuff . substring ( 0 ) . indexOf ( " " , indexPass ) ; for ( int i = indexPass + 1 ; i < indexAfterPass ; i ++ ) { sBuff . setCharAt ( i , '*' ) ; } } return sBuff . toString ( ) ; } public static class CurrentModUpdated extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { TIME_CURRENT , TIME_MODIFIED , TIME_UPDATED } ; } } public static class WritableFiles extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { WRITABLE_REPLACE , WRITABLE_SKIP , WRITABLE_FAIL } ; } } } 	0	['55', '3', '8', '20', '106', '1313', '8', '12', '9', '0.956552707', '1133', '1', '2', '0.406593407', '0.195454545', '0', '0', '19.12727273', '10', '1.8545', '0']
package org . apache . tools . ant . util . regexp ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . tools . ant . BuildException ; public class Jdk14RegexpRegexp extends Jdk14RegexpMatcher implements Regexp { public Jdk14RegexpRegexp ( ) { super ( ) ; } protected int getSubsOptions ( int options ) { int subsOptions = REPLACE_FIRST ; if ( RegexpUtil . hasFlag ( options , REPLACE_ALL ) ) { subsOptions = REPLACE_ALL ; } return subsOptions ; } public String substitute ( String input , String argument , int options ) throws BuildException { StringBuffer subst = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '$' ) { subst . append ( '\\' ) ; subst . append ( '$' ) ; } else if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { subst . append ( "$" ) . append ( value ) ; } else { subst . append ( c ) ; } } else { subst . append ( '\\' ) ; } } else { subst . append ( c ) ; } } argument = subst . toString ( ) ; int sOptions = getSubsOptions ( options ) ; Pattern p = getCompiledPattern ( options ) ; StringBuffer sb = new StringBuffer ( ) ; Matcher m = p . matcher ( input ) ; if ( RegexpUtil . hasFlag ( sOptions , REPLACE_ALL ) ) { sb . append ( m . replaceAll ( argument ) ) ; } else { boolean res = m . find ( ) ; if ( res ) { m . appendReplacement ( sb , argument ) ; m . appendTail ( sb ) ; } else { sb . append ( input ) ; } } return sb . toString ( ) ; } } 	0	['3', '2', '0', '4', '19', '3', '0', '4', '2', '2', '136', '0', '0', '0.8', '0.666666667', '0', '0', '44.33333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . DeweyDecimal ; public class AntVersion implements Condition { private String atLeast = null ; private String exactly = null ; public boolean eval ( ) throws BuildException { validate ( ) ; DeweyDecimal actual = getVersion ( ) ; if ( null != atLeast ) { return actual . isGreaterThanOrEqual ( new DeweyDecimal ( atLeast ) ) ; } if ( null != exactly ) { return actual . isEqual ( new DeweyDecimal ( exactly ) ) ; } return false ; } private void validate ( ) throws BuildException { if ( atLeast != null && exactly != null ) { throw new BuildException ( "Only one of atleast or exactly may be set." ) ; } if ( null == atLeast && null == exactly ) { throw new BuildException ( "One of atleast or exactly must be set." ) ; } try { if ( atLeast != null ) { new DeweyDecimal ( atLeast ) ; } else { new DeweyDecimal ( exactly ) ; } } catch ( NumberFormatException e ) { throw new BuildException ( "The argument is not a Dewey Decimal eg 1.1.0" ) ; } } private DeweyDecimal getVersion ( ) { Project p = new Project ( ) ; p . init ( ) ; char [ ] versionString = p . getProperty ( "ant.version" ) . toCharArray ( ) ; StringBuffer sb = new StringBuffer ( ) ; boolean foundFirstDigit = false ; for ( int i = 0 ; i < versionString . length ; i ++ ) { if ( Character . isDigit ( versionString [ i ] ) ) { sb . append ( versionString [ i ] ) ; foundFirstDigit = true ; } if ( versionString [ i ] == '.' && foundFirstDigit ) { sb . append ( versionString [ i ] ) ; } if ( Character . isLetter ( versionString [ i ] ) && foundFirstDigit ) { break ; } } return new DeweyDecimal ( sb . toString ( ) ) ; } public String getAtLeast ( ) { return atLeast ; } public void setAtLeast ( String atLeast ) { this . atLeast = atLeast ; } public String getExactly ( ) { return exactly ; } public void setExactly ( String exactly ) { this . exactly = exactly ; } } 	0	['8', '1', '0', '4', '22', '0', '0', '4', '6', '0.428571429', '169', '1', '0', '0', '0.625', '0', '0', '19.875', '7', '1.625', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class LazyFileOutputStream extends OutputStream { private FileOutputStream fos ; private File file ; private boolean append ; private boolean alwaysCreate ; private boolean opened = false ; private boolean closed = false ; public LazyFileOutputStream ( String name ) { this ( name , false ) ; } public LazyFileOutputStream ( String name , boolean append ) { this ( new File ( name ) , append ) ; } public LazyFileOutputStream ( File f ) { this ( f , false ) ; } public LazyFileOutputStream ( File file , boolean append ) { this ( file , append , false ) ; } public LazyFileOutputStream ( File file , boolean append , boolean alwaysCreate ) { this . file = file ; this . append = append ; this . alwaysCreate = alwaysCreate ; } public void open ( ) throws IOException { ensureOpened ( ) ; } public synchronized void close ( ) throws IOException { if ( alwaysCreate && ! closed ) { ensureOpened ( ) ; } if ( opened ) { fos . close ( ) ; } closed = true ; } public void write ( byte [ ] b ) throws IOException { write ( b , 0 , b . length ) ; } public synchronized void write ( byte [ ] b , int offset , int len ) throws IOException { ensureOpened ( ) ; fos . write ( b , offset , len ) ; } public synchronized void write ( int b ) throws IOException { ensureOpened ( ) ; fos . write ( b ) ; } private synchronized void ensureOpened ( ) throws IOException { if ( closed ) { throw new IOException ( file + " has already been closed." ) ; } if ( ! opened ) { fos = new FileOutputStream ( file . getAbsolutePath ( ) , append ) ; opened = true ; } } } 	0	['11', '2', '0', '1', '23', '39', '1', '0', '10', '0.483333333', '136', '1', '0', '0.454545455', '0.348484848', '1', '1', '10.81818182', '1', '0.5455', '0']
package org . apache . tools . ant . util ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; public class LoaderUtils { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public static void setContextClassLoader ( ClassLoader loader ) { Thread currentThread = Thread . currentThread ( ) ; currentThread . setContextClassLoader ( loader ) ; } public static ClassLoader getContextClassLoader ( ) { Thread currentThread = Thread . currentThread ( ) ; return currentThread . getContextClassLoader ( ) ; } public static boolean isContextLoaderAvailable ( ) { return true ; } private static File normalizeSource ( File source ) { if ( source != null ) { try { source = FILE_UTILS . normalize ( source . getAbsolutePath ( ) ) ; } catch ( BuildException e ) { } } return source ; } public static File getClassSource ( Class c ) { return normalizeSource ( Locator . getClassSource ( c ) ) ; } public static File getResourceSource ( ClassLoader c , String resource ) { if ( c == null ) { c = LoaderUtils . class . getClassLoader ( ) ; } return normalizeSource ( Locator . getResourceSource ( c , resource ) ) ; } public static String classNameToResource ( String className ) { return className . replace ( '.' , '/' ) + ".class" ; } public static boolean classExists ( ClassLoader loader , String className ) { return loader . getResource ( classNameToResource ( className ) ) != null ; } } 	0	['10', '1', '0', '10', '29', '43', '7', '3', '8', '0.833333333', '91', '0.5', '1', '0', '0.2', '0', '0', '7.9', '3', '1.2', '0']
package org . apache . tools . ant . loader ; import org . apache . tools . ant . AntClassLoader ; public class AntClassLoader2 extends AntClassLoader { public AntClassLoader2 ( ) { } } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import java . io . IOException ; public class ForkingSunRmic extends DefaultRmicAdapter { public static final String COMPILER_NAME = "forking" ; public boolean execute ( ) throws BuildException { Rmic owner = getRmic ( ) ; Commandline cmd = setupRmicCommand ( ) ; Project project = owner . getProject ( ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( getExecutableName ( ) ) ) ; String [ ] args = cmd . getCommandline ( ) ; try { Execute exe = new Execute ( new LogStreamHandler ( owner , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( args ) ; exe . execute ( ) ; return ! exe . isFailure ( ) ; } catch ( IOException exception ) { throw new BuildException ( "Error running " + getExecutableName ( ) + " -maybe it is not on the path" , exception ) ; } } protected String getExecutableName ( ) { return SunRmic . RMIC_EXECUTABLE ; } } 	0	['3', '2', '1', '12', '22', '3', '2', '10', '2', '1.5', '72', '0', '0', '0.866666667', '1', '0', '0', '22.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . util ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . Vector ; public final class StringUtils { private StringUtils ( ) { } public static final String LINE_SEP = System . getProperty ( "line.separator" ) ; public static Vector lineSplit ( String data ) { return split ( data , '\n' ) ; } public static Vector split ( String data , int ch ) { Vector elems = new Vector ( ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( ch , i ) ) != - 1 ) { String elem = data . substring ( i , pos ) ; elems . addElement ( elem ) ; i = pos + 1 ; } elems . addElement ( data . substring ( i ) ) ; return elems ; } public static String replace ( String data , String from , String to ) { StringBuffer buf = new StringBuffer ( data . length ( ) ) ; int pos = - 1 ; int i = 0 ; while ( ( pos = data . indexOf ( from , i ) ) != - 1 ) { buf . append ( data . substring ( i , pos ) ) . append ( to ) ; i = pos + from . length ( ) ; } buf . append ( data . substring ( i ) ) ; return buf . toString ( ) ; } public static String getStackTrace ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; pw . flush ( ) ; pw . close ( ) ; return sw . toString ( ) ; } public static boolean endsWith ( StringBuffer buffer , String suffix ) { if ( suffix . length ( ) > buffer . length ( ) ) { return false ; } int endIndex = suffix . length ( ) - 1 ; int bufferIndex = buffer . length ( ) - 1 ; while ( endIndex >= 0 ) { if ( buffer . charAt ( bufferIndex ) != suffix . charAt ( endIndex ) ) { return false ; } bufferIndex -- ; endIndex -- ; } return true ; } public static String resolveBackSlash ( String input ) { StringBuffer b = new StringBuffer ( ) ; boolean backSlashSeen = false ; for ( int i = 0 ; i < input . length ( ) ; ++ i ) { char c = input . charAt ( i ) ; if ( ! backSlashSeen ) { if ( c == '\\' ) { backSlashSeen = true ; } else { b . append ( c ) ; } } else { switch ( c ) { case '\\' : b . append ( ( char ) '\\' ) ; break ; case 'n' : b . append ( ( char ) '\n' ) ; break ; case 'r' : b . append ( ( char ) '\r' ) ; break ; case 't' : b . append ( ( char ) '\t' ) ; break ; case 'f' : b . append ( ( char ) '\f' ) ; break ; case 's' : b . append ( " \t\n\r\f" ) ; break ; default : b . append ( c ) ; } backSlashSeen = false ; } } return b . toString ( ) ; } public static long parseHumanSizes ( String humanSize ) throws Exception { final long KILOBYTE = 1024 ; final long MEGABYTE = KILOBYTE * 1024 ; final long GIGABYTE = MEGABYTE * 1024 ; final long TERABYTE = GIGABYTE * 1024 ; final long PETABYTE = TERABYTE * 1024 ; if ( ! Character . isDigit ( humanSize . charAt ( humanSize . length ( ) - 1 ) ) ) { char c = humanSize . charAt ( humanSize . length ( ) - 1 ) ; long value = Long . valueOf ( humanSize . substring ( 0 , humanSize . length ( ) - 1 ) ) . longValue ( ) ; switch ( c ) { case 'K' : return value * KILOBYTE ; case 'M' : return value * MEGABYTE ; case 'G' : return value * GIGABYTE ; case 'T' : return value * TERABYTE ; case 'P' : return value * PETABYTE ; default : return value ; } } else { return Long . parseLong ( humanSize ) ; } } } 	0	['9', '1', '0', '32', '36', '36', '32', '0', '7', '1.104166667', '281', '0.833333333', '0', '0', '0.25', '0', '0', '29.55555556', '11', '3', '0']
package org . apache . tools . ant . types ; public final class Parameter { private String name = null ; private String type = null ; private String value = null ; public void setName ( final String name ) { this . name = name ; } public void setType ( final String type ) { this . type = type ; } public void setValue ( final String value ) { this . value = value ; } public String getName ( ) { return name ; } public String getType ( ) { return type ; } public String getValue ( ) { return value ; } } 	0	['7', '1', '0', '24', '8', '3', '24', '0', '7', '0.666666667', '43', '1', '0', '0', '0.714285714', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import org . apache . tools . ant . BuildException ; public class Jdk14RegexpMatcher implements RegexpMatcher { private String pattern ; public Jdk14RegexpMatcher ( ) { } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return pattern ; } protected Pattern getCompiledPattern ( int options ) throws BuildException { int cOptions = getCompilerOptions ( options ) ; try { Pattern p = Pattern . compile ( this . pattern , cOptions ) ; return p ; } catch ( PatternSyntaxException e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { try { Pattern p = getCompiledPattern ( options ) ; return p . matcher ( input ) . find ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { Pattern p = getCompiledPattern ( options ) ; Matcher matcher = p . matcher ( input ) ; if ( ! matcher . find ( ) ) { return null ; } Vector v = new Vector ( ) ; int cnt = matcher . groupCount ( ) ; for ( int i = 0 ; i <= cnt ; i ++ ) { String match = matcher . group ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = Pattern . UNIX_LINES ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= Pattern . CASE_INSENSITIVE ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= Pattern . MULTILINE ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= Pattern . DOTALL ; } return cOptions ; } } 	0	['9', '1', '1', '4', '19', '30', '1', '3', '7', '0.5', '130', '1', '0', '0', '0.666666667', '0', '0', '13.33333333', '4', '1.2222', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . LineOrientedOutputStream ; public class LogOutputStream extends LineOrientedOutputStream { private ProjectComponent pc ; private int level = Project . MSG_INFO ; public LogOutputStream ( Task task , int level ) { this ( ( ProjectComponent ) task , level ) ; } public LogOutputStream ( ProjectComponent pc , int level ) { this . pc = pc ; this . level = level ; } protected void processBuffer ( ) { try { super . processBuffer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( "Impossible IOException caught: " + e ) ; } } protected void processLine ( String line ) { processLine ( line , level ) ; } protected void processLine ( String line , int level ) { pc . log ( line , level ) ; } public int getMessageLevel ( ) { return level ; } } 	0	['6', '3', '2', '20', '13', '7', '17', '3', '3', '0.4', '56', '1', '1', '0.733333333', '0.433333333', '1', '4', '8', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public interface JspMangler { String mapJspToJavaName ( File jspFile ) ; String mapPath ( String path ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public class Ildasm extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File sourceFile ; private File destFile ; private boolean progressBar = false ; private String encoding ; private boolean bytes = false ; private boolean linenumbers = false ; private boolean rawExceptionHandling = false ; private boolean showSource = false ; private boolean quoteallnames = false ; private boolean header = false ; private boolean assembler = true ; private boolean metadata = false ; private String visibility ; private String item ; private String executable = "ildasm" ; private File resourceDir ; public void setResourceDir ( File resourceDir ) { this . resourceDir = resourceDir ; } public void setExecutable ( String executable ) { this . executable = executable ; } public void setEncoding ( EncodingTypes encoding ) { this . encoding = encoding . getValue ( ) ; } public void setAssembler ( boolean assembler ) { this . assembler = assembler ; } public void setBytes ( boolean bytes ) { this . bytes = bytes ; } public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setHeader ( boolean header ) { this . header = header ; } public void setItem ( String item ) { this . item = item ; } public void setLinenumbers ( boolean linenumbers ) { this . linenumbers = linenumbers ; } public void setMetadata ( boolean metadata ) { this . metadata = metadata ; } public void setProgressBar ( boolean progressBar ) { this . progressBar = progressBar ; } public void setQuoteallnames ( boolean quoteallnames ) { this . quoteallnames = quoteallnames ; } public void setRawExceptionHandling ( boolean rawExceptionHandling ) { this . rawExceptionHandling = rawExceptionHandling ; } public void setShowSource ( boolean showSource ) { this . showSource = showSource ; } public void setSourceFile ( File sourceFile ) { this . sourceFile = sourceFile ; } public void setSrcFile ( File sourceFile ) { setSourceFile ( sourceFile ) ; } public void setVisibility ( String visibility ) { this . visibility = visibility ; } private void validate ( ) { if ( sourceFile == null || ! sourceFile . exists ( ) || ! sourceFile . isFile ( ) ) { throw new BuildException ( "invalid source" ) ; } if ( destFile == null || destFile . isDirectory ( ) ) { throw new BuildException ( "invalid dest" ) ; } if ( resourceDir != null && ( ! resourceDir . exists ( ) || ! resourceDir . isDirectory ( ) ) ) { throw new BuildException ( "invalid resource directory" ) ; } } private boolean isDisassemblyNeeded ( ) { if ( ! destFile . exists ( ) ) { log ( "Destination file does not exist: a build is required" , Project . MSG_VERBOSE ) ; return true ; } long sourceTime = sourceFile . lastModified ( ) ; long destTime = destFile . lastModified ( ) ; if ( sourceTime > ( destTime + FILE_UTILS . getFileTimestampGranularity ( ) ) ) { log ( "Source file is newer than the dest file: a rebuild is required" , Project . MSG_VERBOSE ) ; return true ; } else { log ( "The .il file is up to date" , Project . MSG_VERBOSE ) ; return false ; } } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; if ( ! isDisassemblyNeeded ( ) ) { return ; } NetCommand command = new NetCommand ( this , "ildasm" , executable ) ; command . setFailOnError ( true ) ; command . addArgument ( "/text" ) ; command . addArgument ( "/out=" + destFile . toString ( ) ) ; if ( ! progressBar ) { command . addArgument ( "/nobar" ) ; } if ( linenumbers ) { command . addArgument ( "/linenum" ) ; } if ( showSource ) { command . addArgument ( "/source" ) ; } if ( quoteallnames ) { command . addArgument ( "/quoteallnames" ) ; } if ( header ) { command . addArgument ( "/header" ) ; } if ( ! assembler ) { command . addArgument ( "/noil" ) ; } if ( metadata ) { command . addArgument ( "/tokens" ) ; } command . addArgument ( "/item:" , item ) ; if ( rawExceptionHandling ) { command . addArgument ( "/raweh" ) ; } command . addArgument ( EncodingTypes . getEncodingOption ( encoding ) ) ; if ( bytes ) { command . addArgument ( "/bytes" ) ; } command . addArgument ( "/vis:" , visibility ) ; command . addArgument ( sourceFile . getAbsolutePath ( ) ) ; File execDir = resourceDir ; if ( execDir == null ) { execDir = destFile . getParentFile ( ) ; } command . setDirectory ( execDir ) ; try { command . runCommand ( ) ; } catch ( BuildException e ) { if ( destFile . exists ( ) ) { log ( "Deleting destination file as it may be corrupt" ) ; destFile . delete ( ) ; } throw e ; } } public static class EncodingTypes extends EnumeratedAttribute { public static final String UNICODE = "unicode" ; public static final String UTF8 = "utf8" ; public static final String ASCII = "ascii" ; public String [ ] getValues ( ) { return new String [ ] { ASCII , UTF8 , UNICODE , } ; } public static String getEncodingOption ( String enumValue ) { if ( UNICODE . equals ( enumValue ) ) { return "/unicode" ; } if ( UTF8 . equals ( enumValue ) ) { return "/utf8" ; } return null ; } } public static class VisibilityOptions extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "pub" , "pri" , "fam" , "asm" , "faa" , "foa" , "psc" , } ; } } } 	0	['22', '3', '0', '5', '47', '159', '0', '5', '19', '0.904761905', '365', '1', '1', '0.649122807', '0.361904762', '2', '2', '14.81818182', '9', '1.3636', '0']
package org . apache . tools . ant ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . WeakHashMap ; public class DemuxOutputStream extends OutputStream { private static class BufferInfo { private ByteArrayOutputStream buffer ; private boolean crSeen = false ; } private static final int MAX_SIZE = 1024 ; private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private WeakHashMap buffers = new WeakHashMap ( ) ; private Project project ; private boolean isErrorStream ; public DemuxOutputStream ( Project project , boolean isErrorStream ) { this . project = project ; this . isErrorStream = isErrorStream ; } private BufferInfo getBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; if ( bufferInfo == null ) { bufferInfo = new BufferInfo ( ) ; bufferInfo . buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; bufferInfo . crSeen = false ; buffers . put ( current , bufferInfo ) ; } return bufferInfo ; } private void resetBufferInfo ( ) { Thread current = Thread . currentThread ( ) ; BufferInfo bufferInfo = ( BufferInfo ) buffers . get ( current ) ; try { bufferInfo . buffer . close ( ) ; } catch ( IOException e ) { } bufferInfo . buffer = new ByteArrayOutputStream ( ) ; bufferInfo . crSeen = false ; } private void removeBuffer ( ) { Thread current = Thread . currentThread ( ) ; buffers . remove ( current ) ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; BufferInfo bufferInfo = getBufferInfo ( ) ; if ( c == '\n' ) { bufferInfo . buffer . write ( cc ) ; processBuffer ( bufferInfo . buffer ) ; } else { if ( bufferInfo . crSeen ) { processBuffer ( bufferInfo . buffer ) ; } bufferInfo . buffer . write ( cc ) ; } bufferInfo . crSeen = ( c == '\r' ) ; if ( ! bufferInfo . crSeen && bufferInfo . buffer . size ( ) > MAX_SIZE ) { processBuffer ( bufferInfo . buffer ) ; } } protected void processBuffer ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxOutput ( output , isErrorStream ) ; resetBufferInfo ( ) ; } protected void processFlush ( ByteArrayOutputStream buffer ) { String output = buffer . toString ( ) ; project . demuxFlush ( output , isErrorStream ) ; resetBufferInfo ( ) ; } public void close ( ) throws IOException { flush ( ) ; removeBuffer ( ) ; } public void flush ( ) throws IOException { BufferInfo bufferInfo = getBufferInfo ( ) ; if ( bufferInfo . buffer . size ( ) > 0 ) { processFlush ( bufferInfo . buffer ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; BufferInfo bufferInfo = getBufferInfo ( ) ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { bufferInfo . buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['10', '2', '0', '3', '30', '27', '1', '2', '5', '0.761904762', '245', '1', '1', '0.357142857', '0.283333333', '1', '1', '22.8', '2', '1', '0']
package org . apache . tools . ant . types ; import java . util . Stack ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . IdentityStack ; public abstract class DataType extends ProjectComponent implements Cloneable { protected Reference ref ; protected boolean checked = true ; public boolean isReference ( ) { return ref != null ; } public void setRefid ( final Reference ref ) { this . ref = ref ; checked = false ; } protected String getDataTypeName ( ) { return ComponentHelper . getElementName ( getProject ( ) , this , true ) ; } protected void dieOnCircularReference ( ) { dieOnCircularReference ( getProject ( ) ) ; } protected void dieOnCircularReference ( Project p ) { if ( checked || ! isReference ( ) ) { return ; } dieOnCircularReference ( new IdentityStack ( this ) , p ) ; } protected void dieOnCircularReference ( final Stack stack , final Project project ) throws BuildException { if ( checked || ! isReference ( ) ) { return ; } Object o = ref . getReferencedObject ( project ) ; if ( o instanceof DataType ) { IdentityStack id = IdentityStack . getInstance ( stack ) ; if ( id . contains ( o ) ) { throw circularReference ( ) ; } else { id . push ( o ) ; ( ( DataType ) o ) . dieOnCircularReference ( id , project ) ; id . pop ( ) ; } } checked = true ; } public static void invokeCircularReferenceCheck ( DataType dt , Stack stk , Project p ) { dt . dieOnCircularReference ( stk , p ) ; } protected Object getCheckedRef ( ) { return getCheckedRef ( getProject ( ) ) ; } protected Object getCheckedRef ( Project p ) { return getCheckedRef ( getClass ( ) , getDataTypeName ( ) , p ) ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName ) { return getCheckedRef ( requiredClass , dataTypeName , getProject ( ) ) ; } protected Object getCheckedRef ( final Class requiredClass , final String dataTypeName , final Project project ) { if ( project == null ) { throw new BuildException ( "No Project specified" ) ; } dieOnCircularReference ( project ) ; Object o = ref . getReferencedObject ( project ) ; if ( ! ( requiredClass . isAssignableFrom ( o . getClass ( ) ) ) ) { log ( "Class " + o . getClass ( ) + " is not a subclass of " + requiredClass , Project . MSG_VERBOSE ) ; String msg = ref . getRefId ( ) + " doesn\'t denote a " + dataTypeName ; throw new BuildException ( msg ) ; } return o ; } protected BuildException tooManyAttributes ( ) { return new BuildException ( "You must not specify more than one " + "attribute when using refid" ) ; } protected BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested elements " + "when using refid" ) ; } protected BuildException circularReference ( ) { return new BuildException ( "This data type contains a circular " + "reference." ) ; } protected boolean isChecked ( ) { return checked ; } protected void setChecked ( final boolean checked ) { this . checked = checked ; } public Reference getRefid ( ) { return ref ; } protected void checkAttributesAllowed ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } protected void checkChildrenAllowed ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } } public String toString ( ) { String d = getDescription ( ) ; return d == null ? getDataTypeName ( ) : getDataTypeName ( ) + " " + d ; } public Object clone ( ) throws CloneNotSupportedException { DataType dt = ( DataType ) super . clone ( ) ; dt . setDescription ( getDescription ( ) ) ; if ( getRefid ( ) != null ) { dt . setRefid ( getRefid ( ) ) ; } dt . setChecked ( isChecked ( ) ) ; return dt ; } } 	0	['22', '2', '28', '37', '44', '183', '31', '6', '7', '0.523809524', '271', '1', '1', '0.3', '0.198863636', '1', '2', '11.22727273', '3', '1.3182', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . types . Commandline ; public class XNewRmic extends ForkingSunRmic { public static final String COMPILER_NAME = "xnew" ; public XNewRmic ( ) { } protected Commandline setupRmicCommand ( ) { String [ ] options = new String [ ] { "-Xnew" } ; Commandline commandline = super . setupRmicCommand ( options ) ; return commandline ; } } 	0	['2', '3', '0', '3', '4', '1', '1', '2', '1', '2', '19', '0', '0', '0.9375', '1', '2', '2', '8', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . util . Enumeration ; import java . util . NoSuchElementException ; public final class Enumerations { private Enumerations ( ) { } public static Enumeration fromArray ( Object [ ] array ) { return new ArrayEnumeration ( array ) ; } public static Enumeration fromCompound ( Enumeration [ ] enums ) { return new CompoundEnumeration ( enums ) ; } } class ArrayEnumeration implements Enumeration { private Object [ ] array ; private int pos ; public ArrayEnumeration ( Object [ ] array ) { this . array = array ; this . pos = 0 ; } public boolean hasMoreElements ( ) { return ( pos < array . length ) ; } public Object nextElement ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { Object o = array [ pos ] ; pos ++ ; return o ; } throw new NoSuchElementException ( ) ; } } class CompoundEnumeration implements Enumeration { private Enumeration [ ] enumArray ; private int index = 0 ; public CompoundEnumeration ( Enumeration [ ] enumarray ) { this . enumArray = enumarray ; } public boolean hasMoreElements ( ) { while ( index < enumArray . length ) { if ( enumArray [ index ] != null && enumArray [ index ] . hasMoreElements ( ) ) { return true ; } index ++ ; } return false ; } public Object nextElement ( ) throws NoSuchElementException { if ( hasMoreElements ( ) ) { return enumArray [ index ] . nextElement ( ) ; } throw new NoSuchElementException ( ) ; } } 	0	['3', '1', '0', '3', '6', '3', '1', '2', '2', '2', '16', '0', '0', '0', '0.333333333', '0', '0', '4.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Nice extends Task { private Integer newPriority ; private String currentPriority ; public void execute ( ) throws BuildException { Thread self = Thread . currentThread ( ) ; int priority = self . getPriority ( ) ; if ( currentPriority != null ) { String current = Integer . toString ( priority ) ; getProject ( ) . setNewProperty ( currentPriority , current ) ; } if ( newPriority != null && priority != newPriority . intValue ( ) ) { try { self . setPriority ( newPriority . intValue ( ) ) ; } catch ( SecurityException e ) { log ( "Unable to set new priority -a security manager is in the way" , Project . MSG_WARN ) ; } catch ( IllegalArgumentException iae ) { throw new BuildException ( "Priority out of range" , iae ) ; } } } public void setCurrentPriority ( String currentPriority ) { this . currentPriority = currentPriority ; } public void setNewPriority ( int newPriority ) { if ( newPriority < Thread . MIN_PRIORITY || newPriority > Thread . MAX_PRIORITY ) { throw new BuildException ( "The thread priority is out of the range 1-10" ) ; } this . newPriority = new Integer ( newPriority ) ; } } 	0	['4', '3', '0', '3', '16', '2', '0', '3', '4', '0.666666667', '76', '1', '0', '0.925', '0.5', '1', '1', '17.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ScriptRunnerHelper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class Script extends Task { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public void execute ( ) throws BuildException { helper . getScriptRunner ( ) . executeScript ( "ANT" ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } public void setSrc ( String fileName ) { helper . setSrc ( new File ( fileName ) ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } public void setSetBeans ( boolean setBeans ) { helper . setSetBeans ( setBeans ) ; } } 	0	['11', '3', '0', '8', '26', '0', '0', '8', '11', '0', '76', '1', '1', '0.787234043', '0.287878788', '2', '2', '5.818181818', '1', '0.9091', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . io . IOException ; public class DifferentSelector extends MappingSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private boolean ignoreFileTimes = true ; private boolean ignoreContents = false ; public void setIgnoreFileTimes ( boolean ignoreFileTimes ) { this . ignoreFileTimes = ignoreFileTimes ; } public void setIgnoreContents ( boolean ignoreContents ) { this . ignoreContents = ignoreContents ; } protected boolean selectionTest ( File srcfile , File destfile ) { if ( srcfile . exists ( ) != destfile . exists ( ) ) { return true ; } if ( srcfile . length ( ) != destfile . length ( ) ) { return true ; } if ( ! ignoreFileTimes ) { boolean sameDate ; sameDate = destfile . lastModified ( ) >= srcfile . lastModified ( ) - granularity && destfile . lastModified ( ) <= srcfile . lastModified ( ) + granularity ; if ( ! sameDate ) { return true ; } } if ( ! ignoreContents ) { try { return ! FILE_UTILS . contentEquals ( srcfile , destfile ) ; } catch ( IOException e ) { throw new BuildException ( "while comparing " + srcfile + " and " + destfile , e ) ; } } else { return false ; } } } 	0	['5', '5', '0', '8', '16', '0', '5', '3', '3', '0.583333333', '105', '1', '1', '0.931818182', '0.583333333', '1', '1', '19.4', '9', '2.2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . util . Vector ; import org . w3c . dom . Attr ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Comment ; import org . w3c . dom . DOMException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . ProcessingInstruction ; import org . w3c . dom . Text ; public final class DOMUtil { private DOMUtil ( ) { } public interface NodeFilter { boolean accept ( Node node ) ; } public static NodeList listChildNodes ( Node parent , NodeFilter filter , boolean recurse ) { NodeListImpl matches = new NodeListImpl ( ) ; NodeList children = parent . getChildNodes ( ) ; if ( children != null ) { final int len = children . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Node child = children . item ( i ) ; if ( filter . accept ( child ) ) { matches . addElement ( child ) ; } if ( recurse ) { NodeList recmatches = listChildNodes ( child , filter , recurse ) ; final int reclength = recmatches . getLength ( ) ; for ( int j = 0 ; j < reclength ; j ++ ) { matches . addElement ( recmatches . item ( i ) ) ; } } } } return matches ; } public static class NodeListImpl extends Vector implements NodeList { public int getLength ( ) { return size ( ) ; } public Node item ( int i ) { try { return ( Node ) elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } } public static String getNodeAttribute ( Node node , String name ) { if ( node instanceof Element ) { Element element = ( Element ) node ; return element . getAttribute ( name ) ; } return null ; } public static Element getChildByTagName ( Node parent , String tagname ) { if ( parent == null ) { return null ; } NodeList childList = parent . getChildNodes ( ) ; final int len = childList . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Node child = childList . item ( i ) ; if ( child != null && child . getNodeType ( ) == Node . ELEMENT_NODE && child . getNodeName ( ) . equals ( tagname ) ) { return ( Element ) child ; } } return null ; } public static Node importNode ( Node parent , Node child ) { Node copy = null ; final Document doc = parent . getOwnerDocument ( ) ; switch ( child . getNodeType ( ) ) { case Node . CDATA_SECTION_NODE : copy = doc . createCDATASection ( ( ( CDATASection ) child ) . getData ( ) ) ; break ; case Node . COMMENT_NODE : copy = doc . createComment ( ( ( Comment ) child ) . getData ( ) ) ; break ; case Node . DOCUMENT_FRAGMENT_NODE : copy = doc . createDocumentFragment ( ) ; break ; case Node . ELEMENT_NODE : final Element elem = doc . createElement ( ( ( Element ) child ) . getTagName ( ) ) ; copy = elem ; final NamedNodeMap attributes = child . getAttributes ( ) ; if ( attributes != null ) { final int size = attributes . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Attr attr = ( Attr ) attributes . item ( i ) ; elem . setAttribute ( attr . getName ( ) , attr . getValue ( ) ) ; } } break ; case Node . ENTITY_REFERENCE_NODE : copy = doc . createEntityReference ( child . getNodeName ( ) ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : final ProcessingInstruction pi = ( ProcessingInstruction ) child ; copy = doc . createProcessingInstruction ( pi . getTarget ( ) , pi . getData ( ) ) ; break ; case Node . TEXT_NODE : copy = doc . createTextNode ( ( ( Text ) child ) . getData ( ) ) ; break ; default : throw new IllegalStateException ( "Invalid node type: " + child . getNodeType ( ) ) ; } try { final NodeList children = child . getChildNodes ( ) ; if ( children != null ) { final int size = children . getLength ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Node newChild = children . item ( i ) ; if ( newChild != null ) { importNode ( copy , newChild ) ; } } } } catch ( DOMException ignored ) { } parent . appendChild ( copy ) ; return copy ; } } 	0	['5', '1', '0', '3', '41', '10', '1', '2', '4', '2', '241', '0', '0', '0', '0.36', '0', '0', '47.2', '7', '4.2', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; import java . io . FileInputStream ; import java . security . DigestInputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . NoSuchProviderException ; import org . apache . tools . ant . BuildException ; public class DigestAlgorithm implements Algorithm { private String algorithm = "MD5" ; private String provider = null ; private MessageDigest messageDigest = null ; private int readBufferSize = 8 * 1024 ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void setProvider ( String provider ) { this . provider = provider ; } public void initMessageDigest ( ) { if ( messageDigest != null ) { return ; } if ( ( provider != null ) && ! "" . equals ( provider ) && ! "null" . equals ( provider ) ) { try { messageDigest = MessageDigest . getInstance ( algorithm , provider ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } catch ( NoSuchProviderException noprovider ) { throw new BuildException ( noprovider ) ; } } else { try { messageDigest = MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException noalgo ) { throw new BuildException ( noalgo ) ; } } } public boolean isValid ( ) { return "SHA" . equalsIgnoreCase ( algorithm ) || "MD5" . equalsIgnoreCase ( algorithm ) ; } public String getValue ( File file ) { initMessageDigest ( ) ; String checksum = null ; try { if ( ! file . canRead ( ) ) { return null ; } FileInputStream fis = null ; byte [ ] buf = new byte [ readBufferSize ] ; try { messageDigest . reset ( ) ; fis = new FileInputStream ( file ) ; DigestInputStream dis = new DigestInputStream ( fis , messageDigest ) ; while ( dis . read ( buf , 0 , readBufferSize ) != - 1 ) { } dis . close ( ) ; fis . close ( ) ; fis = null ; byte [ ] fileDigest = messageDigest . digest ( ) ; StringBuffer checksumSb = new StringBuffer ( ) ; for ( int i = 0 ; i < fileDigest . length ; i ++ ) { String hexStr = Integer . toHexString ( 0x00ff & fileDigest [ i ] ) ; if ( hexStr . length ( ) < 2 ) { checksumSb . append ( "0" ) ; } checksumSb . append ( hexStr ) ; } checksum = checksumSb . toString ( ) ; } catch ( Exception e ) { return null ; } } catch ( Exception e ) { return null ; } return checksum ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<DigestAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ";provider=" ) . append ( provider ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['7', '1', '0', '3', '26', '0', '1', '2', '7', '0.5', '218', '1', '0', '0', '0.476190476', '0', '0', '29.57142857', '5', '2.2857', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . IOException ; import java . io . PrintWriter ; import java . text . SimpleDateFormat ; import java . util . Enumeration ; import java . util . TimeZone ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DOMUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class ChangeLogWriter { private static final SimpleDateFormat OUTPUT_DATE = new SimpleDateFormat ( "yyyy-MM-dd" ) ; private static final SimpleDateFormat OUTPUT_TIME = new SimpleDateFormat ( "HH:mm" ) ; private static final DOMElementWriter DOM_WRITER = new DOMElementWriter ( ) ; static { TimeZone utc = TimeZone . getTimeZone ( "UTC" ) ; OUTPUT_DATE . setTimeZone ( utc ) ; OUTPUT_TIME . setTimeZone ( utc ) ; } public void printChangeLog ( final PrintWriter output , final CVSEntry [ ] entries ) { try { output . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; Document doc = DOMUtils . newDocument ( ) ; Element root = doc . createElement ( "changelog" ) ; DOM_WRITER . openElement ( root , output , 0 , "\t" ) ; output . println ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { final CVSEntry entry = entries [ i ] ; printEntry ( doc , output , entry ) ; } DOM_WRITER . closeElement ( root , output , 0 , "\t" , true ) ; output . flush ( ) ; output . close ( ) ; } catch ( IOException e ) { throw new org . apache . tools . ant . BuildException ( e ) ; } } private void printEntry ( Document doc , final PrintWriter output , final CVSEntry entry ) throws IOException { Element ent = doc . createElement ( "entry" ) ; DOMUtils . appendTextElement ( ent , "date" , OUTPUT_DATE . format ( entry . getDate ( ) ) ) ; DOMUtils . appendTextElement ( ent , "time" , OUTPUT_TIME . format ( entry . getDate ( ) ) ) ; DOMUtils . appendCDATAElement ( ent , "author" , entry . getAuthor ( ) ) ; final Enumeration enumeration = entry . getFiles ( ) . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { final RCSFile file = ( RCSFile ) enumeration . nextElement ( ) ; Element f = DOMUtils . createChildElement ( ent , "file" ) ; DOMUtils . appendCDATAElement ( f , "name" , file . getName ( ) ) ; DOMUtils . appendTextElement ( f , "revision" , file . getRevision ( ) ) ; final String previousRevision = file . getPreviousRevision ( ) ; if ( previousRevision != null ) { DOMUtils . appendTextElement ( f , "prevrevision" , previousRevision ) ; } } DOMUtils . appendCDATAElement ( ent , "msg" , entry . getComment ( ) ) ; DOM_WRITER . write ( ent , output , 1 , "\t" ) ; } } 	0	['4', '1', '0', '6', '33', '0', '1', '5', '2', '0.333333333', '157', '1', '1', '0', '0.533333333', '0', '0', '37.5', '2', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; public class JarLibDisplayTask extends Task { private File libraryFile ; private final Vector libraryFileSets = new Vector ( ) ; public void setFile ( final File file ) { this . libraryFile = file ; } public void addFileset ( final FileSet fileSet ) { libraryFileSets . addElement ( fileSet ) ; } public void execute ( ) throws BuildException { validate ( ) ; final LibraryDisplayer displayer = new LibraryDisplayer ( ) ; if ( ! libraryFileSets . isEmpty ( ) ) { final Iterator iterator = libraryFileSets . iterator ( ) ; while ( iterator . hasNext ( ) ) { final FileSet fileSet = ( FileSet ) iterator . next ( ) ; final DirectoryScanner scanner = fileSet . getDirectoryScanner ( getProject ( ) ) ; final File basedir = scanner . getBasedir ( ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { final File file = new File ( basedir , files [ i ] ) ; displayer . displayLibrary ( file ) ; } } } else { displayer . displayLibrary ( libraryFile ) ; } } private void validate ( ) throws BuildException { if ( null == libraryFile && libraryFileSets . isEmpty ( ) ) { final String message = "File attribute not specified." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . exists ( ) ) { final String message = "File '" + libraryFile + "' does not exist." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . isFile ( ) ) { final String message = "\'" + libraryFile + "\' is not a file." ; throw new BuildException ( message ) ; } } } 	0	['5', '3', '0', '6', '26', '0', '0', '6', '4', '0.375', '141', '1', '0', '0.902439024', '0.466666667', '0', '0', '26.8', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . Task ; public class TaskOutputStream extends OutputStream { private Task task ; private StringBuffer line ; private int msgOutputLevel ; TaskOutputStream ( Task task , int msgOutputLevel ) { System . err . println ( "As of Ant 1.2 released in October 2000, the " + "TaskOutputStream class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . msgOutputLevel = msgOutputLevel ; line = new StringBuffer ( ) ; } public void write ( int c ) throws IOException { char cc = ( char ) c ; if ( cc == '\r' || cc == '\n' ) { if ( line . length ( ) > 0 ) { processLine ( ) ; } } else { line . append ( cc ) ; } } private void processLine ( ) { String s = line . toString ( ) ; task . log ( s , msgOutputLevel ) ; line = new StringBuffer ( ) ; } } 	0	['3', '2', '0', '1', '10', '0', '0', '1', '1', '0', '67', '1', '1', '0.714285714', '0.666666667', '1', '1', '20.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Comparison ; public class Size implements ResourceSelector { private long size = - 1 ; private Comparison when = Comparison . EQUAL ; public void setSize ( long l ) { size = l ; } public long getSize ( ) { return size ; } public void setWhen ( Comparison c ) { when = c ; } public Comparison getWhen ( ) { return when ; } public boolean isSelected ( Resource r ) { long diff = r . getSize ( ) - size ; return when . evaluate ( diff == 0 ? 0 : ( int ) ( diff / Math . abs ( diff ) ) ) ; } } 	0	['6', '1', '0', '3', '10', '0', '0', '3', '6', '0.4', '52', '1', '1', '0', '0.375', '0', '0', '7.333333333', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class MajoritySelector extends BaseSelectorContainer { private boolean allowtie = true ; public MajoritySelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{majorityselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void setAllowtie ( boolean tiebreaker ) { allowtie = tiebreaker ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; int yesvotes = 0 ; int novotes = 0 ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { yesvotes = yesvotes + 1 ; } else { novotes = novotes + 1 ; } } if ( yesvotes > novotes ) { return true ; } else if ( novotes > yesvotes ) { return false ; } return allowtie ; } } 	0	['4', '5', '0', '7', '15', '0', '6', '2', '4', '0.333333333', '77', '1', '0', '0.953846154', '0.4375', '1', '1', '18', '5', '2', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . taskdefs . Execute ; public class IsFailure implements Condition { private int code ; public void setCode ( int c ) { code = c ; } public int getCode ( ) { return code ; } public boolean eval ( ) { return Execute . isFailure ( code ) ; } } 	0	['4', '1', '0', '2', '6', '0', '0', '2', '4', '0.333333333', '19', '1', '0', '0', '0.625', '0', '0', '3.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedOutputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . lang . reflect . Field ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; abstract class XalanExecutor { private static final String PACKAGE = "org.apache.tools.ant.taskdefs.optional.junit." ; protected AggregateTransformer caller ; private void setCaller ( AggregateTransformer caller ) { this . caller = caller ; } protected final OutputStream getOutputStream ( ) throws IOException { if ( AggregateTransformer . FRAMES . equals ( caller . format ) ) { return new ByteArrayOutputStream ( ) ; } else { return new BufferedOutputStream ( new FileOutputStream ( new File ( caller . toDir , "junit-noframes.html" ) ) ) ; } } abstract void execute ( ) throws Exception ; static XalanExecutor newInstance ( AggregateTransformer caller ) throws BuildException { XalanExecutor executor = null ; try { Class clazz = Class . forName ( PACKAGE + "Xalan2Executor" ) ; executor = ( XalanExecutor ) clazz . newInstance ( ) ; } catch ( Exception xsltcApacheMissing ) { caller . task . log ( xsltcApacheMissing . toString ( ) ) ; throw new BuildException ( "Could not find xstlc nor xalan2 " + "in the classpath. Check " + "http://xml.apache.org/xalan-j" ) ; } String classNameImpl = executor . getImplementation ( ) ; String version = executor . getProcVersion ( classNameImpl ) ; caller . task . log ( "Using " + version , Project . MSG_VERBOSE ) ; executor . setCaller ( caller ) ; return executor ; } protected abstract String getImplementation ( ) ; protected abstract String getProcVersion ( String classNameImpl ) throws BuildException ; protected final String getXSLTCVersion ( String procVersionClassName ) throws ClassNotFoundException { Class procVersion = Class . forName ( procVersionClassName ) ; Package pkg = procVersion . getPackage ( ) ; return pkg . getName ( ) + " " + pkg . getImplementationTitle ( ) + " " + pkg . getImplementationVersion ( ) ; } protected final String getXalanVersion ( String procVersionClassName ) throws ClassNotFoundException { Class procVersion = Class . forName ( procVersionClassName ) ; String pkg = procVersion . getPackage ( ) . getName ( ) ; try { Field f = procVersion . getField ( "S_VERSION" ) ; return pkg + " " + f . get ( null ) . toString ( ) ; } catch ( Exception e ) { return pkg + " ?.?" ; } } } 	0	['9', '1', '1', '4', '32', '34', '1', '3', '0', '0.9375', '145', '1', '1', '0', '0.481481481', '0', '0', '14.88888889', '1', '0.8889', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class SizeSelector extends BaseExtendSelector { public static final String SIZE_KEY = "value" ; public static final String UNITS_KEY = "units" ; public static final String WHEN_KEY = "when" ; private long size = - 1 ; private long multiplier = 1 ; private long sizelimit = - 1 ; private Comparison when = Comparison . EQUAL ; public SizeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{sizeselector value: " ) ; buf . append ( sizelimit ) ; buf . append ( "compare: " ) . append ( when . getValue ( ) ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setValue ( long size ) { this . size = size ; if ( multiplier != 0 && size > - 1 ) { sizelimit = size * multiplier ; } } public void setUnits ( ByteUnits units ) { int i = units . getIndex ( ) ; multiplier = 0 ; if ( i > - 1 && i < 4 ) { multiplier = 1000 ; } else if ( i > 3 && i < 9 ) { multiplier = 1024 ; } else if ( i > 8 && i < 13 ) { multiplier = 1000000 ; } else if ( i > 12 && i < 18 ) { multiplier = 1048576 ; } else if ( i > 17 && i < 22 ) { multiplier = 1000000000L ; } else if ( i > 21 && i < 27 ) { multiplier = 1073741824L ; } else if ( i > 26 && i < 31 ) { multiplier = 1000000000000L ; } else if ( i > 30 && i < 36 ) { multiplier = 1099511627776L ; } if ( multiplier > 0 && size > - 1 ) { sizelimit = size * multiplier ; } } public void setWhen ( SizeComparisons when ) { this . when = when ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( SIZE_KEY . equalsIgnoreCase ( paramname ) ) { try { setValue ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid size setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( UNITS_KEY . equalsIgnoreCase ( paramname ) ) { ByteUnits units = new ByteUnits ( ) ; units . setValue ( parameters [ i ] . getValue ( ) ) ; setUnits ( units ) ; } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { SizeComparisons scmp = new SizeComparisons ( ) ; scmp . setValue ( parameters [ i ] . getValue ( ) ) ; setWhen ( scmp ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( size < 0 ) { setError ( "The value attribute is required, and must be positive" ) ; } else if ( multiplier < 1 ) { setError ( "Invalid Units supplied, must be K,Ki,M,Mi,G,Gi,T,or Ti" ) ; } else if ( sizelimit < 0 ) { setError ( "Internal error: Code is not setting sizelimit correctly" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return true ; } long diff = file . length ( ) - sizelimit ; return when . evaluate ( diff == 0 ? 0 : ( int ) ( diff / Math . abs ( diff ) ) ) ; } public static class ByteUnits extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "K" , "k" , "kilo" , "KILO" , "Ki" , "KI" , "ki" , "kibi" , "KIBI" , "M" , "m" , "mega" , "MEGA" , "Mi" , "MI" , "mi" , "mebi" , "MEBI" , "G" , "g" , "giga" , "GIGA" , "Gi" , "GI" , "gi" , "gibi" , "GIBI" , "T" , "t" , "tera" , "TERA" , "Ti" , "TI" , "ti" , "tebi" , "TEBI" } ; } } public static class SizeComparisons extends Comparison { } } 	0	['8', '5', '0', '11', '31', '0', '6', '5', '8', '0.693877551', '329', '0.571428571', '1', '0.844444444', '0.25', '1', '4', '39.25', '19', '4.625', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . StreamPumper ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; public class Cab extends MatchingTask { private File cabFile ; private File baseDir ; private Vector filesets = new Vector ( ) ; private boolean doCompress = true ; private boolean doVerbose = false ; private String cmdOptions ; protected String archiveType = "cab" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setCabfile ( File cabFile ) { this . cabFile = cabFile ; } public void setBasedir ( File baseDir ) { this . baseDir = baseDir ; } public void setCompress ( boolean compress ) { doCompress = compress ; } public void setVerbose ( boolean verbose ) { doVerbose = verbose ; } public void setOptions ( String options ) { cmdOptions = options ; } public void addFileset ( FileSet set ) { if ( filesets . size ( ) > 0 ) { throw new BuildException ( "Only one nested fileset allowed" ) ; } filesets . addElement ( set ) ; } protected void checkConfiguration ( ) throws BuildException { if ( baseDir == null && filesets . size ( ) == 0 ) { throw new BuildException ( "basedir attribute or one " + "nested fileset is required!" , getLocation ( ) ) ; } if ( baseDir != null && ! baseDir . exists ( ) ) { throw new BuildException ( "basedir does not exist!" , getLocation ( ) ) ; } if ( baseDir != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Both basedir attribute and a nested fileset is not allowed" ) ; } if ( cabFile == null ) { throw new BuildException ( "cabfile attribute must be set!" , getLocation ( ) ) ; } } protected ExecTask createExec ( ) throws BuildException { ExecTask exec = new ExecTask ( this ) ; return exec ; } protected boolean isUpToDate ( Vector files ) { boolean upToDate = true ; for ( int i = 0 ; i < files . size ( ) && upToDate ; i ++ ) { String file = files . elementAt ( i ) . toString ( ) ; if ( FILE_UTILS . resolveFile ( baseDir , file ) . lastModified ( ) > cabFile . lastModified ( ) ) { upToDate = false ; } } return upToDate ; } protected File createListFile ( Vector files ) throws IOException { File listFile = FILE_UTILS . createTempFile ( "ant" , "" , null ) ; listFile . deleteOnExit ( ) ; PrintWriter writer = new PrintWriter ( new FileOutputStream ( listFile ) ) ; int size = files . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { writer . println ( '\"' + files . elementAt ( i ) . toString ( ) + '\"' ) ; } writer . close ( ) ; return listFile ; } protected void appendFiles ( Vector files , DirectoryScanner ds ) { String [ ] dsfiles = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < dsfiles . length ; i ++ ) { files . addElement ( dsfiles [ i ] ) ; } } protected Vector getFileList ( ) throws BuildException { Vector files = new Vector ( ) ; if ( baseDir != null ) { appendFiles ( files , super . getDirectoryScanner ( baseDir ) ) ; } else { FileSet fs = ( FileSet ) filesets . elementAt ( 0 ) ; baseDir = fs . getDir ( ) ; appendFiles ( files , fs . getDirectoryScanner ( getProject ( ) ) ) ; } return files ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; Vector files = getFileList ( ) ; if ( isUpToDate ( files ) ) { return ; } log ( "Building " + archiveType + ": " + cabFile . getAbsolutePath ( ) ) ; if ( ! Os . isFamily ( "windows" ) ) { log ( "Using listcab/libcabinet" , Project . MSG_VERBOSE ) ; StringBuffer sb = new StringBuffer ( ) ; Enumeration fileEnum = files . elements ( ) ; while ( fileEnum . hasMoreElements ( ) ) { sb . append ( fileEnum . nextElement ( ) ) . append ( "\n" ) ; } sb . append ( "\n" ) . append ( cabFile . getAbsolutePath ( ) ) . append ( "\n" ) ; try { Process p = Execute . launch ( getProject ( ) , new String [ ] { "listcab" } , null , baseDir != null ? baseDir : getProject ( ) . getBaseDir ( ) , true ) ; OutputStream out = p . getOutputStream ( ) ; LogOutputStream outLog = new LogOutputStream ( this , Project . MSG_VERBOSE ) ; LogOutputStream errLog = new LogOutputStream ( this , Project . MSG_ERR ) ; StreamPumper outPump = new StreamPumper ( p . getInputStream ( ) , outLog ) ; StreamPumper errPump = new StreamPumper ( p . getErrorStream ( ) , errLog ) ; ( new Thread ( outPump ) ) . start ( ) ; ( new Thread ( errPump ) ) . start ( ) ; out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; out . close ( ) ; int result = - 99 ; try { result = p . waitFor ( ) ; outPump . waitFor ( ) ; outLog . close ( ) ; errPump . waitFor ( ) ; errLog . close ( ) ; } catch ( InterruptedException ie ) { log ( "Thread interrupted: " + ie ) ; } if ( Execute . isFailure ( result ) ) { log ( "Error executing listcab; error code: " + result ) ; } } catch ( IOException ex ) { String msg = "Problem creating " + cabFile + " " + ex . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } else { try { File listFile = createListFile ( files ) ; ExecTask exec = createExec ( ) ; File outFile = null ; exec . setFailonerror ( true ) ; exec . setDir ( baseDir ) ; if ( ! doVerbose ) { outFile = FILE_UTILS . createTempFile ( "ant" , "" , null ) ; outFile . deleteOnExit ( ) ; exec . setOutput ( outFile ) ; } exec . setExecutable ( "cabarc" ) ; exec . createArg ( ) . setValue ( "-r" ) ; exec . createArg ( ) . setValue ( "-p" ) ; if ( ! doCompress ) { exec . createArg ( ) . setValue ( "-m" ) ; exec . createArg ( ) . setValue ( "none" ) ; } if ( cmdOptions != null ) { exec . createArg ( ) . setLine ( cmdOptions ) ; } exec . createArg ( ) . setValue ( "n" ) ; exec . createArg ( ) . setFile ( cabFile ) ; exec . createArg ( ) . setValue ( "@" + listFile . getAbsolutePath ( ) ) ; exec . execute ( ) ; if ( outFile != null ) { outFile . delete ( ) ; } listFile . delete ( ) ; } catch ( IOException ioe ) { String msg = "Problem creating " + cabFile + " " + ioe . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } } 	0	['15', '4', '0', '14', '83', '47', '0', '14', '8', '0.821428571', '566', '1', '1', '0.857142857', '0.244897959', '2', '2', '36.2', '4', '1.2', '0']
package org . apache . tools . ant . util ; public interface TimeoutObserver { void timeoutOccured ( Watchdog w ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import org . w3c . dom . Attr ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; public class DOMElementWriter { private static final String NS = "ns" ; private boolean xmlDeclaration = true ; private XmlNamespacePolicy namespacePolicy = XmlNamespacePolicy . IGNORE ; private HashMap nsPrefixMap = new HashMap ( ) ; private int nextPrefix = 0 ; private HashMap nsURIByElement = new HashMap ( ) ; public static class XmlNamespacePolicy { private boolean qualifyElements ; private boolean qualifyAttributes ; public static final XmlNamespacePolicy IGNORE = new XmlNamespacePolicy ( false , false ) ; public static final XmlNamespacePolicy ONLY_QUALIFY_ELEMENTS = new XmlNamespacePolicy ( true , false ) ; public static final XmlNamespacePolicy QUALIFY_ALL = new XmlNamespacePolicy ( true , true ) ; public XmlNamespacePolicy ( boolean qualifyElements , boolean qualifyAttributes ) { this . qualifyElements = qualifyElements ; this . qualifyAttributes = qualifyAttributes ; } } public DOMElementWriter ( ) { } public DOMElementWriter ( boolean xmlDeclaration ) { this ( xmlDeclaration , XmlNamespacePolicy . IGNORE ) ; } public DOMElementWriter ( boolean xmlDeclaration , XmlNamespacePolicy namespacePolicy ) { this . xmlDeclaration = xmlDeclaration ; this . namespacePolicy = namespacePolicy ; } private static String lSep = System . getProperty ( "line.separator" ) ; protected String [ ] knownEntities = { "gt" , "amp" , "lt" , "apos" , "quot" } ; public void write ( Element root , OutputStream out ) throws IOException { Writer wri = new OutputStreamWriter ( out , "UTF8" ) ; writeXMLDeclaration ( wri ) ; write ( root , wri , 0 , "  " ) ; wri . flush ( ) ; } public void writeXMLDeclaration ( Writer wri ) throws IOException { if ( xmlDeclaration ) { wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; } } public void write ( Element element , Writer out , int indent , String indentWith ) throws IOException { NodeList children = element . getChildNodes ( ) ; boolean hasChildren = ( children . getLength ( ) > 0 ) ; boolean hasChildElements = false ; openElement ( element , out , indent , indentWith , hasChildren ) ; if ( hasChildren ) { for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . ELEMENT_NODE : hasChildElements = true ; if ( i == 0 ) { out . write ( lSep ) ; } write ( ( Element ) child , out , indent + 1 , indentWith ) ; break ; case Node . TEXT_NODE : out . write ( encode ( child . getNodeValue ( ) ) ) ; break ; case Node . COMMENT_NODE : out . write ( "<!--" ) ; out . write ( encode ( child . getNodeValue ( ) ) ) ; out . write ( "-->" ) ; break ; case Node . CDATA_SECTION_NODE : out . write ( "<![CDATA[" ) ; out . write ( encodedata ( ( ( Text ) child ) . getData ( ) ) ) ; out . write ( "]]>" ) ; break ; case Node . ENTITY_REFERENCE_NODE : out . write ( '&' ) ; out . write ( child . getNodeName ( ) ) ; out . write ( ';' ) ; break ; case Node . PROCESSING_INSTRUCTION_NODE : out . write ( "<?" ) ; out . write ( child . getNodeName ( ) ) ; String data = child . getNodeValue ( ) ; if ( data != null && data . length ( ) > 0 ) { out . write ( ' ' ) ; out . write ( data ) ; } out . write ( "?>" ) ; break ; default : } } closeElement ( element , out , indent , indentWith , hasChildElements ) ; } } public void openElement ( Element element , Writer out , int indent , String indentWith ) throws IOException { openElement ( element , out , indent , indentWith , true ) ; } public void openElement ( Element element , Writer out , int indent , String indentWith , boolean hasChildren ) throws IOException { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } out . write ( "<" ) ; if ( namespacePolicy . qualifyElements ) { String uri = getNamespaceURI ( element ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix == null ) { if ( nsPrefixMap . isEmpty ( ) ) { prefix = "" ; } else { prefix = NS + ( nextPrefix ++ ) ; } nsPrefixMap . put ( uri , prefix ) ; addNSDefinition ( element , uri ) ; } if ( ! "" . equals ( prefix ) ) { out . write ( prefix ) ; out . write ( ":" ) ; } } out . write ( element . getTagName ( ) ) ; NamedNodeMap attrs = element . getAttributes ( ) ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; out . write ( " " ) ; if ( namespacePolicy . qualifyAttributes ) { String uri = getNamespaceURI ( attr ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix == null ) { prefix = NS + ( nextPrefix ++ ) ; nsPrefixMap . put ( uri , prefix ) ; addNSDefinition ( element , uri ) ; } out . write ( prefix ) ; out . write ( ":" ) ; } out . write ( attr . getName ( ) ) ; out . write ( "=\"" ) ; out . write ( encode ( attr . getValue ( ) ) ) ; out . write ( "\"" ) ; } ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al != null ) { Iterator iter = al . iterator ( ) ; while ( iter . hasNext ( ) ) { String uri = ( String ) iter . next ( ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; out . write ( " xmlns" ) ; if ( ! "" . equals ( prefix ) ) { out . write ( ":" ) ; out . write ( prefix ) ; } out . write ( "=\"" ) ; out . write ( uri ) ; out . write ( "\"" ) ; } } if ( hasChildren ) { out . write ( ">" ) ; } else { removeNSDefinitions ( element ) ; out . write ( " />" ) ; out . write ( lSep ) ; out . flush ( ) ; } } public void closeElement ( Element element , Writer out , int indent , String indentWith , boolean hasChildren ) throws IOException { if ( hasChildren ) { for ( int i = 0 ; i < indent ; i ++ ) { out . write ( indentWith ) ; } } out . write ( "</" ) ; if ( namespacePolicy . qualifyElements ) { String uri = getNamespaceURI ( element ) ; String prefix = ( String ) nsPrefixMap . get ( uri ) ; if ( prefix != null && ! "" . equals ( prefix ) ) { out . write ( prefix ) ; out . write ( ":" ) ; } removeNSDefinitions ( element ) ; } out . write ( element . getTagName ( ) ) ; out . write ( ">" ) ; out . write ( lSep ) ; out . flush ( ) ; } public String encode ( String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '\'' : sb . append ( "&apos;" ) ; break ; case '\"' : sb . append ( "&quot;" ) ; break ; case '&' : int nextSemi = value . indexOf ( ";" , i ) ; if ( nextSemi < 0 || ! isReference ( value . substring ( i , nextSemi + 1 ) ) ) { sb . append ( "&amp;" ) ; } else { sb . append ( '&' ) ; } break ; default : if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } break ; } } return sb . substring ( 0 ) ; } public String encodedata ( final String value ) { StringBuffer sb = new StringBuffer ( ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( isLegalCharacter ( c ) ) { sb . append ( c ) ; } } String result = sb . substring ( 0 ) ; int cdEnd = result . indexOf ( "]]>" ) ; while ( cdEnd != - 1 ) { sb . setLength ( cdEnd ) ; sb . append ( "&#x5d;&#x5d;&gt;" ) . append ( result . substring ( cdEnd + 3 ) ) ; result = sb . substring ( 0 ) ; cdEnd = result . indexOf ( "]]>" ) ; } return result ; } public boolean isReference ( String ent ) { if ( ! ( ent . charAt ( 0 ) == '&' ) || ! ent . endsWith ( ";" ) ) { return false ; } if ( ent . charAt ( 1 ) == '#' ) { if ( ent . charAt ( 2 ) == 'x' ) { try { Integer . parseInt ( ent . substring ( 3 , ent . length ( ) - 1 ) , 16 ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } else { try { Integer . parseInt ( ent . substring ( 2 , ent . length ( ) - 1 ) ) ; return true ; } catch ( NumberFormatException nfe ) { return false ; } } } String name = ent . substring ( 1 , ent . length ( ) - 1 ) ; for ( int i = 0 ; i < knownEntities . length ; i ++ ) { if ( name . equals ( knownEntities [ i ] ) ) { return true ; } } return false ; } public boolean isLegalCharacter ( char c ) { if ( c == 0x9 || c == 0xA || c == 0xD ) { return true ; } else if ( c < 0x20 ) { return false ; } else if ( c <= 0xD7FF ) { return true ; } else if ( c < 0xE000 ) { return false ; } else if ( c <= 0xFFFD ) { return true ; } return false ; } private void removeNSDefinitions ( Element element ) { ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al != null ) { Iterator iter = al . iterator ( ) ; while ( iter . hasNext ( ) ) { nsPrefixMap . remove ( iter . next ( ) ) ; } nsURIByElement . remove ( element ) ; } } private void addNSDefinition ( Element element , String uri ) { ArrayList al = ( ArrayList ) nsURIByElement . get ( element ) ; if ( al == null ) { al = new ArrayList ( ) ; nsURIByElement . put ( element , al ) ; } al . add ( uri ) ; } private static String getNamespaceURI ( Node n ) { String uri = n . getNamespaceURI ( ) ; if ( uri == null ) { uri = "" ; } return uri ; } } 	0	['17', '1', '0', '8', '67', '90', '7', '1', '13', '0.703125', '878', '1', '1', '0', '0.29375', '0', '0', '50.17647059', '11', '2.5294', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . util . FileUtils ; public abstract class CompressedResource extends Resource { private Resource resource ; public CompressedResource ( ) { } public CompressedResource ( ResourceCollection other ) { addConfigured ( other ) ; } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( resource != null ) { throw new BuildException ( "you must not specify more than one" + " resource" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported" ) ; } resource = ( Resource ) a . iterator ( ) . next ( ) ; } public String getName ( ) { return getResource ( ) . getName ( ) ; } public void setName ( String name ) throws BuildException { throw new BuildException ( "you can't change the name of a compressed" + " resource" ) ; } public boolean isExists ( ) { return getResource ( ) . isExists ( ) ; } public void setExists ( boolean exists ) { throw new BuildException ( "you can't change the exists state of a " + " compressed resource" ) ; } public long getLastModified ( ) { return getResource ( ) . getLastModified ( ) ; } public void setLastModified ( long lastmodified ) throws BuildException { throw new BuildException ( "you can't change the timestamp of a " + " compressed resource" ) ; } public boolean isDirectory ( ) { return getResource ( ) . isDirectory ( ) ; } public void setDirectory ( boolean directory ) throws BuildException { throw new BuildException ( "you can't change the directory state of a " + " compressed resource" ) ; } public long getSize ( ) { if ( isExists ( ) ) { InputStream in = null ; try { in = getInputStream ( ) ; byte [ ] buf = new byte [ 8192 ] ; int size = 0 ; int readNow ; while ( ( readNow = in . read ( buf , 0 , buf . length ) ) > 0 ) { size += readNow ; } return size ; } catch ( IOException ex ) { throw new BuildException ( "caught exception while reading " + getName ( ) , ex ) ; } finally { FileUtils . close ( in ) ; } } else { return 0 ; } } public void setSize ( long size ) throws BuildException { throw new BuildException ( "you can't change the size of a " + " compressed resource" ) ; } public int compareTo ( Object other ) { if ( other == this ) { return 0 ; } if ( other instanceof CompressedResource ) { return getResource ( ) . compareTo ( ( ( CompressedResource ) other ) . getResource ( ) ) ; } return getResource ( ) . compareTo ( other ) ; } public int hashCode ( ) { return getResource ( ) . hashCode ( ) ; } public InputStream getInputStream ( ) throws IOException { InputStream in = getResource ( ) . getInputStream ( ) ; if ( in != null ) { in = wrapStream ( in ) ; } return in ; } public OutputStream getOutputStream ( ) throws IOException { OutputStream out = getResource ( ) . getOutputStream ( ) ; if ( out != null ) { out = wrapStream ( out ) ; } return out ; } public boolean isFilesystemOnly ( ) { return false ; } public String toString ( ) { return getCompressionName ( ) + " compressed " + getResource ( ) . toString ( ) ; } public void setRefid ( Reference r ) { if ( resource != null ) { throw noChildrenAllowed ( ) ; } super . setRefid ( r ) ; } protected abstract InputStream wrapStream ( InputStream in ) throws IOException ; protected abstract OutputStream wrapStream ( OutputStream out ) throws IOException ; protected abstract String getCompressionName ( ) ; private Resource getResource ( ) { if ( isReference ( ) ) { return ( Resource ) getCheckedRef ( ) ; } else if ( resource == null ) { throw new BuildException ( "no resource specified" ) ; } return resource ; } } 	0	['24', '4', '2', '7', '50', '270', '2', '5', '20', '0.434782609', '250', '1', '1', '0.706666667', '0.162037037', '2', '15', '9.375', '5', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ClassCPInfo ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ConstantPool ; import org . apache . tools . ant . taskdefs . optional . depend . constantpool . ConstantPoolEntry ; public class ClassFile { private static final int CLASS_MAGIC = 0xCAFEBABE ; private ConstantPool constantPool ; private String className ; public void read ( InputStream stream ) throws IOException , ClassFormatError { DataInputStream classStream = new DataInputStream ( stream ) ; if ( classStream . readInt ( ) != CLASS_MAGIC ) { throw new ClassFormatError ( "No Magic Code Found " + "- probably not a Java class file." ) ; } classStream . readUnsignedShort ( ) ; classStream . readUnsignedShort ( ) ; constantPool = new ConstantPool ( ) ; constantPool . read ( classStream ) ; constantPool . resolve ( ) ; classStream . readUnsignedShort ( ) ; int thisClassIndex = classStream . readUnsignedShort ( ) ; classStream . readUnsignedShort ( ) ; ClassCPInfo classInfo = ( ClassCPInfo ) constantPool . getEntry ( thisClassIndex ) ; className = classInfo . getClassName ( ) ; } public Vector getClassRefs ( ) { Vector classRefs = new Vector ( ) ; for ( int i = 0 ; i < constantPool . size ( ) ; ++ i ) { ConstantPoolEntry entry = constantPool . getEntry ( i ) ; if ( entry != null && entry . getTag ( ) == ConstantPoolEntry . CONSTANT_CLASS ) { ClassCPInfo classEntry = ( ClassCPInfo ) entry ; if ( ! classEntry . getClassName ( ) . equals ( className ) ) { classRefs . addElement ( ClassFileUtils . convertSlashName ( classEntry . getClassName ( ) ) ) ; } } } return classRefs ; } public String getFullClassName ( ) { return ClassFileUtils . convertSlashName ( className ) ; } } 	0	['4', '1', '0', '8', '20', '0', '4', '4', '4', '0.777777778', '106', '1', '1', '0', '0.625', '0', '0', '24.75', '5', '1.75', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public final class AntFilterReader extends DataType implements Cloneable { private String className ; private final Vector parameters = new Vector ( ) ; private Path classpath ; public void setClassName ( final String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void addParam ( final Parameter param ) { parameters . addElement ( param ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public Path getClasspath ( ) { return classpath ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public Parameter [ ] getParams ( ) { Parameter [ ] params = new Parameter [ parameters . size ( ) ] ; parameters . copyInto ( params ) ; return params ; } public void setRefid ( Reference r ) throws BuildException { if ( ! parameters . isEmpty ( ) || className != null || classpath != null ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof AntFilterReader ) { AntFilterReader afr = ( AntFilterReader ) o ; setClassName ( afr . getClassName ( ) ) ; setClasspath ( afr . getClasspath ( ) ) ; Parameter [ ] p = afr . getParams ( ) ; if ( p != null ) { for ( int i = 0 ; i < p . length ; i ++ ) { addParam ( p [ i ] ) ; } } } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterReader" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } } 	0	['10', '3', '0', '8', '32', '15', '2', '6', '10', '0.666666667', '166', '1', '1', '0.769230769', '0.3', '1', '1', '15.3', '3', '1.4', '0']
package org . apache . tools . ant ; public interface DynamicAttribute { void setDynamicAttribute ( String name , String value ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ExtendSelector extends BaseSelector { private String classname = null ; private FileSelector dynselector = null ; private Vector paramVec = new Vector ( ) ; private Path classpath = null ; public ExtendSelector ( ) { } public void setClassname ( String classname ) { this . classname = classname ; } public void selectorCreate ( ) { if ( classname != null && classname . length ( ) > 0 ) { try { Class c = null ; if ( classpath == null ) { c = Class . forName ( classname ) ; } else { AntClassLoader al = getProject ( ) . createClassLoader ( classpath ) ; c = Class . forName ( classname , true , al ) ; } dynselector = ( FileSelector ) c . newInstance ( ) ; final Project p = getProject ( ) ; if ( p != null ) { p . setProjectReference ( dynselector ) ; } } catch ( ClassNotFoundException cnfexcept ) { setError ( "Selector " + classname + " not initialized, no such class" ) ; } catch ( InstantiationException iexcept ) { setError ( "Selector " + classname + " not initialized, could not create class" ) ; } catch ( IllegalAccessException iaexcept ) { setError ( "Selector " + classname + " not initialized, class not accessible" ) ; } } else { setError ( "There is no classname specified" ) ; } } public void addParam ( Parameter p ) { paramVec . addElement ( p ) ; } public final void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public final Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public final Path getClasspath ( ) { return classpath ; } public void setClasspathref ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; } public void verifySettings ( ) { if ( dynselector == null ) { selectorCreate ( ) ; } if ( classname == null || classname . length ( ) < 1 ) { setError ( "The classname attribute is required" ) ; } else if ( dynselector == null ) { setError ( "Internal Error: The custom selector was not created" ) ; } else if ( ! ( dynselector instanceof ExtendFileSelector ) && ( paramVec . size ( ) > 0 ) ) { setError ( "Cannot set parameters on custom selector that does not " + "implement ExtendFileSelector" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) throws BuildException { validate ( ) ; if ( paramVec . size ( ) > 0 && dynselector instanceof ExtendFileSelector ) { Parameter [ ] paramArray = new Parameter [ paramVec . size ( ) ] ; paramVec . copyInto ( paramArray ) ; ( ( ExtendFileSelector ) dynselector ) . setParameters ( paramArray ) ; } return dynselector . isSelected ( basedir , filename , file ) ; } } 	0	['10', '4', '0', '15', '36', '3', '6', '9', '10', '0.583333333', '249', '1', '2', '0.795454545', '0.266666667', '1', '3', '23.5', '7', '2.4', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . FileSet ; public class CCMCheck extends Continuus { private File file = null ; private String comment = null ; private String task = null ; protected Vector filesets = new Vector ( ) ; public CCMCheck ( ) { super ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File v ) { log ( "working file " + v , Project . MSG_VERBOSE ) ; this . file = v ; } public String getComment ( ) { return comment ; } public void setComment ( String v ) { this . comment = v ; } public String getTask ( ) { return task ; } public void setTask ( String v ) { this . task = v ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( file == null && filesets . size ( ) == 0 ) { throw new BuildException ( "Specify at least one source - a file or a fileset." ) ; } if ( file != null && file . exists ( ) && file . isDirectory ( ) ) { throw new BuildException ( "CCMCheck cannot be generated for directories" ) ; } if ( file != null && filesets . size ( ) > 0 ) { throw new BuildException ( "Choose between file and fileset !" ) ; } if ( getFile ( ) != null ) { doit ( ) ; return ; } int sizeofFileSet = filesets . size ( ) ; for ( int i = 0 ; i < sizeofFileSet ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File src = new File ( fs . getDir ( getProject ( ) ) , srcFiles [ j ] ) ; setFile ( src ) ; doit ( ) ; } } } private void doit ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; int result = run ( commandLine ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } if ( getTask ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_TASK ) ; cmd . createArgument ( ) . setValue ( getTask ( ) ) ; } if ( getFile ( ) != null ) { cmd . createArgument ( ) . setValue ( file . getAbsolutePath ( ) ) ; } } public static final String FLAG_COMMENT = "/comment" ; public static final String FLAG_TASK = "/task" ; } 	0	['11', '4', '3', '12', '41', '19', '3', '9', '9', '0.816666667', '240', '0.666666667', '0', '0.811320755', '0.290909091', '0', '0', '20.27272727', '4', '1.2727', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class JikesOutputParser implements ExecuteStreamHandler { protected Task task ; protected boolean errorFlag = false ; protected int errors ; protected int warnings ; protected boolean error = false ; protected boolean emacsMode ; protected BufferedReader br ; public void setProcessInputStream ( OutputStream os ) { } public void setProcessErrorStream ( InputStream is ) { } public void setProcessOutputStream ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public void start ( ) throws IOException { parseOutput ( br ) ; } public void stop ( ) { } protected JikesOutputParser ( Task task , boolean emacsMode ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, the " + "JikesOutputParser class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . task = task ; this . emacsMode = emacsMode ; } protected void parseOutput ( BufferedReader reader ) throws IOException { if ( emacsMode ) { parseEmacsOutput ( reader ) ; } else { parseStandardOutput ( reader ) ; } } private void parseStandardOutput ( BufferedReader reader ) throws IOException { String line ; String lower ; while ( ( line = reader . readLine ( ) ) != null ) { lower = line . toLowerCase ( ) ; if ( line . trim ( ) . equals ( "" ) ) { continue ; } if ( lower . indexOf ( "error" ) != - 1 ) { setError ( true ) ; } else if ( lower . indexOf ( "warning" ) != - 1 ) { setError ( false ) ; } else { if ( emacsMode ) { setError ( true ) ; } } log ( line ) ; } } private void parseEmacsOutput ( BufferedReader reader ) throws IOException { parseStandardOutput ( reader ) ; } private void setError ( boolean err ) { error = err ; if ( error ) { errorFlag = true ; } } private void log ( String line ) { if ( ! emacsMode ) { task . log ( "" , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } task . log ( line , ( error ? Project . MSG_ERR : Project . MSG_WARN ) ) ; } protected boolean getErrorFlag ( ) { return errorFlag ; } } 	0	['12', '1', '0', '3', '22', '44', '1', '2', '5', '0.805194805', '156', '1', '1', '0', '0.261904762', '0', '0', '11.41666667', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Not extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <not>" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <not>" ) ; } return ! ( ( Condition ) getConditions ( ) . nextElement ( ) ) . eval ( ) ; } } 	0	['2', '3', '0', '3', '8', '1', '1', '3', '2', '2', '33', '0', '0', '0.96969697', '1', '0', '0', '15.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class BuildNumber extends Task { private static final String DEFAULT_PROPERTY_NAME = "build.number" ; private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File myFile ; public void setFile ( final File file ) { myFile = file ; } public void execute ( ) throws BuildException { File savedFile = myFile ; validate ( ) ; final Properties properties = loadProperties ( ) ; final int buildNumber = getBuildNumber ( properties ) ; properties . put ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber + 1 ) ) ; FileOutputStream output = null ; try { output = new FileOutputStream ( myFile ) ; final String header = "Build Number for ANT. Do not edit!" ; properties . store ( output , header ) ; } catch ( final IOException ioe ) { final String message = "Error while writing " + myFile ; throw new BuildException ( message , ioe ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( final IOException ioe ) { log ( "error closing output stream " + ioe , Project . MSG_ERR ) ; } } myFile = savedFile ; } getProject ( ) . setNewProperty ( DEFAULT_PROPERTY_NAME , String . valueOf ( buildNumber ) ) ; } private int getBuildNumber ( final Properties properties ) throws BuildException { final String buildNumber = properties . getProperty ( DEFAULT_PROPERTY_NAME , "0" ) . trim ( ) ; try { return Integer . parseInt ( buildNumber ) ; } catch ( final NumberFormatException nfe ) { final String message = myFile + " contains a non integer build number: " + buildNumber ; throw new BuildException ( message , nfe ) ; } } private Properties loadProperties ( ) throws BuildException { FileInputStream input = null ; try { final Properties properties = new Properties ( ) ; input = new FileInputStream ( myFile ) ; properties . load ( input ) ; return properties ; } catch ( final IOException ioe ) { throw new BuildException ( ioe ) ; } finally { if ( null != input ) { try { input . close ( ) ; } catch ( final IOException ioe ) { log ( "error closing input stream " + ioe , Project . MSG_ERR ) ; } } } } private void validate ( ) throws BuildException { if ( null == myFile ) { myFile = FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , DEFAULT_FILENAME ) ; } if ( ! myFile . exists ( ) ) { try { FILE_UTILS . createNewFile ( myFile ) ; } catch ( final IOException ioe ) { final String message = myFile + " doesn't exist and new file can't be created." ; throw new BuildException ( message , ioe ) ; } } if ( ! myFile . canRead ( ) ) { final String message = "Unable to read from " + myFile + "." ; throw new BuildException ( message ) ; } if ( ! myFile . canWrite ( ) ) { final String message = "Unable to write to " + myFile + "." ; throw new BuildException ( message ) ; } } } 	0	['7', '3', '0', '4', '38', '0', '0', '4', '3', '0.833333333', '258', '1', '1', '0.880952381', '0.444444444', '1', '1', '35.28571429', '1', '0.7143', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; public interface BuildLogger extends BuildListener { void setMessageOutputLevel ( int level ) ; void setOutputPrintStream ( PrintStream output ) ; void setEmacsMode ( boolean emacsMode ) ; void setErrorPrintStream ( PrintStream err ) ; } 	0	['4', '1', '0', '6', '4', '6', '5', '1', '4', '2', '4', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; public class Reverse extends ResourceComparator { private static final String ONE_NESTED = "You must not nest more than one ResourceComparator for reversal." ; private ResourceComparator nested ; public Reverse ( ) { } public Reverse ( ResourceComparator c ) { add ( c ) ; } public void add ( ResourceComparator c ) { if ( nested != null ) { throw new BuildException ( ONE_NESTED ) ; } nested = c ; } protected int resourceCompare ( Resource foo , Resource bar ) { return - 1 * ( nested == null ? foo . compareTo ( bar ) : nested . compare ( foo , bar ) ) ; } } 	0	['4', '4', '0', '5', '8', '4', '2', '3', '3', '0.833333333', '42', '1', '1', '0.944444444', '0.583333333', '1', '1', '9', '2', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . Reference ; public abstract class ArchiveResource extends Resource { private static final int NULL_ARCHIVE = Resource . getMagicNumber ( "null archive" . getBytes ( ) ) ; private Resource archive ; private boolean haveEntry = false ; private boolean modeSet = false ; private int mode = 0 ; public ArchiveResource ( ) { } public ArchiveResource ( File a ) { this ( a , false ) ; } public ArchiveResource ( File a , boolean withEntry ) { setArchive ( a ) ; haveEntry = withEntry ; } public ArchiveResource ( Resource a , boolean withEntry ) { addConfigured ( a ) ; haveEntry = withEntry ; } public void setArchive ( File a ) { checkAttributesAllowed ( ) ; archive = new FileResource ( a ) ; } public void setMode ( int mode ) { checkAttributesAllowed ( ) ; this . mode = mode ; modeSet = true ; } public void addConfigured ( ResourceCollection a ) { checkChildrenAllowed ( ) ; if ( archive != null ) { throw new BuildException ( "you must not specify more than one" + " archive" ) ; } if ( a . size ( ) != 1 ) { throw new BuildException ( "only single argument resource collections" + " are supported as archives" ) ; } archive = ( Resource ) a . iterator ( ) . next ( ) ; } public Resource getArchive ( ) { return isReference ( ) ? ( ( ArchiveResource ) getCheckedRef ( ) ) . getArchive ( ) : archive ; } public long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } checkEntry ( ) ; return super . getLastModified ( ) ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } checkEntry ( ) ; return super . getSize ( ) ; } public boolean isDirectory ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) ; } checkEntry ( ) ; return super . isDirectory ( ) ; } public boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } checkEntry ( ) ; return super . isExists ( ) ; } public int getMode ( ) { if ( isReference ( ) ) { return ( ( ArchiveResource ) getCheckedRef ( ) ) . getMode ( ) ; } checkEntry ( ) ; return mode ; } public void setRefid ( Reference r ) { if ( archive != null || modeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public int compareTo ( Object another ) { return this . equals ( another ) ? 0 : super . compareTo ( another ) ; } public boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } ArchiveResource r = ( ArchiveResource ) another ; return getArchive ( ) . equals ( r . getArchive ( ) ) && getName ( ) . equals ( r . getName ( ) ) ; } public int hashCode ( ) { return super . hashCode ( ) * ( getArchive ( ) == null ? NULL_ARCHIVE : getArchive ( ) . hashCode ( ) ) ; } public String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : getArchive ( ) . toString ( ) + ':' + getName ( ) ; } private synchronized void checkEntry ( ) throws BuildException { if ( haveEntry ) { return ; } String name = getName ( ) ; if ( name == null ) { throw new BuildException ( "entry name not set" ) ; } Resource r = getArchive ( ) ; if ( r == null ) { throw new BuildException ( "archive attribute not set" ) ; } if ( ! r . isExists ( ) ) { throw new BuildException ( r . toString ( ) + " does not exist." ) ; } if ( r . isDirectory ( ) ) { throw new BuildException ( r + " denotes a directory." ) ; } fetchEntry ( ) ; haveEntry = true ; } protected abstract void fetchEntry ( ) ; } 	0	['21', '4', '2', '9', '55', '162', '4', '5', '18', '0.71', '361', '1', '1', '0.768115942', '0.19375', '2', '9', '15.95238095', '6', '1.619', '0']
package org . apache . tools . ant . types . resources ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; public class First extends BaseResourceCollectionWrapper { private static final String BAD_COUNT = "count of first resources should be set to an int >= 0" ; private int count = 1 ; public synchronized void setCount ( int i ) { count = i ; } public synchronized int getCount ( ) { return count ; } protected Collection getCollection ( ) { int ct = getCount ( ) ; if ( ct < 0 ) { throw new BuildException ( BAD_COUNT ) ; } Iterator iter = getResourceCollection ( ) . iterator ( ) ; ArrayList al = new ArrayList ( ct ) ; for ( int i = 0 ; i < ct && iter . hasNext ( ) ; i ++ ) { al . add ( iter . next ( ) ) ; } return al ; } } 	0	['4', '4', '0', '3', '12', '0', '0', '3', '3', '0.666666667', '55', '1', '0', '0.933333333', '0.625', '1', '1', '12.25', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . xml . sax . SAXException ; public class XMLResultAggregator extends Task implements XMLConstants { protected Vector filesets = new Vector ( ) ; protected String toFile ; protected File toDir ; protected Vector transformers = new Vector ( ) ; public static final String DEFAULT_DIR = "." ; public static final String DEFAULT_FILENAME = "TESTS-TestSuites.xml" ; protected int generatedId = 0 ; static final String WARNING_IS_POSSIBLY_CORRUPTED = " is not a valid XML document. It is possibly corrupted." ; static final String WARNING_INVALID_ROOT_ELEMENT = " is not a valid testsuite XML document" ; static final String WARNING_EMPTY_FILE = " is empty.\nThis can be caused by the test JVM exiting unexpectedly" ; public AggregateTransformer createReport ( ) { AggregateTransformer transformer = new AggregateTransformer ( this ) ; transformers . addElement ( transformer ) ; return transformer ; } public void setTofile ( String value ) { toFile = value ; } public void setTodir ( File value ) { toDir = value ; } public void addFileSet ( FileSet fs ) { filesets . addElement ( fs ) ; } public void execute ( ) throws BuildException { Element rootElement = createDocument ( ) ; File destFile = getDestinationFile ( ) ; try { writeDOMTree ( rootElement . getOwnerDocument ( ) , destFile ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to write test aggregate to '" + destFile + "'" , e ) ; } Enumeration e = transformers . elements ( ) ; while ( e . hasMoreElements ( ) ) { AggregateTransformer transformer = ( AggregateTransformer ) e . nextElement ( ) ; transformer . setXmlDocument ( rootElement . getOwnerDocument ( ) ) ; transformer . transform ( ) ; } } public File getDestinationFile ( ) { if ( toFile == null ) { toFile = DEFAULT_FILENAME ; } if ( toDir == null ) { toDir = getProject ( ) . resolveFile ( DEFAULT_DIR ) ; } return new File ( toDir , toFile ) ; } protected File [ ] getFiles ( ) { Vector v = new Vector ( ) ; final int size = filesets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; ds . scan ( ) ; String [ ] f = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < f . length ; j ++ ) { String pathname = f [ j ] ; if ( pathname . endsWith ( ".xml" ) ) { File file = new File ( ds . getBasedir ( ) , pathname ) ; file = getProject ( ) . resolveFile ( file . getPath ( ) ) ; v . addElement ( file ) ; } } } File [ ] files = new File [ v . size ( ) ] ; v . copyInto ( files ) ; return files ; } protected void writeDOMTree ( Document doc , File file ) throws IOException { OutputStream out = null ; PrintWriter wri = null ; try { out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; wri = new PrintWriter ( new OutputStreamWriter ( out , "UTF8" ) ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" ) ; ( new DOMElementWriter ( ) ) . write ( doc . getDocumentElement ( ) , wri , 0 , "  " ) ; wri . flush ( ) ; if ( wri . checkError ( ) ) { throw new IOException ( "Error while writing DOM content" ) ; } } finally { FileUtils . close ( wri ) ; FileUtils . close ( out ) ; } } protected Element createDocument ( ) { DocumentBuilder builder = getDocumentBuilder ( ) ; Document doc = builder . newDocument ( ) ; Element rootElement = doc . createElement ( TESTSUITES ) ; doc . appendChild ( rootElement ) ; generatedId = 0 ; File [ ] files = getFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; try { log ( "Parsing file: '" + file + "'" , Project . MSG_VERBOSE ) ; if ( file . length ( ) > 0 ) { Document testsuiteDoc = builder . parse ( FileUtils . getFileUtils ( ) . toURI ( files [ i ] . getAbsolutePath ( ) ) ) ; Element elem = testsuiteDoc . getDocumentElement ( ) ; if ( TESTSUITE . equals ( elem . getNodeName ( ) ) ) { addTestSuite ( rootElement , elem ) ; generatedId ++ ; } else { log ( "the file " + file + WARNING_INVALID_ROOT_ELEMENT , Project . MSG_WARN ) ; } } else { log ( "the file " + file + WARNING_EMPTY_FILE , Project . MSG_WARN ) ; } } catch ( SAXException e ) { log ( "The file " + file + WARNING_IS_POSSIBLY_CORRUPTED , Project . MSG_WARN ) ; log ( StringUtils . getStackTrace ( e ) , Project . MSG_DEBUG ) ; } catch ( IOException e ) { log ( "Error while accessing file " + file + ": " + e . getMessage ( ) , Project . MSG_ERR ) ; } } return rootElement ; } protected void addTestSuite ( Element root , Element testsuite ) { String fullclassname = testsuite . getAttribute ( ATTR_NAME ) ; int pos = fullclassname . lastIndexOf ( '.' ) ; String pkgName = ( pos == - 1 ) ? "" : fullclassname . substring ( 0 , pos ) ; String classname = ( pos == - 1 ) ? fullclassname : fullclassname . substring ( pos + 1 ) ; Element copy = ( Element ) DOMUtil . importNode ( root , testsuite ) ; copy . setAttribute ( ATTR_NAME , classname ) ; copy . setAttribute ( ATTR_PACKAGE , pkgName ) ; copy . setAttribute ( ATTR_ID , Integer . toString ( generatedId ) ) ; } private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } } 	0	['12', '3', '0', '11', '75', '44', '1', '11', '7', '0.936363636', '455', '0.5', '0', '0.770833333', '0.236111111', '0', '0', '36.08333333', '4', '1.75', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public interface RegexpMatcher { int MATCH_DEFAULT = 0x00000000 ; int MATCH_CASE_INSENSITIVE = 0x00000100 ; int MATCH_MULTILINE = 0x00001000 ; int MATCH_SINGLELINE = 0x00010000 ; void setPattern ( String pattern ) throws BuildException ; String getPattern ( ) throws BuildException ; boolean matches ( String argument ) throws BuildException ; Vector getGroups ( String argument ) throws BuildException ; boolean matches ( String input , int options ) throws BuildException ; Vector getGroups ( String input , int options ) throws BuildException ; } 	0	['6', '1', '0', '9', '6', '15', '8', '1', '6', '1.2', '10', '0', '0', '0', '0.722222222', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class OrSelector extends BaseSelectorContainer { public OrSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{orselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return true ; } } return false ; } } 	0	['3', '5', '0', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . types . spi ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildException ; public class Service extends ProjectComponent { private List providerList = new ArrayList ( ) ; private String type ; public void setProvider ( String className ) { Provider provider = new Provider ( ) ; provider . setClassName ( className ) ; providerList . add ( provider ) ; } public void addConfiguredProvider ( Provider provider ) { provider . check ( ) ; providerList . add ( provider ) ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public InputStream getAsStream ( ) throws IOException { ByteArrayOutputStream arrayOut ; Writer writer ; Iterator providerIterator ; Provider provider ; arrayOut = new ByteArrayOutputStream ( ) ; writer = new OutputStreamWriter ( arrayOut , "UTF-8" ) ; providerIterator = providerList . iterator ( ) ; while ( providerIterator . hasNext ( ) ) { provider = ( Provider ) providerIterator . next ( ) ; writer . write ( provider . getClassName ( ) ) ; writer . write ( "\n" ) ; } writer . close ( ) ; return new ByteArrayInputStream ( arrayOut . toByteArray ( ) ) ; } public void check ( ) { if ( type == null ) { throw new BuildException ( "type attribute must be set for service element" , getLocation ( ) ) ; } if ( type . length ( ) == 0 ) { throw new BuildException ( "Invalid empty type classname" , getLocation ( ) ) ; } if ( providerList . size ( ) == 0 ) { throw new BuildException ( "provider attribute or nested provider element must be set!" , getLocation ( ) ) ; } } } 	0	['7', '2', '0', '5', '27', '0', '1', '4', '7', '0.5', '115', '1', '0', '0.6', '0.476190476', '0', '0', '15.14285714', '4', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Hashtable ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . xml . sax . AttributeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class DescriptorHandler extends org . xml . sax . HandlerBase { private static final int DEFAULT_HASH_TABLE_SIZE = 10 ; private static final int STATE_LOOKING_EJBJAR = 1 ; private static final int STATE_IN_EJBJAR = 2 ; private static final int STATE_IN_BEANS = 3 ; private static final int STATE_IN_SESSION = 4 ; private static final int STATE_IN_ENTITY = 5 ; private static final int STATE_IN_MESSAGE = 6 ; private Task owningTask ; private String publicId = null ; private static final String EJB_REF = "ejb-ref" ; private static final String EJB_LOCAL_REF = "ejb-local-ref" ; private static final String HOME_INTERFACE = "home" ; private static final String REMOTE_INTERFACE = "remote" ; private static final String LOCAL_HOME_INTERFACE = "local-home" ; private static final String LOCAL_INTERFACE = "local" ; private static final String BEAN_CLASS = "ejb-class" ; private static final String PK_CLASS = "prim-key-class" ; private static final String EJB_NAME = "ejb-name" ; private static final String EJB_JAR = "ejb-jar" ; private static final String ENTERPRISE_BEANS = "enterprise-beans" ; private static final String ENTITY_BEAN = "entity" ; private static final String SESSION_BEAN = "session" ; private static final String MESSAGE_BEAN = "message-driven" ; private int parseState = STATE_LOOKING_EJBJAR ; protected String currentElement = null ; protected String currentText = null ; protected Hashtable ejbFiles = null ; protected String ejbName = null ; private Hashtable fileDTDs = new Hashtable ( ) ; private Hashtable resourceDTDs = new Hashtable ( ) ; private boolean inEJBRef = false ; private Hashtable urlDTDs = new Hashtable ( ) ; private File srcDir ; public DescriptorHandler ( Task task , File srcDir ) { this . owningTask = task ; this . srcDir = srcDir ; } public void registerDTD ( String publicId , String location ) { if ( location == null ) { return ; } File fileDTD = new File ( location ) ; if ( ! fileDTD . exists ( ) ) { fileDTD = owningTask . getProject ( ) . resolveFile ( location ) ; } if ( fileDTD . exists ( ) ) { if ( publicId != null ) { fileDTDs . put ( publicId , fileDTD ) ; owningTask . log ( "Mapped publicId " + publicId + " to file " + fileDTD , Project . MSG_VERBOSE ) ; } return ; } if ( getClass ( ) . getResource ( location ) != null ) { if ( publicId != null ) { resourceDTDs . put ( publicId , location ) ; owningTask . log ( "Mapped publicId " + publicId + " to resource " + location , Project . MSG_VERBOSE ) ; } } try { if ( publicId != null ) { URL urldtd = new URL ( location ) ; urlDTDs . put ( publicId , urldtd ) ; } } catch ( java . net . MalformedURLException e ) { } } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException { this . publicId = publicId ; File dtdFile = ( File ) fileDTDs . get ( publicId ) ; if ( dtdFile != null ) { try { owningTask . log ( "Resolved " + publicId + " to local file " + dtdFile , Project . MSG_VERBOSE ) ; return new InputSource ( new FileInputStream ( dtdFile ) ) ; } catch ( FileNotFoundException ex ) { } } String dtdResourceName = ( String ) resourceDTDs . get ( publicId ) ; if ( dtdResourceName != null ) { InputStream is = this . getClass ( ) . getResourceAsStream ( dtdResourceName ) ; if ( is != null ) { owningTask . log ( "Resolved " + publicId + " to local resource " + dtdResourceName , Project . MSG_VERBOSE ) ; return new InputSource ( is ) ; } } URL dtdUrl = ( URL ) urlDTDs . get ( publicId ) ; if ( dtdUrl != null ) { try { InputStream is = dtdUrl . openStream ( ) ; owningTask . log ( "Resolved " + publicId + " to url " + dtdUrl , Project . MSG_VERBOSE ) ; return new InputSource ( is ) ; } catch ( IOException ioe ) { } } owningTask . log ( "Could not resolve ( publicId: " + publicId + ", systemId: " + systemId + ") to a local entity" , Project . MSG_INFO ) ; return null ; } public Hashtable getFiles ( ) { return ( ejbFiles == null ) ? new Hashtable ( ) : ejbFiles ; } public String getPublicId ( ) { return publicId ; } public String getEjbName ( ) { return ejbName ; } public void startDocument ( ) throws SAXException { this . ejbFiles = new Hashtable ( DEFAULT_HASH_TABLE_SIZE , 1 ) ; this . currentElement = null ; inEJBRef = false ; } public void startElement ( String name , AttributeList attrs ) throws SAXException { this . currentElement = name ; currentText = "" ; if ( name . equals ( EJB_REF ) || name . equals ( EJB_LOCAL_REF ) ) { inEJBRef = true ; } else if ( parseState == STATE_LOOKING_EJBJAR && name . equals ( EJB_JAR ) ) { parseState = STATE_IN_EJBJAR ; } else if ( parseState == STATE_IN_EJBJAR && name . equals ( ENTERPRISE_BEANS ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_BEANS && name . equals ( SESSION_BEAN ) ) { parseState = STATE_IN_SESSION ; } else if ( parseState == STATE_IN_BEANS && name . equals ( ENTITY_BEAN ) ) { parseState = STATE_IN_ENTITY ; } else if ( parseState == STATE_IN_BEANS && name . equals ( MESSAGE_BEAN ) ) { parseState = STATE_IN_MESSAGE ; } } public void endElement ( String name ) throws SAXException { processElement ( ) ; currentText = "" ; this . currentElement = "" ; if ( name . equals ( EJB_REF ) || name . equals ( EJB_LOCAL_REF ) ) { inEJBRef = false ; } else if ( parseState == STATE_IN_ENTITY && name . equals ( ENTITY_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_SESSION && name . equals ( SESSION_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_MESSAGE && name . equals ( MESSAGE_BEAN ) ) { parseState = STATE_IN_BEANS ; } else if ( parseState == STATE_IN_BEANS && name . equals ( ENTERPRISE_BEANS ) ) { parseState = STATE_IN_EJBJAR ; } else if ( parseState == STATE_IN_EJBJAR && name . equals ( EJB_JAR ) ) { parseState = STATE_LOOKING_EJBJAR ; } } public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentText += new String ( ch , start , length ) ; } protected void processElement ( ) { if ( inEJBRef || ( parseState != STATE_IN_ENTITY && parseState != STATE_IN_SESSION && parseState != STATE_IN_MESSAGE ) ) { return ; } if ( currentElement . equals ( HOME_INTERFACE ) || currentElement . equals ( REMOTE_INTERFACE ) || currentElement . equals ( LOCAL_INTERFACE ) || currentElement . equals ( LOCAL_HOME_INTERFACE ) || currentElement . equals ( BEAN_CLASS ) || currentElement . equals ( PK_CLASS ) ) { File classFile = null ; String className = currentText . trim ( ) ; if ( ! className . startsWith ( "java." ) && ! className . startsWith ( "javax." ) ) { className = className . replace ( '.' , File . separatorChar ) ; className += ".class" ; classFile = new File ( srcDir , className ) ; ejbFiles . put ( className , classFile ) ; } } if ( currentElement . equals ( EJB_NAME ) ) { if ( ejbName == null ) { ejbName = currentText . trim ( ) ; } } } } 	0	['11', '2', '3', '11', '39', '7', '9', '2', '10', '0.960606061', '605', '1', '1', '0.583333333', '0.25974026', '0', '0', '51', '15', '2.9091', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; import java . util . zip . ZipEntry ; import java . util . zip . ZipException ; import java . util . zip . ZipFile ; import java . util . zip . ZipOutputStream ; public class jlink { private String outfile = null ; private Vector mergefiles = new Vector ( 10 ) ; private Vector addfiles = new Vector ( 10 ) ; private boolean compression = false ; byte [ ] buffer = new byte [ 8192 ] ; public void setOutfile ( String outfile ) { if ( outfile == null ) { return ; } this . outfile = outfile ; } public void addMergeFile ( String fileToMerge ) { if ( fileToMerge == null ) { return ; } mergefiles . addElement ( fileToMerge ) ; } public void addAddFile ( String fileToAdd ) { if ( fileToAdd == null ) { return ; } addfiles . addElement ( fileToAdd ) ; } public void addMergeFiles ( String [ ] filesToMerge ) { if ( filesToMerge == null ) { return ; } for ( int i = 0 ; i < filesToMerge . length ; i ++ ) { addMergeFile ( filesToMerge [ i ] ) ; } } public void addAddFiles ( String [ ] filesToAdd ) { if ( filesToAdd == null ) { return ; } for ( int i = 0 ; i < filesToAdd . length ; i ++ ) { addAddFile ( filesToAdd [ i ] ) ; } } public void setCompression ( boolean compress ) { this . compression = compress ; } public void link ( ) throws Exception { ZipOutputStream output = new ZipOutputStream ( new FileOutputStream ( outfile ) ) ; if ( compression ) { output . setMethod ( ZipOutputStream . DEFLATED ) ; output . setLevel ( Deflater . DEFAULT_COMPRESSION ) ; } else { output . setMethod ( ZipOutputStream . STORED ) ; } Enumeration merges = mergefiles . elements ( ) ; while ( merges . hasMoreElements ( ) ) { String path = ( String ) merges . nextElement ( ) ; File f = new File ( path ) ; if ( f . getName ( ) . endsWith ( ".jar" ) || f . getName ( ) . endsWith ( ".zip" ) ) { mergeZipJarContents ( output , f ) ; } else { addAddFile ( path ) ; } } Enumeration adds = addfiles . elements ( ) ; while ( adds . hasMoreElements ( ) ) { String name = ( String ) adds . nextElement ( ) ; File f = new File ( name ) ; if ( f . isDirectory ( ) ) { addDirContents ( output , f , f . getName ( ) + '/' , compression ) ; } else { addFile ( output , f , "" , compression ) ; } } if ( output != null ) { try { output . close ( ) ; } catch ( IOException ioe ) { } } } public static void main ( String [ ] args ) { if ( args . length < 2 ) { System . out . println ( "usage: jlink output input1 ... inputN" ) ; System . exit ( 1 ) ; } jlink linker = new jlink ( ) ; linker . setOutfile ( args [ 0 ] ) ; for ( int i = 1 ; i < args . length ; i ++ ) { linker . addMergeFile ( args [ i ] ) ; } try { linker . link ( ) ; } catch ( Exception ex ) { System . err . print ( ex . getMessage ( ) ) ; } } private void mergeZipJarContents ( ZipOutputStream output , File f ) throws IOException { if ( ! f . exists ( ) ) { return ; } ZipFile zipf = new ZipFile ( f ) ; Enumeration entries = zipf . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry inputEntry = ( ZipEntry ) entries . nextElement ( ) ; String inputEntryName = inputEntry . getName ( ) ; int index = inputEntryName . indexOf ( "META-INF" ) ; if ( index < 0 ) { try { output . putNextEntry ( processEntry ( zipf , inputEntry ) ) ; } catch ( ZipException ex ) { String mess = ex . getMessage ( ) ; if ( mess . indexOf ( "duplicate" ) >= 0 ) { continue ; } else { throw ex ; } } InputStream in = zipf . getInputStream ( inputEntry ) ; int len = buffer . length ; int count = - 1 ; while ( ( count = in . read ( buffer , 0 , len ) ) > 0 ) { output . write ( buffer , 0 , count ) ; } in . close ( ) ; output . closeEntry ( ) ; } } zipf . close ( ) ; } private void addDirContents ( ZipOutputStream output , File dir , String prefix , boolean compress ) throws IOException { String [ ] contents = dir . list ( ) ; for ( int i = 0 ; i < contents . length ; ++ i ) { String name = contents [ i ] ; File file = new File ( dir , name ) ; if ( file . isDirectory ( ) ) { addDirContents ( output , file , prefix + name + '/' , compress ) ; } else { addFile ( output , file , prefix , compress ) ; } } } private String getEntryName ( File file , String prefix ) { String name = file . getName ( ) ; if ( ! name . endsWith ( ".class" ) ) { InputStream input = null ; try { input = new FileInputStream ( file ) ; String className = ClassNameReader . getClassName ( input ) ; if ( className != null ) { return className . replace ( '.' , '/' ) + ".class" ; } } catch ( IOException ioe ) { } finally { if ( input != null ) { try { input . close ( ) ; } catch ( IOException e ) { } } } } System . out . println ( "From " + file . getPath ( ) + " and prefix " + prefix + ", creating entry " + prefix + name ) ; return ( prefix + name ) ; } private void addFile ( ZipOutputStream output , File file , String prefix , boolean compress ) throws IOException { if ( ! file . exists ( ) ) { return ; } ZipEntry entry = new ZipEntry ( getEntryName ( file , prefix ) ) ; entry . setTime ( file . lastModified ( ) ) ; entry . setSize ( file . length ( ) ) ; if ( ! compress ) { entry . setCrc ( calcChecksum ( file ) ) ; } FileInputStream input = new FileInputStream ( file ) ; addToOutputStream ( output , input , entry ) ; } private void addToOutputStream ( ZipOutputStream output , InputStream input , ZipEntry ze ) throws IOException { try { output . putNextEntry ( ze ) ; } catch ( ZipException zipEx ) { input . close ( ) ; return ; } int numBytes = - 1 ; while ( ( numBytes = input . read ( buffer ) ) > 0 ) { output . write ( buffer , 0 , numBytes ) ; } output . closeEntry ( ) ; input . close ( ) ; } private ZipEntry processEntry ( ZipFile zip , ZipEntry inputEntry ) { String name = inputEntry . getName ( ) ; if ( ! ( inputEntry . isDirectory ( ) || name . endsWith ( ".class" ) ) ) { try { InputStream input = zip . getInputStream ( zip . getEntry ( name ) ) ; String className = ClassNameReader . getClassName ( input ) ; input . close ( ) ; if ( className != null ) { name = className . replace ( '.' , '/' ) + ".class" ; } } catch ( IOException ioe ) { } } ZipEntry outputEntry = new ZipEntry ( name ) ; outputEntry . setTime ( inputEntry . getTime ( ) ) ; outputEntry . setExtra ( inputEntry . getExtra ( ) ) ; outputEntry . setComment ( inputEntry . getComment ( ) ) ; outputEntry . setTime ( inputEntry . getTime ( ) ) ; if ( compression ) { outputEntry . setMethod ( ZipEntry . DEFLATED ) ; } else { outputEntry . setMethod ( ZipEntry . STORED ) ; outputEntry . setCrc ( inputEntry . getCrc ( ) ) ; outputEntry . setSize ( inputEntry . getSize ( ) ) ; } return outputEntry ; } private long calcChecksum ( File f ) throws IOException { BufferedInputStream in = new BufferedInputStream ( new FileInputStream ( f ) ) ; return calcChecksum ( in ) ; } private long calcChecksum ( InputStream in ) throws IOException { CRC32 crc = new CRC32 ( ) ; int len = buffer . length ; int count = - 1 ; int haveRead = 0 ; while ( ( count = in . read ( buffer , 0 , len ) ) > 0 ) { haveRead += count ; crc . update ( buffer , 0 , count ) ; } in . close ( ) ; return crc . getValue ( ) ; } } 	0	['17', '1', '0', '2', '81', '100', '1', '1', '9', '0.7125', '654', '0.8', '0', '0', '0.274509804', '0', '0', '37.17647059', '7', '2.0588', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class SimpleP4OutputHandler extends P4HandlerAdapter { P4Base parent ; public SimpleP4OutputHandler ( P4Base parent ) { this . parent = parent ; } public void process ( String line ) throws BuildException { if ( parent . util . match ( "/^exit/" , line ) ) { return ; } if ( parent . util . match ( "/^error:/" , line ) || parent . util . match ( "/^Perforce client error:/" , line ) ) { if ( ! parent . util . match ( "/label in sync/" , line ) && ! parent . util . match ( "/up-to-date/" , line ) ) { parent . setInError ( true ) ; } else { line = parent . util . substitute ( "s/^[^:]*: //" , line ) ; } } else if ( parent . util . match ( "/^info.*?:/" , line ) ) { line = parent . util . substitute ( "s/^[^:]*: //" , line ) ; } parent . log ( line , parent . getInError ( ) ? Project . MSG_ERR : Project . MSG_INFO ) ; if ( parent . getInError ( ) ) { parent . setErrorMessage ( parent . getErrorMessage ( ) + line + StringUtils . LINE_SEP ) ; } } } 	0	['2', '2', '1', '17', '14', '0', '13', '5', '2', '0', '103', '0', '1', '0.875', '0.666666667', '0', '0', '50', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . CompositeMapper ; import org . apache . tools . ant . util . ContainerMapper ; public class Mapper extends DataType implements Cloneable { protected MapperType type = null ; protected String classname = null ; protected Path classpath = null ; protected String from = null ; protected String to = null ; private ContainerMapper container = null ; public Mapper ( Project p ) { setProject ( p ) ; } public void setType ( MapperType type ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . type = type ; } public void addConfigured ( FileNameMapper fileNameMapper ) { add ( fileNameMapper ) ; } public void add ( FileNameMapper fileNameMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( container == null ) { if ( type == null && classname == null ) { container = new CompositeMapper ( ) ; } else { FileNameMapper m = getImplementation ( ) ; if ( m instanceof ContainerMapper ) { container = ( ContainerMapper ) m ; } else { throw new BuildException ( String . valueOf ( m ) + " mapper implementation does not support nested mappers!" ) ; } } } container . add ( fileNameMapper ) ; } public void addConfiguredMapper ( Mapper mapper ) { add ( mapper . getImplementation ( ) ) ; } public void setClassname ( String classname ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . classname = classname ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference ref ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( ref ) ; } public void setFrom ( String from ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . from = from ; } public void setTo ( String to ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . to = to ; } public void setRefid ( Reference r ) throws BuildException { if ( type != null || from != null || to != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public FileNameMapper getImplementation ( ) throws BuildException { if ( isReference ( ) ) { return getRef ( ) . getImplementation ( ) ; } if ( type == null && classname == null && container == null ) { throw new BuildException ( "nested mapper or " + "one of the attributes type or classname is required" ) ; } if ( container != null ) { return container ; } if ( type != null && classname != null ) { throw new BuildException ( "must not specify both type and classname attribute" ) ; } try { FileNameMapper m = ( FileNameMapper ) ( getImplementationClass ( ) . newInstance ( ) ) ; final Project p = getProject ( ) ; if ( p != null ) { p . setProjectReference ( m ) ; } m . setFrom ( from ) ; m . setTo ( to ) ; return m ; } catch ( BuildException be ) { throw be ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } protected Class getImplementationClass ( ) throws ClassNotFoundException { String cName = this . classname ; if ( type != null ) { cName = type . getImplementation ( ) ; } ClassLoader loader = ( classpath == null ) ? getClass ( ) . getClassLoader ( ) : getProject ( ) . createClassLoader ( classpath ) ; return Class . forName ( cName , true , loader ) ; } protected Mapper getRef ( ) { return ( Mapper ) getCheckedRef ( ) ; } public static class MapperType extends EnumeratedAttribute { private Properties implementations ; public MapperType ( ) { implementations = new Properties ( ) ; implementations . put ( "identity" , "org.apache.tools.ant.util.IdentityMapper" ) ; implementations . put ( "flatten" , "org.apache.tools.ant.util.FlatFileNameMapper" ) ; implementations . put ( "glob" , "org.apache.tools.ant.util.GlobPatternMapper" ) ; implementations . put ( "merge" , "org.apache.tools.ant.util.MergingMapper" ) ; implementations . put ( "regexp" , "org.apache.tools.ant.util.RegexpPatternMapper" ) ; implementations . put ( "package" , "org.apache.tools.ant.util.PackageNameMapper" ) ; implementations . put ( "unpackage" , "org.apache.tools.ant.util.UnPackageNameMapper" ) ; } public String [ ] getValues ( ) { return new String [ ] { "identity" , "flatten" , "glob" , "merge" , "regexp" , "package" , "unpackage" } ; } public String getImplementation ( ) { return implementations . getProperty ( getValue ( ) ) ; } } } 	0	['15', '3', '0', '25', '44', '45', '16', '10', '13', '0.619047619', '311', '1', '3', '0.681818182', '0.216666667', '1', '1', '19.33333333', '6', '1.8667', '0']
package org . apache . tools . ant ; import org . apache . tools . ant . dispatch . DispatchUtils ; import java . util . Enumeration ; import java . io . IOException ; public abstract class Task extends ProjectComponent { protected Target target ; protected String taskName ; protected String taskType ; protected RuntimeConfigurable wrapper ; private boolean invalid ; public Task ( ) { } public void setOwningTarget ( Target target ) { this . target = target ; } public Target getOwningTarget ( ) { return target ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void setTaskType ( String type ) { this . taskType = type ; } public void init ( ) throws BuildException { } public void execute ( ) throws BuildException { } public RuntimeConfigurable getRuntimeConfigurableWrapper ( ) { if ( wrapper == null ) { wrapper = new RuntimeConfigurable ( this , getTaskName ( ) ) ; } return wrapper ; } public void setRuntimeConfigurableWrapper ( RuntimeConfigurable wrapper ) { this . wrapper = wrapper ; } public void maybeConfigure ( ) throws BuildException { if ( ! invalid ) { if ( wrapper != null ) { wrapper . maybeConfigure ( getProject ( ) ) ; } } else { getReplacement ( ) ; } } public void reconfigure ( ) { if ( wrapper != null ) { wrapper . reconfigure ( getProject ( ) ) ; } } protected void handleOutput ( String output ) { log ( output , Project . MSG_INFO ) ; } protected void handleFlush ( String output ) { handleOutput ( output ) ; } protected int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException { return getProject ( ) . defaultInput ( buffer , offset , length ) ; } protected void handleErrorOutput ( String output ) { log ( output , Project . MSG_WARN ) ; } protected void handleErrorFlush ( String output ) { handleErrorOutput ( output ) ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( this , msg , msgLevel ) ; } else { super . log ( msg , msgLevel ) ; } } public void log ( Throwable t , int msgLevel ) { if ( t != null ) { log ( t . getMessage ( ) , t , msgLevel ) ; } } public void log ( String msg , Throwable t , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( this , msg , t , msgLevel ) ; } else { super . log ( msg , msgLevel ) ; } } public final void perform ( ) { if ( ! invalid ) { getProject ( ) . fireTaskStarted ( this ) ; Throwable reason = null ; try { maybeConfigure ( ) ; DispatchUtils . execute ( this ) ; } catch ( BuildException ex ) { if ( ex . getLocation ( ) == Location . UNKNOWN_LOCATION ) { ex . setLocation ( getLocation ( ) ) ; } reason = ex ; throw ex ; } catch ( Exception ex ) { reason = ex ; BuildException be = new BuildException ( ex ) ; be . setLocation ( getLocation ( ) ) ; throw be ; } catch ( Error ex ) { reason = ex ; throw ex ; } finally { getProject ( ) . fireTaskFinished ( this , reason ) ; } } else { UnknownElement ue = getReplacement ( ) ; Task task = ue . getTask ( ) ; task . perform ( ) ; } } final void markInvalid ( ) { invalid = true ; } protected final boolean isInvalid ( ) { return invalid ; } private UnknownElement replacement ; private UnknownElement getReplacement ( ) { if ( replacement == null ) { replacement = new UnknownElement ( taskType ) ; replacement . setProject ( getProject ( ) ) ; replacement . setTaskType ( taskType ) ; replacement . setTaskName ( taskName ) ; replacement . setLocation ( location ) ; replacement . setOwningTarget ( target ) ; replacement . setRuntimeConfigurableWrapper ( wrapper ) ; wrapper . setProxy ( replacement ) ; replaceChildren ( wrapper , replacement ) ; target . replaceChild ( this , replacement ) ; replacement . maybeConfigure ( ) ; } return replacement ; } private void replaceChildren ( RuntimeConfigurable wrapper , UnknownElement parentElement ) { Enumeration e = wrapper . getChildren ( ) ; while ( e . hasMoreElements ( ) ) { RuntimeConfigurable childWrapper = ( RuntimeConfigurable ) e . nextElement ( ) ; UnknownElement childElement = new UnknownElement ( childWrapper . getElementTag ( ) ) ; parentElement . addChild ( childElement ) ; childElement . setProject ( getProject ( ) ) ; childElement . setRuntimeConfigurableWrapper ( childWrapper ) ; childWrapper . setProxy ( childElement ) ; replaceChildren ( childWrapper , childElement ) ; } } public String getTaskType ( ) { return taskType ; } protected RuntimeConfigurable getWrapper ( ) { return wrapper ; } public final void bindToOwner ( Task owner ) { setProject ( owner . getProject ( ) ) ; setOwningTarget ( owner . getOwningTarget ( ) ) ; setTaskName ( owner . getTaskName ( ) ) ; setDescription ( owner . getDescription ( ) ) ; setLocation ( owner . getLocation ( ) ) ; setTaskType ( owner . getTaskType ( ) ) ; } } 	0	['29', '2', '102', '184', '66', '346', '181', '8', '19', '0.839285714', '375', '1', '3', '0.243243243', '0.191570881', '1', '1', '11.72413793', '5', '1.3448', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public class HashvalueAlgorithm implements Algorithm { public boolean isValid ( ) { return true ; } public String getValue ( File file ) { try { if ( ! file . canRead ( ) ) { return null ; } java . io . FileInputStream fis = new java . io . FileInputStream ( file ) ; byte [ ] content = new byte [ fis . available ( ) ] ; fis . read ( content ) ; fis . close ( ) ; String s = new String ( content ) ; int hash = s . hashCode ( ) ; return Integer . toString ( hash ) ; } catch ( Exception e ) { return null ; } } public String toString ( ) { return "HashvalueAlgorithm" ; } } 	0	['4', '1', '0', '2', '13', '6', '1', '1', '4', '2', '45', '0', '0', '0', '0.625', '0', '0', '10.25', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceFactory ; import org . apache . tools . ant . types . resources . FileResource ; public class SourceFileScanner implements ResourceFactory { protected Task task ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destDir ; public SourceFileScanner ( Task task ) { this . task = task ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { return restrict ( files , srcDir , destDir , mapper , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public String [ ] restrict ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper , long granularity ) { this . destDir = destDir ; Vector v = new Vector ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File src = FILE_UTILS . resolveFile ( srcDir , files [ i ] ) ; v . addElement ( new Resource ( files [ i ] , src . exists ( ) , src . lastModified ( ) , src . isDirectory ( ) ) ) ; } Resource [ ] sourceresources = new Resource [ v . size ( ) ] ; v . copyInto ( sourceresources ) ; Resource [ ] outofdate = ResourceUtils . selectOutOfDateSources ( task , sourceresources , mapper , this , granularity ) ; String [ ] result = new String [ outofdate . length ] ; for ( int counter = 0 ; counter < outofdate . length ; counter ++ ) { result [ counter ] = outofdate [ counter ] . getName ( ) ; } return result ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper ) { return restrictAsFiles ( files , srcDir , destDir , mapper , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public File [ ] restrictAsFiles ( String [ ] files , File srcDir , File destDir , FileNameMapper mapper , long granularity ) { String [ ] res = restrict ( files , srcDir , destDir , mapper , granularity ) ; File [ ] result = new File [ res . length ] ; for ( int i = 0 ; i < res . length ; i ++ ) { result [ i ] = new File ( srcDir , res [ i ] ) ; } return result ; } public Resource getResource ( String name ) { return new FileResource ( destDir , name ) ; } } 	0	['7', '1', '0', '15', '23', '5', '7', '8', '6', '0.444444444', '148', '1', '2', '0', '0.523809524', '0', '0', '19.71428571', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . i18n ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Hashtable ; import java . util . Locale ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LineTokenizer ; public class Translate extends MatchingTask { private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT = 0 ; private static final int BUNDLE_SPECIFIED_LANGUAGE_COUNTRY = 1 ; private static final int BUNDLE_SPECIFIED_LANGUAGE = 2 ; private static final int BUNDLE_NOMATCH = 3 ; private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT = 4 ; private static final int BUNDLE_DEFAULT_LANGUAGE_COUNTRY = 5 ; private static final int BUNDLE_DEFAULT_LANGUAGE = 6 ; private static final int BUNDLE_MAX_ALTERNATIVES = BUNDLE_DEFAULT_LANGUAGE + 1 ; private String bundle ; private String bundleLanguage ; private String bundleCountry ; private String bundleVariant ; private File toDir ; private String srcEncoding ; private String destEncoding ; private String bundleEncoding ; private String startToken ; private String endToken ; private boolean forceOverwrite ; private Vector filesets = new Vector ( ) ; private Hashtable resourceMap = new Hashtable ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private long [ ] bundleLastModified = new long [ BUNDLE_MAX_ALTERNATIVES ] ; private long srcLastModified ; private long destLastModified ; private boolean loaded = false ; public void setBundle ( String bundle ) { this . bundle = bundle ; } public void setBundleLanguage ( String bundleLanguage ) { this . bundleLanguage = bundleLanguage ; } public void setBundleCountry ( String bundleCountry ) { this . bundleCountry = bundleCountry ; } public void setBundleVariant ( String bundleVariant ) { this . bundleVariant = bundleVariant ; } public void setToDir ( File toDir ) { this . toDir = toDir ; } public void setStartToken ( String startToken ) { this . startToken = startToken ; } public void setEndToken ( String endToken ) { this . endToken = endToken ; } public void setSrcEncoding ( String srcEncoding ) { this . srcEncoding = srcEncoding ; } public void setDestEncoding ( String destEncoding ) { this . destEncoding = destEncoding ; } public void setBundleEncoding ( String bundleEncoding ) { this . bundleEncoding = bundleEncoding ; } public void setForceOverwrite ( boolean forceOverwrite ) { this . forceOverwrite = forceOverwrite ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( bundle == null ) { throw new BuildException ( "The bundle attribute must be set." , getLocation ( ) ) ; } if ( startToken == null ) { throw new BuildException ( "The starttoken attribute must be set." , getLocation ( ) ) ; } if ( endToken == null ) { throw new BuildException ( "The endtoken attribute must be set." , getLocation ( ) ) ; } if ( bundleLanguage == null ) { Locale l = Locale . getDefault ( ) ; bundleLanguage = l . getLanguage ( ) ; } if ( bundleCountry == null ) { bundleCountry = Locale . getDefault ( ) . getCountry ( ) ; } if ( bundleVariant == null ) { Locale l = new Locale ( bundleLanguage , bundleCountry ) ; bundleVariant = l . getVariant ( ) ; } if ( toDir == null ) { throw new BuildException ( "The todir attribute must be set." , getLocation ( ) ) ; } if ( ! toDir . exists ( ) ) { toDir . mkdirs ( ) ; } else if ( toDir . isFile ( ) ) { throw new BuildException ( toDir + " is not a directory" ) ; } if ( srcEncoding == null ) { srcEncoding = System . getProperty ( "file.encoding" ) ; } if ( destEncoding == null ) { destEncoding = srcEncoding ; } if ( bundleEncoding == null ) { bundleEncoding = srcEncoding ; } loadResourceMaps ( ) ; translate ( ) ; } private void loadResourceMaps ( ) throws BuildException { Locale locale = new Locale ( bundleLanguage , bundleCountry , bundleVariant ) ; String language = locale . getLanguage ( ) . length ( ) > 0 ? "_" + locale . getLanguage ( ) : "" ; String country = locale . getCountry ( ) . length ( ) > 0 ? "_" + locale . getCountry ( ) : "" ; String variant = locale . getVariant ( ) . length ( ) > 0 ? "_" + locale . getVariant ( ) : "" ; String bundleFile = bundle + language + country + variant ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE_COUNTRY_VARIANT , false ) ; bundleFile = bundle + language + country ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE_COUNTRY , false ) ; bundleFile = bundle + language ; processBundle ( bundleFile , BUNDLE_SPECIFIED_LANGUAGE , false ) ; bundleFile = bundle ; processBundle ( bundleFile , BUNDLE_NOMATCH , false ) ; locale = Locale . getDefault ( ) ; language = locale . getLanguage ( ) . length ( ) > 0 ? "_" + locale . getLanguage ( ) : "" ; country = locale . getCountry ( ) . length ( ) > 0 ? "_" + locale . getCountry ( ) : "" ; variant = locale . getVariant ( ) . length ( ) > 0 ? "_" + locale . getVariant ( ) : "" ; bundleEncoding = System . getProperty ( "file.encoding" ) ; bundleFile = bundle + language + country + variant ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE_COUNTRY_VARIANT , false ) ; bundleFile = bundle + language + country ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE_COUNTRY , false ) ; bundleFile = bundle + language ; processBundle ( bundleFile , BUNDLE_DEFAULT_LANGUAGE , true ) ; } private void processBundle ( final String bundleFile , final int i , final boolean checkLoaded ) throws BuildException { final File propsFile = getProject ( ) . resolveFile ( bundleFile + ".properties" ) ; FileInputStream ins = null ; try { ins = new FileInputStream ( propsFile ) ; loaded = true ; bundleLastModified [ i ] = propsFile . lastModified ( ) ; log ( "Using " + propsFile , Project . MSG_DEBUG ) ; loadResourceMap ( ins ) ; } catch ( IOException ioe ) { log ( propsFile + " not found." , Project . MSG_DEBUG ) ; if ( ! loaded && checkLoaded ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } } private void loadResourceMap ( FileInputStream ins ) throws BuildException { try { BufferedReader in = null ; InputStreamReader isr = new InputStreamReader ( ins , bundleEncoding ) ; in = new BufferedReader ( isr ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . trim ( ) . length ( ) > 1 && '#' != line . charAt ( 0 ) && '!' != line . charAt ( 0 ) ) { int sepIndex = line . indexOf ( '=' ) ; if ( - 1 == sepIndex ) { sepIndex = line . indexOf ( ':' ) ; } if ( - 1 == sepIndex ) { for ( int k = 0 ; k < line . length ( ) ; k ++ ) { if ( Character . isSpaceChar ( line . charAt ( k ) ) ) { sepIndex = k ; break ; } } } if ( - 1 != sepIndex ) { String key = line . substring ( 0 , sepIndex ) . trim ( ) ; String value = line . substring ( sepIndex + 1 ) . trim ( ) ; while ( value . endsWith ( "\\" ) ) { value = value . substring ( 0 , value . length ( ) - 1 ) ; if ( ( line = in . readLine ( ) ) != null ) { value = value + line . trim ( ) ; } else { break ; } } if ( key . length ( ) > 0 ) { if ( resourceMap . get ( key ) == null ) { resourceMap . put ( key , value ) ; } } } } } if ( in != null ) { in . close ( ) ; } } catch ( IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } private void translate ( ) throws BuildException { int filesProcessed = 0 ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < srcFiles . length ; j ++ ) { try { File dest = FILE_UTILS . resolveFile ( toDir , srcFiles [ j ] ) ; try { File destDir = new File ( dest . getParent ( ) ) ; if ( ! destDir . exists ( ) ) { destDir . mkdirs ( ) ; } } catch ( Exception e ) { log ( "Exception occurred while trying to check/create " + " parent directory.  " + e . getMessage ( ) , Project . MSG_DEBUG ) ; } destLastModified = dest . lastModified ( ) ; File src = FILE_UTILS . resolveFile ( ds . getBasedir ( ) , srcFiles [ j ] ) ; srcLastModified = src . lastModified ( ) ; boolean needsWork = forceOverwrite || destLastModified < srcLastModified ; if ( ! needsWork ) { for ( int icounter = 0 ; icounter < BUNDLE_MAX_ALTERNATIVES ; icounter ++ ) { needsWork = ( destLastModified < bundleLastModified [ icounter ] ) ; if ( needsWork ) { break ; } } } if ( needsWork ) { log ( "Processing " + srcFiles [ j ] , Project . MSG_DEBUG ) ; FileOutputStream fos = new FileOutputStream ( dest ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( fos , destEncoding ) ) ; FileInputStream fis = new FileInputStream ( src ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( fis , srcEncoding ) ) ; String line ; LineTokenizer lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; line = lineTokenizer . getToken ( in ) ; while ( ( line ) != null ) { int startIndex = line . indexOf ( startToken ) ; while ( startIndex >= 0 && ( startIndex + startToken . length ( ) ) <= line . length ( ) ) { String replace = null ; int endIndex = line . indexOf ( endToken , startIndex + startToken . length ( ) ) ; if ( endIndex < 0 ) { startIndex += 1 ; } else { String token = line . substring ( startIndex + startToken . length ( ) , endIndex ) ; boolean validToken = true ; for ( int k = 0 ; k < token . length ( ) && validToken ; k ++ ) { char c = token . charAt ( k ) ; if ( c == ':' || c == '=' || Character . isSpaceChar ( c ) ) { validToken = false ; } } if ( ! validToken ) { startIndex += 1 ; } else { if ( resourceMap . containsKey ( token ) ) { replace = ( String ) resourceMap . get ( token ) ; } else { log ( "Replacement string missing for: " + token , Project . MSG_VERBOSE ) ; replace = startToken + token + endToken ; } line = line . substring ( 0 , startIndex ) + replace + line . substring ( endIndex + endToken . length ( ) ) ; startIndex += replace . length ( ) ; } } startIndex = line . indexOf ( startToken , startIndex ) ; } out . write ( line ) ; line = lineTokenizer . getToken ( in ) ; } if ( in != null ) { in . close ( ) ; } if ( out != null ) { out . close ( ) ; } ++ filesProcessed ; } else { log ( "Skipping " + srcFiles [ j ] + " as destination file is up to date" , Project . MSG_VERBOSE ) ; } } catch ( IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , getLocation ( ) ) ; } } } log ( "Translation performed on " + filesProcessed + " file(s)." , Project . MSG_DEBUG ) ; } } 	0	['19', '4', '0', '8', '84', '103', '0', '8', '14', '0.929487179', '1034', '1', '1', '0.821052632', '0.26984127', '0', '0', '52.05263158', '1', '0.8947', '0']
package org . apache . tools . ant . util . optional ; import org . apache . tools . ant . util . WeakishReference ; public class WeakishReference12 extends WeakishReference . HardReference { public WeakishReference12 ( Object reference ) { super ( reference ) ; } } 	0	['1', '3', '0', '1', '2', '0', '0', '1', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public class FilenameSelector extends BaseExtendSelector { private String pattern = null ; private boolean casesensitive = true ; private boolean negated = false ; public static final String NAME_KEY = "name" ; public static final String CASE_KEY = "casesensitive" ; public static final String NEGATE_KEY = "negate" ; public FilenameSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{filenameselector name: " ) ; buf . append ( pattern ) ; buf . append ( " negate: " ) ; if ( negated ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( " casesensitive: " ) ; if ( casesensitive ) { buf . append ( "true" ) ; } else { buf . append ( "false" ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setName ( String pattern ) { pattern = pattern . replace ( '/' , File . separatorChar ) . replace ( '\\' , File . separatorChar ) ; if ( pattern . endsWith ( File . separator ) ) { pattern += "**" ; } this . pattern = pattern ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setNegate ( boolean negated ) { this . negated = negated ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( NAME_KEY . equalsIgnoreCase ( paramname ) ) { setName ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( NEGATE_KEY . equalsIgnoreCase ( paramname ) ) { setNegate ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( pattern == null ) { setError ( "The name attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( SelectorUtils . matchPath ( pattern , filename , casesensitive ) == ! ( negated ) ) ; } } 	0	['8', '5', '0', '10', '23', '0', '6', '4', '8', '0.761904762', '197', '0.5', '0', '0.844444444', '0.35', '1', '4', '22.875', '6', '2.25', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . File ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . io . BufferedOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class FormatterElement { private String classname ; private String extension ; private OutputStream out = System . out ; private File outFile ; private boolean useFile = true ; private String ifProperty ; private String unlessProperty ; public static final String XML_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter" ; public static final String BRIEF_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter" ; public static final String PLAIN_FORMATTER_CLASS_NAME = "org.apache.tools.ant.taskdefs.optional.junit.PlainJUnitResultFormatter" ; public void setType ( TypeAttribute type ) { if ( "xml" . equals ( type . getValue ( ) ) ) { setClassname ( XML_FORMATTER_CLASS_NAME ) ; } else { if ( "brief" . equals ( type . getValue ( ) ) ) { setClassname ( BRIEF_FORMATTER_CLASS_NAME ) ; } else { setClassname ( PLAIN_FORMATTER_CLASS_NAME ) ; } } } public void setClassname ( String classname ) { this . classname = classname ; if ( XML_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".xml" ) ; } else if ( PLAIN_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".txt" ) ; } else if ( BRIEF_FORMATTER_CLASS_NAME . equals ( classname ) ) { setExtension ( ".txt" ) ; } } public String getClassname ( ) { return classname ; } public void setExtension ( String ext ) { this . extension = ext ; } public String getExtension ( ) { return extension ; } void setOutfile ( File out ) { this . outFile = out ; } public void setOutput ( OutputStream out ) { this . out = out ; } public void setUseFile ( boolean useFile ) { this . useFile = useFile ; } boolean getUseFile ( ) { return useFile ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean shouldUse ( Task t ) { if ( ifProperty != null && t . getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && t . getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } JUnitTaskMirror . JUnitResultFormatterMirror createFormatter ( ) throws BuildException { return createFormatter ( null ) ; } JUnitTaskMirror . JUnitResultFormatterMirror createFormatter ( ClassLoader loader ) throws BuildException { if ( classname == null ) { throw new BuildException ( "you must specify type or classname" ) ; } Class f = null ; try { if ( loader == null ) { f = Class . forName ( classname ) ; } else { f = Class . forName ( classname , true , loader ) ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Using loader " + loader + " on class " + classname + ": " + e , e ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Using loader " + loader + " on class " + classname + ": " + e , e ) ; } Object o = null ; try { o = f . newInstance ( ) ; } catch ( InstantiationException e ) { throw new BuildException ( e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( e ) ; } if ( ! ( o instanceof JUnitTaskMirror . JUnitResultFormatterMirror ) ) { throw new BuildException ( classname + " is not a JUnitResultFormatter" ) ; } JUnitTaskMirror . JUnitResultFormatterMirror r = ( JUnitTaskMirror . JUnitResultFormatterMirror ) o ; if ( useFile && outFile != null ) { try { out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; } catch ( java . io . IOException e ) { throw new BuildException ( "Unable to open file " + outFile , e ) ; } } r . setOutput ( out ) ; return r ; } public static class TypeAttribute extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "plain" , "xml" , "brief" } ; } } } 	0	['15', '1', '0', '7', '34', '75', '2', '5', '11', '0.9', '286', '0.7', '0', '0', '0.208333333', '0', '0', '17.4', '5', '1.5333', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class RegexpMatcherFactory { public RegexpMatcherFactory ( ) { } public RegexpMatcher newRegexpMatcher ( ) throws BuildException { return newRegexpMatcher ( null ) ; } public RegexpMatcher newRegexpMatcher ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( MagicNames . REGEXP_IMPL ) ; } else { systemDefault = p . getProperty ( MagicNames . REGEXP_IMPL ) ; } if ( systemDefault != null ) { return createInstance ( systemDefault ) ; } Throwable cause = null ; try { testAvailability ( "java.util.regex.Matcher" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , JavaEnvUtils . getJavaVersionNumber ( ) < 14 ) ; } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaOroMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } try { testAvailability ( "org.apache.regexp.RE" ) ; return createInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpMatcher" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } throw new BuildException ( "No supported regular expression matcher found" + ( cause != null ? ": " + cause : "" ) , cause ) ; } static Throwable orCause ( Throwable deflt , BuildException be , boolean ignoreCnfe ) { if ( deflt != null ) { return deflt ; } Throwable t = be . getException ( ) ; return ignoreCnfe && t instanceof ClassNotFoundException ? null : t ; } protected RegexpMatcher createInstance ( String className ) throws BuildException { return ( RegexpMatcher ) ClasspathUtils . newInstance ( className , RegexpMatcherFactory . class . getClassLoader ( ) , RegexpMatcher . class ) ; } protected void testAvailability ( String className ) throws BuildException { try { Class . forName ( className ) ; } catch ( Throwable t ) { throw new BuildException ( t ) ; } } } 	0	['6', '1', '1', '8', '22', '15', '3', '5', '3', '0.8', '163', '0', '0', '0', '0.305555556', '0', '0', '25.83333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class Mkdir extends Task { private static final int MKDIR_RETRY_SLEEP_MILLIS = 10 ; private File dir ; public void execute ( ) throws BuildException { if ( dir == null ) { throw new BuildException ( "dir attribute is required" , getLocation ( ) ) ; } if ( dir . isFile ( ) ) { throw new BuildException ( "Unable to create directory as a file " + "already exists with that name: " + dir . getAbsolutePath ( ) ) ; } if ( ! dir . exists ( ) ) { boolean result = mkdirs ( dir ) ; if ( ! result ) { String msg = "Directory " + dir . getAbsolutePath ( ) + " creation was not successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } else { log ( "Skipping " + dir . getAbsolutePath ( ) + " because it already exists." , Project . MSG_VERBOSE ) ; } } public void setDir ( File dir ) { this . dir = dir ; } private boolean mkdirs ( File f ) { if ( ! f . mkdirs ( ) ) { try { Thread . sleep ( MKDIR_RETRY_SLEEP_MILLIS ) ; return f . mkdirs ( ) ; } catch ( InterruptedException ex ) { return f . mkdirs ( ) ; } } return true ; } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '1', '111', '1', '0', '0.925', '0.75', '2', '2', '26.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; class ConstantPool { static final byte UTF8 = 1 , UNUSED = 2 , INTEGER = 3 , FLOAT = 4 , LONG = 5 , DOUBLE = 6 , CLASS = 7 , STRING = 8 , FIELDREF = 9 , METHODREF = 10 , INTERFACEMETHODREF = 11 , NAMEANDTYPE = 12 ; byte [ ] types ; Object [ ] values ; ConstantPool ( DataInput data ) throws IOException { super ( ) ; int count = data . readUnsignedShort ( ) ; types = new byte [ count ] ; values = new Object [ count ] ; for ( int i = 1 ; i < count ; i ++ ) { byte type = data . readByte ( ) ; types [ i ] = type ; switch ( type ) { case UTF8 : values [ i ] = data . readUTF ( ) ; break ; case UNUSED : break ; case INTEGER : values [ i ] = new Integer ( data . readInt ( ) ) ; break ; case FLOAT : values [ i ] = new Float ( data . readFloat ( ) ) ; break ; case LONG : values [ i ] = new Long ( data . readLong ( ) ) ; ++ i ; break ; case DOUBLE : values [ i ] = new Double ( data . readDouble ( ) ) ; ++ i ; break ; case CLASS : case STRING : values [ i ] = new Integer ( data . readUnsignedShort ( ) ) ; break ; case FIELDREF : case METHODREF : case INTERFACEMETHODREF : case NAMEANDTYPE : values [ i ] = new Integer ( data . readInt ( ) ) ; break ; default : } } } } public class ClassNameReader extends Object { public static String getClassName ( InputStream input ) throws IOException { DataInputStream data = new DataInputStream ( input ) ; int cookie = data . readInt ( ) ; if ( cookie != 0xCAFEBABE ) { return null ; } data . readInt ( ) ; ConstantPool constants = new ConstantPool ( data ) ; Object [ ] values = constants . values ; data . readUnsignedShort ( ) ; int classIndex = data . readUnsignedShort ( ) ; Integer stringIndex = ( Integer ) values [ classIndex ] ; String className = ( String ) values [ stringIndex . intValue ( ) ] ; return className ; } } 	0	['2', '1', '0', '2', '8', '1', '1', '1', '2', '2', '48', '0', '0', '0', '0.5', '0', '0', '23', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; public interface MSVSSConstants { String SS_EXE = "ss" ; String PROJECT_PREFIX = "$" ; String COMMAND_CP = "CP" ; String COMMAND_ADD = "Add" ; String COMMAND_GET = "Get" ; String COMMAND_CHECKOUT = "Checkout" ; String COMMAND_CHECKIN = "Checkin" ; String COMMAND_LABEL = "Label" ; String COMMAND_HISTORY = "History" ; String COMMAND_CREATE = "Create" ; String STYLE_BRIEF = "brief" ; String STYLE_CODEDIFF = "codediff" ; String STYLE_NOFILE = "nofile" ; String STYLE_DEFAULT = "default" ; String TIME_CURRENT = "current" ; String TIME_MODIFIED = "modified" ; String TIME_UPDATED = "updated" ; String WRITABLE_REPLACE = "replace" ; String WRITABLE_SKIP = "skip" ; String WRITABLE_FAIL = "fail" ; String FLAG_LOGIN = "-Y" ; String FLAG_OVERRIDE_WORKING_DIR = "-GL" ; String FLAG_AUTORESPONSE_DEF = "-I-" ; String FLAG_AUTORESPONSE_YES = "-I-Y" ; String FLAG_AUTORESPONSE_NO = "-I-N" ; String FLAG_RECURSION = "-R" ; String FLAG_VERSION = "-V" ; String FLAG_VERSION_DATE = "-Vd" ; String FLAG_VERSION_LABEL = "-VL" ; String FLAG_WRITABLE = "-W" ; String VALUE_NO = "-N" ; String VALUE_YES = "-Y" ; String FLAG_QUIET = "-O-" ; String FLAG_COMMENT = "-C" ; String FLAG_LABEL = "-L" ; String VALUE_FROMDATE = "~d" ; String VALUE_FROMLABEL = "~L" ; String FLAG_OUTPUT = "-O" ; String FLAG_USER = "-U" ; String FLAG_NO_FILE = "-F-" ; String FLAG_BRIEF = "-B" ; String FLAG_CODEDIFF = "-D" ; String FLAG_FILETIME_DEF = "-GTC" ; String FLAG_FILETIME_MODIFIED = "-GTM" ; String FLAG_FILETIME_UPDATED = "-GTU" ; String FLAG_REPLACE_WRITABLE = "-GWR" ; String FLAG_SKIP_WRITABLE = "-GWS" ; String FLAG_NO_GET = "-G-" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '48', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMklbtype extends ClearCase { private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; private boolean mReplace = false ; private boolean mGlobal = false ; private boolean mOrdinary = true ; private boolean mPbranch = false ; private boolean mShared = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKLBTYPE ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getTypeSpecifier ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getOrdinary ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_ORDINARY ) ; } else { if ( getGlobal ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_GLOBAL ) ; } } if ( getPbranch ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PBRANCH ) ; } if ( getShared ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_SHARED ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getTypeSpecifier ( ) ) ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } public void setReplace ( boolean repl ) { mReplace = repl ; } public boolean getReplace ( ) { return mReplace ; } public void setGlobal ( boolean glob ) { mGlobal = glob ; } public boolean getGlobal ( ) { return mGlobal ; } public void setOrdinary ( boolean ordinary ) { mOrdinary = ordinary ; } public boolean getOrdinary ( ) { return mOrdinary ; } public void setPbranch ( boolean pbranch ) { mPbranch = pbranch ; } public boolean getPbranch ( ) { return mPbranch ; } public void setShared ( boolean shared ) { mShared = shared ; } public boolean getShared ( ) { return mShared ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private String getTypeSpecifier ( ) { String typenm = null ; typenm = getTypeName ( ) ; if ( getVOB ( ) != null ) { typenm += "@" + getVOB ( ) ; } return typenm ; } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_GLOBAL = "-global" ; public static final String FLAG_ORDINARY = "-ordinary" ; public static final String FLAG_PBRANCH = "-pbranch" ; public static final String FLAG_SHARED = "-shared" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['24', '4', '0', '7', '43', '222', '0', '7', '20', '0.943734015', '309', '0.529411765', '0', '0.676056338', '0.375', '2', '2', '11.16666667', '8', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . pvcs ; public class PvcsProject { private String name ; public PvcsProject ( ) { super ( ) ; } public void setName ( String name ) { PvcsProject . this . name = name ; } public String getName ( ) { return name ; } } 	0	['3', '1', '0', '1', '4', '1', '1', '0', '3', '0.5', '14', '1', '0', '0', '0.666666667', '0', '0', '3.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public final class StripJavaComments extends BaseFilterReader implements ChainableReader { private int readAheadCh = - 1 ; private boolean inString = false ; private boolean quoted = false ; public StripJavaComments ( ) { super ( ) ; } public StripJavaComments ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( readAheadCh != - 1 ) { ch = readAheadCh ; readAheadCh = - 1 ; } else { ch = in . read ( ) ; if ( ch == '"' && ! quoted ) { inString = ! inString ; quoted = false ; } else if ( ch == '\\' ) { quoted = ! quoted ; } else { quoted = false ; if ( ! inString ) { if ( ch == '/' ) { ch = in . read ( ) ; if ( ch == '/' ) { while ( ch != '\n' && ch != - 1 && ch != '\r' ) { ch = in . read ( ) ; } } else if ( ch == '*' ) { while ( ch != - 1 ) { ch = in . read ( ) ; if ( ch == '*' ) { ch = in . read ( ) ; while ( ch == '*' && ch != - 1 ) { ch = in . read ( ) ; } if ( ch == '/' ) { ch = read ( ) ; break ; } } } } else { readAheadCh = ch ; ch = '/' ; } } } } } return ch ; } public Reader chain ( final Reader rdr ) { StripJavaComments newFilter = new StripJavaComments ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '3', '7', '0', '1', '2', '4', '0', '161', '1', '0', '0.928571429', '0.75', '2', '4', '38.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskAdapter ; public class Taskdef extends Typedef { public Taskdef ( ) { setAdapterClass ( TaskAdapter . class ) ; setAdaptToClass ( Task . class ) ; } } 	0	['1', '7', '0', '1', '7', '0', '0', '1', '1', '2', '40', '0', '0', '1', '1', '0', '0', '37', '0', '0', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; import org . apache . tools . ant . ProjectComponent ; public class LineTokenizer extends ProjectComponent implements Tokenizer { private String lineEnd = "" ; private int pushed = - 2 ; private boolean includeDelims = false ; public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } lineEnd = "" ; StringBuffer line = new StringBuffer ( ) ; int state = 0 ; while ( ch != - 1 ) { if ( state == 0 ) { if ( ch == '\r' ) { state = 1 ; } else if ( ch == '\n' ) { lineEnd = "\n" ; break ; } else { line . append ( ( char ) ch ) ; } } else { state = 0 ; if ( ch == '\n' ) { lineEnd = "\r\n" ; } else { pushed = ch ; lineEnd = "\r" ; } break ; } ch = in . read ( ) ; } if ( ch == - 1 && state == 1 ) { lineEnd = "\r" ; } if ( includeDelims ) { line . append ( lineEnd ) ; } return line . toString ( ) ; } public String getPostToken ( ) { if ( includeDelims ) { return "" ; } return lineEnd ; } } 	0	['4', '2', '0', '8', '10', '0', '6', '2', '4', '0.333333333', '125', '1', '0', '0.75', '0.5', '0', '0', '29.5', '2', '1', '0']
package org . apache . tools . ant ; import java . io . File ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import org . apache . tools . ant . taskdefs . condition . Os ; public class PathTokenizer { private StringTokenizer tokenizer ; private String lookahead = null ; private boolean onNetWare = Os . isFamily ( "netware" ) ; private boolean dosStyleFilesystem ; public PathTokenizer ( String path ) { if ( onNetWare ) { tokenizer = new StringTokenizer ( path , ":;" , true ) ; } else { tokenizer = new StringTokenizer ( path , ":;" , false ) ; } dosStyleFilesystem = File . pathSeparatorChar == ';' ; } public boolean hasMoreTokens ( ) { if ( lookahead != null ) { return true ; } return tokenizer . hasMoreTokens ( ) ; } public String nextToken ( ) throws NoSuchElementException { String token = null ; if ( lookahead != null ) { token = lookahead ; lookahead = null ; } else { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( ! onNetWare ) { if ( token . length ( ) == 1 && Character . isLetter ( token . charAt ( 0 ) ) && dosStyleFilesystem && tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( nextToken . startsWith ( "\\" ) || nextToken . startsWith ( "/" ) ) { token += ":" + nextToken ; } else { lookahead = nextToken ; } } } else { if ( token . equals ( File . pathSeparator ) || token . equals ( ":" ) ) { token = tokenizer . nextToken ( ) . trim ( ) ; } if ( tokenizer . hasMoreTokens ( ) ) { String nextToken = tokenizer . nextToken ( ) . trim ( ) ; if ( ! nextToken . equals ( File . pathSeparator ) ) { if ( nextToken . equals ( ":" ) ) { if ( ! token . startsWith ( "/" ) && ! token . startsWith ( "\\" ) && ! token . startsWith ( "." ) && ! token . startsWith ( ".." ) ) { String oneMore = tokenizer . nextToken ( ) . trim ( ) ; if ( ! oneMore . equals ( File . pathSeparator ) ) { token += ":" + oneMore ; } else { token += ":" ; lookahead = oneMore ; } } } else { lookahead = nextToken ; } } } } return token ; } } 	0	['3', '1', '0', '3', '18', '0', '2', '1', '3', '0.25', '204', '1', '0', '0', '0.666666667', '0', '0', '65.66666667', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Parameterizable ; public abstract class BaseParamFilterReader extends BaseFilterReader implements Parameterizable { private Parameter [ ] parameters ; public BaseParamFilterReader ( ) { super ( ) ; } public BaseParamFilterReader ( final Reader in ) { super ( in ) ; } public final void setParameters ( final Parameter [ ] parameters ) { this . parameters = parameters ; setInitialized ( false ) ; } protected final Parameter [ ] getParameters ( ) { return parameters ; } } 	0	['4', '4', '12', '15', '7', '4', '12', '3', '3', '0.666666667', '22', '1', '1', '0.928571429', '0.5', '0', '0', '4.25', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public abstract class MappingSelector extends BaseSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected File targetdir = null ; protected Mapper mapperElement = null ; protected FileNameMapper map = null ; protected int granularity = 0 ; public MappingSelector ( ) { granularity = ( int ) FILE_UTILS . getFileTimestampGranularity ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir . getName ( ) + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; boolean selected = selectionTest ( file , destfile ) ; return selected ; } protected abstract boolean selectionTest ( File srcfile , File destfile ) ; public void setGranularity ( int granularity ) { this . granularity = granularity ; } } 	0	['8', '4', '2', '9', '24', '8', '2', '7', '6', '0.742857143', '143', '1', '3', '0.853658537', '0.428571429', '1', '3', '16.25', '4', '1.5', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . FileInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; public class ConcatFileInputStream extends InputStream { private static final int EOF = - 1 ; private int currentIndex = - 1 ; private boolean eof = false ; private File [ ] file ; private InputStream currentStream ; private ProjectComponent managingPc ; public ConcatFileInputStream ( File [ ] file ) throws IOException { this . file = file ; } public void close ( ) throws IOException { closeCurrent ( ) ; eof = true ; } public int read ( ) throws IOException { int result = readCurrent ( ) ; if ( result == EOF && ! eof ) { openFile ( ++ currentIndex ) ; result = readCurrent ( ) ; } return result ; } public void setManagingTask ( Task task ) { setManagingComponent ( task ) ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { if ( loglevel > Project . MSG_WARN ) { System . out . println ( message ) ; } else { System . err . println ( message ) ; } } } private int readCurrent ( ) throws IOException { return ( eof || currentStream == null ) ? EOF : currentStream . read ( ) ; } private void openFile ( int index ) throws IOException { closeCurrent ( ) ; if ( file != null && index < file . length ) { log ( "Opening " + file [ index ] , Project . MSG_VERBOSE ) ; try { currentStream = new BufferedInputStream ( new FileInputStream ( file [ index ] ) ) ; } catch ( IOException eyeOhEx ) { log ( "Failed to open " + file [ index ] , Project . MSG_ERR ) ; throw eyeOhEx ; } } else { eof = true ; } } private void closeCurrent ( ) { FileUtils . close ( currentStream ) ; currentStream = null ; } } 	0	['9', '2', '0', '4', '19', '10', '1', '3', '6', '0.729166667', '159', '1', '1', '0.529411765', '0.277777778', '1', '1', '16', '3', '1.1111', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class And extends ResourceSelectorContainer implements ResourceSelector { public And ( ) { } public And ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ! ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { return false ; } } return true ; } } 	0	['3', '4', '0', '4', '9', '3', '1', '3', '3', '2', '27', '0', '0', '0.972222222', '0.555555556', '0', '0', '8', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JJTree extends Task { private static final String OUTPUT_FILE = "OUTPUT_FILE" ; private static final String BUILD_NODE_FILES = "BUILD_NODE_FILES" ; private static final String MULTI = "MULTI" ; private static final String NODE_DEFAULT_VOID = "NODE_DEFAULT_VOID" ; private static final String NODE_FACTORY = "NODE_FACTORY" ; private static final String NODE_SCOPE_HOOK = "NODE_SCOPE_HOOK" ; private static final String NODE_USES_PARSER = "NODE_USES_PARSER" ; private static final String STATIC = "STATIC" ; private static final String VISITOR = "VISITOR" ; private static final String NODE_PACKAGE = "NODE_PACKAGE" ; private static final String VISITOR_EXCEPTION = "VISITOR_EXCEPTION" ; private static final String NODE_PREFIX = "NODE_PREFIX" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private String outputFile = null ; private static final String DEFAULT_SUFFIX = ".jj" ; private File outputDirectory = null ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; public void setBuildnodefiles ( boolean buildNodeFiles ) { optionalAttrs . put ( BUILD_NODE_FILES , buildNodeFiles ? Boolean . TRUE : Boolean . FALSE ) ; } public void setMulti ( boolean multi ) { optionalAttrs . put ( MULTI , multi ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodedefaultvoid ( boolean nodeDefaultVoid ) { optionalAttrs . put ( NODE_DEFAULT_VOID , nodeDefaultVoid ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodefactory ( boolean nodeFactory ) { optionalAttrs . put ( NODE_FACTORY , nodeFactory ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodescopehook ( boolean nodeScopeHook ) { optionalAttrs . put ( NODE_SCOPE_HOOK , nodeScopeHook ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodeusesparser ( boolean nodeUsesParser ) { optionalAttrs . put ( NODE_USES_PARSER , nodeUsesParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setStatic ( boolean staticParser ) { optionalAttrs . put ( STATIC , staticParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setVisitor ( boolean visitor ) { optionalAttrs . put ( VISITOR , visitor ? Boolean . TRUE : Boolean . FALSE ) ; } public void setNodepackage ( String nodePackage ) { optionalAttrs . put ( NODE_PACKAGE , nodePackage ) ; } public void setVisitorException ( String visitorException ) { optionalAttrs . put ( VISITOR_EXCEPTION , visitorException ) ; } public void setNodeprefix ( String nodePrefix ) { optionalAttrs . put ( NODE_PREFIX , nodePrefix ) ; } public void setOutputdirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public void setOutputfile ( String outputFile ) { this . outputFile = outputFile ; } public void setTarget ( File targetFile ) { this . targetFile = targetFile ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JJTree ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } File javaFile = null ; if ( outputDirectory == null ) { cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + getDefaultOutputDirectory ( ) ) ; javaFile = new File ( createOutputFileName ( targetFile , outputFile , null ) ) ; } else { if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "'outputdirectory' " + outputDirectory + " is not a directory." ) ; } cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + outputDirectory . getAbsolutePath ( ) . replace ( '\\' , '/' ) ) ; javaFile = new File ( createOutputFileName ( targetFile , outputFile , outputDirectory . getPath ( ) ) ) ; } if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } if ( outputFile != null ) { cmdl . createArgument ( ) . setValue ( "-" + OUTPUT_FILE + ":" + outputFile . replace ( '\\' , '/' ) ) ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JJTREE ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; final Execute process = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_INFO ) , null ) ; log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; process . setCommandline ( cmdl . getCommandline ( ) ) ; try { if ( process . execute ( ) != 0 ) { throw new BuildException ( "JJTree failed." ) ; } } catch ( IOException e ) { throw new BuildException ( "Failed to launch JJTree" , e ) ; } } private String createOutputFileName ( File destFile , String optionalOutputFile , String outputDir ) { optionalOutputFile = validateOutputFile ( optionalOutputFile , outputDir ) ; String jjtreeFile = destFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( ( optionalOutputFile == null ) || optionalOutputFile . equals ( "" ) ) { int filePos = jjtreeFile . lastIndexOf ( "/" ) ; if ( filePos >= 0 ) { jjtreeFile = jjtreeFile . substring ( filePos + 1 ) ; } int suffixPos = jjtreeFile . lastIndexOf ( '.' ) ; if ( suffixPos == - 1 ) { optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX ; } else { String currentSuffix = jjtreeFile . substring ( suffixPos ) ; if ( currentSuffix . equals ( DEFAULT_SUFFIX ) ) { optionalOutputFile = jjtreeFile + DEFAULT_SUFFIX ; } else { optionalOutputFile = jjtreeFile . substring ( 0 , suffixPos ) + DEFAULT_SUFFIX ; } } } if ( ( outputDir == null ) || outputDir . equals ( "" ) ) { outputDir = getDefaultOutputDirectory ( ) ; } return ( outputDir + "/" + optionalOutputFile ) . replace ( '\\' , '/' ) ; } private String validateOutputFile ( String destFile , String outputDir ) throws BuildException { if ( destFile == null ) { return null ; } if ( ( outputDir == null ) && ( destFile . startsWith ( "/" ) || destFile . startsWith ( "\\" ) ) ) { String relativeOutputFile = makeOutputFileRelative ( destFile ) ; setOutputfile ( relativeOutputFile ) ; return relativeOutputFile ; } String root = getRoot ( new File ( destFile ) ) . getAbsolutePath ( ) ; if ( ( root . length ( ) > 1 ) && destFile . startsWith ( root . substring ( 0 , root . length ( ) - 1 ) ) ) { throw new BuildException ( "Drive letter in 'outputfile' not " + "supported: " + destFile ) ; } return destFile ; } private String makeOutputFileRelative ( String destFile ) { StringBuffer relativePath = new StringBuffer ( ) ; String defaultOutputDirectory = getDefaultOutputDirectory ( ) ; int nextPos = defaultOutputDirectory . indexOf ( '/' ) ; int startPos = nextPos + 1 ; while ( startPos > - 1 && startPos < defaultOutputDirectory . length ( ) ) { relativePath . append ( "/.." ) ; nextPos = defaultOutputDirectory . indexOf ( '/' , startPos ) ; if ( nextPos == - 1 ) { startPos = nextPos ; } else { startPos = nextPos + 1 ; } } relativePath . append ( destFile ) ; return relativePath . toString ( ) ; } private String getDefaultOutputDirectory ( ) { return getProject ( ) . getBaseDir ( ) . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; } private File getRoot ( File file ) { File root = file . getAbsoluteFile ( ) ; while ( root . getParent ( ) != null ) { root = root . getParentFile ( ) ; } return root ; } } 	0	['22', '3', '0', '13', '80', '59', '0', '13', '17', '0.977443609', '678', '1', '1', '0.637931034', '0.477272727', '1', '1', '28.95454545', '8', '1.8182', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import java . io . File ; import java . util . Vector ; import java . util . Hashtable ; import java . util . Enumeration ; public class DotnetBaseMatchingTask extends MatchingTask { protected File outputFile ; protected Vector filesets = new Vector ( ) ; protected File srcDir ; protected static final boolean isWindows = Os . isFamily ( "windows" ) ; public File getSrcDir ( ) { return this . srcDir ; } public void setSrcDir ( File srcDirName ) { this . srcDir = srcDirName ; } public void setDestFile ( File file ) { outputFile = file ; } public void addSrc ( FileSet src ) { filesets . add ( src ) ; } public File getDestFile ( ) { return outputFile ; } protected int buildFileList ( NetCommand command , Hashtable filesToBuild , long outputTimestamp ) { int filesOutOfDate = 0 ; boolean scanImplicitFileset = getSrcDir ( ) != null || filesets . size ( ) == 0 ; if ( scanImplicitFileset ) { if ( getSrcDir ( ) == null ) { setSrcDir ( getProject ( ) . resolveFile ( "." ) ) ; } log ( "working from source directory " + getSrcDir ( ) , Project . MSG_VERBOSE ) ; DirectoryScanner scanner = getDirectoryScanner ( getSrcDir ( ) ) ; filesOutOfDate = command . scanOneFileset ( scanner , filesToBuild , outputTimestamp ) ; } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; filesOutOfDate += command . scanOneFileset ( fs . getDirectoryScanner ( getProject ( ) ) , filesToBuild , outputTimestamp ) ; } return filesOutOfDate ; } protected void addFilesToCommand ( Hashtable filesToBuild , NetCommand command ) { int count = filesToBuild . size ( ) ; log ( "compiling " + count + " file" + ( ( count == 1 ) ? "" : "s" ) , Project . MSG_VERBOSE ) ; Enumeration files = filesToBuild . elements ( ) ; while ( files . hasMoreElements ( ) ) { File file = ( File ) files . nextElement ( ) ; command . addArgument ( file . toString ( ) ) ; } } protected long getOutputFileTimestamp ( ) { long outputTimestamp ; if ( getDestFile ( ) != null && getDestFile ( ) . exists ( ) ) { outputTimestamp = getDestFile ( ) . lastModified ( ) ; } else { outputTimestamp = 0 ; } return outputTimestamp ; } protected void addFilesAndExecute ( NetCommand command , boolean ignoreTimestamps ) { long outputTimestamp = getOutputFileTimestamp ( ) ; Hashtable filesToBuild = new Hashtable ( ) ; int filesOutOfDate = buildFileList ( command , filesToBuild , outputTimestamp ) ; if ( filesOutOfDate > 0 ) { addFilesToCommand ( filesToBuild , command ) ; command . runCommand ( ) ; } else { log ( "output file is up to date" , Project . MSG_VERBOSE ) ; } } } 	0	['11', '4', '2', '8', '38', '45', '2', '6', '6', '0.775', '202', '1', '0', '0.896551724', '0.285714286', '0', '0', '17', '6', '1.7273', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . Project ; public final class ExpandProperties extends BaseFilterReader implements ChainableReader { private String queuedData = null ; public ExpandProperties ( ) { super ( ) ; } public ExpandProperties ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readFully ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { Project project = getProject ( ) ; queuedData = project . replaceProperties ( queuedData ) ; return read ( ) ; } } return ch ; } public Reader chain ( final Reader rdr ) { ExpandProperties newFilter = new ExpandProperties ( rdr ) ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '13', '0', '1', '3', '4', '0', '87', '1', '0', '0.928571429', '0.75', '2', '4', '20.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Properties ; import java . io . File ; import java . io . BufferedInputStream ; import java . io . FileInputStream ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; public class PropertiesfileCache implements Cache { private File cachefile = null ; private Properties cache = new Properties ( ) ; private boolean cacheLoaded = false ; private boolean cacheDirty = true ; public PropertiesfileCache ( ) { } public PropertiesfileCache ( File cachefile ) { this . cachefile = cachefile ; } public void setCachefile ( File file ) { cachefile = file ; } public File getCachefile ( ) { return cachefile ; } public boolean isValid ( ) { return ( cachefile != null ) ; } public void load ( ) { if ( ( cachefile != null ) && cachefile . isFile ( ) && cachefile . canRead ( ) ) { try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( cachefile ) ) ; cache . load ( bis ) ; bis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheLoaded = true ; cacheDirty = false ; } public void save ( ) { if ( ! cacheDirty ) { return ; } if ( ( cachefile != null ) && cache . propertyNames ( ) . hasMoreElements ( ) ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( cachefile ) ) ; cache . store ( bos , null ) ; bos . flush ( ) ; bos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } cacheDirty = false ; } public void delete ( ) { cache = new Properties ( ) ; cachefile . delete ( ) ; cacheLoaded = true ; cacheDirty = false ; } public Object get ( Object key ) { if ( ! cacheLoaded ) { load ( ) ; } try { return cache . getProperty ( String . valueOf ( key ) ) ; } catch ( ClassCastException e ) { return null ; } } public void put ( Object key , Object value ) { cache . put ( String . valueOf ( key ) , String . valueOf ( value ) ) ; cacheDirty = true ; } public Iterator iterator ( ) { Vector v = new java . util . Vector ( ) ; Enumeration en = cache . propertyNames ( ) ; while ( en . hasMoreElements ( ) ) { v . add ( en . nextElement ( ) ) ; } return v . iterator ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<PropertiesfileCache:" ) ; buf . append ( "cachefile=" ) . append ( cachefile ) ; buf . append ( ";noOfEntries=" ) . append ( cache . size ( ) ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['12', '1', '0', '2', '42', '0', '1', '1', '12', '0.386363636', '234', '1', '0', '0', '0.444444444', '0', '0', '18.16666667', '4', '1.5833', '0']
package org . apache . tools . ant . taskdefs . cvslib ; class RCSFile { private String name ; private String revision ; private String previousRevision ; RCSFile ( final String name , final String rev ) { this ( name , rev , null ) ; } RCSFile ( final String name , final String revision , final String previousRevision ) { this . name = name ; this . revision = revision ; if ( ! revision . equals ( previousRevision ) ) { this . previousRevision = previousRevision ; } } String getName ( ) { return name ; } String getRevision ( ) { return revision ; } String getPreviousRevision ( ) { return previousRevision ; } } 	0	['5', '1', '0', '2', '7', '4', '2', '0', '0', '0.5', '39', '1', '0', '0', '0.7', '0', '0', '6.2', '1', '0.6', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . io . FilterInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . zip . ZipFile ; import org . apache . tools . zip . ZipEntry ; public class ZipResource extends ArchiveResource { private String encoding ; public ZipResource ( ) { } public ZipResource ( File z , String enc , ZipEntry e ) { super ( z , true ) ; setEncoding ( enc ) ; setEntry ( e ) ; } public void setZipfile ( File z ) { setArchive ( z ) ; } public File getZipfile ( ) { FileResource r = ( FileResource ) getArchive ( ) ; return r . getFile ( ) ; } public void addConfigured ( ResourceCollection a ) { super . addConfigured ( a ) ; if ( ! a . isFilesystemOnly ( ) ) { throw new BuildException ( "only filesystem resources are supported" ) ; } } public void setEncoding ( String enc ) { checkAttributesAllowed ( ) ; encoding = enc ; } public String getEncoding ( ) { return isReference ( ) ? ( ( ZipResource ) getCheckedRef ( ) ) . getEncoding ( ) : encoding ; } public void setRefid ( Reference r ) { if ( encoding != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } final ZipFile z = new ZipFile ( getZipfile ( ) , getEncoding ( ) ) ; ZipEntry ze = z . getEntry ( getName ( ) ) ; if ( ze == null ) { z . close ( ) ; throw new BuildException ( "no entry " + getName ( ) + " in " + getArchive ( ) ) ; } return new FilterInputStream ( z . getInputStream ( ze ) ) { public void close ( ) throws IOException { FileUtils . close ( in ) ; z . close ( ) ; } protected void finalize ( ) throws Throwable { try { close ( ) ; } finally { super . finalize ( ) ; } } } ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( "Use the zip task for zip output." ) ; } protected void fetchEntry ( ) { ZipFile z = null ; try { z = new ZipFile ( getZipfile ( ) , getEncoding ( ) ) ; setEntry ( z . getEntry ( getName ( ) ) ) ; } catch ( IOException e ) { log ( e . getMessage ( ) , Project . MSG_DEBUG ) ; throw new BuildException ( e ) ; } finally { if ( z != null ) { try { z . close ( ) ; } catch ( IOException e ) { } } } } private void setEntry ( ZipEntry e ) { if ( e == null ) { setExists ( false ) ; return ; } setName ( e . getName ( ) ) ; setExists ( true ) ; setLastModified ( e . getTime ( ) ) ; setDirectory ( e . isDirectory ( ) ) ; setSize ( e . getSize ( ) ) ; setMode ( e . getUnixMode ( ) ) ; } } 	0	['12', '5', '0', '10', '52', '60', '2', '9', '10', '0.545454545', '213', '1', '0', '0.873417722', '0.277777778', '3', '6', '16.66666667', '4', '1.4167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public interface ExecuteStreamHandler { void setProcessInputStream ( OutputStream os ) throws IOException ; void setProcessErrorStream ( InputStream is ) throws IOException ; void setProcessOutputStream ( InputStream is ) throws IOException ; void start ( ) throws IOException ; void stop ( ) ; } 	0	['5', '1', '0', '31', '5', '10', '31', '0', '5', '2', '5', '0', '0', '0', '0.533333333', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . io . IOException ; import java . io . FileOutputStream ; import java . io . PrintWriter ; import java . io . BufferedOutputStream ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class NetCommand { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected Task owner ; protected Execute executable ; protected Commandline commandLine ; protected String title ; protected String program ; protected boolean traceCommandLine = false ; protected boolean failOnError ; private File directory ; private boolean useResponseFile = false ; private File temporaryCommandFile ; private int automaticResponseFileThreshold = 64 ; public NetCommand ( Task owner , String title , String program ) { this . owner = owner ; this . title = title ; this . program = program ; commandLine = new Commandline ( ) ; commandLine . setExecutable ( program ) ; } public void setTraceCommandLine ( boolean b ) { traceCommandLine = b ; } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailFailOnError ( ) { return failOnError ; } public void setDirectory ( File directory ) { this . directory = directory ; } protected void logVerbose ( String msg ) { owner . getProject ( ) . log ( msg , Project . MSG_VERBOSE ) ; } protected void logError ( String msg ) { owner . getProject ( ) . log ( msg , Project . MSG_ERR ) ; } public void addArgument ( String argument ) { if ( argument != null && argument . length ( ) != 0 ) { commandLine . createArgument ( ) . setValue ( argument ) ; } } public void addArguments ( String [ ] arguments ) { if ( arguments != null && arguments . length != 0 ) { for ( int i = 0 ; i < arguments . length ; i ++ ) { addArgument ( arguments [ i ] ) ; } } } public void addArgument ( String argument1 , String argument2 ) { if ( argument2 != null && argument2 . length ( ) != 0 ) { commandLine . createArgument ( ) . setValue ( argument1 + argument2 ) ; } } public boolean isUseResponseFile ( ) { return useResponseFile ; } public void setUseResponseFile ( boolean useResponseFile ) { this . useResponseFile = useResponseFile ; } public int getAutomaticResponseFileThreshold ( ) { return automaticResponseFileThreshold ; } public void setAutomaticResponseFileThreshold ( int automaticResponseFileThreshold ) { this . automaticResponseFileThreshold = automaticResponseFileThreshold ; } protected void prepareExecutor ( ) { if ( owner == null ) { throw new RuntimeException ( "no owner" ) ; } if ( owner . getProject ( ) == null ) { throw new RuntimeException ( "Owner has no project" ) ; } File dir = owner . getProject ( ) . getBaseDir ( ) ; if ( directory != null ) { dir = directory ; } ExecuteStreamHandler handler = new LogStreamHandler ( owner , Project . MSG_INFO , Project . MSG_WARN ) ; executable = new Execute ( handler , null ) ; executable . setAntRun ( owner . getProject ( ) ) ; executable . setWorkingDirectory ( dir ) ; } public void runCommand ( ) throws BuildException { prepareExecutor ( ) ; int err = - 1 ; try { if ( traceCommandLine ) { owner . log ( "In directory " + executable . getWorkingDirectory ( ) ) ; owner . log ( commandLine . describeCommand ( ) ) ; } else { logVerbose ( "In directory " + executable . getWorkingDirectory ( ) ) ; logVerbose ( commandLine . describeCommand ( ) ) ; } setExecutableCommandLine ( ) ; err = executable . execute ( ) ; if ( Execute . isFailure ( err ) ) { if ( failOnError ) { throw new BuildException ( title + " returned: " + err , owner . getLocation ( ) ) ; } else { owner . log ( title + "  Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException e ) { throw new BuildException ( title + " failed: " + e , e , owner . getLocation ( ) ) ; } finally { if ( temporaryCommandFile != null ) { temporaryCommandFile . delete ( ) ; } } } private void setExecutableCommandLine ( ) { String [ ] commands = commandLine . getCommandline ( ) ; if ( automaticResponseFileThreshold > 0 && commands . length > automaticResponseFileThreshold ) { useResponseFile = true ; } if ( ! useResponseFile || commands . length <= 1 ) { executable . setCommandline ( commands ) ; } else { FileOutputStream fos = null ; temporaryCommandFile = FILE_UTILS . createTempFile ( "cmd" , ".txt" , null ) ; owner . log ( "Using response file " + temporaryCommandFile , Project . MSG_VERBOSE ) ; try { fos = new FileOutputStream ( temporaryCommandFile ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( fos ) ) ; for ( int i = 1 ; i < commands . length ; ++ i ) { out . println ( commands [ i ] ) ; } out . flush ( ) ; out . close ( ) ; } catch ( IOException ex ) { throw new BuildException ( "saving command stream to " + temporaryCommandFile , ex ) ; } String [ ] newCommandLine = new String [ 2 ] ; newCommandLine [ 0 ] = commands [ 0 ] ; newCommandLine [ 1 ] = "@" + temporaryCommandFile . getAbsolutePath ( ) ; logVerbose ( Commandline . describeCommand ( newCommandLine ) ) ; executable . setCommandline ( newCommandLine ) ; } } public int scanOneFileset ( DirectoryScanner scanner , Hashtable filesToBuild , long outputTimestamp ) { int filesOutOfDate = 0 ; String [ ] dependencies = scanner . getIncludedFiles ( ) ; File base = scanner . getBasedir ( ) ; for ( int i = 0 ; i < dependencies . length ; i ++ ) { File targetFile = new File ( base , dependencies [ i ] ) ; if ( filesToBuild . get ( targetFile ) == null ) { filesToBuild . put ( targetFile , targetFile ) ; if ( targetFile . lastModified ( ) > outputTimestamp ) { filesOutOfDate ++ ; owner . log ( targetFile . toString ( ) + " is out of date" , Project . MSG_VERBOSE ) ; } else { owner . log ( targetFile . toString ( ) , Project . MSG_VERBOSE ) ; } } } return filesOutOfDate ; } } 	0	['19', '1', '0', '23', '69', '81', '11', '12', '14', '0.856481481', '517', '1', '4', '0', '0.183333333', '0', '0', '25.57894737', '6', '1.8421', '0']
package org . apache . tools . ant . listener ; import org . apache . tools . ant . DefaultLogger ; import java . util . Date ; import java . text . DateFormat ; public class TimestampedLogger extends DefaultLogger { private static final String SPACER = " - at " ; protected String getBuildFailedMessage ( ) { return super . getBuildFailedMessage ( ) + SPACER + getTimestamp ( ) ; } protected String getBuildSuccessfulMessage ( ) { return super . getBuildSuccessfulMessage ( ) + SPACER + getTimestamp ( ) ; } protected String getTimestamp ( ) { Date date = new Date ( System . currentTimeMillis ( ) ) ; DateFormat formatter = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT ) ; String finishTime = formatter . format ( date ) ; return finishTime ; } } 	0	['4', '2', '0', '1', '15', '6', '0', '1', '1', '1.333333333', '49', '1', '0', '0.842105263', '1', '1', '1', '11', '1', '0.75', '0']
package org . apache . tools . mail ; import java . io . IOException ; public class ErrorInQuitException extends IOException { public ErrorInQuitException ( IOException e ) { super ( e . getMessage ( ) ) ; } } 	0	['1', '4', '0', '1', '3', '0', '1', '0', '1', '2', '6', '0', '0', '1', '1', '0', '0', '5', '0', '0', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Exists extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { boolean f = foo . isExists ( ) ; if ( f == bar . isExists ( ) ) { return 0 ; } return f ? 1 : - 1 ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '20', '0', '0', '0.971428571', '0.75', '1', '1', '9', '3', '1.5', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; public class ProxySetup { private Project owner ; public static final String USE_SYSTEM_PROXIES = "java.net.useSystemProxies" ; public static final String HTTP_PROXY_HOST = "http.proxyHost" ; public static final String HTTP_PROXY_PORT = "http.proxyPort" ; public static final String HTTPS_PROXY_HOST = "https.proxyHost" ; public static final String HTTPS_PROXY_PORT = "https.proxyPort" ; public static final String FTP_PROXY_HOST = "ftp.proxyHost" ; public static final String FTP_PROXY_PORT = "ftp.proxyPort" ; public static final String HTTP_NON_PROXY_HOSTS = "http.nonProxyHosts" ; public static final String HTTPS_NON_PROXY_HOSTS = "https.nonProxyHosts" ; public static final String FTP_NON_PROXY_HOSTS = "ftp.nonProxyHosts" ; public static final String HTTP_PROXY_USERNAME = "http.proxyUser" ; public static final String HTTP_PROXY_PASSWORD = "http.proxyPassword" ; public static final String SOCKS_PROXY_HOST = "socksProxyHost" ; public static final String SOCKS_PROXY_PORT = "socksProxyPort" ; public static final String SOCKS_PROXY_USERNAME = "java.net.socks.username" ; public static final String SOCKS_PROXY_PASSWORD = "java.net.socks.password" ; public ProxySetup ( Project owner ) { this . owner = owner ; } public static String getSystemProxySetting ( ) { try { return System . getProperty ( USE_SYSTEM_PROXIES ) ; } catch ( SecurityException e ) { return null ; } } public void enableProxies ( ) { if ( ! ( getSystemProxySetting ( ) != null ) ) { String proxies = owner . getProperty ( USE_SYSTEM_PROXIES ) ; if ( proxies == null || Project . toBoolean ( proxies ) ) { proxies = "true" ; } String message = "setting " + USE_SYSTEM_PROXIES + " to " + proxies ; try { owner . log ( message , Project . MSG_DEBUG ) ; System . setProperty ( USE_SYSTEM_PROXIES , proxies ) ; } catch ( SecurityException e ) { owner . log ( "Security Exception when " + message ) ; } } } } 	0	['3', '1', '0', '2', '13', '1', '1', '1', '3', '1.441176471', '76', '0.058823529', '1', '0', '0.5', '0', '0', '18.66666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class Continuus extends Task { private String ccmDir = "" ; private String ccmAction = "" ; public String getCcmAction ( ) { return ccmAction ; } public void setCcmAction ( String v ) { this . ccmAction = v ; } public final void setCcmDir ( String dir ) { ccmDir = FileUtils . translatePath ( dir ) ; } protected final String getCcmCommand ( ) { String toReturn = ccmDir ; if ( ! toReturn . equals ( "" ) && ! toReturn . endsWith ( "/" ) ) { toReturn += "/" ; } toReturn += CCM_EXE ; return toReturn ; } protected int run ( Commandline cmd , ExecuteStreamHandler handler ) { try { Execute exe = new Execute ( handler ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected int run ( Commandline cmd ) { return run ( cmd , new LogStreamHandler ( this , Project . MSG_VERBOSE , Project . MSG_WARN ) ) ; } private static final String CCM_EXE = "ccm" ; public static final String COMMAND_CREATE_TASK = "create_task" ; public static final String COMMAND_CHECKOUT = "co" ; public static final String COMMAND_CHECKIN = "ci" ; public static final String COMMAND_RECONFIGURE = "reconfigure" ; public static final String COMMAND_DEFAULT_TASK = "default_task" ; } 	0	['7', '3', '3', '12', '26', '9', '3', '9', '4', '1.041666667', '106', '0.375', '0', '0.860465116', '0.428571429', '0', '0', '13', '3', '1.1429', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; public interface Retryable { int RETRY_FOREVER = - 1 ; void execute ( ) throws IOException ; } 	0	['1', '1', '0', '1', '1', '0', '1', '0', '1', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . Move ; import org . apache . tools . ant . types . Mapper ; public class RenameExtensions extends MatchingTask { private String fromExtension = "" ; private String toExtension = "" ; private boolean replace = false ; private File srcDir ; private Mapper . MapperType globType ; public RenameExtensions ( ) { super ( ) ; globType = new Mapper . MapperType ( ) ; globType . setValue ( "glob" ) ; } public void setFromExtension ( String from ) { fromExtension = from ; } public void setToExtension ( String to ) { toExtension = to ; } public void setReplace ( boolean replace ) { this . replace = replace ; } public void setSrcDir ( File srcDir ) { this . srcDir = srcDir ; } public void execute ( ) throws BuildException { if ( fromExtension == null || toExtension == null || srcDir == null ) { throw new BuildException ( "srcDir, fromExtension and toExtension " + "attributes must be set!" ) ; } log ( "DEPRECATED - The renameext task is deprecated.  Use move instead." , Project . MSG_WARN ) ; log ( "Replace this with:" , Project . MSG_INFO ) ; log ( "<move todir=\"" + srcDir + "\" overwrite=\"" + replace + "\">" , Project . MSG_INFO ) ; log ( "  <fileset dir=\"" + srcDir + "\" />" , Project . MSG_INFO ) ; log ( "  <mapper type=\"glob\"" , Project . MSG_INFO ) ; log ( "          from=\"*" + fromExtension + "\"" , Project . MSG_INFO ) ; log ( "          to=\"*" + toExtension + "\" />" , Project . MSG_INFO ) ; log ( "</move>" , Project . MSG_INFO ) ; log ( "using the same patterns on <fileset> as you\'ve used here" , Project . MSG_INFO ) ; Move move = new Move ( ) ; move . bindToOwner ( this ) ; move . setOwningTarget ( getOwningTarget ( ) ) ; move . setTaskName ( getTaskName ( ) ) ; move . setLocation ( getLocation ( ) ) ; move . setTodir ( srcDir ) ; move . setOverwrite ( replace ) ; fileset . setDir ( srcDir ) ; move . addFileset ( fileset ) ; Mapper me = move . createMapper ( ) ; me . setType ( globType ) ; me . setFrom ( "*" + fromExtension ) ; me . setTo ( "*" + toExtension ) ; move . execute ( ) ; } } 	0	['6', '4', '0', '9', '33', '0', '0', '9', '6', '0.68', '205', '1', '1', '0.939759036', '0.416666667', '2', '4', '32.33333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . util . EventObject ; public class BuildEvent extends EventObject { private Project project ; private Target target ; private Task task ; private String message ; private int priority = Project . MSG_VERBOSE ; private Throwable exception ; public BuildEvent ( Project project ) { super ( project ) ; this . project = project ; this . target = null ; this . task = null ; } public BuildEvent ( Target target ) { super ( target ) ; this . project = target . getProject ( ) ; this . target = target ; this . task = null ; } public BuildEvent ( Task task ) { super ( task ) ; this . project = task . getProject ( ) ; this . target = task . getOwningTarget ( ) ; this . task = task ; } public void setMessage ( String message , int priority ) { this . message = message ; this . priority = priority ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Project getProject ( ) { return project ; } public Target getTarget ( ) { return target ; } public Task getTask ( ) { return task ; } public String getMessage ( ) { return message ; } public int getPriority ( ) { return priority ; } public Throwable getException ( ) { return exception ; } } 	0	['11', '2', '0', '17', '15', '13', '15', '3', '11', '0.75', '97', '1', '3', '0.2', '0.220779221', '0', '0', '7.272727273', '1', '0.7273', '0']
package org . apache . tools . ant . util ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; public class CompositeMapper extends ContainerMapper { public String [ ] mapFileName ( String sourceFileName ) { HashSet results = new HashSet ( ) ; FileNameMapper mapper = null ; for ( Iterator mIter = getMappers ( ) . iterator ( ) ; mIter . hasNext ( ) ; ) { mapper = ( FileNameMapper ) ( mIter . next ( ) ) ; if ( mapper != null ) { String [ ] mapped = mapper . mapFileName ( sourceFileName ) ; if ( mapped != null ) { results . addAll ( Arrays . asList ( mapped ) ) ; } } } return ( results . size ( ) == 0 ) ? null : ( String [ ] ) results . toArray ( new String [ results . size ( ) ] ) ; } } 	0	['2', '2', '0', '3', '13', '1', '1', '2', '2', '2', '48', '0', '0', '0.875', '0.75', '0', '0', '23', '5', '2.5', '0']
package org . apache . tools . ant . util ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Project ; import java . util . Map ; import java . util . HashMap ; import java . util . Iterator ; public abstract class ScriptRunnerBase { private boolean keepEngine = false ; private String language ; private String script = "" ; private Project project ; private ClassLoader scriptLoader ; private Map beans = new HashMap ( ) ; public void addBeans ( Map dictionary ) { for ( Iterator i = dictionary . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; try { Object val = dictionary . get ( key ) ; addBean ( key , val ) ; } catch ( BuildException ex ) { } } } public void addBean ( String key , Object bean ) { boolean isValid = key . length ( ) > 0 && Character . isJavaIdentifierStart ( key . charAt ( 0 ) ) ; for ( int i = 1 ; isValid && i < key . length ( ) ; i ++ ) { isValid = Character . isJavaIdentifierPart ( key . charAt ( i ) ) ; } if ( isValid ) { beans . put ( key , bean ) ; } } protected Map getBeans ( ) { return beans ; } public abstract void executeScript ( String execName ) ; public abstract Object evaluateScript ( String execName ) ; public abstract boolean supportsLanguage ( ) ; public abstract String getManagerName ( ) ; public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setScriptClassLoader ( ClassLoader classLoader ) { this . scriptLoader = classLoader ; } protected ClassLoader getScriptClassLoader ( ) { return scriptLoader ; } public void setKeepEngine ( boolean keepEngine ) { this . keepEngine = keepEngine ; } public boolean getKeepEngine ( ) { return keepEngine ; } public void setSrc ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "file " + file . getPath ( ) + " not found." ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; script += FileUtils . readFully ( in ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } finally { FileUtils . close ( in ) ; } } public void addText ( String text ) { this . script += text ; } public String getScript ( ) { return script ; } public void clearScript ( ) { this . script = "" ; } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public void bindToComponent ( ProjectComponent component ) { project = component . getProject ( ) ; addBeans ( project . getProperties ( ) ) ; addBeans ( project . getUserProperties ( ) ) ; addBeans ( project . getTargets ( ) ) ; addBeans ( project . getReferences ( ) ) ; addBean ( "project" , project ) ; addBean ( "self" , component ) ; } public void bindToComponentMinimum ( ProjectComponent component ) { project = component . getProject ( ) ; addBean ( "project" , project ) ; addBean ( "self" , component ) ; } protected void checkLanguage ( ) { if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } } protected ClassLoader replaceContextLoader ( ) { ClassLoader origContextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( getScriptClassLoader ( ) == null ) { setScriptClassLoader ( getClass ( ) . getClassLoader ( ) ) ; } Thread . currentThread ( ) . setContextClassLoader ( getScriptClassLoader ( ) ) ; return origContextClassLoader ; } protected void restoreContextLoader ( ClassLoader origLoader ) { Thread . currentThread ( ) . setContextClassLoader ( origLoader ) ; } } 	0	['25', '1', '1', '13', '59', '248', '9', '4', '20', '0.875', '290', '1', '1', '0', '0.173333333', '0', '0', '10.36', '6', '1.4', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; class RedirectingStreamHandler extends PumpStreamHandler { RedirectingStreamHandler ( final ChangeLogParser parser ) { super ( new RedirectingOutputStream ( parser ) , new ByteArrayOutputStream ( ) ) ; } String getErrors ( ) { try { final ByteArrayOutputStream error = ( ByteArrayOutputStream ) getErr ( ) ; return error . toString ( "ASCII" ) ; } catch ( final Exception e ) { return null ; } } public void stop ( ) { super . stop ( ) ; try { getErr ( ) . close ( ) ; getOut ( ) . close ( ) ; } catch ( final IOException e ) { throw new BuildException ( e ) ; } } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '1', '2', '40', '0', '0', '0.857142857', '0.666666667', '0', '0', '12.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsTrue extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for truth" ) ; } return value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '30', '1', '0', '0.818181818', '0.666666667', '0', '0', '8.666666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . util . ArrayList ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Reference ; public class ExtensionSet extends DataType { private final ArrayList extensions = new ArrayList ( ) ; private final ArrayList extensionsFilesets = new ArrayList ( ) ; public void addExtension ( final ExtensionAdapter extensionAdapter ) { extensions . add ( extensionAdapter ) ; } public void addLibfileset ( final LibFileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public void addFileset ( final FileSet fileSet ) { extensionsFilesets . add ( fileSet ) ; } public Extension [ ] toExtensions ( final Project proj ) throws BuildException { final ArrayList extensionsList = ExtensionUtil . toExtensions ( extensions ) ; ExtensionUtil . extractExtensions ( proj , extensionsList , extensionsFilesets ) ; return ( Extension [ ] ) extensionsList . toArray ( new Extension [ extensionsList . size ( ) ] ) ; } public void setRefid ( final Reference reference ) throws BuildException { if ( ! extensions . isEmpty ( ) || ! extensionsFilesets . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } final Object object = reference . getReferencedObject ( getProject ( ) ) ; if ( object instanceof ExtensionSet ) { final ExtensionSet other = ( ExtensionSet ) object ; extensions . addAll ( other . extensions ) ; extensionsFilesets . addAll ( other . extensionsFilesets ) ; } else { final String message = reference . getRefId ( ) + " doesn\'t refer to a ExtensionSet" ; throw new BuildException ( message ) ; } super . setRefid ( reference ) ; } public String toString ( ) { return "ExtensionSet" + Arrays . asList ( toExtensions ( getProject ( ) ) ) ; } } 	0	['7', '3', '0', '11', '28', '0', '2', '9', '7', '0.25', '122', '1', '0', '0.833333333', '0.285714286', '1', '1', '16.14285714', '1', '0.8571', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Or extends ResourceSelectorContainer implements ResourceSelector { public Or ( ) { } public Or ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { return true ; } } return false ; } } 	0	['3', '4', '0', '4', '9', '3', '1', '3', '3', '2', '27', '0', '0', '0.972222222', '0.555555556', '0', '0', '8', '3', '1', '0']
package org . apache . tools . bzip2 ; public interface BZip2Constants { int baseBlockSize = 100000 ; int MAX_ALPHA_SIZE = 258 ; int MAX_CODE_LEN = 23 ; int RUNA = 0 ; int RUNB = 1 ; int N_GROUPS = 6 ; int G_SIZE = 50 ; int N_ITERS = 4 ; int MAX_SELECTORS = ( 2 + ( 900000 / G_SIZE ) ) ; int NUM_OVERSHOOT_BYTES = 20 ; int [ ] rNums = { 619 , 720 , 127 , 481 , 931 , 816 , 813 , 233 , 566 , 247 , 985 , 724 , 205 , 454 , 863 , 491 , 741 , 242 , 949 , 214 , 733 , 859 , 335 , 708 , 621 , 574 , 73 , 654 , 730 , 472 , 419 , 436 , 278 , 496 , 867 , 210 , 399 , 680 , 480 , 51 , 878 , 465 , 811 , 169 , 869 , 675 , 611 , 697 , 867 , 561 , 862 , 687 , 507 , 283 , 482 , 129 , 807 , 591 , 733 , 623 , 150 , 238 , 59 , 379 , 684 , 877 , 625 , 169 , 643 , 105 , 170 , 607 , 520 , 932 , 727 , 476 , 693 , 425 , 174 , 647 , 73 , 122 , 335 , 530 , 442 , 853 , 695 , 249 , 445 , 515 , 909 , 545 , 703 , 919 , 874 , 474 , 882 , 500 , 594 , 612 , 641 , 801 , 220 , 162 , 819 , 984 , 589 , 513 , 495 , 799 , 161 , 604 , 958 , 533 , 221 , 400 , 386 , 867 , 600 , 782 , 382 , 596 , 414 , 171 , 516 , 375 , 682 , 485 , 911 , 276 , 98 , 553 , 163 , 354 , 666 , 933 , 424 , 341 , 533 , 870 , 227 , 730 , 475 , 186 , 263 , 647 , 537 , 686 , 600 , 224 , 469 , 68 , 770 , 919 , 190 , 373 , 294 , 822 , 808 , 206 , 184 , 943 , 795 , 384 , 383 , 461 , 404 , 758 , 839 , 887 , 715 , 67 , 618 , 276 , 204 , 918 , 873 , 777 , 604 , 560 , 951 , 160 , 578 , 722 , 79 , 804 , 96 , 409 , 713 , 940 , 652 , 934 , 970 , 447 , 318 , 353 , 859 , 672 , 112 , 785 , 645 , 863 , 803 , 350 , 139 , 93 , 354 , 99 , 820 , 908 , 609 , 772 , 154 , 274 , 580 , 184 , 79 , 626 , 630 , 742 , 653 , 282 , 762 , 623 , 680 , 81 , 927 , 626 , 789 , 125 , 411 , 521 , 938 , 300 , 821 , 78 , 343 , 175 , 128 , 250 , 170 , 774 , 972 , 275 , 999 , 639 , 495 , 78 , 352 , 126 , 857 , 956 , 358 , 619 , 580 , 124 , 737 , 594 , 701 , 612 , 669 , 112 , 134 , 694 , 363 , 992 , 809 , 743 , 168 , 974 , 944 , 375 , 748 , 52 , 600 , 747 , 642 , 182 , 862 , 81 , 344 , 805 , 988 , 739 , 511 , 655 , 814 , 334 , 249 , 515 , 897 , 955 , 664 , 981 , 649 , 113 , 974 , 459 , 893 , 228 , 433 , 837 , 553 , 268 , 926 , 240 , 102 , 654 , 459 , 51 , 686 , 754 , 806 , 760 , 493 , 403 , 415 , 394 , 687 , 700 , 946 , 670 , 656 , 610 , 738 , 392 , 760 , 799 , 887 , 653 , 978 , 321 , 576 , 617 , 626 , 502 , 894 , 679 , 243 , 440 , 680 , 879 , 194 , 572 , 640 , 724 , 926 , 56 , 204 , 700 , 707 , 151 , 457 , 449 , 797 , 195 , 791 , 558 , 945 , 679 , 297 , 59 , 87 , 824 , 713 , 663 , 412 , 693 , 342 , 606 , 134 , 108 , 571 , 364 , 631 , 212 , 174 , 643 , 304 , 329 , 343 , 97 , 430 , 751 , 497 , 314 , 983 , 374 , 822 , 928 , 140 , 206 , 73 , 263 , 980 , 736 , 876 , 478 , 430 , 305 , 170 , 514 , 364 , 692 , 829 , 82 , 855 , 953 , 676 , 246 , 369 , 970 , 294 , 750 , 807 , 827 , 150 , 790 , 288 , 923 , 804 , 378 , 215 , 828 , 592 , 281 , 565 , 555 , 710 , 82 , 896 , 831 , 547 , 261 , 524 , 462 , 293 , 465 , 502 , 56 , 661 , 821 , 976 , 991 , 658 , 869 , 905 , 758 , 745 , 193 , 768 , 550 , 608 , 933 , 378 , 286 , 215 , 979 , 792 , 961 , 61 , 688 , 793 , 644 , 986 , 403 , 106 , 366 , 905 , 644 , 372 , 567 , 466 , 434 , 645 , 210 , 389 , 550 , 919 , 135 , 780 , 773 , 635 , 389 , 707 , 100 , 626 , 958 , 165 , 504 , 920 , 176 , 193 , 713 , 857 , 265 , 203 , 50 , 668 , 108 , 645 , 990 , 626 , 197 , 510 , 357 , 358 , 850 , 858 , 364 , 936 , 638 } ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '0', '2', '2064', '0', '0', '0', '0', '0', '0', '2052', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSADD extends MSVSS { private String localPath = null ; protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getLocalpath ( ) == null ) { String msg = "localPath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_ADD ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; return commandLine ; } protected String getLocalpath ( ) { return localPath ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setLocalpath ( Path localPath ) { this . localPath = localPath . toString ( ) ; } } 	0	['8', '4', '0', '6', '26', '22', '0', '6', '6', '0.571428571', '95', '1', '0', '0.928571429', '0.40625', '1', '1', '10.75', '2', '1', '0']
package org . apache . tools . ant . types ; import java . security . UnresolvedPermission ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitException ; public class Permissions { private List grantedPermissions = new LinkedList ( ) ; private List revokedPermissions = new LinkedList ( ) ; private java . security . Permissions granted = null ; private SecurityManager origSm = null ; private boolean active = false ; private boolean delegateToOldSM ; public Permissions ( ) { this ( false ) ; } public Permissions ( boolean delegateToOldSM ) { this . delegateToOldSM = delegateToOldSM ; } public void addConfiguredGrant ( Permissions . Permission perm ) { grantedPermissions . add ( perm ) ; } public void addConfiguredRevoke ( Permissions . Permission perm ) { revokedPermissions . add ( perm ) ; } public synchronized void setSecurityManager ( ) throws BuildException { origSm = System . getSecurityManager ( ) ; init ( ) ; System . setSecurityManager ( new MySM ( ) ) ; active = true ; } private void init ( ) throws BuildException { granted = new java . security . Permissions ( ) ; for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Revoked permission " + p + " does not contain a class." ) ; } } for ( Iterator i = grantedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { Permissions . Permission p = ( Permissions . Permission ) i . next ( ) ; if ( p . getClassName ( ) == null ) { throw new BuildException ( "Granted permission " + p + " does not contain a class." ) ; } else { java . security . Permission perm = new UnresolvedPermission ( p . getClassName ( ) , p . getName ( ) , p . getActions ( ) , null ) ; granted . add ( perm ) ; } } granted . add ( new java . net . SocketPermission ( "localhost:1024-" , "listen" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vendor.url" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.class.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "os.arch" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.encoding" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "file.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "path.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "line.separator" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.specification.name" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.version" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.vendor" , "read" ) ) ; granted . add ( new java . util . PropertyPermission ( "java.vm.name" , "read" ) ) ; } public synchronized void restoreSecurityManager ( ) { active = false ; System . setSecurityManager ( origSm ) ; } private class MySM extends SecurityManager { public void checkExit ( int status ) { java . security . Permission perm = new java . lang . RuntimePermission ( "exitVM" , null ) ; try { checkPermission ( perm ) ; } catch ( SecurityException e ) { throw new ExitException ( e . getMessage ( ) , status ) ; } } public void checkPermission ( java . security . Permission perm ) { if ( active ) { if ( delegateToOldSM && ! perm . getName ( ) . equals ( "exitVM" ) ) { boolean permOK = false ; if ( granted . implies ( perm ) ) { permOK = true ; } checkRevoked ( perm ) ; if ( ! permOK && origSm != null ) { origSm . checkPermission ( perm ) ; } } else { if ( ! granted . implies ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was not granted." ) ; } checkRevoked ( perm ) ; } } } private void checkRevoked ( java . security . Permission perm ) { for ( Iterator i = revokedPermissions . listIterator ( ) ; i . hasNext ( ) ; ) { if ( ( ( Permissions . Permission ) i . next ( ) ) . matches ( perm ) ) { throw new SecurityException ( "Permission " + perm + " was revoked." ) ; } } } } public static class Permission { private String className ; private String name ; private String actionString ; private Set actions ; public void setClass ( String aClass ) { className = aClass . trim ( ) ; } public String getClassName ( ) { return className ; } public void setName ( String aName ) { name = aName . trim ( ) ; } public String getName ( ) { return name ; } public void setActions ( String actions ) { actionString = actions ; if ( actions . length ( ) > 0 ) { this . actions = parseActions ( actions ) ; } } public String getActions ( ) { return actionString ; } boolean matches ( java . security . Permission perm ) { if ( ! className . equals ( perm . getClass ( ) . getName ( ) ) ) { return false ; } if ( name != null ) { if ( name . endsWith ( "*" ) ) { if ( ! perm . getName ( ) . startsWith ( name . substring ( 0 , name . length ( ) - 1 ) ) ) { return false ; } } else { if ( ! name . equals ( perm . getName ( ) ) ) { return false ; } } } if ( actions != null ) { Set as = parseActions ( perm . getActions ( ) ) ; int size = as . size ( ) ; as . removeAll ( actions ) ; if ( as . size ( ) == size ) { return false ; } } return true ; } private Set parseActions ( String actions ) { Set result = new HashSet ( ) ; StringTokenizer tk = new StringTokenizer ( actions , "," ) ; while ( tk . hasMoreTokens ( ) ) { String item = tk . nextToken ( ) . trim ( ) ; if ( ! item . equals ( "" ) ) { result . add ( item ) ; } } return result ; } public String toString ( ) { return ( "Permission: " + className + " (\"" + name + "\", \"" + actions + "\")" ) ; } } } 	0	['12', '1', '0', '8', '34', '26', '6', '3', '6', '0.651515152', '341', '1', '0', '0', '0.3125', '0', '0', '26.91666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . ReflectWrapper ; import org . apache . tools . ant . util . StringUtils ; public class HasFreeSpace implements Condition { private String partition ; private String needed ; public boolean eval ( ) throws BuildException { validate ( ) ; try { if ( JavaEnvUtils . isAtLeastJavaVersion ( "1.6" ) ) { File fs = new File ( partition ) ; ReflectWrapper w = new ReflectWrapper ( fs ) ; long free = ( ( Long ) w . invoke ( "getFreeSpace" ) ) . longValue ( ) ; return free >= StringUtils . parseHumanSizes ( needed ) ; } else { throw new BuildException ( "HasFreeSpace condition not supported on Java5 or less." ) ; } } catch ( Exception e ) { throw new BuildException ( e ) ; } } private void validate ( ) throws BuildException { if ( null == partition ) { throw new BuildException ( "Please set the partition attribute." ) ; } if ( null == needed ) { throw new BuildException ( "Please set the needed attribute." ) ; } } public String getPartition ( ) { return partition ; } public void setPartition ( String partition ) { this . partition = partition ; } public String getNeeded ( ) { return needed ; } public void setNeeded ( String needed ) { this . needed = needed ; } } 	0	['7', '1', '0', '5', '16', '0', '0', '5', '6', '0.5', '86', '1', '0', '0', '0.642857143', '0', '0', '11', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . email ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . PrintStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . UUEncoder ; class UUMailer extends PlainMailer { protected void attach ( File file , PrintStream out ) throws IOException { if ( ! file . exists ( ) || ! file . canRead ( ) ) { throw new BuildException ( "File \"" + file . getName ( ) + "\" does not exist or is not " + "readable." ) ; } FileInputStream finstr = new FileInputStream ( file ) ; try { BufferedInputStream in = new BufferedInputStream ( finstr ) ; UUEncoder encoder = new UUEncoder ( file . getName ( ) ) ; encoder . encode ( in , out ) ; } finally { finstr . close ( ) ; } } } 	0	['2', '3', '0', '3', '15', '1', '0', '3', '0', '2', '58', '0', '0', '0.952380952', '0.666666667', '1', '1', '28', '1', '0.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public interface ResourceSelector { boolean isSelected ( Resource r ) ; } 	0	['1', '1', '0', '26', '1', '0', '25', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Constructor ; public class AntTypeDefinition { private String name ; private Class clazz ; private Class adapterClass ; private Class adaptToClass ; private String className ; private ClassLoader classLoader ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setClass ( Class clazz ) { this . clazz = clazz ; if ( clazz == null ) { return ; } this . classLoader = ( classLoader == null ) ? clazz . getClassLoader ( ) : classLoader ; this . className = ( className == null ) ? clazz . getName ( ) : className ; } public void setClassName ( String className ) { this . className = className ; } public String getClassName ( ) { return className ; } public void setAdapterClass ( Class adapterClass ) { this . adapterClass = adapterClass ; } public void setAdaptToClass ( Class adaptToClass ) { this . adaptToClass = adaptToClass ; } public void setClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } public ClassLoader getClassLoader ( ) { return classLoader ; } public Class getExposedClass ( Project project ) { if ( adaptToClass != null ) { Class z = getTypeClass ( project ) ; if ( z == null || adaptToClass . isAssignableFrom ( z ) ) { return z ; } } return ( adapterClass == null ) ? getTypeClass ( project ) : adapterClass ; } public Class getTypeClass ( Project project ) { try { return innerGetTypeClass ( ) ; } catch ( NoClassDefFoundError ncdfe ) { project . log ( "Could not load a dependent class (" + ncdfe . getMessage ( ) + ") for type " + name , Project . MSG_DEBUG ) ; } catch ( ClassNotFoundException cnfe ) { project . log ( "Could not load class (" + className + ") for type " + name , Project . MSG_DEBUG ) ; } return null ; } public Class innerGetTypeClass ( ) throws ClassNotFoundException { if ( clazz != null ) { return clazz ; } if ( classLoader == null ) { clazz = Class . forName ( className ) ; } else { clazz = classLoader . loadClass ( className ) ; } return clazz ; } public Object create ( Project project ) { return icreate ( project ) ; } private Object icreate ( Project project ) { Class c = getTypeClass ( project ) ; if ( c == null ) { return null ; } Object o = createAndSet ( project , c ) ; if ( o == null || adapterClass == null ) { return o ; } if ( adaptToClass != null ) { if ( adaptToClass . isAssignableFrom ( o . getClass ( ) ) ) { return o ; } } TypeAdapter adapterObject = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapterObject == null ) { return null ; } adapterObject . setProxy ( o ) ; return adapterObject ; } public void checkClass ( Project project ) { if ( clazz == null ) { clazz = getTypeClass ( project ) ; if ( clazz == null ) { throw new BuildException ( "Unable to create class for " + getName ( ) ) ; } } if ( adapterClass != null && ( adaptToClass == null || ! adaptToClass . isAssignableFrom ( clazz ) ) ) { TypeAdapter adapter = ( TypeAdapter ) createAndSet ( project , adapterClass ) ; if ( adapter == null ) { throw new BuildException ( "Unable to create adapter object" ) ; } adapter . checkProxyClass ( clazz ) ; } } private Object createAndSet ( Project project , Class c ) { try { Object o = innerCreateAndSet ( c , project ) ; return o ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } catch ( NoClassDefFoundError ncdfe ) { String msg = "Type " + name + ": A class needed by class " + c + " cannot be found: " + ncdfe . getMessage ( ) ; throw new BuildException ( msg , ncdfe ) ; } catch ( NoSuchMethodException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " has no compatible constructor" ) ; } catch ( InstantiationException nsme ) { throw new BuildException ( "Could not create type " + name + " as the class " + c + " is abstract" ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not create type " + name + " as the constructor " + c + " is not accessible" ) ; } catch ( Throwable t ) { throw new BuildException ( "Could not create type " + name + " due to " + t , t ) ; } } public Object innerCreateAndSet ( Class newclass , Project project ) throws NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { Constructor ctor = null ; boolean noArg = false ; try { ctor = newclass . getConstructor ( new Class [ 0 ] ) ; noArg = true ; } catch ( NoSuchMethodException nse ) { ctor = newclass . getConstructor ( new Class [ ] { Project . class } ) ; noArg = false ; } Object o = ctor . newInstance ( ( ( noArg ) ? new Object [ 0 ] : new Object [ ] { project } ) ) ; project . setProjectReference ( o ) ; return o ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) == getClass ( ) && other . getTypeClass ( project ) . equals ( getTypeClass ( project ) ) && other . getExposedClass ( project ) . equals ( getExposedClass ( project ) ) && other . adapterClass == adapterClass && other . adaptToClass == adaptToClass ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { if ( other == null || getClass ( ) != other . getClass ( ) || ! getClassName ( ) . equals ( other . getClassName ( ) ) || ! extractClassname ( adapterClass ) . equals ( extractClassname ( other . adapterClass ) ) || ! extractClassname ( adaptToClass ) . equals ( extractClassname ( other . adaptToClass ) ) ) { return false ; } ClassLoader oldLoader = other . getClassLoader ( ) ; ClassLoader newLoader = getClassLoader ( ) ; return oldLoader == newLoader || ( oldLoader instanceof AntClassLoader && newLoader instanceof AntClassLoader && ( ( AntClassLoader ) oldLoader ) . getClasspath ( ) . equals ( ( ( AntClassLoader ) newLoader ) . getClasspath ( ) ) ) ; } private String extractClassname ( Class c ) { return ( c == null ) ? "<null>" : c . getClass ( ) . getName ( ) ; } } 	0	['21', '1', '2', '14', '47', '124', '10', '4', '18', '0.7', '575', '0.857142857', '0', '0', '0.325396825', '0', '0', '26.04761905', '10', '2.619', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; public class AntlibDefinition extends Task { private String uri = "" ; private ClassLoader antlibClassLoader ; public void setURI ( String uri ) throws BuildException { if ( uri . equals ( ProjectHelper . ANT_CORE_URI ) ) { uri = "" ; } if ( uri . startsWith ( "ant:" ) ) { throw new BuildException ( "Attempt to use a reserved URI " + uri ) ; } this . uri = uri ; } public String getURI ( ) { return uri ; } public void setAntlibClassLoader ( ClassLoader classLoader ) { this . antlibClassLoader = classLoader ; } public ClassLoader getAntlibClassLoader ( ) { return antlibClassLoader ; } } 	0	['5', '3', '3', '6', '12', '2', '4', '2', '5', '0.625', '48', '1', '0', '0.902439024', '0.466666667', '0', '0', '8.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; public class WebLogicHotDeploymentTool extends AbstractHotDeploymentTool implements HotDeploymentTool { private static final String WEBLOGIC_DEPLOY_CLASS_NAME = "weblogic.deploy" ; private static final String [ ] VALID_ACTIONS = { ACTION_DELETE , ACTION_DEPLOY , ACTION_LIST , ACTION_UNDEPLOY , ACTION_UPDATE } ; private boolean debug ; private String application ; private String component ; public void deploy ( ) { Java java = new Java ( getTask ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . setClasspath ( getClasspath ( ) ) ; java . setClassname ( WEBLOGIC_DEPLOY_CLASS_NAME ) ; java . createArg ( ) . setLine ( getArguments ( ) ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; String action = getTask ( ) . getAction ( ) ; if ( ( getPassword ( ) == null ) ) { throw new BuildException ( "The password attribute must be set." ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && application == null ) { throw new BuildException ( "The application attribute must be set " + "if action = " + action ) ; } if ( ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) && getTask ( ) . getSource ( ) == null ) { throw new BuildException ( "The source attribute must be set if " + "action = " + action ) ; } if ( ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) && application == null ) { throw new BuildException ( "The application attribute must be set if " + "action = " + action ) ; } } public String getArguments ( ) throws BuildException { String action = getTask ( ) . getAction ( ) ; String args = null ; if ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) ) { args = buildDeployArgs ( ) ; } else if ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) { args = buildUndeployArgs ( ) ; } else if ( action . equals ( ACTION_LIST ) ) { args = buildListArgs ( ) ; } return args ; } protected boolean isActionValid ( ) { boolean valid = false ; String action = getTask ( ) . getAction ( ) ; for ( int i = 0 ; i < VALID_ACTIONS . length ; i ++ ) { if ( action . equals ( VALID_ACTIONS [ i ] ) ) { valid = true ; break ; } } return valid ; } protected StringBuffer buildArgsPrefix ( ) { ServerDeploy task = getTask ( ) ; return new StringBuffer ( 1024 ) . append ( ( getServer ( ) != null ) ? "-url " + getServer ( ) : "" ) . append ( " " ) . append ( debug ? "-debug " : "" ) . append ( ( getUserName ( ) != null ) ? "-username " + getUserName ( ) : "" ) . append ( " " ) . append ( task . getAction ( ) ) . append ( " " ) . append ( getPassword ( ) ) . append ( " " ) ; } protected String buildDeployArgs ( ) { String args = buildArgsPrefix ( ) . append ( application ) . append ( " " ) . append ( getTask ( ) . getSource ( ) ) . toString ( ) ; if ( component != null ) { args = "-component " + component + " " + args ; } return args ; } protected String buildUndeployArgs ( ) { return buildArgsPrefix ( ) . append ( application ) . append ( " " ) . toString ( ) ; } protected String buildListArgs ( ) { return buildArgsPrefix ( ) . toString ( ) ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setApplication ( String application ) { this . application = application ; } public void setComponent ( String component ) { this . component = component ; } } 	0	['13', '2', '0', '8', '37', '60', '1', '8', '7', '0.833333333', '331', '1', '0', '0.56', '0.416666667', '2', '3', '24.07692308', '4', '1.3077', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSLABEL extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { throw new BuildException ( "vsspath attribute must be set!" , getLocation ( ) ) ; } String label = getLabel ( ) ; if ( label . equals ( "" ) ) { String msg = "label attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LABEL ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( label ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['6', '4', '0', '5', '25', '15', '0', '5', '5', '2', '94', '0', '0', '0.947916667', '0.833333333', '1', '1', '14.66666667', '3', '1.1667', '0']
package org . apache . tools . ant . types . selectors ; import org . apache . tools . ant . types . Parameterizable ; public interface ExtendFileSelector extends FileSelector , Parameterizable { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Change extends P4Base { protected String emptyChangeList = null ; protected String description = "AutoSubmit By Ant" ; public void execute ( ) throws BuildException { if ( emptyChangeList == null ) { emptyChangeList = getEmptyChangeList ( ) ; } final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { if ( util . match ( "/Change/" , line ) ) { line = util . substitute ( "s/[^0-9]//g" , line ) ; int changenumber = Integer . parseInt ( line ) ; log ( "Change Number is " + changenumber , Project . MSG_INFO ) ; myProj . setProperty ( "p4.change" , "" + changenumber ) ; } else if ( util . match ( "/error/" , line ) ) { throw new BuildException ( "Perforce Error, check client settings and/or server" ) ; } } } ; handler . setOutput ( emptyChangeList ) ; execP4Command ( "change -i" , handler ) ; } public String getEmptyChangeList ( ) throws BuildException { final StringBuffer stringbuf = new StringBuffer ( ) ; execP4Command ( "change -o" , new P4HandlerAdapter ( ) { public void process ( String line ) { if ( ! util . match ( "/^#/" , line ) ) { if ( util . match ( "/error/" , line ) ) { log ( "Client Error" , Project . MSG_VERBOSE ) ; throw new BuildException ( "Perforce Error, " + "check client settings and/or server" ) ; } else if ( util . match ( "/<enter description here>/" , line ) ) { description = backslash ( description ) ; line = util . substitute ( "s/<enter description here>/" + description + "/" , line ) ; } else if ( util . match ( "/\\/\\//" , line ) ) { return ; } stringbuf . append ( line ) ; stringbuf . append ( "\n" ) ; } } } ) ; return stringbuf . toString ( ) ; } public static final String backslash ( String value ) { final StringBuffer buf = new StringBuffer ( value . length ( ) ) ; final int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == '/' ) { buf . append ( '\\' ) ; } buf . append ( c ) ; } return buf . toString ( ) ; } public void setDescription ( String desc ) { this . description = desc ; } } 	0	['5', '4', '0', '6', '17', '6', '2', '6', '5', '0.75', '94', '1', '0', '0.927272727', '0.6', '2', '2', '17.4', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . launch . Locator ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class SunJavah implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "sun" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupJavahCommand ( javah ) ; ExecuteJava ej = new ExecuteJava ( ) ; Class c = null ; try { try { c = Class . forName ( "com.sun.tools.javah.oldjavah.Main" ) ; } catch ( ClassNotFoundException cnfe ) { c = Class . forName ( "com.sun.tools.javah.Main" ) ; } } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Can't load javah" , ex , javah . getLocation ( ) ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; File f = Locator . getClassSource ( c ) ; if ( f != null ) { ej . setClasspath ( new Path ( javah . getProject ( ) , f . getPath ( ) ) ) ; } return ej . fork ( javah ) == 0 ; } private Commandline setupJavahCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } if ( javah . getClasspath ( ) != null ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( javah . getClasspath ( ) ) ; } if ( javah . getVerbose ( ) ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-old" ) ; } if ( javah . getForce ( ) ) { cmd . createArgument ( ) . setValue ( "-force" ) ; } if ( javah . getStubs ( ) && ! javah . getOld ( ) ) { throw new BuildException ( "stubs only available in old mode." , javah . getLocation ( ) ) ; } if ( javah . getStubs ( ) ) { cmd . createArgument ( ) . setValue ( "-stubs" ) ; } Path bcp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { bcp . append ( javah . getBootclasspath ( ) ) ; } bcp = bcp . concatSystemBootClasspath ( "ignore" ) ; if ( bcp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( bcp ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0	['3', '1', '0', '12', '38', '3', '1', '11', '2', '1.5', '182', '0', '0', '0', '0.833333333', '0', '0', '59.33333333', '12', '4.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import java . util . Enumeration ; import java . util . LinkedList ; import java . util . List ; import java . util . ListIterator ; import java . util . Properties ; import java . util . Vector ; public class CommandlineJava implements Cloneable { private Commandline vmCommand = new Commandline ( ) ; private Commandline javaCommand = new Commandline ( ) ; private SysProperties sysProperties = new SysProperties ( ) ; private Path classpath = null ; private Path bootclasspath = null ; private String vmVersion ; private String maxMemory = null ; private Assertions assertions = null ; private boolean executeJar = false ; private boolean cloneVm = false ; public static class SysProperties extends Environment implements Cloneable { Properties sys = null ; private Vector propertySets = new Vector ( ) ; public String [ ] getVariables ( ) throws BuildException { List definitions = new LinkedList ( ) ; ListIterator list = definitions . listIterator ( ) ; addDefinitionsToList ( list ) ; if ( definitions . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) definitions . toArray ( new String [ definitions . size ( ) ] ) ; } } public void addDefinitionsToList ( ListIterator listIt ) { String [ ] props = super . getVariables ( ) ; if ( props != null ) { for ( int i = 0 ; i < props . length ; i ++ ) { listIt . add ( "-D" + props [ i ] ) ; } } Properties propertySetProperties = mergePropertySets ( ) ; for ( Enumeration e = propertySetProperties . keys ( ) ; e . hasMoreElements ( ) ; ) { String key = ( String ) e . nextElement ( ) ; String value = propertySetProperties . getProperty ( key ) ; listIt . add ( "-D" + key + "=" + value ) ; } } public int size ( ) { Properties p = mergePropertySets ( ) ; return variables . size ( ) + p . size ( ) ; } public void setSystem ( ) throws BuildException { try { sys = System . getProperties ( ) ; Properties p = new Properties ( ) ; for ( Enumeration e = sys . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; p . put ( name , sys . getProperty ( name ) ) ; } p . putAll ( mergePropertySets ( ) ) ; for ( Enumeration e = variables . elements ( ) ; e . hasMoreElements ( ) ; ) { Environment . Variable v = ( Environment . Variable ) e . nextElement ( ) ; v . validate ( ) ; p . put ( v . getKey ( ) , v . getValue ( ) ) ; } System . setProperties ( p ) ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public void restoreSystem ( ) throws BuildException { if ( sys == null ) { throw new BuildException ( "Unbalanced nesting of SysProperties" ) ; } try { System . setProperties ( sys ) ; sys = null ; } catch ( SecurityException e ) { throw new BuildException ( "Cannot modify system properties" , e ) ; } } public Object clone ( ) throws CloneNotSupportedException { try { SysProperties c = ( SysProperties ) super . clone ( ) ; c . variables = ( Vector ) variables . clone ( ) ; c . propertySets = ( Vector ) propertySets . clone ( ) ; return c ; } catch ( CloneNotSupportedException e ) { return null ; } } public void addSyspropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void addSysproperties ( SysProperties ps ) { variables . addAll ( ps . variables ) ; propertySets . addAll ( ps . propertySets ) ; } private Properties mergePropertySets ( ) { Properties p = new Properties ( ) ; for ( Enumeration e = propertySets . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; p . putAll ( ps . getProperties ( ) ) ; } return p ; } } public CommandlineJava ( ) { setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; setVmversion ( JavaEnvUtils . getJavaVersion ( ) ) ; } public Commandline . Argument createArgument ( ) { return javaCommand . createArgument ( ) ; } public Commandline . Argument createVmArgument ( ) { return vmCommand . createArgument ( ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public void addSyspropertyset ( PropertySet sysp ) { sysProperties . addSyspropertyset ( sysp ) ; } public void addSysproperties ( SysProperties sysp ) { sysProperties . addSysproperties ( sysp ) ; } public void setVm ( String vm ) { vmCommand . setExecutable ( vm ) ; } public void setVmversion ( String value ) { vmVersion = value ; } public void setCloneVm ( boolean cloneVm ) { this . cloneVm = cloneVm ; } public Assertions getAssertions ( ) { return assertions ; } public void setAssertions ( Assertions assertions ) { this . assertions = assertions ; } public void setJar ( String jarpathname ) { javaCommand . setExecutable ( jarpathname ) ; executeJar = true ; } public String getJar ( ) { if ( executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public void setClassname ( String classname ) { javaCommand . setExecutable ( classname ) ; executeJar = false ; } public String getClassname ( ) { if ( ! executeJar ) { return javaCommand . getExecutable ( ) ; } return null ; } public Path createClasspath ( Project p ) { if ( classpath == null ) { classpath = new Path ( p ) ; } return classpath ; } public Path createBootclasspath ( Project p ) { if ( bootclasspath == null ) { bootclasspath = new Path ( p ) ; } return bootclasspath ; } public String getVmversion ( ) { return vmVersion ; } public String [ ] getCommandline ( ) { List commands = new LinkedList ( ) ; final ListIterator listIterator = commands . listIterator ( ) ; addCommandsToList ( listIterator ) ; return ( String [ ] ) commands . toArray ( new String [ commands . size ( ) ] ) ; } private void addCommandsToList ( final ListIterator listIterator ) { getActualVMCommand ( ) . addCommandToList ( listIterator ) ; sysProperties . addDefinitionsToList ( listIterator ) ; if ( isCloneVm ( ) ) { SysProperties clonedSysProperties = new SysProperties ( ) ; PropertySet ps = new PropertySet ( ) ; PropertySet . BuiltinPropertySetName sys = new PropertySet . BuiltinPropertySetName ( ) ; sys . setValue ( "system" ) ; ps . appendBuiltin ( sys ) ; clonedSysProperties . addSyspropertyset ( ps ) ; clonedSysProperties . addDefinitionsToList ( listIterator ) ; } Path bcp = calculateBootclasspath ( true ) ; if ( bcp . size ( ) > 0 ) { listIterator . add ( "-Xbootclasspath:" + bcp . toString ( ) ) ; } if ( haveClasspath ( ) ) { listIterator . add ( "-classpath" ) ; listIterator . add ( classpath . concatSystemClasspath ( "ignore" ) . toString ( ) ) ; } if ( getAssertions ( ) != null ) { getAssertions ( ) . applyAssertions ( listIterator ) ; } if ( executeJar ) { listIterator . add ( "-jar" ) ; } javaCommand . addCommandToList ( listIterator ) ; } public void setMaxmemory ( String max ) { this . maxMemory = max ; } public String toString ( ) { return Commandline . toString ( getCommandline ( ) ) ; } public String describeCommand ( ) { return Commandline . describeCommand ( getCommandline ( ) ) ; } public String describeJavaCommand ( ) { return Commandline . describeCommand ( getJavaCommand ( ) ) ; } protected Commandline getActualVMCommand ( ) { Commandline actualVMCommand = ( Commandline ) vmCommand . clone ( ) ; if ( maxMemory != null ) { if ( vmVersion . startsWith ( "1.1" ) ) { actualVMCommand . createArgument ( ) . setValue ( "-mx" + maxMemory ) ; } else { actualVMCommand . createArgument ( ) . setValue ( "-Xmx" + maxMemory ) ; } } return actualVMCommand ; } public int size ( ) { int size = getActualVMCommand ( ) . size ( ) + javaCommand . size ( ) + sysProperties . size ( ) ; if ( isCloneVm ( ) ) { size += System . getProperties ( ) . size ( ) ; } if ( haveClasspath ( ) ) { size += 2 ; } if ( calculateBootclasspath ( true ) . size ( ) > 0 ) { size ++ ; } if ( executeJar ) { size ++ ; } if ( getAssertions ( ) != null ) { size += getAssertions ( ) . size ( ) ; } return size ; } public Commandline getJavaCommand ( ) { return javaCommand ; } public Commandline getVmCommand ( ) { return getActualVMCommand ( ) ; } public Path getClasspath ( ) { return classpath ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setSystemProperties ( ) throws BuildException { sysProperties . setSystem ( ) ; } public void restoreSystemProperties ( ) throws BuildException { sysProperties . restoreSystem ( ) ; } public SysProperties getSystemProperties ( ) { return sysProperties ; } public Object clone ( ) throws CloneNotSupportedException { try { CommandlineJava c = ( CommandlineJava ) super . clone ( ) ; c . vmCommand = ( Commandline ) vmCommand . clone ( ) ; c . javaCommand = ( Commandline ) javaCommand . clone ( ) ; c . sysProperties = ( SysProperties ) sysProperties . clone ( ) ; if ( classpath != null ) { c . classpath = ( Path ) classpath . clone ( ) ; } if ( bootclasspath != null ) { c . bootclasspath = ( Path ) bootclasspath . clone ( ) ; } if ( assertions != null ) { c . assertions = ( Assertions ) assertions . clone ( ) ; } return c ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } public void clearJavaArgs ( ) { javaCommand . clearArgs ( ) ; } protected boolean haveClasspath ( ) { Path fullClasspath = classpath != null ? classpath . concatSystemClasspath ( "ignore" ) : null ; return fullClasspath != null && fullClasspath . toString ( ) . trim ( ) . length ( ) > 0 ; } protected boolean haveBootclasspath ( boolean log ) { return calculateBootclasspath ( log ) . size ( ) > 0 ; } private Path calculateBootclasspath ( boolean log ) { if ( vmVersion . startsWith ( "1.1" ) ) { if ( bootclasspath != null && log ) { bootclasspath . log ( "Ignoring bootclasspath as " + "the target VM doesn't support it." ) ; } } else { if ( bootclasspath != null ) { return bootclasspath . concatSystemBootClasspath ( isCloneVm ( ) ? "last" : "ignore" ) ; } else if ( isCloneVm ( ) ) { return Path . systemBootClasspath ; } } return new Path ( null ) ; } private boolean isCloneVm ( ) { return cloneVm || "true" . equals ( System . getProperty ( "ant.build.clonevm" ) ) ; } } 	0	['39', '1', '0', '21', '94', '461', '11', '11', '33', '0.786842105', '559', '1', '6', '0', '0.153846154', '0', '0', '13.07692308', '7', '1.6923', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; public final class ClassConstants extends BaseFilterReader implements ChainableReader { private String queuedData = null ; private static final String JAVA_CLASS_HELPER = "org.apache.tools.ant.filters.util.JavaClassHelper" ; public ClassConstants ( ) { super ( ) ; } public ClassConstants ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { final String clazz = readFully ( ) ; if ( clazz == null ) { ch = - 1 ; } else { final byte [ ] bytes = clazz . getBytes ( "ISO-8859-1" ) ; try { final Class javaClassHelper = Class . forName ( JAVA_CLASS_HELPER ) ; if ( javaClassHelper != null ) { final Class [ ] params = { byte [ ] . class } ; final Method getConstants = javaClassHelper . getMethod ( "getConstants" , params ) ; final Object [ ] args = { bytes } ; final StringBuffer sb = ( StringBuffer ) getConstants . invoke ( null , args ) ; if ( sb . length ( ) > 0 ) { queuedData = sb . toString ( ) ; return read ( ) ; } } } catch ( NoClassDefFoundError ex ) { throw ex ; } catch ( RuntimeException ex ) { throw ex ; } catch ( InvocationTargetException ex ) { Throwable t = ex . getTargetException ( ) ; if ( t instanceof NoClassDefFoundError ) { throw ( NoClassDefFoundError ) t ; } if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } throw new BuildException ( t ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } return ch ; } public Reader chain ( final Reader rdr ) { ClassConstants newFilter = new ClassConstants ( rdr ) ; return newFilter ; } } 	0	['4', '4', '0', '4', '20', '0', '1', '3', '4', '0.777777778', '162', '0.666666667', '0', '0.928571429', '0.75', '2', '4', '38.75', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCLock extends ClearCase { private boolean mReplace = false ; private boolean mObsolete = false ; private String mComment = null ; private String mNusers = null ; private String mPname = null ; private String mObjselect = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_LOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getObsolete ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OBSOLETE ) ; } else { getNusersCommand ( cmd ) ; } getCommentCommand ( cmd ) ; if ( getObjselect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjselect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjselect ( ) ) ; } } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setObsolete ( boolean obsolete ) { mObsolete = obsolete ; } public boolean getObsolete ( ) { return mObsolete ; } public void setNusers ( String nusers ) { mNusers = nusers ; } public String getNusers ( ) { return mNusers ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjSel ( String objsel ) { mObjselect = objsel ; } public void setObjselect ( String objselect ) { mObjselect = objselect ; } public String getObjselect ( ) { return mObjselect ; } private void getNusersCommand ( Commandline cmd ) { if ( getNusers ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_NUSERS ) ; cmd . createArgument ( ) . setValue ( getNusers ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjselect ( ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_NUSERS = "-nusers" ; public static final String FLAG_OBSOLETE = "-obsolete" ; public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0	['20', '4', '0', '7', '42', '148', '0', '7', '15', '0.918660287', '263', '0.545454545', '0', '0.71641791', '0.3875', '2', '3', '11.6', '6', '1.4', '0']
package org . apache . tools . ant . taskdefs ; public class Cvs extends AbstractCvsTask { public Cvs ( ) { } } 	0	['1', '4', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class Reference { private String refid ; private Project project ; public Reference ( ) { } public Reference ( String id ) { setRefId ( id ) ; } public Reference ( Project p , String id ) { setRefId ( id ) ; setProject ( p ) ; } public void setRefId ( String id ) { refid = id ; } public String getRefId ( ) { return refid ; } public void setProject ( Project p ) { this . project = p ; } public Project getProject ( ) { return project ; } public Object getReferencedObject ( Project fallback ) throws BuildException { if ( refid == null ) { throw new BuildException ( "No reference specified" ) ; } Object o = project == null ? fallback . getReference ( refid ) : project . getReference ( refid ) ; if ( o == null ) { throw new BuildException ( "Reference " + refid + " not found." ) ; } return o ; } public Object getReferencedObject ( ) throws BuildException { if ( project == null ) { throw new BuildException ( "No project set on reference to " + refid ) ; } return getReferencedObject ( project ) ; } } 	0	['9', '1', '1', '63', '15', '14', '61', '2', '9', '0.4375', '103', '1', '1', '0', '0.555555556', '0', '0', '10.22222222', '1', '0.6667', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; public final class LineContains extends BaseParamFilterReader implements ChainableReader { private static final String CONTAINS_KEY = "contains" ; private static final String NEGATE_KEY = "negate" ; private Vector contains = new Vector ( ) ; private String line = null ; private boolean negate = false ; public LineContains ( ) { super ( ) ; } public LineContains ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { final int containsSize = contains . size ( ) ; for ( line = readLine ( ) ; line != null ; line = readLine ( ) ) { boolean matches = true ; for ( int i = 0 ; matches && i < containsSize ; i ++ ) { String containsStr = ( String ) contains . elementAt ( i ) ; matches = line . indexOf ( containsStr ) >= 0 ; } if ( matches ^ isNegated ( ) ) { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredContains ( final Contains contains ) { this . contains . addElement ( contains . getValue ( ) ) ; } public void setNegate ( boolean b ) { negate = b ; } public boolean isNegated ( ) { return negate ; } private void setContains ( final Vector contains ) { this . contains = contains ; } private Vector getContains ( ) { return contains ; } public Reader chain ( final Reader rdr ) { LineContains newFilter = new LineContains ( rdr ) ; newFilter . setContains ( getContains ( ) ) ; newFilter . setNegate ( isNegated ( ) ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( CONTAINS_KEY . equals ( params [ i ] . getType ( ) ) ) { contains . addElement ( params [ i ] . getValue ( ) ) ; } else if ( NEGATE_KEY . equals ( params [ i ] . getType ( ) ) ) { setNegate ( Project . toBoolean ( params [ i ] . getValue ( ) ) ) ; } } } } public static class Contains { private String value ; public final void setValue ( String contains ) { value = contains ; } public final String getValue ( ) { return value ; } } } 	0	['10', '5', '0', '6', '29', '0', '1', '5', '7', '0.688888889', '212', '1', '0', '0.777777778', '0.3', '2', '5', '19.7', '5', '1.2', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Parameter ; public class TypeSelector extends BaseExtendSelector { private String type = null ; public static final String TYPE_KEY = "type" ; public TypeSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{typeselector type: " ) ; buf . append ( type ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setType ( FileType fileTypes ) { this . type = fileTypes . getValue ( ) ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( TYPE_KEY . equalsIgnoreCase ( paramname ) ) { FileType t = new FileType ( ) ; t . setValue ( parameters [ i ] . getValue ( ) ) ; setType ( t ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( type == null ) { setError ( "The type attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( file . isDirectory ( ) ) { return type . equals ( FileType . DIR ) ; } else { return type . equals ( FileType . FILE ) ; } } public static class FileType extends EnumeratedAttribute { public static final String FILE = "file" ; public static final String DIR = "dir" ; public String [ ] getValues ( ) { return new String [ ] { FILE , DIR } ; } } } 	0	['6', '5', '0', '8', '21', '0', '5', '3', '6', '0.6', '104', '0.5', '0', '0.88372093', '0.333333333', '2', '5', '16', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Sleep extends Task { private boolean failOnError = true ; private int seconds = 0 ; private int hours = 0 ; private int minutes = 0 ; private int milliseconds = 0 ; public Sleep ( ) { } public void setSeconds ( int seconds ) { this . seconds = seconds ; } public void setHours ( int hours ) { this . hours = hours ; } public void setMinutes ( int minutes ) { this . minutes = minutes ; } public void setMilliseconds ( int milliseconds ) { this . milliseconds = milliseconds ; } public void doSleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException ie ) { } } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } private long getSleepTime ( ) { return ( ( ( ( long ) hours * 60 ) + minutes ) * 60 + seconds ) * 1000 + milliseconds ; } public void validate ( ) throws BuildException { if ( getSleepTime ( ) < 0 ) { throw new BuildException ( "Negative sleep periods are not " + "supported" ) ; } } public void execute ( ) throws BuildException { try { validate ( ) ; long sleepTime = getSleepTime ( ) ; log ( "sleeping for " + sleepTime + " milliseconds" , Project . MSG_VERBOSE ) ; doSleep ( sleepTime ) ; } catch ( Exception e ) { if ( failOnError ) { throw new BuildException ( e ) ; } else { String text = e . toString ( ) ; log ( text , Project . MSG_ERR ) ; } } } } 	0	['10', '3', '0', '2', '20', '21', '0', '2', '9', '0.6', '129', '1', '0', '0.804347826', '0.4', '1', '1', '11.4', '1', '0.9', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . util . Comparator ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; public abstract class ResourceComparator extends DataType implements Comparator { public final int compare ( Object foo , Object bar ) { dieOnCircularReference ( ) ; ResourceComparator c = isReference ( ) ? ( ResourceComparator ) getCheckedRef ( ) : this ; return c . resourceCompare ( ( Resource ) foo , ( Resource ) bar ) ; } public boolean equals ( Object o ) { if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( o ) ; } if ( o == null ) { return false ; } return o == this || o . getClass ( ) . equals ( getClass ( ) ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return getClass ( ) . hashCode ( ) ; } protected abstract int resourceCompare ( Resource foo , Resource bar ) ; } 	0	['5', '3', '9', '18', '12', '10', '16', '2', '4', '2', '62', '0', '0', '0.882352941', '0.533333333', '1', '1', '11.4', '5', '2', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Type extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { boolean f = foo . isDirectory ( ) ; if ( f == bar . isDirectory ( ) ) { return 0 ; } return f ? 1 : - 1 ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '20', '0', '0', '0.971428571', '0.75', '1', '1', '9', '3', '1.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class TabsToSpaces extends BaseParamFilterReader implements ChainableReader { private static final int DEFAULT_TAB_LENGTH = 8 ; private static final String TAB_LENGTH_KEY = "tablength" ; private int tabLength = DEFAULT_TAB_LENGTH ; private int spacesRemaining = 0 ; public TabsToSpaces ( ) { super ( ) ; } public TabsToSpaces ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( spacesRemaining > 0 ) { spacesRemaining -- ; ch = ' ' ; } else { ch = in . read ( ) ; if ( ch == '\t' ) { spacesRemaining = tabLength - 1 ; ch = ' ' ; } } return ch ; } public void setTablength ( final int tabLength ) { this . tabLength = tabLength ; } private int getTablength ( ) { return tabLength ; } public Reader chain ( final Reader rdr ) { TabsToSpaces newFilter = new TabsToSpaces ( rdr ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( params [ i ] != null ) { if ( TAB_LENGTH_KEY . equals ( params [ i ] . getName ( ) ) ) { tabLength = new Integer ( params [ i ] . getValue ( ) ) . intValue ( ) ; break ; } } } } } } 	0	['7', '5', '0', '4', '18', '0', '1', '3', '5', '0.708333333', '126', '1', '0', '0.848484848', '0.476190476', '2', '5', '16.42857143', '5', '1.2857', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jikes extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jikes compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; Path sourcepath = null ; if ( compileSourcepath != null ) { sourcepath = compileSourcepath ; } else { sourcepath = src ; } if ( sourcepath . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-sourcepath" ) ; cmd . createArgument ( ) . setPath ( sourcepath ) ; } Path classpath = new Path ( project ) ; if ( bootclasspath == null || bootclasspath . size ( ) == 0 ) { includeJavaRuntime = true ; } else { } classpath . append ( getCompileClasspath ( ) ) ; String jikesPath = System . getProperty ( "jikes.class.path" ) ; if ( jikesPath != null ) { classpath . append ( new Path ( project , jikesPath ) ) ; } if ( extdirs != null && extdirs . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-extdirs" ) ; cmd . createArgument ( ) . setPath ( extdirs ) ; } String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jikes" : exec ) ; if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { String debugLevel = attributes . getDebugLevel ( ) ; if ( debugLevel != null ) { cmd . createArgument ( ) . setValue ( "-g:" + debugLevel ) ; } else { cmd . createArgument ( ) . setValue ( "-g" ) ; } } else { cmd . createArgument ( ) . setValue ( "-g:none" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } if ( depend ) { cmd . createArgument ( ) . setValue ( "-depend" ) ; } if ( target != null ) { cmd . createArgument ( ) . setValue ( "-target" ) ; cmd . createArgument ( ) . setValue ( target ) ; } String emacsProperty = project . getProperty ( "build.compiler.emacs" ) ; if ( emacsProperty != null && Project . toBoolean ( emacsProperty ) ) { cmd . createArgument ( ) . setValue ( "+E" ) ; } String warningsProperty = project . getProperty ( "build.compiler.warnings" ) ; if ( warningsProperty != null ) { attributes . log ( "!! the build.compiler.warnings property is " + "deprecated. !!" , Project . MSG_WARN ) ; attributes . log ( "!! Use the nowarn attribute instead. !!" , Project . MSG_WARN ) ; if ( ! Project . toBoolean ( warningsProperty ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } } if ( attributes . getNowarn ( ) ) { cmd . createArgument ( ) . setValue ( "-nowarn" ) ; } String pedanticProperty = project . getProperty ( "build.compiler.pedantic" ) ; if ( pedanticProperty != null && Project . toBoolean ( pedanticProperty ) ) { cmd . createArgument ( ) . setValue ( "+P" ) ; } String fullDependProperty = project . getProperty ( "build.compiler.fulldepend" ) ; if ( fullDependProperty != null && Project . toBoolean ( fullDependProperty ) ) { cmd . createArgument ( ) . setValue ( "+F" ) ; } if ( attributes . getSource ( ) != null ) { cmd . createArgument ( ) . setValue ( "-source" ) ; String source = attributes . getSource ( ) ; if ( source . equals ( "1.1" ) || source . equals ( "1.2" ) ) { attributes . log ( "Jikes doesn't support '-source " + source + "', will use '-source 1.3' instead" ) ; cmd . createArgument ( ) . setValue ( "1.3" ) ; } else { cmd . createArgument ( ) . setValue ( source ) ; } } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; Path boot = getBootClassPath ( ) ; if ( boot . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-bootclasspath" ) ; cmd . createArgument ( ) . setPath ( boot ) ; } logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '8', '34', '1', '1', '7', '2', '2', '346', '0', '0', '0.958333333', '1', '1', '1', '172', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; public interface ResourceCollection { Iterator iterator ( ) ; int size ( ) ; boolean isFilesystemOnly ( ) ; } 	0	['3', '1', '0', '69', '3', '3', '69', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . util . Stack ; public class IdentityStack extends Stack { public static IdentityStack getInstance ( Stack s ) { if ( s instanceof IdentityStack ) { return ( IdentityStack ) s ; } IdentityStack result = new IdentityStack ( ) ; if ( s != null ) { result . addAll ( s ) ; } return result ; } public IdentityStack ( ) { } public IdentityStack ( Object o ) { super ( ) ; push ( o ) ; } public synchronized boolean contains ( Object o ) { return indexOf ( o ) >= 0 ; } public synchronized int indexOf ( Object o , int pos ) { for ( int i = pos ; i < size ( ) ; i ++ ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } public synchronized int lastIndexOf ( Object o , int pos ) { for ( int i = pos ; i >= 0 ; i -- ) { if ( get ( i ) == o ) { return i ; } } return - 1 ; } } 	0	['6', '5', '0', '1', '12', '15', '1', '0', '6', '2', '74', '0', '0', '0.954545455', '0.5', '2', '7', '11.33333333', '3', '1.8333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public class WebsphereDeploymentTool extends GenericDeploymentTool { public static final String PUBLICID_EJB11 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; public static final String PUBLICID_EJB20 = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String SCHEMA_DIR = "Schema/" ; protected static final String WAS_EXT = "ibm-ejb-jar-ext.xmi" ; protected static final String WAS_BND = "ibm-ejb-jar-bnd.xmi" ; protected static final String WAS_CMP_MAP = "Map.mapxmi" ; protected static final String WAS_CMP_SCHEMA = "Schema.dbxmi" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String jarSuffix = ".jar" ; private String ejb11DTD ; private boolean keepGeneric = false ; private boolean alwaysRebuild = true ; private boolean ejbdeploy = true ; private boolean newCMP = false ; private Path wasClasspath = null ; private String dbVendor ; private String dbName ; private String dbSchema ; private boolean codegen ; private boolean quiet = true ; private boolean novalidate ; private boolean nowarn ; private boolean noinform ; private boolean trace ; private String rmicOptions ; private boolean use35MappingRules ; private String tempdir = "_ejbdeploy_temp" ; private File websphereHome ; public Path createWASClasspath ( ) { if ( wasClasspath == null ) { wasClasspath = new Path ( getTask ( ) . getProject ( ) ) ; } return wasClasspath . createPath ( ) ; } public void setWASClasspath ( Path wasClasspath ) { this . wasClasspath = wasClasspath ; } public void setDbvendor ( String dbvendor ) { this . dbVendor = dbvendor ; } public void setDbname ( String dbName ) { this . dbName = dbName ; } public void setDbschema ( String dbSchema ) { this . dbSchema = dbSchema ; } public void setCodegen ( boolean codegen ) { this . codegen = codegen ; } public void setQuiet ( boolean quiet ) { this . quiet = quiet ; } public void setNovalidate ( boolean novalidate ) { this . novalidate = novalidate ; } public void setNowarn ( boolean nowarn ) { this . nowarn = nowarn ; } public void setNoinform ( boolean noinform ) { this . noinform = noinform ; } public void setTrace ( boolean trace ) { this . trace = trace ; } public void setRmicoptions ( String options ) { this . rmicOptions = options ; } public void setUse35 ( boolean attr ) { use35MappingRules = attr ; } public void setRebuild ( boolean rebuild ) { this . alwaysRebuild = rebuild ; } public void setSuffix ( String inString ) { this . jarSuffix = inString ; } public void setKeepgeneric ( boolean inValue ) { this . keepGeneric = inValue ; } public void setEjbdeploy ( boolean ejbdeploy ) { this . ejbdeploy = ejbdeploy ; } public void setEJBdtd ( String inString ) { this . ejb11DTD = inString ; } public void setOldCMP ( boolean oldCMP ) { this . newCMP = ! oldCMP ; } public void setNewCMP ( boolean newCMP ) { this . newCMP = newCMP ; } public void setTempdir ( String tempdir ) { this . tempdir = tempdir ; } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) ; handler . registerDTD ( PUBLICID_EJB11 , ejb11DTD ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected DescriptorHandler getWebsphereDescriptorHandler ( final File srcDir ) { DescriptorHandler handler = new DescriptorHandler ( getTask ( ) , srcDir ) { protected void processElement ( ) { } } ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; handler . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String baseName ) { String ddPrefix = ( usingBaseJarName ( ) ? "" : baseName ) ; String dbPrefix = ( dbVendor == null ) ? "" : dbVendor + "-" ; File websphereEXT = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_EXT ) ; if ( websphereEXT . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_EXT , websphereEXT ) ; } else { log ( "Unable to locate websphere extensions. " + "It was expected to be in " + websphereEXT . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereBND = new File ( getConfig ( ) . descriptorDir , ddPrefix + WAS_BND ) ; if ( websphereBND . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_BND , websphereBND ) ; } else { log ( "Unable to locate websphere bindings. " + "It was expected to be in " + websphereBND . getPath ( ) , Project . MSG_VERBOSE ) ; } if ( ! newCMP ) { log ( "The old method for locating CMP files has been DEPRECATED." , Project . MSG_VERBOSE ) ; log ( "Please adjust your websphere descriptor and set " + "newCMP=\"true\" to use the new CMP descriptor " + "inclusion mechanism. " , Project . MSG_VERBOSE ) ; } else { try { File websphereMAP = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_MAP ) ; if ( websphereMAP . exists ( ) ) { ejbFiles . put ( META_DIR + WAS_CMP_MAP , websphereMAP ) ; } else { log ( "Unable to locate the websphere Map: " + websphereMAP . getPath ( ) , Project . MSG_VERBOSE ) ; } File websphereSchema = new File ( getConfig ( ) . descriptorDir , ddPrefix + dbPrefix + WAS_CMP_SCHEMA ) ; if ( websphereSchema . exists ( ) ) { ejbFiles . put ( META_DIR + SCHEMA_DIR + WAS_CMP_SCHEMA , websphereSchema ) ; } else { log ( "Unable to locate the websphere Schema: " + websphereSchema . getPath ( ) , Project . MSG_VERBOSE ) ; } } catch ( Exception e ) { String msg = "Exception while adding Vendor specific files: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } protected String getOptions ( ) { StringBuffer options = new StringBuffer ( ) ; if ( dbVendor != null ) { options . append ( " -dbvendor " ) . append ( dbVendor ) ; } if ( dbName != null ) { options . append ( " -dbname \"" ) . append ( dbName ) . append ( "\"" ) ; } if ( dbSchema != null ) { options . append ( " -dbschema \"" ) . append ( dbSchema ) . append ( "\"" ) ; } if ( codegen ) { options . append ( " -codegen" ) ; } if ( quiet ) { options . append ( " -quiet" ) ; } if ( novalidate ) { options . append ( " -novalidate" ) ; } if ( nowarn ) { options . append ( " -nowarn" ) ; } if ( noinform ) { options . append ( " -noinform" ) ; } if ( trace ) { options . append ( " -trace" ) ; } if ( use35MappingRules ) { options . append ( " -35" ) ; } if ( rmicOptions != null ) { options . append ( " -rmic \"" ) . append ( rmicOptions ) . append ( "\"" ) ; } return options . toString ( ) ; } private void buildWebsphereJar ( File sourceJar , File destJar ) { try { if ( ejbdeploy ) { Java javaTask = new Java ( getTask ( ) ) ; javaTask . createJvmarg ( ) . setValue ( "-Xms64m" ) ; javaTask . createJvmarg ( ) . setValue ( "-Xmx128m" ) ; Environment . Variable var = new Environment . Variable ( ) ; var . setKey ( "websphere.lib.dir" ) ; File libdir = new File ( websphereHome , "lib" ) ; var . setValue ( libdir . getAbsolutePath ( ) ) ; javaTask . addSysproperty ( var ) ; javaTask . setDir ( websphereHome ) ; javaTask . setTaskName ( "ejbdeploy" ) ; javaTask . setClassname ( "com.ibm.etools.ejbdeploy.EJBDeploy" ) ; javaTask . createArg ( ) . setValue ( sourceJar . getPath ( ) ) ; javaTask . createArg ( ) . setValue ( tempdir ) ; javaTask . createArg ( ) . setValue ( destJar . getPath ( ) ) ; javaTask . createArg ( ) . setLine ( getOptions ( ) ) ; if ( getCombinedClasspath ( ) != null && getCombinedClasspath ( ) . toString ( ) . length ( ) > 0 ) { javaTask . createArg ( ) . setValue ( "-cp" ) ; javaTask . createArg ( ) . setValue ( getCombinedClasspath ( ) . toString ( ) ) ; } Path classpath = wasClasspath ; if ( classpath == null ) { classpath = getCombinedClasspath ( ) ; } if ( classpath != null ) { javaTask . setClasspath ( classpath ) ; javaTask . setFork ( true ) ; } else { javaTask . setFork ( true ) ; } log ( "Calling websphere.ejbdeploy for " + sourceJar . toString ( ) , Project . MSG_VERBOSE ) ; javaTask . execute ( ) ; } } catch ( Exception e ) { String msg = "Exception while calling ejbdeploy. Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void writeJar ( String baseName , File jarFile , Hashtable files , String publicId ) throws BuildException { if ( ejbdeploy ) { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , files , publicId ) ; if ( alwaysRebuild || isRebuildRequired ( genericJarFile , jarFile ) ) { buildWebsphereJar ( genericJarFile , jarFile ) ; } if ( ! keepGeneric ) { log ( "deleting generic jar " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } else { super . writeJar ( baseName , jarFile , files , publicId ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; if ( ejbdeploy ) { String home = getTask ( ) . getProject ( ) . getProperty ( "websphere.home" ) ; if ( home == null ) { throw new BuildException ( "The 'websphere.home' property must " + "be set when 'ejbdeploy=true'" ) ; } websphereHome = getTask ( ) . getProject ( ) . resolveFile ( home ) ; } } protected boolean isRebuildRequired ( File genericJarFile , File websphereJarFile ) { boolean rebuild = false ; JarFile genericJar = null ; JarFile wasJar = null ; File newwasJarFile = null ; JarOutputStream newJarStream = null ; try { log ( "Checking if websphere Jar needs to be rebuilt for jar " + websphereJarFile . getName ( ) , Project . MSG_VERBOSE ) ; if ( genericJarFile . exists ( ) && genericJarFile . isFile ( ) && websphereJarFile . exists ( ) && websphereJarFile . isFile ( ) ) { genericJar = new JarFile ( genericJarFile ) ; wasJar = new JarFile ( websphereJarFile ) ; Hashtable genericEntries = new Hashtable ( ) ; Hashtable wasEntries = new Hashtable ( ) ; Hashtable replaceEntries = new Hashtable ( ) ; for ( Enumeration e = genericJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; genericEntries . put ( je . getName ( ) . replace ( '\\' , '/' ) , je ) ; } for ( Enumeration e = wasJar . entries ( ) ; e . hasMoreElements ( ) ; ) { JarEntry je = ( JarEntry ) e . nextElement ( ) ; wasEntries . put ( je . getName ( ) , je ) ; } ClassLoader genericLoader = getClassLoaderFromJar ( genericJarFile ) ; for ( Enumeration e = genericEntries . keys ( ) ; e . hasMoreElements ( ) ; ) { String filepath = ( String ) e . nextElement ( ) ; if ( wasEntries . containsKey ( filepath ) ) { JarEntry genericEntry = ( JarEntry ) genericEntries . get ( filepath ) ; JarEntry wasEntry = ( JarEntry ) wasEntries . get ( filepath ) ; if ( ( genericEntry . getCrc ( ) != wasEntry . getCrc ( ) ) || ( genericEntry . getSize ( ) != wasEntry . getSize ( ) ) ) { if ( genericEntry . getName ( ) . endsWith ( ".class" ) ) { String classname = genericEntry . getName ( ) . replace ( File . separatorChar , '.' ) ; classname = classname . substring ( 0 , classname . lastIndexOf ( ".class" ) ) ; Class genclass = genericLoader . loadClass ( classname ) ; if ( genclass . isInterface ( ) ) { log ( "Interface " + genclass . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } else { replaceEntries . put ( filepath , genericEntry ) ; } } else { if ( ! genericEntry . getName ( ) . equals ( "META-INF/MANIFEST.MF" ) ) { log ( "Non class file " + genericEntry . getName ( ) + " has changed" , Project . MSG_VERBOSE ) ; rebuild = true ; } break ; } } } else { log ( "File " + filepath + " not present in websphere jar" , Project . MSG_VERBOSE ) ; rebuild = true ; break ; } } if ( ! rebuild ) { log ( "No rebuild needed - updating jar" , Project . MSG_VERBOSE ) ; newwasJarFile = new File ( websphereJarFile . getAbsolutePath ( ) + ".temp" ) ; if ( newwasJarFile . exists ( ) ) { newwasJarFile . delete ( ) ; } newJarStream = new JarOutputStream ( new FileOutputStream ( newwasJarFile ) ) ; newJarStream . setLevel ( 0 ) ; for ( Enumeration e = wasEntries . elements ( ) ; e . hasMoreElements ( ) ; ) { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; int bytesRead ; InputStream is ; JarEntry je = ( JarEntry ) e . nextElement ( ) ; if ( je . getCompressedSize ( ) == - 1 || je . getCompressedSize ( ) == je . getSize ( ) ) { newJarStream . setLevel ( 0 ) ; } else { newJarStream . setLevel ( JAR_COMPRESS_LEVEL ) ; } if ( replaceEntries . containsKey ( je . getName ( ) ) ) { log ( "Updating Bean class from generic Jar " + je . getName ( ) , Project . MSG_VERBOSE ) ; je = ( JarEntry ) replaceEntries . get ( je . getName ( ) ) ; is = genericJar . getInputStream ( je ) ; } else { is = wasJar . getInputStream ( je ) ; } newJarStream . putNextEntry ( new JarEntry ( je . getName ( ) ) ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { newJarStream . write ( buffer , 0 , bytesRead ) ; } is . close ( ) ; } } else { log ( "websphere Jar rebuild needed due to changed " + "interface or XML" , Project . MSG_VERBOSE ) ; } } else { rebuild = true ; } } catch ( ClassNotFoundException cnfe ) { String cnfmsg = "ClassNotFoundException while processing ejb-jar file" + ". Details: " + cnfe . getMessage ( ) ; throw new BuildException ( cnfmsg , cnfe ) ; } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file " + ". Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( genericJar != null ) { try { genericJar . close ( ) ; } catch ( IOException closeException ) { } } if ( wasJar != null ) { try { wasJar . close ( ) ; } catch ( IOException closeException ) { } } if ( newJarStream != null ) { try { newJarStream . close ( ) ; } catch ( IOException closeException ) { } try { FILE_UTILS . rename ( newwasJarFile , websphereJarFile ) ; } catch ( IOException renameException ) { log ( renameException . getMessage ( ) , Project . MSG_WARN ) ; rebuild = true ; } } } return rebuild ; } protected ClassLoader getClassLoaderFromJar ( File classjar ) throws IOException { Path lookupPath = new Path ( getTask ( ) . getProject ( ) ) ; lookupPath . setLocation ( classjar ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath != null ) { lookupPath . append ( classpath ) ; } return getTask ( ) . getProject ( ) . createClassLoader ( lookupPath ) ; } } 	0	['33', '2', '0', '15', '130', '434', '2', '14', '23', '0.940848214', '1220', '0.928571429', '2', '0.507936508', '0.328125', '1', '5', '35.12121212', '26', '2.5152', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Basename extends Task { private File file ; private String property ; private String suffix ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void setSuffix ( String suffix ) { this . suffix = suffix ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } String value = file . getName ( ) ; if ( suffix != null && value . endsWith ( suffix ) ) { int pos = value . length ( ) - suffix . length ( ) ; if ( pos > 0 && suffix . charAt ( 0 ) != '.' && value . charAt ( pos - 1 ) == '.' ) { pos -- ; } value = value . substring ( 0 , pos ) ; } getProject ( ) . setNewProperty ( property , value ) ; } } 	0	['5', '3', '0', '4', '15', '4', '0', '4', '5', '0.75', '90', '1', '0', '0.902439024', '0.533333333', '0', '0', '16.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . optional . Javah ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Kaffeh implements JavahAdapter { public static final String IMPLEMENTATION_NAME = "kaffeh" ; public boolean compile ( Javah javah ) throws BuildException { Commandline cmd = setupKaffehCommand ( javah ) ; try { Execute . runCommand ( javah , cmd . getCommandline ( ) ) ; return true ; } catch ( BuildException e ) { if ( e . getMessage ( ) . indexOf ( "failed with return code" ) == - 1 ) { throw e ; } } return false ; } private Commandline setupKaffehCommand ( Javah javah ) { Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "kaffeh" ) ) ; if ( javah . getDestdir ( ) != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( javah . getDestdir ( ) ) ; } if ( javah . getOutputfile ( ) != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( javah . getOutputfile ( ) ) ; } Path cp = new Path ( javah . getProject ( ) ) ; if ( javah . getBootclasspath ( ) != null ) { cp . append ( javah . getBootclasspath ( ) ) ; } cp = cp . concatSystemBootClasspath ( "ignore" ) ; if ( javah . getClasspath ( ) != null ) { cp . append ( javah . getClasspath ( ) ) ; } if ( cp . size ( ) > 0 ) { cmd . createArgument ( ) . setValue ( "-classpath" ) ; cmd . createArgument ( ) . setPath ( cp ) ; } if ( ! javah . getOld ( ) ) { cmd . createArgument ( ) . setValue ( "-jni" ) ; } cmd . addArguments ( javah . getCurrentArgs ( ) ) ; javah . logAndAddFiles ( cmd ) ; return cmd ; } } 	0	['3', '1', '0', '11', '28', '3', '1', '10', '2', '1.5', '111', '0', '0', '0', '0.833333333', '0', '0', '35.66666667', '7', '2.6667', '0']
package org . apache . tools . ant . util ; import java . util . List ; import java . util . Arrays ; import java . util . Iterator ; import java . util . ArrayList ; public class ChainedMapper extends ContainerMapper { public String [ ] mapFileName ( String sourceFileName ) { List inputs = new ArrayList ( ) ; List results = new ArrayList ( ) ; results . add ( sourceFileName ) ; FileNameMapper mapper = null ; for ( Iterator mIter = getMappers ( ) . iterator ( ) ; mIter . hasNext ( ) ; ) { mapper = ( FileNameMapper ) ( mIter . next ( ) ) ; if ( mapper != null ) { inputs . clear ( ) ; inputs . addAll ( results ) ; results . clear ( ) ; for ( Iterator it = inputs . iterator ( ) ; it . hasNext ( ) ; ) { String [ ] mapped = mapper . mapFileName ( ( String ) ( it . next ( ) ) ) ; if ( mapped != null ) { results . addAll ( Arrays . asList ( mapped ) ) ; } } } } return ( results . size ( ) == 0 ) ? null : ( String [ ] ) results . toArray ( new String [ results . size ( ) ] ) ; } } 	0	['2', '2', '0', '2', '15', '1', '0', '2', '2', '2', '73', '0', '0', '0.875', '0.75', '0', '0', '35.5', '6', '3', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckout extends CCMCheck { public CCMCheckout ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKOUT ) ; } } 	0	['1', '5', '0', '1', '3', '0', '0', '1', '1', '2', '7', '0', '0', '1', '1', '0', '0', '6', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2InputStream ; public class BUnzip2 extends Unpack { private static final String DEFAULT_EXTENSION = ".bz2" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; CBZip2InputStream zIn = null ; InputStream fis = null ; BufferedInputStream bis = null ; try { out = new FileOutputStream ( dest ) ; fis = srcResource . getInputStream ( ) ; bis = new BufferedInputStream ( fis ) ; int b = bis . read ( ) ; if ( b != 'B' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } b = bis . read ( ) ; if ( b != 'Z' ) { throw new BuildException ( "Invalid bz2 file." , getLocation ( ) ) ; } zIn = new CBZip2InputStream ( bis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bis ) ; FileUtils . close ( fis ) ; FileUtils . close ( out ) ; FileUtils . close ( zIn ) ; } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( BUnzip2 . class ) ; } } 	0	['4', '4', '0', '6', '29', '6', '0', '6', '1', '1.166666667', '164', '0.5', '0', '0.942307692', '1', '3', '5', '39.5', '7', '2.5', '0']
package org . apache . tools . ant . util ; public class Base64Converter { private static final char [ ] ALPHABET = { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' , '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '/' } ; public static final char [ ] alphabet = ALPHABET ; public String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } public String encode ( byte [ ] octetString ) { int bits24 ; int bits6 ; char [ ] out = new char [ ( ( octetString . length - 1 ) / 3 + 1 ) * 4 ] ; int outIndex = 0 ; int i = 0 ; while ( ( i + 3 ) <= octetString . length ) { bits24 = ( octetString [ i ++ ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i ++ ] & 0xFF ) << 8 ; bits24 |= octetString [ i ++ ] ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0000003F ) ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; } if ( octetString . length - i == 2 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits24 |= ( octetString [ i + 1 ] & 0xFF ) << 8 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x00000FC0 ) > > 6 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; } else if ( octetString . length - i == 1 ) { bits24 = ( octetString [ i ] & 0xFF ) << 16 ; bits6 = ( bits24 & 0x00FC0000 ) > > 18 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; bits6 = ( bits24 & 0x0003F000 ) > > 12 ; out [ outIndex ++ ] = ALPHABET [ bits6 ] ; out [ outIndex ++ ] = '=' ; out [ outIndex ++ ] = '=' ; } return new String ( out ) ; } } 	0	['4', '1', '1', '2', '7', '4', '2', '0', '3', '0.666666667', '502', '0.5', '0', '0', '0.555555556', '0', '0', '124', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Channel ; import com . jcraft . jsch . ChannelExec ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . SftpProgressMonitor ; import java . io . IOException ; import java . io . OutputStream ; import java . io . InputStream ; import java . text . NumberFormat ; import org . apache . tools . ant . BuildException ; public abstract class AbstractSshMessage { private Session session ; private boolean verbose ; private LogListener listener = new LogListener ( ) { public void log ( String message ) { } } ; public AbstractSshMessage ( Session session ) { this ( false , session ) ; } public AbstractSshMessage ( boolean verbose , Session session ) { this . verbose = verbose ; this . session = session ; } protected Channel openExecChannel ( String command ) throws JSchException { ChannelExec channel = ( ChannelExec ) session . openChannel ( "exec" ) ; channel . setCommand ( command ) ; return channel ; } protected ChannelSftp openSftpChannel ( ) throws JSchException { ChannelSftp channel = ( ChannelSftp ) session . openChannel ( "sftp" ) ; return channel ; } protected void sendAck ( OutputStream out ) throws IOException { byte [ ] buf = new byte [ 1 ] ; buf [ 0 ] = 0 ; out . write ( buf ) ; out . flush ( ) ; } protected void waitForAck ( InputStream in ) throws IOException , BuildException { int b = in . read ( ) ; if ( b == - 1 ) { throw new BuildException ( "No response from server" ) ; } else if ( b != 0 ) { StringBuffer sb = new StringBuffer ( ) ; int c = in . read ( ) ; while ( c > 0 && c != '\n' ) { sb . append ( ( char ) c ) ; c = in . read ( ) ; } if ( b == 1 ) { throw new BuildException ( "server indicated an error: " + sb . toString ( ) ) ; } else if ( b == 2 ) { throw new BuildException ( "server indicated a fatal error: " + sb . toString ( ) ) ; } else { throw new BuildException ( "unknown response, code " + b + " message: " + sb . toString ( ) ) ; } } } public abstract void execute ( ) throws IOException , JSchException ; public void setLogListener ( LogListener aListener ) { listener = aListener ; } protected void log ( String message ) { listener . log ( message ) ; } protected void logStats ( long timeStarted , long timeEnded , long totalLength ) { double duration = ( timeEnded - timeStarted ) / 1000.0 ; NumberFormat format = NumberFormat . getNumberInstance ( ) ; format . setMaximumFractionDigits ( 2 ) ; format . setMinimumFractionDigits ( 1 ) ; listener . log ( "File transfer time: " + format . format ( duration ) + " Average Rate: " + format . format ( totalLength / duration ) + " B/s" ) ; } protected final boolean getVerbose ( ) { return verbose ; } protected final int trackProgress ( long filesize , long totalLength , int percentTransmitted ) { int percent = ( int ) Math . round ( Math . floor ( ( totalLength / ( double ) filesize ) * 100 ) ) ; if ( percent > percentTransmitted ) { if ( filesize < 1048576 ) { if ( percent % 10 == 0 ) { if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "*" ) ; } } } else { if ( percent == 50 ) { System . out . println ( " 50%" ) ; } else if ( percent == 100 ) { System . out . println ( " 100%" ) ; } else { System . out . print ( "." ) ; } } } return percent ; } private ProgressMonitor monitor = null ; protected SftpProgressMonitor getProgressMonitor ( ) { if ( monitor == null ) { monitor = new ProgressMonitor ( ) ; } return monitor ; } private class ProgressMonitor implements SftpProgressMonitor { private long initFileSize = 0 ; private long totalLength = 0 ; private int percentTransmitted = 0 ; public void init ( int op , String src , String dest , long max ) { initFileSize = max ; totalLength = 0 ; percentTransmitted = 0 ; } public boolean count ( long len ) { totalLength += len ; percentTransmitted = trackProgress ( initFileSize , totalLength , percentTransmitted ) ; return true ; } public void end ( ) { } public long getTotalLength ( ) { return totalLength ; } } } 	0	['13', '1', '2', '12', '37', '56', '4', '10', '4', '0.770833333', '269', '1', '2', '0', '0.205128205', '0', '0', '19.38461538', '7', '1.3846', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class Majority extends ResourceSelectorContainer implements ResourceSelector { private boolean tie = true ; public Majority ( ) { } public Majority ( ResourceSelector [ ] r ) { super ( r ) ; } public synchronized void setAllowtie ( boolean b ) { tie = b ; } public synchronized boolean isSelected ( Resource r ) { int passed = 0 ; int failed = 0 ; int count = selectorCount ( ) ; boolean even = count % 2 == 0 ; int threshold = count / 2 ; for ( Iterator i = getSelectors ( ) ; i . hasNext ( ) ; ) { if ( ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ) { ++ passed ; if ( passed > threshold || ( even && tie && passed == threshold ) ) { return true ; } } else { ++ failed ; if ( failed > threshold || ( even && ! tie && failed == threshold ) ) { return false ; } } } return false ; } } 	0	['4', '4', '0', '3', '11', '0', '0', '3', '4', '0', '84', '1', '0', '0.945945946', '0.4375', '0', '0', '19.75', '12', '3.25', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; public interface HotDeploymentTool { String ACTION_DELETE = "delete" ; String ACTION_DEPLOY = "deploy" ; String ACTION_LIST = "list" ; String ACTION_UNDEPLOY = "undeploy" ; String ACTION_UPDATE = "update" ; void validateAttributes ( ) throws BuildException ; void deploy ( ) throws BuildException ; void setTask ( ServerDeploy task ) ; } 	0	['3', '1', '0', '5', '3', '3', '4', '2', '3', '1.5', '8', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Intersect extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rcs = getResourceCollections ( ) ; int size = rcs . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The intersection of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } ArrayList al = new ArrayList ( ) ; Iterator rc = rcs . iterator ( ) ; al . addAll ( collect ( rc . next ( ) ) ) ; while ( rc . hasNext ( ) ) { al . retainAll ( collect ( rc . next ( ) ) ) ; } return al ; } private ArrayList collect ( Object o ) { ArrayList result = new ArrayList ( ) ; for ( Iterator i = ( ( ResourceCollection ) o ) . iterator ( ) ; i . hasNext ( ) ; ) { result . add ( i . next ( ) ) ; } return result ; } } 	0	['3', '4', '0', '3', '19', '3', '0', '3', '1', '2', '83', '0', '0', '0.956521739', '0.666666667', '1', '1', '26.66666667', '4', '2', '0']
package org . apache . tools . ant . types . resources ; public interface Touchable { void touch ( long modTime ) ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class LocationResolver implements ExtensionResolver { private String location ; public void setLocation ( final String location ) { this . location = location ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { if ( null == location ) { final String message = "No location specified for resolver" ; throw new BuildException ( message ) ; } return project . resolveFile ( location ) ; } public String toString ( ) { return "Location[" + location + "]" ; } } 	0	['4', '1', '0', '5', '10', '0', '1', '4', '4', '0.333333333', '36', '1', '0', '0', '0.4375', '0', '0', '7.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSGet extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; if ( getVersion ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_VERSION ) ; commandLine . createArgument ( ) . setValue ( getVersion ( ) ) ; } } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_GET_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; if ( getLabel ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_LABEL ) ; commandLine . createArgument ( ) . setValue ( getLabel ( ) ) ; } } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; return commandLine ; } } 	0	['6', '4', '0', '3', '20', '15', '0', '3', '5', '2', '106', '0', '0', '0.936708861', '0.555555556', '1', '2', '16.66666667', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class Utf8CPInfo extends ConstantPoolEntry { private String value ; public Utf8CPInfo ( ) { super ( CONSTANT_UTF8 , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { value = cpStream . readUTF ( ) ; } public String toString ( ) { return "UTF8 Value = " + value ; } public String getValue ( ) { return value ; } } 	0	['4', '2', '0', '5', '9', '0', '5', '1', '4', '0.333333333', '27', '1', '0', '0.666666667', '0.625', '1', '1', '5.5', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public interface SelectorContainer { boolean hasSelectors ( ) ; int selectorCount ( ) ; FileSelector [ ] getSelectors ( Project p ) ; Enumeration selectorElements ( ) ; void appendSelector ( FileSelector selector ) ; void addSelector ( SelectSelector selector ) ; void addAnd ( AndSelector selector ) ; void addOr ( OrSelector selector ) ; void addNot ( NotSelector selector ) ; void addNone ( NoneSelector selector ) ; void addMajority ( MajoritySelector selector ) ; void addDate ( DateSelector selector ) ; void addSize ( SizeSelector selector ) ; void addFilename ( FilenameSelector selector ) ; void addCustom ( ExtendSelector selector ) ; void addContains ( ContainsSelector selector ) ; void addPresent ( PresentSelector selector ) ; void addDepth ( DepthSelector selector ) ; void addDepend ( DependSelector selector ) ; void addContainsRegexp ( ContainsRegexpSelector selector ) ; void addType ( TypeSelector selector ) ; void addDifferent ( DifferentSelector selector ) ; void addModified ( ModifiedSelector selector ) ; void add ( FileSelector selector ) ; } 	0	['24', '1', '0', '24', '24', '276', '4', '20', '24', '2', '24', '0', '0', '0', '0.089285714', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . StringTokenizer ; import java . io . File ; public class Directory { private File directory ; private ArrayList childDirectories ; private ArrayList files ; private Directory parent ; public Directory ( File directory ) { this ( directory , null ) ; } public Directory ( File directory , Directory parent ) { this . parent = parent ; this . childDirectories = new ArrayList ( ) ; this . files = new ArrayList ( ) ; this . directory = directory ; } public void addDirectory ( Directory directory ) { if ( ! childDirectories . contains ( directory ) ) { childDirectories . add ( directory ) ; } } public void addFile ( File file ) { files . add ( file ) ; } public Iterator directoryIterator ( ) { return childDirectories . iterator ( ) ; } public Iterator filesIterator ( ) { return files . iterator ( ) ; } public Directory getParent ( ) { return parent ; } public boolean isRoot ( ) { return parent == null ; } public File getDirectory ( ) { return directory ; } public Directory getChild ( File dir ) { for ( int i = 0 ; i < childDirectories . size ( ) ; i ++ ) { Directory current = ( Directory ) childDirectories . get ( i ) ; if ( current . getDirectory ( ) . equals ( dir ) ) { return current ; } } return null ; } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Directory ) ) { return false ; } Directory d = ( Directory ) obj ; return this . directory . equals ( d . directory ) ; } public int hashCode ( ) { return directory . hashCode ( ) ; } public String [ ] getPath ( ) { return getPath ( directory . getAbsolutePath ( ) ) ; } public static String [ ] getPath ( String thePath ) { StringTokenizer tokenizer = new StringTokenizer ( thePath , File . separator ) ; String [ ] path = new String [ tokenizer . countTokens ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { path [ i ] = tokenizer . nextToken ( ) ; i ++ ; } return path ; } public int fileSize ( ) { return files . size ( ) ; } } 	0	['15', '1', '0', '3', '29', '55', '3', '0', '15', '0.696428571', '161', '1', '1', '0', '0.293333333', '1', '1', '9.466666667', '3', '1.3333', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Vector ; public class FilterSetCollection { private Vector filterSets = new Vector ( ) ; public FilterSetCollection ( ) { } public FilterSetCollection ( FilterSet filterSet ) { addFilterSet ( filterSet ) ; } public void addFilterSet ( FilterSet filterSet ) { filterSets . addElement ( filterSet ) ; } public String replaceTokens ( String line ) { String replacedLine = line ; for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; replacedLine = filterSet . replaceTokens ( replacedLine ) ; } return replacedLine ; } public boolean hasFilters ( ) { for ( Enumeration e = filterSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FilterSet filterSet = ( FilterSet ) e . nextElement ( ) ; if ( filterSet . hasFilters ( ) ) { return true ; } } return false ; } } 	0	['5', '1', '0', '9', '13', '0', '8', '1', '5', '0', '69', '1', '0', '0', '0.533333333', '0', '0', '12.6', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Stack ; import java . util . Vector ; public class DirectoryIterator implements ClassFileIterator { private Stack enumStack ; private Enumeration currentEnum ; public DirectoryIterator ( File rootDirectory , boolean changeInto ) throws IOException { super ( ) ; enumStack = new Stack ( ) ; Vector filesInRoot = getDirectoryEntries ( rootDirectory ) ; currentEnum = filesInRoot . elements ( ) ; } private Vector getDirectoryEntries ( File directory ) { Vector files = new Vector ( ) ; String [ ] filesInDir = directory . list ( ) ; if ( filesInDir != null ) { int length = filesInDir . length ; for ( int i = 0 ; i < length ; ++ i ) { files . addElement ( new File ( directory , filesInDir [ i ] ) ) ; } } return files ; } public ClassFile getNextClassFile ( ) { ClassFile nextElement = null ; try { while ( nextElement == null ) { if ( currentEnum . hasMoreElements ( ) ) { File element = ( File ) currentEnum . nextElement ( ) ; if ( element . isDirectory ( ) ) { enumStack . push ( currentEnum ) ; Vector files = getDirectoryEntries ( element ) ; currentEnum = files . elements ( ) ; } else { FileInputStream inFileStream = new FileInputStream ( element ) ; if ( element . getName ( ) . endsWith ( ".class" ) ) { ClassFile javaClass = new ClassFile ( ) ; javaClass . read ( inFileStream ) ; nextElement = javaClass ; } } } else { if ( enumStack . empty ( ) ) { break ; } else { currentEnum = ( Enumeration ) enumStack . pop ( ) ; } } } } catch ( IOException e ) { nextElement = null ; } return nextElement ; } } 	0	['3', '1', '0', '2', '21', '1', '0', '2', '2', '0.5', '120', '1', '0', '0', '0.666666667', '0', '0', '38.33333333', '6', '3', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; public class ConstantPool { private Vector entries ; private Hashtable utf8Indexes ; public ConstantPool ( ) { entries = new Vector ( ) ; entries . addElement ( null ) ; utf8Indexes = new Hashtable ( ) ; } public void read ( DataInputStream classStream ) throws IOException { int numEntries = classStream . readUnsignedShort ( ) ; for ( int i = 1 ; i < numEntries ; ) { ConstantPoolEntry nextEntry = ConstantPoolEntry . readEntry ( classStream ) ; i += nextEntry . getNumEntries ( ) ; addEntry ( nextEntry ) ; } } public int size ( ) { return entries . size ( ) ; } public int addEntry ( ConstantPoolEntry entry ) { int index = entries . size ( ) ; entries . addElement ( entry ) ; int numSlots = entry . getNumEntries ( ) ; for ( int j = 0 ; j < numSlots - 1 ; ++ j ) { entries . addElement ( null ) ; } if ( entry instanceof Utf8CPInfo ) { Utf8CPInfo utf8Info = ( Utf8CPInfo ) entry ; utf8Indexes . put ( utf8Info . getValue ( ) , new Integer ( index ) ) ; } return index ; } public void resolve ( ) { for ( Enumeration i = entries . elements ( ) ; i . hasMoreElements ( ) ; ) { ConstantPoolEntry poolInfo = ( ConstantPoolEntry ) i . nextElement ( ) ; if ( poolInfo != null && ! poolInfo . isResolved ( ) ) { poolInfo . resolve ( this ) ; } } } public ConstantPoolEntry getEntry ( int index ) { return ( ConstantPoolEntry ) entries . elementAt ( index ) ; } public int getUTF8Entry ( String value ) { int index = - 1 ; Integer indexInteger = ( Integer ) utf8Indexes . get ( value ) ; if ( indexInteger != null ) { index = indexInteger . intValue ( ) ; } return index ; } public int getClassEntry ( String className ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ClassCPInfo ) { ClassCPInfo classinfo = ( ClassCPInfo ) element ; if ( classinfo . getClassName ( ) . equals ( className ) ) { index = i ; } } } return index ; } public int getConstantEntry ( Object constantValue ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof ConstantCPInfo ) { ConstantCPInfo constantEntry = ( ConstantCPInfo ) element ; if ( constantEntry . getValue ( ) . equals ( constantValue ) ) { index = i ; } } } return index ; } public int getMethodRefEntry ( String methodClassName , String methodName , String methodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof MethodRefCPInfo ) { MethodRefCPInfo methodRefEntry = ( MethodRefCPInfo ) element ; if ( methodRefEntry . getMethodClassName ( ) . equals ( methodClassName ) && methodRefEntry . getMethodName ( ) . equals ( methodName ) && methodRefEntry . getMethodType ( ) . equals ( methodType ) ) { index = i ; } } } return index ; } public int getInterfaceMethodRefEntry ( String interfaceMethodClassName , String interfaceMethodName , String interfaceMethodType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof InterfaceMethodRefCPInfo ) { InterfaceMethodRefCPInfo interfaceMethodRefEntry = ( InterfaceMethodRefCPInfo ) element ; if ( interfaceMethodRefEntry . getInterfaceMethodClassName ( ) . equals ( interfaceMethodClassName ) && interfaceMethodRefEntry . getInterfaceMethodName ( ) . equals ( interfaceMethodName ) && interfaceMethodRefEntry . getInterfaceMethodType ( ) . equals ( interfaceMethodType ) ) { index = i ; } } } return index ; } public int getFieldRefEntry ( String fieldClassName , String fieldName , String fieldType ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof FieldRefCPInfo ) { FieldRefCPInfo fieldRefEntry = ( FieldRefCPInfo ) element ; if ( fieldRefEntry . getFieldClassName ( ) . equals ( fieldClassName ) && fieldRefEntry . getFieldName ( ) . equals ( fieldName ) && fieldRefEntry . getFieldType ( ) . equals ( fieldType ) ) { index = i ; } } } return index ; } public int getNameAndTypeEntry ( String name , String type ) { int index = - 1 ; for ( int i = 0 ; i < entries . size ( ) && index == - 1 ; ++ i ) { Object element = entries . elementAt ( i ) ; if ( element instanceof NameAndTypeCPInfo ) { NameAndTypeCPInfo nameAndTypeEntry = ( NameAndTypeCPInfo ) element ; if ( nameAndTypeEntry . getName ( ) . equals ( name ) && nameAndTypeEntry . getType ( ) . equals ( type ) ) { index = i ; } } } return index ; } public String toString ( ) { StringBuffer sb = new StringBuffer ( "\n" ) ; int size = entries . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { sb . append ( "[" + i + "] = " + getEntry ( i ) + "\n" ) ; } return sb . toString ( ) ; } } 	0	['14', '1', '0', '10', '53', '0', '8', '8', '14', '0.423076923', '419', '1', '0', '0', '0.285714286', '0', '0', '28.78571429', '7', '3.6429', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckout extends ClearCase { private boolean mReserved = true ; private String mOut = null ; private boolean mNdata = false ; private String mBranch = null ; private boolean mVersion = false ; private boolean mNwarn = false ; private String mComment = null ; private String mCfile = null ; private boolean mNotco = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKOUT ) ; checkOptions ( commandLine ) ; if ( ! getNotco ( ) && lsCheckout ( ) ) { getProject ( ) . log ( "Already checked out in this view: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; return ; } if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private boolean lsCheckout ( ) { Commandline cmdl = new Commandline ( ) ; String result ; cmdl . setExecutable ( getClearToolCommand ( ) ) ; cmdl . createArgument ( ) . setValue ( COMMAND_LSCO ) ; cmdl . createArgument ( ) . setValue ( "-cview" ) ; cmdl . createArgument ( ) . setValue ( "-short" ) ; cmdl . createArgument ( ) . setValue ( "-d" ) ; cmdl . createArgument ( ) . setValue ( getViewPath ( ) ) ; result = runS ( cmdl ) ; return ( result != null && result . length ( ) > 0 ) ? true : false ; } private void checkOptions ( Commandline cmd ) { if ( getReserved ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RESERVED ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_UNRESERVED ) ; } if ( getOut ( ) != null ) { getOutCommand ( cmd ) ; } else { if ( getNoData ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NODATA ) ; } } if ( getBranch ( ) != null ) { getBranchCommand ( cmd ) ; } else { if ( getVersion ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReserved ( boolean reserved ) { mReserved = reserved ; } public boolean getReserved ( ) { return mReserved ; } public void setNotco ( boolean notco ) { mNotco = notco ; } public boolean getNotco ( ) { return mNotco ; } public void setOut ( String outf ) { mOut = outf ; } public String getOut ( ) { return mOut ; } public void setNoData ( boolean ndata ) { mNdata = ndata ; } public boolean getNoData ( ) { return mNdata ; } public void setBranch ( String branch ) { mBranch = branch ; } public String getBranch ( ) { return mBranch ; } public void setVersion ( boolean version ) { mVersion = version ; } public boolean getVersion ( ) { return mVersion ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } private void getOutCommand ( Commandline cmd ) { if ( getOut ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_OUT ) ; cmd . createArgument ( ) . setValue ( getOut ( ) ) ; } } private void getBranchCommand ( Commandline cmd ) { if ( getBranch ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_BRANCH ) ; cmd . createArgument ( ) . setValue ( getBranch ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_RESERVED = "-reserved" ; public static final String FLAG_UNRESERVED = "-unreserved" ; public static final String FLAG_OUT = "-out" ; public static final String FLAG_NODATA = "-ndata" ; public static final String FLAG_BRANCH = "-branch" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['26', '4', '0', '7', '50', '271', '0', '7', '20', '0.955789474', '392', '0.473684211', '0', '0.657534247', '0.384615385', '2', '3', '13.34615385', '9', '1.5', '0']
package org . apache . tools . ant ; public interface TypeAdapter { void setProject ( Project p ) ; Project getProject ( ) ; void setProxy ( Object o ) ; Object getProxy ( ) ; void checkProxyClass ( Class proxyClass ) ; } 	0	['5', '1', '0', '7', '5', '10', '6', '1', '5', '2', '5', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCCheckin extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mKeep = false ; private boolean mIdentical = true ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKIN ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } if ( getKeepCopy ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_KEEPCOPY ) ; } if ( getIdentical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IDENTICAL ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setKeepCopy ( boolean keep ) { mKeep = keep ; } public boolean getKeepCopy ( ) { return mKeep ; } public void setIdentical ( boolean identical ) { mIdentical = identical ; } public boolean getIdentical ( ) { return mIdentical ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_KEEPCOPY = "-keep" ; public static final String FLAG_IDENTICAL = "-identical" ; } 	0	['17', '4', '0', '7', '39', '100', '0', '7', '14', '0.9375', '241', '0.461538462', '0', '0.75', '0.382352941', '2', '3', '12.41176471', '7', '1.4118', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; public class ImportTypelib extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File srcFile ; private File destFile ; private String namespace ; private boolean useSysArray = false ; private boolean unsafe = false ; private String extraOptions = null ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setSrcFile ( File srcFile ) { this . srcFile = srcFile ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public void setUseSysArray ( boolean useSysArray ) { this . useSysArray = useSysArray ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( "destination file must be specified" ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( "destination file is a directory" ) ; } if ( srcFile == null || ! srcFile . exists ( ) ) { throw new BuildException ( "source file does not exist" ) ; } if ( srcFile . isDirectory ( ) ) { throw new BuildException ( "source file is a directory" ) ; } if ( namespace == null ) { throw new BuildException ( "No namespace" ) ; } } private boolean isExecuteNeeded ( ) { if ( ! destFile . exists ( ) ) { log ( "Destination file does not exist: a build is required" , Project . MSG_VERBOSE ) ; return true ; } long sourceTime = srcFile . lastModified ( ) ; long destTime = destFile . lastModified ( ) ; if ( sourceTime > ( destTime + FILE_UTILS . getFileTimestampGranularity ( ) ) ) { log ( "Source file is newer than the dest file: a rebuild is required" , Project . MSG_VERBOSE ) ; return true ; } else { log ( "The output file is up to date" , Project . MSG_VERBOSE ) ; return false ; } } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; log ( "Importing typelib " + srcFile + " to assembly " + destFile + " in namespace " + namespace , Project . MSG_VERBOSE ) ; if ( ! isExecuteNeeded ( ) ) { return ; } NetCommand command = new NetCommand ( this , "ImportTypelib" , "tlbimp" ) ; command . setFailOnError ( true ) ; command . addArgument ( srcFile . toString ( ) ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/namespace:" , namespace ) ; if ( useSysArray ) { command . addArgument ( "/sysarray" ) ; } if ( unsafe ) { command . addArgument ( "/unsafe" ) ; } command . addArgument ( extraOptions ) ; command . runCommand ( ) ; } } 	0	['11', '3', '0', '4', '29', '17', '0', '4', '8', '0.771428571', '224', '1', '1', '0.804347826', '0.4', '1', '1', '18.72727273', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Get ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class URLResolver implements ExtensionResolver { private File destfile ; private File destdir ; private URL url ; public void setUrl ( final URL url ) { this . url = url ; } public void setDestfile ( final File destfile ) { this . destfile = destfile ; } public void setDestdir ( final File destdir ) { this . destdir = destdir ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { validate ( ) ; final File file = getDest ( ) ; final Get get = new Get ( ) ; get . setProject ( project ) ; get . setDest ( file ) ; get . setSrc ( url ) ; get . execute ( ) ; return file ; } private File getDest ( ) { File result ; if ( null != destfile ) { result = destfile ; } else { final String file = url . getFile ( ) ; String filename ; if ( null == file || file . length ( ) <= 1 ) { filename = "default.file" ; } else { int index = file . lastIndexOf ( '/' ) ; if ( - 1 == index ) { index = 0 ; } filename = file . substring ( index ) ; } result = new File ( destdir , filename ) ; } return result ; } private void validate ( ) { if ( null == url ) { final String message = "Must specify URL" ; throw new BuildException ( message ) ; } if ( null == destdir && null == destfile ) { final String message = "Must specify destination file or directory" ; throw new BuildException ( message ) ; } else if ( null != destdir && null != destfile ) { final String message = "Must not specify both destination file or directory" ; throw new BuildException ( message ) ; } } public String toString ( ) { return "URL[" + url + "]" ; } } 	0	['8', '1', '0', '6', '24', '0', '1', '5', '6', '0.523809524', '133', '1', '0', '0', '0.325', '0', '0', '15.25', '6', '2', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public final class KaffeNative2Ascii extends DefaultNative2Ascii { private static final String [ ] N2A_CLASSNAMES = new String [ ] { "gnu.classpath.tools.native2ascii.Native2Ascii" , "kaffe.tools.native2ascii.Native2Ascii" , } ; public static final String IMPLEMENTATION_NAME = "kaffe" ; protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getReverse ( ) ) { throw new BuildException ( "-reverse is not supported by Kaffe" ) ; } super . setup ( cmd , args ) ; } protected boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException { ExecuteJava ej = new ExecuteJava ( ) ; Class c = getN2aClass ( ) ; if ( c == null ) { throw new BuildException ( "Couldn't load Kaffe's Native2Ascii" + " class" ) ; } cmd . setExecutable ( c . getName ( ) ) ; ej . setJavaCommand ( cmd ) ; ej . execute ( log . getProject ( ) ) ; return true ; } private static Class getN2aClass ( ) { for ( int i = 0 ; i < N2A_CLASSNAMES . length ; i ++ ) { try { return Class . forName ( N2A_CLASSNAMES [ i ] ) ; } catch ( ClassNotFoundException cnfe ) { } } return null ; } } 	0	['5', '2', '0', '8', '16', '8', '1', '7', '1', '0.875', '77', '0.5', '0', '0.571428571', '0.4375', '1', '2', '14', '2', '0.8', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . BuildException ; public class CvsUser { private String userID ; private String displayName ; public void setDisplayname ( final String displayName ) { this . displayName = displayName ; } public void setUserid ( final String userID ) { this . userID = userID ; } public String getUserID ( ) { return userID ; } public String getDisplayname ( ) { return displayName ; } public void validate ( ) throws BuildException { if ( null == userID ) { final String message = "Username attribute must be set." ; throw new BuildException ( message ) ; } if ( null == displayName ) { final String message = "Displayname attribute must be set for userID " + userID ; throw new BuildException ( message ) ; } } } 	0	['6', '1', '0', '2', '11', '3', '1', '1', '6', '0.6', '51', '1', '0', '0', '0.666666667', '0', '0', '7.166666667', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . LinkedList ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . util . LineTokenizer ; public final class TailFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private boolean completedReadAhead = false ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; private LinkedList lineList = new LinkedList ( ) ; public TailFilter ( ) { super ( ) ; } public TailFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; line = tailFilter ( line ) ; if ( line == null ) { return - 1 ; } linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public void setLines ( final long lines ) { this . lines = lines ; } private long getLines ( ) { return lines ; } public void setSkip ( final long skip ) { this . skip = skip ; } private long getSkip ( ) { return skip ; } public Reader chain ( final Reader rdr ) { TailFilter newFilter = new TailFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { setLines ( new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String tailFilter ( String line ) { if ( ! completedReadAhead ) { if ( line != null ) { lineList . add ( line ) ; if ( lines == - 1 ) { if ( lineList . size ( ) > skip ) { return ( String ) lineList . removeFirst ( ) ; } } else { long linesToKeep = lines + ( skip > 0 ? skip : 0 ) ; if ( linesToKeep < lineList . size ( ) ) { lineList . removeFirst ( ) ; } } return "" ; } completedReadAhead = true ; if ( skip > 0 ) { for ( int i = 0 ; i < skip ; ++ i ) { lineList . removeLast ( ) ; } } if ( lines > - 1 ) { while ( lineList . size ( ) > lines ) { lineList . removeFirst ( ) ; } } } if ( lineList . size ( ) > 0 ) { return ( String ) lineList . removeFirst ( ) ; } return null ; } } 	0	['10', '5', '0', '5', '30', '0', '1', '4', '6', '0.688888889', '328', '1', '1', '0.777777778', '0.375', '2', '5', '30.8', '12', '2.3', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import javax . xml . transform . stream . StreamSource ; import org . apache . tools . ant . BuildException ; public class Xalan2Executor extends XalanExecutor { private static final String APAC = "org.apache.xalan." ; private static final String SPAC = "com.sun.org.apache.xalan." ; private TransformerFactory tfactory = TransformerFactory . newInstance ( ) ; protected String getImplementation ( ) throws BuildException { return tfactory . getClass ( ) . getName ( ) ; } protected String getProcVersion ( String classNameImpl ) throws BuildException { try { if ( classNameImpl . equals ( APAC + "processor.TransformerFactoryImpl" ) || classNameImpl . equals ( APAC + "xslt.XSLTProcessorFactory" ) ) { return getXalanVersion ( APAC + "processor.XSLProcessorVersion" ) ; } if ( classNameImpl . equals ( APAC + "xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( APAC + "xsltc.ProcessorVersion" ) ; } if ( classNameImpl . equals ( SPAC + "internal.xsltc.trax.TransformerFactoryImpl" ) ) { return getXSLTCVersion ( SPAC + "internal.xsltc.ProcessorVersion" ) ; } throw new BuildException ( "Could not find a valid processor version" + " implementation from " + classNameImpl ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find processor version " + "implementation" , e ) ; } } void execute ( ) throws Exception { String systemId = caller . getStylesheetSystemId ( ) ; Source xslSrc = new StreamSource ( systemId ) ; Transformer tformer = tfactory . newTransformer ( xslSrc ) ; Source xmlSrc = new DOMSource ( caller . document ) ; OutputStream os = getOutputStream ( ) ; try { tformer . setParameter ( "output.dir" , caller . toDir . getAbsolutePath ( ) ) ; Result result = new StreamResult ( os ) ; tformer . transform ( xmlSrc , result ) ; } finally { os . close ( ) ; } } } 	0	['4', '2', '0', '3', '26', '0', '0', '3', '1', '1', '115', '1', '0', '0.727272727', '0.625', '2', '3', '27', '1', '0.75', '0']
package org . apache . tools . ant . types . selectors ; import java . util . Enumeration ; import java . io . File ; import org . apache . tools . ant . Project ; public class SelectSelector extends BaseSelectorContainer { private String ifProperty ; private String unlessProperty ; public SelectSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{select" ) ; if ( ifProperty != null ) { buf . append ( " if: " ) ; buf . append ( ifProperty ) ; } if ( unlessProperty != null ) { buf . append ( " unless: " ) ; buf . append ( unlessProperty ) ; } buf . append ( " " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } private SelectSelector getRef ( ) { Object o = getCheckedRef ( this . getClass ( ) , "SelectSelector" ) ; return ( SelectSelector ) o ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return getRef ( ) . hasSelectors ( ) ; } return super . hasSelectors ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorCount ( ) ; } return super . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { if ( isReference ( ) ) { return getRef ( ) . getSelectors ( p ) ; } return super . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { if ( isReference ( ) ) { return getRef ( ) . selectorElements ( ) ; } return super . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } super . appendSelector ( selector ) ; } public void verifySettings ( ) { int cnt = selectorCount ( ) ; if ( cnt < 0 || cnt > 1 ) { setError ( "Only one selector is allowed within the " + "<selector> tag" ) ; } } public boolean passesConditions ( ) { if ( ifProperty != null && getProject ( ) . getProperty ( ifProperty ) == null ) { return false ; } else if ( unlessProperty != null && getProject ( ) . getProperty ( unlessProperty ) != null ) { return false ; } return true ; } public void setIf ( String ifProperty ) { this . ifProperty = ifProperty ; } public void setUnless ( String unlessProperty ) { this . unlessProperty = unlessProperty ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; if ( ! ( passesConditions ( ) ) ) { return false ; } Enumeration e = selectorElements ( ) ; if ( ! ( e . hasMoreElements ( ) ) ) { return true ; } FileSelector f = ( FileSelector ) e . nextElement ( ) ; return f . isSelected ( basedir , filename , file ) ; } } 	0	['13', '5', '0', '9', '34', '68', '6', '4', '12', '0.75', '199', '1', '0', '0.837837838', '0.292307692', '2', '8', '14.15384615', '5', '2.1538', '0']
package org . apache . tools . ant . listener ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintStream ; import java . util . Properties ; import org . apache . tools . ant . DefaultLogger ; import org . apache . tools . ant . Project ; public final class AnsiColorLogger extends DefaultLogger { private static final int ATTR_DIM = 2 ; private static final int FG_RED = 31 ; private static final int FG_GREEN = 32 ; private static final int FG_BLUE = 34 ; private static final int FG_MAGENTA = 35 ; private static final int FG_CYAN = 36 ; private static final String PREFIX = "[" ; private static final String SUFFIX = "m" ; private static final char SEPARATOR = ';' ; private static final String END_COLOR = PREFIX + SUFFIX ; private String errColor = PREFIX + ATTR_DIM + SEPARATOR + FG_RED + SUFFIX ; private String warnColor = PREFIX + ATTR_DIM + SEPARATOR + FG_MAGENTA + SUFFIX ; private String infoColor = PREFIX + ATTR_DIM + SEPARATOR + FG_CYAN + SUFFIX ; private String verboseColor = PREFIX + ATTR_DIM + SEPARATOR + FG_GREEN + SUFFIX ; private String debugColor = PREFIX + ATTR_DIM + SEPARATOR + FG_BLUE + SUFFIX ; private boolean colorsSet = false ; private void setColors ( ) { String userColorFile = System . getProperty ( "ant.logger.defaults" ) ; String systemColorFile = "/org/apache/tools/ant/listener/defaults.properties" ; InputStream in = null ; try { Properties prop = new Properties ( ) ; if ( userColorFile != null ) { in = new FileInputStream ( userColorFile ) ; } else { in = getClass ( ) . getResourceAsStream ( systemColorFile ) ; } if ( in != null ) { prop . load ( in ) ; } String errC = prop . getProperty ( "AnsiColorLogger.ERROR_COLOR" ) ; String warn = prop . getProperty ( "AnsiColorLogger.WARNING_COLOR" ) ; String info = prop . getProperty ( "AnsiColorLogger.INFO_COLOR" ) ; String verbose = prop . getProperty ( "AnsiColorLogger.VERBOSE_COLOR" ) ; String debug = prop . getProperty ( "AnsiColorLogger.DEBUG_COLOR" ) ; if ( errC != null ) { errColor = PREFIX + errC + SUFFIX ; } if ( warn != null ) { warnColor = PREFIX + warn + SUFFIX ; } if ( info != null ) { infoColor = PREFIX + info + SUFFIX ; } if ( verbose != null ) { verboseColor = PREFIX + verbose + SUFFIX ; } if ( debug != null ) { debugColor = PREFIX + debug + SUFFIX ; } } catch ( IOException ioe ) { } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } } } protected void printMessage ( final String message , final PrintStream stream , final int priority ) { if ( message != null && stream != null ) { if ( ! colorsSet ) { setColors ( ) ; colorsSet = true ; } final StringBuffer msg = new StringBuffer ( message ) ; switch ( priority ) { case Project . MSG_ERR : msg . insert ( 0 , errColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_WARN : msg . insert ( 0 , warnColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_INFO : msg . insert ( 0 , infoColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_VERBOSE : msg . insert ( 0 , verboseColor ) ; msg . append ( END_COLOR ) ; break ; case Project . MSG_DEBUG : default : msg . insert ( 0 , debugColor ) ; msg . append ( END_COLOR ) ; break ; } final String strmessage = msg . toString ( ) ; stream . println ( strmessage ) ; } } } 	0	['3', '2', '0', '1', '17', '0', '0', '1', '1', '0.96875', '251', '1', '0', '0.888888889', '0.5', '1', '3', '77.33333333', '11', '5.3333', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public class Quantifier extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "all" , "each" , "every" , "any" , "some" , "one" , "majority" , "most" , "none" } ; public static final Quantifier ALL = new Quantifier ( "all" ) ; public static final Quantifier ANY = new Quantifier ( "any" ) ; public static final Quantifier ONE = new Quantifier ( "one" ) ; public static final Quantifier MAJORITY = new Quantifier ( "majority" ) ; public static final Quantifier NONE = new Quantifier ( "none" ) ; private abstract static class Predicate { abstract boolean eval ( int t , int f ) ; } private static final Predicate ALL_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return f == 0 ; } } ; private static final Predicate ANY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > 0 ; } } ; private static final Predicate ONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 1 ; } } ; private static final Predicate MAJORITY_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t > f ; } } ; private static final Predicate NONE_PRED = new Predicate ( ) { boolean eval ( int t , int f ) { return t == 0 ; } } ; private static final Predicate [ ] PREDS = new Predicate [ VALUES . length ] ; static { PREDS [ 0 ] = ALL_PRED ; PREDS [ 1 ] = ALL_PRED ; PREDS [ 2 ] = ALL_PRED ; PREDS [ 3 ] = ANY_PRED ; PREDS [ 4 ] = ANY_PRED ; PREDS [ 5 ] = ONE_PRED ; PREDS [ 6 ] = MAJORITY_PRED ; PREDS [ 7 ] = MAJORITY_PRED ; PREDS [ 8 ] = NONE_PRED ; } public Quantifier ( ) { } public Quantifier ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( boolean [ ] b ) { int t = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] ) { t ++ ; } } return evaluate ( t , b . length - t ) ; } public boolean evaluate ( int t , int f ) { int index = getIndex ( ) ; if ( index == - 1 ) { throw new BuildException ( "Quantifier value not set." ) ; } return PREDS [ index ] . eval ( t , f ) ; } } 	0	['6', '2', '0', '9', '16', '11', '1', '8', '5', '0.95', '195', '0.583333333', '11', '0.727272727', '0.4', '1', '1', '29.5', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; public abstract class ClearCase extends Task { private String mClearToolDir = "" ; private String mviewPath = null ; private String mobjSelect = null ; private static int pcnt = 0 ; private boolean mFailonerr = true ; public final void setClearToolDir ( String dir ) { mClearToolDir = FileUtils . translatePath ( dir ) ; } protected final String getClearToolCommand ( ) { String toReturn = mClearToolDir ; if ( ! toReturn . equals ( "" ) && ! toReturn . endsWith ( "/" ) ) { toReturn += "/" ; } toReturn += CLEARTOOL_EXE ; return toReturn ; } public final void setViewPath ( String viewPath ) { mviewPath = viewPath ; } public String getViewPath ( ) { return mviewPath ; } public String getViewPathBasename ( ) { return ( new File ( mviewPath ) ) . getName ( ) ; } public final void setObjSelect ( String objSelect ) { mobjSelect = objSelect ; } public String getObjSelect ( ) { return mobjSelect ; } protected int run ( Commandline cmd ) { try { Project aProj = getProject ( ) ; Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( aProj ) ; exe . setWorkingDirectory ( aProj . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected String runS ( Commandline cmdline ) { String outV = "opts.cc.runS.output" + pcnt ++ ; ExecTask exe = new ExecTask ( this ) ; Commandline . Argument arg = exe . createArg ( ) ; exe . setExecutable ( cmdline . getExecutable ( ) ) ; arg . setLine ( Commandline . toString ( cmdline . getArguments ( ) ) ) ; exe . setOutputproperty ( outV ) ; exe . execute ( ) ; return getProject ( ) . getProperty ( outV ) ; } public void setFailOnErr ( boolean failonerr ) { mFailonerr = failonerr ; } public boolean getFailOnErr ( ) { return mFailonerr ; } private static final String CLEARTOOL_EXE = "cleartool" ; public static final String COMMAND_UPDATE = "update" ; public static final String COMMAND_CHECKOUT = "checkout" ; public static final String COMMAND_CHECKIN = "checkin" ; public static final String COMMAND_UNCHECKOUT = "uncheckout" ; public static final String COMMAND_LOCK = "lock" ; public static final String COMMAND_UNLOCK = "unlock" ; public static final String COMMAND_MKBL = "mkbl" ; public static final String COMMAND_MKLABEL = "mklabel" ; public static final String COMMAND_MKLBTYPE = "mklbtype" ; public static final String COMMAND_RMTYPE = "rmtype" ; public static final String COMMAND_LSCO = "lsco" ; public static final String COMMAND_MKELEM = "mkelem" ; public static final String COMMAND_MKATTR = "mkattr" ; public static final String COMMAND_MKDIR = "mkdir" ; } 	0	['13', '3', '13', '24', '45', '46', '13', '11', '9', '1.020833333', '189', '0.3', '0', '0.770833333', '0.375', '0', '0', '12', '3', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUnlock extends ClearCase { private String mComment = null ; private String mPname = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UNLOCK ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getOpType ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { getCommentCommand ( cmd ) ; if ( getObjSelect ( ) == null && getPname ( ) == null ) { throw new BuildException ( "Should select either an element " + "(pname) or an object (objselect)" ) ; } getPnameCommand ( cmd ) ; if ( getObjSelect ( ) != null ) { cmd . createArgument ( ) . setValue ( getObjSelect ( ) ) ; } } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setPname ( String pname ) { mPname = pname ; } public String getPname ( ) { return mPname ; } public void setObjselect ( String objselect ) { setObjSelect ( objselect ) ; } public void setObjSel ( String objsel ) { setObjSelect ( objsel ) ; } public String getObjselect ( ) { return getObjSelect ( ) ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getPnameCommand ( Commandline cmd ) { if ( getPname ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_PNAME ) ; cmd . createArgument ( ) . setValue ( getPname ( ) ) ; } } private String getOpType ( ) { if ( getPname ( ) != null ) { return getPname ( ) ; } else { return getObjSelect ( ) ; } } public static final String FLAG_COMMENT = "-comment" ; public static final String FLAG_PNAME = "-pname" ; } 	0	['13', '4', '0', '7', '37', '66', '0', '7', '9', '0.875', '184', '0.5', '0', '0.8', '0.512820513', '2', '3', '12.84615385', '4', '1.3846', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . ResourceCollection ; public class ResourceCount extends Task implements Condition { private static final String ONE_NESTED_MESSAGE = "ResourceCount can count resources from exactly one nested ResourceCollection." ; private static final String COUNT_REQUIRED = "Use of the ResourceCount condition requires that the count attribute be set." ; private ResourceCollection rc ; private Comparison when = Comparison . EQUAL ; private Integer count ; private String property ; public void add ( ResourceCollection r ) { if ( rc != null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } rc = r ; } public void setRefid ( Reference r ) { Object o = r . getReferencedObject ( ) ; if ( ! ( o instanceof ResourceCollection ) ) { throw new BuildException ( r . getRefId ( ) + " doesn\'t denote a ResourceCollection" ) ; } add ( ( ResourceCollection ) o ) ; } public void execute ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( property == null ) { log ( "resource count = " + rc . size ( ) ) ; } else { getProject ( ) . setNewProperty ( property , Integer . toString ( rc . size ( ) ) ) ; } } public boolean eval ( ) { if ( rc == null ) { throw new BuildException ( ONE_NESTED_MESSAGE ) ; } if ( count == null ) { throw new BuildException ( COUNT_REQUIRED ) ; } return when . evaluate ( new Integer ( rc . size ( ) ) . compareTo ( count ) ) ; } public void setCount ( int c ) { count = new Integer ( c ) ; } public void setWhen ( Comparison c ) { when = c ; } public void setProperty ( String p ) { property = p ; } } 	0	['8', '3', '0', '7', '25', '12', '0', '7', '8', '0.880952381', '133', '1', '2', '0.840909091', '0.270833333', '1', '1', '14.875', '3', '1.625', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class ScriptRunnerCreator { private static final String AUTO = "auto" ; private static final String OATAU = "org.apache.tools.ant.util" ; private static final String UTIL_OPT = OATAU + ".optional" ; private static final String BSF = "bsf" ; private static final String BSF_PACK = "org.apache.bsf" ; private static final String BSF_MANAGER = BSF_PACK + ".BSFManager" ; private static final String BSF_RUNNER = UTIL_OPT + ".ScriptRunner" ; private static final String JAVAX = "javax" ; private static final String JAVAX_MANAGER = "javax.script.ScriptEngineManager" ; private static final String JAVAX_RUNNER = UTIL_OPT + ".JavaxScriptRunner" ; private Project project ; private String manager ; private String language ; private ClassLoader scriptLoader = null ; public ScriptRunnerCreator ( Project project ) { this . project = project ; } public ScriptRunnerBase createRunner ( String manager , String language , ClassLoader classLoader ) { this . manager = manager ; this . language = language ; this . scriptLoader = classLoader ; if ( language == null ) { throw new BuildException ( "script language must be specified" ) ; } if ( ! manager . equals ( AUTO ) && ! manager . equals ( JAVAX ) && ! manager . equals ( BSF ) ) { throw new BuildException ( "Unsupported language prefix " + manager ) ; } ScriptRunnerBase ret = null ; ret = createRunner ( BSF , BSF_MANAGER , BSF_RUNNER ) ; if ( ret == null ) { ret = createRunner ( JAVAX , JAVAX_MANAGER , JAVAX_RUNNER ) ; } if ( ret != null ) { return ret ; } if ( JAVAX . equals ( manager ) ) { throw new BuildException ( "Unable to load the script engine manager " + "(" + JAVAX_MANAGER + ")" ) ; } else if ( BSF . equals ( manager ) ) { throw new BuildException ( "Unable to load the BSF script engine manager " + "(" + BSF_MANAGER + ")" ) ; } else { throw new BuildException ( "Unable to load a script engine manager " + "(" + BSF_MANAGER + " or " + JAVAX_MANAGER + ")" ) ; } } private ScriptRunnerBase createRunner ( String checkManager , String managerClass , String runnerClass ) { ScriptRunnerBase runner = null ; if ( ! manager . equals ( AUTO ) && ! manager . equals ( checkManager ) ) { return null ; } if ( scriptLoader . getResource ( LoaderUtils . classNameToResource ( managerClass ) ) == null ) { return null ; } try { runner = ( ScriptRunnerBase ) Class . forName ( runnerClass , true , scriptLoader ) . newInstance ( ) ; runner . setProject ( project ) ; } catch ( Exception ex ) { ReflectUtil . throwBuildException ( ex ) ; } runner . setLanguage ( language ) ; runner . setScriptClassLoader ( scriptLoader ) ; return runner ; } } 	0	['3', '1', '0', '6', '17', '0', '1', '5', '2', '1.142857143', '156', '1', '1', '0', '0.583333333', '0', '0', '46.33333333', '9', '4.3333', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . ResourceUtils ; public class Content extends ResourceComparator { private boolean binary = true ; public void setBinary ( boolean b ) { binary = b ; } public boolean isBinary ( ) { return binary ; } protected int resourceCompare ( Resource foo , Resource bar ) { try { return ResourceUtils . compareContent ( foo , bar , ! binary ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } } 	0	['4', '4', '0', '4', '7', '0', '0', '4', '3', '0', '34', '1', '0', '0.918918919', '0.5', '1', '1', '7.25', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . UserInfo ; import com . jcraft . jsch . UIKeyboardInteractive ; public class SSHUserInfo implements UserInfo , UIKeyboardInteractive { private String name ; private String password = null ; private String keyfile ; private String passphrase = null ; private boolean trustAllCertificates ; public SSHUserInfo ( ) { super ( ) ; this . trustAllCertificates = false ; } public SSHUserInfo ( String password , boolean trustAllCertificates ) { super ( ) ; this . password = password ; this . trustAllCertificates = trustAllCertificates ; } public String getName ( ) { return name ; } public String getPassphrase ( String message ) { return passphrase ; } public String getPassword ( ) { return password ; } public boolean prompt ( String str ) { return false ; } public boolean retry ( ) { return false ; } public void setName ( String name ) { this . name = name ; } public void setPassphrase ( String passphrase ) { this . passphrase = passphrase ; } public void setPassword ( String password ) { this . password = password ; } public void setTrust ( boolean trust ) { this . trustAllCertificates = trust ; } public boolean getTrust ( ) { return this . trustAllCertificates ; } public String getPassphrase ( ) { return passphrase ; } public String getKeyfile ( ) { return keyfile ; } public void setKeyfile ( String keyfile ) { this . keyfile = keyfile ; } public boolean promptPassphrase ( String message ) { return true ; } public boolean promptPassword ( String passwordPrompt ) { return true ; } public boolean promptYesNo ( String message ) { return trustAllCertificates ; } public void showMessage ( String message ) { } public String [ ] promptKeyboardInteractive ( String destination , String name , String instruction , String [ ] prompt , boolean [ ] echo ) { if ( prompt . length != 1 || echo [ 0 ] || this . password == null ) { return null ; } String [ ] response = new String [ 1 ] ; response [ 0 ] = this . password ; return response ; } } 	0	['20', '1', '0', '5', '21', '130', '3', '2', '20', '0.852631579', '125', '1', '0', '0', '0.36', '0', '0', '5', '4', '1.05', '0']
package org . apache . tools . ant . util ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . FileWriter ; import java . io . BufferedWriter ; import java . util . Vector ; import org . apache . tools . ant . taskdefs . condition . Os ; public final class JavaEnvUtils { private JavaEnvUtils ( ) { } private static final boolean IS_DOS = Os . isFamily ( "dos" ) ; private static final boolean IS_NETWARE = Os . isName ( "netware" ) ; private static final boolean IS_AIX = Os . isName ( "aix" ) ; private static final String JAVA_HOME = System . getProperty ( "java.home" ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static String javaVersion ; private static int javaVersionNumber ; public static final String JAVA_1_0 = "1.0" ; public static final String JAVA_1_1 = "1.1" ; public static final String JAVA_1_2 = "1.2" ; public static final String JAVA_1_3 = "1.3" ; public static final String JAVA_1_4 = "1.4" ; public static final String JAVA_1_5 = "1.5" ; public static final String JAVA_1_6 = "1.6" ; private static boolean kaffeDetected ; private static Vector jrePackages ; static { try { javaVersion = JAVA_1_0 ; javaVersionNumber = 10 ; Class . forName ( "java.lang.Void" ) ; javaVersion = JAVA_1_1 ; javaVersionNumber ++ ; Class . forName ( "java.lang.ThreadLocal" ) ; javaVersion = JAVA_1_2 ; javaVersionNumber ++ ; Class . forName ( "java.lang.StrictMath" ) ; javaVersion = JAVA_1_3 ; javaVersionNumber ++ ; Class . forName ( "java.lang.CharSequence" ) ; javaVersion = JAVA_1_4 ; javaVersionNumber ++ ; Class . forName ( "java.net.Proxy" ) ; javaVersion = JAVA_1_5 ; javaVersionNumber ++ ; Class . forName ( "java.util.ServiceLoader" ) ; javaVersion = JAVA_1_6 ; javaVersionNumber ++ ; } catch ( Throwable t ) { } kaffeDetected = false ; try { Class . forName ( "kaffe.util.NotImplemented" ) ; kaffeDetected = true ; } catch ( Throwable t ) { } } public static String getJavaVersion ( ) { return javaVersion ; } public static int getJavaVersionNumber ( ) { return javaVersionNumber ; } public static boolean isJavaVersion ( String version ) { return javaVersion . equals ( version ) ; } public static boolean isAtLeastJavaVersion ( String version ) { return javaVersion . compareTo ( version ) >= 0 ; } public static boolean isKaffe ( ) { return kaffeDetected ; } public static String getJreExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return addExtension ( command ) ; } } public static String getJdkExecutable ( String command ) { if ( IS_NETWARE ) { return command ; } File jExecutable = null ; if ( IS_AIX ) { jExecutable = findInDir ( JAVA_HOME + "/../sh" , command ) ; } if ( jExecutable == null ) { jExecutable = findInDir ( JAVA_HOME + "/../bin" , command ) ; } if ( jExecutable != null ) { return jExecutable . getAbsolutePath ( ) ; } else { return getJreExecutable ( command ) ; } } private static String addExtension ( String command ) { return command + ( IS_DOS ? ".exe" : "" ) ; } private static File findInDir ( String dirName , String commandName ) { File dir = FILE_UTILS . normalize ( dirName ) ; File executable = null ; if ( dir . exists ( ) ) { executable = new File ( dir , addExtension ( commandName ) ) ; if ( ! executable . exists ( ) ) { executable = null ; } } return executable ; } private static void buildJrePackages ( ) { jrePackages = new Vector ( ) ; switch ( javaVersionNumber ) { case 16 : case 15 : jrePackages . addElement ( "com.sun.org.apache" ) ; case 14 : if ( javaVersionNumber == 14 ) { jrePackages . addElement ( "org.apache.crimson" ) ; jrePackages . addElement ( "org.apache.xalan" ) ; jrePackages . addElement ( "org.apache.xml" ) ; jrePackages . addElement ( "org.apache.xpath" ) ; } jrePackages . addElement ( "org.ietf.jgss" ) ; jrePackages . addElement ( "org.w3c.dom" ) ; jrePackages . addElement ( "org.xml.sax" ) ; case 13 : jrePackages . addElement ( "org.omg" ) ; jrePackages . addElement ( "com.sun.corba" ) ; jrePackages . addElement ( "com.sun.jndi" ) ; jrePackages . addElement ( "com.sun.media" ) ; jrePackages . addElement ( "com.sun.naming" ) ; jrePackages . addElement ( "com.sun.org.omg" ) ; jrePackages . addElement ( "com.sun.rmi" ) ; jrePackages . addElement ( "sunw.io" ) ; jrePackages . addElement ( "sunw.util" ) ; case 12 : jrePackages . addElement ( "com.sun.java" ) ; jrePackages . addElement ( "com.sun.image" ) ; case 11 : default : jrePackages . addElement ( "sun" ) ; jrePackages . addElement ( "java" ) ; jrePackages . addElement ( "javax" ) ; break ; } } public static Vector getJrePackageTestCases ( ) { Vector tests = new Vector ( ) ; tests . addElement ( "java.lang.Object" ) ; switch ( javaVersionNumber ) { case 16 : case 15 : tests . addElement ( "com.sun.org.apache.xerces.internal.jaxp.datatype.DatatypeFactoryImpl " ) ; case 14 : tests . addElement ( "sun.audio.AudioPlayer" ) ; if ( javaVersionNumber == 14 ) { tests . addElement ( "org.apache.crimson.parser.ContentModel" ) ; tests . addElement ( "org.apache.xalan.processor.ProcessorImport" ) ; tests . addElement ( "org.apache.xml.utils.URI" ) ; tests . addElement ( "org.apache.xpath.XPathFactory" ) ; } tests . addElement ( "org.ietf.jgss.Oid" ) ; tests . addElement ( "org.w3c.dom.Attr" ) ; tests . addElement ( "org.xml.sax.XMLReader" ) ; case 13 : tests . addElement ( "org.omg.CORBA.Any" ) ; tests . addElement ( "com.sun.corba.se.internal.corba.AnyImpl" ) ; tests . addElement ( "com.sun.jndi.ldap.LdapURL" ) ; tests . addElement ( "com.sun.media.sound.Printer" ) ; tests . addElement ( "com.sun.naming.internal.VersionHelper" ) ; tests . addElement ( "com.sun.org.omg.CORBA.Initializer" ) ; tests . addElement ( "sunw.io.Serializable" ) ; tests . addElement ( "sunw.util.EventListener" ) ; case 12 : tests . addElement ( "javax.accessibility.Accessible" ) ; tests . addElement ( "sun.misc.BASE64Encoder" ) ; tests . addElement ( "com.sun.image.codec.jpeg.JPEGCodec" ) ; case 11 : default : tests . addElement ( "sun.reflect.SerializationConstructorAccessorImpl" ) ; tests . addElement ( "sun.net.www.http.HttpClient" ) ; tests . addElement ( "sun.audio.AudioPlayer" ) ; break ; } return tests ; } public static Vector getJrePackages ( ) { if ( jrePackages == null ) { buildJrePackages ( ) ; } return jrePackages ; } public static File createVmsJavaOptionFile ( String [ ] cmd ) throws IOException { File script = FILE_UTILS . createTempFile ( "ANT" , ".JAVA_OPTS" , null ) ; PrintWriter out = null ; try { out = new PrintWriter ( new BufferedWriter ( new FileWriter ( script ) ) ) ; for ( int i = 0 ; i < cmd . length ; i ++ ) { out . println ( cmd [ i ] ) ; } } finally { FileUtils . close ( out ) ; } return script ; } public static String getJavaHome ( ) { return JAVA_HOME ; } } 	0	['16', '1', '0', '29', '40', '72', '27', '2', '11', '0.929166667', '463', '0.5625', '1', '0', '0.177777778', '0', '0', '26.9375', '5', '1.9375', '0']
package org . apache . tools . ant . util ; public class XmlConstants { public static final String PROPERTY_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-schemaLocation" ; public static final String PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION = "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation" ; public static final String FEATURE_XSD_FULL_VALIDATION = "http://apache.org/xml/features/validation/schema-full-checking" ; public static final String FEATURE_XSD = "http://apache.org/xml/features/validation/schema" ; public static final String FEATURE_VALIDATION = "http://xml.org/sax/features/validation" ; public static final String FEATURE_NAMESPACES = "http://xml.org/sax/features/namespaces" ; public static final String FEATURE_JAXP12_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage" ; public static final String FEATURE_JAXP12_SCHEMA_SOURCE = "http://java.sun.com/xml/jaxp/properties/schemaSource" ; public static final String URI_XSD = "http://www.w3.org/2001/XMLSchema" ; public static final String FEATURE_EXTERNAL_ENTITIES = "http://xml.org/sax/features/external-general-entities" ; public static final String FEATURE_DISALLOW_DTD = "http://apache.org/xml/features/disallow-doctype-decl" ; } 	0	['1', '1', '0', '0', '2', '0', '0', '0', '1', '2', '15', '0', '0', '0', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public interface ExtensionResolver { File resolve ( Extension extension , Project project ) throws BuildException ; } 	0	['1', '1', '0', '7', '1', '0', '4', '3', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . tar ; public class TarUtils { public static long parseOctal ( byte [ ] header , int offset , int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } if ( header [ i ] == ( byte ) ' ' || header [ i ] == '0' ) { if ( stillPadding ) { continue ; } if ( header [ i ] == ( byte ) ' ' ) { break ; } } stillPadding = false ; result = ( result << 3 ) + ( header [ i ] - '0' ) ; } return result ; } public static StringBuffer parseName ( byte [ ] header , int offset , int length ) { StringBuffer result = new StringBuffer ( length ) ; int end = offset + length ; for ( int i = offset ; i < end ; ++ i ) { if ( header [ i ] == 0 ) { break ; } result . append ( ( char ) header [ i ] ) ; } return result ; } public static int getNameBytes ( StringBuffer name , byte [ ] buf , int offset , int length ) { int i ; for ( i = 0 ; i < length && i < name . length ( ) ; ++ i ) { buf [ offset + i ] = ( byte ) name . charAt ( i ) ; } for ( ; i < length ; ++ i ) { buf [ offset + i ] = 0 ; } return offset + length ; } public static int getOctalBytes ( long value , byte [ ] buf , int offset , int length ) { int idx = length - 1 ; buf [ offset + idx ] = 0 ; -- idx ; buf [ offset + idx ] = ( byte ) ' ' ; -- idx ; if ( value == 0 ) { buf [ offset + idx ] = ( byte ) '0' ; -- idx ; } else { for ( long val = value ; idx >= 0 && val > 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ( ( byte ) '0' + ( byte ) ( val & 7 ) ) ; val = val > > 3 ; } } for ( ; idx >= 0 ; -- idx ) { buf [ offset + idx ] = ( byte ) ' ' ; } return offset + length ; } public static int getLongOctalBytes ( long value , byte [ ] buf , int offset , int length ) { byte [ ] temp = new byte [ length + 1 ] ; getOctalBytes ( value , temp , 0 , length + 1 ) ; System . arraycopy ( temp , 0 , buf , offset , length ) ; return offset + length ; } public static int getCheckSumOctalBytes ( long value , byte [ ] buf , int offset , int length ) { getOctalBytes ( value , buf , offset , length ) ; buf [ offset + length - 1 ] = ( byte ) ' ' ; buf [ offset + length - 2 ] = 0 ; return offset + length ; } public static long computeCheckSum ( byte [ ] buf ) { long sum = 0 ; for ( int i = 0 ; i < buf . length ; ++ i ) { sum += 255 & buf [ i ] ; } return sum ; } } 	0	['8', '1', '0', '1', '14', '28', '1', '0', '8', '2', '271', '0', '0', '0', '0.45', '0', '0', '32.875', '7', '2.875', '0']
package org . apache . tools . zip ; public interface UnixStat { int PERM_MASK = 07777 ; int LINK_FLAG = 0120000 ; int FILE_FLAG = 0100000 ; int DIR_FLAG = 040000 ; int DEFAULT_LINK_PERM = 0777 ; int DEFAULT_DIR_PERM = 0755 ; int DEFAULT_FILE_PERM = 0644 ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '7', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Type implements ResourceSelector { private static final String FILE_ATTR = "file" ; private static final String DIR_ATTR = "dir" ; public static final Type FILE = new Type ( new FileDir ( FILE_ATTR ) ) ; public static final Type DIR = new Type ( new FileDir ( DIR_ATTR ) ) ; public static class FileDir extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { FILE_ATTR , DIR_ATTR } ; public FileDir ( ) { } public FileDir ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } } private FileDir type = null ; public Type ( ) { } public Type ( FileDir fd ) { setType ( fd ) ; } public void setType ( FileDir fd ) { type = fd ; } public boolean isSelected ( Resource r ) { if ( type == null ) { throw new BuildException ( "The type attribute is required." ) ; } int i = type . getIndex ( ) ; return r . isDirectory ( ) ? i == 1 : i == 0 ; } } 	0	['5', '1', '0', '6', '10', '0', '2', '4', '4', '0.9', '74', '0.6', '3', '0', '0.583333333', '0', '0', '12.8', '5', '1.2', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . StringTokenizer ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class FileList extends DataType implements ResourceCollection { private Vector filenames = new Vector ( ) ; private File dir ; public FileList ( ) { super ( ) ; } protected FileList ( FileList filelist ) { this . dir = filelist . dir ; this . filenames = filelist . filenames ; setProject ( filelist . getProject ( ) ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ( dir != null ) || ( filenames . size ( ) != 0 ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setDir ( File dir ) throws BuildException { checkAttributesAllowed ( ) ; this . dir = dir ; } public File getDir ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDir ( p ) ; } return dir ; } public void setFiles ( String filenames ) { checkAttributesAllowed ( ) ; if ( filenames != null && filenames . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( filenames , ", \t\n\r\f" , false ) ; while ( tok . hasMoreTokens ( ) ) { this . filenames . addElement ( tok . nextToken ( ) ) ; } } } public String [ ] getFiles ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getFiles ( p ) ; } if ( dir == null ) { throw new BuildException ( "No directory specified for filelist." ) ; } if ( filenames . size ( ) == 0 ) { throw new BuildException ( "No files specified for filelist." ) ; } String [ ] result = new String [ filenames . size ( ) ] ; filenames . copyInto ( result ) ; return result ; } protected FileList getRef ( Project p ) { return ( FileList ) getCheckedRef ( p ) ; } public static class FileName { private String name ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public void addConfiguredFile ( FileName name ) { if ( name . getName ( ) == null ) { throw new BuildException ( "No name specified in nested file element" ) ; } filenames . addElement ( name . getName ( ) ) ; } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( dir , ( String [ ] ) ( filenames . toArray ( new String [ filenames . size ( ) ] ) ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileList ) getRef ( getProject ( ) ) ) . size ( ) ; } return filenames . size ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } 	0	['12', '3', '0', '13', '32', '0', '6', '7', '10', '0.454545455', '192', '1', '0', '0.75', '0.238095238', '1', '1', '14.83333333', '4', '1.6667', '0']
package org . apache . tools . ant ; public class ExitException extends SecurityException { private int status ; public ExitException ( int status ) { super ( "ExitException: status " + status ) ; this . status = status ; } public ExitException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['3', '5', '0', '3', '7', '0', '3', '0', '3', '0', '27', '1', '0', '0.928571429', '0.666666667', '0', '0', '7.666666667', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . net ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class MimeMail extends EmailTask { public void execute ( ) throws BuildException { log ( "DEPRECATED - The " + getTaskName ( ) + " task is deprecated. " + "Use the mail task instead." ) ; super . execute ( ) ; } } 	0	['2', '4', '0', '2', '9', '1', '0', '2', '2', '2', '22', '0', '0', '0.985507246', '1', '1', '1', '10', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class IntegerCPInfo extends ConstantCPInfo { public IntegerCPInfo ( ) { super ( CONSTANT_INTEGER , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Integer ( cpStream . readInt ( ) ) ) ; } public String toString ( ) { return "Integer Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . StringUtils ; public class P4Labelsync extends P4Base { protected String name ; private boolean add ; private boolean delete ; private boolean simulationmode ; public boolean isAdd ( ) { return add ; } public void setAdd ( boolean add ) { this . add = add ; } public boolean isDelete ( ) { return delete ; } public void setDelete ( boolean delete ) { this . delete = delete ; } public void setName ( String name ) { this . name = name ; } public boolean isSimulationmode ( ) { return simulationmode ; } public void setSimulationmode ( boolean simulationmode ) { this . simulationmode = simulationmode ; } public void execute ( ) throws BuildException { log ( "P4Labelsync exec:" , Project . MSG_INFO ) ; if ( P4View != null && P4View . length ( ) >= 1 ) { P4View = StringUtils . replace ( P4View , ":" , "\n\t" ) ; P4View = StringUtils . replace ( P4View , ";" , "\n\t" ) ; } if ( P4View == null ) { P4View = "" ; } if ( name == null || name . length ( ) < 1 ) { throw new BuildException ( "name attribute is compulsory for labelsync" ) ; } if ( this . isSimulationmode ( ) ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . isDelete ( ) ) { P4CmdOpts = P4CmdOpts + " -d" ; } if ( this . isAdd ( ) ) { P4CmdOpts = P4CmdOpts + " -a" ; } execP4Command ( "-s labelsync -l " + name + " " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['9', '4', '0', '5', '20', '28', '0', '5', '9', '0.78125', '156', '1', '0', '0.86440678', '0.481481481', '2', '2', '15.88888889', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; public class VisualBasicCompile extends DotnetCompile { private boolean removeIntChecks = false ; private boolean optionExplicit = false ; private boolean optionStrict = false ; private String optionCompare ; private String rootNamespace ; private String imports ; public VisualBasicCompile ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; imports = null ; rootNamespace = null ; optionCompare = null ; optionExplicit = false ; optionStrict = false ; removeIntChecks = false ; setExecutable ( "vbc" ) ; } protected String getWin32ResParameter ( ) { if ( getWin32Res ( ) != null ) { return "/win32resource:" + getWin32Res ( ) . toString ( ) ; } else { return null ; } } public void setRemoveIntChecks ( boolean flag ) { removeIntChecks = flag ; } public boolean getRemoveIntChecks ( ) { return removeIntChecks ; } public String getRemoveIntChecksParameter ( ) { return "/removeintchecks" + ( removeIntChecks ? "+" : "-" ) ; } public void setOptionExplicit ( boolean flag ) { optionExplicit = flag ; } public boolean getOptionExplicit ( ) { return optionExplicit ; } public String getOptionExplicitParameter ( ) { return "/optionexplicit" + ( optionExplicit ? "+" : "-" ) ; } public void setOptionStrict ( boolean flag ) { optionStrict = flag ; } public boolean getOptionStrict ( ) { return optionStrict ; } public String getOptionStrictParameter ( ) { return "/optionstrict" + ( optionStrict ? "+" : "-" ) ; } public void setRootNamespace ( String rootNamespace ) { this . rootNamespace = rootNamespace ; } public String getRootNamespace ( ) { return this . rootNamespace ; } protected String getRootNamespaceParameter ( ) { if ( rootNamespace != null && rootNamespace . length ( ) != 0 ) { return "/rootnamespace:" + rootNamespace ; } else { return null ; } } public void setImports ( String imports ) { this . imports = imports ; } public String getImports ( ) { return this . imports ; } protected String getImportsParameter ( ) { if ( imports != null && imports . length ( ) != 0 ) { return "/imports:" + imports ; } else { return null ; } } public void setOptionCompare ( String optionCompare ) { if ( "text" . equalsIgnoreCase ( optionCompare ) ) { this . optionCompare = "text" ; } else { this . optionCompare = "binary" ; } } public String getOptionCompare ( ) { return this . optionCompare ; } protected String getOptionCompareParameter ( ) { if ( optionCompare != null && "text" . equalsIgnoreCase ( optionCompare ) ) { return "/optioncompare:text" ; } else { return "/optioncompare:binary" ; } } protected void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getRemoveIntChecksParameter ( ) ) ; command . addArgument ( getImportsParameter ( ) ) ; command . addArgument ( getOptionExplicitParameter ( ) ) ; command . addArgument ( getOptionStrictParameter ( ) ) ; command . addArgument ( getRootNamespaceParameter ( ) ) ; command . addArgument ( getOptionCompareParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return "," ; } public String getFileExtension ( ) { return "vb" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , false ) ; } protected void validate ( ) throws BuildException { super . validate ( ) ; if ( getDestFile ( ) == null ) { throw new BuildException ( "DestFile was not specified" ) ; } } } 	0	['26', '6', '0', '5', '42', '233', '0', '5', '19', '0.8', '269', '1', '0', '0.857142857', '0.269230769', '1', '7', '9.115384615', '3', '1.3846', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . Iterator ; import java . util . Vector ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class JarLibAvailableTask extends Task { private File libraryFile ; private final Vector extensionFileSets = new Vector ( ) ; private String propertyName ; private ExtensionAdapter requiredExtension ; public void setProperty ( final String property ) { this . propertyName = property ; } public void setFile ( final File file ) { this . libraryFile = file ; } public void addConfiguredExtension ( final ExtensionAdapter extension ) { if ( null != requiredExtension ) { final String message = "Can not specify extension to " + "search for multiple times." ; throw new BuildException ( message ) ; } requiredExtension = extension ; } public void addConfiguredExtensionSet ( final ExtensionSet extensionSet ) { extensionFileSets . addElement ( extensionSet ) ; } public void execute ( ) throws BuildException { validate ( ) ; final Extension test = requiredExtension . toExtension ( ) ; if ( ! extensionFileSets . isEmpty ( ) ) { final Iterator iterator = extensionFileSets . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ExtensionSet extensionSet = ( ExtensionSet ) iterator . next ( ) ; final Extension [ ] extensions = extensionSet . toExtensions ( getProject ( ) ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } else { final Manifest manifest = ExtensionUtil . getManifest ( libraryFile ) ; final Extension [ ] extensions = Extension . getAvailable ( manifest ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( test ) ) { getProject ( ) . setNewProperty ( propertyName , "true" ) ; } } } } private void validate ( ) throws BuildException { if ( null == requiredExtension ) { final String message = "Extension element must be specified." ; throw new BuildException ( message ) ; } if ( null == libraryFile && extensionFileSets . isEmpty ( ) ) { final String message = "File attribute not specified." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . exists ( ) ) { final String message = "File '" + libraryFile + "' does not exist." ; throw new BuildException ( message ) ; } if ( null != libraryFile && ! libraryFile . isFile ( ) ) { final String message = "\'" + libraryFile + "\' is not a file." ; throw new BuildException ( message ) ; } } } 	0	['7', '3', '0', '7', '28', '0', '0', '7', '6', '0.666666667', '191', '1', '1', '0.860465116', '0.314285714', '0', '0', '25.71428571', '2', '1', '0']
package org . apache . tools . ant ; public interface DynamicElement { Object createDynamicElement ( String name ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . email ; public class Header { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } 	0	['5', '1', '0', '3', '6', '6', '3', '0', '5', '0.75', '24', '1', '0', '0', '0.7', '0', '0', '3.4', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . StringTokenizer ; import java . util . TimeZone ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class Tstamp extends Task { private Vector customFormats = new Vector ( ) ; private String prefix = "" ; public void setPrefix ( String prefix ) { this . prefix = prefix ; if ( ! this . prefix . endsWith ( "." ) ) { this . prefix += "." ; } } public void execute ( ) throws BuildException { try { Date d = new Date ( ) ; Enumeration i = customFormats . elements ( ) ; while ( i . hasMoreElements ( ) ) { CustomFormat cts = ( CustomFormat ) i . nextElement ( ) ; cts . execute ( getProject ( ) , d , getLocation ( ) ) ; } SimpleDateFormat dstamp = new SimpleDateFormat ( "yyyyMMdd" ) ; setProperty ( "DSTAMP" , dstamp . format ( d ) ) ; SimpleDateFormat tstamp = new SimpleDateFormat ( "HHmm" ) ; setProperty ( "TSTAMP" , tstamp . format ( d ) ) ; SimpleDateFormat today = new SimpleDateFormat ( "MMMM d yyyy" , Locale . US ) ; setProperty ( "TODAY" , today . format ( d ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public CustomFormat createFormat ( ) { CustomFormat cts = new CustomFormat ( ) ; customFormats . addElement ( cts ) ; return cts ; } private void setProperty ( String name , String value ) { getProject ( ) . setNewProperty ( prefix + name , value ) ; } public class CustomFormat { private TimeZone timeZone ; private String propertyName ; private String pattern ; private String language ; private String country ; private String variant ; private int offset = 0 ; private int field = Calendar . DATE ; public CustomFormat ( ) { } public void setProperty ( String propertyName ) { this . propertyName = propertyName ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setLocale ( String locale ) { StringTokenizer st = new StringTokenizer ( locale , " \t\n\r\f," ) ; try { language = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { country = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { variant = st . nextToken ( ) ; if ( st . hasMoreElements ( ) ) { throw new BuildException ( "bad locale format" , getLocation ( ) ) ; } } } else { country = "" ; } } catch ( NoSuchElementException e ) { throw new BuildException ( "bad locale format" , e , getLocation ( ) ) ; } } public void setTimezone ( String id ) { timeZone = TimeZone . getTimeZone ( id ) ; } public void setOffset ( int offset ) { this . offset = offset ; } public void setUnit ( String unit ) { log ( "DEPRECATED - The setUnit(String) method has been deprecated." + " Use setUnit(Tstamp.Unit) instead." ) ; Unit u = new Unit ( ) ; u . setValue ( unit ) ; field = u . getCalendarField ( ) ; } public void setUnit ( Unit unit ) { field = unit . getCalendarField ( ) ; } public void execute ( Project project , Date date , Location location ) { if ( propertyName == null ) { throw new BuildException ( "property attribute must be provided" , location ) ; } if ( pattern == null ) { throw new BuildException ( "pattern attribute must be provided" , location ) ; } SimpleDateFormat sdf ; if ( language == null ) { sdf = new SimpleDateFormat ( pattern ) ; } else if ( variant == null ) { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country ) ) ; } else { sdf = new SimpleDateFormat ( pattern , new Locale ( language , country , variant ) ) ; } if ( offset != 0 ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . add ( field , offset ) ; date = calendar . getTime ( ) ; } if ( timeZone != null ) { sdf . setTimeZone ( timeZone ) ; } Tstamp . this . setProperty ( propertyName , sdf . format ( date ) ) ; } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Map calendarFields = new HashMap ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	0	['6', '3', '0', '5', '27', '3', '1', '5', '4', '0.4', '135', '1', '0', '0.880952381', '0.5', '0', '0', '21.16666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class SoundTask extends Task { private BuildAlert success = null ; private BuildAlert fail = null ; public BuildAlert createSuccess ( ) { success = new BuildAlert ( ) ; return success ; } public BuildAlert createFail ( ) { fail = new BuildAlert ( ) ; return fail ; } public SoundTask ( ) { } public void init ( ) { } public void execute ( ) { AntSoundPlayer soundPlayer = new AntSoundPlayer ( ) ; if ( success == null ) { log ( "No nested success element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildSuccessfulSound ( success . getSource ( ) , success . getLoops ( ) , success . getDuration ( ) ) ; } if ( fail == null ) { log ( "No nested failure element found." , Project . MSG_WARN ) ; } else { soundPlayer . addBuildFailedSound ( fail . getSource ( ) , fail . getLoops ( ) , fail . getDuration ( ) ) ; } getProject ( ) . addBuildListener ( soundPlayer ) ; } public class BuildAlert { private File source = null ; private int loops = 0 ; private Long duration = null ; public void setDuration ( Long duration ) { this . duration = duration ; } public void setSource ( File source ) { this . source = source ; } public void setLoops ( int loops ) { this . loops = loops ; } public File getSource ( ) { File nofile = null ; if ( source . exists ( ) ) { if ( source . isDirectory ( ) ) { String [ ] entries = source . list ( ) ; Vector files = new Vector ( ) ; for ( int i = 0 ; i < entries . length ; i ++ ) { File f = new File ( source , entries [ i ] ) ; if ( f . isFile ( ) ) { files . addElement ( f ) ; } } if ( files . size ( ) < 1 ) { throw new BuildException ( "No files found in directory " + source ) ; } int numfiles = files . size ( ) ; Random rn = new Random ( ) ; int x = rn . nextInt ( numfiles ) ; this . source = ( File ) files . elementAt ( x ) ; } } else { log ( source + ": invalid path." , Project . MSG_WARN ) ; this . source = nofile ; } return this . source ; } public int getLoops ( ) { return this . loops ; } public Long getDuration ( ) { return this . duration ; } } } 	0	['5', '3', '0', '5', '16', '0', '1', '5', '5', '0.5', '82', '1', '2', '0.902439024', '1', '1', '1', '15', '3', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JJDoc extends Task { private static final String OUTPUT_FILE = "OUTPUT_FILE" ; private static final String TEXT = "TEXT" ; private static final String ONE_TABLE = "ONE_TABLE" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private String outputFile = null ; private boolean plainText = false ; private static final String DEFAULT_SUFFIX_HTML = ".html" ; private static final String DEFAULT_SUFFIX_TEXT = ".txt" ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; public void setText ( boolean plainText ) { optionalAttrs . put ( TEXT , plainText ? Boolean . TRUE : Boolean . FALSE ) ; this . plainText = plainText ; } public void setOnetable ( boolean oneTable ) { optionalAttrs . put ( ONE_TABLE , oneTable ? Boolean . TRUE : Boolean . FALSE ) ; } public void setOutputfile ( String outputFile ) { this . outputFile = outputFile ; } public void setTarget ( File target ) { this . targetFile = target ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JJDoc ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputFile != null ) { cmdl . createArgument ( ) . setValue ( "-" + OUTPUT_FILE + ":" + outputFile . replace ( '\\' , '/' ) ) ; } File javaFile = new File ( createOutputFileName ( targetFile , outputFile , plainText ) ) ; if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JJDOC ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; final Execute process = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_INFO ) , null ) ; log ( cmdl . describeCommand ( ) , Project . MSG_VERBOSE ) ; process . setCommandline ( cmdl . getCommandline ( ) ) ; try { if ( process . execute ( ) != 0 ) { throw new BuildException ( "JJDoc failed." ) ; } } catch ( IOException e ) { throw new BuildException ( "Failed to launch JJDoc" , e ) ; } } private String createOutputFileName ( File destFile , String optionalOutputFile , boolean plain ) { String suffix = DEFAULT_SUFFIX_HTML ; String javaccFile = destFile . getAbsolutePath ( ) . replace ( '\\' , '/' ) ; if ( plain ) { suffix = DEFAULT_SUFFIX_TEXT ; } if ( ( optionalOutputFile == null ) || optionalOutputFile . equals ( "" ) ) { int filePos = javaccFile . lastIndexOf ( "/" ) ; if ( filePos >= 0 ) { javaccFile = javaccFile . substring ( filePos + 1 ) ; } int suffixPos = javaccFile . lastIndexOf ( '.' ) ; if ( suffixPos == - 1 ) { optionalOutputFile = javaccFile + suffix ; } else { String currentSuffix = javaccFile . substring ( suffixPos ) ; if ( currentSuffix . equals ( suffix ) ) { optionalOutputFile = javaccFile + suffix ; } else { optionalOutputFile = javaccFile . substring ( 0 , suffixPos ) + suffix ; } } } else { optionalOutputFile = optionalOutputFile . replace ( '\\' , '/' ) ; } return ( getProject ( ) . getBaseDir ( ) + "/" + optionalOutputFile ) . replace ( '\\' , '/' ) ; } } 	0	['8', '3', '0', '13', '57', '4', '0', '13', '7', '0.909090909', '377', '1', '1', '0.840909091', '0.5', '1', '1', '44.75', '7', '1.875', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Iterator ; public interface Cache { boolean isValid ( ) ; void delete ( ) ; void load ( ) ; void save ( ) ; Object get ( Object key ) ; void put ( Object key , Object value ) ; Iterator iterator ( ) ; } 	0	['7', '1', '0', '2', '7', '21', '2', '0', '7', '2', '7', '0', '0', '0', '0.642857143', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class TarFileSet extends ArchiveFileSet { private boolean userNameSet ; private boolean groupNameSet ; private boolean userIdSet ; private boolean groupIdSet ; private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarFileSet ( ) { super ( ) ; } protected TarFileSet ( FileSet fileset ) { super ( fileset ) ; } protected TarFileSet ( TarFileSet fileset ) { super ( fileset ) ; } public void setUserName ( String userName ) { checkTarFileSetAttributesAllowed ( ) ; userNameSet = true ; this . userName = userName ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public boolean hasUserNameBeenSet ( ) { return userNameSet ; } public void setUid ( int uid ) { checkTarFileSetAttributesAllowed ( ) ; userIdSet = true ; this . uid = uid ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public boolean hasUserIdBeenSet ( ) { return userIdSet ; } public void setGroup ( String groupName ) { checkTarFileSetAttributesAllowed ( ) ; groupNameSet = true ; this . groupName = groupName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public boolean hasGroupBeenSet ( ) { return groupNameSet ; } public void setGid ( int gid ) { checkTarFileSetAttributesAllowed ( ) ; groupIdSet = true ; this . gid = gid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getCheckedRef ( ) ) . getGid ( ) ; } return gid ; } public boolean hasGroupIdBeenSet ( ) { return groupIdSet ; } protected ArchiveScanner newArchiveScanner ( ) { TarScanner zs = new TarScanner ( ) ; return zs ; } public void setRefid ( Reference r ) throws BuildException { if ( userNameSet || userIdSet || groupNameSet || groupIdSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected AbstractFileSet getRef ( Project p ) { dieOnCircularReference ( p ) ; Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof TarFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { TarFileSet zfs = new TarFileSet ( ( FileSet ) o ) ; configureFileSet ( zfs ) ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a tarfileset or a fileset" ; throw new BuildException ( msg ) ; } } protected void configureFileSet ( ArchiveFileSet zfs ) { super . configureFileSet ( zfs ) ; if ( zfs instanceof TarFileSet ) { TarFileSet tfs = ( TarFileSet ) zfs ; tfs . setUserName ( userName ) ; tfs . setGroup ( groupName ) ; tfs . setUid ( uid ) ; tfs . setGid ( gid ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( TarFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } private void checkTarFileSetAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof TarFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	0	['21', '6', '1', '10', '42', '126', '2', '8', '15', '0.7875', '274', '1', '0', '0.871428571', '0.178571429', '5', '19', '11.66666667', '4', '1.381', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; public class JonasDeploymentTool extends GenericDeploymentTool { protected static final String EJB_JAR_1_1_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 1.1//EN" ; protected static final String EJB_JAR_2_0_PUBLIC_ID = "-//Sun Microsystems, Inc.//DTD Enterprise JavaBeans 2.0//EN" ; protected static final String JONAS_EJB_JAR_2_4_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.4//EN" ; protected static final String JONAS_EJB_JAR_2_5_PUBLIC_ID = "-//ObjectWeb//DTD JOnAS 2.5//EN" ; protected static final String RMI_ORB = "RMI" ; protected static final String JEREMIE_ORB = "JEREMIE" ; protected static final String DAVID_ORB = "DAVID" ; protected static final String EJB_JAR_1_1_DTD = "ejb-jar_1_1.dtd" ; protected static final String EJB_JAR_2_0_DTD = "ejb-jar_2_0.dtd" ; protected static final String JONAS_EJB_JAR_2_4_DTD = "jonas-ejb-jar_2_4.dtd" ; protected static final String JONAS_EJB_JAR_2_5_DTD = "jonas-ejb-jar_2_5.dtd" ; protected static final String JONAS_DD = "jonas-ejb-jar.xml" ; protected static final String GENIC_CLASS = "org.objectweb.jonas_ejb.genic.GenIC" ; protected static final String OLD_GENIC_CLASS_1 = "org.objectweb.jonas_ejb.tools.GenWholeIC" ; protected static final String OLD_GENIC_CLASS_2 = "org.objectweb.jonas_ejb.tools.GenIC" ; private String descriptorName ; private String jonasDescriptorName ; private File outputdir ; private boolean keepgenerated = false ; private boolean nocompil = false ; private boolean novalidation = false ; private String javac ; private String javacopts ; private String rmicopts ; private boolean secpropag = false ; private boolean verbose = false ; private String additionalargs ; private File jonasroot ; private boolean keepgeneric = false ; private String suffix = ".jar" ; private String orb ; private boolean nogenic = false ; public void setKeepgenerated ( boolean aBoolean ) { keepgenerated = aBoolean ; } public void setAdditionalargs ( String aString ) { additionalargs = aString ; } public void setNocompil ( boolean aBoolean ) { nocompil = aBoolean ; } public void setNovalidation ( boolean aBoolean ) { novalidation = aBoolean ; } public void setJavac ( String aString ) { javac = aString ; } public void setJavacopts ( String aString ) { javacopts = aString ; } public void setRmicopts ( String aString ) { rmicopts = aString ; } public void setSecpropag ( boolean aBoolean ) { secpropag = aBoolean ; } public void setVerbose ( boolean aBoolean ) { verbose = aBoolean ; } public void setJonasroot ( File aFile ) { jonasroot = aFile ; } public void setKeepgeneric ( boolean aBoolean ) { keepgeneric = aBoolean ; } public void setJarsuffix ( String aString ) { suffix = aString ; } public void setOrb ( String aString ) { orb = aString ; } public void setNogenic ( boolean aBoolean ) { nogenic = aBoolean ; } public void processDescriptor ( String aDescriptorName , SAXParser saxParser ) { descriptorName = aDescriptorName ; log ( "JOnAS Deployment Tool processing: " + descriptorName , Project . MSG_VERBOSE ) ; super . processDescriptor ( descriptorName , saxParser ) ; if ( outputdir != null ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; } } protected void writeJar ( String baseName , File jarfile , Hashtable ejbFiles , String publicId ) throws BuildException { File genericJarFile = super . getVendorOutputJarFile ( baseName ) ; super . writeJar ( baseName , genericJarFile , ejbFiles , publicId ) ; addGenICGeneratedFiles ( genericJarFile , ejbFiles ) ; super . writeJar ( baseName , getVendorOutputJarFile ( baseName ) , ejbFiles , publicId ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { jonasDescriptorName = getJonasDescriptorName ( ) ; File jonasDD = new File ( getConfig ( ) . descriptorDir , jonasDescriptorName ) ; if ( jonasDD . exists ( ) ) { ejbFiles . put ( META_DIR + JONAS_DD , jonasDD ) ; } else { log ( "Unable to locate the JOnAS deployment descriptor. It was expected to be in: " + jonasDD . getPath ( ) + "." , Project . MSG_WARN ) ; } } protected File getVendorOutputJarFile ( String baseName ) { return new File ( getDestDir ( ) , baseName + suffix ) ; } private String getJonasDescriptorName ( ) { String jonasDN ; boolean jonasConvention = false ; String path ; String fileName ; String baseName ; String remainder ; int startOfFileName = descriptorName . lastIndexOf ( File . separatorChar ) ; if ( startOfFileName != - 1 ) { path = descriptorName . substring ( 0 , startOfFileName + 1 ) ; fileName = descriptorName . substring ( startOfFileName + 1 ) ; } else { path = "" ; fileName = descriptorName ; } if ( fileName . startsWith ( EJB_DD ) ) { return path + JONAS_DD ; } int endOfBaseName = descriptorName . indexOf ( getConfig ( ) . baseNameTerminator , startOfFileName ) ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . lastIndexOf ( '.' ) - 1 ; if ( endOfBaseName < 0 ) { endOfBaseName = descriptorName . length ( ) - 1 ; } jonasConvention = true ; } baseName = descriptorName . substring ( startOfFileName + 1 , endOfBaseName + 1 ) ; remainder = descriptorName . substring ( endOfBaseName + 1 ) ; if ( jonasConvention ) { jonasDN = path + "jonas-" + baseName + ".xml" ; } else { jonasDN = path + baseName + "jonas-" + remainder ; } log ( "Standard EJB descriptor name: " + descriptorName , Project . MSG_VERBOSE ) ; log ( "JOnAS-specific descriptor name: " + jonasDN , Project . MSG_VERBOSE ) ; return jonasDN ; } protected String getJarBaseName ( String descriptorFileName ) { String baseName = null ; if ( getConfig ( ) . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { if ( descriptorFileName . indexOf ( getConfig ( ) . baseNameTerminator ) == - 1 ) { String aCanonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int lastSeparatorIndex = aCanonicalDescriptor . lastIndexOf ( '/' ) ; int endOfBaseName ; if ( lastSeparatorIndex != - 1 ) { endOfBaseName = descriptorFileName . indexOf ( ".xml" , lastSeparatorIndex ) ; } else { endOfBaseName = descriptorFileName . indexOf ( ".xml" ) ; } if ( endOfBaseName != - 1 ) { baseName = descriptorFileName . substring ( 0 , endOfBaseName ) ; } } } if ( baseName == null ) { baseName = super . getJarBaseName ( descriptorFileName ) ; } log ( "JAR base name: " + baseName , Project . MSG_VERBOSE ) ; return baseName ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { handler . registerDTD ( EJB_JAR_1_1_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_1_1_DTD ) ; handler . registerDTD ( EJB_JAR_2_0_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + EJB_JAR_2_0_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_4_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_4_DTD ) ; handler . registerDTD ( JONAS_EJB_JAR_2_5_PUBLIC_ID , jonasroot + File . separator + "xml" + File . separator + JONAS_EJB_JAR_2_5_DTD ) ; } private void addGenICGeneratedFiles ( File genericJarFile , Hashtable ejbFiles ) { Java genicTask = null ; String genicClass = null ; if ( nogenic ) { return ; } genicTask = new Java ( getTask ( ) ) ; genicTask . setTaskName ( "genic" ) ; genicTask . setFork ( true ) ; genicTask . createJvmarg ( ) . setValue ( "-Dinstall.root=" + jonasroot ) ; String jonasConfigDir = jonasroot + File . separator + "config" ; File javaPolicyFile = new File ( jonasConfigDir , "java.policy" ) ; if ( javaPolicyFile . exists ( ) ) { genicTask . createJvmarg ( ) . setValue ( "-Djava.security.policy=" + javaPolicyFile . toString ( ) ) ; } try { outputdir = createTempDir ( ) ; } catch ( IOException aIOException ) { String msg = "Cannot create temp dir: " + aIOException . getMessage ( ) ; throw new BuildException ( msg , aIOException ) ; } log ( "Using temporary output directory: " + outputdir , Project . MSG_VERBOSE ) ; genicTask . createArg ( ) . setValue ( "-d" ) ; genicTask . createArg ( ) . setFile ( outputdir ) ; String key ; File f ; Enumeration keys = ejbFiles . keys ( ) ; while ( keys . hasMoreElements ( ) ) { key = ( String ) keys . nextElement ( ) ; f = new File ( outputdir + File . separator + key ) ; f . getParentFile ( ) . mkdirs ( ) ; } log ( "Worked around a bug of GenIC 2.5." , Project . MSG_VERBOSE ) ; Path classpath = getCombinedClasspath ( ) ; if ( classpath == null ) { classpath = new Path ( getTask ( ) . getProject ( ) ) ; } classpath . append ( new Path ( classpath . getProject ( ) , jonasConfigDir ) ) ; classpath . append ( new Path ( classpath . getProject ( ) , outputdir . toString ( ) ) ) ; if ( orb != null ) { String orbJar = jonasroot + File . separator + "lib" + File . separator + orb + "_jonas.jar" ; classpath . append ( new Path ( classpath . getProject ( ) , orbJar ) ) ; } log ( "Using classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; genicTask . setClasspath ( classpath ) ; genicClass = getGenicClassName ( classpath ) ; if ( genicClass == null ) { log ( "Cannot find GenIC class in classpath." , Project . MSG_ERR ) ; throw new BuildException ( "GenIC class not found, please check the classpath." ) ; } else { log ( "Using '" + genicClass + "' GenIC class." , Project . MSG_VERBOSE ) ; genicTask . setClassname ( genicClass ) ; } if ( keepgenerated ) { genicTask . createArg ( ) . setValue ( "-keepgenerated" ) ; } if ( nocompil ) { genicTask . createArg ( ) . setValue ( "-nocompil" ) ; } if ( novalidation ) { genicTask . createArg ( ) . setValue ( "-novalidation" ) ; } if ( javac != null ) { genicTask . createArg ( ) . setValue ( "-javac" ) ; genicTask . createArg ( ) . setLine ( javac ) ; } if ( javacopts != null && ! javacopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-javacopts" ) ; genicTask . createArg ( ) . setLine ( javacopts ) ; } if ( rmicopts != null && ! rmicopts . equals ( "" ) ) { genicTask . createArg ( ) . setValue ( "-rmicopts" ) ; genicTask . createArg ( ) . setLine ( rmicopts ) ; } if ( secpropag ) { genicTask . createArg ( ) . setValue ( "-secpropag" ) ; } if ( verbose ) { genicTask . createArg ( ) . setValue ( "-verbose" ) ; } if ( additionalargs != null ) { genicTask . createArg ( ) . setValue ( additionalargs ) ; } genicTask . createArg ( ) . setValue ( "-noaddinjar" ) ; genicTask . createArg ( ) . setValue ( genericJarFile . getPath ( ) ) ; log ( "Calling " + genicClass + " for " + getConfig ( ) . descriptorDir + File . separator + descriptorName + "." , Project . MSG_VERBOSE ) ; if ( genicTask . executeJava ( ) != 0 ) { log ( "Deleting temp output directory '" + outputdir + "'." , Project . MSG_VERBOSE ) ; deleteAllFiles ( outputdir ) ; if ( ! keepgeneric ) { log ( "Deleting generic JAR " + genericJarFile . toString ( ) , Project . MSG_VERBOSE ) ; genericJarFile . delete ( ) ; } throw new BuildException ( "GenIC reported an error." ) ; } addAllFiles ( outputdir , "" , ejbFiles ) ; } String getGenicClassName ( Path classpath ) { log ( "Looking for GenIC class in classpath: " + classpath . toString ( ) , Project . MSG_VERBOSE ) ; AntClassLoader cl = classpath . getProject ( ) . createClassLoader ( classpath ) ; try { cl . loadClass ( JonasDeploymentTool . GENIC_CLASS ) ; log ( "Found GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . GENIC_CLASS ; } catch ( ClassNotFoundException cnf1 ) { log ( "GenIC class '" + JonasDeploymentTool . GENIC_CLASS + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_1 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_1 ; } catch ( ClassNotFoundException cnf2 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_1 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } try { cl . loadClass ( JonasDeploymentTool . OLD_GENIC_CLASS_2 ) ; log ( "Found GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' in classpath." , Project . MSG_VERBOSE ) ; return JonasDeploymentTool . OLD_GENIC_CLASS_2 ; } catch ( ClassNotFoundException cnf3 ) { log ( "GenIC class '" + JonasDeploymentTool . OLD_GENIC_CLASS_2 + "' not found in classpath." , Project . MSG_VERBOSE ) ; } return null ; } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { if ( jonasroot == null ) { throw new BuildException ( "The jonasroot attribut is not set." ) ; } else if ( ! jonasroot . isDirectory ( ) ) { throw new BuildException ( "The jonasroot attribut '" + jonasroot + "' is not a valid directory." ) ; } if ( orb != null && ! orb . equals ( RMI_ORB ) && ! orb . equals ( JEREMIE_ORB ) && ! orb . equals ( DAVID_ORB ) ) { throw new BuildException ( "The orb attribut '" + orb + "' is not valid (must be either " + RMI_ORB + ", " + JEREMIE_ORB + " or " + DAVID_ORB + ")." ) ; } if ( additionalargs != null && additionalargs . equals ( "" ) ) { throw new BuildException ( "Empty additionalargs attribut." ) ; } if ( javac != null && javac . equals ( "" ) ) { throw new BuildException ( "Empty javac attribut." ) ; } } private File createTempDir ( ) throws IOException { File tmpDir = File . createTempFile ( "genic" , null , null ) ; tmpDir . delete ( ) ; if ( ! tmpDir . mkdir ( ) ) { throw new IOException ( "Cannot create the temporary directory '" + tmpDir + "'." ) ; } return tmpDir ; } private void deleteAllFiles ( File aFile ) { if ( aFile . isDirectory ( ) ) { File [ ] someFiles = aFile . listFiles ( ) ; for ( int i = 0 ; i < someFiles . length ; i ++ ) { deleteAllFiles ( someFiles [ i ] ) ; } } aFile . delete ( ) ; } private void addAllFiles ( File file , String rootDir , Hashtable hashtable ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( ) ; } String newRootDir ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { if ( rootDir . length ( ) > 0 ) { newRootDir = rootDir + File . separator + files [ i ] . getName ( ) ; } else { newRootDir = files [ i ] . getName ( ) ; } addAllFiles ( files [ i ] , newRootDir , hashtable ) ; } } else { hashtable . put ( rootDir , file ) ; } } } 	0	['28', '2', '0', '12', '97', '302', '1', '11', '16', '0.962962963', '1230', '1', '0', '0.542372881', '0.272321429', '2', '8', '41.78571429', '20', '2.2857', '0']
package org . apache . tools . tar ; public interface TarConstants { int NAMELEN = 100 ; int MODELEN = 8 ; int UIDLEN = 8 ; int GIDLEN = 8 ; int CHKSUMLEN = 8 ; int SIZELEN = 12 ; long MAXSIZE = 077777777777L ; int MAGICLEN = 8 ; int MODTIMELEN = 12 ; int UNAMELEN = 32 ; int GNAMELEN = 32 ; int DEVLEN = 8 ; byte LF_OLDNORM = 0 ; byte LF_NORMAL = ( byte ) '0' ; byte LF_LINK = ( byte ) '1' ; byte LF_SYMLINK = ( byte ) '2' ; byte LF_CHR = ( byte ) '3' ; byte LF_BLK = ( byte ) '4' ; byte LF_DIR = ( byte ) '5' ; byte LF_FIFO = ( byte ) '6' ; byte LF_CONTIG = ( byte ) '7' ; String TMAGIC = "ustar" ; String GNU_TMAGIC = "ustar  " ; String GNU_LONGLINK = "././@LongLink" ; byte LF_GNUTYPE_LONGNAME = ( byte ) 'L' ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '25', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Sj extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using symantec java compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "sj" : exec ) ; int firstFileName = cmd . size ( ) - compileList . length ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } protected String getNoDebugArgument ( ) { return null ; } } 	0	['3', '2', '0', '5', '12', '3', '1', '4', '2', '2', '44', '0', '0', '0.92', '1', '1', '1', '13.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Delete extends P4Base { public String change = null ; public void setChange ( String change ) { this . change = change ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( P4View == null ) { throw new BuildException ( "No view specified to delete" ) ; } execP4Command ( "-s delete " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '10', '0', '0', '4', '3', '0', '55', '0', '0', '0.962264151', '0.666666667', '1', '1', '17', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import java . util . List ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import java . util . Collections ; import java . util . Iterator ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . PropertySet ; import org . apache . tools . ant . util . CollectionUtils ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class EchoProperties extends Task { private static final String PROPERTIES = "properties" ; private static final String PROPERTY = "property" ; private static final String ATTR_NAME = "name" ; private static final String ATTR_VALUE = "value" ; private File inFile = null ; private File destfile = null ; private boolean failonerror = true ; private Vector propertySets = new Vector ( ) ; private String format = "text" ; private String prefix ; private String regex ; public void setSrcfile ( File file ) { inFile = file ; } public void setDestfile ( File destfile ) { this . destfile = destfile ; } public void setFailOnError ( boolean failonerror ) { this . failonerror = failonerror ; } public void setPrefix ( String prefix ) { if ( prefix != null && prefix . length ( ) != 0 ) { this . prefix = prefix ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendPrefix ( prefix ) ; addPropertyset ( ps ) ; } } public void setRegex ( String regex ) { if ( regex != null && regex . length ( ) != 0 ) { this . regex = regex ; PropertySet ps = new PropertySet ( ) ; ps . setProject ( getProject ( ) ) ; ps . appendRegex ( regex ) ; addPropertyset ( ps ) ; } } public void addPropertyset ( PropertySet ps ) { propertySets . addElement ( ps ) ; } public void setFormat ( FormatAttribute ea ) { format = ea . getValue ( ) ; } public static class FormatAttribute extends EnumeratedAttribute { private String [ ] formats = new String [ ] { "xml" , "text" } ; public String [ ] getValues ( ) { return formats ; } } public void execute ( ) throws BuildException { if ( prefix != null && regex != null ) { throw new BuildException ( "Please specify either prefix" + " or regex, but not both" , getLocation ( ) ) ; } Hashtable allProps = new Hashtable ( ) ; if ( inFile == null && propertySets . size ( ) == 0 ) { allProps . putAll ( getProject ( ) . getProperties ( ) ) ; } else if ( inFile != null ) { if ( inFile . exists ( ) && inFile . isDirectory ( ) ) { String message = "srcfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( inFile . exists ( ) && ! inFile . canRead ( ) ) { String message = "Can not read from the specified srcfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } FileInputStream in = null ; try { in = new FileInputStream ( inFile ) ; Properties props = new Properties ( ) ; props . load ( in ) ; allProps . putAll ( props ) ; } catch ( FileNotFoundException fnfe ) { String message = "Could not find file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , fnfe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } catch ( IOException ioe ) { String message = "Could not read file " + inFile . getAbsolutePath ( ) ; if ( failonerror ) { throw new BuildException ( message , ioe , getLocation ( ) ) ; } else { log ( message , Project . MSG_WARN ) ; } return ; } finally { FileUtils . close ( in ) ; } } Enumeration e = propertySets . elements ( ) ; while ( e . hasMoreElements ( ) ) { PropertySet ps = ( PropertySet ) e . nextElement ( ) ; allProps . putAll ( ps . getProperties ( ) ) ; } OutputStream os = null ; try { if ( destfile == null ) { os = new ByteArrayOutputStream ( ) ; saveProperties ( allProps , os ) ; log ( os . toString ( ) , Project . MSG_INFO ) ; } else { if ( destfile . exists ( ) && destfile . isDirectory ( ) ) { String message = "destfile is a directory!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } if ( destfile . exists ( ) && ! destfile . canWrite ( ) ) { String message = "Can not write to the specified destfile!" ; if ( failonerror ) { throw new BuildException ( message , getLocation ( ) ) ; } else { log ( message , Project . MSG_ERR ) ; } return ; } os = new FileOutputStream ( this . destfile ) ; saveProperties ( allProps , os ) ; } } catch ( IOException ioe ) { if ( failonerror ) { throw new BuildException ( ioe , getLocation ( ) ) ; } else { log ( ioe . getMessage ( ) , Project . MSG_INFO ) ; } } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ex ) { } } } } protected void saveProperties ( Hashtable allProps , OutputStream os ) throws IOException , BuildException { final List keyList = new ArrayList ( allProps . keySet ( ) ) ; Collections . sort ( keyList ) ; Properties props = new Properties ( ) { public Enumeration keys ( ) { return CollectionUtils . asEnumeration ( keyList . iterator ( ) ) ; } public Set entrySet ( ) { Set result = super . entrySet ( ) ; if ( JavaEnvUtils . isKaffe ( ) ) { TreeSet t = new TreeSet ( new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { String key1 = ( String ) ( ( Map . Entry ) o1 ) . getKey ( ) ; String key2 = ( String ) ( ( Map . Entry ) o2 ) . getKey ( ) ; return key1 . compareTo ( key2 ) ; } } ) ; t . addAll ( result ) ; result = t ; } return result ; } } ; for ( int i = 0 ; i < keyList . size ( ) ; i ++ ) { String name = keyList . get ( i ) . toString ( ) ; String value = allProps . get ( name ) . toString ( ) ; props . setProperty ( name , value ) ; } if ( "text" . equals ( format ) ) { jdkSaveProperties ( props , os , "Ant properties" ) ; } else if ( "xml" . equals ( format ) ) { xmlSaveProperties ( props , os ) ; } } private static class Tuple implements Comparable { private String key ; private String value ; private Tuple ( String key , String value ) { this . key = key ; this . value = value ; } public int compareTo ( Object o ) { Tuple that = ( Tuple ) o ; return key . compareTo ( that . key ) ; } } private List sortProperties ( Properties props ) { List sorted = new ArrayList ( props . size ( ) ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; sorted . add ( new Tuple ( name , props . getProperty ( name ) ) ) ; } Collections . sort ( sorted ) ; return sorted ; } protected void xmlSaveProperties ( Properties props , OutputStream os ) throws IOException { Document doc = getDocumentBuilder ( ) . newDocument ( ) ; Element rootElement = doc . createElement ( PROPERTIES ) ; List sorted = sortProperties ( props ) ; Iterator iten = sorted . iterator ( ) ; while ( iten . hasNext ( ) ) { Tuple tuple = ( Tuple ) iten . next ( ) ; Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , tuple . key ) ; propElement . setAttribute ( ATTR_VALUE , tuple . value ) ; rootElement . appendChild ( propElement ) ; } Writer wri = null ; try { wri = new OutputStreamWriter ( os , "UTF8" ) ; wri . write ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , 0 , "\t" ) ; wri . flush ( ) ; } catch ( IOException ioe ) { throw new BuildException ( "Unable to write XML file" , ioe ) ; } finally { FileUtils . close ( wri ) ; } } protected void jdkSaveProperties ( Properties props , OutputStream os , String header ) throws IOException { try { props . store ( os , header ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException ioex ) { log ( "Failed to close output stream" ) ; } } } } private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( Exception e ) { throw new ExceptionInInitializerError ( e ) ; } } } 	0	['14', '3', '0', '10', '90', '63', '1', '10', '9', '0.923076923', '615', '1', '0', '0.74', '0.222222222', '1', '1', '42.14285714', '3', '1.2857', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . net . HttpURLConnection ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLConnection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Http extends ProjectComponent implements Condition { private static final int ERROR_BEGINS = 400 ; private String spec = null ; public void setUrl ( String url ) { spec = url ; } private int errorsBeginAt = ERROR_BEGINS ; public void setErrorsBeginAt ( int errorsBeginAt ) { this . errorsBeginAt = errorsBeginAt ; } public boolean eval ( ) throws BuildException { if ( spec == null ) { throw new BuildException ( "No url specified in http condition" ) ; } log ( "Checking for " + spec , Project . MSG_VERBOSE ) ; try { URL url = new URL ( spec ) ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpURLConnection ) { HttpURLConnection http = ( HttpURLConnection ) conn ; int code = http . getResponseCode ( ) ; log ( "Result code for " + spec + " was " + code , Project . MSG_VERBOSE ) ; if ( code > 0 && code < errorsBeginAt ) { return true ; } return false ; } } catch ( java . io . IOException e ) { return false ; } } catch ( MalformedURLException e ) { throw new BuildException ( "Badly formed URL: " + spec , e ) ; } return true ; } } 	0	['4', '2', '0', '4', '15', '0', '1', '3', '4', '0.666666667', '105', '1', '0', '0.75', '0.5', '0', '0', '24.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; public class Rename extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File src ; private File dest ; private boolean replace = true ; public void setSrc ( File src ) { this . src = src ; } public void setDest ( File dest ) { this . dest = dest ; } public void setReplace ( String replace ) { this . replace = Project . toBoolean ( replace ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The rename task is deprecated.  Use move instead." ) ; if ( dest == null ) { throw new BuildException ( "dest attribute is required" , getLocation ( ) ) ; } if ( src == null ) { throw new BuildException ( "src attribute is required" , getLocation ( ) ) ; } if ( ! replace && dest . exists ( ) ) { throw new BuildException ( dest + " already exists." ) ; } try { FILE_UTILS . rename ( src , dest ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to rename " + src + " to " + dest , e , getLocation ( ) ) ; } } } 	0	['6', '3', '0', '5', '21', '3', '0', '5', '5', '0.75', '104', '1', '1', '0.902439024', '0.533333333', '1', '1', '15.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; public interface ClassFileIterator { ClassFile getNextClassFile ( ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Random ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public class Jikes { protected JikesOutputParser jop ; protected String command ; protected Project project ; protected Jikes ( JikesOutputParser jop , String command , Project project ) { super ( ) ; System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Jikes class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; this . jop = jop ; this . command = command ; this . project = project ; } protected void compile ( String [ ] args ) { String [ ] commandArray = null ; File tmpFile = null ; try { String myos = System . getProperty ( "os.name" ) ; if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 && args . length > 250 ) { PrintWriter out = null ; try { String tempFileName = "jikes" + ( new Random ( System . currentTimeMillis ( ) ) ) . nextLong ( ) ; tmpFile = new File ( tempFileName ) ; out = new PrintWriter ( new FileWriter ( tmpFile ) ) ; for ( int i = 0 ; i < args . length ; i ++ ) { out . println ( args [ i ] ) ; } out . flush ( ) ; commandArray = new String [ ] { command , "@" + tmpFile . getAbsolutePath ( ) } ; } catch ( IOException e ) { throw new BuildException ( "Error creating temporary file" , e ) ; } finally { FileUtils . close ( out ) ; } } else { commandArray = new String [ args . length + 1 ] ; commandArray [ 0 ] = command ; System . arraycopy ( args , 0 , commandArray , 1 , args . length ) ; } try { Execute exe = new Execute ( jop ) ; exe . setAntRun ( project ) ; exe . setWorkingDirectory ( project . getBaseDir ( ) ) ; exe . setCommandline ( commandArray ) ; exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Error running Jikes compiler" , e ) ; } } finally { if ( tmpFile != null ) { tmpFile . delete ( ) ; } } } } 	0	['2', '1', '0', '6', '30', '0', '0', '6', '0', '0', '182', '1', '2', '0', '0.6', '0', '0', '88.5', '9', '4.5', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public abstract class ConstantPoolEntry { public static final int CONSTANT_UTF8 = 1 ; public static final int CONSTANT_INTEGER = 3 ; public static final int CONSTANT_FLOAT = 4 ; public static final int CONSTANT_LONG = 5 ; public static final int CONSTANT_DOUBLE = 6 ; public static final int CONSTANT_CLASS = 7 ; public static final int CONSTANT_STRING = 8 ; public static final int CONSTANT_FIELDREF = 9 ; public static final int CONSTANT_METHODREF = 10 ; public static final int CONSTANT_INTERFACEMETHODREF = 11 ; public static final int CONSTANT_NAMEANDTYPE = 12 ; private int tag ; private int numEntries ; private boolean resolved ; public ConstantPoolEntry ( int tagValue , int entries ) { tag = tagValue ; numEntries = entries ; resolved = false ; } public static ConstantPoolEntry readEntry ( DataInputStream cpStream ) throws IOException { ConstantPoolEntry cpInfo = null ; int cpTag = cpStream . readUnsignedByte ( ) ; switch ( cpTag ) { case CONSTANT_UTF8 : cpInfo = new Utf8CPInfo ( ) ; break ; case CONSTANT_INTEGER : cpInfo = new IntegerCPInfo ( ) ; break ; case CONSTANT_FLOAT : cpInfo = new FloatCPInfo ( ) ; break ; case CONSTANT_LONG : cpInfo = new LongCPInfo ( ) ; break ; case CONSTANT_DOUBLE : cpInfo = new DoubleCPInfo ( ) ; break ; case CONSTANT_CLASS : cpInfo = new ClassCPInfo ( ) ; break ; case CONSTANT_STRING : cpInfo = new StringCPInfo ( ) ; break ; case CONSTANT_FIELDREF : cpInfo = new FieldRefCPInfo ( ) ; break ; case CONSTANT_METHODREF : cpInfo = new MethodRefCPInfo ( ) ; break ; case CONSTANT_INTERFACEMETHODREF : cpInfo = new InterfaceMethodRefCPInfo ( ) ; break ; case CONSTANT_NAMEANDTYPE : cpInfo = new NameAndTypeCPInfo ( ) ; break ; default : throw new ClassFormatError ( "Invalid Constant Pool entry Type " + cpTag ) ; } cpInfo . read ( cpStream ) ; return cpInfo ; } public boolean isResolved ( ) { return resolved ; } public void resolve ( ConstantPool constantPool ) { resolved = true ; } public abstract void read ( DataInputStream cpStream ) throws IOException ; public int getTag ( ) { return tag ; } public final int getNumEntries ( ) { return numEntries ; } } 	0	['7', '1', '7', '14', '24', '11', '10', '12', '7', '1.083333333', '124', '0.214285714', '0', '0', '0.357142857', '0', '0', '14.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . OutputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; public class P4OutputStream extends OutputStream { private P4Handler handler ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; private boolean skip = false ; public P4OutputStream ( P4Handler handler ) { this . handler = handler ; } public void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == '\n' ) || ( c == '\r' ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == '\r' ) ; } protected void processBuffer ( ) { handler . process ( buffer . toString ( ) ) ; buffer . reset ( ) ; } public void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } } 	0	['4', '2', '0', '2', '12', '0', '1', '1', '3', '0.222222222', '68', '1', '1', '0.625', '0.5', '1', '1', '15.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; public class Matches extends ProjectComponent implements Condition { private String string ; private boolean caseSensitive = true ; private boolean multiLine = false ; private boolean singleLine = false ; private RegularExpression regularExpression ; public void setString ( String string ) { this . string = string ; } public void setPattern ( String pattern ) { if ( regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( pattern ) ; } public void addRegexp ( RegularExpression regularExpression ) { if ( this . regularExpression != null ) { throw new BuildException ( "Only one regular expression is allowed." ) ; } this . regularExpression = regularExpression ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public void setMultiline ( boolean b ) { multiLine = b ; } public void setSingleLine ( boolean b ) { singleLine = b ; } public boolean eval ( ) throws BuildException { if ( string == null ) { throw new BuildException ( "Parameter string is required in matches." ) ; } if ( regularExpression == null ) { throw new BuildException ( "Missing pattern in matches." ) ; } int options = RegexpMatcher . MATCH_DEFAULT ; if ( ! caseSensitive ) { options = options | RegexpMatcher . MATCH_CASE_INSENSITIVE ; } if ( multiLine ) { options = options | RegexpMatcher . MATCH_MULTILINE ; } if ( singleLine ) { options = options | RegexpMatcher . MATCH_SINGLELINE ; } Regexp regexp = regularExpression . getRegexp ( getProject ( ) ) ; return regexp . matches ( string , options ) ; } } 	0	['8', '2', '0', '6', '15', '6', '0', '6', '8', '0.742857143', '122', '1', '1', '0.5625', '0.4375', '0', '0', '13.625', '2', '1.125', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Exec extends Task { private String os ; private String out ; private File dir ; private String command ; protected PrintWriter fos = null ; private boolean failOnError = false ; public Exec ( ) { System . err . println ( "As of Ant 1.2 released in October 2000, " + "the Exec class" ) ; System . err . println ( "is considered to be dead code by the Ant " + "developers and is unmaintained." ) ; System . err . println ( "Don\'t use it!" ) ; } public void execute ( ) throws BuildException { run ( command ) ; } protected int run ( String command ) throws BuildException { int err = - 1 ; String myos = System . getProperty ( "os.name" ) ; log ( "Myos = " + myos , Project . MSG_VERBOSE ) ; if ( ( os != null ) && ( os . indexOf ( myos ) < 0 ) ) { log ( "Not found in " + os , Project . MSG_VERBOSE ) ; return 0 ; } if ( dir == null ) { dir = getProject ( ) . getBaseDir ( ) ; } if ( myos . toLowerCase ( ) . indexOf ( "windows" ) >= 0 ) { if ( ! dir . equals ( getProject ( ) . resolveFile ( "." ) ) ) { if ( myos . toLowerCase ( ) . indexOf ( "nt" ) >= 0 ) { command = "cmd /c cd " + dir + " && " + command ; } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not " + "found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun.bat" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } } } else { String ant = getProject ( ) . getProperty ( MagicNames . ANT_HOME ) ; if ( ant == null ) { throw new BuildException ( "Property '" + MagicNames . ANT_HOME + "' not found" , getLocation ( ) ) ; } String antRun = getProject ( ) . resolveFile ( ant + "/bin/antRun" ) . toString ( ) ; command = antRun + " " + dir + " " + command ; } try { log ( command , Project . MSG_VERBOSE ) ; Process proc = Runtime . getRuntime ( ) . exec ( command ) ; if ( out != null ) { fos = new PrintWriter ( new FileWriter ( out ) ) ; log ( "Output redirected to " + out , Project . MSG_VERBOSE ) ; } StreamPumper inputPumper = new StreamPumper ( proc . getInputStream ( ) , Project . MSG_INFO ) ; StreamPumper errorPumper = new StreamPumper ( proc . getErrorStream ( ) , Project . MSG_WARN ) ; inputPumper . start ( ) ; errorPumper . start ( ) ; proc . waitFor ( ) ; inputPumper . join ( ) ; errorPumper . join ( ) ; proc . destroy ( ) ; logFlush ( ) ; err = proc . exitValue ( ) ; if ( err != 0 ) { if ( failOnError ) { throw new BuildException ( "Exec returned: " + err , getLocation ( ) ) ; } else { log ( "Result: " + err , Project . MSG_ERR ) ; } } } catch ( IOException ioe ) { throw new BuildException ( "Error exec: " + command , ioe , getLocation ( ) ) ; } catch ( InterruptedException ex ) { } return err ; } public void setDir ( String d ) { this . dir = getProject ( ) . resolveFile ( d ) ; } public void setOs ( String os ) { this . os = os ; } public void setCommand ( String command ) { this . command = command ; } public void setOutput ( String out ) { this . out = out ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } protected void outputLog ( String line , int messageLevel ) { if ( fos == null ) { log ( line , messageLevel ) ; } else { fos . println ( line ) ; } } protected void logFlush ( ) { if ( fos != null ) { fos . close ( ) ; } } class StreamPumper extends Thread { private BufferedReader din ; private int messageLevel ; private boolean endOfStream = false ; private static final int SLEEP_TIME = 5 ; public StreamPumper ( InputStream is , int messageLevel ) { this . din = new BufferedReader ( new InputStreamReader ( is ) ) ; this . messageLevel = messageLevel ; } public void pumpStream ( ) throws IOException { if ( ! endOfStream ) { String line = din . readLine ( ) ; if ( line != null ) { outputLog ( line , messageLevel ) ; } else { endOfStream = true ; } } } public void run ( ) { try { try { while ( ! endOfStream ) { pumpStream ( ) ; sleep ( SLEEP_TIME ) ; } } catch ( InterruptedException ie ) { } din . close ( ) ; } catch ( IOException ioe ) { } } } } 	0	['10', '3', '0', '5', '45', '21', '1', '5', '7', '0.740740741', '359', '1', '0', '0.804347826', '0.45', '0', '0', '34.3', '2', '1.1', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . taskdefs . optional . jsp . JspMangler ; public interface JspCompilerAdapter { void setJspc ( JspC attributes ) ; boolean execute ( ) throws BuildException ; JspMangler createMangler ( ) ; boolean implementsOwnDependencyChecking ( ) ; } 	0	['4', '1', '0', '5', '4', '6', '3', '3', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class TaskLogger { private Task task ; public TaskLogger ( final Task task ) { this . task = task ; } public void info ( final String message ) { task . log ( message , Project . MSG_INFO ) ; } public void error ( final String message ) { task . log ( message , Project . MSG_ERR ) ; } public void warning ( final String message ) { task . log ( message , Project . MSG_WARN ) ; } public void verbose ( final String message ) { task . log ( message , Project . MSG_VERBOSE ) ; } public void debug ( final String message ) { task . log ( message , Project . MSG_DEBUG ) ; } } 	0	['6', '1', '0', '1', '8', '0', '0', '1', '6', '0', '43', '1', '1', '0', '0.666666667', '0', '0', '6', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . NumberFormat ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class BriefJUnitResultFormatter implements JUnitResultFormatter { private OutputStream out ; private PrintWriter output ; private StringWriter results ; private PrintWriter resultWriter ; private NumberFormat numberFormat = NumberFormat . getInstance ( ) ; private String systemOutput = null ; private String systemError = null ; public BriefJUnitResultFormatter ( ) { results = new StringWriter ( ) ; resultWriter = new PrintWriter ( results ) ; } public void setOutput ( OutputStream out ) { this . out = out ; output = new PrintWriter ( out ) ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void startTestSuite ( JUnitTest suite ) { if ( output == null ) { return ; } StringBuffer sb = new StringBuffer ( "Testsuite: " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( StringUtils . LINE_SEP ) ; output . write ( sb . toString ( ) ) ; output . flush ( ) ; } public void endTestSuite ( JUnitTest suite ) { StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( numberFormat . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( StringUtils . LINE_SEP ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "------------- Standard Output ---------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemOutput ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "------------- Standard Error -----------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemError ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( output != null ) { try { output . write ( sb . toString ( ) ) ; resultWriter . close ( ) ; output . write ( results . toString ( ) ) ; output . flush ( ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( out ) ; } } } } public void startTest ( Test test ) { } public void endTest ( Test test ) { } public void addFailure ( Test test , Throwable t ) { formatError ( "\tFAILED" , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable error ) { formatError ( "\tCaused an ERROR" , test , error ) ; } protected String formatTest ( Test test ) { if ( test == null ) { return "Null Test: " ; } else { return "Testcase: " + test . toString ( ) + ":" ; } } protected synchronized void formatError ( String type , Test test , Throwable error ) { if ( test != null ) { endTest ( test ) ; } resultWriter . println ( formatTest ( test ) + type ) ; resultWriter . println ( error . getMessage ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( error ) ; resultWriter . println ( strace ) ; resultWriter . println ( ) ; } } 	0	['13', '1', '0', '7', '40', '58', '0', '7', '11', '0.833333333', '292', '1', '0', '0', '0.32967033', '0', '0', '20.92307692', '10', '1.8462', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class FilesMatch implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file1 , file2 ; private boolean textfile = false ; public void setFile1 ( File file1 ) { this . file1 = file1 ; } public void setFile2 ( File file2 ) { this . file2 = file2 ; } public void setTextfile ( boolean textfile ) { this . textfile = textfile ; } public boolean eval ( ) throws BuildException { if ( file1 == null || file2 == null ) { throw new BuildException ( "both file1 and file2 are required in " + "filesmatch" ) ; } boolean matches = false ; try { matches = FILE_UTILS . contentEquals ( file1 , file2 , textfile ) ; } catch ( IOException ioe ) { throw new BuildException ( "when comparing files: " + ioe . getMessage ( ) , ioe ) ; } return matches ; } } 	0	['6', '1', '0', '4', '15', '3', '1', '3', '5', '0.75', '70', '1', '1', '0', '0.533333333', '0', '0', '10', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCRmtype extends ClearCase { private String mTypeKind = null ; private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; private boolean mRmall = false ; private boolean mIgnore = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; if ( getTypeKind ( ) == null ) { throw new BuildException ( "Required attribute TypeKind not specified" ) ; } if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_RMTYPE ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getTypeSpecifier ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getIgnore ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_IGNORE ) ; } if ( getRmAll ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RMALL ) ; cmd . createArgument ( ) . setValue ( FLAG_FORCE ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } cmd . createArgument ( ) . setValue ( getTypeSpecifier ( ) ) ; } public void setIgnore ( boolean ignore ) { mIgnore = ignore ; } public boolean getIgnore ( ) { return mIgnore ; } public void setRmAll ( boolean rmall ) { mRmall = rmall ; } public boolean getRmAll ( ) { return mRmall ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeKind ( String tk ) { mTypeKind = tk ; } public String getTypeKind ( ) { return mTypeKind ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } private String getTypeSpecifier ( ) { String tkind = getTypeKind ( ) ; String tname = getTypeName ( ) ; String typeSpec = null ; typeSpec = tkind + ":" + tname ; if ( getVOB ( ) != null ) { typeSpec += "@" + getVOB ( ) ; } return typeSpec ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_IGNORE = "-ignore" ; public static final String FLAG_RMALL = "-rmall" ; public static final String FLAG_FORCE = "-force" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['20', '4', '0', '7', '39', '148', '0', '7', '16', '0.923076923', '285', '0.538461538', '0', '0.71641791', '0.375', '2', '2', '12.6', '5', '1.3', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class PackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( File . separatorChar , '.' ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapter ; import org . apache . tools . ant . taskdefs . optional . javah . JavahAdapterFactory ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . util . facade . ImplementationSpecificArgument ; public class Javah extends Task { private Vector classes = new Vector ( 2 ) ; private String cls ; private File destDir ; private Path classpath = null ; private File outputFile = null ; private boolean verbose = false ; private boolean force = false ; private boolean old = false ; private boolean stubs = false ; private Path bootclasspath ; private static String lSep = System . getProperty ( "line.separator" ) ; private FacadeTaskHelper facade = null ; public Javah ( ) { facade = new FacadeTaskHelper ( JavahAdapterFactory . getDefault ( ) ) ; } public void setClass ( String cls ) { this . cls = cls ; } public ClassArgument createClass ( ) { ClassArgument ga = new ClassArgument ( ) ; classes . addElement ( ga ) ; return ga ; } public class ClassArgument { private String name ; public ClassArgument ( ) { } public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } } public String [ ] getClasses ( ) { ArrayList al = new ArrayList ( ) ; if ( cls != null ) { StringTokenizer tok = new StringTokenizer ( cls , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { al . add ( tok . nextToken ( ) . trim ( ) ) ; } } Enumeration e = classes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ClassArgument arg = ( ClassArgument ) e . nextElement ( ) ; al . add ( arg . getName ( ) ) ; } return ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setBootclasspath ( Path src ) { if ( bootclasspath == null ) { bootclasspath = src ; } else { bootclasspath . append ( src ) ; } } public Path createBootclasspath ( ) { if ( bootclasspath == null ) { bootclasspath = new Path ( getProject ( ) ) ; } return bootclasspath . createPath ( ) ; } public void setBootClasspathRef ( Reference r ) { createBootclasspath ( ) . setRefid ( r ) ; } public Path getBootclasspath ( ) { return bootclasspath ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } public File getOutputfile ( ) { return outputFile ; } public void setForce ( boolean force ) { this . force = force ; } public boolean getForce ( ) { return force ; } public void setOld ( boolean old ) { this . old = old ; } public boolean getOld ( ) { return old ; } public void setStubs ( boolean stubs ) { this . stubs = stubs ; } public boolean getStubs ( ) { return stubs ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setImplementation ( String impl ) { if ( "default" . equals ( impl ) ) { facade . setImplementation ( JavahAdapterFactory . getDefault ( ) ) ; } else { facade . setImplementation ( impl ) ; } } public ImplementationSpecificArgument createArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public String [ ] getCurrentArgs ( ) { return facade . getArgs ( ) ; } public void execute ( ) throws BuildException { if ( ( cls == null ) && ( classes . size ( ) == 0 ) ) { throw new BuildException ( "class attribute must be set!" , getLocation ( ) ) ; } if ( ( cls != null ) && ( classes . size ( ) > 0 ) ) { throw new BuildException ( "set class attribute or class element, " + "not both." , getLocation ( ) ) ; } if ( destDir != null ) { if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , getLocation ( ) ) ; } if ( outputFile != null ) { throw new BuildException ( "destdir and outputFile are mutually " + "exclusive" , getLocation ( ) ) ; } } if ( classpath == null ) { classpath = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { classpath = classpath . concatSystemClasspath ( "ignore" ) ; } JavahAdapter ad = JavahAdapterFactory . getAdapter ( facade . getImplementation ( ) , this ) ; if ( ! ad . compile ( this ) ) { throw new BuildException ( "compilation failed" ) ; } } public void logAndAddFiles ( Commandline cmd ) { logAndAddFilesToCompile ( cmd ) ; } protected void logAndAddFilesToCompile ( Commandline cmd ) { log ( "Compilation " + cmd . describeArguments ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceClassList = new StringBuffer ( ) ; String [ ] c = getClasses ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { cmd . createArgument ( ) . setValue ( c [ i ] ) ; niceClassList . append ( "    " ) ; niceClassList . append ( c [ i ] ) ; niceClassList . append ( lSep ) ; } StringBuffer prefix = new StringBuffer ( "Class" ) ; if ( c . length > 1 ) { prefix . append ( "es" ) ; } prefix . append ( " to be compiled:" ) ; prefix . append ( lSep ) ; log ( prefix . toString ( ) + niceClassList . toString ( ) , Project . MSG_VERBOSE ) ; } } 	0	['31', '3', '0', '16', '79', '365', '4', '14', '29', '0.905555556', '466', '1', '3', '0.560606061', '0.20952381', '0', '0', '13.64516129', '4', '1.2581', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . types . resources . FileResource ; public class LoadFile extends LoadResource { public final void setSrcFile ( final File srcFile ) { addConfigured ( new FileResource ( srcFile ) ) ; } } 	0	['2', '4', '0', '3', '5', '1', '0', '3', '2', '2', '12', '0', '0', '0.977777778', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . Method ; import java . lang . reflect . Field ; public class HasMethod extends ProjectComponent implements Condition { private String classname ; private String method ; private String field ; private Path classpath ; private AntClassLoader loader ; private boolean ignoreSystemClasses = false ; public void setClasspath ( Path classpath ) { createClasspath ( ) . append ( classpath ) ; } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setClassname ( String classname ) { this . classname = classname ; } public void setMethod ( String method ) { this . method = method ; } public void setField ( String field ) { this . field = field ; } public void setIgnoreSystemClasses ( boolean ignoreSystemClasses ) { this . ignoreSystemClasses = ignoreSystemClasses ; } private Class loadClass ( String classname ) { try { if ( ignoreSystemClasses ) { loader = getProject ( ) . createClassLoader ( classpath ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; if ( loader != null ) { try { return loader . findClass ( classname ) ; } catch ( SecurityException se ) { return null ; } } else { return null ; } } else if ( loader != null ) { return loader . loadClass ( classname ) ; } else { ClassLoader l = this . getClass ( ) . getClassLoader ( ) ; if ( l != null ) { return Class . forName ( classname , true , l ) ; } else { return Class . forName ( classname ) ; } } } catch ( ClassNotFoundException e ) { throw new BuildException ( "class \"" + classname + "\" was not found" ) ; } catch ( NoClassDefFoundError e ) { throw new BuildException ( "Could not load dependent class \"" + e . getMessage ( ) + "\" for class \"" + classname + "\"" ) ; } } public boolean eval ( ) throws BuildException { if ( classname == null ) { throw new BuildException ( "No classname defined" ) ; } Class clazz = loadClass ( classname ) ; if ( method != null ) { return isMethodFound ( clazz ) ; } if ( field != null ) { return isFieldFound ( clazz ) ; } throw new BuildException ( "Neither method nor field defined" ) ; } private boolean isFieldFound ( Class clazz ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Field fieldEntry = fields [ i ] ; if ( fieldEntry . getName ( ) . equals ( field ) ) { return true ; } } return false ; } private boolean isMethodFound ( Class clazz ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method methodEntry = methods [ i ] ; if ( methodEntry . getName ( ) . equals ( method ) ) { return true ; } } return false ; } } 	0	['12', '2', '0', '7', '37', '44', '0', '7', '9', '0.803030303', '231', '1', '2', '0.45', '0.291666667', '0', '0', '17.75', '5', '1.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . AntClassLoader ; import java . net . URL ; public class WhichResource extends Task { private Path classpath ; private String classname ; private String resource ; private String property ; public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } private void validate ( ) { int setcount = 0 ; if ( classname != null ) { setcount ++ ; } if ( resource != null ) { setcount ++ ; } if ( setcount == 0 ) { throw new BuildException ( "One of classname or resource must be specified" ) ; } if ( setcount > 1 ) { throw new BuildException ( "Only one of classname or resource can be specified" ) ; } if ( property == null ) { throw new BuildException ( "No property defined" ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( classpath != null ) { getProject ( ) . log ( "using user supplied classpath: " + classpath , Project . MSG_DEBUG ) ; classpath = classpath . concatSystemClasspath ( "ignore" ) ; } else { classpath = new Path ( getProject ( ) ) ; classpath = classpath . concatSystemClasspath ( "only" ) ; getProject ( ) . log ( "using system classpath: " + classpath , Project . MSG_DEBUG ) ; } AntClassLoader loader ; loader = new AntClassLoader ( getProject ( ) . getCoreLoader ( ) , getProject ( ) , classpath , false ) ; String loc = null ; if ( classname != null ) { resource = classname . replace ( '.' , '/' ) + ".class" ; } if ( resource == null ) { throw new BuildException ( "One of class or resource is required" ) ; } if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } log ( "Searching for " + resource , Project . MSG_VERBOSE ) ; URL url ; url = loader . getResource ( resource ) ; if ( url != null ) { loc = url . toExternalForm ( ) ; getProject ( ) . setNewProperty ( property , loc ) ; } } public void setResource ( String resource ) { this . resource = resource ; } public void setClass ( String classname ) { this . classname = classname ; } public void setProperty ( String property ) { this . property = property ; } } 	0	['8', '3', '0', '5', '30', '8', '0', '5', '7', '0.714285714', '214', '1', '1', '0.840909091', '0.5', '2', '2', '25.25', '6', '1.75', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . HashSet ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . ResourceCollection ; public class Difference extends BaseResourceCollectionContainer { protected Collection getCollection ( ) { List rc = getResourceCollections ( ) ; int size = rc . size ( ) ; if ( size < 2 ) { throw new BuildException ( "The difference of " + size + " resource collection" + ( ( size == 1 ) ? "" : "s" ) + " is undefined." ) ; } HashSet hs = new HashSet ( ) ; ArrayList al = new ArrayList ( ) ; for ( Iterator rcIter = rc . iterator ( ) ; rcIter . hasNext ( ) ; ) { for ( Iterator r = nextRC ( rcIter ) . iterator ( ) ; r . hasNext ( ) ; ) { Object next = r . next ( ) ; if ( hs . add ( next ) ) { al . add ( next ) ; } else { al . remove ( next ) ; } } } return al ; } private static ResourceCollection nextRC ( Iterator i ) { return ( ResourceCollection ) i . next ( ) ; } } 	0	['3', '4', '0', '3', '20', '3', '0', '3', '1', '2', '82', '0', '0', '0.956521739', '0.5', '1', '1', '26.33333333', '6', '2.3333', '0']
package org . apache . tools . ant . taskdefs . optional . sound ; import java . io . File ; import java . io . IOException ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioInputStream ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . Clip ; import javax . sound . sampled . DataLine ; import javax . sound . sampled . Line ; import javax . sound . sampled . LineEvent ; import javax . sound . sampled . LineListener ; import javax . sound . sampled . LineUnavailableException ; import javax . sound . sampled . UnsupportedAudioFileException ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . Project ; public class AntSoundPlayer implements LineListener , BuildListener { private File fileSuccess = null ; private int loopsSuccess = 0 ; private Long durationSuccess = null ; private File fileFail = null ; private int loopsFail = 0 ; private Long durationFail = null ; public AntSoundPlayer ( ) { } public void addBuildSuccessfulSound ( File file , int loops , Long duration ) { this . fileSuccess = file ; this . loopsSuccess = loops ; this . durationSuccess = duration ; } public void addBuildFailedSound ( File fileFail , int loopsFail , Long durationFail ) { this . fileFail = fileFail ; this . loopsFail = loopsFail ; this . durationFail = durationFail ; } private void play ( Project project , File file , int loops , Long duration ) { Clip audioClip = null ; AudioInputStream audioInputStream = null ; try { audioInputStream = AudioSystem . getAudioInputStream ( file ) ; } catch ( UnsupportedAudioFileException uafe ) { project . log ( "Audio format is not yet supported: " + uafe . getMessage ( ) ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } if ( audioInputStream != null ) { AudioFormat format = audioInputStream . getFormat ( ) ; DataLine . Info info = new DataLine . Info ( Clip . class , format , AudioSystem . NOT_SPECIFIED ) ; try { audioClip = ( Clip ) AudioSystem . getLine ( info ) ; audioClip . addLineListener ( this ) ; audioClip . open ( audioInputStream ) ; } catch ( LineUnavailableException e ) { project . log ( "The sound device is currently unavailable" ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( duration != null ) { playClip ( audioClip , duration . longValue ( ) ) ; } else { playClip ( audioClip , loops ) ; } audioClip . drain ( ) ; audioClip . close ( ) ; } else { project . log ( "Can't get data from file " + file . getName ( ) ) ; } } private void playClip ( Clip clip , int loops ) { clip . loop ( loops ) ; while ( clip . isRunning ( ) ) { } } private void playClip ( Clip clip , long duration ) { clip . loop ( Clip . LOOP_CONTINUOUSLY ) ; try { Thread . sleep ( duration ) ; } catch ( InterruptedException e ) { } } public void update ( LineEvent event ) { if ( event . getType ( ) . equals ( LineEvent . Type . STOP ) ) { Line line = event . getLine ( ) ; line . close ( ) ; } else if ( event . getType ( ) . equals ( LineEvent . Type . CLOSE ) ) { } } public void buildStarted ( BuildEvent event ) { } public void buildFinished ( BuildEvent event ) { if ( event . getException ( ) == null && fileSuccess != null ) { play ( event . getProject ( ) , fileSuccess , loopsSuccess , durationSuccess ) ; } else if ( event . getException ( ) != null && fileFail != null ) { play ( event . getProject ( ) , fileFail , loopsFail , durationFail ) ; } } public void targetStarted ( BuildEvent event ) { } public void targetFinished ( BuildEvent event ) { } public void taskStarted ( BuildEvent event ) { } public void taskFinished ( BuildEvent event ) { } public void messageLogged ( BuildEvent event ) { } } 	0	['14', '1', '0', '4', '43', '81', '1', '3', '11', '0.857142857', '230', '0.857142857', '0', '0', '0.285714286', '0', '0', '14.92857143', '5', '1.5714', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Commandline ; public class GenericHotDeploymentTool extends AbstractHotDeploymentTool { private Java java ; private String className ; private static final String [ ] VALID_ACTIONS = { ACTION_DEPLOY } ; public Commandline . Argument createArg ( ) { return java . createArg ( ) ; } public Commandline . Argument createJvmarg ( ) { return java . createJvmarg ( ) ; } protected boolean isActionValid ( ) { return ( getTask ( ) . getAction ( ) . equals ( VALID_ACTIONS [ 0 ] ) ) ; } public void setTask ( ServerDeploy task ) { super . setTask ( task ) ; java = new Java ( task ) ; } public void deploy ( ) throws BuildException { java . setClassname ( className ) ; java . setClasspath ( getClasspath ( ) ) ; java . setFork ( true ) ; java . setFailonerror ( true ) ; java . execute ( ) ; } public void validateAttributes ( ) throws BuildException { super . validateAttributes ( ) ; if ( className == null ) { throw new BuildException ( "The classname attribute must be set" ) ; } } public void setClassName ( String className ) { this . className = className ; } public Java getJava ( ) { return java ; } public String getClassName ( ) { return className ; } } 	0	['11', '2', '1', '8', '27', '21', '2', '7', '9', '0.733333333', '94', '1', '1', '0.608695652', '0.4', '2', '3', '7.272727273', '1', '0.8182', '0']
package org . apache . tools . ant . util . facade ; import org . apache . tools . ant . types . Commandline ; public class ImplementationSpecificArgument extends Commandline . Argument { private String impl ; public ImplementationSpecificArgument ( ) { super ( ) ; } public void setImplementation ( String impl ) { this . impl = impl ; } public final String [ ] getParts ( String chosenImpl ) { if ( impl == null || impl . equals ( chosenImpl ) ) { return super . getParts ( ) ; } else { return new String [ 0 ] ; } } } 	0	['3', '3', '2', '8', '6', '1', '7', '1', '3', '0.5', '25', '1', '0', '0.882352941', '0.833333333', '1', '1', '7', '3', '1.3333', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Equals implements Condition { private String arg1 , arg2 ; private boolean trim = false ; private boolean caseSensitive = true ; public void setArg1 ( String a1 ) { arg1 = a1 ; } public void setArg2 ( String a2 ) { arg2 = a2 ; } public void setTrim ( boolean b ) { trim = b ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( arg1 == null || arg2 == null ) { throw new BuildException ( "both arg1 and arg2 are required in " + "equals" ) ; } if ( trim ) { arg1 = arg1 . trim ( ) ; arg2 = arg2 . trim ( ) ; } return caseSensitive ? arg1 . equals ( arg2 ) : arg1 . equalsIgnoreCase ( arg2 ) ; } } 	0	['6', '1', '0', '3', '11', '1', '1', '2', '6', '0.7', '74', '1', '0', '0', '0.555555556', '0', '0', '10.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . types ; import java . util . Arrays ; import org . apache . tools . ant . BuildException ; public class Comparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "equal" , "greater" , "less" , "ne" , "ge" , "le" , "eq" , "gt" , "lt" , "more" } ; public static final Comparison EQUAL = new Comparison ( "equal" ) ; public static final Comparison NOT_EQUAL = new Comparison ( "ne" ) ; public static final Comparison GREATER = new Comparison ( "greater" ) ; public static final Comparison LESS = new Comparison ( "less" ) ; public static final Comparison GREATER_EQUAL = new Comparison ( "ge" ) ; public static final Comparison LESS_EQUAL = new Comparison ( "le" ) ; private static final int [ ] EQUAL_INDEX = { 0 , 4 , 5 , 6 } ; private static final int [ ] LESS_INDEX = { 2 , 3 , 5 , 8 } ; private static final int [ ] GREATER_INDEX = { 1 , 3 , 4 , 7 , 9 } ; public Comparison ( ) { } public Comparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( int comparisonResult ) { if ( getIndex ( ) == - 1 ) { throw new BuildException ( "Comparison value not set." ) ; } int [ ] i = comparisonResult < 0 ? LESS_INDEX : comparisonResult > 0 ? GREATER_INDEX : EQUAL_INDEX ; return Arrays . binarySearch ( i , getIndex ( ) ) >= 0 ; } } 	0	['5', '2', '2', '9', '10', '6', '7', '2', '4', '0.9', '185', '0.4', '6', '0.8', '0.5', '1', '1', '34', '5', '1.2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import junit . framework . TestResult ; import org . apache . tools . ant . AntClassLoader ; public final class JUnitTaskMirrorImpl implements JUnitTaskMirror { private final JUnitTask task ; public JUnitTaskMirrorImpl ( JUnitTask task ) { this . task = task ; } public void addVmExit ( JUnitTest test , JUnitTaskMirror . JUnitResultFormatterMirror aFormatter , OutputStream out , String message , String testCase ) { JUnitResultFormatter formatter = ( JUnitResultFormatter ) aFormatter ; formatter . setOutput ( out ) ; formatter . startTestSuite ( test ) ; TestCase t = new VmExitErrorTest ( message , test , testCase ) ; formatter . startTest ( t ) ; formatter . addError ( t , new AssertionFailedError ( message ) ) ; formatter . endTestSuite ( test ) ; } public JUnitTaskMirror . JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) { return new JUnitTestRunner ( test , haltOnError , filterTrace , haltOnFailure , showOutput , logTestListenerEvents , classLoader ) ; } public JUnitTaskMirror . SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) { return new SummaryJUnitResultFormatter ( ) ; } static class VmExitErrorTest extends TestCase { private String message ; private JUnitTest test ; private String testCase ; VmExitErrorTest ( String aMessage , JUnitTest anOriginalTest , String aTestCase ) { message = aMessage ; test = anOriginalTest ; testCase = aTestCase ; } public int countTestCases ( ) { return 1 ; } public void run ( TestResult r ) { throw new AssertionFailedError ( message ) ; } public String getName ( ) { return testCase ; } String getClassName ( ) { return test . getName ( ) ; } public String toString ( ) { return test . getName ( ) + ":" + testCase ; } } } 	0	['4', '1', '0', '13', '14', '6', '0', '13', '4', '1', '56', '1', '1', '0', '0.375', '0', '0', '12.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLoggerAware { void setLogger ( XSLTLogger l ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FieldRefCPInfo extends ConstantPoolEntry { private String fieldClassName ; private String fieldName ; private String fieldType ; private int classIndex ; private int nameAndTypeIndex ; public FieldRefCPInfo ( ) { super ( CONSTANT_FIELDREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo fieldClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; fieldClass . resolve ( constantPool ) ; fieldClassName = fieldClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; fieldName = nt . getName ( ) ; fieldType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Field : Class = " + fieldClassName + ", name = " + fieldName + ", type = " + fieldType ; } else { value = "Field : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public String getFieldClassName ( ) { return fieldClassName ; } public String getFieldName ( ) { return fieldName ; } public String getFieldType ( ) { return fieldType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant . dispatch ; public interface Dispatchable { String getActionParameterName ( ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Path ; import java . io . File ; import org . apache . tools . ant . types . Reference ; public class ScriptRunnerHelper { private ClasspathUtils . Delegate cpDelegate = null ; private File srcFile ; private String manager = "auto" ; private String language ; private String text ; private boolean setBeans = true ; private ProjectComponent projectComponent ; private ClassLoader scriptLoader = null ; public void setProjectComponent ( ProjectComponent component ) { this . projectComponent = component ; } public ScriptRunnerBase getScriptRunner ( ) { ScriptRunnerBase runner = getRunner ( ) ; if ( srcFile != null ) { runner . setSrc ( srcFile ) ; } if ( text != null ) { runner . addText ( text ) ; } if ( setBeans ) { runner . bindToComponent ( projectComponent ) ; } else { runner . bindToComponentMinimum ( projectComponent ) ; } return runner ; } public Path createClasspath ( ) { return getClassPathDelegate ( ) . createClasspath ( ) ; } public void setClasspath ( Path classpath ) { getClassPathDelegate ( ) . setClasspath ( classpath ) ; } public void setClasspathRef ( Reference r ) { getClassPathDelegate ( ) . setClasspathref ( r ) ; } public void setSrc ( File file ) { this . srcFile = file ; } public void addText ( String text ) { this . text = text ; } public void setManager ( String manager ) { this . manager = manager ; } public void setLanguage ( String language ) { this . language = language ; } public String getLanguage ( ) { return language ; } public void setSetBeans ( boolean setBeans ) { this . setBeans = setBeans ; } public void setClassLoader ( ClassLoader loader ) { scriptLoader = loader ; } private ClassLoader generateClassLoader ( ) { if ( scriptLoader != null ) { return scriptLoader ; } if ( cpDelegate == null ) { scriptLoader = getClass ( ) . getClassLoader ( ) ; return scriptLoader ; } scriptLoader = cpDelegate . getClassLoader ( ) ; return scriptLoader ; } private ClasspathUtils . Delegate getClassPathDelegate ( ) { if ( cpDelegate == null ) { cpDelegate = ClasspathUtils . getDelegate ( projectComponent ) ; } return cpDelegate ; } private ScriptRunnerBase getRunner ( ) { return new ScriptRunnerCreator ( projectComponent . getProject ( ) ) . createRunner ( manager , language , generateClassLoader ( ) ) ; } } 	0	['16', '1', '0', '13', '31', '76', '5', '8', '13', '0.791666667', '165', '1', '2', '0', '0.1953125', '0', '0', '8.8125', '4', '1.3125', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ExitStatusException ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class Exit extends Task { private static class NestedCondition extends ConditionBase implements Condition { public boolean eval ( ) { if ( countConditions ( ) != 1 ) { throw new BuildException ( "A single nested condition is required." ) ; } return ( ( Condition ) ( getConditions ( ) . nextElement ( ) ) ) . eval ( ) ; } } private String message ; private String ifCondition , unlessCondition ; private NestedCondition nestedCondition ; private Integer status ; public void setMessage ( String value ) { this . message = value ; } public void setIf ( String c ) { ifCondition = c ; } public void setUnless ( String c ) { unlessCondition = c ; } public void setStatus ( int i ) { status = new Integer ( i ) ; } public void execute ( ) throws BuildException { boolean fail = ( nestedConditionPresent ( ) ) ? testNestedCondition ( ) : ( testIfCondition ( ) && testUnlessCondition ( ) ) ; if ( fail ) { String text = null ; if ( message != null && message . trim ( ) . length ( ) > 0 ) { text = message . trim ( ) ; } else { if ( ifCondition != null && ifCondition . length ( ) > 0 && getProject ( ) . getProperty ( ifCondition ) != null ) { text = "if=" + ifCondition ; } if ( unlessCondition != null && unlessCondition . length ( ) > 0 && getProject ( ) . getProperty ( unlessCondition ) == null ) { if ( text == null ) { text = "" ; } else { text += " and " ; } text += "unless=" + unlessCondition ; } if ( nestedConditionPresent ( ) ) { text = "condition satisfied" ; } else { if ( text == null ) { text = "No message" ; } } } log ( "failing due to " + text , Project . MSG_DEBUG ) ; throw ( ( status == null ) ? new BuildException ( text ) : new ExitStatusException ( text , status . intValue ( ) ) ) ; } } public void addText ( String msg ) { if ( message == null ) { message = "" ; } message += getProject ( ) . replaceProperties ( msg ) ; } public ConditionBase createCondition ( ) { if ( nestedCondition != null ) { throw new BuildException ( "Only one nested condition is allowed." ) ; } nestedCondition = new NestedCondition ( ) ; return nestedCondition ; } private boolean testIfCondition ( ) { if ( ifCondition == null || "" . equals ( ifCondition ) ) { return true ; } return getProject ( ) . getProperty ( ifCondition ) != null ; } private boolean testUnlessCondition ( ) { if ( unlessCondition == null || "" . equals ( unlessCondition ) ) { return true ; } return getProject ( ) . getProperty ( unlessCondition ) == null ; } private boolean testNestedCondition ( ) { boolean result = nestedConditionPresent ( ) ; if ( result && ifCondition != null || unlessCondition != null ) { throw new BuildException ( "Nested conditions " + "not permitted in conjunction with if/unless attributes" ) ; } return result && nestedCondition . eval ( ) ; } private boolean nestedConditionPresent ( ) { return ( nestedCondition != null ) ; } } 	0	['12', '3', '0', '6', '30', '30', '0', '6', '8', '0.781818182', '282', '1', '1', '0.770833333', '0.472222222', '1', '1', '22.08333333', '6', '2.0833', '0']
package org . apache . tools . ant . util ; public class MergingMapper implements FileNameMapper { protected String [ ] mergedFile = null ; public void setFrom ( String from ) { } public void setTo ( String to ) { mergedFile = new String [ ] { to } ; } public String [ ] mapFileName ( String sourceFileName ) { return mergedFile ; } } 	0	['4', '1', '0', '4', '5', '0', '3', '1', '4', '0.333333333', '24', '1', '0', '0', '0.875', '0', '0', '4.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import java . io . File ; import java . util . List ; import java . util . LinkedList ; import java . util . ListIterator ; public class MakeUrl extends Task { private String property ; private File file ; private String separator = " " ; private List filesets = new LinkedList ( ) ; private List paths = new LinkedList ( ) ; private boolean validate = true ; public static final String ERROR_MISSING_FILE = "A source file is missing :" ; public static final String ERROR_NO_PROPERTY = "No property defined" ; public static final String ERROR_NO_FILES = "No files defined" ; public void setProperty ( String property ) { this . property = property ; } public void setFile ( File file ) { this . file = file ; } public void addFileSet ( FileSet fileset ) { filesets . add ( fileset ) ; } public void setSeparator ( String separator ) { this . separator = separator ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public void addPath ( Path path ) { paths . add ( path ) ; } private String filesetsToURL ( ) { if ( filesets . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = filesets . listIterator ( ) ; while ( list . hasNext ( ) ) { FileSet set = ( FileSet ) list . next ( ) ; DirectoryScanner scanner = set . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File f = new File ( scanner . getBasedir ( ) , files [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private String stripTrailingSeparator ( StringBuffer urls , int count ) { if ( count > 0 ) { urls . delete ( urls . length ( ) - separator . length ( ) , urls . length ( ) ) ; return new String ( urls ) ; } else { return "" ; } } private String pathsToURL ( ) { if ( paths . isEmpty ( ) ) { return "" ; } int count = 0 ; StringBuffer urls = new StringBuffer ( ) ; ListIterator list = paths . listIterator ( ) ; while ( list . hasNext ( ) ) { Path path = ( Path ) list . next ( ) ; String [ ] elements = path . list ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { File f = new File ( elements [ i ] ) ; validateFile ( f ) ; String asUrl = toURL ( f ) ; urls . append ( asUrl ) ; log ( asUrl , Project . MSG_DEBUG ) ; urls . append ( separator ) ; count ++ ; } } return stripTrailingSeparator ( urls , count ) ; } private void validateFile ( File fileToCheck ) { if ( validate && ! fileToCheck . exists ( ) ) { throw new BuildException ( ERROR_MISSING_FILE + fileToCheck . toString ( ) ) ; } } public void execute ( ) throws BuildException { validate ( ) ; if ( getProject ( ) . getProperty ( property ) != null ) { return ; } String url ; String filesetURL = filesetsToURL ( ) ; if ( file != null ) { validateFile ( file ) ; url = toURL ( file ) ; if ( filesetURL . length ( ) > 0 ) { url = url + separator + filesetURL ; } } else { url = filesetURL ; } String pathURL = pathsToURL ( ) ; if ( pathURL . length ( ) > 0 ) { if ( url . length ( ) > 0 ) { url = url + separator + pathURL ; } else { url = pathURL ; } } log ( "Setting " + property + " to URL " + url , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , url ) ; } private void validate ( ) { if ( property == null ) { throw new BuildException ( ERROR_NO_PROPERTY ) ; } if ( file == null && filesets . isEmpty ( ) && paths . isEmpty ( ) ) { throw new BuildException ( ERROR_NO_FILES ) ; } } private String toURL ( File fileToConvert ) { String url ; url = FileUtils . getFileUtils ( ) . toURI ( fileToConvert . getAbsolutePath ( ) ) ; return url ; } } 	0	['14', '3', '0', '7', '46', '27', '0', '7', '8', '0.837606838', '372', '0.666666667', '0', '0.74', '0.214285714', '1', '1', '24.92857143', '5', '1.8571', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; public interface SOSCmd { String COMMAND_SOS_EXE = "soscmd" ; String COMMAND_GET_FILE = "GetFile" ; String COMMAND_GET_PROJECT = "GetProject" ; String COMMAND_CHECKOUT_FILE = "CheckOutFile" ; String COMMAND_CHECKOUT_PROJECT = "CheckOutProject" ; String COMMAND_CHECKIN_FILE = "CheckInFile" ; String COMMAND_CHECKIN_PROJECT = "CheckInProject" ; String COMMAND_HISTORY = "GetFileHistory" ; String COMMAND_LABEL = "AddLabel" ; String PROJECT_PREFIX = "$" ; String FLAG_COMMAND = "-command" ; String FLAG_VSS_SERVER = "-database" ; String FLAG_USERNAME = "-name" ; String FLAG_PASSWORD = "-password" ; String FLAG_COMMENT = "-log" ; String FLAG_WORKING_DIR = "-workdir" ; String FLAG_RECURSION = "-recursive" ; String FLAG_VERSION = "-revision" ; String FLAG_LABEL = "-label" ; String FLAG_NO_COMPRESSION = "-nocompress" ; String FLAG_NO_CACHE = "-nocache" ; String FLAG_SOS_SERVER = "-server" ; String FLAG_SOS_HOME = "-soshome" ; String FLAG_PROJECT = "-project" ; String FLAG_FILE = "-file" ; String FLAG_VERBOSE = "-verbose" ; } 	0	['0', '1', '0', '1', '0', '0', '1', '0', '0', '2', '26', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . UnknownHostException ; public class IsReachable extends ProjectComponent implements Condition { private static final int SECOND = 1000 ; private String host ; private String url ; public static final int DEFAULT_TIMEOUT = 30 ; private int timeout = DEFAULT_TIMEOUT ; public static final String ERROR_NO_HOSTNAME = "No hostname defined" ; public static final String ERROR_BAD_TIMEOUT = "Invalid timeout value" ; private static final String WARN_UNKNOWN_HOST = "Unknown host: " ; public static final String ERROR_ON_NETWORK = "network error to " ; public static final String ERROR_BOTH_TARGETS = "Both url and host have been specified" ; public static final String MSG_NO_REACHABLE_TEST = "cannot do a proper reachability test on this Java version" ; public static final String ERROR_BAD_URL = "Bad URL " ; public static final String ERROR_NO_HOST_IN_URL = "No hostname in URL " ; public static final String METHOD_NAME = "isReachable" ; public void setHost ( String host ) { this . host = host ; } public void setUrl ( String url ) { this . url = url ; } public void setTimeout ( int timeout ) { this . timeout = timeout ; } private boolean empty ( String string ) { return string == null || string . length ( ) == 0 ; } private static Class [ ] parameterTypes = { Integer . TYPE } ; public boolean eval ( ) throws BuildException { if ( empty ( host ) && empty ( url ) ) { throw new BuildException ( ERROR_NO_HOSTNAME ) ; } if ( timeout < 0 ) { throw new BuildException ( ERROR_BAD_TIMEOUT ) ; } String target = host ; if ( ! empty ( url ) ) { if ( ! empty ( host ) ) { throw new BuildException ( ERROR_BOTH_TARGETS ) ; } try { URL realURL = new URL ( url ) ; target = realURL . getHost ( ) ; if ( empty ( target ) ) { throw new BuildException ( ERROR_NO_HOST_IN_URL + url ) ; } } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_BAD_URL + url , e ) ; } } log ( "Probing host " + target , Project . MSG_VERBOSE ) ; InetAddress address ; try { address = InetAddress . getByName ( target ) ; } catch ( UnknownHostException e1 ) { log ( WARN_UNKNOWN_HOST + target ) ; return false ; } log ( "Host address = " + address . getHostAddress ( ) , Project . MSG_VERBOSE ) ; boolean reachable ; Method reachableMethod = null ; try { reachableMethod = InetAddress . class . getMethod ( METHOD_NAME , parameterTypes ) ; Object [ ] params = new Object [ 1 ] ; params [ 0 ] = new Integer ( timeout * SECOND ) ; try { reachable = ( ( Boolean ) reachableMethod . invoke ( address , params ) ) . booleanValue ( ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "When calling " + reachableMethod ) ; } catch ( InvocationTargetException e ) { Throwable nested = e . getTargetException ( ) ; log ( ERROR_ON_NETWORK + target + ": " + nested . toString ( ) ) ; reachable = false ; } } catch ( NoSuchMethodException e ) { log ( "Not found: InetAddress." + METHOD_NAME , Project . MSG_VERBOSE ) ; log ( MSG_NO_REACHABLE_TEST ) ; reachable = true ; } log ( "host is" + ( reachable ? "" : " not" ) + " reachable" , Project . MSG_VERBOSE ) ; return reachable ; } } 	0	['7', '2', '0', '3', '30', '9', '0', '3', '5', '1.0625', '278', '0.375', '0', '0.642857143', '0.555555556', '0', '0', '36.42857143', '3', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . util . StringUtils ; public class DefaultExcludes extends Task { private String add = "" ; private String remove = "" ; private boolean defaultrequested = false ; private boolean echo = false ; private int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( ! defaultrequested && add . equals ( "" ) && remove . equals ( "" ) && ! echo ) { throw new BuildException ( "<defaultexcludes> task must set " + "at least one attribute (echo=\"false\"" + " doesn't count since that is the default" ) ; } if ( defaultrequested ) { DirectoryScanner . resetDefaultExcludes ( ) ; } if ( ! add . equals ( "" ) ) { DirectoryScanner . addDefaultExclude ( add ) ; } if ( ! remove . equals ( "" ) ) { DirectoryScanner . removeDefaultExclude ( remove ) ; } if ( echo ) { StringBuffer message = new StringBuffer ( "Current Default Excludes:" ) ; message . append ( StringUtils . LINE_SEP ) ; String [ ] excludes = DirectoryScanner . getDefaultExcludes ( ) ; for ( int i = 0 ; i < excludes . length ; i ++ ) { message . append ( "  " ) ; message . append ( excludes [ i ] ) ; message . append ( StringUtils . LINE_SEP ) ; } log ( message . toString ( ) , logLevel ) ; } } public void setDefault ( boolean def ) { defaultrequested = def ; } public void setAdd ( String add ) { this . add = add ; } public void setRemove ( String remove ) { this . remove = remove ; } public void setEcho ( boolean echo ) { this . echo = echo ; } } 	0	['6', '3', '0', '4', '17', '0', '0', '4', '6', '0.64', '131', '1', '0', '0.880952381', '0.555555556', '2', '2', '20', '1', '0.8333', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class StripLineBreaks extends BaseParamFilterReader implements ChainableReader { private static final String DEFAULT_LINE_BREAKS = "\r\n" ; private static final String LINE_BREAKS_KEY = "linebreaks" ; private String lineBreaks = DEFAULT_LINE_BREAKS ; public StripLineBreaks ( ) { super ( ) ; } public StripLineBreaks ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = in . read ( ) ; while ( ch != - 1 ) { if ( lineBreaks . indexOf ( ch ) == - 1 ) { break ; } else { ch = in . read ( ) ; } } return ch ; } public void setLineBreaks ( final String lineBreaks ) { this . lineBreaks = lineBreaks ; } private String getLineBreaks ( ) { return lineBreaks ; } public Reader chain ( final Reader rdr ) { StripLineBreaks newFilter = new StripLineBreaks ( rdr ) ; newFilter . setLineBreaks ( getLineBreaks ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { String userDefinedLineBreaks = null ; Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINE_BREAKS_KEY . equals ( params [ i ] . getName ( ) ) ) { userDefinedLineBreaks = params [ i ] . getValue ( ) ; break ; } } } if ( userDefinedLineBreaks != null ) { lineBreaks = userDefinedLineBreaks ; } } } 	0	['7', '5', '0', '4', '17', '0', '1', '3', '5', '0.777777778', '107', '1', '0', '0.848484848', '0.476190476', '2', '5', '13.85714286', '5', '1.2857', '0']
package org . apache . tools . ant . taskdefs ; public class Transform extends ExecuteOn { } 	0	['1', '5', '0', '1', '2', '0', '0', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . util ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class ClasspathUtils { public static final String REUSE_LOADER_REF = MagicNames . REFID_CLASSPATH_REUSE_LOADER ; public static ClassLoader getClassLoaderForPath ( Project p , Reference ref ) { return getClassLoaderForPath ( p , ref , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Reference ref , boolean reverseLoader ) { String pathId = ref . getRefId ( ) ; Object path = p . getReference ( pathId ) ; if ( ! ( path instanceof Path ) ) { throw new BuildException ( "The specified classpathref " + pathId + " does not reference a Path." ) ; } String loaderId = MagicNames . REFID_CLASSPATH_LOADER_PREFIX + pathId ; return getClassLoaderForPath ( p , ( Path ) path , loaderId , reverseLoader ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId ) { return getClassLoaderForPath ( p , path , loaderId , false ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader ) { return getClassLoaderForPath ( p , path , loaderId , reverseLoader , isMagicPropertySet ( p ) ) ; } public static ClassLoader getClassLoaderForPath ( Project p , Path path , String loaderId , boolean reverseLoader , boolean reuseLoader ) { ClassLoader cl = null ; if ( loaderId != null && reuseLoader ) { Object reusedLoader = p . getReference ( loaderId ) ; if ( reusedLoader != null && ! ( reusedLoader instanceof ClassLoader ) ) { throw new BuildException ( "The specified loader id " + loaderId + " does not reference a class loader" ) ; } cl = ( ClassLoader ) reusedLoader ; } if ( cl == null ) { cl = getUniqueClassLoaderForPath ( p , path , reverseLoader ) ; if ( loaderId != null && reuseLoader ) { p . addReference ( loaderId , cl ) ; } } return cl ; } public static ClassLoader getUniqueClassLoaderForPath ( Project p , Path path , boolean reverseLoader ) { AntClassLoader acl = p . createClassLoader ( path ) ; if ( reverseLoader ) { acl . setParentFirst ( false ) ; acl . addJavaLibraries ( ) ; } return acl ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader ) { return newInstance ( className , userDefinedLoader , Object . class ) ; } public static Object newInstance ( String className , ClassLoader userDefinedLoader , Class expectedType ) { try { Class clazz = Class . forName ( className , true , userDefinedLoader ) ; Object o = clazz . newInstance ( ) ; if ( ! expectedType . isInstance ( o ) ) { throw new BuildException ( "Class of unexpected Type: " + className + " expected :" + expectedType ) ; } return o ; } catch ( ClassNotFoundException e ) { throw new BuildException ( "Class not found: " + className , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a no " + "argument constructor." , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Could not instantiate " + className + ". Specified class should have a " + "public constructor." , e ) ; } catch ( LinkageError e ) { throw new BuildException ( "Class " + className + " could not be loaded because of an invalid dependency." , e ) ; } } public static Delegate getDelegate ( ProjectComponent component ) { return new Delegate ( component ) ; } private static boolean isMagicPropertySet ( Project p ) { return p . getProperty ( REUSE_LOADER_REF ) != null ; } public static class Delegate { private final ProjectComponent component ; private Path classpath ; private String classpathId ; private String className ; private String loaderId ; private boolean reverseLoader = false ; Delegate ( ProjectComponent component ) { this . component = component ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( component . getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClassname ( String fcqn ) { this . className = fcqn ; } public void setClasspathref ( Reference r ) { this . classpathId = r . getRefId ( ) ; createClasspath ( ) . setRefid ( r ) ; } public void setReverseLoader ( boolean reverseLoader ) { this . reverseLoader = reverseLoader ; } public void setLoaderRef ( Reference r ) { this . loaderId = r . getRefId ( ) ; } public ClassLoader getClassLoader ( ) { return getClassLoaderForPath ( getContextProject ( ) , this . classpath , getClassLoadId ( ) , this . reverseLoader , loaderId != null || isMagicPropertySet ( getContextProject ( ) ) ) ; } private Project getContextProject ( ) { return this . component . getProject ( ) ; } public String getClassLoadId ( ) { return this . loaderId == null && this . classpathId != null ? MagicNames . REFID_CLASSPATH_LOADER_PREFIX + this . classpathId : this . loaderId ; } public Object newInstance ( ) { return ClasspathUtils . newInstance ( this . className , getClassLoader ( ) ) ; } public Path getClasspath ( ) { return classpath ; } public boolean isReverseLoader ( ) { return reverseLoader ; } } } 	0	['12', '1', '0', '19', '33', '66', '13', '7', '10', '1.045454545', '261', '0', '0', '0', '0.259259259', '0', '0', '20.58333333', '8', '1.9167', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; public class Copydir extends MatchingTask { private File srcDir ; private File destDir ; private boolean filtering = false ; private boolean flatten = false ; private boolean forceOverwrite = false ; private Hashtable filecopyList = new Hashtable ( ) ; public void setSrc ( File src ) { srcDir = src ; } public void setDest ( File dest ) { destDir = dest ; } public void setFiltering ( boolean filter ) { filtering = filter ; } public void setFlatten ( boolean flatten ) { this . flatten = flatten ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copydir task is deprecated.  Use copy instead." ) ; if ( srcDir == null ) { throw new BuildException ( "src attribute must be set!" , getLocation ( ) ) ; } if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir " + srcDir . toString ( ) + " does not exist!" , getLocation ( ) ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." , getLocation ( ) ) ; } if ( srcDir . equals ( destDir ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } DirectoryScanner ds = super . getDirectoryScanner ( srcDir ) ; try { String [ ] files = ds . getIncludedFiles ( ) ; scanDir ( srcDir , destDir , files ) ; if ( filecopyList . size ( ) > 0 ) { log ( "Copying " + filecopyList . size ( ) + " file" + ( filecopyList . size ( ) == 1 ? "" : "s" ) + " to " + destDir . getAbsolutePath ( ) ) ; Enumeration e = filecopyList . keys ( ) ; while ( e . hasMoreElements ( ) ) { String fromFile = ( String ) e . nextElement ( ) ; String toFile = ( String ) filecopyList . get ( fromFile ) ; try { getProject ( ) . copyFile ( fromFile , toFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + fromFile + " to " + toFile + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } finally { filecopyList . clear ( ) ; } } private void scanDir ( File from , File to , String [ ] files ) { for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( from , filename ) ; File destFile ; if ( flatten ) { destFile = new File ( to , new File ( filename ) . getName ( ) ) ; } else { destFile = new File ( to , filename ) ; } if ( forceOverwrite || ( srcFile . lastModified ( ) > destFile . lastModified ( ) ) ) { filecopyList . put ( srcFile . getAbsolutePath ( ) , destFile . getAbsolutePath ( ) ) ; } } } } 	0	['8', '4', '0', '5', '39', '4', '0', '5', '7', '0.714285714', '274', '1', '0', '0.917647059', '0.46875', '4', '4', '32.5', '5', '1.375', '0']
package org . apache . tools . ant . types ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Enumeration ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class PatternSet extends DataType implements Cloneable { private Vector includeList = new Vector ( ) ; private Vector excludeList = new Vector ( ) ; private Vector includesFileList = new Vector ( ) ; private Vector excludesFileList = new Vector ( ) ; public class NameEntry { private String name ; private String ifCond ; private String unlessCond ; public void setName ( String name ) { this . name = name ; } public void setIf ( String cond ) { ifCond = cond ; } public void setUnless ( String cond ) { unlessCond = cond ; } public String getName ( ) { return name ; } public String evalName ( Project p ) { return valid ( p ) ? name : null ; } private boolean valid ( Project p ) { if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( name == null ) { buf . append ( "noname" ) ; } else { buf . append ( name ) ; } if ( ( ifCond != null ) || ( unlessCond != null ) ) { buf . append ( ":" ) ; String connector = "" ; if ( ifCond != null ) { buf . append ( "if->" ) ; buf . append ( ifCond ) ; connector = ";" ; } if ( unlessCond != null ) { buf . append ( connector ) ; buf . append ( "unless->" ) ; buf . append ( unlessCond ) ; } } return buf . toString ( ) ; } } public PatternSet ( ) { super ( ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! includeList . isEmpty ( ) || ! excludeList . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void addConfiguredPatternset ( PatternSet p ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } String [ ] nestedIncludes = p . getIncludePatterns ( getProject ( ) ) ; String [ ] nestedExcludes = p . getExcludePatterns ( getProject ( ) ) ; if ( nestedIncludes != null ) { for ( int i = 0 ; i < nestedIncludes . length ; i ++ ) { createInclude ( ) . setName ( nestedIncludes [ i ] ) ; } } if ( nestedExcludes != null ) { for ( int i = 0 ; i < nestedExcludes . length ; i ++ ) { createExclude ( ) . setName ( nestedExcludes [ i ] ) ; } } } public NameEntry createInclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includeList ) ; } public NameEntry createIncludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( includesFileList ) ; } public NameEntry createExclude ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludeList ) ; } public NameEntry createExcludesFile ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } return addPatternToList ( excludesFileList ) ; } public void setIncludes ( String includes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( includes != null && includes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( includes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createInclude ( ) . setName ( tok . nextToken ( ) ) ; } } } public void setExcludes ( String excludes ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( excludes != null && excludes . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( excludes , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( tok . nextToken ( ) ) ; } } } private NameEntry addPatternToList ( Vector list ) { NameEntry result = new NameEntry ( ) ; list . addElement ( result ) ; return result ; } public void setIncludesfile ( File includesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createIncludesFile ( ) . setName ( includesFile . getAbsolutePath ( ) ) ; } public void setExcludesfile ( File excludesFile ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createExcludesFile ( ) . setName ( excludesFile . getAbsolutePath ( ) ) ; } private void readPatterns ( File patternfile , Vector patternlist , Project p ) throws BuildException { BufferedReader patternReader = null ; try { patternReader = new BufferedReader ( new FileReader ( patternfile ) ) ; String line = patternReader . readLine ( ) ; while ( line != null ) { if ( line . length ( ) > 0 ) { line = p . replaceProperties ( line ) ; addPatternToList ( patternlist ) . setName ( line ) ; } line = patternReader . readLine ( ) ; } } catch ( IOException ioe ) { String msg = "An error occurred while reading from pattern file: " + patternfile ; throw new BuildException ( msg , ioe ) ; } finally { if ( null != patternReader ) { try { patternReader . close ( ) ; } catch ( IOException ioe ) { } } } } public void append ( PatternSet other , Project p ) { if ( isReference ( ) ) { throw new BuildException ( "Cannot append to a reference" ) ; } String [ ] incl = other . getIncludePatterns ( p ) ; if ( incl != null ) { for ( int i = 0 ; i < incl . length ; i ++ ) { createInclude ( ) . setName ( incl [ i ] ) ; } } String [ ] excl = other . getExcludePatterns ( p ) ; if ( excl != null ) { for ( int i = 0 ; i < excl . length ; i ++ ) { createExclude ( ) . setName ( excl [ i ] ) ; } } } public String [ ] getIncludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getIncludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( includeList , p ) ; } } public String [ ] getExcludePatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getExcludePatterns ( p ) ; } else { readFiles ( p ) ; return makeArray ( excludeList , p ) ; } } public boolean hasPatterns ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . hasPatterns ( p ) ; } else { return includesFileList . size ( ) > 0 || excludesFileList . size ( ) > 0 || includeList . size ( ) > 0 || excludeList . size ( ) > 0 ; } } private PatternSet getRef ( Project p ) { return ( PatternSet ) getCheckedRef ( p ) ; } private String [ ] makeArray ( Vector list , Project p ) { if ( list . size ( ) == 0 ) { return null ; } Vector tmpNames = new Vector ( ) ; for ( Enumeration e = list . elements ( ) ; e . hasMoreElements ( ) ; ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String pattern = ne . evalName ( p ) ; if ( pattern != null && pattern . length ( ) > 0 ) { tmpNames . addElement ( pattern ) ; } } String [ ] result = new String [ tmpNames . size ( ) ] ; tmpNames . copyInto ( result ) ; return result ; } private void readFiles ( Project p ) { if ( includesFileList . size ( ) > 0 ) { Enumeration e = includesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File inclFile = p . resolveFile ( fileName ) ; if ( ! inclFile . exists ( ) ) { throw new BuildException ( "Includesfile " + inclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( inclFile , includeList , p ) ; } } includesFileList . removeAllElements ( ) ; } if ( excludesFileList . size ( ) > 0 ) { Enumeration e = excludesFileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { NameEntry ne = ( NameEntry ) e . nextElement ( ) ; String fileName = ne . evalName ( p ) ; if ( fileName != null ) { File exclFile = p . resolveFile ( fileName ) ; if ( ! exclFile . exists ( ) ) { throw new BuildException ( "Excludesfile " + exclFile . getAbsolutePath ( ) + " not found." ) ; } readPatterns ( exclFile , excludeList , p ) ; } } excludesFileList . removeAllElements ( ) ; } } public String toString ( ) { return "patternSet{ includes: " + includeList + " excludes: " + excludeList + " }" ; } public Object clone ( ) { try { PatternSet ps = ( PatternSet ) super . clone ( ) ; ps . includeList = ( Vector ) includeList . clone ( ) ; ps . excludeList = ( Vector ) excludeList . clone ( ) ; ps . includesFileList = ( Vector ) includesFileList . clone ( ) ; ps . excludesFileList = ( Vector ) excludesFileList . clone ( ) ; return ps ; } catch ( CloneNotSupportedException e ) { throw new BuildException ( e ) ; } } } 	0	['22', '3', '0', '14', '62', '133', '10', '5', '17', '0.571428571', '625', '1', '0', '0.588235294', '0.266233766', '2', '3', '27.22727273', '9', '2.8182', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; public class Environment { protected Vector variables ; public static class Variable { private String key , value ; public Variable ( ) { super ( ) ; } public void setKey ( String key ) { this . key = key ; } public void setValue ( String value ) { this . value = value ; } public String getKey ( ) { return this . key ; } public String getValue ( ) { return this . value ; } public void setPath ( Path path ) { this . value = path . toString ( ) ; } public void setFile ( java . io . File file ) { this . value = file . getAbsolutePath ( ) ; } public String getContent ( ) throws BuildException { validate ( ) ; StringBuffer sb = new StringBuffer ( key . trim ( ) ) ; sb . append ( "=" ) . append ( value . trim ( ) ) ; return sb . toString ( ) ; } public void validate ( ) { if ( key == null || value == null ) { throw new BuildException ( "key and value must be specified " + "for environment variables." ) ; } } } public Environment ( ) { variables = new Vector ( ) ; } public void addVariable ( Variable var ) { variables . addElement ( var ) ; } public String [ ] getVariables ( ) throws BuildException { if ( variables . size ( ) == 0 ) { return null ; } String [ ] result = new String [ variables . size ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( ( Variable ) variables . elementAt ( i ) ) . getContent ( ) ; } return result ; } public Vector getVariablesVector ( ) { return variables ; } } 	0	['4', '1', '1', '8', '10', '0', '6', '2', '4', '0', '51', '1', '0', '0', '0.625', '0', '0', '11.5', '1', '0.75', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Locale ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . RuntimeConfigurable ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TypeAdapter ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . AttributeList ; import org . xml . sax . DocumentHandler ; import org . xml . sax . HandlerBase ; import org . xml . sax . InputSource ; import org . xml . sax . Locator ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . XMLReaderAdapter ; public class ProjectHelperImpl extends ProjectHelper { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private org . xml . sax . Parser parser ; private Project project ; private File buildFile ; private File buildFileParent ; private Locator locator ; private Target implicitTarget = new Target ( ) ; public ProjectHelperImpl ( ) { implicitTarget . setName ( "" ) ; } public void parse ( Project project , Object source ) throws BuildException { if ( ! ( source instanceof File ) ) { throw new BuildException ( "Only File source supported by " + "default plugin" ) ; } File bFile = ( File ) source ; FileInputStream inputStream = null ; InputSource inputSource = null ; this . project = project ; this . buildFile = new File ( bFile . getAbsolutePath ( ) ) ; buildFileParent = new File ( this . buildFile . getParent ( ) ) ; try { try { parser = JAXPUtils . getParser ( ) ; } catch ( BuildException e ) { parser = new XMLReaderAdapter ( JAXPUtils . getXMLReader ( ) ) ; } String uri = FILE_UTILS . toURI ( bFile . getAbsolutePath ( ) ) ; inputStream = new FileInputStream ( bFile ) ; inputSource = new InputSource ( inputStream ) ; inputSource . setSystemId ( uri ) ; project . log ( "parsing buildfile " + bFile + " with URI = " + uri , Project . MSG_VERBOSE ) ; HandlerBase hb = new RootHandler ( this ) ; parser . setDocumentHandler ( hb ) ; parser . setEntityResolver ( hb ) ; parser . setErrorHandler ( hb ) ; parser . setDTDHandler ( hb ) ; parser . parse ( inputSource ) ; } catch ( SAXParseException exc ) { Location location = new Location ( exc . getSystemId ( ) , exc . getLineNumber ( ) , exc . getColumnNumber ( ) ) ; Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { BuildException be = ( BuildException ) t ; if ( be . getLocation ( ) == Location . UNKNOWN_LOCATION ) { be . setLocation ( location ) ; } throw be ; } throw new BuildException ( exc . getMessage ( ) , t , location ) ; } catch ( SAXException exc ) { Throwable t = exc . getException ( ) ; if ( t instanceof BuildException ) { throw ( BuildException ) t ; } throw new BuildException ( exc . getMessage ( ) , t ) ; } catch ( FileNotFoundException exc ) { throw new BuildException ( exc ) ; } catch ( UnsupportedEncodingException exc ) { throw new BuildException ( "Encoding of project file is invalid." , exc ) ; } catch ( IOException exc ) { throw new BuildException ( "Error reading project file: " + exc . getMessage ( ) , exc ) ; } finally { FileUtils . close ( inputStream ) ; } } static class AbstractHandler extends HandlerBase { protected DocumentHandler parentHandler ; ProjectHelperImpl helperImpl ; public AbstractHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { this . parentHandler = parentHandler ; this . helperImpl = helperImpl ; helperImpl . parser . setDocumentHandler ( this ) ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { throw new SAXParseException ( "Unexpected element \"" + tag + "\"" , helperImpl . locator ) ; } public void characters ( char [ ] buf , int start , int count ) throws SAXParseException { String s = new String ( buf , start , count ) . trim ( ) ; if ( s . length ( ) > 0 ) { throw new SAXParseException ( "Unexpected text \"" + s + "\"" , helperImpl . locator ) ; } } public void endElement ( String name ) throws SAXException { helperImpl . parser . setDocumentHandler ( parentHandler ) ; } } static class RootHandler extends HandlerBase { ProjectHelperImpl helperImpl ; public RootHandler ( ProjectHelperImpl helperImpl ) { this . helperImpl = helperImpl ; } public InputSource resolveEntity ( String publicId , String systemId ) { helperImpl . project . log ( "resolving systemId: " + systemId , Project . MSG_VERBOSE ) ; if ( systemId . startsWith ( "file:" ) ) { String path = FILE_UTILS . fromURI ( systemId ) ; File file = new File ( path ) ; if ( ! file . isAbsolute ( ) ) { file = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , path ) ; helperImpl . project . log ( "Warning: '" + systemId + "' in " + helperImpl . buildFile + " should be expressed simply as '" + path . replace ( '\\' , '/' ) + "' for compliance with other XML tools" , Project . MSG_WARN ) ; } try { InputSource inputSource = new InputSource ( new FileInputStream ( file ) ) ; inputSource . setSystemId ( FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ) ; return inputSource ; } catch ( FileNotFoundException fne ) { helperImpl . project . log ( file . getAbsolutePath ( ) + " could not be found" , Project . MSG_WARN ) ; } } return null ; } public void startElement ( String tag , AttributeList attrs ) throws SAXParseException { if ( tag . equals ( "project" ) ) { new ProjectHandler ( helperImpl , this ) . init ( tag , attrs ) ; } else { throw new SAXParseException ( "Config file is not of expected " + "XML type" , helperImpl . locator ) ; } } public void setDocumentLocator ( Locator locator ) { helperImpl . locator = locator ; } } static class ProjectHandler extends AbstractHandler { public ProjectHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String def = null ; String name = null ; String id = null ; String baseDir = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "default" ) ) { def = value ; } else if ( key . equals ( "name" ) ) { name = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "basedir" ) ) { baseDir = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + attrs . getName ( i ) + "\"" , helperImpl . locator ) ; } } if ( def != null && ! def . equals ( "" ) ) { helperImpl . project . setDefaultTarget ( def ) ; } else { throw new BuildException ( "The default attribute is required" ) ; } if ( name != null ) { helperImpl . project . setName ( name ) ; helperImpl . project . addReference ( name , helperImpl . project ) ; } if ( id != null ) { helperImpl . project . addReference ( id , helperImpl . project ) ; } if ( helperImpl . project . getProperty ( "basedir" ) != null ) { helperImpl . project . setBasedir ( helperImpl . project . getProperty ( "basedir" ) ) ; } else { if ( baseDir == null ) { helperImpl . project . setBasedir ( helperImpl . buildFileParent . getAbsolutePath ( ) ) ; } else { if ( ( new File ( baseDir ) ) . isAbsolute ( ) ) { helperImpl . project . setBasedir ( baseDir ) ; } else { File resolvedBaseDir = FILE_UTILS . resolveFile ( helperImpl . buildFileParent , baseDir ) ; helperImpl . project . setBaseDir ( resolvedBaseDir ) ; } } } helperImpl . project . addTarget ( "" , helperImpl . implicitTarget ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( name . equals ( "target" ) ) { handleTarget ( name , attrs ) ; } else { handleElement ( helperImpl , this , helperImpl . implicitTarget , name , attrs ) ; } } private void handleTarget ( String tag , AttributeList attrs ) throws SAXParseException { new TargetHandler ( helperImpl , this ) . init ( tag , attrs ) ; } } static class TargetHandler extends AbstractHandler { private Target target ; public TargetHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { String name = null ; String depends = "" ; String ifCond = null ; String unlessCond = null ; String id = null ; String description = null ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { String key = attrs . getName ( i ) ; String value = attrs . getValue ( i ) ; if ( key . equals ( "name" ) ) { name = value ; if ( name . equals ( "" ) ) { throw new BuildException ( "name attribute must not" + " be empty" , new Location ( helperImpl . locator ) ) ; } } else if ( key . equals ( "depends" ) ) { depends = value ; } else if ( key . equals ( "if" ) ) { ifCond = value ; } else if ( key . equals ( "unless" ) ) { unlessCond = value ; } else if ( key . equals ( "id" ) ) { id = value ; } else if ( key . equals ( "description" ) ) { description = value ; } else { throw new SAXParseException ( "Unexpected attribute \"" + key + "\"" , helperImpl . locator ) ; } } if ( name == null ) { throw new SAXParseException ( "target element appears without a name attribute" , helperImpl . locator ) ; } target = new Target ( ) ; target . addDependency ( "" ) ; target . setName ( name ) ; target . setIf ( ifCond ) ; target . setUnless ( unlessCond ) ; target . setDescription ( description ) ; helperImpl . project . addTarget ( name , target ) ; if ( id != null && ! id . equals ( "" ) ) { helperImpl . project . addReference ( id , target ) ; } if ( depends . length ( ) > 0 ) { target . setDepends ( depends ) ; } } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { handleElement ( helperImpl , this , target , name , attrs ) ; } } private static void handleElement ( ProjectHelperImpl helperImpl , DocumentHandler parent , Target target , String elementName , AttributeList attrs ) throws SAXParseException { if ( elementName . equals ( "description" ) ) { new DescriptionHandler ( helperImpl , parent ) ; } else if ( helperImpl . project . getDataTypeDefinitions ( ) . get ( elementName ) != null ) { new DataTypeHandler ( helperImpl , parent , target ) . init ( elementName , attrs ) ; } else { new TaskHandler ( helperImpl , parent , target , null , target ) . init ( elementName , attrs ) ; } } static class DescriptionHandler extends AbstractHandler { public DescriptionHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler ) { super ( helperImpl , parentHandler ) ; } public void characters ( char [ ] buf , int start , int count ) { String text = new String ( buf , start , count ) ; String currentDescription = helperImpl . project . getDescription ( ) ; if ( currentDescription == null ) { helperImpl . project . setDescription ( text ) ; } else { helperImpl . project . setDescription ( currentDescription + text ) ; } } } static class TaskHandler extends AbstractHandler { private Target target ; private TaskContainer container ; private Task task ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable wrapper = null ; public TaskHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , TaskContainer container , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; this . container = container ; this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String tag , AttributeList attrs ) throws SAXParseException { try { task = helperImpl . project . createTask ( tag ) ; } catch ( BuildException e ) { } if ( task == null ) { task = new UnknownElement ( tag ) ; task . setProject ( helperImpl . project ) ; task . setTaskName ( tag ) ; } task . setLocation ( new Location ( helperImpl . locator ) ) ; helperImpl . configureId ( task , attrs ) ; task . setOwningTarget ( target ) ; container . addTask ( task ) ; task . init ( ) ; wrapper = task . getRuntimeConfigurableWrapper ( ) ; wrapper . setAttributes ( attrs ) ; if ( parentWrapper != null ) { parentWrapper . addChild ( wrapper ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( task instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) task , wrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , task , wrapper , target ) . init ( name , attrs ) ; } } } static class NestedElementHandler extends AbstractHandler { private Object parent ; private Object child ; private RuntimeConfigurable parentWrapper ; private RuntimeConfigurable childWrapper = null ; private Target target ; public NestedElementHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Object parent , RuntimeConfigurable parentWrapper , Target target ) { super ( helperImpl , parentHandler ) ; if ( parent instanceof TypeAdapter ) { this . parent = ( ( TypeAdapter ) parent ) . getProxy ( ) ; } else { this . parent = parent ; } this . parentWrapper = parentWrapper ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { Class parentClass = parent . getClass ( ) ; IntrospectionHelper ih = IntrospectionHelper . getHelper ( helperImpl . project , parentClass ) ; try { String elementName = propType . toLowerCase ( Locale . US ) ; if ( parent instanceof UnknownElement ) { UnknownElement uc = new UnknownElement ( elementName ) ; uc . setProject ( helperImpl . project ) ; ( ( UnknownElement ) parent ) . addChild ( uc ) ; child = uc ; } else { child = ih . createElement ( helperImpl . project , parent , elementName ) ; } helperImpl . configureId ( child , attrs ) ; childWrapper = new RuntimeConfigurable ( child , propType ) ; childWrapper . setAttributes ( attrs ) ; parentWrapper . addChild ( childWrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { childWrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { if ( child instanceof TaskContainer ) { new TaskHandler ( helperImpl , this , ( TaskContainer ) child , childWrapper , target ) . init ( name , attrs ) ; } else { new NestedElementHandler ( helperImpl , this , child , childWrapper , target ) . init ( name , attrs ) ; } } } static class DataTypeHandler extends AbstractHandler { private Target target ; private Object element ; private RuntimeConfigurable wrapper = null ; public DataTypeHandler ( ProjectHelperImpl helperImpl , DocumentHandler parentHandler , Target target ) { super ( helperImpl , parentHandler ) ; this . target = target ; } public void init ( String propType , AttributeList attrs ) throws SAXParseException { try { element = helperImpl . project . createDataType ( propType ) ; if ( element == null ) { throw new BuildException ( "Unknown data type " + propType ) ; } wrapper = new RuntimeConfigurable ( element , propType ) ; wrapper . setAttributes ( attrs ) ; target . addDataType ( wrapper ) ; } catch ( BuildException exc ) { throw new SAXParseException ( exc . getMessage ( ) , helperImpl . locator , exc ) ; } } public void characters ( char [ ] buf , int start , int count ) { wrapper . addText ( buf , start , count ) ; } public void startElement ( String name , AttributeList attrs ) throws SAXParseException { new NestedElementHandler ( helperImpl , this , element , wrapper , target ) . init ( name , attrs ) ; } } private void configureId ( Object target , AttributeList attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addReference ( id , target ) ; } } } 	0	['15', '2', '0', '18', '66', '77', '9', '13', '2', '0.87755102', '315', '1', '3', '0.566666667', '0.222222222', '1', '1', '19.53333333', '2', '0.9333', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . Javah ; public interface JavahAdapter { boolean compile ( Javah javah ) throws BuildException ; } 	0	['1', '1', '0', '5', '1', '0', '4', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; public class PresentSelector extends BaseSelector { private File targetdir = null ; private Mapper mapperElement = null ; private FileNameMapper map = null ; private boolean destmustexist = true ; public PresentSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{presentselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " present: " ) ; if ( destmustexist ) { buf . append ( "both" ) ; } else { buf . append ( "srconly" ) ; } if ( map != null ) { buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setTargetdir ( File targetdir ) { this . targetdir = targetdir ; } public Mapper createMapper ( ) throws BuildException { if ( mapperElement != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } mapperElement = new Mapper ( getProject ( ) ) ; return mapperElement ; } public void setPresent ( FilePresence fp ) { if ( fp . getIndex ( ) == 0 ) { destmustexist = false ; } } public void verifySettings ( ) { if ( targetdir == null ) { setError ( "The targetdir attribute is required." ) ; } if ( mapperElement == null ) { map = new IdentityMapper ( ) ; } else { map = mapperElement . getImplementation ( ) ; } if ( map == null ) { setError ( "Could not set <mapper> element." ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; String [ ] destfiles = map . mapFileName ( filename ) ; if ( destfiles == null ) { return false ; } if ( destfiles . length != 1 || destfiles [ 0 ] == null ) { throw new BuildException ( "Invalid destination file results for " + targetdir + " with filename " + filename ) ; } String destname = destfiles [ 0 ] ; File destfile = new File ( targetdir , destname ) ; return destfile . exists ( ) == destmustexist ; } public static class FilePresence extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "srconly" , "both" } ; } } } 	0	['7', '4', '0', '13', '26', '0', '6', '7', '7', '0.458333333', '198', '1', '2', '0.853658537', '0.392857143', '1', '3', '26.71428571', '5', '2.5714', '0']
package org . apache . tools . ant . input ; import java . util . Vector ; public class MultipleChoiceInputRequest extends InputRequest { private Vector choices = new Vector ( ) ; public MultipleChoiceInputRequest ( String prompt , Vector choices ) { super ( prompt ) ; if ( choices == null ) { throw new IllegalArgumentException ( "choices must not be null" ) ; } this . choices = choices ; } public Vector getChoices ( ) { return choices ; } public boolean isInputValid ( ) { return choices . contains ( getInput ( ) ) || ( "" . equals ( getInput ( ) ) && getDefaultValue ( ) != null ) ; } } 	0	['3', '2', '0', '3', '10', '0', '2', '1', '3', '0', '44', '1', '0', '0.75', '0.555555556', '1', '1', '13.33333333', '4', '1.6667', '0']
package org . apache . tools . mail ; import java . io . IOException ; import java . io . PrintStream ; import java . io . BufferedOutputStream ; import java . io . OutputStream ; import java . net . Socket ; import java . net . InetAddress ; import java . util . Vector ; import java . util . Enumeration ; public class MailMessage { public static final String DEFAULT_HOST = "localhost" ; public static final int DEFAULT_PORT = 25 ; private String host ; private int port = DEFAULT_PORT ; private String from ; private Vector replyto ; private Vector to ; private Vector cc ; private Vector headersKeys ; private Vector headersValues ; private MailPrintStream out ; private SmtpResponseReader in ; private Socket socket ; private static final int OK_READY = 220 ; private static final int OK_HELO = 250 ; private static final int OK_FROM = 250 ; private static final int OK_RCPT_1 = 250 ; private static final int OK_RCPT_2 = 251 ; private static final int OK_DATA = 354 ; private static final int OK_DOT = 250 ; private static final int OK_QUIT = 221 ; public MailMessage ( ) throws IOException { this ( DEFAULT_HOST , DEFAULT_PORT ) ; } public MailMessage ( String host ) throws IOException { this ( host , DEFAULT_PORT ) ; } public MailMessage ( String host , int port ) throws IOException { this . port = port ; this . host = host ; replyto = new Vector ( ) ; to = new Vector ( ) ; cc = new Vector ( ) ; headersKeys = new Vector ( ) ; headersValues = new Vector ( ) ; connect ( ) ; sendHelo ( ) ; } public void setPort ( int port ) { this . port = port ; } public void from ( String from ) throws IOException { sendFrom ( from ) ; this . from = from ; } public void replyto ( String rto ) { this . replyto . addElement ( rto ) ; } public void to ( String to ) throws IOException { sendRcpt ( to ) ; this . to . addElement ( to ) ; } public void cc ( String cc ) throws IOException { sendRcpt ( cc ) ; this . cc . addElement ( cc ) ; } public void bcc ( String bcc ) throws IOException { sendRcpt ( bcc ) ; } public void setSubject ( String subj ) { setHeader ( "Subject" , subj ) ; } public void setHeader ( String name , String value ) { headersKeys . add ( name ) ; headersValues . add ( value ) ; } public PrintStream getPrintStream ( ) throws IOException { setFromHeader ( ) ; setReplyToHeader ( ) ; setToHeader ( ) ; setCcHeader ( ) ; setHeader ( "X-Mailer" , "org.apache.tools.mail.MailMessage (ant.apache.org)" ) ; sendData ( ) ; flushHeaders ( ) ; return out ; } void setFromHeader ( ) { setHeader ( "From" , from ) ; } void setReplyToHeader ( ) { if ( ! replyto . isEmpty ( ) ) { setHeader ( "Reply-To" , vectorToList ( replyto ) ) ; } } void setToHeader ( ) { if ( ! to . isEmpty ( ) ) { setHeader ( "To" , vectorToList ( to ) ) ; } } void setCcHeader ( ) { if ( ! cc . isEmpty ( ) ) { setHeader ( "Cc" , vectorToList ( cc ) ) ; } } String vectorToList ( Vector v ) { StringBuffer buf = new StringBuffer ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { buf . append ( e . nextElement ( ) ) ; if ( e . hasMoreElements ( ) ) { buf . append ( ", " ) ; } } return buf . toString ( ) ; } void flushHeaders ( ) throws IOException { for ( int i = 0 ; i < headersKeys . size ( ) ; i ++ ) { String name = ( String ) headersKeys . elementAt ( i ) ; String value = ( String ) headersValues . elementAt ( i ) ; out . println ( name + ": " + value ) ; } out . println ( ) ; out . flush ( ) ; } public void sendAndClose ( ) throws IOException { try { sendDot ( ) ; sendQuit ( ) ; } finally { disconnect ( ) ; } } static String sanitizeAddress ( String s ) { int paramDepth = 0 ; int start = 0 ; int end = 0 ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = s . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; } } else if ( paramDepth == 0 && c == '<' ) { start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; } } if ( end == 0 ) { end = len ; } return s . substring ( start , end ) ; } void connect ( ) throws IOException { socket = new Socket ( host , port ) ; out = new MailPrintStream ( new BufferedOutputStream ( socket . getOutputStream ( ) ) ) ; in = new SmtpResponseReader ( socket . getInputStream ( ) ) ; getReady ( ) ; } void getReady ( ) throws IOException { String response = in . getResponse ( ) ; int [ ] ok = { OK_READY } ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Didn't get introduction from server: " + response ) ; } } void sendHelo ( ) throws IOException { String local = InetAddress . getLocalHost ( ) . getHostName ( ) ; int [ ] ok = { OK_HELO } ; send ( "HELO " + local , ok ) ; } void sendFrom ( String from ) throws IOException { int [ ] ok = { OK_FROM } ; send ( "MAIL FROM: " + "<" + sanitizeAddress ( from ) + ">" , ok ) ; } void sendRcpt ( String rcpt ) throws IOException { int [ ] ok = { OK_RCPT_1 , OK_RCPT_2 } ; send ( "RCPT TO: " + "<" + sanitizeAddress ( rcpt ) + ">" , ok ) ; } void sendData ( ) throws IOException { int [ ] ok = { OK_DATA } ; send ( "DATA" , ok ) ; } void sendDot ( ) throws IOException { int [ ] ok = { OK_DOT } ; send ( "\r\n." , ok ) ; } void sendQuit ( ) throws IOException { int [ ] ok = { OK_QUIT } ; try { send ( "QUIT" , ok ) ; } catch ( IOException e ) { throw new ErrorInQuitException ( e ) ; } } void send ( String msg , int [ ] ok ) throws IOException { out . rawPrint ( msg + "\r\n" ) ; String response = in . getResponse ( ) ; if ( ! isResponseOK ( response , ok ) ) { throw new IOException ( "Unexpected reply to command: " + msg + ": " + response ) ; } } boolean isResponseOK ( String response , int [ ] ok ) { for ( int i = 0 ; i < ok . length ; i ++ ) { if ( response . startsWith ( "" + ok [ i ] ) ) { return true ; } } return false ; } void disconnect ( ) throws IOException { if ( out != null ) { out . close ( ) ; } if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( socket != null ) { try { socket . close ( ) ; } catch ( IOException e ) { } } } } class MailPrintStream extends PrintStream { private int lastChar ; public MailPrintStream ( OutputStream out ) { super ( out , true ) ; } public void write ( int b ) { if ( b == '\n' && lastChar != '\r' ) { rawWrite ( '\r' ) ; rawWrite ( b ) ; } else if ( b == '.' && lastChar == '\n' ) { rawWrite ( '.' ) ; rawWrite ( b ) ; } else { rawWrite ( b ) ; } lastChar = b ; } public void write ( byte [ ] buf , int off , int len ) { for ( int i = 0 ; i < len ; i ++ ) { write ( buf [ off + i ] ) ; } } void rawWrite ( int b ) { super . write ( b ) ; } void rawPrint ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rawWrite ( s . charAt ( i ) ) ; } } } 	0	['31', '1', '0', '5', '70', '407', '2', '3', '13', '0.904761905', '615', '0.904761905', '2', '0', '0.316129032', '0', '0', '18.16129032', '11', '1.4516', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class DoubleCPInfo extends ConstantCPInfo { public DoubleCPInfo ( ) { super ( CONSTANT_DOUBLE , 2 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Double ( cpStream . readDouble ( ) ) ) ; } public String toString ( ) { return "Double Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; public class Socket extends ProjectComponent implements Condition { private String server = null ; private int port = 0 ; public void setServer ( String server ) { this . server = server ; } public void setPort ( int port ) { this . port = port ; } public boolean eval ( ) throws BuildException { if ( server == null ) { throw new BuildException ( "No server specified in socket " + "condition" ) ; } if ( port == 0 ) { throw new BuildException ( "No port specified in socket condition" ) ; } log ( "Checking for listener at " + server + ":" + port , Project . MSG_VERBOSE ) ; java . net . Socket s = null ; try { s = new java . net . Socket ( server , port ) ; } catch ( IOException e ) { return false ; } finally { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ioe ) { } } } return true ; } } 	0	['4', '2', '0', '4', '13', '0', '1', '3', '4', '0.333333333', '85', '1', '0', '0.75', '0.5', '0', '0', '19.75', '1', '0.75', '0']
package org . apache . tools . ant ; public class ExitStatusException extends BuildException { private int status ; public ExitStatusException ( int status ) { super ( ) ; this . status = status ; } public ExitStatusException ( String msg , int status ) { super ( msg ) ; this . status = status ; } public ExitStatusException ( String message , int status , Location location ) { super ( message , location ) ; this . status = status ; } public int getStatus ( ) { return status ; } } 	0	['4', '5', '0', '5', '7', '0', '3', '2', '4', '0', '29', '1', '0', '0.954545455', '0.625', '0', '0', '6', '1', '0.25', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . selectors . SelectorUtils ; public class Name implements ResourceSelector { private String pattern ; private boolean cs = true ; public void setName ( String n ) { pattern = n ; } public String getName ( ) { return pattern ; } public void setCaseSensitive ( boolean b ) { cs = b ; } public boolean isCaseSensitive ( ) { return cs ; } public boolean isSelected ( Resource r ) { String n = r . getName ( ) ; if ( SelectorUtils . match ( pattern , n , cs ) ) { return true ; } String s = r . toString ( ) ; return s . equals ( n ) ? false : SelectorUtils . match ( pattern , s , cs ) ; } } 	0	['6', '1', '0', '3', '11', '0', '0', '3', '6', '0.5', '56', '1', '0', '0', '0.375', '0', '0', '8', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public class Contains implements Condition { private String string , subString ; private boolean caseSensitive = true ; public void setString ( String string ) { this . string = string ; } public void setSubstring ( String subString ) { this . subString = subString ; } public void setCasesensitive ( boolean b ) { caseSensitive = b ; } public boolean eval ( ) throws BuildException { if ( string == null || subString == null ) { throw new BuildException ( "both string and substring are required " + "in contains" ) ; } return caseSensitive ? string . indexOf ( subString ) > - 1 : string . toLowerCase ( ) . indexOf ( subString . toLowerCase ( ) ) > - 1 ; } } 	0	['5', '1', '0', '3', '9', '0', '1', '2', '5', '0.666666667', '64', '1', '0', '0', '0.533333333', '0', '0', '11.2', '1', '0.8', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . types . Permissions ; public interface JUnitTaskMirror { void addVmExit ( JUnitTest test , JUnitResultFormatterMirror formatter , OutputStream out , String message , String testCase ) ; JUnitTestRunnerMirror newJUnitTestRunner ( JUnitTest test , boolean haltOnError , boolean filterTrace , boolean haltOnFailure , boolean showOutput , boolean logTestListenerEvents , AntClassLoader classLoader ) ; SummaryJUnitResultFormatterMirror newSummaryJUnitResultFormatter ( ) ; public interface JUnitResultFormatterMirror { void setOutput ( OutputStream outputStream ) ; } public interface SummaryJUnitResultFormatterMirror extends JUnitResultFormatterMirror { void setWithOutAndErr ( boolean value ) ; } public interface JUnitTestRunnerMirror { String IGNORED_FILE_NAME = "IGNORETHIS" ; int SUCCESS = 0 ; int FAILURES = 1 ; int ERRORS = 2 ; void setPermissions ( Permissions perm ) ; void run ( ) ; void addFormatter ( JUnitResultFormatterMirror formatter ) ; int getRetCode ( ) ; void handleErrorFlush ( String output ) ; void handleErrorOutput ( String output ) ; void handleOutput ( String output ) ; int handleInput ( byte [ ] buffer , int offset , int length ) throws IOException ; void handleFlush ( String output ) ; } } 	0	['3', '1', '0', '7', '3', '3', '2', '5', '3', '2', '3', '0', '0', '0', '0.476190476', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public abstract class ProjectComponent implements Cloneable { protected Project project ; protected Location location = Location . UNKNOWN_LOCATION ; protected String description ; public ProjectComponent ( ) { } public void setProject ( Project project ) { this . project = project ; } public Project getProject ( ) { return project ; } public Location getLocation ( ) { return location ; } public void setLocation ( Location location ) { this . location = location ; } public void setDescription ( String desc ) { description = desc ; } public String getDescription ( ) { return description ; } public void log ( String msg ) { log ( msg , Project . MSG_INFO ) ; } public void log ( String msg , int msgLevel ) { if ( getProject ( ) != null ) { getProject ( ) . log ( msg , msgLevel ) ; } else { if ( msgLevel <= Project . MSG_INFO ) { System . err . println ( msg ) ; } } } public Object clone ( ) throws CloneNotSupportedException { ProjectComponent pc = ( ProjectComponent ) super . clone ( ) ; pc . setLocation ( getLocation ( ) ) ; pc . setProject ( getProject ( ) ) ; return pc ; } } 	0	['10', '1', '28', '67', '14', '35', '66', '2', '10', '0.740740741', '75', '1', '2', '0', '0.32', '0', '0', '6.2', '3', '1.1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . types . Parameter ; public final class StripLineComments extends BaseParamFilterReader implements ChainableReader { private static final String COMMENTS_KEY = "comment" ; private Vector comments = new Vector ( ) ; private String line = null ; public StripLineComments ( ) { super ( ) ; } public StripLineComments ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { line = readLine ( ) ; final int commentsSize = comments . size ( ) ; while ( line != null ) { for ( int i = 0 ; i < commentsSize ; i ++ ) { String comment = ( String ) comments . elementAt ( i ) ; if ( line . startsWith ( comment ) ) { line = null ; break ; } } if ( line == null ) { line = readLine ( ) ; } else { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredComment ( final Comment comment ) { comments . addElement ( comment . getValue ( ) ) ; } private void setComments ( final Vector comments ) { this . comments = comments ; } private Vector getComments ( ) { return comments ; } public Reader chain ( final Reader rdr ) { StripLineComments newFilter = new StripLineComments ( rdr ) ; newFilter . setComments ( getComments ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( COMMENTS_KEY . equals ( params [ i ] . getType ( ) ) ) { comments . addElement ( params [ i ] . getValue ( ) ) ; } } } } public static class Comment { private String value ; public final void setValue ( String comment ) { value = comment ; } public final String getValue ( ) { return value ; } } } 	0	['8', '5', '0', '5', '26', '0', '1', '4', '5', '0.571428571', '172', '1', '0', '0.823529412', '0.375', '2', '5', '20.125', '4', '1.125', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; public class CSharp extends DotnetCompile { String definitions ; private File docFile ; private int fileAlign = 0 ; private boolean fullpaths = false ; private boolean incremental ; protected boolean unsafe ; private boolean noconfig = false ; public CSharp ( ) { clear ( ) ; } public void clear ( ) { super . clear ( ) ; docFile = null ; fileAlign = 0 ; fullpaths = true ; incremental = false ; unsafe = false ; noconfig = false ; definitions = null ; setExecutable ( isWindows ? "csc" : "mcs" ) ; } public void setDocFile ( File f ) { docFile = f ; } protected String getDocFileParameter ( ) { if ( docFile != null ) { return "/doc:" + docFile . toString ( ) ; } else { return null ; } } public void setFileAlign ( int fileAlign ) { this . fileAlign = fileAlign ; } protected String getFileAlignParameter ( ) { if ( fileAlign != 0 && ! "mcs" . equals ( getExecutable ( ) ) ) { return "/filealign:" + fileAlign ; } else { return null ; } } public void setFullPaths ( boolean enabled ) { fullpaths = enabled ; } protected String getFullPathsParameter ( ) { return fullpaths ? "/fullpaths" : null ; } public void setIncremental ( boolean incremental ) { this . incremental = incremental ; } public boolean getIncremental ( ) { return incremental ; } protected String getIncrementalParameter ( ) { return "/incremental" + ( incremental ? "+" : "-" ) ; } public void setOutputFile ( File params ) { setDestFile ( params ) ; } public void setUnsafe ( boolean unsafe ) { this . unsafe = unsafe ; } public boolean getUnsafe ( ) { return this . unsafe ; } protected String getUnsafeParameter ( ) { return unsafe ? "/unsafe" : null ; } public void setNoConfig ( boolean enabled ) { noconfig = enabled ; } protected String getNoConfigParameter ( ) { return noconfig ? "/noconfig" : null ; } public void setDefinitions ( String params ) { definitions = params ; } protected String getDefinitionsParameter ( ) { String predecessors = super . getDefinitionsParameter ( ) ; if ( notEmpty ( definitions ) ) { if ( predecessors == null ) { predecessors = "/define:" ; } return predecessors + definitions ; } else { return predecessors ; } } public void addCompilerSpecificOptions ( NetCommand command ) { command . addArgument ( getIncludeDefaultReferencesParameter ( ) ) ; command . addArgument ( getWarnLevelParameter ( ) ) ; command . addArgument ( getDocFileParameter ( ) ) ; command . addArgument ( getFullPathsParameter ( ) ) ; command . addArgument ( getFileAlignParameter ( ) ) ; command . addArgument ( getIncrementalParameter ( ) ) ; command . addArgument ( getNoConfigParameter ( ) ) ; command . addArgument ( getUnsafeParameter ( ) ) ; } public String getReferenceDelimiter ( ) { return ";" ; } public String getFileExtension ( ) { return "cs" ; } protected void createResourceParameter ( NetCommand command , DotnetResource resource ) { resource . getParameters ( getProject ( ) , command , true ) ; } } 	0	['23', '6', '0', '4', '42', '185', '0', '4', '15', '0.811688312', '249', '0.857142857', '0', '0.872093023', '0.211180124', '1', '7', '9.52173913', '3', '1.3913', '0']
package org . apache . tools . ant . types ; public interface ResourceFactory { Resource getResource ( String name ) ; } 	0	['1', '1', '0', '9', '1', '0', '8', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant ; public interface DynamicConfiguratorNS extends DynamicAttributeNS , DynamicElementNS { } 	0	['0', '1', '0', '3', '0', '0', '1', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class TimeComparison extends EnumeratedAttribute { private static final String [ ] VALUES = new String [ ] { "before" , "after" , "equal" } ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public static final TimeComparison BEFORE = new TimeComparison ( "before" ) ; public static final TimeComparison AFTER = new TimeComparison ( "after" ) ; public static final TimeComparison EQUAL = new TimeComparison ( "equal" ) ; public TimeComparison ( ) { } public TimeComparison ( String value ) { setValue ( value ) ; } public String [ ] getValues ( ) { return VALUES ; } public boolean evaluate ( long t1 , long t2 ) { return evaluate ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public boolean evaluate ( long t1 , long t2 , long g ) { int cmp = getIndex ( ) ; if ( cmp == - 1 ) { throw new BuildException ( "TimeComparison value not set." ) ; } if ( cmp == 0 ) { return t1 - g < t2 ; } if ( cmp == 1 ) { return t1 + g > t2 ; } return Math . abs ( t1 - t2 ) <= g ; } public static int compare ( long t1 , long t2 ) { return compare ( t1 , t2 , FILE_UTILS . getFileTimestampGranularity ( ) ) ; } public static int compare ( long t1 , long t2 , long g ) { long diff = t1 - t2 ; long abs = Math . abs ( diff ) ; return abs > Math . abs ( g ) ? ( int ) ( diff / abs ) : 0 ; } } 	0	['8', '2', '1', '8', '15', '20', '5', '3', '7', '0.914285714', '136', '0.4', '4', '0.615384615', '0.476190476', '1', '1', '15.375', '7', '1.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class MSVSSCREATE extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CREATE ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getQuiet ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; return commandLine ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } public final void setQuiet ( boolean quiet ) { super . setInternalQuiet ( quiet ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } } 	0	['5', '4', '0', '5', '21', '10', '0', '5', '4', '2', '71', '0', '0', '0.957894737', '0.533333333', '1', '1', '13.2', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; public class NotSelector extends NoneSelector { public NotSelector ( ) { } public NotSelector ( FileSelector other ) { this ( ) ; appendSelector ( other ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{notselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public void verifySettings ( ) { if ( selectorCount ( ) != 1 ) { setError ( "One and only one selector is allowed within the " + "<not> tag" ) ; } } } 	0	['4', '6', '0', '8', '13', '6', '6', '2', '4', '2', '44', '0', '0', '0.96969697', '0.625', '2', '3', '10', '2', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . JavaClass ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class AncestorAnalyzer extends AbstractAnalyzer { public AncestorAnalyzer ( ) { try { new ClassParser ( "force" ) ; } catch ( IOException e ) { } } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; Hashtable nextAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 2 ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { nextAnalyze . clear ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ClassParser parser = null ; if ( container . getName ( ) . endsWith ( ".class" ) ) { parser = new ClassParser ( container . getPath ( ) ) ; } else { parser = new ClassParser ( container . getPath ( ) , classname . replace ( '.' , '/' ) + ".class" ) ; } JavaClass javaClass = parser . parse ( ) ; String [ ] interfaces = javaClass . getInterfaceNames ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { String interfaceName = interfaces [ i ] ; if ( ! dependencies . containsKey ( interfaceName ) ) { nextAnalyze . put ( interfaceName , interfaceName ) ; } } if ( javaClass . isClass ( ) ) { String superClass = javaClass . getSuperclassName ( ) ; if ( ! dependencies . containsKey ( superClass ) ) { nextAnalyze . put ( superClass , superClass ) ; } } } catch ( IOException ioe ) { } } Hashtable temp = toAnalyze ; toAnalyze = nextAnalyze ; nextAnalyze = temp ; } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	0	['3', '2', '0', '3', '31', '3', '0', '3', '1', '2', '202', '0', '0', '0.882352941', '0.666666667', '1', '2', '66.33333333', '14', '5', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; public class Ilasm extends DotnetBaseMatchingTask { protected static final String exe_name = "ilasm" ; protected static final String file_ext = "il" ; protected static final String file_pattern = "**/*." + file_ext ; protected static final String exe_title = "ilasm" ; protected String targetType ; protected boolean verbose ; protected boolean listing ; protected File resourceFile ; protected boolean failOnError ; protected boolean debug ; private File keyfile ; protected String extraOptions ; protected Vector referenceFilesets = new Vector ( ) ; private boolean isMono = ! Os . isFamily ( "windows" ) ; public Ilasm ( ) { Clear ( ) ; setIncludes ( file_pattern ) ; } public void Clear ( ) { targetType = null ; srcDir = null ; listing = false ; verbose = false ; debug = true ; outputFile = null ; failOnError = true ; resourceFile = null ; extraOptions = null ; } public void setTargetType ( String targetType ) throws BuildException { this . targetType = targetType . toLowerCase ( ) ; if ( ! targetType . equals ( "exe" ) && ! targetType . equals ( "library" ) ) { throw new BuildException ( "targetType " + targetType + " is not a valid type" ) ; } } public String getTargetType ( ) { return targetType ; } protected String getTargetTypeParameter ( ) { if ( ! notEmpty ( targetType ) ) { return null ; } if ( targetType . equals ( "exe" ) ) { return "/exe" ; } else if ( targetType . equals ( "library" ) ) { return "/dll" ; } else { return null ; } } public void setOwner ( String s ) { log ( "This option is not supported by ILASM as of Beta-2, " + "and will be ignored" , Project . MSG_WARN ) ; } protected boolean notEmpty ( String s ) { return s != null && s . length ( ) != 0 ; } public void setVerbose ( boolean b ) { verbose = b ; } protected String getVerboseParameter ( ) { return verbose ? null : "/quiet" ; } public void setListing ( boolean b ) { listing = b ; } protected String getListingParameter ( ) { if ( ! isMono ) { return listing ? "/listing" : "/nolisting" ; } return null ; } public void setOutputFile ( File params ) { outputFile = params ; } protected String getOutputFileParameter ( ) { if ( outputFile == null ) { return null ; } return "/output=" + outputFile . toString ( ) ; } public void setResourceFile ( File fileName ) { resourceFile = fileName ; } protected String getResourceFileParameter ( ) { if ( resourceFile != null ) { return "/resource=" + resourceFile . toString ( ) ; } else { return null ; } } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailOnError ( ) { return failOnError ; } public void setDebug ( boolean f ) { debug = f ; } public boolean getDebug ( ) { return debug ; } protected String getDebugParameter ( ) { return debug ? "/debug" : null ; } public void setKeyfile ( File keyfile ) { this . keyfile = keyfile ; } protected String getKeyfileParameter ( ) { if ( keyfile != null ) { return "/keyfile:" + keyfile . toString ( ) ; } else { return null ; } } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public String getExtraOptions ( ) { return this . extraOptions ; } protected String getExtraOptionsParameter ( ) { if ( extraOptions != null && extraOptions . length ( ) != 0 ) { return extraOptions ; } else { return null ; } } public void setTargetType ( TargetTypes targetType ) { this . targetType = targetType . getValue ( ) ; } public void setMono ( boolean b ) { isMono = b ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; NetCommand command = buildIlasmCommand ( ) ; addFilesAndExecute ( command , false ) ; } private NetCommand buildIlasmCommand ( ) { NetCommand command = new NetCommand ( this , exe_title , exe_name ) ; command . setFailOnError ( getFailOnError ( ) ) ; command . addArgument ( getDebugParameter ( ) ) ; command . addArgument ( getTargetTypeParameter ( ) ) ; command . addArgument ( getListingParameter ( ) ) ; command . addArgument ( getOutputFileParameter ( ) ) ; command . addArgument ( getResourceFileParameter ( ) ) ; command . addArgument ( getVerboseParameter ( ) ) ; command . addArgument ( getKeyfileParameter ( ) ) ; command . addArgument ( getExtraOptionsParameter ( ) ) ; return command ; } public void addReference ( FileSet reference ) { referenceFilesets . add ( reference ) ; } protected static boolean isFileManagedBinary ( File file ) { String filename = file . toString ( ) . toLowerCase ( ) ; return filename . endsWith ( ".exe" ) || filename . endsWith ( ".dll" ) || filename . endsWith ( ".netmodule" ) ; } public static class TargetTypes extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "exe" , "library" , } ; } } } 	0	['31', '5', '0', '7', '51', '381', '0', '7', '20', '0.919047619', '376', '1', '0', '0.743589744', '0.241935484', '2', '4', '10.67741935', '4', '1.5161', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; public class DependSelector extends MappingSelector { public DependSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dependselector targetdir: " ) ; if ( targetdir == null ) { buf . append ( "NOT YET SET" ) ; } else { buf . append ( targetdir . getName ( ) ) ; } buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( map != null ) { buf . append ( " mapper: " ) ; buf . append ( map . toString ( ) ) ; } else if ( mapperElement != null ) { buf . append ( " mapper: " ) ; buf . append ( mapperElement . toString ( ) ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public boolean selectionTest ( File srcfile , File destfile ) { boolean selected = SelectorUtils . isOutOfDate ( srcfile , destfile , granularity ) ; return selected ; } } 	0	['3', '5', '0', '10', '12', '1', '6', '4', '3', '2', '76', '0', '0', '0.953488372', '0.666666667', '1', '1', '24.33333333', '4', '1.6667', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class TarResource extends ArchiveResource { private String userName = "" ; private String groupName = "" ; private int uid ; private int gid ; public TarResource ( ) { } public TarResource ( File a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public TarResource ( Resource a , TarEntry e ) { super ( a , true ) ; setEntry ( e ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } Resource archive = getArchive ( ) ; final TarInputStream i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { return i ; } } FileUtils . close ( i ) ; throw new BuildException ( "no entry " + getName ( ) + " in " + getArchive ( ) ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( "Use the tar task for tar output." ) ; } public String getUserName ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUserName ( ) ; } return userName ; } public String getGroup ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGroup ( ) ; } return groupName ; } public int getUid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getUid ( ) ; } return uid ; } public int getGid ( ) { if ( isReference ( ) ) { return ( ( TarResource ) getCheckedRef ( ) ) . getGid ( ) ; } return uid ; } protected void fetchEntry ( ) { Resource archive = getArchive ( ) ; TarInputStream i = null ; try { i = new TarInputStream ( archive . getInputStream ( ) ) ; TarEntry te = null ; while ( ( te = i . getNextEntry ( ) ) != null ) { if ( te . getName ( ) . equals ( getName ( ) ) ) { setEntry ( te ) ; return ; } } } catch ( IOException e ) { log ( e . getMessage ( ) , Project . MSG_DEBUG ) ; throw new BuildException ( e ) ; } finally { if ( i != null ) { FileUtils . close ( i ) ; } } setEntry ( null ) ; } private void setEntry ( TarEntry e ) { if ( e == null ) { setExists ( false ) ; return ; } setName ( e . getName ( ) ) ; setExists ( true ) ; setLastModified ( e . getModTime ( ) . getTime ( ) ) ; setDirectory ( e . isDirectory ( ) ) ; setSize ( e . getSize ( ) ) ; setMode ( e . getMode ( ) ) ; userName = e . getUserName ( ) ; groupName = e . getGroupName ( ) ; uid = e . getUserId ( ) ; gid = e . getGroupId ( ) ; } } 	0	['11', '5', '0', '8', '49', '21', '2', '6', '9', '0.55', '265', '1', '0', '0.896103896', '0.363636364', '2', '4', '22.72727273', '7', '1.7273', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . Vector ; public class P4Submit extends P4Base { public String change ; private String changeProperty ; private String needsResolveProperty ; public void setChange ( String change ) { this . change = change ; } public void setChangeProperty ( String changeProperty ) { this . changeProperty = changeProperty ; } public void setNeedsResolveProperty ( String needsResolveProperty ) { this . needsResolveProperty = needsResolveProperty ; } public void execute ( ) throws BuildException { if ( change != null ) { execP4Command ( "submit -c " + change , ( P4HandlerAdapter ) new P4SubmitAdapter ( this ) ) ; } else { throw new BuildException ( "No change specified (no support for default change yet...." ) ; } } public class P4SubmitAdapter extends SimpleP4OutputHandler { public P4SubmitAdapter ( P4Base parent ) { super ( parent ) ; } public void process ( String line ) { super . process ( line ) ; getProject ( ) . setProperty ( "p4.needsresolve" , "0" ) ; if ( util . match ( "/renamed/" , line ) ) { try { Vector myarray = new Vector ( ) ; util . split ( myarray , line ) ; boolean found = false ; for ( int counter = 0 ; counter < myarray . size ( ) ; counter ++ ) { if ( found ) { String chnum = ( String ) myarray . elementAt ( counter + 1 ) ; int changenumber = Integer . parseInt ( chnum ) ; log ( "Perforce change renamed " + changenumber , Project . MSG_INFO ) ; getProject ( ) . setProperty ( "p4.change" , "" + changenumber ) ; if ( changeProperty != null ) { getProject ( ) . setNewProperty ( changeProperty , chnum ) ; } found = false ; } if ( ( ( myarray . elementAt ( counter ) ) ) . equals ( "renamed" ) ) { found = true ; } } } catch ( Exception e ) { String msg = "Failed to parse " + line + "\n" + " due to " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } } if ( util . match ( "/p4 submit -c/" , line ) ) { getProject ( ) . setProperty ( "p4.needsresolve" , "1" ) ; if ( needsResolveProperty != null ) { getProject ( ) . setNewProperty ( needsResolveProperty , "true" ) ; } } } } } 	0	['7', '4', '0', '4', '14', '15', '1', '4', '5', '0.833333333', '56', '0.666666667', '0', '0.894736842', '0.476190476', '1', '1', '6.571428571', '1', '0.8571', '0']
package org . apache . tools . ant . types ; public interface Parameterizable { void setParameters ( Parameter [ ] parameters ) ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . lang . ref . WeakReference ; public class WeakishReference { private WeakReference weakref ; WeakishReference ( Object reference ) { this . weakref = new WeakReference ( reference ) ; } public Object get ( ) { return weakref . get ( ) ; } public static WeakishReference createReference ( Object object ) { return new WeakishReference ( object ) ; } public static class HardReference extends WeakishReference { public HardReference ( Object object ) { super ( object ) ; } } } 	0	['3', '1', '1', '1', '6', '1', '1', '0', '2', '0', '22', '1', '0', '0', '0.666666667', '0', '0', '6', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . StringUtils ; public class CVSPass extends Task { private String cvsRoot = null ; private File passFile = null ; private String password = null ; private final char [ ] shifts = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 114 , 120 , 53 , 79 , 96 , 109 , 72 , 108 , 70 , 64 , 76 , 67 , 116 , 74 , 68 , 87 , 111 , 52 , 75 , 119 , 49 , 34 , 82 , 81 , 95 , 65 , 112 , 86 , 118 , 110 , 122 , 105 , 41 , 57 , 83 , 43 , 46 , 102 , 40 , 89 , 38 , 103 , 45 , 50 , 42 , 123 , 91 , 35 , 125 , 55 , 54 , 66 , 124 , 126 , 59 , 47 , 92 , 71 , 115 , 78 , 88 , 107 , 106 , 56 , 36 , 121 , 117 , 104 , 101 , 100 , 69 , 73 , 99 , 63 , 94 , 93 , 39 , 37 , 61 , 48 , 58 , 113 , 32 , 90 , 44 , 98 , 60 , 51 , 33 , 97 , 62 , 77 , 84 , 80 , 85 , 223 , 225 , 216 , 187 , 166 , 229 , 189 , 222 , 188 , 141 , 249 , 148 , 200 , 184 , 136 , 248 , 190 , 199 , 170 , 181 , 204 , 138 , 232 , 218 , 183 , 255 , 234 , 220 , 247 , 213 , 203 , 226 , 193 , 174 , 172 , 228 , 252 , 217 , 201 , 131 , 230 , 197 , 211 , 145 , 238 , 161 , 179 , 160 , 212 , 207 , 221 , 254 , 173 , 202 , 146 , 224 , 151 , 140 , 196 , 205 , 130 , 135 , 133 , 143 , 246 , 192 , 159 , 244 , 239 , 185 , 168 , 215 , 144 , 139 , 165 , 180 , 157 , 147 , 186 , 214 , 176 , 227 , 231 , 219 , 169 , 175 , 156 , 206 , 198 , 129 , 164 , 150 , 210 , 154 , 177 , 134 , 127 , 182 , 128 , 158 , 208 , 162 , 132 , 167 , 209 , 149 , 241 , 153 , 251 , 237 , 236 , 171 , 195 , 243 , 233 , 253 , 240 , 194 , 250 , 191 , 155 , 142 , 137 , 245 , 235 , 163 , 242 , 178 , 152 } ; public CVSPass ( ) { passFile = new File ( System . getProperty ( "cygwin.user.home" , System . getProperty ( "user.home" ) ) + File . separatorChar + ".cvspass" ) ; } public final void execute ( ) throws BuildException { if ( cvsRoot == null ) { throw new BuildException ( "cvsroot is required" ) ; } if ( password == null ) { throw new BuildException ( "password is required" ) ; } log ( "cvsRoot: " + cvsRoot , Project . MSG_DEBUG ) ; log ( "password: " + password , Project . MSG_DEBUG ) ; log ( "passFile: " + passFile , Project . MSG_DEBUG ) ; BufferedReader reader = null ; PrintWriter writer = null ; try { StringBuffer buf = new StringBuffer ( ) ; if ( passFile . exists ( ) ) { reader = new BufferedReader ( new FileReader ( passFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( cvsRoot ) ) { buf . append ( line ) . append ( StringUtils . LINE_SEP ) ; } } } String pwdfile = buf . toString ( ) + cvsRoot + " A" + mangle ( password ) ; log ( "Writing -> " + pwdfile , Project . MSG_DEBUG ) ; writer = new PrintWriter ( new FileWriter ( passFile ) ) ; writer . println ( pwdfile ) ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } if ( writer != null ) { writer . close ( ) ; } } } private final String mangle ( String password ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < password . length ( ) ; i ++ ) { buf . append ( shifts [ password . charAt ( i ) ] ) ; } return buf . toString ( ) ; } public void setCvsroot ( String cvsRoot ) { this . cvsRoot = cvsRoot ; } public void setPassfile ( File passFile ) { this . passFile = passFile ; } public void setPassword ( String password ) { this . password = password ; } } 	0	['6', '3', '0', '3', '32', '0', '0', '3', '5', '0.6', '1254', '1', '0', '0.880952381', '0.555555556', '1', '1', '207.3333333', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; public class LogLevel extends EnumeratedAttribute { public static final LogLevel ERR = new LogLevel ( "error" ) ; public static final LogLevel WARN = new LogLevel ( "warn" ) ; public static final LogLevel INFO = new LogLevel ( "info" ) ; public static final LogLevel VERBOSE = new LogLevel ( "verbose" ) ; public static final LogLevel DEBUG = new LogLevel ( "debug" ) ; public LogLevel ( ) { } private LogLevel ( String value ) { this ( ) ; setValue ( value ) ; } public String [ ] getValues ( ) { return new String [ ] { "error" , "warn" , "warning" , "info" , "verbose" , "debug" } ; } private static int [ ] levels = { Project . MSG_ERR , Project . MSG_WARN , Project . MSG_WARN , Project . MSG_INFO , Project . MSG_VERBOSE , Project . MSG_DEBUG } ; public int getLevel ( ) { return levels [ getIndex ( ) ] ; } } 	0	['5', '2', '2', '3', '8', '8', '2', '1', '3', '0.958333333', '101', '0.166666667', '5', '0.8', '0.625', '1', '1', '18', '1', '0.4', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import java . util . Iterator ; import java . net . MalformedURLException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . FileUtils ; public class WsdlToDotnet extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File destFile = null ; private String language = "CS" ; private boolean server = false ; private String namespace = null ; private boolean failOnError = true ; protected String extraOptions = null ; private String protocol = null ; private boolean ideErrors = false ; private Vector schemas = new Vector ( ) ; private Schema wsdl = new Schema ( ) ; private Compiler compiler = null ; public static final String ERROR_DEST_FILE_IS_DIR = "destination file is a directory" ; public static final String ERROR_NO_DEST_FILE = "destination file must be specified" ; public void setDestFile ( File destFile ) { this . destFile = destFile ; } public void setUrl ( String url ) { wsdl . setUrl ( url ) ; } public void setSrcFile ( File srcFile ) { wsdl . setFile ( srcFile ) ; } public void setLanguage ( String language ) { this . language = language ; } public void setServer ( boolean server ) { this . server = server ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public void setIdeErrors ( boolean ideErrors ) { this . ideErrors = ideErrors ; } public void setProtocol ( String protocol ) { this . protocol = protocol ; } public void addSchema ( Schema source ) { schemas . add ( source ) ; } public void setMakeURL ( boolean b ) { wsdl . setMakeURL ( b ) ; } public void setCompiler ( Compiler compiler ) { this . compiler = compiler ; } protected void validate ( ) throws BuildException { if ( destFile == null ) { throw new BuildException ( ERROR_NO_DEST_FILE ) ; } if ( destFile . isDirectory ( ) ) { throw new BuildException ( ERROR_DEST_FILE_IS_DIR ) ; } wsdl . validate ( ) ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; if ( compiler == null ) { compiler = Compiler . createDefaultCompiler ( ) ; } validate ( ) ; NetCommand command = new NetCommand ( this , "WSDL" , compiler . getCommand ( ) ) ; command . setFailOnError ( failOnError ) ; compiler . applyExtraArgs ( command ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( "/out:" + destFile ) ; command . addArgument ( "/language:" , language ) ; if ( server ) { command . addArgument ( "/server" ) ; } command . addArgument ( "/namespace:" , namespace ) ; if ( protocol != null ) { command . addArgument ( "/protocol:" + protocol ) ; } if ( ideErrors ) { command . addArgument ( "/parsableErrors" ) ; } command . addArgument ( extraOptions ) ; boolean rebuild = true ; long destLastModified = - 1 ; if ( destFile . exists ( ) ) { destLastModified = destFile . lastModified ( ) ; rebuild = isRebuildNeeded ( wsdl , destLastModified ) ; } String path ; path = wsdl . evaluate ( ) ; if ( ! compiler . supportsAbsoluteFiles ( ) && wsdl . getFile ( ) != null ) { File f = wsdl . getFile ( ) ; command . setDirectory ( f . getParentFile ( ) ) ; path = f . getName ( ) ; } command . addArgument ( path ) ; Iterator it = schemas . iterator ( ) ; while ( it . hasNext ( ) ) { Schema schema = ( Schema ) it . next ( ) ; rebuild |= isRebuildNeeded ( schema , destLastModified ) ; command . addArgument ( schema . evaluate ( ) ) ; } if ( rebuild ) { command . runCommand ( ) ; } } private boolean isRebuildNeeded ( Schema schema , long destLastModified ) { if ( destLastModified == - 1 ) { return true ; } return ! FILE_UTILS . isUpToDate ( schema . getTimestamp ( ) , destLastModified ) ; } public static class Schema { private File file ; private String url ; private boolean makeURL = false ; public static final String ERROR_NONE_DECLARED = "One of file and url must be set" ; public static final String ERROR_BOTH_DECLARED = "Only one of file or url can be set" ; public static final String ERROR_FILE_NOT_FOUND = "Not found: " ; public static final String ERROR_FILE_IS_DIR = "File is a directory: " ; public static final String ERROR_NO_URL_CONVERT = "Could not URL convert " ; public void validate ( ) { if ( file != null ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_FILE_NOT_FOUND + file . toString ( ) ) ; } if ( file . isDirectory ( ) ) { throw new BuildException ( ERROR_FILE_IS_DIR + file . toString ( ) ) ; } } if ( file != null && url != null ) { throw new BuildException ( ERROR_BOTH_DECLARED ) ; } if ( file == null && url == null ) { throw new BuildException ( ERROR_NONE_DECLARED ) ; } } public String evaluate ( ) { validate ( ) ; if ( url != null ) { return getUrl ( ) ; } if ( makeURL ) { try { return file . toURL ( ) . toExternalForm ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_CONVERT + file ) ; } } return file . toString ( ) ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public boolean isMakeURL ( ) { return makeURL ; } public void setMakeURL ( boolean makeURL ) { this . makeURL = makeURL ; } public long getTimestamp ( ) { if ( file != null ) { return file . lastModified ( ) ; } else { return - 1 ; } } } public static class Compiler extends EnumeratedAttribute { public static final String COMPILER_MS = "microsoft" ; public static final String COMPILER_MONO = "mono" ; public static final String COMPILER_MS_ON_MONO = "microsoft-on-mono" ; String [ ] compilers = { COMPILER_MS , COMPILER_MONO , COMPILER_MS_ON_MONO } ; public static final String EXE_WSDL = "wsdl" ; public static final String EXE_MONO = "mono" ; String [ ] compilerExecutables = { EXE_WSDL , EXE_WSDL , EXE_MONO } ; String [ ] [ ] extraCompilerArgs = { { } , { } , { EXE_WSDL + ".exe" } } ; boolean [ ] absoluteFiles = { true , false , true } ; public String [ ] getValues ( ) { return compilers ; } public static Compiler createDefaultCompiler ( ) { Compiler c = new Compiler ( ) ; String compilerName ; compilerName = Os . isFamily ( "windows" ) ? COMPILER_MS : COMPILER_MONO ; c . setValue ( compilerName ) ; return c ; } public String getCommand ( ) { return compilerExecutables [ getIndex ( ) ] ; } public String [ ] getExtraArgs ( ) { return extraCompilerArgs [ getIndex ( ) ] ; } public boolean supportsAbsoluteFiles ( ) { return absoluteFiles [ getIndex ( ) ] ; } public void applyExtraArgs ( NetCommand command ) { String [ ] args = getExtraArgs ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { command . addArgument ( args [ i ] ) ; } } } } 	0	['18', '3', '0', '6', '55', '79', '0', '6', '15', '0.890756303', '322', '0.857142857', '3', '0.698113208', '0.268907563', '1', '1', '16.11111111', '3', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Size extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return ( int ) ( foo . getSize ( ) - bar . getSize ( ) ) ; } } 	0	['2', '4', '0', '2', '4', '1', '0', '2', '1', '2', '12', '0', '0', '0.971428571', '0.75', '1', '1', '5', '1', '0.5', '0']
package org . apache . tools . ant . types ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . Map ; import java . util . HashSet ; import java . util . Set ; import java . util . TreeMap ; import java . util . Hashtable ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . resources . PropertyResource ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . regexp . RegexpMatcher ; import org . apache . tools . ant . util . regexp . RegexpMatcherFactory ; public class PropertySet extends DataType implements ResourceCollection { private boolean dynamic = true ; private boolean negate = false ; private Set cachedNames ; private Vector ptyRefs = new Vector ( ) ; private Vector setRefs = new Vector ( ) ; private Mapper mapper ; public static class PropertyRef { private int count ; private String name ; private String regex ; private String prefix ; private String builtin ; public void setName ( String name ) { assertValid ( "name" , name ) ; this . name = name ; } public void setRegex ( String regex ) { assertValid ( "regex" , regex ) ; this . regex = regex ; } public void setPrefix ( String prefix ) { assertValid ( "prefix" , prefix ) ; this . prefix = prefix ; } public void setBuiltin ( BuiltinPropertySetName b ) { String pBuiltIn = b . getValue ( ) ; assertValid ( "builtin" , pBuiltIn ) ; this . builtin = pBuiltIn ; } private void assertValid ( String attr , String value ) { if ( value == null || value . length ( ) < 1 ) { throw new BuildException ( "Invalid attribute: " + attr ) ; } if ( ++ count != 1 ) { throw new BuildException ( "Attributes name, regex, and " + "prefix are mutually exclusive" ) ; } } public String toString ( ) { return "name=" + name + ", regex=" + regex + ", prefix=" + prefix + ", builtin=" + builtin ; } } public void appendName ( String name ) { PropertyRef r = new PropertyRef ( ) ; r . setName ( name ) ; addPropertyref ( r ) ; } public void appendRegex ( String regex ) { PropertyRef r = new PropertyRef ( ) ; r . setRegex ( regex ) ; addPropertyref ( r ) ; } public void appendPrefix ( String prefix ) { PropertyRef r = new PropertyRef ( ) ; r . setPrefix ( prefix ) ; addPropertyref ( r ) ; } public void appendBuiltin ( BuiltinPropertySetName b ) { PropertyRef r = new PropertyRef ( ) ; r . setBuiltin ( b ) ; addPropertyref ( r ) ; } public void setMapper ( String type , String from , String to ) { Mapper m = createMapper ( ) ; Mapper . MapperType mapperType = new Mapper . MapperType ( ) ; mapperType . setValue ( type ) ; m . setType ( mapperType ) ; m . setFrom ( from ) ; m . setTo ( to ) ; } public void addPropertyref ( PropertyRef ref ) { assertNotReference ( ) ; ptyRefs . addElement ( ref ) ; } public void addPropertyset ( PropertySet ref ) { assertNotReference ( ) ; setRefs . addElement ( ref ) ; } public Mapper createMapper ( ) { assertNotReference ( ) ; if ( mapper != null ) { throw new BuildException ( "Too many <mapper>s!" ) ; } mapper = new Mapper ( getProject ( ) ) ; return mapper ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public void setDynamic ( boolean dynamic ) { assertNotReference ( ) ; this . dynamic = dynamic ; } public void setNegate ( boolean negate ) { assertNotReference ( ) ; this . negate = negate ; } public boolean getDynamic ( ) { return isReference ( ) ? getRef ( ) . dynamic : dynamic ; } public Mapper getMapper ( ) { return isReference ( ) ? getRef ( ) . mapper : mapper ; } private Hashtable getAllSystemProperties ( ) { Hashtable ret = new Hashtable ( ) ; for ( Enumeration e = System . getProperties ( ) . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; ret . put ( name , System . getProperties ( ) . getProperty ( name ) ) ; } return ret ; } public Properties getProperties ( ) { if ( isReference ( ) ) { return getRef ( ) . getProperties ( ) ; } Set names = null ; Project prj = getProject ( ) ; Hashtable props = prj == null ? getAllSystemProperties ( ) : prj . getProperties ( ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; props . putAll ( set . getProperties ( ) ) ; } if ( getDynamic ( ) || cachedNames == null ) { names = new HashSet ( ) ; addPropertyNames ( names , props ) ; for ( Enumeration e = setRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertySet set = ( PropertySet ) e . nextElement ( ) ; names . addAll ( set . getProperties ( ) . keySet ( ) ) ; } if ( negate ) { HashSet complement = new HashSet ( props . keySet ( ) ) ; complement . removeAll ( names ) ; names = complement ; } if ( ! getDynamic ( ) ) { cachedNames = names ; } } else { names = cachedNames ; } FileNameMapper m = null ; Mapper myMapper = getMapper ( ) ; if ( myMapper != null ) { m = myMapper . getImplementation ( ) ; } Properties properties = new Properties ( ) ; for ( Iterator iter = names . iterator ( ) ; iter . hasNext ( ) ; ) { String name = ( String ) iter . next ( ) ; String value = ( String ) props . get ( name ) ; if ( value != null ) { if ( m != null ) { String [ ] newname = m . mapFileName ( name ) ; if ( newname != null ) { name = newname [ 0 ] ; } } properties . setProperty ( name , value ) ; } } return properties ; } private void addPropertyNames ( Set names , Hashtable properties ) { for ( Enumeration e = ptyRefs . elements ( ) ; e . hasMoreElements ( ) ; ) { PropertyRef r = ( PropertyRef ) e . nextElement ( ) ; if ( r . name != null ) { if ( properties . get ( r . name ) != null ) { names . add ( r . name ) ; } } else if ( r . prefix != null ) { for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( name . startsWith ( r . prefix ) ) { names . add ( name ) ; } } } else if ( r . regex != null ) { RegexpMatcherFactory matchMaker = new RegexpMatcherFactory ( ) ; RegexpMatcher matcher = matchMaker . newRegexpMatcher ( ) ; matcher . setPattern ( r . regex ) ; for ( Enumeration p = properties . keys ( ) ; p . hasMoreElements ( ) ; ) { String name = ( String ) p . nextElement ( ) ; if ( matcher . matches ( name ) ) { names . add ( name ) ; } } } else if ( r . builtin != null ) { if ( r . builtin . equals ( BuiltinPropertySetName . ALL ) ) { names . addAll ( properties . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . SYSTEM ) ) { names . addAll ( System . getProperties ( ) . keySet ( ) ) ; } else if ( r . builtin . equals ( BuiltinPropertySetName . COMMANDLINE ) ) { names . addAll ( getProject ( ) . getUserProperties ( ) . keySet ( ) ) ; } else { throw new BuildException ( "Impossible: Invalid builtin " + "attribute!" ) ; } } else { throw new BuildException ( "Impossible: Invalid PropertyRef!" ) ; } } } protected PropertySet getRef ( ) { return ( PropertySet ) getCheckedRef ( PropertySet . class , "propertyset" ) ; } public final void setRefid ( Reference r ) { if ( ! noAttributeSet ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected final void assertNotReference ( ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } noAttributeSet = false ; } private boolean noAttributeSet = true ; public static class BuiltinPropertySetName extends EnumeratedAttribute { static final String ALL = "all" ; static final String SYSTEM = "system" ; static final String COMMANDLINE = "commandline" ; public String [ ] getValues ( ) { return new String [ ] { ALL , SYSTEM , COMMANDLINE } ; } } public String toString ( ) { StringBuffer b = new StringBuffer ( ) ; TreeMap sorted = new TreeMap ( getProperties ( ) ) ; for ( Iterator i = sorted . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; if ( b . length ( ) != 0 ) { b . append ( ", " ) ; } b . append ( e . getKey ( ) . toString ( ) ) ; b . append ( "=" ) ; b . append ( e . getValue ( ) . toString ( ) ) ; } return b . toString ( ) ; } public Iterator iterator ( ) { final Enumeration e = getProperties ( ) . propertyNames ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } public Object next ( ) { return new PropertyResource ( getProject ( ) , ( String ) e . nextElement ( ) ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public int size ( ) { return isReference ( ) ? getRef ( ) . size ( ) : getProperties ( ) . size ( ) ; } public boolean isFilesystemOnly ( ) { return isReference ( ) && getRef ( ) . isFilesystemOnly ( ) ; } } 	0	['24', '3', '0', '21', '96', '246', '9', '13', '20', '0.722826087', '610', '0.875', '1', '0.566037736', '0.154166667', '1', '1', '24.08333333', '14', '2.5417', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class ServerDeploy extends Task { private String action ; private File source ; private Vector vendorTools = new Vector ( ) ; public void addGeneric ( GenericHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addWeblogic ( WebLogicHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void addJonas ( JonasHotDeploymentTool tool ) { tool . setTask ( this ) ; vendorTools . addElement ( tool ) ; } public void execute ( ) throws BuildException { for ( Enumeration e = vendorTools . elements ( ) ; e . hasMoreElements ( ) ; ) { HotDeploymentTool tool = ( HotDeploymentTool ) e . nextElement ( ) ; tool . validateAttributes ( ) ; tool . deploy ( ) ; } } public String getAction ( ) { return action ; } public void setAction ( String action ) { this . action = action ; } public File getSource ( ) { return source ; } public void setSource ( File source ) { this . source = source ; } } 	0	['9', '3', '0', '7', '20', '12', '5', '6', '9', '0.75', '75', '1', '0', '0.822222222', '0.259259259', '0', '0', '7', '1', '0.8889', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public class JspNameMangler implements JspMangler { public static final String [ ] keywords = { "assert" , "abstract" , "boolean" , "break" , "byte" , "case" , "catch" , "char" , "class" , "const" , "continue" , "default" , "do" , "double" , "else" , "extends" , "final" , "finally" , "float" , "for" , "goto" , "if" , "implements" , "import" , "instanceof" , "int" , "interface" , "long" , "native" , "new" , "package" , "private" , "protected" , "public" , "return" , "short" , "static" , "super" , "switch" , "synchronized" , "this" , "throw" , "throws" , "transient" , "try" , "void" , "volatile" , "while" } ; public String mapJspToJavaName ( File jspFile ) { return mapJspToBaseName ( jspFile ) + ".java" ; } private String mapJspToBaseName ( File jspFile ) { String className ; className = stripExtension ( jspFile ) ; for ( int i = 0 ; i < keywords . length ; ++ i ) { if ( className . equals ( keywords [ i ] ) ) { className += "%" ; break ; } } StringBuffer modifiedClassName = new StringBuffer ( className . length ( ) ) ; char firstChar = className . charAt ( 0 ) ; if ( Character . isJavaIdentifierStart ( firstChar ) ) { modifiedClassName . append ( firstChar ) ; } else { modifiedClassName . append ( mangleChar ( firstChar ) ) ; } for ( int i = 1 ; i < className . length ( ) ; i ++ ) { char subChar = className . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( subChar ) ) { modifiedClassName . append ( subChar ) ; } else { modifiedClassName . append ( mangleChar ( subChar ) ) ; } } return modifiedClassName . toString ( ) ; } private String stripExtension ( File jspFile ) { String className ; String filename = jspFile . getName ( ) ; if ( filename . endsWith ( ".jsp" ) ) { className = filename . substring ( 0 , filename . length ( ) - 4 ) ; } else { className = filename ; } return className ; } private static String mangleChar ( char ch ) { if ( ch == File . separatorChar ) { ch = '/' ; } String s = Integer . toHexString ( ch ) ; int nzeros = 5 - s . length ( ) ; char [ ] result = new char [ 6 ] ; result [ 0 ] = '_' ; for ( int i = 1 ; i <= nzeros ; ++ i ) { result [ i ] = '0' ; } int resultIndex = 0 ; for ( int i = nzeros + 1 ; i < 6 ; ++ i ) { result [ i ] = s . charAt ( resultIndex ++ ) ; } return new String ( result ) ; } public String mapPath ( String path ) { return null ; } } 	0	['7', '1', '0', '2', '24', '19', '1', '1', '3', '0.666666667', '373', '0', '0', '0', '0.416666667', '0', '0', '52.14285714', '6', '2', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkdir extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNoco = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKDIR ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOCHECKOUT = "-nco" ; } 	0	['11', '4', '0', '7', '33', '37', '0', '7', '8', '0.9', '178', '0.428571429', '0', '0.827586207', '0.386363636', '2', '3', '14.54545455', '4', '1.3636', '0']
package org . apache . tools . ant . taskdefs . optional ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . XmlConstants ; import org . xml . sax . XMLReader ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . ParserConfigurationException ; import java . util . Iterator ; import java . util . HashMap ; import java . io . File ; import java . net . MalformedURLException ; public class SchemaValidate extends XMLValidateTask { private HashMap schemaLocations = new HashMap ( ) ; private boolean fullChecking = true ; private boolean disableDTD = false ; private SchemaLocation anonymousSchema ; public static final String ERROR_SAX_1 = "SAX1 parsers are not supported" ; public static final String ERROR_NO_XSD_SUPPORT = "Parser does not support Xerces or JAXP schema features" ; public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS = "Only one of defaultSchemaFile and defaultSchemaURL allowed" ; public static final String ERROR_PARSER_CREATION_FAILURE = "Could not create parser" ; public static final String MESSAGE_ADDING_SCHEMA = "Adding schema " ; public static final String ERROR_DUPLICATE_SCHEMA = "Duplicate declaration of schema " ; public void init ( ) throws BuildException { super . init ( ) ; setLenient ( false ) ; } public boolean enableXercesSchemaValidation ( ) { try { setFeature ( XmlConstants . FEATURE_XSD , true ) ; setNoNamespaceSchemaProperty ( XmlConstants . PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } private void setNoNamespaceSchemaProperty ( String property ) { String anonSchema = getNoNamespaceSchemaURL ( ) ; if ( anonSchema != null ) { setProperty ( property , anonSchema ) ; } } public boolean enableJAXP12SchemaValidation ( ) { try { setProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_LANGUAGE , XmlConstants . URI_XSD ) ; setNoNamespaceSchemaProperty ( XmlConstants . FEATURE_JAXP12_SCHEMA_SOURCE ) ; } catch ( BuildException e ) { log ( e . toString ( ) , Project . MSG_VERBOSE ) ; return false ; } return true ; } public void addConfiguredSchema ( SchemaLocation location ) { log ( "adding schema " + location , Project . MSG_DEBUG ) ; location . validateNamespace ( ) ; SchemaLocation old = ( SchemaLocation ) schemaLocations . get ( location . getNamespace ( ) ) ; if ( old != null && ! old . equals ( location ) ) { throw new BuildException ( ERROR_DUPLICATE_SCHEMA + location ) ; } schemaLocations . put ( location . getNamespace ( ) , location ) ; } public void setFullChecking ( boolean fullChecking ) { this . fullChecking = fullChecking ; } protected void createAnonymousSchema ( ) { if ( anonymousSchema == null ) { anonymousSchema = new SchemaLocation ( ) ; } anonymousSchema . setNamespace ( "(no namespace)" ) ; } public void setNoNamespaceURL ( String defaultSchemaURL ) { createAnonymousSchema ( ) ; this . anonymousSchema . setUrl ( defaultSchemaURL ) ; } public void setNoNamespaceFile ( File defaultSchemaFile ) { createAnonymousSchema ( ) ; this . anonymousSchema . setFile ( defaultSchemaFile ) ; } public void setDisableDTD ( boolean disableDTD ) { this . disableDTD = disableDTD ; } protected void initValidator ( ) { super . initValidator ( ) ; if ( isSax1Parser ( ) ) { throw new BuildException ( ERROR_SAX_1 ) ; } setFeature ( XmlConstants . FEATURE_NAMESPACES , true ) ; if ( ! enableXercesSchemaValidation ( ) && ! enableJAXP12SchemaValidation ( ) ) { throw new BuildException ( ERROR_NO_XSD_SUPPORT ) ; } setFeature ( XmlConstants . FEATURE_XSD_FULL_VALIDATION , fullChecking ) ; setFeatureIfSupported ( XmlConstants . FEATURE_DISALLOW_DTD , disableDTD ) ; addSchemaLocations ( ) ; } protected XMLReader createDefaultReader ( ) { SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; factory . setValidating ( true ) ; factory . setNamespaceAware ( true ) ; XMLReader reader = null ; try { SAXParser saxParser = factory . newSAXParser ( ) ; reader = saxParser . getXMLReader ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } catch ( SAXException e ) { throw new BuildException ( ERROR_PARSER_CREATION_FAILURE , e ) ; } return reader ; } protected void addSchemaLocations ( ) { Iterator it = schemaLocations . values ( ) . iterator ( ) ; StringBuffer buffer = new StringBuffer ( ) ; int count = 0 ; while ( it . hasNext ( ) ) { if ( count > 0 ) { buffer . append ( ' ' ) ; } SchemaLocation schemaLocation = ( SchemaLocation ) it . next ( ) ; String tuple = schemaLocation . getURIandLocation ( ) ; buffer . append ( tuple ) ; log ( "Adding schema " + tuple , Project . MSG_VERBOSE ) ; count ++ ; } if ( count > 0 ) { setProperty ( XmlConstants . PROPERTY_SCHEMA_LOCATION , buffer . toString ( ) ) ; } } protected String getNoNamespaceSchemaURL ( ) { if ( anonymousSchema == null ) { return null ; } else { return anonymousSchema . getSchemaLocationURL ( ) ; } } protected void setFeatureIfSupported ( String feature , boolean value ) { try { getXmlReader ( ) . setFeature ( feature , value ) ; } catch ( SAXNotRecognizedException e ) { log ( "Not recognizied: " + feature , Project . MSG_VERBOSE ) ; } catch ( SAXNotSupportedException e ) { log ( "Not supported: " + feature , Project . MSG_VERBOSE ) ; } } protected void onSuccessfulValidation ( int fileProcessed ) { log ( fileProcessed + MESSAGE_FILES_VALIDATED , Project . MSG_VERBOSE ) ; } public static class SchemaLocation { private String namespace ; private File file ; private String url ; public static final String ERROR_NO_URI = "No namespace URI" ; public static final String ERROR_TWO_LOCATIONS = "Both URL and File were given for schema " ; public static final String ERROR_NO_FILE = "File not found: " ; public static final String ERROR_NO_URL_REPRESENTATION = "Cannot make a URL of " ; public static final String ERROR_NO_LOCATION = "No file or URL supplied for the schema " ; public SchemaLocation ( ) { } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public String getSchemaLocationURL ( ) { boolean hasFile = file != null ; boolean hasURL = isSet ( url ) ; if ( ! hasFile && ! hasURL ) { throw new BuildException ( ERROR_NO_LOCATION + namespace ) ; } if ( hasFile && hasURL ) { throw new BuildException ( ERROR_TWO_LOCATIONS + namespace ) ; } String schema = url ; if ( hasFile ) { if ( ! file . exists ( ) ) { throw new BuildException ( ERROR_NO_FILE + file ) ; } try { schema = FileUtils . getFileUtils ( ) . getFileURL ( file ) . toString ( ) ; } catch ( MalformedURLException e ) { throw new BuildException ( ERROR_NO_URL_REPRESENTATION + file , e ) ; } } return schema ; } public String getURIandLocation ( ) throws BuildException { validateNamespace ( ) ; StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace ) ; buffer . append ( ' ' ) ; buffer . append ( getSchemaLocationURL ( ) ) ; return new String ( buffer ) ; } public void validateNamespace ( ) { if ( ! isSet ( getNamespace ( ) ) ) { throw new BuildException ( ERROR_NO_URI ) ; } } private boolean isSet ( String property ) { return property != null && property . length ( ) != 0 ; } public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof SchemaLocation ) ) { return false ; } final SchemaLocation schemaLocation = ( SchemaLocation ) o ; if ( file != null ? ! file . equals ( schemaLocation . file ) : schemaLocation . file != null ) { return false ; } if ( namespace != null ? ! namespace . equals ( schemaLocation . namespace ) : schemaLocation . namespace != null ) { return false ; } if ( url != null ? ! url . equals ( schemaLocation . url ) : schemaLocation . url != null ) { return false ; } return true ; } public int hashCode ( ) { int result ; result = ( namespace != null ? namespace . hashCode ( ) : 0 ) ; result = 29 * result + ( file != null ? file . hashCode ( ) : 0 ) ; result = 29 * result + ( url != null ? url . hashCode ( ) : 0 ) ; return result ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( namespace != null ? namespace : "(anonymous)" ) ; buffer . append ( ' ' ) ; buffer . append ( url != null ? ( url + " " ) : "" ) ; buffer . append ( file != null ? file . getAbsolutePath ( ) : "" ) ; return buffer . toString ( ) ; } } } 	0	['17', '4', '0', '3', '58', '108', '0', '3', '9', '0.95625', '345', '0.4', '1', '0.8', '0.254901961', '2', '6', '18.70588235', '4', '1.5882', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMkelem extends ClearCase { private String mComment = null ; private String mCfile = null ; private boolean mNwarn = false ; private boolean mPtime = false ; private boolean mNoco = false ; private boolean mCheckin = false ; private boolean mMaster = false ; private String mEltype = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKELEM ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getNoWarn ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOWARN ) ; } if ( getNoCheckout ( ) && getCheckin ( ) ) { throw new BuildException ( "Should choose either [nocheckout | checkin]" ) ; } if ( getNoCheckout ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_NOCHECKOUT ) ; } if ( getCheckin ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CHECKIN ) ; if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } if ( getMaster ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_MASTER ) ; } if ( getEltype ( ) != null ) { getEltypeCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setNoWarn ( boolean nwarn ) { mNwarn = nwarn ; } public boolean getNoWarn ( ) { return mNwarn ; } public void setPreserveTime ( boolean ptime ) { mPtime = ptime ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setNoCheckout ( boolean co ) { mNoco = co ; } public boolean getNoCheckout ( ) { return mNoco ; } public void setCheckin ( boolean ci ) { mCheckin = ci ; } public boolean getCheckin ( ) { return mCheckin ; } public void setMaster ( boolean master ) { mMaster = master ; } public boolean getMaster ( ) { return mMaster ; } public void setEltype ( String eltype ) { mEltype = eltype ; } public String getEltype ( ) { return mEltype ; } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getEltypeCommand ( Commandline cmd ) { if ( getEltype ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_ELTYPE ) ; cmd . createArgument ( ) . setValue ( getEltype ( ) ) ; } } public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; public static final String FLAG_NOWARN = "-nwarn" ; public static final String FLAG_PRESERVETIME = "-ptime" ; public static final String FLAG_NOCHECKOUT = "-nco" ; public static final String FLAG_CHECKIN = "-ci" ; public static final String FLAG_MASTER = "-master" ; public static final String FLAG_ELTYPE = "-eltype" ; } 	0	['22', '4', '0', '7', '45', '183', '0', '7', '18', '0.949579832', '307', '0.470588235', '0', '0.695652174', '0.386363636', '2', '3', '12.18181818', '11', '1.5455', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . regexp . Regexp ; import org . apache . tools . ant . util . regexp . RegexpFactory ; public class RegularExpression extends DataType { public static final String DATA_TYPE_NAME = "regexp" ; private boolean alreadyInit = false ; private static final RegexpFactory FACTORY = new RegexpFactory ( ) ; private Regexp regexp = null ; private String myPattern ; private boolean setPatternPending = false ; public RegularExpression ( ) { } private void init ( Project p ) { if ( ! alreadyInit ) { this . regexp = FACTORY . newRegexp ( p ) ; alreadyInit = true ; } } private void setPattern ( ) { if ( setPatternPending ) { regexp . setPattern ( myPattern ) ; setPatternPending = false ; } } public void setPattern ( String pattern ) { if ( regexp == null ) { myPattern = pattern ; setPatternPending = true ; } else { regexp . setPattern ( pattern ) ; } } public String getPattern ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getPattern ( p ) ; } setPattern ( ) ; return regexp . getPattern ( ) ; } public Regexp getRegexp ( Project p ) { init ( p ) ; if ( isReference ( ) ) { return getRef ( p ) . getRegexp ( p ) ; } setPattern ( ) ; return this . regexp ; } public RegularExpression getRef ( Project p ) { return ( RegularExpression ) getCheckedRef ( p ) ; } } 	0	['8', '3', '0', '10', '15', '0', '6', '4', '5', '0.595238095', '110', '0.833333333', '2', '0.833333333', '0.571428571', '0', '0', '12', '2', '1.375', '0']
package org . apache . tools . ant . types . resources ; import java . util . Set ; import java . util . HashSet ; import java . util . Iterator ; import java . util . WeakHashMap ; import java . util . NoSuchElementException ; import java . util . ConcurrentModificationException ; class FailFast implements Iterator { private static final WeakHashMap MAP = new WeakHashMap ( ) ; static synchronized void invalidate ( Object o ) { Set s = ( Set ) ( MAP . get ( o ) ) ; if ( s != null ) { s . clear ( ) ; } } private static synchronized void add ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s == null ) { s = new HashSet ( ) ; MAP . put ( f . parent , s ) ; } s . add ( f ) ; } private static synchronized void remove ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( s != null ) { s . remove ( f ) ; } } private static synchronized void failFast ( FailFast f ) { Set s = ( Set ) ( MAP . get ( f . parent ) ) ; if ( ! s . contains ( f ) ) { throw new ConcurrentModificationException ( ) ; } } private Object parent ; private Iterator wrapped ; FailFast ( Object o , Iterator i ) { if ( o == null ) { throw new IllegalArgumentException ( "parent object is null" ) ; } if ( i == null ) { throw new IllegalArgumentException ( "cannot wrap null iterator" ) ; } parent = o ; if ( i . hasNext ( ) ) { wrapped = i ; add ( this ) ; } } public boolean hasNext ( ) { if ( wrapped == null ) { return false ; } failFast ( this ) ; return wrapped . hasNext ( ) ; } public Object next ( ) { if ( wrapped == null || ! wrapped . hasNext ( ) ) { throw new NoSuchElementException ( ) ; } failFast ( this ) ; try { return wrapped . next ( ) ; } finally { if ( ! wrapped . hasNext ( ) ) { wrapped = null ; remove ( this ) ; } } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 	0	['9', '1', '0', '5', '24', '4', '5', '0', '3', '0.416666667', '156', '1', '0', '0', '0.3125', '0', '0', '16', '6', '1.8889', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import java . io . File ; import java . io . IOException ; public class CopyPath extends Task { public static final String ERROR_NO_DESTDIR = "No destDir specified" ; public static final String ERROR_NO_PATH = "No path specified" ; public static final String ERROR_NO_MAPPER = "No mapper specified" ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private FileNameMapper mapper ; private Path path ; private File destDir ; private long granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; private boolean preserveLastModified = false ; public void setDestDir ( File destDir ) { this . destDir = destDir ; } public void add ( FileNameMapper newmapper ) { if ( mapper != null ) { throw new BuildException ( "Only one mapper allowed" ) ; } mapper = newmapper ; } public void setPath ( Path s ) { createPath ( ) . append ( s ) ; } public void setPathRef ( Reference r ) { createPath ( ) . setRefid ( r ) ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path ; } public void setGranularity ( long granularity ) { this . granularity = granularity ; } public void setPreserveLastModified ( boolean preserveLastModified ) { this . preserveLastModified = preserveLastModified ; } protected void validateAttributes ( ) throws BuildException { if ( destDir == null ) { throw new BuildException ( ERROR_NO_DESTDIR ) ; } if ( mapper == null ) { throw new BuildException ( ERROR_NO_MAPPER ) ; } if ( path == null ) { throw new BuildException ( ERROR_NO_PATH ) ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; String [ ] sourceFiles = path . list ( ) ; if ( sourceFiles . length == 0 ) { log ( "Path is empty" , Project . MSG_VERBOSE ) ; return ; } for ( int sources = 0 ; sources < sourceFiles . length ; sources ++ ) { String sourceFileName = sourceFiles [ sources ] ; File sourceFile = new File ( sourceFileName ) ; String [ ] toFiles = ( String [ ] ) mapper . mapFileName ( sourceFileName ) ; for ( int i = 0 ; i < toFiles . length ; i ++ ) { String destFileName = toFiles [ i ] ; File destFile = new File ( destDir , destFileName ) ; if ( sourceFile . equals ( destFile ) ) { log ( "Skipping self-copy of " + sourceFileName , Project . MSG_VERBOSE ) ; continue ; } if ( sourceFile . isDirectory ( ) ) { log ( "Skipping directory " + sourceFileName ) ; continue ; } try { log ( "Copying " + sourceFile + " to " + destFile , Project . MSG_VERBOSE ) ; FILE_UTILS . copyFile ( sourceFile , destFile , null , null , false , preserveLastModified , null , null , getProject ( ) ) ; } catch ( IOException ioe ) { String msg = "Failed to copy " + sourceFile + " to " + destFile + " due to " + ioe . getMessage ( ) ; if ( destFile . exists ( ) && ! destFile . delete ( ) ) { msg += " and I couldn't delete the corrupt " + destFile ; } throw new BuildException ( msg , ioe , getLocation ( ) ) ; } } } } } 	0	['11', '3', '0', '9', '38', '29', '0', '9', '9', '0.888888889', '260', '0.666666667', '3', '0.804347826', '0.228571429', '3', '3', '21.81818182', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Jvc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using jvc compiler" , Project . MSG_VERBOSE ) ; Path classpath = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { classpath . append ( p ) ; } if ( includeJavaRuntime ) { classpath . addExtdirs ( extdirs ) ; } classpath . append ( getCompileClasspath ( ) ) ; if ( compileSourcepath != null ) { classpath . append ( compileSourcepath ) ; } else { classpath . append ( src ) ; } Commandline cmd = new Commandline ( ) ; String exec = getJavac ( ) . getExecutable ( ) ; cmd . setExecutable ( exec == null ? "jvc" : exec ) ; if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "/d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "/cp:p" ) ; cmd . createArgument ( ) . setPath ( classpath ) ; boolean msExtensions = true ; String mse = getProject ( ) . getProperty ( "build.compiler.jvc.extensions" ) ; if ( mse != null ) { msExtensions = Project . toBoolean ( mse ) ; } if ( msExtensions ) { cmd . createArgument ( ) . setValue ( "/x-" ) ; cmd . createArgument ( ) . setValue ( "/nomessage" ) ; } cmd . createArgument ( ) . setValue ( "/nologo" ) ; if ( debug ) { cmd . createArgument ( ) . setValue ( "/g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "/O" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "/verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName ) == 0 ; } } 	0	['2', '2', '0', '8', '26', '1', '1', '7', '2', '2', '149', '0', '0', '0.958333333', '1', '0', '0', '73.5', '1', '0.5', '0']
package org . apache . tools . ant . types . resolver ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . types . ResourceLocation ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogManager ; import org . apache . xml . resolver . tools . CatalogResolver ; public class ApacheCatalogResolver extends CatalogResolver { private XMLCatalog xmlCatalog = null ; static { CatalogManager . getStaticManager ( ) . setIgnoreMissingProperties ( true ) ; System . getProperties ( ) . put ( "xml.catalog.className" , ApacheCatalog . class . getName ( ) ) ; CatalogManager . getStaticManager ( ) . setUseStaticCatalog ( false ) ; } public void setXMLCatalog ( XMLCatalog xmlCatalog ) { this . xmlCatalog = xmlCatalog ; } public void parseCatalog ( String file ) { Catalog catalog = getCatalog ( ) ; if ( ! ( catalog instanceof ApacheCatalog ) ) { throw new BuildException ( "Wrong catalog type found: " + catalog . getClass ( ) . getName ( ) ) ; } ApacheCatalog apacheCatalog = ( ApacheCatalog ) catalog ; apacheCatalog . setResolver ( this ) ; try { apacheCatalog . parseCatalog ( file ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( ex ) ; } catch ( IOException ex ) { throw new BuildException ( ex ) ; } } public void addPublicEntry ( String publicid , String systemid , URL base ) { ResourceLocation dtd = new ResourceLocation ( ) ; dtd . setBase ( base ) ; dtd . setPublicId ( publicid ) ; dtd . setLocation ( systemid ) ; xmlCatalog . addDTD ( dtd ) ; } public void addURIEntry ( String uri , String altURI , URL base ) { ResourceLocation entity = new ResourceLocation ( ) ; entity . setBase ( base ) ; entity . setPublicId ( uri ) ; entity . setLocation ( altURI ) ; xmlCatalog . addEntity ( entity ) ; } } 	0	['6', '2', '0', '7', '31', '3', '1', '7', '5', '0.7', '123', '0.5', '1', '0.6', '0.55', '0', '0', '19.16666667', '2', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . util . StringUtils ; public final class Specification { private static final String MISSING = "Missing " ; public static final Attributes . Name SPECIFICATION_TITLE = Attributes . Name . SPECIFICATION_TITLE ; public static final Attributes . Name SPECIFICATION_VERSION = Attributes . Name . SPECIFICATION_VERSION ; public static final Attributes . Name SPECIFICATION_VENDOR = Attributes . Name . SPECIFICATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_TITLE = Attributes . Name . IMPLEMENTATION_TITLE ; public static final Attributes . Name IMPLEMENTATION_VERSION = Attributes . Name . IMPLEMENTATION_VERSION ; public static final Attributes . Name IMPLEMENTATION_VENDOR = Attributes . Name . IMPLEMENTATION_VENDOR ; public static final Compatibility COMPATIBLE = new Compatibility ( "COMPATIBLE" ) ; public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE = new Compatibility ( "REQUIRE_SPECIFICATION_UPGRADE" ) ; public static final Compatibility REQUIRE_VENDOR_SWITCH = new Compatibility ( "REQUIRE_VENDOR_SWITCH" ) ; public static final Compatibility REQUIRE_IMPLEMENTATION_CHANGE = new Compatibility ( "REQUIRE_IMPLEMENTATION_CHANGE" ) ; public static final Compatibility INCOMPATIBLE = new Compatibility ( "INCOMPATIBLE" ) ; private String specificationTitle ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationTitle ; private String implementationVendor ; private String implementationVersion ; private String [ ] sections ; public static Specification [ ] getSpecifications ( final Manifest manifest ) throws ParseException { if ( null == manifest ) { return new Specification [ 0 ] ; } final ArrayList results = new ArrayList ( ) ; final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; final Specification specification = getSpecification ( key , attributes ) ; if ( null != specification ) { results . add ( specification ) ; } } final ArrayList trimmedResults = removeDuplicates ( results ) ; return ( Specification [ ] ) trimmedResults . toArray ( new Specification [ trimmedResults . size ( ) ] ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor ) { this ( specificationTitle , specificationVersion , specificationVendor , implementationTitle , implementationVersion , implementationVendor , null ) ; } public Specification ( final String specificationTitle , final String specificationVersion , final String specificationVendor , final String implementationTitle , final String implementationVersion , final String implementationVendor , final String [ ] sections ) { this . specificationTitle = specificationTitle ; this . specificationVendor = specificationVendor ; if ( null != specificationVersion ) { try { this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad specification version format '" + specificationVersion + "' in '" + specificationTitle + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } this . implementationTitle = implementationTitle ; this . implementationVendor = implementationVendor ; this . implementationVersion = implementationVersion ; if ( null == this . specificationTitle ) { throw new NullPointerException ( "specificationTitle" ) ; } String [ ] copy = null ; if ( null != sections ) { copy = new String [ sections . length ] ; System . arraycopy ( sections , 0 , copy , 0 , sections . length ) ; } this . sections = copy ; } public String getSpecificationTitle ( ) { return specificationTitle ; } public String getSpecificationVendor ( ) { return specificationVendor ; } public String getImplementationTitle ( ) { return implementationTitle ; } public DeweyDecimal getSpecificationVersion ( ) { return specificationVersion ; } public String getImplementationVendor ( ) { return implementationVendor ; } public String getImplementationVersion ( ) { return implementationVersion ; } public String [ ] getSections ( ) { if ( null == sections ) { return null ; } final String [ ] newSections = new String [ sections . length ] ; System . arraycopy ( sections , 0 , newSections , 0 , sections . length ) ; return newSections ; } public Compatibility getCompatibilityWith ( final Specification other ) { if ( ! specificationTitle . equals ( other . getSpecificationTitle ( ) ) ) { return INCOMPATIBLE ; } final DeweyDecimal otherSpecificationVersion = other . getSpecificationVersion ( ) ; if ( null != specificationVersion ) { if ( null == otherSpecificationVersion || ! isCompatible ( specificationVersion , otherSpecificationVersion ) ) { return REQUIRE_SPECIFICATION_UPGRADE ; } } final String otherImplementationVendor = other . getImplementationVendor ( ) ; if ( null != implementationVendor ) { if ( null == otherImplementationVendor || ! implementationVendor . equals ( otherImplementationVendor ) ) { return REQUIRE_VENDOR_SWITCH ; } } final String otherImplementationVersion = other . getImplementationVersion ( ) ; if ( null != implementationVersion ) { if ( null == otherImplementationVersion || ! implementationVersion . equals ( otherImplementationVersion ) ) { return REQUIRE_IMPLEMENTATION_CHANGE ; } } return COMPATIBLE ; } public boolean isCompatibleWith ( final Specification other ) { return ( COMPATIBLE == getCompatibilityWith ( other ) ) ; } public String toString ( ) { final String brace = ": " ; final StringBuffer sb = new StringBuffer ( SPECIFICATION_TITLE . toString ( ) ) ; sb . append ( brace ) ; sb . append ( specificationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( null != specificationVersion ) { sb . append ( SPECIFICATION_VERSION ) ; sb . append ( brace ) ; sb . append ( specificationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != specificationVendor ) { sb . append ( SPECIFICATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( specificationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationTitle ) { sb . append ( IMPLEMENTATION_TITLE ) ; sb . append ( brace ) ; sb . append ( implementationTitle ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVersion ) { sb . append ( IMPLEMENTATION_VERSION ) ; sb . append ( brace ) ; sb . append ( implementationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendor ) { sb . append ( IMPLEMENTATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( implementationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } return sb . toString ( ) ; } private boolean isCompatible ( final DeweyDecimal first , final DeweyDecimal second ) { return first . isGreaterThanOrEqual ( second ) ; } private static ArrayList removeDuplicates ( final ArrayList list ) { final ArrayList results = new ArrayList ( ) ; final ArrayList sections = new ArrayList ( ) ; while ( list . size ( ) > 0 ) { final Specification specification = ( Specification ) list . remove ( 0 ) ; final Iterator iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { final Specification other = ( Specification ) iterator . next ( ) ; if ( isEqual ( specification , other ) ) { final String [ ] otherSections = other . getSections ( ) ; if ( null != sections ) { sections . addAll ( Arrays . asList ( otherSections ) ) ; } iterator . remove ( ) ; } } final Specification merged = mergeInSections ( specification , sections ) ; results . add ( merged ) ; sections . clear ( ) ; } return results ; } private static boolean isEqual ( final Specification specification , final Specification other ) { return specification . getSpecificationTitle ( ) . equals ( other . getSpecificationTitle ( ) ) && specification . getSpecificationVersion ( ) . isEqual ( other . getSpecificationVersion ( ) ) && specification . getSpecificationVendor ( ) . equals ( other . getSpecificationVendor ( ) ) && specification . getImplementationTitle ( ) . equals ( other . getImplementationTitle ( ) ) && specification . getImplementationVersion ( ) . equals ( other . getImplementationVersion ( ) ) && specification . getImplementationVendor ( ) . equals ( other . getImplementationVendor ( ) ) ; } private static Specification mergeInSections ( final Specification specification , final ArrayList sectionsToAdd ) { if ( 0 == sectionsToAdd . size ( ) ) { return specification ; } sectionsToAdd . addAll ( Arrays . asList ( specification . getSections ( ) ) ) ; final String [ ] sections = ( String [ ] ) sectionsToAdd . toArray ( new String [ sectionsToAdd . size ( ) ] ) ; return new Specification ( specification . getSpecificationTitle ( ) , specification . getSpecificationVersion ( ) . toString ( ) , specification . getSpecificationVendor ( ) , specification . getImplementationTitle ( ) , specification . getImplementationVersion ( ) , specification . getImplementationVendor ( ) , sections ) ; } private static String getTrimmedString ( final String value ) { return value == null ? null : value . trim ( ) ; } private static Specification getSpecification ( final String section , final Attributes attributes ) throws ParseException { final String name = getTrimmedString ( attributes . getValue ( SPECIFICATION_TITLE ) ) ; if ( null == name ) { return null ; } final String specVendor = getTrimmedString ( attributes . getValue ( SPECIFICATION_VENDOR ) ) ; if ( null == specVendor ) { throw new ParseException ( MISSING + SPECIFICATION_VENDOR , 0 ) ; } final String specVersion = getTrimmedString ( attributes . getValue ( SPECIFICATION_VERSION ) ) ; if ( null == specVersion ) { throw new ParseException ( MISSING + SPECIFICATION_VERSION , 0 ) ; } final String impTitle = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_TITLE ) ) ; if ( null == impTitle ) { throw new ParseException ( MISSING + IMPLEMENTATION_TITLE , 0 ) ; } final String impVersion = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VERSION ) ) ; if ( null == impVersion ) { throw new ParseException ( MISSING + IMPLEMENTATION_VERSION , 0 ) ; } final String impVendor = getTrimmedString ( attributes . getValue ( IMPLEMENTATION_VENDOR ) ) ; if ( null == impVendor ) { throw new ParseException ( MISSING + IMPLEMENTATION_VENDOR , 0 ) ; } return new Specification ( name , specVersion , specVendor , impTitle , impVersion , impVendor , new String [ ] { section } ) ; } } 	0	['20', '1', '0', '5', '54', '138', '1', '4', '13', '0.789473684', '703', '0.421052632', '6', '0', '0.177631579', '0', '0', '33.2', '11', '2.3', '0']
package org . apache . tools . ant . taskdefs . optional . script ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DynamicConfigurator ; import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; public class ScriptDefBase extends Task implements DynamicConfigurator { private Map nestedElementMap = new HashMap ( ) ; private Map attributes = new HashMap ( ) ; private String text ; public void execute ( ) { getScript ( ) . executeScript ( attributes , nestedElementMap , this ) ; } private ScriptDef getScript ( ) { String name = getTaskType ( ) ; Map scriptRepository = ( Map ) getProject ( ) . getReference ( MagicNames . SCRIPT_REPOSITORY ) ; if ( scriptRepository == null ) { throw new BuildException ( "Script repository not found for " + name ) ; } ScriptDef definition = ( ScriptDef ) scriptRepository . get ( getTaskType ( ) ) ; if ( definition == null ) { throw new BuildException ( "Script definition not found for " + name ) ; } return definition ; } public Object createDynamicElement ( String name ) { List nestedElementList = ( List ) nestedElementMap . get ( name ) ; if ( nestedElementList == null ) { nestedElementList = new ArrayList ( ) ; nestedElementMap . put ( name , nestedElementList ) ; } Object element = getScript ( ) . createNestedElement ( name ) ; nestedElementList . add ( element ) ; return element ; } public void setDynamicAttribute ( String name , String value ) { ScriptDef definition = getScript ( ) ; if ( ! definition . isAttributeSupported ( name ) ) { throw new BuildException ( "<" + getTaskType ( ) + "> does not support the \"" + name + "\" attribute" ) ; } attributes . put ( name , value ) ; } public void addText ( String text ) { this . text = getProject ( ) . replaceProperties ( text ) ; } public String getText ( ) { return text ; } public void fail ( String message ) { throw new BuildException ( message ) ; } } 	0	['8', '3', '0', '5', '25', '16', '1', '5', '7', '0.761904762', '152', '1', '0', '0.840909091', '0.75', '0', '0', '17.625', '3', '1.375', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUpdate extends ClearCase { private boolean mGraphical = false ; private boolean mOverwrite = false ; private boolean mRename = false ; private boolean mCtime = false ; private boolean mPtime = false ; private String mLog = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UPDATE ) ; checkOptions ( commandLine ) ; getProject ( ) . log ( commandLine . toString ( ) , Project . MSG_DEBUG ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getGraphical ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_GRAPHICAL ) ; } else { if ( getOverwrite ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_OVERWRITE ) ; } else { if ( getRename ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RENAME ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOVERWRITE ) ; } } if ( getCurrentTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_CURRENTTIME ) ; } else { if ( getPreserveTime ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_PRESERVETIME ) ; } } getLogCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setGraphical ( boolean graphical ) { mGraphical = graphical ; } public boolean getGraphical ( ) { return mGraphical ; } public void setOverwrite ( boolean ow ) { mOverwrite = ow ; } public boolean getOverwrite ( ) { return mOverwrite ; } public void setRename ( boolean ren ) { mRename = ren ; } public boolean getRename ( ) { return mRename ; } public void setCurrentTime ( boolean ct ) { mCtime = ct ; } public boolean getCurrentTime ( ) { return mCtime ; } public void setPreserveTime ( boolean pt ) { mPtime = pt ; } public boolean getPreserveTime ( ) { return mPtime ; } public void setLog ( String log ) { mLog = log ; } public String getLog ( ) { return mLog ; } private void getLogCommand ( Commandline cmd ) { if ( getLog ( ) == null ) { return ; } else { cmd . createArgument ( ) . setValue ( FLAG_LOG ) ; cmd . createArgument ( ) . setValue ( getLog ( ) ) ; } } public static final String FLAG_GRAPHICAL = "-graphical" ; public static final String FLAG_LOG = "-log" ; public static final String FLAG_OVERWRITE = "-overwrite" ; public static final String FLAG_NOVERWRITE = "-noverwrite" ; public static final String FLAG_RENAME = "-rename" ; public static final String FLAG_CURRENTTIME = "-ctime" ; public static final String FLAG_PRESERVETIME = "-ptime" ; } 	0	['16', '4', '0', '7', '38', '84', '0', '7', '14', '0.943589744', '234', '0.461538462', '0', '0.761904762', '0.375', '2', '3', '12.8125', '6', '1.3125', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . IOException ; import org . apache . oro . text . perl . Perl5Util ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public abstract class P4Base extends org . apache . tools . ant . Task { protected Perl5Util util = null ; protected String shell ; protected String P4Port = "" ; protected String P4Client = "" ; protected String P4User = "" ; protected String P4View = "" ; protected boolean failOnError = true ; protected String P4Opts = "" ; protected String P4CmdOpts = "" ; private boolean inError = false ; private String errorMessage = "" ; public boolean getInError ( ) { return inError ; } public void setInError ( boolean inError ) { this . inError = inError ; } public String getErrorMessage ( ) { return errorMessage ; } public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; } public void setPort ( String p4Port ) { this . P4Port = "-p" + p4Port ; } public void setClient ( String p4Client ) { this . P4Client = "-c" + p4Client ; } public void setUser ( String p4User ) { this . P4User = "-u" + p4User ; } public void setGlobalopts ( String p4Opts ) { this . P4Opts = p4Opts ; } public void setView ( String p4View ) { this . P4View = p4View ; } public void setCmdopts ( String p4CmdOpts ) { this . P4CmdOpts = p4CmdOpts ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public void init ( ) { util = new Perl5Util ( ) ; String tmpprop ; if ( ( tmpprop = getProject ( ) . getProperty ( "p4.port" ) ) != null ) { setPort ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.client" ) ) != null ) { setClient ( tmpprop ) ; } if ( ( tmpprop = getProject ( ) . getProperty ( "p4.user" ) ) != null ) { setUser ( tmpprop ) ; } } protected void execP4Command ( String command ) throws BuildException { execP4Command ( command , null ) ; } protected void execP4Command ( String command , P4Handler handler ) throws BuildException { try { inError = false ; errorMessage = "" ; Commandline commandline = new Commandline ( ) ; commandline . setExecutable ( "p4" ) ; if ( P4Port != null && P4Port . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Port ) ; } if ( P4User != null && P4User . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4User ) ; } if ( P4Client != null && P4Client . length ( ) != 0 ) { commandline . createArgument ( ) . setValue ( P4Client ) ; } if ( P4Opts != null && P4Opts . length ( ) != 0 ) { commandline . createArgument ( ) . setLine ( P4Opts ) ; } commandline . createArgument ( ) . setLine ( command ) ; log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; if ( handler == null ) { handler = new SimpleP4OutputHandler ( this ) ; } Execute exe = new Execute ( handler , null ) ; exe . setAntRun ( getProject ( ) ) ; exe . setCommandline ( commandline . getCommandline ( ) ) ; try { exe . execute ( ) ; if ( inError && failOnError ) { throw new BuildException ( errorMessage ) ; } } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { try { handler . stop ( ) ; } catch ( Exception e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; } } } catch ( Exception e ) { String failMsg = "Problem exec'ing P4 command: " + e . getMessage ( ) ; if ( failOnError ) { throw new BuildException ( failMsg ) ; } else { log ( failMsg , Project . MSG_ERR ) ; } } } } 	0	['15', '3', '15', '27', '41', '57', '17', '11', '13', '0.818181818', '312', '1', '0', '0.725490196', '0.45', '0', '0', '19.06666667', '4', '1.1333', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . List ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collection ; import java . util . Collections ; import java . util . AbstractCollection ; import java . util . NoSuchElementException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; public class Resources extends DataType implements ResourceCollection { public static final ResourceCollection NONE = new ResourceCollection ( ) { public boolean isFilesystemOnly ( ) { return true ; } public Iterator iterator ( ) { return EMPTY_ITERATOR ; } public int size ( ) { return 0 ; } } ; public static final Iterator EMPTY_ITERATOR = new Iterator ( ) { public Object next ( ) { throw new NoSuchElementException ( ) ; } public boolean hasNext ( ) { return false ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; private class MyCollection extends AbstractCollection { private int size ; MyCollection ( ) { size = 0 ; for ( Iterator rci = getNested ( ) . iterator ( ) ; rci . hasNext ( ) ; ) { size += ( ( ResourceCollection ) rci . next ( ) ) . size ( ) ; } } public int size ( ) { return size ; } public Iterator iterator ( ) { return new MyIterator ( ) ; } private class MyIterator implements Iterator { private Iterator rci = getNested ( ) . iterator ( ) ; private Iterator ri = null ; public boolean hasNext ( ) { boolean result = ri != null && ri . hasNext ( ) ; while ( ! result && rci . hasNext ( ) ) { ri = ( ( ResourceCollection ) rci . next ( ) ) . iterator ( ) ; result = ri . hasNext ( ) ; } return result ; } public Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return ri . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } } private Vector rc ; private Collection coll ; public synchronized void add ( ResourceCollection c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } if ( rc == null ) { rc = new Vector ( ) ; } rc . add ( c ) ; FailFast . invalidate ( this ) ; coll = null ; setChecked ( false ) ; } public synchronized Iterator iterator ( ) { if ( isReference ( ) ) { return getRef ( ) . iterator ( ) ; } validate ( ) ; return new FailFast ( this , coll . iterator ( ) ) ; } public synchronized int size ( ) { if ( isReference ( ) ) { return getRef ( ) . size ( ) ; } validate ( ) ; return coll . size ( ) ; } public boolean isFilesystemOnly ( ) { if ( isReference ( ) ) { return getRef ( ) . isFilesystemOnly ( ) ; } validate ( ) ; for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { if ( ( ! ( ( ResourceCollection ) i . next ( ) ) . isFilesystemOnly ( ) ) ) { return false ; } } return true ; } public synchronized String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } if ( coll == null || coll . isEmpty ( ) ) { return "" ; } StringBuffer sb = new StringBuffer ( ) ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { if ( sb . length ( ) > 0 ) { sb . append ( File . pathSeparatorChar ) ; } sb . append ( i . next ( ) ) ; } return sb . toString ( ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = getNested ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } setChecked ( true ) ; } } private ResourceCollection getRef ( ) { return ( ResourceCollection ) getCheckedRef ( ResourceCollection . class , "ResourceCollection" ) ; } private synchronized void validate ( ) { dieOnCircularReference ( ) ; coll = ( coll == null ) ? new MyCollection ( ) : coll ; } private synchronized List getNested ( ) { return rc == null ? Collections . EMPTY_LIST : rc ; } } 	0	['12', '3', '0', '15', '47', '44', '9', '8', '6', '0.781818182', '240', '0.4', '1', '0.75', '0.254545455', '1', '3', '18.58333333', '6', '2.1667', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . OutputStream ; import junit . framework . TestListener ; import org . apache . tools . ant . BuildException ; public interface JUnitResultFormatter extends TestListener , JUnitTaskMirror . JUnitResultFormatterMirror { void startTestSuite ( JUnitTest suite ) throws BuildException ; void endTestSuite ( JUnitTest suite ) throws BuildException ; void setOutput ( OutputStream out ) ; void setSystemOutput ( String out ) ; void setSystemError ( String err ) ; } 	0	['5', '1', '0', '11', '5', '10', '7', '4', '5', '2', '5', '0', '0', '0', '0.5', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . io . Reader ; import java . io . IOException ; public interface Tokenizer { String getToken ( Reader in ) throws IOException ; String getPostToken ( ) ; } 	0	['2', '1', '0', '6', '2', '1', '6', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class DefaultInputHandler implements InputHandler { public DefaultInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( getInputStream ( ) ) ) ; do { System . err . println ( prompt ) ; System . err . flush ( ) ; try { String input = r . readLine ( ) ; request . setInput ( input ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to read input from" + " Console." , e ) ; } } while ( ! request . isInputValid ( ) ) ; } finally { if ( r != null ) { try { r . close ( ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to close input." , e ) ; } } } } protected String getPrompt ( InputRequest request ) { String prompt = request . getPrompt ( ) ; String def = request . getDefaultValue ( ) ; if ( request instanceof MultipleChoiceInputRequest ) { StringBuffer sb = new StringBuffer ( prompt ) ; sb . append ( " (" ) ; Enumeration e = ( ( MultipleChoiceInputRequest ) request ) . getChoices ( ) . elements ( ) ; boolean first = true ; while ( e . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( ", " ) ; } String next = ( String ) e . nextElement ( ) ; if ( next . equals ( def ) ) { sb . append ( '[' ) ; } sb . append ( next ) ; if ( next . equals ( def ) ) { sb . append ( ']' ) ; } first = false ; } sb . append ( ")" ) ; return sb . toString ( ) ; } else if ( def != null ) { return prompt + " [" + def + "]" ; } else { return prompt ; } } protected InputStream getInputStream ( ) { return System . in ; } } 	0	['4', '1', '1', '8', '26', '6', '4', '4', '2', '2', '152', '0', '0', '0', '0.75', '0', '0', '37', '7', '2.25', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; public class CCMCheckinDefault extends CCMCheck { public CCMCheckinDefault ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKIN ) ; setTask ( DEFAULT_TASK ) ; } public static final String DEFAULT_TASK = "default" ; } 	0	['1', '5', '0', '1', '4', '0', '0', '1', '1', '2', '11', '0', '0', '1', '1', '0', '0', '9', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; public interface Condition { boolean eval ( ) throws BuildException ; } 	0	['1', '1', '0', '36', '1', '0', '35', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . unix ; import org . apache . tools . ant . BuildException ; public class Chgrp extends AbstractAccessTask { private boolean haveGroup = false ; public Chgrp ( ) { super . setExecutable ( "chgrp" ) ; } public void setGroup ( String group ) { createArg ( ) . setValue ( group ) ; haveGroup = true ; } protected void checkConfiguration ( ) { if ( ! haveGroup ) { throw new BuildException ( "Required attribute group not set in " + "chgrp" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable" + " attribute" , getLocation ( ) ) ; } } 	0	['4', '6', '0', '4', '16', '0', '0', '4', '3', '0.333333333', '52', '1', '0', '0.973913043', '0.75', '2', '2', '11.75', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLiaison2 extends XSLTLiaison { void configure ( XSLTProcess xsltTask ) ; } 	0	['1', '1', '0', '3', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . types . Resource ; public interface XSLTLiaison3 extends XSLTLiaison2 { void setStylesheet ( Resource stylesheet ) throws Exception ; } 	0	['1', '1', '0', '4', '1', '0', '2', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Rmic ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileNameMapper ; public interface RmicAdapter { void setRmic ( Rmic attributes ) ; boolean execute ( ) throws BuildException ; FileNameMapper getMapper ( ) ; Path getClasspath ( ) ; } 	0	['4', '1', '0', '6', '4', '6', '3', '4', '4', '2', '4', '0', '0', '0', '0.625', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . java15 ; import org . apache . tools . ant . BuildException ; import java . net . ProxySelector ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . Proxy ; import java . net . SocketAddress ; import java . net . InetSocketAddress ; import java . net . InetAddress ; import java . util . List ; import java . util . Iterator ; public class ProxyDiagnostics { private String destination ; private URI destURI ; public static final String DEFAULT_DESTINATION = "http://ant.apache.org/" ; public ProxyDiagnostics ( String destination ) { this . destination = destination ; try { this . destURI = new URI ( destination ) ; } catch ( URISyntaxException e ) { throw new BuildException ( e ) ; } } public ProxyDiagnostics ( ) { this ( DEFAULT_DESTINATION ) ; } public String toString ( ) { ProxySelector selector = ProxySelector . getDefault ( ) ; List list = selector . select ( destURI ) ; StringBuffer result = new StringBuffer ( ) ; Iterator proxies = list . listIterator ( ) ; while ( proxies . hasNext ( ) ) { Proxy proxy = ( Proxy ) proxies . next ( ) ; SocketAddress address = proxy . address ( ) ; if ( address == null ) { result . append ( "Direct connection\n" ) ; } else { result . append ( proxy . toString ( ) ) ; if ( address instanceof InetSocketAddress ) { InetSocketAddress ina = ( InetSocketAddress ) address ; result . append ( ' ' ) ; result . append ( ina . getHostName ( ) ) ; result . append ( ':' ) ; result . append ( ina . getPort ( ) ) ; if ( ina . isUnresolved ( ) ) { result . append ( " [unresolved]" ) ; } else { InetAddress addr = ina . getAddress ( ) ; result . append ( " [" ) ; result . append ( addr . getHostAddress ( ) ) ; result . append ( ']' ) ; } } result . append ( '\n' ) ; } } return result . toString ( ) ; } } 	0	['3', '1', '0', '1', '23', '1', '0', '1', '3', '0.666666667', '121', '0.666666667', '0', '0', '0.666666667', '0', '0', '38.33333333', '5', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import java . util . Enumeration ; public class Xor extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; boolean state = false ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; state ^= c . eval ( ) ; } return state ; } } 	0	['2', '3', '0', '3', '7', '1', '0', '3', '2', '2', '25', '0', '0', '0.96969697', '1', '0', '0', '11.5', '1', '0.5', '0']
package org . apache . tools . ant . util ; public class FlatFileNameMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { new java . io . File ( sourceFileName ) . getName ( ) } ; } } 	0	['4', '1', '0', '2', '7', '6', '1', '1', '4', '2', '20', '0', '0', '0', '0.875', '0', '0', '4', '1', '0.75', '0']
package org . apache . tools . ant . filters . util ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . ConstantValue ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; public final class JavaClassHelper { private static final String LS = System . getProperty ( "line.separator" ) ; public static StringBuffer getConstants ( byte [ ] bytes ) throws IOException { final StringBuffer sb = new StringBuffer ( ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bytes ) ; final ClassParser parser = new ClassParser ( bis , "" ) ; final JavaClass javaClass = parser . parse ( ) ; final Field [ ] fields = javaClass . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( field != null ) { final ConstantValue cv = field . getConstantValue ( ) ; if ( cv != null ) { String cvs = cv . toString ( ) ; if ( cvs . startsWith ( "\"" ) && cvs . endsWith ( "\"" ) ) { cvs = cvs . substring ( 1 , cvs . length ( ) - 1 ) ; } sb . append ( field . getName ( ) ) ; sb . append ( '=' ) ; sb . append ( cvs ) ; sb . append ( LS ) ; } } } return sb ; } } 	0	['3', '1', '0', '4', '19', '1', '0', '4', '2', '0.5', '89', '1', '0', '0', '0.5', '0', '0', '28.33333333', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FilenameFilter ; public class InnerClassFilenameFilter implements FilenameFilter { private String baseClassName ; InnerClassFilenameFilter ( String baseclass ) { int extidx = baseclass . lastIndexOf ( ".class" ) ; if ( extidx == - 1 ) { extidx = baseclass . length ( ) - 1 ; } baseClassName = baseclass . substring ( 0 , extidx ) ; } public boolean accept ( File dir , String filename ) { if ( ( filename . lastIndexOf ( "." ) != filename . lastIndexOf ( ".class" ) ) || ( filename . indexOf ( baseClassName + "$" ) != 0 ) ) { return false ; } return true ; } } 	0	['2', '1', '0', '1', '11', '0', '1', '0', '1', '0', '47', '1', '0', '0', '0.833333333', '0', '0', '22', '3', '1.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Stack ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Comparison ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Quantifier ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . types . resources . comparators . ResourceComparator ; import org . apache . tools . ant . types . resources . comparators . DelegatedResourceComparator ; public class Compare extends DataType implements ResourceSelector { private static final String ONE_CONTROL_MESSAGE = " the <control> element should be specified exactly once." ; private DelegatedResourceComparator comp = new DelegatedResourceComparator ( ) ; private Quantifier against = Quantifier . ALL ; private Comparison when = Comparison . EQUAL ; private Union control ; public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } comp . add ( c ) ; } public synchronized void setAgainst ( Quantifier against ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . against = against ; } public synchronized void setWhen ( Comparison when ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . when = when ; } public synchronized ResourceCollection createControl ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( control != null ) { throw oneControl ( ) ; } control = new Union ( ) ; return control ; } public synchronized boolean isSelected ( Resource r ) { if ( isReference ( ) ) { return ( ( ResourceSelector ) getCheckedRef ( ) ) . isSelected ( r ) ; } if ( control == null ) { throw oneControl ( ) ; } int t = 0 , f = 0 ; for ( Iterator it = control . iterator ( ) ; it . hasNext ( ) ; ) { if ( when . evaluate ( comp . compare ( r , ( Resource ) it . next ( ) ) ) ) { t ++ ; } else { f ++ ; } } return against . evaluate ( t , f ) ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( control != null ) { DataType . invokeCircularReferenceCheck ( control , stk , p ) ; } DataType . invokeCircularReferenceCheck ( comp , stk , p ) ; setChecked ( true ) ; } } private BuildException oneControl ( ) { return new BuildException ( super . toString ( ) + ONE_CONTROL_MESSAGE ) ; } } 	0	['8', '3', '0', '11', '33', '4', '0', '11', '6', '0.771428571', '167', '1', '4', '0.810810811', '0.25', '1', '3', '19.25', '5', '2', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class FloatCPInfo extends ConstantCPInfo { public FloatCPInfo ( ) { super ( CONSTANT_FLOAT , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Float ( cpStream . readFloat ( ) ) ) ; } public String toString ( ) { return "Float Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . util ; public interface FileNameMapper { void setFrom ( String from ) ; void setTo ( String to ) ; String [ ] mapFileName ( String sourceFileName ) ; } 	0	['3', '1', '0', '38', '3', '3', '38', '0', '3', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Counter extends P4Base { public String counter = null ; public String property = null ; public boolean shouldSetValue = false ; public boolean shouldSetProperty = false ; public int value = 0 ; public void setName ( String counter ) { this . counter = counter ; } public void setValue ( int value ) { this . value = value ; shouldSetValue = true ; } public void setProperty ( String property ) { this . property = property ; shouldSetProperty = true ; } public void execute ( ) throws BuildException { if ( ( counter == null ) || counter . length ( ) == 0 ) { throw new BuildException ( "No counter specified to retrieve" ) ; } if ( shouldSetValue && shouldSetProperty ) { throw new BuildException ( "Cannot both set the value of the property and retrieve the " + "value of the property." ) ; } String command = "counter " + P4CmdOpts + " " + counter ; if ( ! shouldSetProperty ) { command = "-s " + command ; } if ( shouldSetValue ) { command += " " + value ; } if ( shouldSetProperty ) { final Project myProj = getProject ( ) ; P4Handler handler = new P4HandlerAdapter ( ) { public void process ( String line ) { log ( "P4Counter retrieved line \"" + line + "\"" , Project . MSG_VERBOSE ) ; try { value = Integer . parseInt ( line ) ; myProj . setProperty ( property , "" + value ) ; } catch ( NumberFormatException nfe ) { throw new BuildException ( "Perforce error. " + "Could not retrieve counter value." ) ; } } } ; execP4Command ( command , handler ) ; } else { execP4Command ( command , new SimpleP4OutputHandler ( this ) ) ; } } } 	0	['5', '4', '0', '6', '17', '0', '1', '6', '5', '0.55', '134', '0', '0', '0.927272727', '0.533333333', '1', '1', '24.8', '1', '0.8', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; public class ImmutableResourceException extends IOException { public ImmutableResourceException ( ) { super ( ) ; } public ImmutableResourceException ( String s ) { super ( s ) ; } } 	0	['2', '4', '0', '2', '4', '1', '2', '0', '2', '2', '9', '0', '0', '1', '0.75', '0', '0', '3.5', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . ExecTask ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class BorlandGenerateClient extends Task { static final String JAVA_MODE = "java" ; static final String FORK_MODE = "fork" ; boolean debug = false ; File ejbjarfile = null ; File clientjarfile = null ; Path classpath ; String mode = FORK_MODE ; int version = BorlandDeploymentTool . BAS ; public void setVersion ( int version ) { this . version = version ; } public void setMode ( String s ) { mode = s ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setEjbjar ( File ejbfile ) { ejbjarfile = ejbfile ; } public void setClientjar ( File clientjar ) { clientjarfile = clientjar ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void execute ( ) throws BuildException { if ( ejbjarfile == null || ejbjarfile . isDirectory ( ) ) { throw new BuildException ( "invalid ejb jar file." ) ; } if ( clientjarfile == null || clientjarfile . isDirectory ( ) ) { log ( "invalid or missing client jar file." , Project . MSG_VERBOSE ) ; String ejbjarname = ejbjarfile . getAbsolutePath ( ) ; String clientname = ejbjarname . substring ( 0 , ejbjarname . lastIndexOf ( "." ) ) ; clientname = clientname + "client.jar" ; clientjarfile = new File ( clientname ) ; } if ( mode == null ) { log ( "mode is null default mode  is java" ) ; setMode ( JAVA_MODE ) ; } if ( ! ( version == BorlandDeploymentTool . BES || version == BorlandDeploymentTool . BAS ) ) { throw new BuildException ( "version " + version + " is not supported" ) ; } log ( "client jar file is " + clientjarfile ) ; if ( mode . equalsIgnoreCase ( FORK_MODE ) ) { executeFork ( ) ; } else { executeJava ( ) ; } } protected void executeJava ( ) throws BuildException { try { if ( version == BorlandDeploymentTool . BES ) { throw new BuildException ( "java mode is supported only for " + "previous version <=" + BorlandDeploymentTool . BAS ) ; } log ( "mode : java" ) ; Java execTask = null ; execTask = new Java ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setClassname ( "com.inprise.server.commandline.EJBUtilities" ) ; execTask . setClasspath ( classpath . concatSystemClasspath ( ) ) ; execTask . setFork ( true ) ; execTask . createArg ( ) . setValue ( "generateclient" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-trace" ) ; } execTask . createArg ( ) . setValue ( "-short" ) ; execTask . createArg ( ) . setValue ( "-jarfile" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-single" ) ; execTask . createArg ( ) . setValue ( "-clientjarfile" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; log ( "Calling EJBUtilities" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void executeFork ( ) throws BuildException { if ( version == BorlandDeploymentTool . BAS ) { executeForkV4 ( ) ; } if ( version == BorlandDeploymentTool . BES ) { executeForkV5 ( ) ; } } protected void executeForkV4 ( ) throws BuildException { try { log ( "mode : fork " + BorlandDeploymentTool . BAS , Project . MSG_DEBUG ) ; ExecTask execTask = new ExecTask ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; execTask . createArg ( ) . setValue ( "generateclient" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-trace" ) ; } execTask . createArg ( ) . setValue ( "-short" ) ; execTask . createArg ( ) . setValue ( "-jarfile" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-single" ) ; execTask . createArg ( ) . setValue ( "-clientjarfile" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } protected void executeForkV5 ( ) throws BuildException { try { log ( "mode : fork " + BorlandDeploymentTool . BES , Project . MSG_DEBUG ) ; ExecTask execTask = new ExecTask ( this ) ; execTask . setDir ( new File ( "." ) ) ; execTask . setExecutable ( "iastool" ) ; if ( debug ) { execTask . createArg ( ) . setValue ( "-debug" ) ; } execTask . createArg ( ) . setValue ( "-genclient" ) ; execTask . createArg ( ) . setValue ( "-jars" ) ; execTask . createArg ( ) . setValue ( ejbjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-target" ) ; execTask . createArg ( ) . setValue ( clientjarfile . getAbsolutePath ( ) ) ; execTask . createArg ( ) . setValue ( "-cp" ) ; execTask . createArg ( ) . setValue ( classpath . toString ( ) ) ; log ( "Calling iastool" , Project . MSG_VERBOSE ) ; execTask . execute ( ) ; } catch ( Exception e ) { String msg = "Exception while calling generateclient Details: " + e . toString ( ) ; throw new BuildException ( msg , e ) ; } } } 	0	['14', '3', '0', '9', '52', '15', '1', '8', '10', '0.730769231', '468', '0', '1', '0.74', '0.214285714', '2', '2', '31.85714286', '2', '1.0714', '0']
package org . apache . tools . ant . util . optional ; import java . security . Permission ; import org . apache . tools . ant . ExitException ; public class NoExitSecurityManager extends SecurityManager { public void checkExit ( int status ) { throw new ExitException ( status ) ; } public void checkPermission ( Permission perm ) { } } 	0	['3', '2', '0', '1', '5', '3', '0', '1', '3', '2', '12', '0', '0', '0.954545455', '0.555555556', '1', '12', '3', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; public class ManifestException extends Exception { public ManifestException ( String msg ) { super ( msg ) ; } } 	0	['1', '3', '0', '6', '2', '0', '6', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteWatchdog implements TimeoutObserver { private Process process ; private volatile boolean watch = false ; private Exception caught = null ; private volatile boolean killedProcess = false ; private Watchdog watchdog ; public ExecuteWatchdog ( long timeout ) { watchdog = new Watchdog ( timeout ) ; watchdog . addTimeoutObserver ( this ) ; } public ExecuteWatchdog ( int timeout ) { this ( ( long ) timeout ) ; } public synchronized void start ( Process process ) { if ( process == null ) { throw new NullPointerException ( "process is null." ) ; } if ( this . process != null ) { throw new IllegalStateException ( "Already running." ) ; } this . caught = null ; this . killedProcess = false ; this . watch = true ; this . process = process ; watchdog . start ( ) ; } public synchronized void stop ( ) { watchdog . stop ( ) ; cleanUp ( ) ; } public synchronized void timeoutOccured ( Watchdog w ) { try { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { if ( watch ) { killedProcess = true ; process . destroy ( ) ; } } } catch ( Exception e ) { caught = e ; } finally { cleanUp ( ) ; } } protected synchronized void cleanUp ( ) { watch = false ; process = null ; } public synchronized void checkException ( ) throws BuildException { if ( caught != null ) { throw new BuildException ( "Exception in ExecuteWatchdog.run: " + caught . getMessage ( ) , caught ) ; } } public boolean isWatching ( ) { return watch ; } public boolean killedProcess ( ) { return killedProcess ; } } 	0	['9', '1', '0', '17', '23', '0', '14', '3', '8', '0.5', '141', '1', '1', '0', '0.288888889', '0', '0', '14.11111111', '4', '1.3333', '0']
package org . apache . tools . ant . util ; import java . io . OutputStream ; import java . io . IOException ; public class TeeOutputStream extends OutputStream { private OutputStream left ; private OutputStream right ; public TeeOutputStream ( OutputStream left , OutputStream right ) { this . left = left ; this . right = right ; } public void close ( ) throws IOException { try { left . close ( ) ; } finally { right . close ( ) ; } } public void flush ( ) throws IOException { left . flush ( ) ; right . flush ( ) ; } public void write ( byte [ ] b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } public void write ( byte [ ] b , int off , int len ) throws IOException { left . write ( b , off , len ) ; right . write ( b , off , len ) ; } public void write ( int b ) throws IOException { left . write ( b ) ; right . write ( b ) ; } } 	0	['6', '2', '0', '4', '12', '0', '4', '0', '6', '0', '70', '1', '0', '0.5', '0.458333333', '1', '1', '10.33333333', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; public interface P4Handler extends ExecuteStreamHandler { void process ( String line ) throws BuildException ; void setOutput ( String line ) throws BuildException ; } 	0	['2', '1', '0', '20', '2', '1', '18', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; public class CCMkattr extends ClearCase { private boolean mReplace = false ; private boolean mRecurse = false ; private String mVersion = null ; private String mTypeName = null ; private String mTypeValue = null ; private String mComment = null ; private String mCfile = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } if ( getTypeValue ( ) == null ) { throw new BuildException ( "Required attribute TypeValue not specified" ) ; } if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKATTR ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( getVersion ( ) != null ) { getVersionCommand ( cmd ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getTypeName ( ) != null ) { getTypeCommand ( cmd ) ; } if ( getTypeValue ( ) != null ) { getTypeValueCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setRecurse ( boolean recurse ) { mRecurse = recurse ; } public boolean getRecurse ( ) { return mRecurse ; } public void setVersion ( String version ) { mVersion = version ; } public String getVersion ( ) { return mVersion ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setTypeValue ( String tv ) { mTypeValue = tv ; } public String getTypeValue ( ) { return mTypeValue ; } private void getVersionCommand ( Commandline cmd ) { if ( getVersion ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; cmd . createArgument ( ) . setValue ( getVersion ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getTypeCommand ( Commandline cmd ) { String typenm = getTypeName ( ) ; if ( typenm != null ) { cmd . createArgument ( ) . setValue ( typenm ) ; } } private void getTypeValueCommand ( Commandline cmd ) { String typevl = getTypeValue ( ) ; if ( typevl != null ) { if ( Os . isFamily ( "windows" ) ) { typevl = "\\\"" + typevl + "\\\"" ; } else { typevl = "\"" + typevl + "\"" ; } cmd . createArgument ( ) . setValue ( typevl ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_RECURSE = "-recurse" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['22', '4', '0', '8', '46', '189', '0', '8', '16', '0.919413919', '333', '0.538461538', '0', '0.695652174', '0.397727273', '2', '3', '13.54545455', '8', '1.5455', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; public class RegexpFactory extends RegexpMatcherFactory { public RegexpFactory ( ) { } public Regexp newRegexp ( ) throws BuildException { return ( Regexp ) newRegexp ( null ) ; } public Regexp newRegexp ( Project p ) throws BuildException { String systemDefault = null ; if ( p == null ) { systemDefault = System . getProperty ( "ant.regexp.regexpimpl" ) ; } else { systemDefault = p . getProperty ( "ant.regexp.regexpimpl" ) ; } if ( systemDefault != null ) { return createRegexpInstance ( systemDefault ) ; } Throwable cause = null ; try { testAvailability ( "java.util.regex.Matcher" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , JavaEnvUtils . getJavaVersionNumber ( ) < 14 ) ; } try { testAvailability ( "org.apache.oro.text.regex.Pattern" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaOroRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } try { testAvailability ( "org.apache.regexp.RE" ) ; return createRegexpInstance ( "org.apache.tools.ant.util.regexp.JakartaRegexpRegexp" ) ; } catch ( BuildException be ) { cause = orCause ( cause , be , true ) ; } throw new BuildException ( "No supported regular expression matcher found" + ( cause != null ? ": " + cause : "" ) , cause ) ; } protected Regexp createRegexpInstance ( String classname ) throws BuildException { RegexpMatcher m = createInstance ( classname ) ; if ( m instanceof Regexp ) { return ( Regexp ) m ; } else { throw new BuildException ( classname + " doesn't implement the Regexp interface" ) ; } } } 	0	['4', '2', '0', '7', '18', '6', '1', '6', '3', '2', '119', '0', '0', '0.625', '0.5', '0', '0', '28.75', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . types . FileSet ; public class LibFileSet extends FileSet { private boolean includeURL ; private boolean includeImpl ; private String urlBase ; public void setIncludeUrl ( boolean includeURL ) { this . includeURL = includeURL ; } public void setIncludeImpl ( boolean includeImpl ) { this . includeImpl = includeImpl ; } public void setUrlBase ( String urlBase ) { this . urlBase = urlBase ; } boolean isIncludeURL ( ) { return includeURL ; } boolean isIncludeImpl ( ) { return includeImpl ; } String getUrlBase ( ) { return urlBase ; } } 	0	['7', '5', '0', '3', '8', '15', '2', '1', '4', '0.833333333', '34', '1', '0', '0.93814433', '0.476190476', '0', '0', '3.428571429', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class Compatibility { private final String name ; Compatibility ( final String name ) { this . name = name ; } public String toString ( ) { return name ; } } 	0	['2', '1', '0', '2', '3', '0', '2', '0', '1', '0', '12', '1', '0', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . FilterOutputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; public class StringResource extends Resource { private static final int STRING_MAGIC = Resource . getMagicNumber ( "StringResource" . getBytes ( ) ) ; private String encoding = null ; public StringResource ( ) { } public StringResource ( String value ) { setValue ( value ) ; } public synchronized void setName ( String s ) { if ( getName ( ) != null ) { throw new BuildException ( new ImmutableResourceException ( ) ) ; } super . setName ( s ) ; } public synchronized void setValue ( String s ) { setName ( s ) ; } public synchronized String getName ( ) { return super . getName ( ) ; } public synchronized String getValue ( ) { return getName ( ) ; } public synchronized void setEncoding ( String s ) { encoding = s ; } public synchronized String getEncoding ( ) { return encoding ; } public synchronized long getSize ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) : ( long ) getContent ( ) . length ( ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return super . hashCode ( ) * STRING_MAGIC ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } return String . valueOf ( getContent ( ) ) ; } public synchronized InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } return new ByteArrayInputStream ( getContent ( ) . getBytes ( ) ) ; } public synchronized OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } if ( getValue ( ) != null ) { throw new ImmutableResourceException ( ) ; } final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; return new FilterOutputStream ( baos ) { public void close ( ) throws IOException { super . close ( ) ; StringResource . this . setValue ( encoding == null ? baos . toString ( ) : baos . toString ( encoding ) ) ; } } ; } public void setRefid ( Reference r ) { if ( encoding != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } protected synchronized String getContent ( ) { if ( isReference ( ) ) { return ( ( StringResource ) getCheckedRef ( ) ) . getContent ( ) ; } String value = getValue ( ) ; if ( value == null ) { return value ; } return getProject ( ) == null ? value : getProject ( ) . replaceProperties ( value ) ; } } 	0	['17', '4', '0', '8', '41', '104', '3', '6', '14', '0.8125', '185', '1', '0', '0.791044776', '0.328125', '2', '10', '9.764705882', '4', '1.2941', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Substitution ; import org . apache . tools . ant . util . Tokenizer ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . StringUtils ; import org . apache . tools . ant . util . regexp . Regexp ; public class TokenFilter extends BaseFilterReader implements ChainableReader { public interface Filter { String filter ( String string ) ; } private Vector filters = new Vector ( ) ; private Tokenizer tokenizer = null ; private String delimOutput = null ; private String line = null ; private int linePos = 0 ; public TokenFilter ( ) { super ( ) ; } public TokenFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } while ( line == null || line . length ( ) == 0 ) { line = tokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } for ( Enumeration e = filters . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; line = filter . filter ( line ) ; if ( line == null ) { break ; } } linePos = 0 ; if ( line != null ) { if ( tokenizer . getPostToken ( ) . length ( ) != 0 ) { if ( delimOutput != null ) { line = line + delimOutput ; } else { line = line + tokenizer . getPostToken ( ) ; } } } } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public final Reader chain ( final Reader reader ) { TokenFilter newFilter = new TokenFilter ( reader ) ; newFilter . filters = filters ; newFilter . tokenizer = tokenizer ; newFilter . delimOutput = delimOutput ; newFilter . setProject ( getProject ( ) ) ; return newFilter ; } public void setDelimOutput ( String delimOutput ) { this . delimOutput = resolveBackSlash ( delimOutput ) ; } public void addLineTokenizer ( LineTokenizer tokenizer ) { add ( tokenizer ) ; } public void addStringTokenizer ( StringTokenizer tokenizer ) { add ( tokenizer ) ; } public void addFileTokenizer ( FileTokenizer tokenizer ) { add ( tokenizer ) ; } public void add ( Tokenizer tokenizer ) { if ( this . tokenizer != null ) { throw new BuildException ( "Only one tokenizer allowed" ) ; } this . tokenizer = tokenizer ; } public void addReplaceString ( ReplaceString filter ) { filters . addElement ( filter ) ; } public void addContainsString ( ContainsString filter ) { filters . addElement ( filter ) ; } public void addReplaceRegex ( ReplaceRegex filter ) { filters . addElement ( filter ) ; } public void addContainsRegex ( ContainsRegex filter ) { filters . addElement ( filter ) ; } public void addTrim ( Trim filter ) { filters . addElement ( filter ) ; } public void addIgnoreBlank ( IgnoreBlank filter ) { filters . addElement ( filter ) ; } public void addDeleteCharacters ( DeleteCharacters filter ) { filters . addElement ( filter ) ; } public void add ( Filter filter ) { filters . addElement ( filter ) ; } public static class FileTokenizer extends org . apache . tools . ant . util . FileTokenizer { } public static class StringTokenizer extends org . apache . tools . ant . util . StringTokenizer { } public abstract static class ChainableReaderFilter extends ProjectComponent implements ChainableReader , Filter { private boolean byLine = true ; public void setByLine ( boolean byLine ) { this . byLine = byLine ; } public Reader chain ( Reader reader ) { TokenFilter tokenFilter = new TokenFilter ( reader ) ; if ( ! byLine ) { tokenFilter . add ( new FileTokenizer ( ) ) ; } tokenFilter . add ( this ) ; return tokenFilter ; } } public static class ReplaceString extends ChainableReaderFilter { private String from ; private String to ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String filter ( String line ) { if ( from == null ) { throw new BuildException ( "Missing from in stringreplace" ) ; } StringBuffer ret = new StringBuffer ( ) ; int start = 0 ; int found = line . indexOf ( from ) ; while ( found >= 0 ) { if ( found > start ) { ret . append ( line . substring ( start , found ) ) ; } if ( to != null ) { ret . append ( to ) ; } start = found + from . length ( ) ; found = line . indexOf ( from , start ) ; } if ( line . length ( ) > start ) { ret . append ( line . substring ( start , line . length ( ) ) ) ; } return ret . toString ( ) ; } } public static class ContainsString extends ProjectComponent implements Filter { private String contains ; public void setContains ( String contains ) { this . contains = contains ; } public String filter ( String string ) { if ( contains == null ) { throw new BuildException ( "Missing contains in containsstring" ) ; } if ( string . indexOf ( contains ) > - 1 ) { return string ; } return null ; } } public static class ReplaceRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing pattern in replaceregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { to = "" ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String line ) { initialize ( ) ; if ( ! regexp . matches ( line , options ) ) { return line ; } return regexp . substitute ( line , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class ContainsRegex extends ChainableReaderFilter { private String from ; private String to ; private RegularExpression regularExpression ; private Substitution substitution ; private boolean initialized = false ; private String flags = "" ; private int options ; private Regexp regexp ; public void setPattern ( String from ) { this . from = from ; } public void setReplace ( String to ) { this . to = to ; } public void setFlags ( String flags ) { this . flags = flags ; } private void initialize ( ) { if ( initialized ) { return ; } options = convertRegexOptions ( flags ) ; if ( from == null ) { throw new BuildException ( "Missing from in containsregex" ) ; } regularExpression = new RegularExpression ( ) ; regularExpression . setPattern ( from ) ; regexp = regularExpression . getRegexp ( getProject ( ) ) ; if ( to == null ) { return ; } substitution = new Substitution ( ) ; substitution . setExpression ( to ) ; } public String filter ( String string ) { initialize ( ) ; if ( ! regexp . matches ( string , options ) ) { return null ; } if ( substitution == null ) { return string ; } return regexp . substitute ( string , substitution . getExpression ( getProject ( ) ) , options ) ; } } public static class Trim extends ChainableReaderFilter { public String filter ( String line ) { return line . trim ( ) ; } } public static class IgnoreBlank extends ChainableReaderFilter { public String filter ( String line ) { if ( line . trim ( ) . length ( ) == 0 ) { return null ; } return line ; } } public static class DeleteCharacters extends ProjectComponent implements Filter , ChainableReader { private String deleteChars = "" ; public void setChars ( String deleteChars ) { this . deleteChars = resolveBackSlash ( deleteChars ) ; } public String filter ( String string ) { StringBuffer output = new StringBuffer ( string . length ( ) ) ; for ( int i = 0 ; i < string . length ( ) ; ++ i ) { char ch = string . charAt ( i ) ; if ( ! ( isDeleteCharacter ( ch ) ) ) { output . append ( ch ) ; } } return output . toString ( ) ; } public Reader chain ( Reader reader ) { return new BaseFilterReader ( reader ) { public int read ( ) throws IOException { while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { return c ; } if ( ! ( isDeleteCharacter ( ( char ) c ) ) ) { return c ; } } } } ; } private boolean isDeleteCharacter ( char c ) { for ( int d = 0 ; d < deleteChars . length ( ) ; ++ d ) { if ( deleteChars . charAt ( d ) == c ) { return true ; } } return false ; } } public static String resolveBackSlash ( String input ) { return StringUtils . resolveBackSlash ( input ) ; } public static int convertRegexOptions ( String flags ) { if ( flags == null ) { return 0 ; } int options = 0 ; if ( flags . indexOf ( 'g' ) != - 1 ) { options |= Regexp . REPLACE_ALL ; } if ( flags . indexOf ( 'i' ) != - 1 ) { options |= Regexp . MATCH_CASE_INSENSITIVE ; } if ( flags . indexOf ( 'm' ) != - 1 ) { options |= Regexp . MATCH_MULTILINE ; } if ( flags . indexOf ( 's' ) != - 1 ) { options |= Regexp . MATCH_SINGLELINE ; } return options ; } } 	0	['19', '4', '0', '19', '41', '23', '5', '17', '19', '0.688888889', '319', '1', '1', '0.604651163', '0.119298246', '2', '4', '15.52631579', '6', '1.2105', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . OutputStream ; public class OutputStreamFunneler { public static final long DEFAULT_TIMEOUT_MILLIS = 1000 ; private final class Funnel extends OutputStream { private boolean closed = false ; private Funnel ( ) { synchronized ( OutputStreamFunneler . this ) { ++ count ; } } public void flush ( ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . flush ( ) ; } } public void write ( int b ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b ) ; } } public void write ( byte [ ] b ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b ) ; } } public void write ( byte [ ] b , int off , int len ) throws IOException { synchronized ( OutputStreamFunneler . this ) { dieIfClosed ( ) ; out . write ( b , off , len ) ; } } public void close ( ) throws IOException { release ( this ) ; } } private OutputStream out ; private int count = 0 ; private boolean closed ; private long timeoutMillis ; public OutputStreamFunneler ( OutputStream out ) { this ( out , DEFAULT_TIMEOUT_MILLIS ) ; } public OutputStreamFunneler ( OutputStream out , long timeoutMillis ) { if ( out == null ) { throw new IllegalArgumentException ( "OutputStreamFunneler.<init>:  out == null" ) ; } this . out = out ; this . closed = false ; setTimeout ( timeoutMillis ) ; } public synchronized void setTimeout ( long timeoutMillis ) { this . timeoutMillis = timeoutMillis ; } public synchronized OutputStream getFunnelInstance ( ) throws IOException { dieIfClosed ( ) ; try { return new Funnel ( ) ; } finally { notifyAll ( ) ; } } private synchronized void release ( Funnel funnel ) throws IOException { if ( ! funnel . closed ) { try { if ( timeoutMillis > 0 ) { try { wait ( timeoutMillis ) ; } catch ( InterruptedException eyeEx ) { } } if ( -- count == 0 ) { close ( ) ; } } finally { funnel . closed = true ; } } } private synchronized void close ( ) throws IOException { try { dieIfClosed ( ) ; out . close ( ) ; } finally { closed = true ; } } private synchronized void dieIfClosed ( ) throws IOException { if ( closed ) { throw new IOException ( "The funneled OutputStream has been closed." ) ; } } } 	0	['12', '1', '0', '2', '21', '42', '2', '1', '4', '0.654545455', '146', '0.8', '0', '0', '0.263888889', '0', '0', '10.75', '1', '0.8333', '0']
package org . apache . tools . ant . types . optional . depend ; import java . io . File ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; public class DependScanner extends DirectoryScanner { public static final String DEFAULT_ANALYZER_CLASS = "org.apache.tools.ant.util.depend.bcel.FullAnalyzer" ; private Vector rootClasses ; private Vector included ; private DirectoryScanner parentScanner ; public DependScanner ( DirectoryScanner parentScanner ) { this . parentScanner = parentScanner ; } public synchronized void setRootClasses ( Vector rootClasses ) { this . rootClasses = rootClasses ; } public String [ ] getIncludedFiles ( ) { String [ ] files = new String [ getIncludedFilesCount ( ) ] ; for ( int i = 0 ; i < files . length ; i ++ ) { files [ i ] = ( String ) included . elementAt ( i ) ; } return files ; } public synchronized int getIncludedFilesCount ( ) { if ( included == null ) { throw new IllegalStateException ( ) ; } return included . size ( ) ; } public synchronized void scan ( ) throws IllegalStateException { included = new Vector ( ) ; String analyzerClassName = DEFAULT_ANALYZER_CLASS ; DependencyAnalyzer analyzer = null ; try { Class analyzerClass = Class . forName ( analyzerClassName ) ; analyzer = ( DependencyAnalyzer ) analyzerClass . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( "Unable to load dependency analyzer: " + analyzerClassName , e ) ; } analyzer . addClassPath ( new Path ( null , basedir . getPath ( ) ) ) ; for ( Enumeration e = rootClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String rootClass = ( String ) e . nextElement ( ) ; analyzer . addRootClass ( rootClass ) ; } Enumeration e = analyzer . getClassDependencies ( ) ; String [ ] parentFiles = parentScanner . getIncludedFiles ( ) ; Hashtable parentSet = new Hashtable ( ) ; for ( int i = 0 ; i < parentFiles . length ; ++ i ) { parentSet . put ( parentFiles [ i ] , parentFiles [ i ] ) ; } while ( e . hasMoreElements ( ) ) { String classname = ( String ) e . nextElement ( ) ; String filename = classname . replace ( '.' , File . separatorChar ) ; filename = filename + ".class" ; File depFile = new File ( basedir , filename ) ; if ( depFile . exists ( ) && parentSet . containsKey ( filename ) ) { included . addElement ( filename ) ; } } } public void addDefaultExcludes ( ) { } public String [ ] getExcludedDirectories ( ) { return null ; } public String [ ] getExcludedFiles ( ) { return null ; } public String [ ] getIncludedDirectories ( ) { return new String [ 0 ] ; } public int getIncludedDirsCount ( ) { return 0 ; } public String [ ] getNotIncludedDirectories ( ) { return null ; } public String [ ] getNotIncludedFiles ( ) { return null ; } public void setExcludes ( String [ ] excludes ) { } public void setIncludes ( String [ ] includes ) { } public void setCaseSensitive ( boolean isCaseSensitive ) { } } 	0	['15', '2', '0', '6', '43', '95', '1', '5', '15', '0.946428571', '202', '0.75', '1', '0.813333333', '0.266666667', '1', '1', '12.2', '2', '1.0667', '0']
package org . apache . tools . ant . launch ; import java . util . Properties ; public interface AntMain { void startAnt ( String [ ] args , Properties additionalUserProperties , ClassLoader coreLoader ) ; } 	0	['1', '1', '0', '2', '1', '0', '2', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util ; import java . lang . reflect . Constructor ; public class ReflectWrapper { private Object obj ; public ReflectWrapper ( ClassLoader loader , String name ) { try { Class clazz ; clazz = Class . forName ( name , true , loader ) ; Constructor constructor ; constructor = clazz . getConstructor ( ( Class [ ] ) null ) ; obj = constructor . newInstance ( ( Object [ ] ) null ) ; } catch ( Exception t ) { ReflectUtil . throwBuildException ( t ) ; } } public ReflectWrapper ( Object obj ) { this . obj = obj ; } public Object getObject ( ) { return obj ; } public Object invoke ( String methodName ) { return ReflectUtil . invoke ( obj , methodName ) ; } public Object invoke ( String methodName , Class argType , Object arg ) { return ReflectUtil . invoke ( obj , methodName , argType , arg ) ; } public Object invoke ( String methodName , Class argType1 , Object arg1 , Class argType2 , Object arg2 ) { return ReflectUtil . invoke ( obj , methodName , argType1 , arg1 , argType2 , arg2 ) ; } } 	0	['6', '1', '0', '3', '14', '0', '2', '1', '6', '0', '58', '1', '0', '0', '0.533333333', '0', '0', '8.5', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; public interface SelectorScanner { void setSelectors ( FileSelector [ ] selectors ) ; String [ ] getDeselectedDirectories ( ) ; String [ ] getDeselectedFiles ( ) ; } 	0	['3', '1', '0', '3', '3', '3', '2', '1', '3', '2', '3', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . filters . ChainableReader ; import org . apache . tools . ant . filters . ClassConstants ; import org . apache . tools . ant . filters . EscapeUnicode ; import org . apache . tools . ant . filters . ExpandProperties ; import org . apache . tools . ant . filters . HeadFilter ; import org . apache . tools . ant . filters . LineContains ; import org . apache . tools . ant . filters . LineContainsRegExp ; import org . apache . tools . ant . filters . PrefixLines ; import org . apache . tools . ant . filters . ReplaceTokens ; import org . apache . tools . ant . filters . StripJavaComments ; import org . apache . tools . ant . filters . StripLineBreaks ; import org . apache . tools . ant . filters . StripLineComments ; import org . apache . tools . ant . filters . TabsToSpaces ; import org . apache . tools . ant . filters . TailFilter ; import org . apache . tools . ant . filters . TokenFilter ; public class FilterChain extends DataType implements Cloneable { private Vector filterReaders = new Vector ( ) ; public void addFilterReader ( final AntFilterReader filterReader ) { filterReaders . addElement ( filterReader ) ; } public Vector getFilterReaders ( ) { return filterReaders ; } public void addClassConstants ( final ClassConstants classConstants ) { filterReaders . addElement ( classConstants ) ; } public void addExpandProperties ( final ExpandProperties expandProperties ) { filterReaders . addElement ( expandProperties ) ; } public void addHeadFilter ( final HeadFilter headFilter ) { filterReaders . addElement ( headFilter ) ; } public void addLineContains ( final LineContains lineContains ) { filterReaders . addElement ( lineContains ) ; } public void addLineContainsRegExp ( final LineContainsRegExp lineContainsRegExp ) { filterReaders . addElement ( lineContainsRegExp ) ; } public void addPrefixLines ( final PrefixLines prefixLines ) { filterReaders . addElement ( prefixLines ) ; } public void addReplaceTokens ( final ReplaceTokens replaceTokens ) { filterReaders . addElement ( replaceTokens ) ; } public void addStripJavaComments ( final StripJavaComments stripJavaComments ) { filterReaders . addElement ( stripJavaComments ) ; } public void addStripLineBreaks ( final StripLineBreaks stripLineBreaks ) { filterReaders . addElement ( stripLineBreaks ) ; } public void addStripLineComments ( final StripLineComments stripLineComments ) { filterReaders . addElement ( stripLineComments ) ; } public void addTabsToSpaces ( final TabsToSpaces tabsToSpaces ) { filterReaders . addElement ( tabsToSpaces ) ; } public void addTailFilter ( final TailFilter tailFilter ) { filterReaders . addElement ( tailFilter ) ; } public void addEscapeUnicode ( final EscapeUnicode escapeUnicode ) { filterReaders . addElement ( escapeUnicode ) ; } public void addTokenFilter ( final TokenFilter tokenFilter ) { filterReaders . addElement ( tokenFilter ) ; } public void addDeleteCharacters ( TokenFilter . DeleteCharacters filter ) { filterReaders . addElement ( filter ) ; } public void addContainsRegex ( TokenFilter . ContainsRegex filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceRegex ( TokenFilter . ReplaceRegex filter ) { filterReaders . addElement ( filter ) ; } public void addTrim ( TokenFilter . Trim filter ) { filterReaders . addElement ( filter ) ; } public void addReplaceString ( TokenFilter . ReplaceString filter ) { filterReaders . addElement ( filter ) ; } public void addIgnoreBlank ( TokenFilter . IgnoreBlank filter ) { filterReaders . addElement ( filter ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! filterReaders . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } Object o = r . getReferencedObject ( getProject ( ) ) ; if ( o instanceof FilterChain ) { FilterChain fc = ( FilterChain ) o ; filterReaders = fc . getFilterReaders ( ) ; } else { String msg = r . getRefId ( ) + " doesn\'t refer to a FilterChain" ; throw new BuildException ( msg ) ; } super . setRefid ( r ) ; } public void add ( ChainableReader filter ) { filterReaders . addElement ( filter ) ; } } 	0	['25', '3', '1', '35', '39', '0', '9', '26', '25', '0', '189', '1', '0', '0.555555556', '0.08', '1', '1', '6.52', '1', '0.96', '0']
package org . apache . tools . ant . launch ; public class LaunchException extends Exception { public LaunchException ( String message ) { super ( message ) ; } } 	0	['1', '3', '0', '1', '2', '0', '1', '0', '1', '2', '5', '0', '0', '1', '1', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; public interface Native2AsciiAdapter { boolean convert ( Native2Ascii args , File srcFile , File destFile ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '2', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . InputStream ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . StreamPumper ; import org . apache . tools . ant . util . FileUtils ; public class GreedyInputHandler extends DefaultInputHandler { private static final int BUFFER_SIZE = 1024 ; public GreedyInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { String prompt = getPrompt ( request ) ; InputStream in = null ; try { in = getInputStream ( ) ; System . err . println ( prompt ) ; System . err . flush ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; StreamPumper p = new StreamPumper ( in , baos ) ; Thread t = new Thread ( p ) ; t . start ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { try { t . join ( ) ; } catch ( InterruptedException e2 ) { } } request . setInput ( new String ( baos . toByteArray ( ) ) ) ; if ( ! ( request . isInputValid ( ) ) ) { throw new BuildException ( "Received invalid console input" ) ; } if ( p . getException ( ) != null ) { throw new BuildException ( "Failed to read input from console" , p . getException ( ) ) ; } } finally { FileUtils . close ( in ) ; } } } 	0	['2', '2', '0', '6', '20', '1', '1', '5', '2', '2', '80', '1', '0', '0.75', '0.75', '1', '1', '38.5', '1', '0.5', '0']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . util . FileNameMapper ; import java . util . ArrayList ; public class ScriptMapper extends AbstractScriptComponent implements FileNameMapper { private ArrayList files ; static final String [ ] EMPTY_STRING_ARRAY = new String [ 0 ] ; public void setFrom ( String from ) { } public void setTo ( String to ) { } public void clear ( ) { files = new ArrayList ( 1 ) ; } public void addMappedName ( String mapping ) { files . add ( mapping ) ; } public String [ ] mapFileName ( String sourceFileName ) { initScriptRunner ( ) ; getRunner ( ) . addBean ( "source" , sourceFileName ) ; clear ( ) ; executeScript ( "ant_mapper" ) ; if ( files . size ( ) == 0 ) { return null ; } else { return ( String [ ] ) files . toArray ( EMPTY_STRING_ARRAY ) ; } } } 	0	['7', '3', '0', '3', '16', '13', '0', '3', '6', '0.75', '55', '0.5', '0', '0.8', '0.833333333', '0', '0', '6.571428571', '2', '0.8571', '0']
package org . apache . tools . ant . types . resolver ; import org . apache . xml . resolver . Catalog ; import org . apache . xml . resolver . CatalogEntry ; import org . apache . xml . resolver . helpers . PublicId ; public class ApacheCatalog extends Catalog { private ApacheCatalogResolver resolver = null ; protected Catalog newCatalog ( ) { ApacheCatalog cat = ( ApacheCatalog ) super . newCatalog ( ) ; cat . setResolver ( resolver ) ; return cat ; } public void setResolver ( ApacheCatalogResolver resolver ) { this . resolver = resolver ; } public void addEntry ( CatalogEntry entry ) { int type = entry . getEntryType ( ) ; if ( type == PUBLIC ) { String publicid = PublicId . normalize ( entry . getEntryArg ( 0 ) ) ; String systemid = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addPublicEntry ( publicid , systemid , base ) ; } } else if ( type == URI ) { String uri = normalizeURI ( entry . getEntryArg ( 0 ) ) ; String altURI = normalizeURI ( entry . getEntryArg ( 1 ) ) ; if ( resolver == null ) { catalogManager . debug . message ( 1 , "Internal Error: null ApacheCatalogResolver" ) ; } else { resolver . addURIEntry ( uri , altURI , base ) ; } } super . addEntry ( entry ) ; } } 	0	['4', '2', '0', '6', '14', '0', '1', '6', '3', '0', '96', '1', '1', '0.916666667', '0.5', '1', '3', '22.75', '5', '1.75', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Edit extends P4Base { public String change = null ; public void setChange ( String change ) { this . change = change ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( P4View == null ) { throw new BuildException ( "No view specified to edit" ) ; } execP4Command ( "-s edit " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '10', '0', '0', '4', '3', '0', '55', '0', '0', '0.962264151', '0.666666667', '1', '1', '17', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSCHECKIN extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKIN ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } } 	0	['7', '4', '0', '6', '28', '21', '0', '6', '6', '2', '92', '0', '0', '0.93814433', '0.428571429', '1', '1', '12.14285714', '2', '1', '0']
package org . apache . tools . ant ; public interface DynamicElementNS { Object createDynamicElement ( String uri , String localName , String qName ) throws BuildException ; } 	0	['1', '1', '0', '4', '1', '0', '3', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringReader ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class Execute { public static final int INVALID = Integer . MAX_VALUE ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private String [ ] cmdl = null ; private String [ ] env = null ; private int exitValue = INVALID ; private ExecuteStreamHandler streamHandler ; private ExecuteWatchdog watchdog ; private File workingDirectory = null ; private Project project = null ; private boolean newEnvironment = false ; private boolean spawn = false ; private boolean useVMLauncher = true ; private static String antWorkingDirectory = System . getProperty ( "user.dir" ) ; private static CommandLauncher vmLauncher = null ; private static CommandLauncher shellLauncher = null ; private static Vector procEnvironment = null ; private static ProcessDestroyer processDestroyer = new ProcessDestroyer ( ) ; private static boolean environmentCaseInSensitive = false ; static { try { if ( ! Os . isFamily ( "os/2" ) ) { vmLauncher = new Java13CommandLauncher ( ) ; } } catch ( NoSuchMethodException exc ) { } if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { shellLauncher = new MacCommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "os/2" ) ) { shellLauncher = new OS2CommandLauncher ( new CommandLauncher ( ) ) ; } else if ( Os . isFamily ( "windows" ) ) { environmentCaseInSensitive = true ; CommandLauncher baseLauncher = new CommandLauncher ( ) ; if ( ! Os . isFamily ( "win9x" ) ) { shellLauncher = new WinNTCommandLauncher ( baseLauncher ) ; } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun.bat" , baseLauncher ) ; } } else if ( Os . isFamily ( "netware" ) ) { CommandLauncher baseLauncher = new CommandLauncher ( ) ; shellLauncher = new PerlScriptCommandLauncher ( "bin/antRun.pl" , baseLauncher ) ; } else if ( Os . isFamily ( "openvms" ) ) { try { shellLauncher = new VmsCommandLauncher ( ) ; } catch ( NoSuchMethodException exc ) { } } else { shellLauncher = new ScriptCommandLauncher ( "bin/antRun" , new CommandLauncher ( ) ) ; } } public void setSpawn ( boolean spawn ) { this . spawn = spawn ; } public static synchronized Vector getProcEnvironment ( ) { if ( procEnvironment != null ) { return procEnvironment ; } procEnvironment = new Vector ( ) ; try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Execute exe = new Execute ( new PumpStreamHandler ( out ) ) ; exe . setCommandline ( getProcEnvCommand ( ) ) ; exe . setNewenvironment ( true ) ; int retval = exe . execute ( ) ; if ( retval != 0 ) { } BufferedReader in = new BufferedReader ( new StringReader ( toString ( out ) ) ) ; if ( Os . isFamily ( "openvms" ) ) { procEnvironment = addVMSLogicals ( procEnvironment , in ) ; return procEnvironment ; } String var = null ; String line , lineSep = StringUtils . LINE_SEP ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . indexOf ( '=' ) == - 1 ) { if ( var == null ) { var = lineSep + line ; } else { var += lineSep + line ; } } else { if ( var != null ) { procEnvironment . addElement ( var ) ; } var = line ; } } if ( var != null ) { procEnvironment . addElement ( var ) ; } } catch ( java . io . IOException exc ) { exc . printStackTrace ( ) ; } return procEnvironment ; } private static String [ ] getProcEnvCommand ( ) { if ( Os . isFamily ( "os/2" ) ) { return new String [ ] { "cmd" , "/c" , "set" } ; } else if ( Os . isFamily ( "windows" ) ) { if ( Os . isFamily ( "win9x" ) ) { return new String [ ] { "command.com" , "/c" , "set" } ; } else { return new String [ ] { "cmd" , "/c" , "set" } ; } } else if ( Os . isFamily ( "z/os" ) || Os . isFamily ( "unix" ) ) { String [ ] cmd = new String [ 1 ] ; if ( new File ( "/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/bin/env" ; } else if ( new File ( "/usr/bin/env" ) . canRead ( ) ) { cmd [ 0 ] = "/usr/bin/env" ; } else { cmd [ 0 ] = "env" ; } return cmd ; } else if ( Os . isFamily ( "netware" ) || Os . isFamily ( "os/400" ) ) { return new String [ ] { "env" } ; } else if ( Os . isFamily ( "openvms" ) ) { return new String [ ] { "show" , "logical" } ; } else { return null ; } } public static String toString ( ByteArrayOutputStream bos ) { if ( Os . isFamily ( "z/os" ) ) { try { return bos . toString ( "Cp1047" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } else if ( Os . isFamily ( "os/400" ) ) { try { return bos . toString ( "Cp500" ) ; } catch ( java . io . UnsupportedEncodingException e ) { } } return bos . toString ( ) ; } public Execute ( ) { this ( new PumpStreamHandler ( ) , null ) ; } public Execute ( ExecuteStreamHandler streamHandler ) { this ( streamHandler , null ) ; } public Execute ( ExecuteStreamHandler streamHandler , ExecuteWatchdog watchdog ) { setStreamHandler ( streamHandler ) ; this . watchdog = watchdog ; if ( Os . isFamily ( "openvms" ) ) { useVMLauncher = false ; } } public void setStreamHandler ( ExecuteStreamHandler streamHandler ) { this . streamHandler = streamHandler ; } public String [ ] getCommandline ( ) { return cmdl ; } public void setCommandline ( String [ ] commandline ) { cmdl = commandline ; } public void setNewenvironment ( boolean newenv ) { newEnvironment = newenv ; } public String [ ] getEnvironment ( ) { return ( env == null || newEnvironment ) ? env : patchEnvironment ( ) ; } public void setEnvironment ( String [ ] env ) { this . env = env ; } public void setWorkingDirectory ( File wd ) { workingDirectory = ( wd == null || wd . getAbsolutePath ( ) . equals ( antWorkingDirectory ) ) ? null : wd ; } public File getWorkingDirectory ( ) { return workingDirectory == null ? new File ( antWorkingDirectory ) : workingDirectory ; } public void setAntRun ( Project project ) throws BuildException { this . project = project ; } public void setVMLauncher ( boolean useVMLauncher ) { this . useVMLauncher = useVMLauncher ; } public static Process launch ( Project project , String [ ] command , String [ ] env , File dir , boolean useVM ) throws IOException { if ( dir != null && ! dir . exists ( ) ) { throw new BuildException ( dir + " doesn't exist." ) ; } CommandLauncher launcher = ( ( useVM && vmLauncher != null ) ? vmLauncher : shellLauncher ) ; return launcher . exec ( project , command , env , dir ) ; } public int execute ( ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new BuildException ( workingDirectory + " doesn't exist." ) ; } final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; try { streamHandler . setProcessInputStream ( process . getOutputStream ( ) ) ; streamHandler . setProcessOutputStream ( process . getInputStream ( ) ) ; streamHandler . setProcessErrorStream ( process . getErrorStream ( ) ) ; } catch ( IOException e ) { process . destroy ( ) ; throw e ; } streamHandler . start ( ) ; try { processDestroyer . add ( process ) ; if ( watchdog != null ) { watchdog . start ( process ) ; } waitFor ( process ) ; if ( watchdog != null ) { watchdog . stop ( ) ; } streamHandler . stop ( ) ; closeStreams ( process ) ; if ( watchdog != null ) { watchdog . checkException ( ) ; } return getExitValue ( ) ; } catch ( ThreadDeath t ) { process . destroy ( ) ; throw t ; } finally { processDestroyer . remove ( process ) ; } } public void spawn ( ) throws IOException { if ( workingDirectory != null && ! workingDirectory . exists ( ) ) { throw new BuildException ( workingDirectory + " doesn't exist." ) ; } final Process process = launch ( project , getCommandline ( ) , getEnvironment ( ) , workingDirectory , useVMLauncher ) ; if ( Os . isFamily ( "windows" ) ) { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { project . log ( "interruption in the sleep after having spawned a" + " process" , Project . MSG_VERBOSE ) ; } } OutputStream dummyOut = new OutputStream ( ) { public void write ( int b ) throws IOException { } } ; ExecuteStreamHandler handler = new PumpStreamHandler ( dummyOut ) ; handler . setProcessErrorStream ( process . getErrorStream ( ) ) ; handler . setProcessOutputStream ( process . getInputStream ( ) ) ; handler . start ( ) ; process . getOutputStream ( ) . close ( ) ; project . log ( "spawned process " + process . toString ( ) , Project . MSG_VERBOSE ) ; } protected void waitFor ( Process process ) { try { process . waitFor ( ) ; setExitValue ( process . exitValue ( ) ) ; } catch ( InterruptedException e ) { process . destroy ( ) ; } } protected void setExitValue ( int value ) { exitValue = value ; } public int getExitValue ( ) { return exitValue ; } public static boolean isFailure ( int exitValue ) { return Os . isFamily ( "openvms" ) ? ( exitValue % 2 == 0 ) : ( exitValue != 0 ) ; } public boolean isFailure ( ) { return isFailure ( getExitValue ( ) ) ; } public boolean killedProcess ( ) { return watchdog != null && watchdog . killedProcess ( ) ; } private String [ ] patchEnvironment ( ) { if ( Os . isFamily ( "openvms" ) ) { return env ; } Vector osEnv = ( Vector ) getProcEnvironment ( ) . clone ( ) ; for ( int i = 0 ; i < env . length ; i ++ ) { String keyValue = env [ i ] ; String key = keyValue . substring ( 0 , keyValue . indexOf ( '=' ) + 1 ) ; if ( environmentCaseInSensitive ) { key = key . toLowerCase ( ) ; } int size = osEnv . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { String osEnvItem = ( String ) osEnv . elementAt ( j ) ; String convertedItem = environmentCaseInSensitive ? osEnvItem . toLowerCase ( ) : osEnvItem ; if ( convertedItem . startsWith ( key ) ) { osEnv . removeElementAt ( j ) ; if ( environmentCaseInSensitive ) { keyValue = osEnvItem . substring ( 0 , key . length ( ) ) + keyValue . substring ( key . length ( ) ) ; } break ; } } osEnv . addElement ( keyValue ) ; } return ( String [ ] ) ( osEnv . toArray ( new String [ osEnv . size ( ) ] ) ) ; } public static void runCommand ( Task task , String [ ] cmdline ) throws BuildException { try { task . log ( Commandline . describeCommand ( cmdline ) , Project . MSG_VERBOSE ) ; Execute exe = new Execute ( new LogStreamHandler ( task , Project . MSG_INFO , Project . MSG_ERR ) ) ; exe . setAntRun ( task . getProject ( ) ) ; exe . setCommandline ( cmdline ) ; int retval = exe . execute ( ) ; if ( isFailure ( retval ) ) { throw new BuildException ( cmdline [ 0 ] + " failed with return code " + retval , task . getLocation ( ) ) ; } } catch ( java . io . IOException exc ) { throw new BuildException ( "Could not launch " + cmdline [ 0 ] + ": " + exc , task . getLocation ( ) ) ; } } public static void closeStreams ( Process process ) { FileUtils . close ( process . getInputStream ( ) ) ; FileUtils . close ( process . getOutputStream ( ) ) ; FileUtils . close ( process . getErrorStream ( ) ) ; } private static Vector addVMSLogicals ( Vector environment , BufferedReader in ) throws IOException { HashMap logicals = new HashMap ( ) ; String logName = null , logValue = null , newLogName ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "\t=" ) ) { if ( logName != null ) { logValue += "," + line . substring ( 4 , line . length ( ) - 1 ) ; } } else if ( line . startsWith ( "  \"" ) ) { if ( logName != null ) { logicals . put ( logName , logValue ) ; } int eqIndex = line . indexOf ( '=' ) ; newLogName = line . substring ( 3 , eqIndex - 2 ) ; if ( logicals . containsKey ( newLogName ) ) { logName = null ; } else { logName = newLogName ; logValue = line . substring ( eqIndex + 3 , line . length ( ) - 1 ) ; } } } if ( logName != null ) { logicals . put ( logName , logValue ) ; } for ( Iterator i = logicals . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String logical = ( String ) i . next ( ) ; environment . add ( logical + "=" + logicals . get ( logical ) ) ; } return environment ; } private static class CommandLauncher { public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { if ( project != null ) { project . log ( "Execute:CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return Runtime . getRuntime ( ) . exec ( cmd , env ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot execute a process in different " + "directory under this JVM" ) ; } } private static class Java13CommandLauncher extends CommandLauncher { private Method myExecWithCWD ; public Java13CommandLauncher ( ) throws NoSuchMethodException { myExecWithCWD = Runtime . class . getMethod ( "exec" , new Class [ ] { String [ ] . class , String [ ] . class , File . class } ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { try { if ( project != null ) { project . log ( "Execute:Java13CommandLauncher: " + Commandline . describeCommand ( cmd ) , Project . MSG_DEBUG ) ; } return ( Process ) myExecWithCWD . invoke ( Runtime . getRuntime ( ) , new Object [ ] { cmd , env , workingDir } ) ; } catch ( InvocationTargetException exc ) { Throwable realexc = exc . getTargetException ( ) ; if ( realexc instanceof ThreadDeath ) { throw ( ThreadDeath ) realexc ; } else if ( realexc instanceof IOException ) { throw ( IOException ) realexc ; } else { throw new BuildException ( "Unable to execute command" , realexc ) ; } } catch ( Exception exc ) { throw new BuildException ( "Unable to execute command" , exc ) ; } } } private static class CommandLauncherProxy extends CommandLauncher { private CommandLauncher myLauncher ; CommandLauncherProxy ( CommandLauncher launcher ) { myLauncher = launcher ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { return myLauncher . exec ( project , cmd , env ) ; } } private static class OS2CommandLauncher extends CommandLauncherProxy { OS2CommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 7 ; final String cmdDir = commandDir . getAbsolutePath ( ) ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = cmdDir . substring ( 0 , 2 ) ; newcmd [ 3 ] = "&&" ; newcmd [ 4 ] = "cd" ; newcmd [ 5 ] = cmdDir . substring ( 2 ) ; newcmd [ 6 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class WinNTCommandLauncher extends CommandLauncherProxy { WinNTCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File commandDir = workingDir ; if ( workingDir == null ) { if ( project != null ) { commandDir = project . getBaseDir ( ) ; } else { return exec ( project , cmd , env ) ; } } final int preCmdLength = 6 ; String [ ] newcmd = new String [ cmd . length + preCmdLength ] ; newcmd [ 0 ] = "cmd" ; newcmd [ 1 ] = "/c" ; newcmd [ 2 ] = "cd" ; newcmd [ 3 ] = "/d" ; newcmd [ 4 ] = commandDir . getAbsolutePath ( ) ; newcmd [ 5 ] = "&&" ; System . arraycopy ( cmd , 0 , newcmd , preCmdLength , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class MacCommandLauncher extends CommandLauncherProxy { MacCommandLauncher ( CommandLauncher launcher ) { super ( launcher ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } System . getProperties ( ) . put ( "user.dir" , workingDir . getAbsolutePath ( ) ) ; try { return exec ( project , cmd , env ) ; } finally { System . getProperties ( ) . put ( "user.dir" , antWorkingDirectory ) ; } } } private static class ScriptCommandLauncher extends CommandLauncherProxy { ScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( MagicNames . ANT_HOME ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property '" + MagicNames . ANT_HOME + "' not found" ) ; } String antRun = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 2 ] ; newcmd [ 0 ] = antRun ; newcmd [ 1 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 2 , cmd . length ) ; return exec ( project , newcmd , env ) ; } private String myScript ; } private static class PerlScriptCommandLauncher extends CommandLauncherProxy { private String myScript ; PerlScriptCommandLauncher ( String script , CommandLauncher launcher ) { super ( launcher ) ; myScript = script ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { if ( project == null ) { if ( workingDir == null ) { return exec ( project , cmd , env ) ; } throw new IOException ( "Cannot locate antRun script: " + "No project provided" ) ; } String antHome = project . getProperty ( MagicNames . ANT_HOME ) ; if ( antHome == null ) { throw new IOException ( "Cannot locate antRun script: " + "Property '" + MagicNames . ANT_HOME + "' not found" ) ; } String antRun = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , antHome + File . separator + myScript ) . toString ( ) ; File commandDir = workingDir ; if ( workingDir == null && project != null ) { commandDir = project . getBaseDir ( ) ; } String [ ] newcmd = new String [ cmd . length + 3 ] ; newcmd [ 0 ] = "perl" ; newcmd [ 1 ] = antRun ; newcmd [ 2 ] = commandDir . getAbsolutePath ( ) ; System . arraycopy ( cmd , 0 , newcmd , 3 , cmd . length ) ; return exec ( project , newcmd , env ) ; } } private static class VmsCommandLauncher extends Java13CommandLauncher { public VmsCommandLauncher ( ) throws NoSuchMethodException { super ( ) ; } public Process exec ( Project project , String [ ] cmd , String [ ] env ) throws IOException { File cmdFile = createCommandFile ( cmd , env ) ; Process p = super . exec ( project , new String [ ] { cmdFile . getPath ( ) } , env ) ; deleteAfter ( cmdFile , p ) ; return p ; } public Process exec ( Project project , String [ ] cmd , String [ ] env , File workingDir ) throws IOException { File cmdFile = createCommandFile ( cmd , env ) ; Process p = super . exec ( project , new String [ ] { cmdFile . getPath ( ) } , env , workingDir ) ; deleteAfter ( cmdFile , p ) ; return p ; } private File createCommandFile ( String [ ] cmd , String [ ] env ) throws IOException { File script = FILE_UTILS . createTempFile ( "ANT" , ".COM" , null ) ; script . deleteOnExit ( ) ; PrintWriter out = null ; try { out = new PrintWriter ( new FileWriter ( script ) ) ; if ( env != null ) { int eqIndex ; for ( int i = 0 ; i < env . length ; i ++ ) { eqIndex = env [ i ] . indexOf ( '=' ) ; if ( eqIndex != - 1 ) { out . print ( "$ DEFINE/NOLOG " ) ; out . print ( env [ i ] . substring ( 0 , eqIndex ) ) ; out . print ( " \"" ) ; out . print ( env [ i ] . substring ( eqIndex + 1 ) ) ; out . println ( '\"' ) ; } } } out . print ( "$ " + cmd [ 0 ] ) ; for ( int i = 1 ; i < cmd . length ; i ++ ) { out . println ( " -" ) ; out . print ( cmd [ i ] ) ; } } finally { if ( out != null ) { out . close ( ) ; } } return script ; } private void deleteAfter ( final File f , final Process p ) { new Thread ( ) { public void run ( ) { try { p . waitFor ( ) ; } catch ( InterruptedException e ) { } FileUtils . delete ( f ) ; } } . start ( ) ; } } } 	0	['33', '1', '0', '70', '121', '440', '54', '22', '25', '0.860119048', '1095', '0.80952381', '7', '0', '0.110576923', '0', '0', '31.54545455', '11', '1.9697', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Vector ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . DTDLocation ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . XMLCatalog ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . XmlConstants ; import org . xml . sax . EntityResolver ; import org . xml . sax . ErrorHandler ; import org . xml . sax . InputSource ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . SAXParseException ; import org . xml . sax . XMLReader ; import org . xml . sax . helpers . ParserAdapter ; public class XMLValidateTask extends Task { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; protected static final String INIT_FAILED_MSG = "Could not start xml validation: " ; protected boolean failOnError = true ; protected boolean warn = true ; protected boolean lenient = false ; protected String readerClassName = null ; protected File file = null ; protected Vector filesets = new Vector ( ) ; protected Path classpath ; protected XMLReader xmlReader = null ; protected ValidatorErrorHandler errorHandler = new ValidatorErrorHandler ( ) ; private Vector attributeList = new Vector ( ) ; private final Vector propertyList = new Vector ( ) ; private XMLCatalog xmlCatalog = new XMLCatalog ( ) ; public static final String MESSAGE_FILES_VALIDATED = " file(s) have been successfully validated." ; public void setFailOnError ( boolean fail ) { failOnError = fail ; } public void setWarn ( boolean bool ) { warn = bool ; } public void setLenient ( boolean bool ) { lenient = bool ; } public void setClassName ( String className ) { readerClassName = className ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } return this . classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public void setFile ( File file ) { this . file = file ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { xmlCatalog . addConfiguredXMLCatalog ( catalog ) ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public Attribute createAttribute ( ) { final Attribute feature = new Attribute ( ) ; attributeList . addElement ( feature ) ; return feature ; } public Property createProperty ( ) { final Property prop = new Property ( ) ; propertyList . addElement ( prop ) ; return prop ; } public void init ( ) throws BuildException { super . init ( ) ; xmlCatalog . setProject ( getProject ( ) ) ; } public DTDLocation createDTD ( ) { DTDLocation dtdLocation = new DTDLocation ( ) ; xmlCatalog . addDTD ( dtdLocation ) ; return dtdLocation ; } protected EntityResolver getEntityResolver ( ) { return xmlCatalog ; } protected XMLReader getXmlReader ( ) { return xmlReader ; } public void execute ( ) throws BuildException { int fileProcessed = 0 ; if ( file == null && ( filesets . size ( ) == 0 ) ) { throw new BuildException ( "Specify at least one source - " + "a file or a fileset." ) ; } if ( file != null ) { if ( file . exists ( ) && file . canRead ( ) && file . isFile ( ) ) { doValidate ( file ) ; fileProcessed ++ ; } else { String errorMsg = "File " + file + " cannot be read" ; if ( failOnError ) { throw new BuildException ( errorMsg ) ; } else { log ( errorMsg , Project . MSG_ERR ) ; } } } for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int j = 0 ; j < files . length ; j ++ ) { File srcFile = new File ( fs . getDir ( getProject ( ) ) , files [ j ] ) ; doValidate ( srcFile ) ; fileProcessed ++ ; } } onSuccessfulValidation ( fileProcessed ) ; } protected void onSuccessfulValidation ( int fileProcessed ) { log ( fileProcessed + MESSAGE_FILES_VALIDATED ) ; } protected void initValidator ( ) { xmlReader = createXmlReader ( ) ; xmlReader . setEntityResolver ( getEntityResolver ( ) ) ; xmlReader . setErrorHandler ( errorHandler ) ; if ( ! isSax1Parser ( ) ) { if ( ! lenient ) { setFeature ( XmlConstants . FEATURE_VALIDATION , true ) ; } for ( int i = 0 ; i < attributeList . size ( ) ; i ++ ) { Attribute feature = ( Attribute ) attributeList . elementAt ( i ) ; setFeature ( feature . getName ( ) , feature . getValue ( ) ) ; } for ( int i = 0 ; i < propertyList . size ( ) ; i ++ ) { final Property prop = ( Property ) propertyList . elementAt ( i ) ; setProperty ( prop . getName ( ) , prop . getValue ( ) ) ; } } } protected boolean isSax1Parser ( ) { return ( xmlReader instanceof ParserAdapter ) ; } protected XMLReader createXmlReader ( ) { Object reader = null ; if ( readerClassName == null ) { reader = createDefaultReaderOrParser ( ) ; } else { Class readerClass = null ; try { if ( classpath != null ) { AntClassLoader loader = getProject ( ) . createClassLoader ( classpath ) ; readerClass = Class . forName ( readerClassName , true , loader ) ; } else { readerClass = Class . forName ( readerClassName ) ; } reader = readerClass . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } catch ( InstantiationException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( INIT_FAILED_MSG + readerClassName , e ) ; } } XMLReader newReader ; if ( reader instanceof XMLReader ) { newReader = ( XMLReader ) reader ; log ( "Using SAX2 reader " + reader . getClass ( ) . getName ( ) , Project . MSG_VERBOSE ) ; } else { if ( reader instanceof Parser ) { newReader = new ParserAdapter ( ( Parser ) reader ) ; log ( "Using SAX1 parser " + reader . getClass ( ) . getName ( ) , Project . MSG_VERBOSE ) ; } else { throw new BuildException ( INIT_FAILED_MSG + reader . getClass ( ) . getName ( ) + " implements nor SAX1 Parser nor SAX2 XMLReader." ) ; } } return newReader ; } private Object createDefaultReaderOrParser ( ) { Object reader ; try { reader = createDefaultReader ( ) ; } catch ( BuildException exc ) { reader = JAXPUtils . getParser ( ) ; } return reader ; } protected XMLReader createDefaultReader ( ) { return JAXPUtils . getXMLReader ( ) ; } protected void setFeature ( String feature , boolean value ) throws BuildException { log ( "Setting feature " + feature + "=" + value , Project . MSG_DEBUG ) ; try { xmlReader . setFeature ( feature , value ) ; } catch ( SAXNotRecognizedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't recognize feature " + feature , e , getLocation ( ) ) ; } catch ( SAXNotSupportedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't support feature " + feature , e , getLocation ( ) ) ; } } protected void setProperty ( String name , String value ) throws BuildException { if ( name == null || value == null ) { throw new BuildException ( "Property name and value must be specified." ) ; } try { xmlReader . setProperty ( name , value ) ; } catch ( SAXNotRecognizedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't recognize property " + name , e , getLocation ( ) ) ; } catch ( SAXNotSupportedException e ) { throw new BuildException ( "Parser " + xmlReader . getClass ( ) . getName ( ) + " doesn't support property " + name , e , getLocation ( ) ) ; } } protected boolean doValidate ( File afile ) { initValidator ( ) ; boolean result = true ; try { log ( "Validating " + afile . getName ( ) + "... " , Project . MSG_VERBOSE ) ; errorHandler . init ( afile ) ; InputSource is = new InputSource ( new FileInputStream ( afile ) ) ; String uri = FILE_UTILS . toURI ( afile . getAbsolutePath ( ) ) ; is . setSystemId ( uri ) ; xmlReader . parse ( is ) ; } catch ( SAXException ex ) { log ( "Caught when validating: " + ex . toString ( ) , Project . MSG_DEBUG ) ; if ( failOnError ) { throw new BuildException ( "Could not validate document " + afile ) ; } log ( "Could not validate document " + afile + ": " + ex . toString ( ) ) ; result = false ; } catch ( IOException ex ) { throw new BuildException ( "Could not validate document " + afile , ex ) ; } if ( errorHandler . getFailure ( ) ) { if ( failOnError ) { throw new BuildException ( afile + " is not a valid XML document." ) ; } result = false ; log ( afile + " is not a valid XML document" , Project . MSG_ERR ) ; } return result ; } protected class ValidatorErrorHandler implements ErrorHandler { protected File currentFile = null ; protected String lastErrorMessage = null ; protected boolean failed = false ; public void init ( File file ) { currentFile = file ; failed = false ; } public boolean getFailure ( ) { return failed ; } public void fatalError ( SAXParseException exception ) { failed = true ; doLog ( exception , Project . MSG_ERR ) ; } public void error ( SAXParseException exception ) { failed = true ; doLog ( exception , Project . MSG_ERR ) ; } public void warning ( SAXParseException exception ) { if ( warn ) { doLog ( exception , Project . MSG_WARN ) ; } } private void doLog ( SAXParseException e , int logLevel ) { log ( getMessage ( e ) , logLevel ) ; } private String getMessage ( SAXParseException e ) { String sysID = e . getSystemId ( ) ; if ( sysID != null ) { String name = sysID ; if ( sysID . startsWith ( "file:" ) ) { try { name = FILE_UTILS . fromURI ( sysID ) ; } catch ( Exception ex ) { } } int line = e . getLineNumber ( ) ; int col = e . getColumnNumber ( ) ; return name + ( line == - 1 ? "" : ( ":" + line + ( col == - 1 ? "" : ( ":" + col ) ) ) ) + ": " + e . getMessage ( ) ; } return e . getMessage ( ) ; } } public static class Attribute { private String attributeName = null ; private boolean attributeValue ; public void setName ( String name ) { attributeName = name ; } public void setValue ( boolean value ) { attributeValue = value ; } public String getName ( ) { return attributeName ; } public boolean getValue ( ) { return attributeValue ; } } public static final class Property { private String name ; private String value ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } } } 	0	['29', '3', '1', '18', '96', '294', '2', '17', '16', '0.897619048', '796', '0.933333333', '4', '0.578125', '0.162698413', '2', '2', '25.93103448', '5', '1.3793', '0']
package org . apache . tools . ant . types . optional . depend ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class ClassfileSet extends FileSet { private Vector rootClasses = new Vector ( ) ; private Vector rootFileSets = new Vector ( ) ; public static class ClassRoot { private String rootClass ; public void setClassname ( String name ) { this . rootClass = name ; } public String getClassname ( ) { return rootClass ; } } public ClassfileSet ( ) { } public void addRootFileset ( FileSet rootFileSet ) { rootFileSets . addElement ( rootFileSet ) ; } protected ClassfileSet ( ClassfileSet s ) { super ( s ) ; rootClasses = ( Vector ) s . rootClasses . clone ( ) ; } public void setRootClass ( String rootClass ) { rootClasses . addElement ( rootClass ) ; } public DirectoryScanner getDirectoryScanner ( Project p ) { if ( isReference ( ) ) { return getRef ( p ) . getDirectoryScanner ( p ) ; } Vector allRootClasses = ( Vector ) rootClasses . clone ( ) ; for ( Enumeration e = rootFileSets . elements ( ) ; e . hasMoreElements ( ) ; ) { FileSet additionalRootSet = ( FileSet ) e . nextElement ( ) ; DirectoryScanner additionalScanner = additionalRootSet . getDirectoryScanner ( p ) ; String [ ] files = additionalScanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; ++ i ) { if ( files [ i ] . endsWith ( ".class" ) ) { String classFilePath = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; String className = classFilePath . replace ( '/' , '.' ) . replace ( '\\' , '.' ) ; allRootClasses . addElement ( className ) ; } } } DirectoryScanner parentScanner = super . getDirectoryScanner ( p ) ; DependScanner scanner = new DependScanner ( parentScanner ) ; scanner . setBasedir ( getDir ( p ) ) ; scanner . setRootClasses ( allRootClasses ) ; scanner . scan ( ) ; return scanner ; } public void addConfiguredRoot ( ClassRoot root ) { rootClasses . addElement ( root . getClassname ( ) ) ; } public Object clone ( ) { return new ClassfileSet ( isReference ( ) ? ( ClassfileSet ) ( getRef ( getProject ( ) ) ) : this ) ; } } 	0	['7', '5', '0', '6', '31', '0', '0', '6', '6', '0.25', '163', '1', '0', '0.947916667', '0.285714286', '3', '10', '22', '5', '1.4286', '0']
package org . apache . tools . ant . util ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public class KeepAliveOutputStream extends FilterOutputStream { public KeepAliveOutputStream ( OutputStream out ) { super ( out ) ; } public void close ( ) throws IOException { } } 	0	['2', '3', '0', '2', '3', '1', '2', '0', '2', '2', '7', '0', '0', '0.909090909', '0.75', '1', '1', '2.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . jlink ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . Path ; public class JlinkTask extends MatchingTask { public void setOutfile ( File outfile ) { this . outfile = outfile ; } public Path createMergefiles ( ) { if ( this . mergefiles == null ) { this . mergefiles = new Path ( getProject ( ) ) ; } return this . mergefiles . createPath ( ) ; } public void setMergefiles ( Path mergefiles ) { if ( this . mergefiles == null ) { this . mergefiles = mergefiles ; } else { this . mergefiles . append ( mergefiles ) ; } } public Path createAddfiles ( ) { if ( this . addfiles == null ) { this . addfiles = new Path ( getProject ( ) ) ; } return this . addfiles . createPath ( ) ; } public void setAddfiles ( Path addfiles ) { if ( this . addfiles == null ) { this . addfiles = addfiles ; } else { this . addfiles . append ( addfiles ) ; } } public void setCompress ( boolean compress ) { this . compress = compress ; } public void execute ( ) throws BuildException { if ( outfile == null ) { throw new BuildException ( "outfile attribute is required! " + "Please set." ) ; } if ( ! haveAddFiles ( ) && ! haveMergeFiles ( ) ) { throw new BuildException ( "addfiles or mergefiles required! " + "Please set." ) ; } log ( "linking:     " + outfile . getPath ( ) ) ; log ( "compression: " + compress , Project . MSG_VERBOSE ) ; jlink linker = new jlink ( ) ; linker . setOutfile ( outfile . getPath ( ) ) ; linker . setCompression ( compress ) ; if ( haveMergeFiles ( ) ) { log ( "merge files: " + mergefiles . toString ( ) , Project . MSG_VERBOSE ) ; linker . addMergeFiles ( mergefiles . list ( ) ) ; } if ( haveAddFiles ( ) ) { log ( "add files: " + addfiles . toString ( ) , Project . MSG_VERBOSE ) ; linker . addAddFiles ( addfiles . list ( ) ) ; } try { linker . link ( ) ; } catch ( Exception ex ) { throw new BuildException ( ex , getLocation ( ) ) ; } } private boolean haveAddFiles ( ) { return haveEntries ( addfiles ) ; } private boolean haveMergeFiles ( ) { return haveEntries ( mergefiles ) ; } private boolean haveEntries ( Path p ) { if ( p == null ) { return false ; } if ( p . size ( ) > 0 ) { return true ; } return false ; } private File outfile = null ; private Path mergefiles = null ; private Path addfiles = null ; private boolean compress = false ; } 	0	['11', '4', '0', '6', '35', '9', '0', '6', '8', '0.7', '217', '1', '2', '0.886363636', '0.363636364', '2', '2', '18.36363636', '3', '1.4545', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; public interface XMLConstants { String TESTSUITES = "testsuites" ; String TESTSUITE = "testsuite" ; String TESTCASE = "testcase" ; String ERROR = "error" ; String FAILURE = "failure" ; String SYSTEM_ERR = "system-err" ; String SYSTEM_OUT = "system-out" ; String ATTR_PACKAGE = "package" ; String ATTR_NAME = "name" ; String ATTR_TIME = "time" ; String ATTR_ERRORS = "errors" ; String ATTR_FAILURES = "failures" ; String ATTR_TESTS = "tests" ; String ATTR_TYPE = "type" ; String ATTR_MESSAGE = "message" ; String PROPERTIES = "properties" ; String PROPERTY = "property" ; String ATTR_VALUE = "value" ; String ATTR_CLASSNAME = "classname" ; String ATTR_ID = "id" ; String TIMESTAMP = "timestamp" ; String HOSTNAME = "hostname" ; } 	0	['0', '1', '0', '2', '0', '0', '2', '0', '0', '2', '22', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . filters ; import java . io . StringReader ; import org . apache . tools . ant . util . ReaderInputStream ; public class StringInputStream extends ReaderInputStream { public StringInputStream ( String source ) { super ( new StringReader ( source ) ) ; } public StringInputStream ( String source , String encoding ) { super ( new StringReader ( source ) , encoding ) ; } } 	0	['2', '3', '0', '1', '5', '1', '0', '1', '2', '2', '17', '0', '0', '1', '1', '0', '0', '7.5', '0', '0', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Dirname extends Task { private File file ; private String property ; public void setFile ( File file ) { this . file = file ; } public void setProperty ( String property ) { this . property = property ; } public void execute ( ) throws BuildException { if ( property == null ) { throw new BuildException ( "property attribute required" , getLocation ( ) ) ; } if ( file == null ) { throw new BuildException ( "file attribute required" , getLocation ( ) ) ; } else { String value = file . getParent ( ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } 	0	['4', '3', '0', '4', '10', '2', '0', '4', '4', '0.666666667', '48', '1', '0', '0.925', '0.5', '0', '0', '10.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . File ; import java . util . Vector ; import java . util . ArrayList ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class P4Fstat extends P4Base { private int changelist ; private String addCmd = "" ; private Vector filesets = new Vector ( ) ; private static final int DEFAULT_CMD_LENGTH = 300 ; private int cmdLength = DEFAULT_CMD_LENGTH ; private static final int SHOW_ALL = 0 ; private static final int SHOW_EXISTING = 1 ; private static final int SHOW_NON_EXISTING = 2 ; private int show = SHOW_NON_EXISTING ; private FStatP4OutputHandler handler ; private StringBuffer filelist ; private int fileNum = 0 ; private int doneFileNum = 0 ; private boolean debug = false ; private static final String EXISTING_HEADER = "Following files exist in perforce" ; private static final String NONEXISTING_HEADER = "Following files do not exist in perforce" ; public void setShowFilter ( String filter ) { if ( filter . equalsIgnoreCase ( "all" ) ) { show = SHOW_ALL ; } else if ( filter . equalsIgnoreCase ( "existing" ) ) { show = SHOW_EXISTING ; } else if ( filter . equalsIgnoreCase ( "non-existing" ) ) { show = SHOW_NON_EXISTING ; } else { throw new BuildException ( "P4Fstat: ShowFilter should be one of: " + "all, existing, non-existing" ) ; } } public void setChangelist ( int changelist ) throws BuildException { if ( changelist <= 0 ) { throw new BuildException ( "P4FStat: Changelist# should be a " + "positive number" ) ; } this . changelist = changelist ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { handler = new FStatP4OutputHandler ( this ) ; if ( P4View != null ) { addCmd = P4View ; } P4CmdOpts = ( changelist > 0 ) ? ( "-c " + changelist ) : "" ; filelist = new StringBuffer ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; fileNum = srcFiles . length ; if ( srcFiles != null ) { for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File f = new File ( ds . getBasedir ( ) , srcFiles [ j ] ) ; filelist . append ( " " ) . append ( '"' ) . append ( f . getAbsolutePath ( ) ) . append ( '"' ) ; doneFileNum ++ ; if ( filelist . length ( ) > cmdLength ) { execP4Fstat ( filelist ) ; filelist = new StringBuffer ( ) ; } } if ( filelist . length ( ) > 0 ) { execP4Fstat ( filelist ) ; } } else { log ( "No files specified to query status on!" , Project . MSG_WARN ) ; } } if ( show == SHOW_ALL || show == SHOW_EXISTING ) { printRes ( handler . getExisting ( ) , EXISTING_HEADER ) ; } if ( show == SHOW_ALL || show == SHOW_NON_EXISTING ) { printRes ( handler . getNonExisting ( ) , NONEXISTING_HEADER ) ; } } public int getLengthOfTask ( ) { return fileNum ; } int getPasses ( ) { return filesets . size ( ) ; } private void printRes ( ArrayList ar , String header ) { log ( header , Project . MSG_INFO ) ; for ( int i = 0 ; i < ar . size ( ) ; i ++ ) { log ( ( String ) ar . get ( i ) , Project . MSG_INFO ) ; } } private void execP4Fstat ( StringBuffer list ) { String l = list . substring ( 0 ) ; if ( debug ) { log ( "Executing fstat " + P4CmdOpts + " " + addCmd + l + "\n" , Project . MSG_INFO ) ; } execP4Command ( "fstat " + P4CmdOpts + " " + addCmd + l , handler ) ; } } 	0	['9', '4', '0', '7', '37', '10', '1', '7', '6', '0.9296875', '323', '1', '1', '0.86440678', '0.277777778', '0', '0', '33.11111111', '4', '1.4444', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSCHECKOUT extends MSVSS { protected Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_CHECKOUT ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionDateLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getFileTimeStamp ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritableFiles ( ) ) ; commandLine . createArgument ( ) . setValue ( getGetLocalCopy ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setDate ( String date ) { super . setInternalDate ( date ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setFileTimeStamp ( CurrentModUpdated timestamp ) { super . setInternalFileTimeStamp ( timestamp ) ; } public void setWritableFiles ( WritableFiles files ) { super . setInternalWritableFiles ( files ) ; } public void setGetLocalCopy ( boolean get ) { super . setInternalGetLocalCopy ( get ) ; } } 	0	['11', '4', '0', '8', '38', '55', '0', '8', '10', '2', '122', '0', '0', '0.900990099', '0.303030303', '1', '1', '10.09090909', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . text . ParseException ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; class LibraryDisplayer { void displayLibrary ( final File file ) throws BuildException { final Manifest manifest = ExtensionUtil . getManifest ( file ) ; displayLibrary ( file , manifest ) ; } void displayLibrary ( final File file , final Manifest manifest ) throws BuildException { final Extension [ ] available = Extension . getAvailable ( manifest ) ; final Extension [ ] required = Extension . getRequired ( manifest ) ; final Extension [ ] options = Extension . getOptions ( manifest ) ; final Specification [ ] specifications = getSpecifications ( manifest ) ; if ( 0 == available . length && 0 == required . length && 0 == options . length && 0 == specifications . length ) { return ; } final String message = "File: " + file ; final int size = message . length ( ) ; printLine ( size ) ; System . out . println ( message ) ; printLine ( size ) ; if ( 0 != available . length ) { System . out . println ( "Extensions Supported By Library:" ) ; for ( int i = 0 ; i < available . length ; i ++ ) { final Extension extension = available [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != required . length ) { System . out . println ( "Extensions Required By Library:" ) ; for ( int i = 0 ; i < required . length ; i ++ ) { final Extension extension = required [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != options . length ) { System . out . println ( "Extensions that will be used by Library if present:" ) ; for ( int i = 0 ; i < options . length ; i ++ ) { final Extension extension = options [ i ] ; System . out . println ( extension . toString ( ) ) ; } } if ( 0 != specifications . length ) { System . out . println ( "Specifications Supported By Library:" ) ; for ( int i = 0 ; i < specifications . length ; i ++ ) { final Specification specification = specifications [ i ] ; displaySpecification ( specification ) ; } } } private void printLine ( final int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( "-" ) ; } System . out . println ( ) ; } private Specification [ ] getSpecifications ( final Manifest manifest ) throws BuildException { try { return Specification . getSpecifications ( manifest ) ; } catch ( final ParseException pe ) { throw new BuildException ( pe . getMessage ( ) , pe ) ; } } private void displaySpecification ( final Specification specification ) { final String [ ] sections = specification . getSections ( ) ; if ( null != sections ) { final StringBuffer sb = new StringBuffer ( "Sections: " ) ; for ( int i = 0 ; i < sections . length ; i ++ ) { sb . append ( " " ) ; sb . append ( sections [ i ] ) ; } System . out . println ( sb ) ; } System . out . println ( specification . toString ( ) ) ; } } 	0	['6', '1', '0', '5', '26', '15', '1', '4', '0', '2', '211', '0', '0', '0', '0.4', '0', '0', '34.16666667', '3', '1.3333', '0']
package org . apache . tools . ant . types ; import java . io . IOException ; import java . util . Map ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . resources . TarResource ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; public class TarScanner extends ArchiveScanner { protected void fillMapsFromArchive ( Resource src , String encoding , Map fileEntries , Map matchFileEntries , Map dirEntries , Map matchDirEntries ) { TarEntry entry = null ; TarInputStream ti = null ; try { try { ti = new TarInputStream ( src . getInputStream ( ) ) ; } catch ( IOException ex ) { throw new BuildException ( "problem opening " + srcFile , ex ) ; } while ( ( entry = ti . getNextEntry ( ) ) != null ) { Resource r = new TarResource ( src , entry ) ; String name = entry . getName ( ) ; if ( entry . isDirectory ( ) ) { name = trimSeparator ( name ) ; dirEntries . put ( name , r ) ; if ( match ( name ) ) { matchDirEntries . put ( name , r ) ; } } else { fileEntries . put ( name , r ) ; if ( match ( name ) ) { matchFileEntries . put ( name , r ) ; } } } } catch ( IOException ex ) { throw new BuildException ( "problem reading " + srcFile , ex ) ; } finally { if ( ti != null ) { try { ti . close ( ) ; } catch ( IOException ex ) { } } } } } 	0	['2', '3', '0', '7', '17', '1', '1', '6', '1', '2', '108', '0', '0', '0.987179487', '0.625', '1', '3', '53', '8', '4', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . io . File ; import java . io . BufferedReader ; import java . io . FileReader ; import org . apache . tools . ant . types . Parameter ; public final class ConcatFilter extends BaseParamFilterReader implements ChainableReader { private File prepend ; private File append ; private Reader prependReader = null ; private Reader appendReader = null ; public ConcatFilter ( ) { super ( ) ; } public ConcatFilter ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( prependReader != null ) { ch = prependReader . read ( ) ; if ( ch == - 1 ) { prependReader . close ( ) ; prependReader = null ; } } if ( ch == - 1 ) { ch = super . read ( ) ; } if ( ch == - 1 ) { if ( appendReader != null ) { ch = appendReader . read ( ) ; if ( ch == - 1 ) { appendReader . close ( ) ; appendReader = null ; } } } return ch ; } public void setPrepend ( final File prepend ) { this . prepend = prepend ; } public File getPrepend ( ) { return prepend ; } public void setAppend ( final File append ) { this . append = append ; } public File getAppend ( ) { return append ; } public Reader chain ( final Reader rdr ) { ConcatFilter newFilter = new ConcatFilter ( rdr ) ; newFilter . setPrepend ( getPrepend ( ) ) ; newFilter . setAppend ( getAppend ( ) ) ; return newFilter ; } private void initialize ( ) throws IOException { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( "prepend" . equals ( params [ i ] . getName ( ) ) ) { setPrepend ( new File ( params [ i ] . getValue ( ) ) ) ; continue ; } if ( "append" . equals ( params [ i ] . getName ( ) ) ) { setAppend ( new File ( params [ i ] . getValue ( ) ) ) ; continue ; } } } if ( prepend != null ) { if ( ! prepend . isAbsolute ( ) ) { prepend = new File ( getProject ( ) . getBaseDir ( ) , prepend . getPath ( ) ) ; } prependReader = new BufferedReader ( new FileReader ( prepend ) ) ; } if ( append != null ) { if ( ! append . isAbsolute ( ) ) { append = new File ( getProject ( ) . getBaseDir ( ) , append . getPath ( ) ) ; } appendReader = new BufferedReader ( new FileReader ( append ) ) ; } } } 	0	['9', '5', '0', '4', '28', '12', '0', '4', '8', '0.5', '217', '1', '0', '0.8', '0.481481481', '2', '5', '22.66666667', '1', '0.7778', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import java . util . Vector ; public class ImportTask extends Task { private String file ; private boolean optional ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public void setOptional ( boolean optional ) { this . optional = optional ; } public void setFile ( String file ) { this . file = file ; } public void execute ( ) { if ( file == null ) { throw new BuildException ( "import requires file attribute" ) ; } if ( getOwningTarget ( ) == null || ! "" . equals ( getOwningTarget ( ) . getName ( ) ) ) { throw new BuildException ( "import only allowed as a top-level task" ) ; } ProjectHelper helper = ( ProjectHelper ) getProject ( ) . getReference ( ProjectHelper . PROJECTHELPER_REFERENCE ) ; if ( helper == null ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } Vector importStack = helper . getImportStack ( ) ; if ( importStack . size ( ) == 0 ) { throw new BuildException ( "import requires support in ProjectHelper" ) ; } if ( getLocation ( ) == null || getLocation ( ) . getFileName ( ) == null ) { throw new BuildException ( "Unable to get location of import task" ) ; } File buildFile = new File ( getLocation ( ) . getFileName ( ) ) . getAbsoluteFile ( ) ; File buildFileParent = new File ( buildFile . getParent ( ) ) ; File importedFile = FILE_UTILS . resolveFile ( buildFileParent , file ) ; getProject ( ) . log ( "Importing file " + importedFile + " from " + buildFile . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( ! importedFile . exists ( ) ) { String message = "Cannot find " + file + " imported from " + buildFile . getAbsolutePath ( ) ; if ( optional ) { getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; return ; } else { throw new BuildException ( message ) ; } } if ( importStack . contains ( importedFile ) ) { getProject ( ) . log ( "Skipped already imported file:\n   " + importedFile + "\n" , Project . MSG_VERBOSE ) ; return ; } try { helper . parse ( getProject ( ) , importedFile ) ; } catch ( BuildException ex ) { throw ProjectHelper . addLocationToBuildException ( ex , getLocation ( ) ) ; } } } 	0	['5', '3', '0', '7', '31', '4', '0', '7', '4', '0.75', '178', '1', '1', '0.925', '0.5', '2', '2', '34', '11', '2.6', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Resolve extends P4Base { private String resolvemode = null ; private boolean redoall ; private boolean simulationmode ; private boolean forcetextmode ; private boolean markersforall ; private static final String AUTOMATIC = "automatic" ; private static final String FORCE = "force" ; private static final String SAFE = "safe" ; private static final String THEIRS = "theirs" ; private static final String YOURS = "yours" ; private static final String [ ] RESOLVE_MODES = { AUTOMATIC , FORCE , SAFE , THEIRS , YOURS } ; public String getResolvemode ( ) { return resolvemode ; } public void setResolvemode ( String resolvemode ) { boolean found = false ; for ( int counter = 0 ; counter < RESOLVE_MODES . length ; counter ++ ) { if ( resolvemode . equals ( RESOLVE_MODES [ counter ] ) ) { found = true ; break ; } } if ( ! found ) { throw new BuildException ( "Unacceptable value for resolve mode" ) ; } this . resolvemode = resolvemode ; } public boolean isRedoall ( ) { return redoall ; } public void setRedoall ( boolean redoall ) { this . redoall = redoall ; } public boolean isSimulationmode ( ) { return simulationmode ; } public void setSimulationmode ( boolean simulationmode ) { this . simulationmode = simulationmode ; } public boolean isForcetextmode ( ) { return forcetextmode ; } public void setForcetextmode ( boolean forcetextmode ) { this . forcetextmode = forcetextmode ; } public boolean isMarkersforall ( ) { return markersforall ; } public void setMarkersforall ( boolean markersforall ) { this . markersforall = markersforall ; } public void execute ( ) throws BuildException { if ( this . resolvemode . equals ( AUTOMATIC ) ) { P4CmdOpts = P4CmdOpts + " -am" ; } else if ( this . resolvemode . equals ( FORCE ) ) { P4CmdOpts = P4CmdOpts + " -af" ; } else if ( this . resolvemode . equals ( SAFE ) ) { P4CmdOpts = P4CmdOpts + " -as" ; } else if ( this . resolvemode . equals ( THEIRS ) ) { P4CmdOpts = P4CmdOpts + " -at" ; } else if ( this . resolvemode . equals ( YOURS ) ) { P4CmdOpts = P4CmdOpts + " -ay" ; } else { throw new BuildException ( "unsupported or absent resolve mode" ) ; } if ( P4View == null ) { throw new BuildException ( "please specify a view" ) ; } if ( this . isRedoall ( ) ) { P4CmdOpts = P4CmdOpts + " -f" ; } if ( this . isSimulationmode ( ) ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . isForcetextmode ( ) ) { P4CmdOpts = P4CmdOpts + " -t" ; } if ( this . isMarkersforall ( ) ) { P4CmdOpts = P4CmdOpts + " -v" ; } execP4Command ( "-s resolve " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['13', '4', '0', '4', '22', '56', '0', '4', '12', '0.946969697', '298', '1', '0', '0.822580645', '0.472222222', '2', '2', '21.07692308', '4', '1.0769', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . taskdefs . email . EmailTask ; public class SendEmail extends EmailTask { public void setMailport ( Integer value ) { setMailport ( value . intValue ( ) ) ; } } 	0	['2', '4', '0', '1', '5', '1', '0', '1', '2', '2', '10', '0', '0', '0.985507246', '0.75', '1', '1', '4', '1', '0.5', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . ProjectComponent ; public class StringTokenizer extends ProjectComponent implements Tokenizer { private String intraString = "" ; private int pushed = - 2 ; private char [ ] delims = null ; private boolean delimsAreTokens = false ; private boolean suppressDelims = false ; private boolean includeDelims = false ; public void setDelims ( String delims ) { this . delims = StringUtils . resolveBackSlash ( delims ) . toCharArray ( ) ; } public void setDelimsAreTokens ( boolean delimsAreTokens ) { this . delimsAreTokens = delimsAreTokens ; } public void setSuppressDelims ( boolean suppressDelims ) { this . suppressDelims = suppressDelims ; } public void setIncludeDelims ( boolean includeDelims ) { this . includeDelims = includeDelims ; } public String getToken ( Reader in ) throws IOException { int ch = - 1 ; if ( pushed != - 2 ) { ch = pushed ; pushed = - 2 ; } else { ch = in . read ( ) ; } if ( ch == - 1 ) { return null ; } boolean inToken = true ; intraString = "" ; StringBuffer word = new StringBuffer ( ) ; StringBuffer padding = new StringBuffer ( ) ; while ( ch != - 1 ) { char c = ( char ) ch ; boolean isDelim = isDelim ( c ) ; if ( inToken ) { if ( isDelim ) { if ( delimsAreTokens ) { if ( word . length ( ) == 0 ) { word . append ( c ) ; } else { pushed = ch ; } break ; } padding . append ( c ) ; inToken = false ; } else { word . append ( c ) ; } } else { if ( isDelim ) { padding . append ( c ) ; } else { pushed = ch ; break ; } } ch = in . read ( ) ; } intraString = padding . toString ( ) ; if ( includeDelims ) { word . append ( intraString ) ; } return word . toString ( ) ; } public String getPostToken ( ) { return suppressDelims || includeDelims ? "" : intraString ; } private boolean isDelim ( char ch ) { if ( delims == null ) { return Character . isWhitespace ( ch ) ; } for ( int i = 0 ; i < delims . length ; ++ i ) { if ( delims [ i ] == ch ) { return true ; } } return false ; } } 	0	['8', '2', '1', '4', '18', '2', '1', '3', '7', '0.69047619', '194', '1', '0', '0.5625', '0.35', '0', '0', '22.5', '4', '1.5', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . input . DefaultInputHandler ; import org . apache . tools . ant . input . GreedyInputHandler ; import org . apache . tools . ant . input . InputHandler ; import org . apache . tools . ant . input . InputRequest ; import org . apache . tools . ant . input . MultipleChoiceInputRequest ; import org . apache . tools . ant . input . PropertyFileInputHandler ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . StringUtils ; public class Input extends Task { public class Handler extends DefBase { private String refid = null ; private HandlerType type = null ; private String classname = null ; public void setRefid ( String refid ) { this . refid = refid ; } public String getRefid ( ) { return refid ; } public void setClassname ( String classname ) { this . classname = classname ; } public String getClassname ( ) { return classname ; } public void setType ( HandlerType type ) { this . type = type ; } public HandlerType getType ( ) { return type ; } private InputHandler getInputHandler ( ) { if ( type != null ) { return type . getInputHandler ( ) ; } if ( refid != null ) { try { return ( InputHandler ) ( getProject ( ) . getReference ( refid ) ) ; } catch ( ClassCastException e ) { throw new BuildException ( refid + " does not denote an InputHandler" , e ) ; } } if ( classname != null ) { return ( InputHandler ) ( ClasspathUtils . newInstance ( classname , createLoader ( ) , InputHandler . class ) ) ; } throw new BuildException ( "Must specify refid, classname or type" ) ; } } public static class HandlerType extends EnumeratedAttribute { private static final String [ ] VALUES = { "default" , "propertyfile" , "greedy" } ; private static final InputHandler [ ] HANDLERS = { new DefaultInputHandler ( ) , new PropertyFileInputHandler ( ) , new GreedyInputHandler ( ) } ; public String [ ] getValues ( ) { return VALUES ; } private InputHandler getInputHandler ( ) { return HANDLERS [ getIndex ( ) ] ; } } private String validargs = null ; private String message = "" ; private String addproperty = null ; private String defaultvalue = null ; private Handler handler = null ; private boolean messageAttribute ; public void setValidargs ( String validargs ) { this . validargs = validargs ; } public void setAddproperty ( String addproperty ) { this . addproperty = addproperty ; } public void setMessage ( String message ) { this . message = message ; messageAttribute = true ; } public void setDefaultvalue ( String defaultvalue ) { this . defaultvalue = defaultvalue ; } public void addText ( String msg ) { if ( messageAttribute && "" . equals ( msg . trim ( ) ) ) { return ; } message += getProject ( ) . replaceProperties ( msg ) ; } public Input ( ) { } public void execute ( ) throws BuildException { if ( addproperty != null && getProject ( ) . getProperty ( addproperty ) != null ) { log ( "skipping " + getTaskName ( ) + " as property " + addproperty + " has already been set." ) ; return ; } InputRequest request = null ; if ( validargs != null ) { Vector accept = StringUtils . split ( validargs , ',' ) ; request = new MultipleChoiceInputRequest ( message , accept ) ; } else { request = new InputRequest ( message ) ; } request . setDefaultValue ( defaultvalue ) ; InputHandler h = handler == null ? getProject ( ) . getInputHandler ( ) : handler . getInputHandler ( ) ; h . handleInput ( request ) ; String value = request . getInput ( ) ; if ( ( value == null || value . trim ( ) . length ( ) == 0 ) && defaultvalue != null ) { value = defaultvalue ; } if ( addproperty != null && value != null ) { getProject ( ) . setNewProperty ( addproperty , value ) ; } } public Handler createHandler ( ) { if ( handler != null ) { throw new BuildException ( "Cannot define > 1 nested input handler" ) ; } handler = new Handler ( ) ; return handler ; } } 	0	['8', '3', '0', '8', '32', '0', '1', '8', '8', '0.775510204', '190', '0.857142857', '1', '0.840909091', '0.8125', '1', '1', '21.875', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . FileUtils ; public abstract class SOS extends Task implements SOSCmd { private String sosCmdDir = null ; private String sosUsername = null ; private String sosPassword = "" ; private String projectPath = null ; private String vssServerPath = null ; private String sosServerPath = null ; private String sosHome = null ; private String localPath = null ; private String version = null ; private String label = null ; private String comment = null ; private String filename = null ; private boolean noCompress = false ; private boolean noCache = false ; private boolean recursive = false ; private boolean verbose = false ; protected Commandline commandLine ; public final void setNoCache ( boolean nocache ) { noCache = nocache ; } public final void setNoCompress ( boolean nocompress ) { noCompress = nocompress ; } public final void setSosCmd ( String dir ) { sosCmdDir = FileUtils . translatePath ( dir ) ; } public final void setUsername ( String username ) { sosUsername = username ; } public final void setPassword ( String password ) { sosPassword = password ; } public final void setProjectPath ( String projectpath ) { if ( projectpath . startsWith ( SOSCmd . PROJECT_PREFIX ) ) { projectPath = projectpath ; } else { projectPath = SOSCmd . PROJECT_PREFIX + projectpath ; } } public final void setVssServerPath ( String vssServerPath ) { this . vssServerPath = vssServerPath ; } public final void setSosHome ( String sosHome ) { this . sosHome = sosHome ; } public final void setSosServerPath ( String sosServerPath ) { this . sosServerPath = sosServerPath ; } public final void setLocalPath ( Path path ) { localPath = path . toString ( ) ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } protected void setInternalFilename ( String file ) { filename = file ; } protected void setInternalRecursive ( boolean recurse ) { recursive = recurse ; } protected void setInternalComment ( String text ) { comment = text ; } protected void setInternalLabel ( String text ) { label = text ; } protected void setInternalVersion ( String text ) { version = text ; } protected String getSosCommand ( ) { if ( sosCmdDir == null ) { return COMMAND_SOS_EXE ; } else { return sosCmdDir + File . separator + COMMAND_SOS_EXE ; } } protected String getComment ( ) { return comment ; } protected String getVersion ( ) { return version ; } protected String getLabel ( ) { return label ; } protected String getUsername ( ) { return sosUsername ; } protected String getPassword ( ) { return sosPassword ; } protected String getProjectPath ( ) { return projectPath ; } protected String getVssServerPath ( ) { return vssServerPath ; } protected String getSosHome ( ) { return sosHome ; } protected String getSosServerPath ( ) { return sosServerPath ; } protected String getFilename ( ) { return filename ; } protected String getNoCompress ( ) { return noCompress ? FLAG_NO_COMPRESSION : "" ; } protected String getNoCache ( ) { return noCache ? FLAG_NO_CACHE : "" ; } protected String getVerbose ( ) { return verbose ? FLAG_VERBOSE : "" ; } protected String getRecursive ( ) { return recursive ? FLAG_RECURSION : "" ; } protected String getLocalPath ( ) { if ( localPath == null ) { return getProject ( ) . getBaseDir ( ) . getAbsolutePath ( ) ; } else { File dir = getProject ( ) . resolveFile ( localPath ) ; if ( ! dir . exists ( ) ) { boolean done = dir . mkdirs ( ) ; if ( ! done ) { String msg = "Directory " + localPath + " creation was not " + "successful for an unknown reason" ; throw new BuildException ( msg , getLocation ( ) ) ; } getProject ( ) . log ( "Created dir: " + dir . getAbsolutePath ( ) ) ; } return dir . getAbsolutePath ( ) ; } } abstract Commandline buildCmdLine ( ) ; public void execute ( ) throws BuildException { int result = 0 ; buildCmdLine ( ) ; result = run ( commandLine ) ; if ( result == 255 ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } protected int run ( Commandline cmd ) { try { Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; exe . setAntRun ( getProject ( ) ) ; exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; exe . setVMLauncher ( false ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } protected void getRequiredAttributes ( ) { commandLine . setExecutable ( getSosCommand ( ) ) ; if ( getSosServerPath ( ) == null ) { throw new BuildException ( "sosserverpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_SOS_SERVER ) ; commandLine . createArgument ( ) . setValue ( getSosServerPath ( ) ) ; if ( getUsername ( ) == null ) { throw new BuildException ( "username attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_USERNAME ) ; commandLine . createArgument ( ) . setValue ( getUsername ( ) ) ; commandLine . createArgument ( ) . setValue ( FLAG_PASSWORD ) ; commandLine . createArgument ( ) . setValue ( getPassword ( ) ) ; if ( getVssServerPath ( ) == null ) { throw new BuildException ( "vssserverpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_VSS_SERVER ) ; commandLine . createArgument ( ) . setValue ( getVssServerPath ( ) ) ; if ( getProjectPath ( ) == null ) { throw new BuildException ( "projectpath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( FLAG_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getProjectPath ( ) ) ; } protected void getOptionalAttributes ( ) { commandLine . createArgument ( ) . setValue ( getVerbose ( ) ) ; commandLine . createArgument ( ) . setValue ( getNoCompress ( ) ) ; if ( getSosHome ( ) == null ) { commandLine . createArgument ( ) . setValue ( getNoCache ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( FLAG_SOS_HOME ) ; commandLine . createArgument ( ) . setValue ( getSosHome ( ) ) ; } if ( getLocalPath ( ) != null ) { commandLine . createArgument ( ) . setValue ( FLAG_WORKING_DIR ) ; commandLine . createArgument ( ) . setValue ( getLocalPath ( ) ) ; } } } 	0	['38', '3', '4', '16', '68', '601', '4', '12', '13', '0.92845787', '534', '1', '1', '0.5', '0.289473684', '0', '0', '12.60526316', '5', '1.3684', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class DotnetDefine { private String name ; private String ifCond ; private String unlessCond ; public void setIf ( String condition ) { this . ifCond = condition ; } public void setUnless ( String condition ) { this . unlessCond = condition ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getValue ( Task owner ) throws BuildException { if ( name == null ) { throw new BuildException ( "No name provided for the define element" , owner . getLocation ( ) ) ; } if ( ! isSet ( owner ) ) { return null ; } return name ; } public boolean isSet ( Task owner ) { Project p = owner . getProject ( ) ; if ( ifCond != null && p . getProperty ( ifCond ) == null ) { return false ; } else if ( unlessCond != null && p . getProperty ( unlessCond ) != null ) { return false ; } return true ; } } 	0	['7', '1', '0', '5', '12', '11', '1', '4', '7', '0.666666667', '72', '1', '0', '0', '0.571428571', '0', '0', '8.857142857', '5', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . util . Date ; public class CCMCheckin extends CCMCheck { public CCMCheckin ( ) { super ( ) ; setCcmAction ( COMMAND_CHECKIN ) ; setComment ( "Checkin " + new Date ( ) ) ; } } 	0	['1', '5', '0', '1', '8', '0', '0', '1', '1', '2', '18', '0', '0', '1', '1', '0', '0', '17', '0', '0', '0']
package org . apache . tools . ant ; public interface SubBuildListener extends BuildListener { void subBuildStarted ( BuildEvent event ) ; void subBuildFinished ( BuildEvent event ) ; } 	0	['2', '1', '0', '6', '2', '1', '4', '2', '2', '2', '2', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . zip . GZIPInputStream ; import java . util . zip . GZIPOutputStream ; public class GZipResource extends CompressedResource { public GZipResource ( ) { } public GZipResource ( org . apache . tools . ant . types . ResourceCollection other ) { super ( other ) ; } protected InputStream wrapStream ( InputStream in ) throws IOException { return new GZIPInputStream ( in ) ; } protected OutputStream wrapStream ( OutputStream out ) throws IOException { return new GZIPOutputStream ( out ) ; } protected String getCompressionName ( ) { return "GZip" ; } } 	0	['5', '5', '0', '2', '9', '10', '0', '2', '2', '2', '24', '0', '0', '0.961538462', '0.4', '1', '2', '3.8', '1', '0.6', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . util . regexp . Regexp ; public final class LineContainsRegExp extends BaseParamFilterReader implements ChainableReader { private static final String REGEXP_KEY = "regexp" ; private static final String NEGATE_KEY = "negate" ; private Vector regexps = new Vector ( ) ; private String line = null ; private boolean negate = false ; public LineContainsRegExp ( ) { super ( ) ; } public LineContainsRegExp ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( line != null ) { ch = line . charAt ( 0 ) ; if ( line . length ( ) == 1 ) { line = null ; } else { line = line . substring ( 1 ) ; } } else { final int regexpsSize = regexps . size ( ) ; for ( line = readLine ( ) ; line != null ; line = readLine ( ) ) { boolean matches = true ; for ( int i = 0 ; matches && i < regexpsSize ; i ++ ) { RegularExpression regexp = ( RegularExpression ) regexps . elementAt ( i ) ; Regexp re = regexp . getRegexp ( getProject ( ) ) ; matches = re . matches ( line ) ; } if ( matches ^ isNegated ( ) ) { break ; } } if ( line != null ) { return read ( ) ; } } return ch ; } public void addConfiguredRegexp ( final RegularExpression regExp ) { this . regexps . addElement ( regExp ) ; } private void setRegexps ( final Vector regexps ) { this . regexps = regexps ; } private Vector getRegexps ( ) { return regexps ; } public Reader chain ( final Reader rdr ) { LineContainsRegExp newFilter = new LineContainsRegExp ( rdr ) ; newFilter . setRegexps ( getRegexps ( ) ) ; newFilter . setNegate ( isNegated ( ) ) ; return newFilter ; } public void setNegate ( boolean b ) { negate = b ; } public boolean isNegated ( ) { return negate ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( REGEXP_KEY . equals ( params [ i ] . getType ( ) ) ) { String pattern = params [ i ] . getValue ( ) ; RegularExpression regexp = new RegularExpression ( ) ; regexp . setPattern ( pattern ) ; regexps . addElement ( regexp ) ; } else if ( NEGATE_KEY . equals ( params [ i ] . getType ( ) ) ) { setNegate ( Project . toBoolean ( params [ i ] . getValue ( ) ) ) ; } } } } } 	0	['10', '5', '0', '7', '32', '0', '1', '6', '7', '0.688888889', '221', '1', '0', '0.777777778', '0.3', '2', '5', '20.6', '5', '1.2', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class FileSet extends AbstractFileSet implements ResourceCollection { public FileSet ( ) { super ( ) ; } protected FileSet ( FileSet fileset ) { super ( fileset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( getDir ( getProject ( ) ) , getDirectoryScanner ( getProject ( ) ) . getIncludedFiles ( ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( FileSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( getProject ( ) ) . getIncludedFilesCount ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } 	0	['6', '4', '5', '64', '17', '15', '59', '5', '5', '2', '67', '0', '0', '0.956043956', '0.583333333', '3', '4', '10.16666667', '2', '1.1667', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . ResourceUtils ; public class ResourcesMatch implements Condition { private Union resources = null ; private boolean asText = false ; public void setAsText ( boolean asText ) { this . asText = asText ; } public void add ( ResourceCollection rc ) { if ( rc == null ) { return ; } resources = resources == null ? new Union ( ) : resources ; resources . add ( rc ) ; } public boolean eval ( ) throws BuildException { if ( resources == null ) { throw new BuildException ( "You must specify one or more nested resource collections" ) ; } if ( resources . size ( ) > 1 ) { Iterator i = resources . iterator ( ) ; Resource r1 = ( Resource ) i . next ( ) ; Resource r2 = null ; while ( i . hasNext ( ) ) { r2 = ( Resource ) i . next ( ) ; try { if ( ! ResourceUtils . contentEquals ( r1 , r2 , asText ) ) { return false ; } } catch ( IOException ioe ) { throw new BuildException ( "when comparing resources " + r1 . toString ( ) + " and " + r2 . toString ( ) , ioe ) ; } r1 = r2 ; } } return true ; } } 	0	['4', '1', '0', '6', '18', '0', '0', '6', '4', '0.333333333', '100', '1', '1', '0', '0.5', '0', '0', '23.5', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . condition . Condition ; import org . apache . tools . ant . taskdefs . condition . ConditionBase ; public class ConditionTask extends ConditionBase { private String property = null ; private String value = "true" ; private String alternative = null ; public ConditionTask ( ) { super ( "condition" ) ; } public void setProperty ( String p ) { property = p ; } public void setValue ( String v ) { value = v ; } public void setElse ( String e ) { alternative = e ; } public void execute ( ) throws BuildException { if ( countConditions ( ) > 1 ) { throw new BuildException ( "You must not nest more than one " + "condition into <" + getTaskName ( ) + ">" ) ; } if ( countConditions ( ) < 1 ) { throw new BuildException ( "You must nest a condition into <" + getTaskName ( ) + ">" ) ; } if ( property == null ) { throw new BuildException ( "The property attribute is required." ) ; } Condition c = ( Condition ) getConditions ( ) . nextElement ( ) ; if ( c . eval ( ) ) { log ( "Condition true; setting " + property + " to " + value , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , value ) ; } else if ( alternative != null ) { log ( "Condition false; setting " + property + " to " + alternative , Project . MSG_DEBUG ) ; getProject ( ) . setNewProperty ( property , alternative ) ; } else { log ( "Condition false; not setting " + property , Project . MSG_DEBUG ) ; } } } 	0	['5', '3', '0', '4', '18', '0', '0', '4', '5', '0.5', '148', '1', '0', '0.888888889', '0.8', '0', '0', '28', '1', '0.8', '0']
package org . apache . tools . ant . util . depend ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import org . apache . tools . ant . types . Path ; public interface DependencyAnalyzer { void addSourcePath ( Path sourcePath ) ; void addClassPath ( Path classpath ) ; void addRootClass ( String classname ) ; Enumeration getFileDependencies ( ) ; Enumeration getClassDependencies ( ) ; void reset ( ) ; void config ( String name , Object info ) ; void setClosure ( boolean closure ) ; File getClassContainer ( String classname ) throws IOException ; File getSourceContainer ( String classname ) throws IOException ; } 	0	['10', '1', '0', '5', '10', '45', '4', '1', '10', '2', '10', '0', '0', '0', '0.36', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSCheckout extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKOUT_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKOUT_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; return commandLine ; } } 	0	['4', '4', '0', '3', '14', '6', '0', '3', '3', '2', '68', '0', '0', '0.961038961', '0.5', '1', '2', '16', '2', '1', '0']
package org . apache . tools . ant . types . optional ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Condition ; public class ScriptCondition extends AbstractScriptComponent implements Condition { private boolean value = false ; public boolean eval ( ) throws BuildException { initScriptRunner ( ) ; executeScript ( "ant_condition" ) ; return getValue ( ) ; } public boolean getValue ( ) { return value ; } public void setValue ( boolean value ) { this . value = value ; } } 	0	['4', '3', '0', '3', '7', '0', '0', '3', '4', '0', '26', '1', '0', '0.869565217', '0.625', '0', '0', '5.25', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . ProjectComponent ; public class FileTokenizer extends ProjectComponent implements Tokenizer { public String getToken ( Reader in ) throws IOException { return FileUtils . readFully ( in ) ; } public String getPostToken ( ) { return "" ; } } 	0	['3', '2', '1', '4', '5', '3', '1', '3', '3', '2', '11', '0', '0', '0.818181818', '0.666666667', '0', '0', '2.666666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Copyfile extends Task { private File srcFile ; private File destFile ; private boolean filtering = false ; private boolean forceOverwrite = false ; public void setSrc ( File src ) { srcFile = src ; } public void setForceoverwrite ( boolean force ) { forceOverwrite = force ; } public void setDest ( File dest ) { destFile = dest ; } public void setFiltering ( String filter ) { filtering = Project . toBoolean ( filter ) ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The copyfile task is deprecated.  Use copy instead." ) ; if ( srcFile == null ) { throw new BuildException ( "The src attribute must be present." , getLocation ( ) ) ; } if ( ! srcFile . exists ( ) ) { throw new BuildException ( "src " + srcFile . toString ( ) + " does not exist." , getLocation ( ) ) ; } if ( destFile == null ) { throw new BuildException ( "The dest attribute must be present." , getLocation ( ) ) ; } if ( srcFile . equals ( destFile ) ) { log ( "Warning: src == dest" , Project . MSG_WARN ) ; } if ( forceOverwrite || srcFile . lastModified ( ) > destFile . lastModified ( ) ) { try { getProject ( ) . copyFile ( srcFile , destFile , filtering , forceOverwrite ) ; } catch ( IOException ioe ) { String msg = "Error copying file: " + srcFile . getAbsolutePath ( ) + " due to " + ioe . getMessage ( ) ; throw new BuildException ( msg ) ; } } } } 	0	['6', '3', '0', '4', '24', '1', '0', '4', '6', '0.7', '135', '1', '0', '0.880952381', '0.416666667', '3', '3', '20.83333333', '1', '0.8333', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; import org . apache . tools . ant . dispatch . Dispatchable ; import org . apache . tools . ant . dispatch . DispatchUtils ; public class TaskAdapter extends Task implements TypeAdapter { private Object proxy ; public static void checkTaskClass ( final Class taskClass , final Project project ) { if ( ! Dispatchable . class . isAssignableFrom ( taskClass ) ) { try { final Method executeM = taskClass . getMethod ( "execute" , ( Class [ ] ) null ) ; if ( ! Void . TYPE . equals ( executeM . getReturnType ( ) ) ) { final String message = "return type of execute() should be " + "void but was \"" + executeM . getReturnType ( ) + "\" in " + taskClass ; project . log ( message , Project . MSG_WARN ) ; } } catch ( NoSuchMethodException e ) { final String message = "No public execute() in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } catch ( LinkageError e ) { String message = "Could not load " + taskClass + ": " + e ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message , e ) ; } } } public void checkProxyClass ( Class proxyClass ) { checkTaskClass ( proxyClass , getProject ( ) ) ; } public void execute ( ) throws BuildException { try { Method setLocationM = proxy . getClass ( ) . getMethod ( "setLocation" , new Class [ ] { Location . class } ) ; if ( setLocationM != null ) { setLocationM . invoke ( proxy , new Object [ ] { getLocation ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting location in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } try { Method setProjectM = proxy . getClass ( ) . getMethod ( "setProject" , new Class [ ] { Project . class } ) ; if ( setProjectM != null ) { setProjectM . invoke ( proxy , new Object [ ] { getProject ( ) } ) ; } } catch ( NoSuchMethodException e ) { } catch ( Exception ex ) { log ( "Error setting project in " + proxy . getClass ( ) , Project . MSG_ERR ) ; throw new BuildException ( ex ) ; } try { DispatchUtils . execute ( proxy ) ; } catch ( BuildException be ) { throw be ; } catch ( Exception ex ) { log ( "Error in " + proxy . getClass ( ) , Project . MSG_VERBOSE ) ; throw new BuildException ( ex ) ; } } public void setProxy ( Object o ) { this . proxy = o ; } public Object getProxy ( ) { return proxy ; } } 	0	['6', '3', '0', '7', '28', '9', '2', '6', '6', '0.85', '261', '0.25', '0', '0.880952381', '0.375', '1', '1', '41.83333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FileWriter ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . UnsupportedEncodingException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . IntrospectionHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Reference ; public class AntStructure extends Task { private static final String LINE_SEP = System . getProperty ( "line.separator" ) ; private File output ; private StructurePrinter printer = new DTDPrinter ( ) ; public void setOutput ( File output ) { this . output = output ; } public void add ( StructurePrinter p ) { printer = p ; } public void execute ( ) throws BuildException { if ( output == null ) { throw new BuildException ( "output attribute is required" , getLocation ( ) ) ; } PrintWriter out = null ; try { try { out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( output ) , "UTF8" ) ) ; } catch ( UnsupportedEncodingException ue ) { out = new PrintWriter ( new FileWriter ( output ) ) ; } printer . printHead ( out , getProject ( ) , getProject ( ) . getTaskDefinitions ( ) , getProject ( ) . getDataTypeDefinitions ( ) ) ; printer . printTargetDecl ( out ) ; Enumeration dataTypes = getProject ( ) . getDataTypeDefinitions ( ) . keys ( ) ; while ( dataTypes . hasMoreElements ( ) ) { String typeName = ( String ) dataTypes . nextElement ( ) ; printer . printElementDecl ( out , getProject ( ) , typeName , ( Class ) getProject ( ) . getDataTypeDefinitions ( ) . get ( typeName ) ) ; } Enumeration tasks = getProject ( ) . getTaskDefinitions ( ) . keys ( ) ; while ( tasks . hasMoreElements ( ) ) { String tName = ( String ) tasks . nextElement ( ) ; printer . printElementDecl ( out , getProject ( ) , tName , ( Class ) getProject ( ) . getTaskDefinitions ( ) . get ( tName ) ) ; } printer . printTail ( out ) ; } catch ( IOException ioe ) { throw new BuildException ( "Error writing " + output . getAbsolutePath ( ) , ioe , getLocation ( ) ) ; } finally { if ( out != null ) { out . close ( ) ; } } } public static interface StructurePrinter { void printHead ( PrintWriter out , Project p , Hashtable tasks , Hashtable types ) ; void printTargetDecl ( PrintWriter out ) ; void printElementDecl ( PrintWriter out , Project p , String name , Class element ) ; void printTail ( PrintWriter out ) ; } private static class DTDPrinter implements StructurePrinter { private static final String BOOLEAN = "%boolean;" ; private static final String TASKS = "%tasks;" ; private static final String TYPES = "%types;" ; private Hashtable visited = new Hashtable ( ) ; public void printTail ( PrintWriter out ) { visited . clear ( ) ; } public void printHead ( PrintWriter out , Project p , Hashtable tasks , Hashtable types ) { printHead ( out , tasks . keys ( ) , types . keys ( ) ) ; } private void printHead ( PrintWriter out , Enumeration tasks , Enumeration types ) { out . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>" ) ; out . println ( "<!ENTITY % boolean \"(true|false|on|off|yes|no)\">" ) ; out . print ( "<!ENTITY % tasks \"" ) ; boolean first = true ; while ( tasks . hasMoreElements ( ) ) { String tName = ( String ) tasks . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( tName ) ; } out . println ( "\">" ) ; out . print ( "<!ENTITY % types \"" ) ; first = true ; while ( types . hasMoreElements ( ) ) { String typeName = ( String ) types . nextElement ( ) ; if ( ! first ) { out . print ( " | " ) ; } else { first = false ; } out . print ( typeName ) ; } out . println ( "\">" ) ; out . println ( "" ) ; out . print ( "<!ELEMENT project (target | " ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "<!ATTLIST project" ) ; out . println ( "          name    CDATA #IMPLIED" ) ; out . println ( "          default CDATA #IMPLIED" ) ; out . println ( "          basedir CDATA #IMPLIED>" ) ; out . println ( "" ) ; } public void printTargetDecl ( PrintWriter out ) { out . print ( "<!ELEMENT target (" ) ; out . print ( TASKS ) ; out . print ( " | " ) ; out . print ( TYPES ) ; out . println ( ")*>" ) ; out . println ( "" ) ; out . println ( "<!ATTLIST target" ) ; out . println ( "          id          ID    #IMPLIED" ) ; out . println ( "          name        CDATA #REQUIRED" ) ; out . println ( "          if          CDATA #IMPLIED" ) ; out . println ( "          unless      CDATA #IMPLIED" ) ; out . println ( "          depends     CDATA #IMPLIED" ) ; out . println ( "          description CDATA #IMPLIED>" ) ; out . println ( "" ) ; } public void printElementDecl ( PrintWriter out , Project p , String name , Class element ) { if ( visited . containsKey ( name ) ) { return ; } visited . put ( name , "" ) ; IntrospectionHelper ih = null ; try { ih = IntrospectionHelper . getHelper ( p , element ) ; } catch ( Throwable t ) { return ; } StringBuffer sb = new StringBuffer ( "<!ELEMENT " ) ; sb . append ( name ) . append ( " " ) ; if ( org . apache . tools . ant . types . Reference . class . equals ( element ) ) { sb . append ( "EMPTY>" ) . append ( LINE_SEP ) ; sb . append ( "<!ATTLIST " ) . append ( name ) ; sb . append ( LINE_SEP ) . append ( "          id ID #IMPLIED" ) ; sb . append ( LINE_SEP ) . append ( "          refid IDREF #IMPLIED" ) ; sb . append ( ">" ) . append ( LINE_SEP ) ; out . println ( sb ) ; return ; } Vector v = new Vector ( ) ; if ( ih . supportsCharacters ( ) ) { v . addElement ( "#PCDATA" ) ; } if ( TaskContainer . class . isAssignableFrom ( element ) ) { v . addElement ( TASKS ) ; } Enumeration e = ih . getNestedElements ( ) ; while ( e . hasMoreElements ( ) ) { v . addElement ( e . nextElement ( ) ) ; } if ( v . isEmpty ( ) ) { sb . append ( "EMPTY" ) ; } else { sb . append ( "(" ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( v . elementAt ( i ) ) ; } sb . append ( ")" ) ; if ( count > 1 || ! v . elementAt ( 0 ) . equals ( "#PCDATA" ) ) { sb . append ( "*" ) ; } } sb . append ( ">" ) ; out . println ( sb ) ; sb = new StringBuffer ( "<!ATTLIST " ) ; sb . append ( name ) ; sb . append ( LINE_SEP ) . append ( "          id ID #IMPLIED" ) ; e = ih . getAttributes ( ) ; while ( e . hasMoreElements ( ) ) { String attrName = ( String ) e . nextElement ( ) ; if ( "id" . equals ( attrName ) ) { continue ; } sb . append ( LINE_SEP ) . append ( "          " ) . append ( attrName ) . append ( " " ) ; Class type = ih . getAttributeType ( attrName ) ; if ( type . equals ( java . lang . Boolean . class ) || type . equals ( java . lang . Boolean . TYPE ) ) { sb . append ( BOOLEAN ) . append ( " " ) ; } else if ( Reference . class . isAssignableFrom ( type ) ) { sb . append ( "IDREF " ) ; } else if ( EnumeratedAttribute . class . isAssignableFrom ( type ) ) { try { EnumeratedAttribute ea = ( EnumeratedAttribute ) type . newInstance ( ) ; String [ ] values = ea . getValues ( ) ; if ( values == null || values . length == 0 || ! areNmtokens ( values ) ) { sb . append ( "CDATA " ) ; } else { sb . append ( "(" ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( values [ i ] ) ; } sb . append ( ") " ) ; } } catch ( InstantiationException ie ) { sb . append ( "CDATA " ) ; } catch ( IllegalAccessException ie ) { sb . append ( "CDATA " ) ; } } else if ( type . getSuperclass ( ) != null && type . getSuperclass ( ) . getName ( ) . equals ( "java.lang.Enum" ) ) { try { Object [ ] values = ( Object [ ] ) type . getMethod ( "values" , ( Class [ ] ) null ) . invoke ( null , ( Object [ ] ) null ) ; if ( values . length == 0 ) { sb . append ( "CDATA " ) ; } else { sb . append ( '(' ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( " | " ) ; } sb . append ( type . getMethod ( "name" , ( Class [ ] ) null ) . invoke ( values [ i ] , ( Object [ ] ) null ) ) ; } sb . append ( ") " ) ; } } catch ( Exception x ) { sb . append ( "CDATA " ) ; } } else { sb . append ( "CDATA " ) ; } sb . append ( "#IMPLIED" ) ; } sb . append ( ">" ) . append ( LINE_SEP ) ; out . println ( sb ) ; final int count = v . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String nestedName = ( String ) v . elementAt ( i ) ; if ( ! "#PCDATA" . equals ( nestedName ) && ! TASKS . equals ( nestedName ) && ! TYPES . equals ( nestedName ) ) { printElementDecl ( out , p , nestedName , ih . getElementType ( nestedName ) ) ; } } } public static final boolean isNmtoken ( String s ) { final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = s . charAt ( i ) ; if ( ! Character . isLetterOrDigit ( c ) && c != '.' && c != '-' && c != '_' && c != ':' ) { return false ; } } return true ; } public static final boolean areNmtokens ( String [ ] s ) { for ( int i = 0 ; i < s . length ; i ++ ) { if ( ! isNmtoken ( s [ i ] ) ) { return false ; } } return true ; } } protected boolean isNmtoken ( String s ) { return DTDPrinter . isNmtoken ( s ) ; } protected boolean areNmtokens ( String [ ] s ) { return DTDPrinter . areNmtokens ( s ) ; } } 	0	['8', '3', '0', '6', '36', '18', '1', '6', '4', '1', '182', '0.428571429', '1', '0.860465116', '0.285714286', '0', '0', '20.875', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import java . util . Date ; import java . util . Vector ; public class CVSEntry { private Date date ; private String author ; private final String comment ; private final Vector files = new Vector ( ) ; public CVSEntry ( final Date date , final String author , final String comment ) { this . date = date ; this . author = author ; this . comment = comment ; } public void addFile ( final String file , final String revision ) { files . addElement ( new RCSFile ( file , revision ) ) ; } public void addFile ( final String file , final String revision , final String previousRevision ) { files . addElement ( new RCSFile ( file , revision , previousRevision ) ) ; } public Date getDate ( ) { return date ; } public void setAuthor ( final String author ) { this . author = author ; } public String getAuthor ( ) { return author ; } public String getComment ( ) { return comment ; } public Vector getFiles ( ) { return files ; } public String toString ( ) { return getAuthor ( ) + "\n" + getDate ( ) + "\n" + getFiles ( ) + "\n" + getComment ( ) ; } } 	0	['9', '1', '0', '4', '19', '14', '3', '1', '9', '0.65625', '88', '1', '0', '0', '0.518518519', '0', '0', '8.333333333', '1', '0.8889', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . types . Resource ; public class InstanceOf implements ResourceSelector { private static final String ONE_ONLY = "Exactly one of class|type must be set." ; private Project project ; private Class clazz ; private String type ; private String uri ; public void setProject ( Project p ) { project = p ; } public void setClass ( Class c ) { if ( clazz != null ) { throw new BuildException ( "The class attribute has already been set." ) ; } clazz = c ; } public void setType ( String s ) { type = s ; } public void setURI ( String u ) { uri = u ; } public Class getCheckClass ( ) { return clazz ; } public String getType ( ) { return type ; } public String getURI ( ) { return uri ; } public boolean isSelected ( Resource r ) { if ( ( clazz == null ) == ( type == null ) ) { throw new BuildException ( ONE_ONLY ) ; } Class c = clazz ; if ( type != null ) { if ( project == null ) { throw new BuildException ( "No project set for InstanceOf ResourceSelector; " + "the type attribute is invalid." ) ; } AntTypeDefinition d = ComponentHelper . getComponentHelper ( project ) . getDefinition ( ProjectHelper . genComponentName ( uri , type ) ) ; if ( d == null ) { throw new BuildException ( "type " + type + " not found." ) ; } try { c = d . innerGetTypeClass ( ) ; } catch ( ClassNotFoundException e ) { throw new BuildException ( e ) ; } } return c . isAssignableFrom ( r . getClass ( ) ) ; } } 	0	['9', '1', '0', '7', '21', '16', '0', '7', '9', '0.85', '123', '1', '1', '0', '0.311111111', '0', '0', '12.11111111', '7', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; import java . util . Date ; import java . util . StringTokenizer ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . Path ; public class WLJspc extends MatchingTask { private File destinationDirectory ; private File sourceDirectory ; private String destinationPackage ; private Path compileClasspath ; private String pathToPackage = "" ; private Vector filesToDo = new Vector ( ) ; public void execute ( ) throws BuildException { if ( ! destinationDirectory . isDirectory ( ) ) { throw new BuildException ( "destination directory " + destinationDirectory . getPath ( ) + " is not valid" ) ; } if ( ! sourceDirectory . isDirectory ( ) ) { throw new BuildException ( "src directory " + sourceDirectory . getPath ( ) + " is not valid" ) ; } if ( destinationPackage == null ) { throw new BuildException ( "package attribute must be present." , getLocation ( ) ) ; } pathToPackage = this . destinationPackage . replace ( '.' , File . separatorChar ) ; DirectoryScanner ds = super . getDirectoryScanner ( sourceDirectory ) ; if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } compileClasspath = compileClasspath . concatSystemClasspath ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; Java helperTask = new Java ( this ) ; helperTask . setFork ( true ) ; helperTask . setClassname ( "weblogic.jspc" ) ; helperTask . setTaskName ( getTaskName ( ) ) ; String [ ] args = new String [ 12 ] ; File jspFile = null ; String parents = "" ; int j = 0 ; args [ j ++ ] = "-d" ; args [ j ++ ] = destinationDirectory . getAbsolutePath ( ) . trim ( ) ; args [ j ++ ] = "-docroot" ; args [ j ++ ] = sourceDirectory . getAbsolutePath ( ) . trim ( ) ; args [ j ++ ] = "-keepgenerated" ; args [ j ++ ] = "-compilerclass" ; args [ j ++ ] = "sun.tools.javac.Main" ; args [ j ++ ] = "-classpath" ; args [ j ++ ] = compileClasspath . toString ( ) ; this . scanDir ( files ) ; log ( "Compiling " + filesToDo . size ( ) + " JSP files" ) ; for ( int i = 0 ; i < filesToDo . size ( ) ; i ++ ) { String filename = ( String ) filesToDo . elementAt ( i ) ; jspFile = new File ( filename ) ; args [ j ] = "-package" ; parents = jspFile . getParent ( ) ; if ( ( parents != null ) && ( ! ( "" ) . equals ( parents ) ) ) { parents = this . replaceString ( parents , File . separator , "_." ) ; args [ j + 1 ] = destinationPackage + "." + "_" + parents ; } else { args [ j + 1 ] = destinationPackage ; } args [ j + 2 ] = sourceDirectory + File . separator + filename ; helperTask . clearArgs ( ) ; for ( int x = 0 ; x < j + 3 ; x ++ ) { helperTask . createArg ( ) . setValue ( args [ x ] ) ; } helperTask . setClasspath ( compileClasspath ) ; if ( helperTask . executeJava ( ) != 0 ) { log ( filename + " failed to compile" , Project . MSG_WARN ) ; } } } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath ; } public void setSrc ( File dirName ) { sourceDirectory = dirName ; } public void setDest ( File dirName ) { destinationDirectory = dirName ; } public void setPackage ( String packageName ) { destinationPackage = packageName ; } protected void scanDir ( String [ ] files ) { long now = ( new Date ( ) ) . getTime ( ) ; File jspFile = null ; String parents = null ; String pack = "" ; for ( int i = 0 ; i < files . length ; i ++ ) { File srcFile = new File ( this . sourceDirectory , files [ i ] ) ; jspFile = new File ( files [ i ] ) ; parents = jspFile . getParent ( ) ; if ( ( parents != null ) && ( ! ( "" ) . equals ( parents ) ) ) { parents = this . replaceString ( parents , File . separator , "_/" ) ; pack = pathToPackage + File . separator + "_" + parents ; } else { pack = pathToPackage ; } String filePath = pack + File . separator + "_" ; int startingIndex = files [ i ] . lastIndexOf ( File . separator ) != - 1 ? files [ i ] . lastIndexOf ( File . separator ) + 1 : 0 ; int endingIndex = files [ i ] . indexOf ( ".jsp" ) ; if ( endingIndex == - 1 ) { log ( "Skipping " + files [ i ] + ". Not a JSP" , Project . MSG_VERBOSE ) ; continue ; } filePath += files [ i ] . substring ( startingIndex , endingIndex ) ; filePath += ".class" ; File classFile = new File ( this . destinationDirectory , filePath ) ; if ( srcFile . lastModified ( ) > now ) { log ( "Warning: file modified in the future: " + files [ i ] , Project . MSG_WARN ) ; } if ( srcFile . lastModified ( ) > classFile . lastModified ( ) ) { filesToDo . addElement ( files [ i ] ) ; log ( "Recompiling File " + files [ i ] , Project . MSG_VERBOSE ) ; } } } protected String replaceString ( String inpString , String escapeChars , String replaceChars ) { String localString = "" ; int numTokens = 0 ; StringTokenizer st = new StringTokenizer ( inpString , escapeChars , true ) ; numTokens = st . countTokens ( ) ; for ( int i = 0 ; i < numTokens ; i ++ ) { String test = st . nextToken ( ) ; test = ( test . equals ( escapeChars ) ? replaceChars : test ) ; localString += test ; } return localString ; } } 	0	['9', '4', '0', '9', '61', '14', '0', '9', '7', '0.770833333', '586', '1', '1', '0.906976744', '0.333333333', '4', '4', '63.44444444', '8', '2.1111', '0']
package org . apache . tools . ant . types ; import java . io . File ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . ArrayList ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Redirector ; public class RedirectorElement extends DataType { private boolean usingInput = false ; private boolean usingOutput = false ; private boolean usingError = false ; private Boolean logError ; private String outputProperty ; private String errorProperty ; private String inputString ; private Boolean append ; private Boolean alwaysLog ; private Boolean createEmptyFiles ; private Mapper inputMapper ; private Mapper outputMapper ; private Mapper errorMapper ; private Vector inputFilterChains = new Vector ( ) ; private Vector outputFilterChains = new Vector ( ) ; private Vector errorFilterChains = new Vector ( ) ; private String outputEncoding ; private String errorEncoding ; private String inputEncoding ; private Boolean logInputString ; public void addConfiguredInputMapper ( Mapper inputMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . inputMapper != null ) { if ( usingInput ) { throw new BuildException ( "attribute \"input\"" + " cannot coexist with a nested <inputmapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <inputmapper>" ) ; } } this . inputMapper = inputMapper ; } public void addConfiguredOutputMapper ( Mapper outputMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . outputMapper != null ) { if ( usingOutput ) { throw new BuildException ( "attribute \"output\"" + " cannot coexist with a nested <outputmapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <outputmapper>" ) ; } } this . outputMapper = outputMapper ; } public void addConfiguredErrorMapper ( Mapper errorMapper ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . errorMapper != null ) { if ( usingError ) { throw new BuildException ( "attribute \"error\"" + " cannot coexist with a nested <errormapper>" ) ; } else { throw new BuildException ( "Cannot have > 1 <errormapper>" ) ; } } this . errorMapper = errorMapper ; } public void setRefid ( Reference r ) throws BuildException { if ( usingInput || usingOutput || usingError || inputString != null || logError != null || append != null || createEmptyFiles != null || inputEncoding != null || outputEncoding != null || errorEncoding != null || outputProperty != null || errorProperty != null || logInputString != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public void setInput ( File input ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( inputString != null ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } usingInput = true ; inputMapper = createMergeMapper ( input ) ; } public void setInputString ( String inputString ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( usingInput ) { throw new BuildException ( "The \"input\" and \"inputstring\" " + "attributes cannot both be specified" ) ; } this . inputString = inputString ; } public void setLogInputString ( boolean logInputString ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . logInputString = logInputString ? Boolean . TRUE : Boolean . FALSE ; } public void setOutput ( File out ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( out == null ) { throw new IllegalArgumentException ( "output file specified as null" ) ; } usingOutput = true ; outputMapper = createMergeMapper ( out ) ; } public void setOutputEncoding ( String outputEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . outputEncoding = outputEncoding ; } public void setErrorEncoding ( String errorEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . errorEncoding = errorEncoding ; } public void setInputEncoding ( String inputEncoding ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . inputEncoding = inputEncoding ; } public void setLogError ( boolean logError ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . logError = ( ( logError ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setError ( File error ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( error == null ) { throw new IllegalArgumentException ( "error file specified as null" ) ; } usingError = true ; errorMapper = createMergeMapper ( error ) ; } public void setOutputProperty ( String outputProperty ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . outputProperty = outputProperty ; } public void setAppend ( boolean append ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . append = ( ( append ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setAlwaysLog ( boolean alwaysLog ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . alwaysLog = ( ( alwaysLog ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCreateEmptyFiles ( boolean createEmptyFiles ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . createEmptyFiles = ( ( createEmptyFiles ) ? Boolean . TRUE : Boolean . FALSE ) ; } public void setErrorProperty ( String errorProperty ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } this . errorProperty = errorProperty ; } public FilterChain createInputFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; inputFilterChains . add ( result ) ; return result ; } public FilterChain createOutputFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; outputFilterChains . add ( result ) ; return result ; } public FilterChain createErrorFilterChain ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } FilterChain result = new FilterChain ( ) ; result . setProject ( getProject ( ) ) ; errorFilterChains . add ( result ) ; return result ; } public void configure ( Redirector redirector ) { configure ( redirector , null ) ; } public void configure ( Redirector redirector , String sourcefile ) { if ( isReference ( ) ) { getRef ( ) . configure ( redirector , sourcefile ) ; return ; } if ( alwaysLog != null ) { redirector . setAlwaysLog ( alwaysLog . booleanValue ( ) ) ; } if ( logError != null ) { redirector . setLogError ( logError . booleanValue ( ) ) ; } if ( append != null ) { redirector . setAppend ( append . booleanValue ( ) ) ; } if ( createEmptyFiles != null ) { redirector . setCreateEmptyFiles ( createEmptyFiles . booleanValue ( ) ) ; } if ( outputProperty != null ) { redirector . setOutputProperty ( outputProperty ) ; } if ( errorProperty != null ) { redirector . setErrorProperty ( errorProperty ) ; } if ( inputString != null ) { redirector . setInputString ( inputString ) ; } if ( logInputString != null ) { redirector . setLogInputString ( logInputString . booleanValue ( ) ) ; } if ( inputMapper != null ) { String [ ] inputTargets = null ; try { inputTargets = inputMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( inputTargets != null && inputTargets . length > 0 ) { redirector . setInput ( toFileArray ( inputTargets ) ) ; } } if ( outputMapper != null ) { String [ ] outputTargets = null ; try { outputTargets = outputMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( outputTargets != null && outputTargets . length > 0 ) { redirector . setOutput ( toFileArray ( outputTargets ) ) ; } } if ( errorMapper != null ) { String [ ] errorTargets = null ; try { errorTargets = errorMapper . getImplementation ( ) . mapFileName ( sourcefile ) ; } catch ( NullPointerException enPeaEx ) { if ( sourcefile != null ) { throw enPeaEx ; } } if ( errorTargets != null && errorTargets . length > 0 ) { redirector . setError ( toFileArray ( errorTargets ) ) ; } } if ( inputFilterChains . size ( ) > 0 ) { redirector . setInputFilterChains ( inputFilterChains ) ; } if ( outputFilterChains . size ( ) > 0 ) { redirector . setOutputFilterChains ( outputFilterChains ) ; } if ( errorFilterChains . size ( ) > 0 ) { redirector . setErrorFilterChains ( errorFilterChains ) ; } if ( inputEncoding != null ) { redirector . setInputEncoding ( inputEncoding ) ; } if ( outputEncoding != null ) { redirector . setOutputEncoding ( outputEncoding ) ; } if ( errorEncoding != null ) { redirector . setErrorEncoding ( errorEncoding ) ; } } protected Mapper createMergeMapper ( File destfile ) { Mapper result = new Mapper ( getProject ( ) ) ; result . setClassname ( org . apache . tools . ant . util . MergingMapper . class . getName ( ) ) ; result . setTo ( destfile . getAbsolutePath ( ) ) ; return result ; } protected File [ ] toFileArray ( String [ ] name ) { if ( name == null ) { return null ; } ArrayList list = new ArrayList ( name . length ) ; for ( int i = 0 ; i < name . length ; i ++ ) { if ( name [ i ] != null ) { list . add ( getProject ( ) . resolveFile ( name [ i ] ) ) ; } } return ( File [ ] ) ( list . toArray ( new File [ list . size ( ) ] ) ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { Mapper [ ] m = new Mapper [ ] { inputMapper , outputMapper , errorMapper } ; for ( int i = 0 ; i < m . length ; i ++ ) { if ( m [ i ] != null ) { stk . push ( m [ i ] ) ; m [ i ] . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } Vector [ ] v = new Vector [ ] { inputFilterChains , outputFilterChains , errorFilterChains } ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] != null ) { for ( Iterator fci = v [ i ] . iterator ( ) ; fci . hasNext ( ) ; ) { FilterChain fc = ( FilterChain ) fci . next ( ) ; stk . push ( fc ) ; fc . dieOnCircularReference ( stk , p ) ; stk . pop ( ) ; } } } setChecked ( true ) ; } } private RedirectorElement getRef ( ) { return ( RedirectorElement ) getCheckedRef ( ) ; } } 	0	['28', '3', '0', '13', '85', '248', '5', '8', '24', '0.87654321', '860', '0.952380952', '3', '0.526315789', '0.189285714', '1', '4', '28.96428571', '28', '3.3214', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class Kjc extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using kjc compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupKjcCommand ( ) ; cmd . setExecutable ( "at.dms.kjc.Main" ) ; ExecuteJava ej = new ExecuteJava ( ) ; ej . setJavaCommand ( cmd ) ; return ej . fork ( getJavac ( ) ) == 0 ; } protected Commandline setupKjcCommand ( ) { Commandline cmd = new Commandline ( ) ; Path classpath = getCompileClasspath ( ) ; if ( deprecation ) { cmd . createArgument ( ) . setValue ( "-deprecation" ) ; } if ( destDir != null ) { cmd . createArgument ( ) . setValue ( "-d" ) ; cmd . createArgument ( ) . setFile ( destDir ) ; } cmd . createArgument ( ) . setValue ( "-classpath" ) ; Path cp = new Path ( project ) ; Path p = getBootClassPath ( ) ; if ( p . size ( ) > 0 ) { cp . append ( p ) ; } if ( extdirs != null ) { cp . addExtdirs ( extdirs ) ; } cp . append ( classpath ) ; if ( compileSourcepath != null ) { cp . append ( compileSourcepath ) ; } else { cp . append ( src ) ; } cmd . createArgument ( ) . setPath ( cp ) ; if ( encoding != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( encoding ) ; } if ( debug ) { cmd . createArgument ( ) . setValue ( "-g" ) ; } if ( optimize ) { cmd . createArgument ( ) . setValue ( "-O2" ) ; } if ( verbose ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; } addCurrentCompilerArgs ( cmd ) ; logAndAddFilesToCompile ( cmd ) ; return cmd ; } } 	0	['3', '2', '0', '10', '23', '3', '1', '9', '2', '2', '145', '0', '0', '0.92', '1', '0', '0', '47.33333333', '10', '3.6667', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Iterator ; import org . apache . tools . ant . types . Resource ; public class None extends ResourceSelectorContainer implements ResourceSelector { public None ( ) { } public None ( ResourceSelector [ ] r ) { super ( r ) ; } public boolean isSelected ( Resource r ) { boolean none = true ; for ( Iterator i = getSelectors ( ) ; none && i . hasNext ( ) ; ) { none = ! ( ( ResourceSelector ) i . next ( ) ) . isSelected ( r ) ; } return none ; } } 	0	['3', '4', '0', '3', '9', '3', '0', '3', '3', '2', '33', '0', '0', '0.972222222', '0.555555556', '0', '0', '10', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class WeblogicTOPLinkDeploymentTool extends WeblogicDeploymentTool { private static final String TL_DTD_LOC = "http://www.objectpeople.com/tlwl/dtd/toplink-cmp_2_5_1.dtd" ; private String toplinkDescriptor ; private String toplinkDTD ; public void setToplinkdescriptor ( String inString ) { this . toplinkDescriptor = inString ; } public void setToplinkdtd ( String inString ) { this . toplinkDTD = inString ; } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler handler = super . getDescriptorHandler ( srcDir ) ; if ( toplinkDTD != null ) { handler . registerDTD ( "-//The Object People, Inc.//" + "DTD TOPLink for WebLogic CMP 2.5.1//EN" , toplinkDTD ) ; } else { handler . registerDTD ( "-//The Object People, Inc.//" + "DTD TOPLink for WebLogic CMP 2.5.1//EN" , TL_DTD_LOC ) ; } return handler ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { super . addVendorFiles ( ejbFiles , ddPrefix ) ; File toplinkDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + toplinkDescriptor ) ; if ( toplinkDD . exists ( ) ) { ejbFiles . put ( META_DIR + toplinkDescriptor , toplinkDD ) ; } else { log ( "Unable to locate toplink deployment descriptor. " + "It was expected to be in " + toplinkDD . getPath ( ) , Project . MSG_WARN ) ; } } public void validateConfigured ( ) throws BuildException { super . validateConfigured ( ) ; if ( toplinkDescriptor == null ) { throw new BuildException ( "The toplinkdescriptor attribute must " + "be specified" ) ; } } } 	0	['6', '3', '0', '5', '22', '7', '1', '4', '4', '0.866666667', '98', '1', '0', '0.925373134', '0.458333333', '2', '4', '14.83333333', '2', '1.1667', '0']
package org . apache . tools . ant ; public interface DynamicConfigurator extends DynamicAttribute , DynamicElement { } 	0	['0', '1', '0', '4', '0', '0', '2', '2', '0', '2', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . types . Path ; public class JonasHotDeploymentTool extends GenericHotDeploymentTool implements HotDeploymentTool { protected static final String DEFAULT_ORB = "RMI" ; private static final String JONAS_DEPLOY_CLASS_NAME = "org.objectweb.jonas.adm.JonasAdmin" ; private static final String [ ] VALID_ACTIONS = { ACTION_DELETE , ACTION_DEPLOY , ACTION_LIST , ACTION_UNDEPLOY , ACTION_UPDATE } ; private File jonasroot ; private String orb = null ; private String davidHost ; private int davidPort ; public void setDavidhost ( final String inValue ) { davidHost = inValue ; } public void setDavidport ( final int inValue ) { davidPort = inValue ; } public void setJonasroot ( final File inValue ) { jonasroot = inValue ; } public void setOrb ( final String inValue ) { orb = inValue ; } public Path getClasspath ( ) { Path aClassPath = super . getClasspath ( ) ; if ( aClassPath == null ) { aClassPath = new Path ( getTask ( ) . getProject ( ) ) ; } if ( orb != null ) { String aOrbJar = new File ( jonasroot , "lib/" + orb + "_jonas.jar" ) . toString ( ) ; String aConfigDir = new File ( jonasroot , "config/" ) . toString ( ) ; Path aJOnASOrbPath = new Path ( aClassPath . getProject ( ) , aOrbJar + File . pathSeparator + aConfigDir ) ; aClassPath . append ( aJOnASOrbPath ) ; } return aClassPath ; } public void validateAttributes ( ) throws BuildException { Java java = getJava ( ) ; String action = getTask ( ) . getAction ( ) ; if ( action == null ) { throw new BuildException ( "The \"action\" attribute must be set" ) ; } if ( ! isActionValid ( ) ) { throw new BuildException ( "Invalid action \"" + action + "\" passed" ) ; } if ( getClassName ( ) == null ) { setClassName ( JONAS_DEPLOY_CLASS_NAME ) ; } if ( jonasroot == null || jonasroot . isDirectory ( ) ) { java . createJvmarg ( ) . setValue ( "-Dinstall.root=" + jonasroot ) ; java . createJvmarg ( ) . setValue ( "-Djava.security.policy=" + jonasroot + "/config/java.policy" ) ; if ( "DAVID" . equals ( orb ) ) { java . createJvmarg ( ) . setValue ( "-Dorg.omg.CORBA.ORBClass" + "=org.objectweb.david.libs.binding.orbs.iiop.IIOPORB" ) ; java . createJvmarg ( ) . setValue ( "-Dorg.omg.CORBA.ORBSingletonClass=" + "org.objectweb.david.libs.binding.orbs.ORBSingletonClass" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.StubClass=" + "org.objectweb.david.libs.stub_factories.rmi.StubDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.PortableRemoteObjectClass=" + "org.objectweb.david.libs.binding.rmi.ORBPortableRemoteObjectDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Djavax.rmi.CORBA.UtilClass=" + "org.objectweb.david.libs.helpers.RMIUtilDelegate" ) ; java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_method=0" ) ; java . createJvmarg ( ) . setValue ( "-Ddavid.rmi.ValueHandlerClass=" + "com.sun.corba.se.internal.io.ValueHandlerImpl" ) ; if ( davidHost != null ) { java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_host=" + davidHost ) ; } if ( davidPort != 0 ) { java . createJvmarg ( ) . setValue ( "-Ddavid.CosNaming.default_port=" + davidPort ) ; } } } if ( getServer ( ) != null ) { java . createArg ( ) . setLine ( "-n " + getServer ( ) ) ; } if ( action . equals ( ACTION_DEPLOY ) || action . equals ( ACTION_UPDATE ) || action . equals ( "redeploy" ) ) { java . createArg ( ) . setLine ( "-a " + getTask ( ) . getSource ( ) ) ; } else if ( action . equals ( ACTION_DELETE ) || action . equals ( ACTION_UNDEPLOY ) ) { java . createArg ( ) . setLine ( "-r " + getTask ( ) . getSource ( ) ) ; } else if ( action . equals ( ACTION_LIST ) ) { java . createArg ( ) . setValue ( "-l" ) ; } } protected boolean isActionValid ( ) { boolean valid = false ; String action = getTask ( ) . getAction ( ) ; for ( int i = 0 ; i < VALID_ACTIONS . length ; i ++ ) { if ( action . equals ( VALID_ACTIONS [ i ] ) ) { valid = true ; break ; } } return valid ; } } 	0	['9', '3', '0', '8', '38', '14', '1', '8', '7', '0.875', '345', '1', '0', '0.766666667', '0.375', '3', '5', '36.55555556', '3', '1.2222', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCUnCheckout extends ClearCase { private boolean mKeep = false ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_UNCHECKOUT ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getKeepCopy ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_KEEPCOPY ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_RM ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setKeepCopy ( boolean keep ) { mKeep = keep ; } public boolean getKeepCopy ( ) { return mKeep ; } public static final String FLAG_KEEPCOPY = "-keep" ; public static final String FLAG_RM = "-rm" ; } 	0	['5', '4', '0', '7', '27', '4', '0', '7', '4', '0.916666667', '109', '0.333333333', '0', '0.923076923', '0.466666667', '2', '3', '20.2', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import java . io . File ; import java . text . SimpleDateFormat ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class MSVSSHISTORY extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; if ( getVsspath ( ) == null ) { String msg = "vsspath attribute must be set!" ; throw new BuildException ( msg , getLocation ( ) ) ; } commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_HISTORY ) ; commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( FLAG_AUTORESPONSE_DEF ) ; commandLine . createArgument ( ) . setValue ( getVersionDate ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getStyle ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getOutput ( ) ) ; return commandLine ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setUser ( String user ) { super . setInternalUser ( user ) ; } public void setFromDate ( String fromDate ) { super . setInternalFromDate ( fromDate ) ; } public void setToDate ( String toDate ) { super . setInternalToDate ( toDate ) ; } public void setFromLabel ( String fromLabel ) { super . setInternalFromLabel ( fromLabel ) ; } public void setToLabel ( String toLabel ) { super . setInternalToLabel ( toLabel ) ; } public void setNumdays ( int numd ) { super . setInternalNumDays ( numd ) ; } public void setOutput ( File outfile ) { if ( outfile != null ) { super . setInternalOutputFilename ( outfile . getAbsolutePath ( ) ) ; } } public void setDateFormat ( String dateFormat ) { super . setInternalDateFormat ( new SimpleDateFormat ( dateFormat ) ) ; } public void setStyle ( BriefCodediffNofile attr ) { String option = attr . getValue ( ) ; if ( option . equals ( STYLE_BRIEF ) ) { super . setInternalStyle ( FLAG_BRIEF ) ; } else if ( option . equals ( STYLE_CODEDIFF ) ) { super . setInternalStyle ( FLAG_CODEDIFF ) ; } else if ( option . equals ( STYLE_DEFAULT ) ) { super . setInternalStyle ( "" ) ; } else if ( option . equals ( STYLE_NOFILE ) ) { super . setInternalStyle ( FLAG_NO_FILE ) ; } else { throw new BuildException ( "Style " + attr + " unknown." , getLocation ( ) ) ; } } public static class BriefCodediffNofile extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { STYLE_BRIEF , STYLE_CODEDIFF , STYLE_NOFILE , STYLE_DEFAULT } ; } } } 	0	['12', '4', '0', '6', '45', '66', '0', '6', '11', '2', '173', '0', '0', '0.892156863', '0.305555556', '1', '1', '13.41666667', '5', '1.4167', '0']
package org . apache . tools . ant ; public interface DynamicAttributeNS { void setDynamicAttribute ( String uri , String localName , String qName , String value ) throws BuildException ; } 	0	['1', '1', '0', '3', '1', '0', '2', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . util . ArrayList ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . AntResolver ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . LocationResolver ; import org . apache . tools . ant . taskdefs . optional . extension . resolvers . URLResolver ; public class JarLibResolveTask extends Task { private String propertyName ; private Extension requiredExtension ; private final ArrayList resolvers = new ArrayList ( ) ; private boolean checkExtension = true ; private boolean failOnError = true ; public void setProperty ( final String property ) { this . propertyName = property ; } public void setCheckExtension ( final boolean checkExtension ) { this . checkExtension = checkExtension ; } public void setFailOnError ( final boolean failOnError ) { this . failOnError = failOnError ; } public void addConfiguredLocation ( final LocationResolver loc ) { resolvers . add ( loc ) ; } public void addConfiguredUrl ( final URLResolver url ) { resolvers . add ( url ) ; } public void addConfiguredAnt ( final AntResolver ant ) { resolvers . add ( ant ) ; } public void addConfiguredExtension ( final ExtensionAdapter extension ) { if ( null != requiredExtension ) { final String message = "Can not specify extension to " + "resolve multiple times." ; throw new BuildException ( message ) ; } requiredExtension = extension . toExtension ( ) ; } public void execute ( ) throws BuildException { validate ( ) ; getProject ( ) . log ( "Resolving extension: " + requiredExtension , Project . MSG_VERBOSE ) ; String candidate = getProject ( ) . getProperty ( propertyName ) ; if ( null != candidate ) { final String message = "Property Already set to: " + candidate ; if ( failOnError ) { throw new BuildException ( message ) ; } getProject ( ) . log ( message , Project . MSG_ERR ) ; return ; } final int size = resolvers . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionResolver resolver = ( ExtensionResolver ) resolvers . get ( i ) ; getProject ( ) . log ( "Searching for extension using Resolver:" + resolver , Project . MSG_VERBOSE ) ; try { final File file = resolver . resolve ( requiredExtension , getProject ( ) ) ; try { checkExtension ( file ) ; return ; } catch ( final BuildException be ) { final String message = "File " + file + " returned by " + "resolver failed to satisfy extension due to: " + be . getMessage ( ) ; getProject ( ) . log ( message , Project . MSG_WARN ) ; } } catch ( final BuildException be ) { final String message = "Failed to resolve extension to file " + "using resolver " + resolver + " due to: " + be ; getProject ( ) . log ( message , Project . MSG_WARN ) ; } } missingExtension ( ) ; } private void missingExtension ( ) { final String message = "Unable to resolve extension to a file" ; if ( failOnError ) { throw new BuildException ( message ) ; } getProject ( ) . log ( message , Project . MSG_ERR ) ; } private void checkExtension ( final File file ) { if ( ! file . exists ( ) ) { final String message = "File " + file + " does not exist" ; throw new BuildException ( message ) ; } if ( ! file . isFile ( ) ) { final String message = "File " + file + " is not a file" ; throw new BuildException ( message ) ; } if ( ! checkExtension ) { final String message = "Setting property to " + file + " without verifying library satisfies extension" ; getProject ( ) . log ( message , Project . MSG_VERBOSE ) ; setLibraryProperty ( file ) ; } else { getProject ( ) . log ( "Checking file " + file + " to see if it satisfies extension" , Project . MSG_VERBOSE ) ; final Manifest manifest = ExtensionUtil . getManifest ( file ) ; final Extension [ ] extensions = Extension . getAvailable ( manifest ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; if ( extension . isCompatibleWith ( requiredExtension ) ) { setLibraryProperty ( file ) ; return ; } } getProject ( ) . log ( "File " + file + " skipped as it " + "does not satisfy extension" , Project . MSG_VERBOSE ) ; final String message = "File " + file + " does not satisfy extension" ; throw new BuildException ( message ) ; } } private void setLibraryProperty ( final File file ) { getProject ( ) . setNewProperty ( propertyName , file . getAbsolutePath ( ) ) ; } private void validate ( ) throws BuildException { if ( null == propertyName ) { final String message = "Property attribute must be specified." ; throw new BuildException ( message ) ; } if ( null == requiredExtension ) { final String message = "Extension element must be specified." ; throw new BuildException ( message ) ; } } } 	0	['13', '3', '0', '10', '36', '20', '0', '10', '9', '0.716666667', '369', '1', '1', '0.755102041', '0.211538462', '1', '1', '27', '6', '1.4615', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Apt ; import org . apache . tools . ant . types . Commandline ; public class AptExternalCompilerAdapter extends DefaultCompilerAdapter { protected Apt getApt ( ) { return ( Apt ) getJavac ( ) ; } public boolean execute ( ) throws BuildException { attributes . log ( "Using external apt compiler" , Project . MSG_VERBOSE ) ; Apt apt = getApt ( ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( apt . getAptExecutable ( ) ) ; setupModernJavacCommandlineSwitches ( cmd ) ; AptCompilerAdapter . setAptCommandlineSwitches ( apt , cmd ) ; int firstFileName = cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; return 0 == executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) ; } } 	0	['3', '2', '0', '6', '15', '3', '0', '6', '2', '2', '50', '0', '0', '0.92', '1', '0', '0', '15.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . types . CommandlineJava ; public abstract class DefaultJspCompilerAdapter implements JspCompilerAdapter { private static String lSep = System . getProperty ( "line.separator" ) ; protected void logAndAddFilesToCompile ( JspC jspc , Vector compileList , CommandlineJava cmd ) { jspc . log ( "Compilation " + cmd . describeJavaCommand ( ) , Project . MSG_VERBOSE ) ; StringBuffer niceSourceList = new StringBuffer ( "File" ) ; if ( compileList . size ( ) != 1 ) { niceSourceList . append ( "s" ) ; } niceSourceList . append ( " to be compiled:" ) ; niceSourceList . append ( lSep ) ; Enumeration e = compileList . elements ( ) ; while ( e . hasMoreElements ( ) ) { String arg = ( String ) e . nextElement ( ) ; cmd . createArgument ( ) . setValue ( arg ) ; niceSourceList . append ( "    " ) ; niceSourceList . append ( arg ) ; niceSourceList . append ( lSep ) ; } jspc . log ( niceSourceList . toString ( ) , Project . MSG_VERBOSE ) ; } protected JspC owner ; public void setJspc ( JspC owner ) { this . owner = owner ; } public JspC getJspc ( ) { return owner ; } protected void addArg ( CommandlineJava cmd , String argument ) { if ( argument != null && argument . length ( ) != 0 ) { cmd . createArgument ( ) . setValue ( argument ) ; } } protected void addArg ( CommandlineJava cmd , String argument , String value ) { if ( value != null ) { cmd . createArgument ( ) . setValue ( argument ) ; cmd . createArgument ( ) . setValue ( value ) ; } } protected void addArg ( CommandlineJava cmd , String argument , File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( argument ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public boolean implementsOwnDependencyChecking ( ) { return false ; } public Project getProject ( ) { return getJspc ( ) . getProject ( ) ; } } 	0	['10', '1', '1', '6', '26', '41', '1', '5', '5', '0.833333333', '129', '1', '1', '0', '0.37037037', '0', '0', '11.7', '3', '1.4', '0']
package org . apache . tools . ant . types ; import java . net . URL ; public class ResourceLocation { private String publicId = null ; private String location = null ; private URL base = null ; public void setPublicId ( String publicId ) { this . publicId = publicId ; } public void setLocation ( String location ) { this . location = location ; } public void setBase ( URL base ) { this . base = base ; } public String getPublicId ( ) { return publicId ; } public String getLocation ( ) { return location ; } public URL getBase ( ) { return base ; } } 	0	['7', '1', '1', '6', '8', '3', '6', '0', '7', '0.666666667', '43', '1', '0', '0', '0.476190476', '0', '0', '4.714285714', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DynamicElement ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . Available ; import org . apache . tools . ant . taskdefs . Checksum ; import org . apache . tools . ant . taskdefs . UpToDate ; public abstract class ConditionBase extends ProjectComponent implements DynamicElement { private static final String CONDITION_ANTLIB = "antlib:org.apache.tools.ant.types.conditions:" ; private String taskName = "condition" ; private Vector conditions = new Vector ( ) ; protected ConditionBase ( ) { taskName = "component" ; } protected ConditionBase ( String taskName ) { this . taskName = taskName ; } protected int countConditions ( ) { return conditions . size ( ) ; } protected final Enumeration getConditions ( ) { return conditions . elements ( ) ; } public void setTaskName ( String name ) { this . taskName = name ; } public String getTaskName ( ) { return taskName ; } public void addAvailable ( Available a ) { conditions . addElement ( a ) ; } public void addChecksum ( Checksum c ) { conditions . addElement ( c ) ; } public void addUptodate ( UpToDate u ) { conditions . addElement ( u ) ; } public void addNot ( Not n ) { conditions . addElement ( n ) ; } public void addAnd ( And a ) { conditions . addElement ( a ) ; } public void addOr ( Or o ) { conditions . addElement ( o ) ; } public void addEquals ( Equals e ) { conditions . addElement ( e ) ; } public void addOs ( Os o ) { conditions . addElement ( o ) ; } public void addIsSet ( IsSet i ) { conditions . addElement ( i ) ; } public void addHttp ( Http h ) { conditions . addElement ( h ) ; } public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } public void addFilesMatch ( FilesMatch test ) { conditions . addElement ( test ) ; } public void addContains ( Contains test ) { conditions . addElement ( test ) ; } public void addIsTrue ( IsTrue test ) { conditions . addElement ( test ) ; } public void addIsFalse ( IsFalse test ) { conditions . addElement ( test ) ; } public void addIsReference ( IsReference i ) { conditions . addElement ( i ) ; } public void addIsFileSelected ( IsFileSelected test ) { conditions . addElement ( test ) ; } public void add ( Condition c ) { conditions . addElement ( c ) ; } public Object createDynamicElement ( String name ) { Object cond = ComponentHelper . getComponentHelper ( getProject ( ) ) . createComponent ( CONDITION_ANTLIB + name ) ; if ( ! ( cond instanceof Condition ) ) { return null ; } log ( "Dynamically discovered '" + name + "' " + cond , Project . MSG_DEBUG ) ; add ( ( Condition ) cond ) ; return cond ; } } 	0	['25', '2', '7', '27', '38', '0', '8', '22', '21', '0.666666667', '198', '1', '0', '0.28125', '0.092', '0', '0', '6.8', '2', '0.96', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Integrate extends P4Base { private String change = null ; private String fromfile = null ; private String tofile = null ; private String branch = null ; private boolean restoredeletedrevisions = false ; private boolean forceintegrate = false ; private boolean leavetargetrevision = false ; private boolean enablebaselessmerges = false ; private boolean simulationmode = false ; private boolean reversebranchmappings = false ; private boolean propagatesourcefiletype = false ; private boolean nocopynewtargetfiles = false ; public String getChange ( ) { return change ; } public void setChange ( String change ) { this . change = change ; } public String getFromfile ( ) { return fromfile ; } public void setFromfile ( String fromf ) { this . fromfile = fromf ; } public String getTofile ( ) { return tofile ; } public void setTofile ( String tof ) { this . tofile = tof ; } public String getBranch ( ) { return branch ; } public void setBranch ( String br ) { this . branch = br ; } public boolean isRestoreDeletedRevisions ( ) { return restoredeletedrevisions ; } public void setRestoreDeletedRevisions ( boolean setrest ) { this . restoredeletedrevisions = setrest ; } public boolean isForceIntegrate ( ) { return forceintegrate ; } public void setForceIntegrate ( boolean setrest ) { this . forceintegrate = setrest ; } public boolean isLeaveTargetRevision ( ) { return leavetargetrevision ; } public void setLeaveTargetRevision ( boolean setrest ) { this . leavetargetrevision = setrest ; } public boolean isEnableBaselessMerges ( ) { return enablebaselessmerges ; } public void setEnableBaselessMerges ( boolean setrest ) { this . enablebaselessmerges = setrest ; } public boolean isSimulationMode ( ) { return simulationmode ; } public void setSimulationMode ( boolean setrest ) { this . simulationmode = setrest ; } public boolean isReversebranchmappings ( ) { return reversebranchmappings ; } public void setReversebranchmappings ( boolean reversebranchmappings ) { this . reversebranchmappings = reversebranchmappings ; } public boolean isPropagatesourcefiletype ( ) { return propagatesourcefiletype ; } public void setPropagatesourcefiletype ( boolean propagatesourcefiletype ) { this . propagatesourcefiletype = propagatesourcefiletype ; } public boolean isNocopynewtargetfiles ( ) { return nocopynewtargetfiles ; } public void setNocopynewtargetfiles ( boolean nocopynewtargetfiles ) { this . nocopynewtargetfiles = nocopynewtargetfiles ; } public void execute ( ) throws BuildException { if ( change != null ) { P4CmdOpts = "-c " + change ; } if ( this . forceintegrate ) { P4CmdOpts = P4CmdOpts + " -f" ; } if ( this . restoredeletedrevisions ) { P4CmdOpts = P4CmdOpts + " -d" ; } if ( this . leavetargetrevision ) { P4CmdOpts = P4CmdOpts + " -h" ; } if ( this . enablebaselessmerges ) { P4CmdOpts = P4CmdOpts + " -i" ; } if ( this . simulationmode ) { P4CmdOpts = P4CmdOpts + " -n" ; } if ( this . reversebranchmappings ) { P4CmdOpts = P4CmdOpts + " -r" ; } if ( this . propagatesourcefiletype ) { P4CmdOpts = P4CmdOpts + " -t" ; } if ( this . nocopynewtargetfiles ) { P4CmdOpts = P4CmdOpts + "-v" ; } String command ; if ( branch == null && fromfile != null && tofile != null ) { command = P4CmdOpts + " " + fromfile + " " + tofile ; } else if ( branch != null && fromfile == null && tofile != null ) { command = P4CmdOpts + " -b " + branch + " " + tofile ; } else if ( branch != null && fromfile != null ) { command = P4CmdOpts + " -b " + branch + " -s " + fromfile + " " + tofile ; } else { throw new BuildException ( "you need to specify fromfile and tofile, " + "or branch and tofile, or branch and fromfile, or branch and fromfile and tofile " ) ; } execP4Command ( "-s integrate " + command , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['26', '4', '0', '4', '34', '203', '0', '4', '26', '0.88', '399', '1', '0', '0.671052632', '0.487179487', '1', '1', '13.88461538', '1', '0.9615', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class CCMCreateTask extends Continuus implements ExecuteStreamHandler { private String comment = null ; private String platform = null ; private String resolver = null ; private String release = null ; private String subSystem = null ; private String task = null ; public CCMCreateTask ( ) { super ( ) ; setCcmAction ( COMMAND_CREATE_TASK ) ; } public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; result = run ( commandLine , this ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } Commandline commandLine2 = new Commandline ( ) ; commandLine2 . setExecutable ( getCcmCommand ( ) ) ; commandLine2 . createArgument ( ) . setValue ( COMMAND_DEFAULT_TASK ) ; commandLine2 . createArgument ( ) . setValue ( getTask ( ) ) ; log ( commandLine . describeCommand ( ) , Project . MSG_DEBUG ) ; result = run ( commandLine2 ) ; if ( result != 0 ) { String msg = "Failed executing: " + commandLine2 . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( "\"" + getComment ( ) + "\"" ) ; } if ( getPlatform ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_PLATFORM ) ; cmd . createArgument ( ) . setValue ( getPlatform ( ) ) ; } if ( getResolver ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_RESOLVER ) ; cmd . createArgument ( ) . setValue ( getResolver ( ) ) ; } if ( getSubSystem ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_SUBSYSTEM ) ; cmd . createArgument ( ) . setValue ( "\"" + getSubSystem ( ) + "\"" ) ; } if ( getRelease ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_RELEASE ) ; cmd . createArgument ( ) . setValue ( getRelease ( ) ) ; } } public String getComment ( ) { return comment ; } public void setComment ( String v ) { this . comment = v ; } public String getPlatform ( ) { return platform ; } public void setPlatform ( String v ) { this . platform = v ; } public String getResolver ( ) { return resolver ; } public void setResolver ( String v ) { this . resolver = v ; } public String getRelease ( ) { return release ; } public void setRelease ( String v ) { this . release = v ; } public String getSubSystem ( ) { return subSystem ; } public void setSubSystem ( String v ) { this . subSystem = v ; } public String getTask ( ) { return task ; } public void setTask ( String v ) { this . task = v ; } public static final String FLAG_COMMENT = "/synopsis" ; public static final String FLAG_PLATFORM = "/plat" ; public static final String FLAG_RESOLVER = "/resolver" ; public static final String FLAG_RELEASE = "/release" ; public static final String FLAG_SUBSYSTEM = "/subsystem" ; public static final String FLAG_TASK = "/task" ; public void start ( ) throws IOException { } public void stop ( ) { } public void setProcessInputStream ( OutputStream param1 ) throws IOException { } public void setProcessErrorStream ( InputStream is ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String s = reader . readLine ( ) ; if ( s != null ) { log ( "err " + s , Project . MSG_DEBUG ) ; } } public void setProcessOutputStream ( InputStream is ) throws IOException { String buffer = "" ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; buffer = reader . readLine ( ) ; if ( buffer != null ) { log ( "buffer:" + buffer , Project . MSG_DEBUG ) ; String taskstring = buffer . substring ( buffer . indexOf ( ' ' ) ) . trim ( ) ; taskstring = taskstring . substring ( 0 , taskstring . lastIndexOf ( ' ' ) ) . trim ( ) ; setTask ( taskstring ) ; log ( "task is " + getTask ( ) , Project . MSG_DEBUG ) ; } } catch ( NullPointerException npe ) { log ( "error procession stream , null pointer exception" , Project . MSG_ERR ) ; npe . printStackTrace ( ) ; throw new BuildException ( npe . getClass ( ) . getName ( ) ) ; } catch ( Exception e ) { log ( "error procession stream " + e . getMessage ( ) , Project . MSG_ERR ) ; throw new BuildException ( e . getMessage ( ) ) ; } } } 	0	['20', '4', '0', '7', '52', '154', '0', '7', '19', '0.942982456', '377', '0.5', '0', '0.693548387', '0.3', '2', '2', '17.25', '6', '1.2', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class RetryHandler { private int retriesAllowed = 0 ; private Task task ; public RetryHandler ( int retriesAllowed , Task task ) { this . retriesAllowed = retriesAllowed ; this . task = task ; } public void execute ( Retryable exe , String desc ) throws IOException { int retries = 0 ; while ( true ) { try { exe . execute ( ) ; break ; } catch ( IOException e ) { retries ++ ; if ( retries > this . retriesAllowed && this . retriesAllowed > - 1 ) { task . log ( "try #" + retries + ": IO error (" + desc + "), number of maximum retries reached (" + this . retriesAllowed + "), giving up" , Project . MSG_WARN ) ; throw e ; } else { task . log ( "try #" + retries + ": IO error (" + desc + "), retrying" , Project . MSG_WARN ) ; } } } } } 	0	['2', '1', '0', '2', '9', '0', '0', '2', '2', '0', '74', '1', '1', '0', '0.6', '0', '0', '35', '1', '0.5', '0']
package org . apache . tools . ant . types . mappers ; import java . io . StringReader ; import java . io . Reader ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . UnsupportedAttributeException ; import org . apache . tools . ant . filters . util . ChainReaderHelper ; import org . apache . tools . ant . types . FilterChain ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . FileUtils ; public class FilterMapper extends FilterChain implements FileNameMapper { public void setFrom ( String from ) { throw new UnsupportedAttributeException ( "filtermapper doesn't support the \"from\" attribute." , "from" ) ; } public void setTo ( String to ) { throw new UnsupportedAttributeException ( "filtermapper doesn't support the \"to\" attribute." , "to" ) ; } public String [ ] mapFileName ( String sourceFileName ) { try { Reader stringReader = new StringReader ( sourceFileName ) ; ChainReaderHelper helper = new ChainReaderHelper ( ) ; helper . setBufferSize ( 8192 ) ; helper . setPrimaryReader ( stringReader ) ; helper . setProject ( getProject ( ) ) ; Vector filterChains = new Vector ( ) ; filterChains . add ( this ) ; helper . setFilterChains ( filterChains ) ; String result = FileUtils . readFully ( helper . getAssembledReader ( ) ) ; if ( result . length ( ) == 0 ) { return null ; } else { return new String [ ] { result } ; } } catch ( BuildException ex ) { throw ex ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } 	0	['4', '4', '0', '7', '19', '6', '0', '7', '4', '2', '74', '0', '0', '0.947368421', '0.875', '0', '0', '17.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public final class CompilerAdapterFactory { private static final String MODERN_COMPILER = "com.sun.tools.javac.Main" ; private CompilerAdapterFactory ( ) { } public static CompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { boolean isClassicCompilerSupported = true ; if ( ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_2 ) && ! JavaEnvUtils . isJavaVersion ( JavaEnvUtils . JAVA_1_3 ) ) { isClassicCompilerSupported = false ; } if ( compilerType . equalsIgnoreCase ( "jikes" ) ) { return new Jikes ( ) ; } if ( compilerType . equalsIgnoreCase ( "extJavac" ) ) { return new JavacExternal ( ) ; } if ( compilerType . equalsIgnoreCase ( "classic" ) || compilerType . equalsIgnoreCase ( "javac1.1" ) || compilerType . equalsIgnoreCase ( "javac1.2" ) ) { if ( isClassicCompilerSupported ) { return new Javac12 ( ) ; } else { task . log ( "This version of java does " + "not support the classic " + "compiler; upgrading to modern" , Project . MSG_WARN ) ; compilerType = "modern" ; } } if ( compilerType . equalsIgnoreCase ( "modern" ) || compilerType . equalsIgnoreCase ( "javac1.3" ) || compilerType . equalsIgnoreCase ( "javac1.4" ) || compilerType . equalsIgnoreCase ( "javac1.5" ) || compilerType . equalsIgnoreCase ( "javac1.6" ) ) { if ( doesModernCompilerExist ( ) ) { return new Javac13 ( ) ; } else { if ( isClassicCompilerSupported ) { task . log ( "Modern compiler not found - looking for " + "classic compiler" , Project . MSG_WARN ) ; return new Javac12 ( ) ; } else { throw new BuildException ( "Unable to find a javac " + "compiler;\n" + MODERN_COMPILER + " is not on the " + "classpath.\n" + "Perhaps JAVA_HOME does not" + " point to the JDK.\n" + "It is currently set to \"" + JavaEnvUtils . getJavaHome ( ) + "\"" ) ; } } } if ( compilerType . equalsIgnoreCase ( "jvc" ) || compilerType . equalsIgnoreCase ( "microsoft" ) ) { return new Jvc ( ) ; } if ( compilerType . equalsIgnoreCase ( "kjc" ) ) { return new Kjc ( ) ; } if ( compilerType . equalsIgnoreCase ( "gcj" ) ) { return new Gcj ( ) ; } if ( compilerType . equalsIgnoreCase ( "sj" ) || compilerType . equalsIgnoreCase ( "symantec" ) ) { return new Sj ( ) ; } return resolveClassName ( compilerType ) ; } private static boolean doesModernCompilerExist ( ) { try { Class . forName ( MODERN_COMPILER ) ; return true ; } catch ( ClassNotFoundException cnfe ) { try { ClassLoader cl = CompilerAdapterFactory . class . getClassLoader ( ) ; if ( cl != null ) { cl . loadClass ( MODERN_COMPILER ) ; return true ; } } catch ( ClassNotFoundException cnfe2 ) { } } return false ; } private static CompilerAdapter resolveClassName ( String className ) throws BuildException { return ( CompilerAdapter ) ClasspathUtils . newInstance ( className , CompilerAdapterFactory . class . getClassLoader ( ) , CompilerAdapter . class ) ; } } 	0	['4', '1', '0', '14', '27', '4', '1', '13', '1', '0.777777778', '221', '0.333333333', '0', '0', '0.333333333', '0', '0', '53.5', '3', '1.25', '0']
package org . apache . tools . ant . util ; import java . util . Hashtable ; import java . util . Enumeration ; public class LazyHashtable extends Hashtable { protected boolean initAllDone = false ; public LazyHashtable ( ) { super ( ) ; } protected void initAll ( ) { if ( initAllDone ) { return ; } initAllDone = true ; } public Enumeration elements ( ) { initAll ( ) ; return super . elements ( ) ; } public boolean isEmpty ( ) { initAll ( ) ; return super . isEmpty ( ) ; } public int size ( ) { initAll ( ) ; return super . size ( ) ; } public boolean contains ( Object value ) { initAll ( ) ; return super . contains ( value ) ; } public boolean containsKey ( Object value ) { initAll ( ) ; return super . containsKey ( value ) ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } public Enumeration keys ( ) { initAll ( ) ; return super . keys ( ) ; } } 	0	['9', '3', '0', '0', '16', '34', '0', '0', '8', '0', '60', '1', '0', '0.8', '0.666666667', '1', '1', '5.555555556', '2', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . text . ParseException ; import java . util . Locale ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . TimeComparison ; import org . apache . tools . ant . util . FileUtils ; public class DateSelector extends BaseExtendSelector { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private long millis = - 1 ; private String dateTime = null ; private boolean includeDirs = false ; private long granularity = 0 ; private String pattern ; private TimeComparison when = TimeComparison . EQUAL ; public static final String MILLIS_KEY = "millis" ; public static final String DATETIME_KEY = "datetime" ; public static final String CHECKDIRS_KEY = "checkdirs" ; public static final String GRANULARITY_KEY = "granularity" ; public static final String WHEN_KEY = "when" ; public static final String PATTERN_KEY = "pattern" ; public DateSelector ( ) { granularity = FILE_UTILS . getFileTimestampGranularity ( ) ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{dateselector date: " ) ; buf . append ( dateTime ) ; buf . append ( " compare: " ) . append ( when . getValue ( ) ) ; buf . append ( " granularity: " ) ; buf . append ( granularity ) ; if ( pattern != null ) { buf . append ( " pattern: " ) . append ( pattern ) ; } buf . append ( "}" ) ; return buf . toString ( ) ; } public void setMillis ( long millis ) { this . millis = millis ; } public long getMillis ( ) { if ( dateTime != null ) { validate ( ) ; } return millis ; } public void setDatetime ( String dateTime ) { this . dateTime = dateTime ; millis = - 1 ; } public void setCheckdirs ( boolean includeDirs ) { this . includeDirs = includeDirs ; } public void setGranularity ( int granularity ) { this . granularity = granularity ; } public void setWhen ( TimeComparisons tcmp ) { setWhen ( ( TimeComparison ) tcmp ) ; } public void setWhen ( TimeComparison t ) { when = t ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( MILLIS_KEY . equalsIgnoreCase ( paramname ) ) { try { setMillis ( new Long ( parameters [ i ] . getValue ( ) ) . longValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid millisecond setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( DATETIME_KEY . equalsIgnoreCase ( paramname ) ) { setDatetime ( parameters [ i ] . getValue ( ) ) ; } else if ( CHECKDIRS_KEY . equalsIgnoreCase ( paramname ) ) { setCheckdirs ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( GRANULARITY_KEY . equalsIgnoreCase ( paramname ) ) { try { setGranularity ( new Integer ( parameters [ i ] . getValue ( ) ) . intValue ( ) ) ; } catch ( NumberFormatException nfe ) { setError ( "Invalid granularity setting " + parameters [ i ] . getValue ( ) ) ; } } else if ( WHEN_KEY . equalsIgnoreCase ( paramname ) ) { setWhen ( new TimeComparison ( parameters [ i ] . getValue ( ) ) ) ; } else if ( PATTERN_KEY . equalsIgnoreCase ( paramname ) ) { setPattern ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( dateTime == null && millis < 0 ) { setError ( "You must provide a datetime or the number of " + "milliseconds." ) ; } else if ( millis < 0 && dateTime != null ) { DateFormat df = ( ( pattern == null ) ? DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT , Locale . US ) : new SimpleDateFormat ( pattern ) ) ; try { setMillis ( df . parse ( dateTime ) . getTime ( ) ) ; if ( millis < 0 ) { setError ( "Date of " + dateTime + " results in negative milliseconds value" + " relative to epoch (January 1, 1970, 00:00:00 GMT)." ) ; } } catch ( ParseException pe ) { setError ( "Date of " + dateTime + " Cannot be parsed correctly. It should be in" + ( ( pattern == null ) ? " MM/DD/YYYY HH:MM AM_PM" : pattern ) + " format." ) ; } } } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; return ( file . isDirectory ( ) && ! includeDirs ) || when . evaluate ( file . lastModified ( ) , millis , granularity ) ; } public static class TimeComparisons extends TimeComparison { } } 	0	['14', '5', '0', '12', '41', '29', '6', '6', '13', '0.875739645', '377', '0.538461538', '2', '0.76', '0.196581197', '1', '4', '25', '9', '2.2857', '0']
package org . apache . tools . ant . taskdefs . optional . script ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . taskdefs . DefBase ; import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Set ; import java . util . HashSet ; import java . io . File ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; public class ScriptDef extends DefBase { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner = null ; private String name ; private List attributes = new ArrayList ( ) ; private List nestedElements = new ArrayList ( ) ; private Set attributeSet ; private Map nestedElementMap ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; helper . setSetBeans ( false ) ; } public void setName ( String name ) { this . name = name ; } public boolean isAttributeSupported ( String attributeName ) { return attributeSet . contains ( attributeName ) ; } public static class Attribute { private String name ; public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } } public void addAttribute ( Attribute attribute ) { attributes . add ( attribute ) ; } public static class NestedElement { private String name ; private String type ; private String className ; public void setName ( String name ) { this . name = name . toLowerCase ( Locale . US ) ; } public void setType ( String type ) { this . type = type ; } public void setClassName ( String className ) { this . className = className ; } } public void addElement ( NestedElement nestedElement ) { nestedElements . add ( nestedElement ) ; } public void execute ( ) { if ( name == null ) { throw new BuildException ( "scriptdef requires a name attribute to " + "name the script" ) ; } if ( helper . getLanguage ( ) == null ) { throw new BuildException ( "<scriptdef> requires a language attribute " + "to specify the script language" ) ; } if ( getAntlibClassLoader ( ) != null || hasCpDelegate ( ) ) { helper . setClassLoader ( createLoader ( ) ) ; } runner = helper . getScriptRunner ( ) ; attributeSet = new HashSet ( ) ; for ( Iterator i = attributes . iterator ( ) ; i . hasNext ( ) ; ) { Attribute attribute = ( Attribute ) i . next ( ) ; if ( attribute . name == null ) { throw new BuildException ( "scriptdef <attribute> elements " + "must specify an attribute name" ) ; } if ( attributeSet . contains ( attribute . name ) ) { throw new BuildException ( "scriptdef <" + name + "> declares " + "the " + attribute . name + " attribute more than once" ) ; } attributeSet . add ( attribute . name ) ; } nestedElementMap = new HashMap ( ) ; for ( Iterator i = nestedElements . iterator ( ) ; i . hasNext ( ) ; ) { NestedElement nestedElement = ( NestedElement ) i . next ( ) ; if ( nestedElement . name == null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify an element name" ) ; } if ( nestedElementMap . containsKey ( nestedElement . name ) ) { throw new BuildException ( "scriptdef <" + name + "> declares " + "the " + nestedElement . name + " nested element more " + "than once" ) ; } if ( nestedElement . className == null && nestedElement . type == null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify either a classname or type attribute" ) ; } if ( nestedElement . className != null && nestedElement . type != null ) { throw new BuildException ( "scriptdef <element> elements " + "must specify only one of the classname and type " + "attributes" ) ; } nestedElementMap . put ( nestedElement . name , nestedElement ) ; } Map scriptRepository = null ; Project p = getProject ( ) ; synchronized ( p ) { scriptRepository = ( Map ) p . getReference ( MagicNames . SCRIPT_REPOSITORY ) ; if ( scriptRepository == null ) { scriptRepository = new HashMap ( ) ; p . addReference ( MagicNames . SCRIPT_REPOSITORY , scriptRepository ) ; } } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; scriptRepository . put ( name , this ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClass ( ScriptDefBase . class ) ; ComponentHelper . getComponentHelper ( getProject ( ) ) . addDataTypeDefinition ( def ) ; } public Object createNestedElement ( String elementName ) { NestedElement definition = ( NestedElement ) nestedElementMap . get ( elementName ) ; if ( definition == null ) { throw new BuildException ( "<" + name + "> does not support " + "the <" + elementName + "> nested element" ) ; } Object instance = null ; String classname = definition . className ; if ( classname == null ) { instance = getProject ( ) . createTask ( definition . type ) ; if ( instance == null ) { instance = getProject ( ) . createDataType ( definition . type ) ; } } else { ClassLoader loader = createLoader ( ) ; try { instance = ClasspathUtils . newInstance ( classname , loader ) ; } catch ( BuildException e ) { instance = ClasspathUtils . newInstance ( classname , ScriptDef . class . getClassLoader ( ) ) ; } getProject ( ) . setProjectReference ( instance ) ; } if ( instance == null ) { throw new BuildException ( "<" + name + "> is unable to create " + "the <" + elementName + "> nested element" ) ; } return instance ; } public void executeScript ( Map attributes , Map elements ) { executeScript ( attributes , elements , null ) ; } public void executeScript ( Map attributes , Map elements , ScriptDefBase instance ) { runner . addBean ( "attributes" , attributes ) ; runner . addBean ( "elements" , elements ) ; runner . addBean ( "project" , getProject ( ) ) ; if ( instance != null ) { runner . addBean ( "self" , instance ) ; } runner . executeScript ( "scriptdef_" + name ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } } 	0	['14', '5', '0', '14', '69', '25', '1', '14', '14', '0.837606838', '492', '0.777777778', '2', '0.805970149', '0.241071429', '1', '1', '33.5', '17', '2.5', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import java . io . File ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . AbstractSelectorContainer ; public class IsFileSelected extends AbstractSelectorContainer implements Condition { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private File file ; private File baseDir ; public void setFile ( File file ) { this . file = file ; } public void setBaseDir ( File baseDir ) { this . baseDir = baseDir ; } public void validate ( ) { if ( selectorCount ( ) != 1 ) { throw new BuildException ( "Only one selector allowed" ) ; } super . validate ( ) ; } public boolean eval ( ) { if ( file == null ) { throw new BuildException ( "file attribute not set" ) ; } validate ( ) ; File myBaseDir = baseDir ; if ( myBaseDir == null ) { myBaseDir = getProject ( ) . getBaseDir ( ) ; } FileSelector f = getSelectors ( getProject ( ) ) [ 0 ] ; return f . isSelected ( myBaseDir , FILE_UTILS . removeLeadingPath ( myBaseDir , file ) , file ) ; } } 	0	['6', '4', '0', '7', '16', '9', '1', '6', '5', '0.8', '72', '1', '1', '0.933333333', '0.7', '0', '0', '10.5', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . List ; import java . util . Vector ; import java . util . ArrayList ; import java . util . StringTokenizer ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . resources . Union ; import org . apache . tools . ant . util . FileNameMapper ; public class PathConvert extends Task { private static boolean onWindows = Os . isFamily ( "dos" ) ; private Union path = null ; private Reference refid = null ; private String targetOS = null ; private boolean targetWindows = false ; private boolean setonempty = true ; private String property = null ; private Vector prefixMap = new Vector ( ) ; private String pathSep = null ; private String dirSep = null ; private Mapper mapper = null ; public PathConvert ( ) { } public class MapEntry { private String from = null ; private String to = null ; public void setFrom ( String from ) { this . from = from ; } public void setTo ( String to ) { this . to = to ; } public String apply ( String elem ) { if ( from == null || to == null ) { throw new BuildException ( "Both 'from' and 'to' must be set " + "in a map entry" ) ; } String cmpElem = onWindows ? elem . toLowerCase ( ) . replace ( '\\' , '/' ) : elem ; String cmpFrom = onWindows ? from . toLowerCase ( ) . replace ( '\\' , '/' ) : from ; return cmpElem . startsWith ( cmpFrom ) ? to + elem . substring ( from . length ( ) ) : elem ; } } public static class TargetOs extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "windows" , "unix" , "netware" , "os/2" , "tandem" } ; } } public Path createPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Path result = new Path ( getProject ( ) ) ; add ( result ) ; return result ; } public void add ( ResourceCollection rc ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getPath ( ) . add ( rc ) ; } private synchronized Union getPath ( ) { if ( path == null ) { path = new Union ( ) ; path . setProject ( getProject ( ) ) ; } return path ; } public MapEntry createMap ( ) { MapEntry entry = new MapEntry ( ) ; prefixMap . addElement ( entry ) ; return entry ; } public void setTargetos ( String target ) { TargetOs to = new TargetOs ( ) ; to . setValue ( target ) ; setTargetos ( to ) ; } public void setTargetos ( TargetOs target ) { targetOS = target . getValue ( ) ; targetWindows = ! targetOS . equals ( "unix" ) && ! targetOS . equals ( "tandem" ) ; } public void setSetonempty ( boolean setonempty ) { this . setonempty = setonempty ; } public void setProperty ( String p ) { property = p ; } public void setRefid ( Reference r ) { if ( path != null ) { throw noChildrenAllowed ( ) ; } refid = r ; } public void setPathSep ( String sep ) { pathSep = sep ; } public void setDirSep ( String sep ) { dirSep = sep ; } public boolean isReference ( ) { return refid != null ; } public void execute ( ) throws BuildException { Union savedPath = path ; String savedPathSep = pathSep ; String savedDirSep = dirSep ; try { if ( isReference ( ) ) { Object o = refid . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof ResourceCollection ) ) { throw new BuildException ( "refid '" + refid . getRefId ( ) + "' does not refer to a resource collection." ) ; } getPath ( ) . add ( ( ResourceCollection ) o ) ; } validateSetup ( ) ; String fromDirSep = onWindows ? "\\" : "/" ; StringBuffer rslt = new StringBuffer ( ) ; String [ ] elems = path . list ( ) ; if ( mapper != null ) { FileNameMapper impl = mapper . getImplementation ( ) ; List ret = new ArrayList ( ) ; for ( int i = 0 ; i < elems . length ; ++ i ) { String [ ] mapped = impl . mapFileName ( elems [ i ] ) ; for ( int m = 0 ; mapped != null && m < mapped . length ; ++ m ) { ret . add ( mapped [ m ] ) ; } } elems = ( String [ ] ) ret . toArray ( new String [ ret . size ( ) ] ) ; } for ( int i = 0 ; i < elems . length ; i ++ ) { String elem = mapElement ( elems [ i ] ) ; if ( i != 0 ) { rslt . append ( pathSep ) ; } StringTokenizer stDirectory = new StringTokenizer ( elem , fromDirSep , true ) ; while ( stDirectory . hasMoreTokens ( ) ) { String token = stDirectory . nextToken ( ) ; rslt . append ( fromDirSep . equals ( token ) ? dirSep : token ) ; } } if ( setonempty || rslt . length ( ) > 0 ) { String value = rslt . toString ( ) ; if ( property == null ) { log ( value ) ; } else { log ( "Set property " + property + " = " + value , Project . MSG_VERBOSE ) ; getProject ( ) . setNewProperty ( property , value ) ; } } } finally { path = savedPath ; dirSep = savedDirSep ; pathSep = savedPathSep ; } } private String mapElement ( String elem ) { int size = prefixMap . size ( ) ; if ( size != 0 ) { for ( int i = 0 ; i < size ; i ++ ) { MapEntry entry = ( MapEntry ) prefixMap . elementAt ( i ) ; String newElem = entry . apply ( elem ) ; if ( newElem != elem ) { elem = newElem ; break ; } } } return elem ; } public void addMapper ( Mapper mapper ) { if ( this . mapper != null ) { throw new BuildException ( "Cannot define more than one mapper" ) ; } this . mapper = mapper ; } public void add ( FileNameMapper fileNameMapper ) { Mapper m = new Mapper ( getProject ( ) ) ; m . add ( fileNameMapper ) ; addMapper ( m ) ; } private void validateSetup ( ) throws BuildException { if ( path == null ) { throw new BuildException ( "You must specify a path to convert" ) ; } String dsep = File . separator ; String psep = File . pathSeparator ; if ( targetOS != null ) { psep = targetWindows ? ";" : ":" ; dsep = targetWindows ? "\\" : "/" ; } if ( pathSep != null ) { psep = pathSep ; } if ( dirSep != null ) { dsep = dirSep ; } pathSep = psep ; dirSep = dsep ; } private BuildException noChildrenAllowed ( ) { return new BuildException ( "You must not specify nested " + "elements when using the refid attribute." ) ; } } 	0	['21', '3', '0', '12', '61', '144', '1', '12', '15', '0.836363636', '507', '1', '3', '0.660714286', '0.1875', '2', '2', '22.61904762', '4', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; public class Jasper41Mangler implements JspMangler { public String mapJspToJavaName ( File jspFile ) { String jspUri = jspFile . getAbsolutePath ( ) ; int start = jspUri . lastIndexOf ( File . separatorChar ) + 1 ; int end = jspUri . length ( ) ; StringBuffer modifiedClassName ; modifiedClassName = new StringBuffer ( jspUri . length ( ) - start ) ; if ( ! Character . isJavaIdentifierStart ( jspUri . charAt ( start ) ) || jspUri . charAt ( start ) == '_' ) { modifiedClassName . append ( '_' ) ; } for ( int i = start ; i < end ; i ++ ) { char ch = jspUri . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( ch ) ) { modifiedClassName . append ( ch ) ; } else if ( ch == '.' ) { modifiedClassName . append ( '_' ) ; } else { modifiedClassName . append ( mangleChar ( ch ) ) ; } } return modifiedClassName . toString ( ) ; } private static String mangleChar ( char ch ) { String s = Integer . toHexString ( ch ) ; int nzeros = 5 - s . length ( ) ; char [ ] result = new char [ 6 ] ; result [ 0 ] = '_' ; for ( int i = 1 ; i <= nzeros ; i ++ ) { result [ i ] = '0' ; } for ( int i = nzeros + 1 , j = 0 ; i < 6 ; i ++ , j ++ ) { result [ i ] = s . charAt ( j ) ; } return new String ( result ) ; } public String mapPath ( String path ) { return null ; } } 	0	['4', '1', '0', '2', '17', '6', '1', '1', '3', '2', '127', '0', '0', '0', '0.375', '0', '0', '30.75', '6', '2.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public class Not implements ResourceSelector { private ResourceSelector sel ; public Not ( ) { } public Not ( ResourceSelector s ) { add ( s ) ; } public void add ( ResourceSelector s ) { if ( sel != null ) { throw new IllegalStateException ( "The Not ResourceSelector accepts a single nested ResourceSelector" ) ; } sel = s ; } public boolean isSelected ( Resource r ) { return ! ( sel . isSelected ( r ) ) ; } } 	0	['4', '1', '0', '5', '7', '4', '3', '2', '4', '0.333333333', '35', '1', '1', '0', '0.583333333', '0', '0', '7.5', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class MethodRefCPInfo extends ConstantPoolEntry { private String methodClassName ; private String methodName ; private String methodType ; private int classIndex ; private int nameAndTypeIndex ; public MethodRefCPInfo ( ) { super ( CONSTANT_METHODREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Method : Class = " + methodClassName + ", name = " + methodName + ", type = " + methodType ; } else { value = "Method : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo methodClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; methodClass . resolve ( constantPool ) ; methodClassName = methodClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; methodName = nt . getName ( ) ; methodType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String getMethodClassName ( ) { return methodClassName ; } public String getMethodName ( ) { return methodName ; } public String getMethodType ( ) { return methodType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . Writer ; import java . io . BufferedWriter ; import java . io . OutputStreamWriter ; import java . io . FileOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . LogLevel ; public class Echo extends Task { protected String message = "" ; protected File file = null ; protected boolean append = false ; private String encoding = "" ; protected int logLevel = Project . MSG_WARN ; public void execute ( ) throws BuildException { if ( file == null ) { log ( message , logLevel ) ; } else { Writer out = null ; try { String filename = file . getAbsolutePath ( ) ; if ( encoding == null || encoding . length ( ) == 0 ) { out = new FileWriter ( filename , append ) ; } else { out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( filename , append ) , encoding ) ) ; } out . write ( message , 0 , message . length ( ) ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { FileUtils . close ( out ) ; } } } public void setMessage ( String msg ) { this . message = msg ; } public void setFile ( File file ) { this . file = file ; } public void setAppend ( boolean append ) { this . append = append ; } public void addText ( String msg ) { message += getProject ( ) . replaceProperties ( msg ) ; } public void setLevel ( EchoLevel echoLevel ) { logLevel = echoLevel . getLevel ( ) ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public static class EchoLevel extends LogLevel { } } 	0	['8', '3', '0', '6', '27', '0', '0', '6', '8', '0.685714286', '141', '1', '0', '0.840909091', '0.35', '1', '1', '16', '1', '0.875', '0']
package org . apache . tools . ant . util ; import org . w3c . dom . CDATASection ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class DOMUtils { public static Document newDocument ( ) { return JAXPUtils . getDocumentBuilder ( ) . newDocument ( ) ; } public static Element createChildElement ( Element parent , String name ) { Document doc = parent . getOwnerDocument ( ) ; Element e = doc . createElement ( name ) ; parent . appendChild ( e ) ; return e ; } public static void appendText ( Element parent , String content ) { Document doc = parent . getOwnerDocument ( ) ; Text t = doc . createTextNode ( content ) ; parent . appendChild ( t ) ; } public static void appendCDATA ( Element parent , String content ) { Document doc = parent . getOwnerDocument ( ) ; CDATASection c = doc . createCDATASection ( content ) ; parent . appendChild ( c ) ; } public static void appendTextElement ( Element parent , String name , String content ) { Element e = createChildElement ( parent , name ) ; appendText ( e , content ) ; } public static void appendCDATAElement ( Element parent , String name , String content ) { Element e = createChildElement ( parent , name ) ; appendCDATA ( e , content ) ; } } 	0	['7', '1', '0', '3', '15', '21', '2', '1', '7', '2', '66', '0', '0', '0', '0.523809524', '0', '0', '8.428571429', '1', '0.8571', '0']
package org . apache . tools . ant . helper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Executor ; import org . apache . tools . ant . BuildException ; public class DefaultExecutor implements Executor { private static final SingleCheckExecutor SUB_EXECUTOR = new SingleCheckExecutor ( ) ; public void executeTargets ( Project project , String [ ] targetNames ) throws BuildException { BuildException thrownException = null ; for ( int i = 0 ; i < targetNames . length ; i ++ ) { try { project . executeTarget ( targetNames [ i ] ) ; } catch ( BuildException ex ) { if ( project . isKeepGoingMode ( ) ) { thrownException = ex ; } else { throw ex ; } } } if ( thrownException != null ) { throw thrownException ; } } public Executor getSubProjectExecutor ( ) { return SUB_EXECUTOR ; } } 	0	['4', '1', '0', '4', '8', '4', '0', '4', '3', '0.666666667', '45', '1', '1', '0', '0.555555556', '0', '0', '10', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class Compatability { private final String name ; Compatability ( final String name ) { this . name = name ; } public String toString ( ) { return name ; } } 	0	['2', '1', '0', '0', '3', '0', '0', '0', '1', '0', '12', '1', '0', '0', '0.75', '0', '0', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . vss ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; public class MSVSSGET extends MSVSS { Commandline buildCmdLine ( ) { Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getSSCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_GET ) ; if ( getVsspath ( ) == null ) { throw new BuildException ( "vsspath attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( getVsspath ( ) ) ; commandLine . createArgument ( ) . setValue ( getLocalpath ( ) ) ; commandLine . createArgument ( ) . setValue ( getAutoresponse ( ) ) ; commandLine . createArgument ( ) . setValue ( getQuiet ( ) ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; commandLine . createArgument ( ) . setValue ( getVersionDateLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritable ( ) ) ; commandLine . createArgument ( ) . setValue ( getLogin ( ) ) ; commandLine . createArgument ( ) . setValue ( getFileTimeStamp ( ) ) ; commandLine . createArgument ( ) . setValue ( getWritableFiles ( ) ) ; return commandLine ; } public void setLocalpath ( Path localPath ) { super . setInternalLocalPath ( localPath . toString ( ) ) ; } public final void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public final void setQuiet ( boolean quiet ) { super . setInternalQuiet ( quiet ) ; } public final void setWritable ( boolean writable ) { super . setInternalWritable ( writable ) ; } public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setDate ( String date ) { super . setInternalDate ( date ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setAutoresponse ( String response ) { super . setInternalAutoResponse ( response ) ; } public void setFileTimeStamp ( CurrentModUpdated timestamp ) { super . setInternalFileTimeStamp ( timestamp ) ; } public void setWritableFiles ( WritableFiles files ) { super . setInternalWritableFiles ( files ) ; } } 	0	['12', '4', '0', '8', '41', '66', '0', '8', '11', '2', '130', '0', '0', '0.892156863', '0.305555556', '1', '1', '9.833333333', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Diagnostics ; public class DiagnosticsTask extends Task { private static final String [ ] ARGS = new String [ 0 ] ; public void execute ( ) throws BuildException { Diagnostics . main ( ARGS ) ; } } 	0	['3', '3', '0', '3', '5', '1', '0', '3', '2', '0.5', '14', '1', '0', '0.973684211', '1', '0', '0', '3.333333333', '1', '0.3333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; public final class DeweyDecimal extends org . apache . tools . ant . util . DeweyDecimal { public DeweyDecimal ( final int [ ] components ) { super ( components ) ; } public DeweyDecimal ( final String string ) throws NumberFormatException { super ( string ) ; } } 	0	['2', '2', '0', '5', '4', '1', '4', '1', '2', '2', '10', '0', '0', '1', '0.666666667', '0', '0', '4', '0', '0', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class And extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( ! c . eval ( ) ) { return false ; } } return true ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant ; public class UnsupportedElementException extends BuildException { private String element ; public UnsupportedElementException ( String msg , String element ) { super ( msg ) ; this . element = element ; } public String getElement ( ) { return element ; } } 	0	['2', '5', '0', '3', '3', '0', '2', '1', '2', '0', '13', '1', '0', '0.954545455', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ccm ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMReconfigure extends Continuus { private String ccmProject = null ; private boolean recurse = false ; private boolean verbose = false ; public CCMReconfigure ( ) { super ( ) ; setCcmAction ( COMMAND_RECONFIGURE ) ; } public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; int result = 0 ; commandLine . setExecutable ( getCcmCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( getCcmAction ( ) ) ; checkOptions ( commandLine ) ; result = run ( commandLine ) ; if ( Execute . isFailure ( result ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( isRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( isVerbose ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_VERBOSE ) ; } if ( getCcmProject ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_PROJECT ) ; cmd . createArgument ( ) . setValue ( getCcmProject ( ) ) ; } } public String getCcmProject ( ) { return ccmProject ; } public void setCcmProject ( String v ) { this . ccmProject = v ; } public boolean isRecurse ( ) { return recurse ; } public void setRecurse ( boolean v ) { this . recurse = v ; } public boolean isVerbose ( ) { return verbose ; } public void setVerbose ( boolean v ) { this . verbose = v ; } public static final String FLAG_RECURSE = "/recurse" ; public static final String FLAG_VERBOSE = "/verbose" ; public static final String FLAG_PROJECT = "/project" ; } 	0	['9', '4', '0', '6', '25', '18', '0', '6', '8', '0.875', '120', '0.5', '0', '0.843137255', '0.361111111', '1', '1', '11.66666667', '4', '1.2222', '0']
package org . apache . tools . ant ; public interface Executor { void executeTargets ( Project project , String [ ] targetNames ) throws BuildException ; Executor getSubProjectExecutor ( ) ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.666666667', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . util . Stack ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . util . ConcatResourceInputStream ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . util . Tokenizer ; public class Tokens extends BaseResourceCollectionWrapper { private Tokenizer tokenizer ; private String encoding ; protected synchronized Collection getCollection ( ) { ResourceCollection rc = getResourceCollection ( ) ; if ( rc . size ( ) == 0 ) { return Collections . EMPTY_SET ; } if ( tokenizer == null ) { tokenizer = new LineTokenizer ( ) ; } ConcatResourceInputStream cat = new ConcatResourceInputStream ( rc ) ; cat . setManagingComponent ( this ) ; InputStreamReader rdr = null ; if ( encoding == null ) { rdr = new InputStreamReader ( cat ) ; } else { try { rdr = new InputStreamReader ( cat , encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new BuildException ( e ) ; } } ArrayList result = new ArrayList ( ) ; try { for ( String s = tokenizer . getToken ( rdr ) ; s != null ; s = tokenizer . getToken ( rdr ) ) { result . add ( new StringResource ( s ) ) ; } } catch ( IOException e ) { throw new BuildException ( "Error reading tokens" , e ) ; } return result ; } public synchronized void setEncoding ( String encoding ) { this . encoding = encoding ; } public synchronized void add ( Tokenizer tokenizer ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . tokenizer != null ) { throw new BuildException ( "Only one nested tokenizer allowed." ) ; } this . tokenizer = tokenizer ; } protected synchronized void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( tokenizer instanceof DataType ) { stk . push ( tokenizer ) ; invokeCircularReferenceCheck ( ( DataType ) tokenizer , stk , p ) ; } setChecked ( true ) ; } } } 	0	['5', '4', '0', '10', '27', '2', '0', '10', '3', '0.625', '146', '1', '1', '0.913043478', '0.36', '2', '5', '27.8', '5', '2', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; public class Javac13 extends DefaultCompilerAdapter { private static final int MODERN_COMPILER_SUCCESS = 0 ; public boolean execute ( ) throws BuildException { attributes . log ( "Using modern compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; try { Class c = Class . forName ( "com.sun.tools.javac.Main" ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == MODERN_COMPILER_SUCCESS ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting modern compiler" , ex , location ) ; } } } } 	0	['2', '2', '0', '6', '13', '1', '1', '5', '2', '2', '66', '1', '0', '0.958333333', '1', '0', '0', '31.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . OutputStream ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . types . Commandline ; public class Javac12 extends DefaultCompilerAdapter { protected static final String CLASSIC_COMPILER_CLASSNAME = "sun.tools.javac.Main" ; public boolean execute ( ) throws BuildException { attributes . log ( "Using classic compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupJavacCommand ( true ) ; OutputStream logstr = new LogOutputStream ( attributes , Project . MSG_WARN ) ; try { Class c = Class . forName ( CLASSIC_COMPILER_CLASSNAME ) ; Constructor cons = c . getConstructor ( new Class [ ] { OutputStream . class , String . class } ) ; Object compiler = cons . newInstance ( new Object [ ] { logstr , "javac" } ) ; Method compile = c . getMethod ( "compile" , new Class [ ] { String [ ] . class } ) ; Boolean ok = ( Boolean ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ; return ok . booleanValue ( ) ; } catch ( ClassNotFoundException ex ) { throw new BuildException ( "Cannot use classic compiler , as it is " + "not available. \n" + " A common solution is " + "to set the environment variable" + " JAVA_HOME to your jdk directory.\n" + "It is currently set to \"" + JavaEnvUtils . getJavaHome ( ) + "\"" , location ) ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error starting classic compiler: " , ex , location ) ; } } finally { FileUtils . close ( logstr ) ; } } } 	0	['2', '2', '0', '10', '22', '1', '1', '9', '2', '1.25', '163', '0.25', '0', '0.958333333', '1', '0', '0', '78.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Revert extends P4Base { private String revertChange = null ; private boolean onlyUnchanged = false ; public void setChange ( String revertChange ) throws BuildException { if ( revertChange == null || revertChange . equals ( "" ) ) { throw new BuildException ( "P4Revert: change cannot be null or empty" ) ; } this . revertChange = revertChange ; } public void setRevertOnlyUnchanged ( boolean onlyUnchanged ) { this . onlyUnchanged = onlyUnchanged ; } public void execute ( ) throws BuildException { String p4cmd = "-s revert" ; if ( onlyUnchanged ) { p4cmd += " -a" ; } if ( revertChange != null ) { p4cmd += " -c " + revertChange ; } execP4Command ( p4cmd + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['4', '4', '0', '4', '13', '0', '0', '4', '4', '0.333333333', '81', '1', '0', '0.944444444', '0.5', '1', '1', '18.75', '1', '0.75', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . util . LineTokenizer ; import org . apache . tools . ant . types . Parameter ; public final class HeadFilter extends BaseParamFilterReader implements ChainableReader { private static final String LINES_KEY = "lines" ; private static final String SKIP_KEY = "skip" ; private long linesRead = 0 ; private static final int DEFAULT_NUM_LINES = 10 ; private long lines = DEFAULT_NUM_LINES ; private long skip = 0 ; private LineTokenizer lineTokenizer = null ; private String line = null ; private int linePos = 0 ; public HeadFilter ( ) { super ( ) ; } public HeadFilter ( final Reader in ) { super ( in ) ; lineTokenizer = new LineTokenizer ( ) ; lineTokenizer . setIncludeDelims ( true ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } while ( line == null || line . length ( ) == 0 ) { line = lineTokenizer . getToken ( in ) ; if ( line == null ) { return - 1 ; } line = headFilter ( line ) ; linePos = 0 ; } int ch = line . charAt ( linePos ) ; linePos ++ ; if ( linePos == line . length ( ) ) { line = null ; } return ch ; } public void setLines ( final long lines ) { this . lines = lines ; } private long getLines ( ) { return lines ; } public void setSkip ( final long skip ) { this . skip = skip ; } private long getSkip ( ) { return skip ; } public Reader chain ( final Reader rdr ) { HeadFilter newFilter = new HeadFilter ( rdr ) ; newFilter . setLines ( getLines ( ) ) ; newFilter . setSkip ( getSkip ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( LINES_KEY . equals ( params [ i ] . getName ( ) ) ) { lines = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } if ( SKIP_KEY . equals ( params [ i ] . getName ( ) ) ) { skip = new Long ( params [ i ] . getValue ( ) ) . longValue ( ) ; continue ; } } } } private String headFilter ( String line ) { linesRead ++ ; if ( skip > 0 ) { if ( ( linesRead - 1 ) < skip ) { return null ; } } if ( lines > 0 ) { if ( linesRead > ( lines + skip ) ) { return null ; } } return line ; } } 	0	['10', '5', '0', '5', '25', '0', '1', '4', '6', '0.703703704', '251', '1', '1', '0.777777778', '0.375', '2', '4', '23.2', '5', '1.6', '0']
package org . apache . tools . ant . dispatch ; import org . apache . tools . ant . Task ; public abstract class DispatchTask extends Task implements Dispatchable { private String action ; public String getActionParameterName ( ) { return "action" ; } public void setAction ( String action ) { this . action = action ; } public String getAction ( ) { return action ; } } 	0	['4', '3', '1', '3', '5', '4', '1', '2', '4', '0.666666667', '17', '1', '0', '0.925', '0.625', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . types . resources ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . ByteArrayInputStream ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . util . PropertyOutputStream ; public class PropertyResource extends Resource { private static final int PROPERTY_MAGIC = Resource . getMagicNumber ( "PropertyResource" . getBytes ( ) ) ; private static final InputStream UNSET = new InputStream ( ) { public int read ( ) { return - 1 ; } } ; public PropertyResource ( ) { } public PropertyResource ( Project p , String n ) { super ( n ) ; setProject ( p ) ; } public String getValue ( ) { Project p = getProject ( ) ; return p == null ? null : p . getProperty ( getName ( ) ) ; } public boolean isExists ( ) { return getValue ( ) != null ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } return isExists ( ) ? ( long ) getValue ( ) . length ( ) : 0L ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return super . hashCode ( ) * PROPERTY_MAGIC ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } return String . valueOf ( getValue ( ) ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } return isExists ( ) ? new ByteArrayInputStream ( getValue ( ) . getBytes ( ) ) : UNSET ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } if ( isExists ( ) ) { throw new ImmutableResourceException ( ) ; } return new PropertyOutputStream ( getProject ( ) , getName ( ) ) ; } } 	0	['10', '4', '0', '6', '32', '41', '1', '5', '9', '0.888888889', '134', '1', '0', '0.883333333', '0.407407407', '1', '6', '12.2', '3', '1.3', '0']
package org . apache . tools . ant . taskdefs . optional . jsp ; import java . io . File ; import java . util . Date ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . optional . jsp . compilers . JspCompilerAdapter ; import org . apache . tools . ant . taskdefs . optional . jsp . compilers . JspCompilerAdapterFactory ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; public class JspC extends MatchingTask { private Path classpath ; private Path compilerClasspath ; private Path src ; private File destDir ; private String packageName ; private String compilerName = "jasper" ; private String iepluginid ; private boolean mapped ; private int verbose = 0 ; protected Vector compileList = new Vector ( ) ; Vector javaFiles = new Vector ( ) ; protected boolean failOnError = true ; private File uriroot ; private File webinc ; private File webxml ; protected WebAppParameter webApp ; private static final String FAIL_MSG = "Compile failed, messages should have been provided." ; public void setSrcDir ( Path srcDir ) { if ( src == null ) { src = srcDir ; } else { src . append ( srcDir ) ; } } public Path getSrcDir ( ) { return src ; } public void setDestdir ( File destDir ) { this . destDir = destDir ; } public File getDestdir ( ) { return destDir ; } public void setPackage ( String pkg ) { this . packageName = pkg ; } public String getPackage ( ) { return packageName ; } public void setVerbose ( int i ) { verbose = i ; } public int getVerbose ( ) { return verbose ; } public void setFailonerror ( boolean fail ) { failOnError = fail ; } public boolean getFailonerror ( ) { return failOnError ; } public String getIeplugin ( ) { return iepluginid ; } public void setIeplugin ( String iepluginid ) { this . iepluginid = iepluginid ; } public boolean isMapped ( ) { return mapped ; } public void setMapped ( boolean mapped ) { this . mapped = mapped ; } public void setUribase ( File uribase ) { log ( "Uribase is currently an unused parameter" , Project . MSG_WARN ) ; } public File getUribase ( ) { return uriroot ; } public void setUriroot ( File uriroot ) { this . uriroot = uriroot ; } public File getUriroot ( ) { return uriroot ; } public void setClasspath ( Path cp ) { if ( classpath == null ) { classpath = cp ; } else { classpath . append ( cp ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public Path getClasspath ( ) { return classpath ; } public void setCompilerclasspath ( Path cp ) { if ( compilerClasspath == null ) { compilerClasspath = cp ; } else { compilerClasspath . append ( cp ) ; } } public Path getCompilerclasspath ( ) { return compilerClasspath ; } public Path createCompilerclasspath ( ) { if ( compilerClasspath == null ) { compilerClasspath = new Path ( getProject ( ) ) ; } return compilerClasspath . createPath ( ) ; } public void setWebxml ( File webxml ) { this . webxml = webxml ; } public File getWebxml ( ) { return this . webxml ; } public void setWebinc ( File webinc ) { this . webinc = webinc ; } public File getWebinc ( ) { return this . webinc ; } public void addWebApp ( WebAppParameter webappParam ) throws BuildException { if ( webApp == null ) { webApp = webappParam ; } else { throw new BuildException ( "Only one webapp can be specified" ) ; } } public WebAppParameter getWebApp ( ) { return webApp ; } public void setCompiler ( String compiler ) { this . compilerName = compiler ; } public Vector getCompileList ( ) { return compileList ; } public void execute ( ) throws BuildException { if ( destDir == null ) { throw new BuildException ( "destdir attribute must be set!" , getLocation ( ) ) ; } if ( ! destDir . isDirectory ( ) ) { throw new BuildException ( "destination directory \"" + destDir + "\" does not exist or is not a directory" , getLocation ( ) ) ; } File dest = getActualDestDir ( ) ; JspCompilerAdapter compiler = JspCompilerAdapterFactory . getCompiler ( compilerName , this , getProject ( ) . createClassLoader ( compilerClasspath ) ) ; if ( webApp != null ) { doCompilation ( compiler ) ; return ; } if ( src == null ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } String [ ] list = src . list ( ) ; if ( list . length == 0 ) { throw new BuildException ( "srcdir attribute must be set!" , getLocation ( ) ) ; } if ( compiler . implementsOwnDependencyChecking ( ) ) { doCompilation ( compiler ) ; return ; } JspMangler mangler = compiler . createMangler ( ) ; resetFileLists ( ) ; int filecount = 0 ; for ( int i = 0 ; i < list . length ; i ++ ) { File srcDir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! srcDir . exists ( ) ) { throw new BuildException ( "srcdir \"" + srcDir . getPath ( ) + "\" does not exist!" , getLocation ( ) ) ; } DirectoryScanner ds = this . getDirectoryScanner ( srcDir ) ; String [ ] files = ds . getIncludedFiles ( ) ; filecount = files . length ; scanDir ( srcDir , dest , mangler , files ) ; } log ( "compiling " + compileList . size ( ) + " files" , Project . MSG_VERBOSE ) ; if ( compileList . size ( ) > 0 ) { log ( "Compiling " + compileList . size ( ) + " source file" + ( compileList . size ( ) == 1 ? "" : "s" ) + " to " + dest ) ; doCompilation ( compiler ) ; } else { if ( filecount == 0 ) { log ( "there were no files to compile" , Project . MSG_INFO ) ; } else { log ( "all files are up to date" , Project . MSG_VERBOSE ) ; } } } private File getActualDestDir ( ) { File dest = null ; if ( packageName == null ) { dest = destDir ; } else { String path = destDir . getPath ( ) + File . separatorChar + packageName . replace ( '.' , File . separatorChar ) ; dest = new File ( path ) ; } return dest ; } private void doCompilation ( JspCompilerAdapter compiler ) throws BuildException { compiler . setJspc ( this ) ; if ( ! compiler . execute ( ) ) { if ( failOnError ) { throw new BuildException ( FAIL_MSG , getLocation ( ) ) ; } else { log ( FAIL_MSG , Project . MSG_ERR ) ; } } } protected void resetFileLists ( ) { compileList . removeAllElements ( ) ; } protected void scanDir ( File srcDir , File dest , JspMangler mangler , String [ ] files ) { long now = ( new Date ( ) ) . getTime ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String filename = files [ i ] ; File srcFile = new File ( srcDir , filename ) ; File javaFile = mapToJavaFile ( mangler , srcFile , srcDir , dest ) ; if ( javaFile == null ) { continue ; } if ( srcFile . lastModified ( ) > now ) { log ( "Warning: file modified in the future: " + filename , Project . MSG_WARN ) ; } boolean shouldCompile = false ; shouldCompile = isCompileNeeded ( srcFile , javaFile ) ; if ( shouldCompile ) { compileList . addElement ( srcFile . getAbsolutePath ( ) ) ; javaFiles . addElement ( javaFile ) ; } } } private boolean isCompileNeeded ( File srcFile , File javaFile ) { boolean shouldCompile = false ; if ( ! javaFile . exists ( ) ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because java file " + javaFile . getPath ( ) + " does not exist" , Project . MSG_VERBOSE ) ; } else { if ( srcFile . lastModified ( ) > javaFile . lastModified ( ) ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because it is out of date with respect to " + javaFile . getPath ( ) , Project . MSG_VERBOSE ) ; } else { if ( javaFile . length ( ) == 0 ) { shouldCompile = true ; log ( "Compiling " + srcFile . getPath ( ) + " because java file " + javaFile . getPath ( ) + " is empty" , Project . MSG_VERBOSE ) ; } } } return shouldCompile ; } protected File mapToJavaFile ( JspMangler mangler , File srcFile , File srcDir , File dest ) { if ( ! srcFile . getName ( ) . endsWith ( ".jsp" ) ) { return null ; } String javaFileName = mangler . mapJspToJavaName ( srcFile ) ; return new File ( dest , javaFileName ) ; } public void deleteEmptyJavaFiles ( ) { if ( javaFiles != null ) { Enumeration e = javaFiles . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; if ( file . exists ( ) && file . length ( ) == 0 ) { log ( "deleting empty output file " + file ) ; file . delete ( ) ; } } } } public static class WebAppParameter { private File directory ; public File getDirectory ( ) { return directory ; } public void setBaseDir ( File directory ) { this . directory = directory ; } } } 	0	['42', '4', '0', '15', '92', '753', '3', '13', '36', '0.948350072', '707', '0.941176471', '4', '0.655462185', '0.140692641', '3', '3', '15.42857143', '5', '1.4048', '0']
package org . apache . tools . ant . util . depend ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Vector ; import java . util . zip . ZipFile ; import org . apache . tools . ant . types . Path ; public abstract class AbstractAnalyzer implements DependencyAnalyzer { public static final int MAX_LOOPS = 1000 ; private Path sourcePath = new Path ( null ) ; private Path classPath = new Path ( null ) ; private Vector rootClasses = new Vector ( ) ; private boolean determined = false ; private Vector fileDependencies ; private Vector classDependencies ; private boolean closure = true ; protected AbstractAnalyzer ( ) { reset ( ) ; } public void setClosure ( boolean closure ) { this . closure = closure ; } public Enumeration getFileDependencies ( ) { if ( ! supportsFileDependencies ( ) ) { throw new RuntimeException ( "File dependencies are not supported " + "by this analyzer" ) ; } if ( ! determined ) { determineDependencies ( fileDependencies , classDependencies ) ; } return fileDependencies . elements ( ) ; } public Enumeration getClassDependencies ( ) { if ( ! determined ) { determineDependencies ( fileDependencies , classDependencies ) ; } return classDependencies . elements ( ) ; } public File getClassContainer ( String classname ) throws IOException { String classLocation = classname . replace ( '.' , '/' ) + ".class" ; return getResourceContainer ( classLocation , classPath . list ( ) ) ; } public File getSourceContainer ( String classname ) throws IOException { String sourceLocation = classname . replace ( '.' , '/' ) + ".java" ; return getResourceContainer ( sourceLocation , sourcePath . list ( ) ) ; } public void addSourcePath ( Path sourcePath ) { if ( sourcePath == null ) { return ; } this . sourcePath . append ( sourcePath ) ; this . sourcePath . setProject ( sourcePath . getProject ( ) ) ; } public void addClassPath ( Path classPath ) { if ( classPath == null ) { return ; } this . classPath . append ( classPath ) ; this . classPath . setProject ( classPath . getProject ( ) ) ; } public void addRootClass ( String className ) { if ( className == null ) { return ; } if ( ! rootClasses . contains ( className ) ) { rootClasses . addElement ( className ) ; } } public void config ( String name , Object info ) { } public void reset ( ) { rootClasses . removeAllElements ( ) ; determined = false ; fileDependencies = new Vector ( ) ; classDependencies = new Vector ( ) ; } protected Enumeration getRootClasses ( ) { return rootClasses . elements ( ) ; } protected boolean isClosureRequired ( ) { return closure ; } protected abstract void determineDependencies ( Vector files , Vector classes ) ; protected abstract boolean supportsFileDependencies ( ) ; private File getResourceContainer ( String resourceLocation , String [ ] paths ) throws IOException { for ( int i = 0 ; i < paths . length ; ++ i ) { File element = new File ( paths [ i ] ) ; if ( ! element . exists ( ) ) { continue ; } if ( element . isDirectory ( ) ) { File resource = new File ( element , resourceLocation ) ; if ( resource . exists ( ) ) { return resource ; } } else { ZipFile zipFile = null ; try { zipFile = new ZipFile ( element ) ; if ( zipFile . getEntry ( resourceLocation ) != null ) { return element ; } } finally { if ( zipFile != null ) { zipFile . close ( ) ; } } } } return null ; } } 	0	['16', '1', '3', '6', '40', '80', '3', '3', '10', '0.858333333', '254', '0.875', '2', '0', '0.241071429', '0', '0', '14.375', '3', '1.375', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . InputStream ; import java . io . Reader ; public class ReaderInputStream extends InputStream { private Reader in ; private String encoding = System . getProperty ( "file.encoding" ) ; private byte [ ] slack ; private int begin ; public ReaderInputStream ( Reader reader ) { in = reader ; } public ReaderInputStream ( Reader reader , String encoding ) { this ( reader ) ; if ( encoding == null ) { throw new IllegalArgumentException ( "encoding must not be null" ) ; } else { this . encoding = encoding ; } } public synchronized int read ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } byte result ; if ( slack != null && begin < slack . length ) { result = slack [ begin ] ; if ( ++ begin == slack . length ) { slack = null ; } } else { byte [ ] buf = new byte [ 1 ] ; if ( read ( buf , 0 , 1 ) <= 0 ) { return - 1 ; } else { result = buf [ 0 ] ; } } return result & 0xFF ; } public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( len == 0 ) { return 0 ; } while ( slack == null ) { char [ ] buf = new char [ len ] ; int n = in . read ( buf ) ; if ( n == - 1 ) { return - 1 ; } if ( n > 0 ) { slack = new String ( buf , 0 , n ) . getBytes ( encoding ) ; begin = 0 ; } } if ( len > slack . length - begin ) { len = slack . length - begin ; } System . arraycopy ( slack , begin , b , off , len ) ; if ( ( begin += len ) >= slack . length ) { slack = null ; } return len ; } public synchronized void mark ( final int limit ) { try { in . mark ( limit ) ; } catch ( IOException ioe ) { throw new RuntimeException ( ioe . getMessage ( ) ) ; } } public synchronized int available ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } if ( slack != null ) { return slack . length - begin ; } if ( in . ready ( ) ) { return 1 ; } else { return 0 ; } } public boolean markSupported ( ) { return false ; } public synchronized void reset ( ) throws IOException { if ( in == null ) { throw new IOException ( "Stream Closed" ) ; } slack = null ; in . reset ( ) ; } public synchronized void close ( ) throws IOException { if ( in != null ) { in . close ( ) ; slack = null ; in = null ; } } } 	0	['9', '2', '1', '2', '23', '0', '2', '0', '9', '0.5', '246', '1', '0', '0.5625', '0.333333333', '1', '2', '25.88888889', '1', '0.7778', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . FileUtils ; public class ContainsSelector extends BaseExtendSelector implements ResourceSelector { private String contains = null ; private boolean casesensitive = true ; private boolean ignorewhitespace = false ; public static final String EXPRESSION_KEY = "expression" ; public static final String CONTAINS_KEY = "text" ; public static final String CASE_KEY = "casesensitive" ; public static final String WHITESPACE_KEY = "ignorewhitespace" ; public ContainsSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsselector text: " ) ; buf . append ( '"' ) . append ( contains ) . append ( '"' ) ; buf . append ( " casesensitive: " ) ; buf . append ( casesensitive ? "true" : "false" ) ; buf . append ( " ignorewhitespace: " ) ; buf . append ( ignorewhitespace ? "true" : "false" ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setText ( String contains ) { this . contains = contains ; } public void setCasesensitive ( boolean casesensitive ) { this . casesensitive = casesensitive ; } public void setIgnorewhitespace ( boolean ignorewhitespace ) { this . ignorewhitespace = ignorewhitespace ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( CONTAINS_KEY . equalsIgnoreCase ( paramname ) ) { setText ( parameters [ i ] . getValue ( ) ) ; } else if ( CASE_KEY . equalsIgnoreCase ( paramname ) ) { setCasesensitive ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else if ( WHITESPACE_KEY . equalsIgnoreCase ( paramname ) ) { setIgnorewhitespace ( Project . toBoolean ( parameters [ i ] . getValue ( ) ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( contains == null ) { setError ( "The text attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( new FileResource ( file ) ) ; } public boolean isSelected ( Resource r ) { validate ( ) ; if ( r . isDirectory ( ) ) { return true ; } String userstr = contains ; if ( ! casesensitive ) { userstr = contains . toLowerCase ( ) ; } if ( ignorewhitespace ) { userstr = SelectorUtils . removeWhitespace ( userstr ) ; } BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( r . getInputStream ( ) ) ) ; } catch ( Exception e ) { throw new BuildException ( "Could not get InputStream from " + r . toLongString ( ) , e ) ; } try { String teststr = in . readLine ( ) ; while ( teststr != null ) { if ( ! casesensitive ) { teststr = teststr . toLowerCase ( ) ; } if ( ignorewhitespace ) { teststr = SelectorUtils . removeWhitespace ( teststr ) ; } if ( teststr . indexOf ( userstr ) > - 1 ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read " + r . toLongString ( ) ) ; } finally { FileUtils . close ( in ) ; } } } 	0	['9', '5', '0', '15', '34', '4', '6', '9', '9', '0.785714286', '266', '0.428571429', '0', '0.826086957', '0.296296296', '1', '4', '27.77777778', '11', '2.8889', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . util . JavaEnvUtils ; public class GenerateKey extends Task { public static class DnameParam { private String name ; private String value ; public void setName ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public void setValue ( String value ) { this . value = value ; } public String getValue ( ) { return value ; } } public static class DistinguishedName { private Vector params = new Vector ( ) ; public Object createParam ( ) { DnameParam param = new DnameParam ( ) ; params . addElement ( param ) ; return param ; } public Enumeration getParams ( ) { return params . elements ( ) ; } public String toString ( ) { final int size = params . size ( ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean firstPass = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( ! firstPass ) { sb . append ( " ," ) ; } firstPass = false ; final DnameParam param = ( DnameParam ) params . elementAt ( i ) ; sb . append ( encode ( param . getName ( ) ) ) ; sb . append ( '=' ) ; sb . append ( encode ( param . getValue ( ) ) ) ; } return sb . toString ( ) ; } public String encode ( final String string ) { int end = string . indexOf ( ',' ) ; if ( - 1 == end ) { return string ; } final StringBuffer sb = new StringBuffer ( ) ; int start = 0 ; while ( - 1 != end ) { sb . append ( string . substring ( start , end ) ) ; sb . append ( "\\," ) ; start = end + 1 ; end = string . indexOf ( ',' , start ) ; } sb . append ( string . substring ( start ) ) ; return sb . toString ( ) ; } } protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected String sigalg ; protected String keyalg ; protected String dname ; protected DistinguishedName expandedDname ; protected int keysize ; protected int validity ; protected boolean verbose ; public DistinguishedName createDname ( ) throws BuildException { if ( null != expandedDname ) { throw new BuildException ( "DName sub-element can only be " + "specified once." ) ; } if ( null != dname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } expandedDname = new DistinguishedName ( ) ; return expandedDname ; } public void setDname ( final String dname ) { if ( null != expandedDname ) { throw new BuildException ( "It is not possible to specify dname " + " both as attribute and element." ) ; } this . dname = dname ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setSigalg ( final String sigalg ) { this . sigalg = sigalg ; } public void setKeyalg ( final String keyalg ) { this . keyalg = keyalg ; } public void setKeysize ( final String keysize ) throws BuildException { try { this . keysize = Integer . parseInt ( keysize ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "KeySize attribute should be a integer" ) ; } } public void setValidity ( final String validity ) throws BuildException { try { this . validity = Integer . parseInt ( validity ) ; } catch ( final NumberFormatException nfe ) { throw new BuildException ( "Validity attribute should be a integer" ) ; } } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void execute ( ) throws BuildException { if ( null == alias ) { throw new BuildException ( "alias attribute must be set" ) ; } if ( null == storepass ) { throw new BuildException ( "storepass attribute must be set" ) ; } if ( null == dname && null == expandedDname ) { throw new BuildException ( "dname must be set" ) ; } final StringBuffer sb = new StringBuffer ( ) ; sb . append ( "-genkey " ) ; if ( verbose ) { sb . append ( "-v " ) ; } sb . append ( "-alias \"" ) ; sb . append ( alias ) ; sb . append ( "\" " ) ; if ( null != dname ) { sb . append ( "-dname \"" ) ; sb . append ( dname ) ; sb . append ( "\" " ) ; } if ( null != expandedDname ) { sb . append ( "-dname \"" ) ; sb . append ( expandedDname ) ; sb . append ( "\" " ) ; } if ( null != keystore ) { sb . append ( "-keystore \"" ) ; sb . append ( keystore ) ; sb . append ( "\" " ) ; } if ( null != storepass ) { sb . append ( "-storepass \"" ) ; sb . append ( storepass ) ; sb . append ( "\" " ) ; } if ( null != storetype ) { sb . append ( "-storetype \"" ) ; sb . append ( storetype ) ; sb . append ( "\" " ) ; } sb . append ( "-keypass \"" ) ; if ( null != keypass ) { sb . append ( keypass ) ; } else { sb . append ( storepass ) ; } sb . append ( "\" " ) ; if ( null != sigalg ) { sb . append ( "-sigalg \"" ) ; sb . append ( sigalg ) ; sb . append ( "\" " ) ; } if ( null != keyalg ) { sb . append ( "-keyalg \"" ) ; sb . append ( keyalg ) ; sb . append ( "\" " ) ; } if ( 0 < keysize ) { sb . append ( "-keysize \"" ) ; sb . append ( keysize ) ; sb . append ( "\" " ) ; } if ( 0 < validity ) { sb . append ( "-validity \"" ) ; sb . append ( validity ) ; sb . append ( "\" " ) ; } log ( "Generating Key for " + alias ) ; final ExecTask cmd = new ExecTask ( this ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( "keytool" ) ) ; Commandline . Argument arg = cmd . createArg ( ) ; arg . setLine ( sb . toString ( ) ) ; cmd . setFailonerror ( true ) ; cmd . setTaskName ( getTaskName ( ) ) ; cmd . execute ( ) ; } } 	0	['14', '3', '0', '6', '34', '65', '0', '6', '14', '0.91025641', '378', '1', '1', '0.74', '0.595238095', '1', '1', '25.14285714', '2', '1', '0']
package org . apache . tools . ant . taskdefs ; public class Typedef extends Definer { } 	0	['1', '6', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . helper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Executor ; import org . apache . tools . ant . BuildException ; public class SingleCheckExecutor implements Executor { public void executeTargets ( Project project , String [ ] targetNames ) throws BuildException { project . executeSortedTargets ( project . topoSort ( targetNames , project . getTargets ( ) , false ) ) ; } public Executor getSubProjectExecutor ( ) { return this ; } } 	0	['3', '1', '0', '4', '7', '3', '1', '3', '3', '2', '17', '0', '0', '0', '0.555555556', '0', '0', '4.666666667', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . math . BigInteger ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class Resource extends DataType implements Cloneable , Comparable , ResourceCollection { public static final long UNKNOWN_SIZE = - 1 ; public static final long UNKNOWN_DATETIME = 0L ; protected static final int MAGIC = getMagicNumber ( "Resource" . getBytes ( ) ) ; private static final int NULL_NAME = getMagicNumber ( "null name" . getBytes ( ) ) ; protected static int getMagicNumber ( byte [ ] seed ) { return new BigInteger ( seed ) . intValue ( ) ; } private String name = null ; private Boolean exists = null ; private Long lastmodified = null ; private Boolean directory = null ; private Long size = null ; public Resource ( ) { } public Resource ( String name ) { this ( name , false , 0 , false ) ; } public Resource ( String name , boolean exists , long lastmodified ) { this ( name , exists , lastmodified , false ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory ) { this ( name , exists , lastmodified , directory , UNKNOWN_SIZE ) ; } public Resource ( String name , boolean exists , long lastmodified , boolean directory , long size ) { this . name = name ; setName ( name ) ; setExists ( exists ) ; setLastModified ( lastmodified ) ; setDirectory ( directory ) ; setSize ( size ) ; } public String getName ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getName ( ) : name ; } public void setName ( String name ) { checkAttributesAllowed ( ) ; this . name = name ; } public boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } return exists == null || exists . booleanValue ( ) ; } public void setExists ( boolean exists ) { checkAttributesAllowed ( ) ; this . exists = exists ? Boolean . TRUE : Boolean . FALSE ; } public long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } if ( ! isExists ( ) || lastmodified == null ) { return UNKNOWN_DATETIME ; } long result = lastmodified . longValue ( ) ; return result < UNKNOWN_DATETIME ? UNKNOWN_DATETIME : result ; } public void setLastModified ( long lastmodified ) { checkAttributesAllowed ( ) ; this . lastmodified = new Long ( lastmodified ) ; } public boolean isDirectory ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) ; } return directory != null && directory . booleanValue ( ) ; } public void setDirectory ( boolean directory ) { checkAttributesAllowed ( ) ; this . directory = directory ? Boolean . TRUE : Boolean . FALSE ; } public void setSize ( long size ) { checkAttributesAllowed ( ) ; this . size = new Long ( size > UNKNOWN_SIZE ? size : UNKNOWN_SIZE ) ; } public long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } return isExists ( ) ? ( size != null ? size . longValue ( ) : UNKNOWN_SIZE ) : 0L ; } public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new UnsupportedOperationException ( "CloneNotSupportedException for a Resource caught. " + "Derived classes must support cloning." ) ; } } public int compareTo ( Object other ) { if ( isReference ( ) ) { return ( ( Comparable ) getCheckedRef ( ) ) . compareTo ( other ) ; } if ( ! ( other instanceof Resource ) ) { throw new IllegalArgumentException ( "Can only be compared with Resources" ) ; } return toString ( ) . compareTo ( other . toString ( ) ) ; } public boolean equals ( Object other ) { if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( other ) ; } return other . getClass ( ) . equals ( getClass ( ) ) && compareTo ( other ) == 0 ; } public int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } String name = getName ( ) ; return MAGIC * ( name == null ? NULL_NAME : name . hashCode ( ) ) ; } public InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } throw new UnsupportedOperationException ( ) ; } public OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } throw new UnsupportedOperationException ( ) ; } public Iterator iterator ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . iterator ( ) : new Iterator ( ) { private boolean done = false ; public boolean hasNext ( ) { return ! done ; } public Object next ( ) { if ( done ) { throw new NoSuchElementException ( ) ; } done = true ; return Resource . this ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public int size ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . size ( ) : 1 ; } public boolean isFilesystemOnly ( ) { return isReference ( ) && ( ( Resource ) getCheckedRef ( ) ) . isFilesystemOnly ( ) ; } public String toString ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . toString ( ) ; } String n = getName ( ) ; return n == null ? "(anonymous)" : n ; } public final String toLongString ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . toLongString ( ) : getDataTypeName ( ) + " \"" + toString ( ) + '"' ; } public void setRefid ( Reference r ) { if ( name != null || exists != null || lastmodified != null || directory != null || size != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } } 	0	['29', '3', '7', '89', '59', '328', '85', '5', '27', '0.880952381', '471', '0.777777778', '0', '0.566037736', '0.234693878', '3', '4', '14.93103448', '6', '2.0345', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import java . io . File ; import java . util . Vector ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . FileSet ; public class P4Add extends P4Base { private static final int DEFAULT_CMD_LENGTH = 450 ; private int changelist ; private String addCmd = "" ; private Vector filesets = new Vector ( ) ; private int cmdLength = DEFAULT_CMD_LENGTH ; public void setCommandlength ( int len ) throws BuildException { if ( len <= 0 ) { throw new BuildException ( "P4Add: Commandlength should be a positive number" ) ; } this . cmdLength = len ; } public void setChangelist ( int changelist ) throws BuildException { if ( changelist <= 0 ) { throw new BuildException ( "P4Add: Changelist# should be a positive number" ) ; } this . changelist = changelist ; } public void addFileset ( FileSet set ) { filesets . addElement ( set ) ; } public void execute ( ) throws BuildException { if ( P4View != null ) { addCmd = P4View ; } P4CmdOpts = ( changelist > 0 ) ? ( "-c " + changelist ) : "" ; StringBuffer filelist = new StringBuffer ( ) ; for ( int i = 0 ; i < filesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) filesets . elementAt ( i ) ; DirectoryScanner ds = fs . getDirectoryScanner ( getProject ( ) ) ; String [ ] srcFiles = ds . getIncludedFiles ( ) ; if ( srcFiles != null ) { for ( int j = 0 ; j < srcFiles . length ; j ++ ) { File f = new File ( ds . getBasedir ( ) , srcFiles [ j ] ) ; filelist . append ( " " ) . append ( '"' ) . append ( f . getAbsolutePath ( ) ) . append ( '"' ) ; if ( filelist . length ( ) > cmdLength ) { execP4Add ( filelist ) ; filelist = new StringBuffer ( ) ; } } if ( filelist . length ( ) > 0 ) { execP4Add ( filelist ) ; } } else { log ( "No files specified to add!" , Project . MSG_WARN ) ; } } } private void execP4Add ( StringBuffer list ) { log ( "Execing add " + P4CmdOpts + " " + addCmd + list , Project . MSG_INFO ) ; execP4Command ( "-s add " + P4CmdOpts + " " + addCmd + list , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['6', '4', '0', '7', '29', '0', '0', '7', '5', '0.76', '195', '1', '0', '0.910714286', '0.416666667', '0', '0', '30.66666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . text . DateFormat ; import java . text . DecimalFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; public class PropertyFile extends Task { private String comment ; private Properties properties ; private File propertyfile ; private Vector entries = new Vector ( ) ; public void execute ( ) throws BuildException { checkParameters ( ) ; readFile ( ) ; executeOperation ( ) ; writeFile ( ) ; } public Entry createEntry ( ) { Entry e = new Entry ( ) ; entries . addElement ( e ) ; return e ; } private void executeOperation ( ) throws BuildException { for ( Enumeration e = entries . elements ( ) ; e . hasMoreElements ( ) ; ) { Entry entry = ( Entry ) e . nextElement ( ) ; entry . executeOn ( properties ) ; } } private void readFile ( ) throws BuildException { properties = new Properties ( ) ; try { if ( propertyfile . exists ( ) ) { log ( "Updating property file: " + propertyfile . getAbsolutePath ( ) ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( propertyfile ) ; BufferedInputStream bis = new BufferedInputStream ( fis ) ; properties . load ( bis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } } else { log ( "Creating new property file: " + propertyfile . getAbsolutePath ( ) ) ; FileOutputStream out = null ; try { out = new FileOutputStream ( propertyfile . getAbsolutePath ( ) ) ; out . flush ( ) ; } finally { if ( out != null ) { out . close ( ) ; } } } } catch ( IOException ioe ) { throw new BuildException ( ioe . toString ( ) ) ; } } private void checkParameters ( ) throws BuildException { if ( ! checkParam ( propertyfile ) ) { throw new BuildException ( "file token must not be null." , getLocation ( ) ) ; } } public void setFile ( File file ) { propertyfile = file ; } public void setComment ( String hdr ) { comment = hdr ; } private void writeFile ( ) throws BuildException { BufferedOutputStream bos = null ; try { bos = new BufferedOutputStream ( new FileOutputStream ( propertyfile ) ) ; properties . store ( bos , comment ) ; } catch ( IOException ioe ) { throw new BuildException ( ioe , getLocation ( ) ) ; } finally { FileUtils . close ( bos ) ; } } private boolean checkParam ( File param ) { return ! ( param == null ) ; } public static class Entry { private static final int DEFAULT_INT_VALUE = 0 ; private static final String DEFAULT_DATE_VALUE = "now" ; private static final String DEFAULT_STRING_VALUE = "" ; private String key = null ; private int type = Type . STRING_TYPE ; private int operation = Operation . EQUALS_OPER ; private String value = null ; private String defaultValue = null ; private String newValue = null ; private String pattern = null ; private int field = Calendar . DATE ; public void setKey ( String value ) { this . key = value ; } public void setValue ( String value ) { this . value = value ; } public void setOperation ( Operation value ) { this . operation = Operation . toOperation ( value . getValue ( ) ) ; } public void setType ( Type value ) { this . type = Type . toType ( value . getValue ( ) ) ; } public void setDefault ( String value ) { this . defaultValue = value ; } public void setPattern ( String value ) { this . pattern = value ; } public void setUnit ( PropertyFile . Unit unit ) { field = unit . getCalendarField ( ) ; } protected void executeOn ( Properties props ) throws BuildException { checkParameters ( ) ; String oldValue = ( String ) props . get ( key ) ; try { if ( type == Type . INTEGER_TYPE ) { executeInteger ( oldValue ) ; } else if ( type == Type . DATE_TYPE ) { executeDate ( oldValue ) ; } else if ( type == Type . STRING_TYPE ) { executeString ( oldValue ) ; } else { throw new BuildException ( "Unknown operation type: " + type ) ; } } catch ( NullPointerException npe ) { npe . printStackTrace ( ) ; } if ( newValue == null ) { newValue = "" ; } props . put ( key , newValue ) ; } private void executeDate ( String oldValue ) throws BuildException { Calendar currentValue = Calendar . getInstance ( ) ; if ( pattern == null ) { pattern = "yyyy/MM/dd HH:mm" ; } DateFormat fmt = new SimpleDateFormat ( pattern ) ; String currentStringValue = getCurrentValue ( oldValue ) ; if ( currentStringValue == null ) { currentStringValue = DEFAULT_DATE_VALUE ; } if ( "now" . equals ( currentStringValue ) ) { currentValue . setTime ( new Date ( ) ) ; } else { try { currentValue . setTime ( fmt . parse ( currentStringValue ) ) ; } catch ( ParseException pe ) { } } if ( operation != Operation . EQUALS_OPER ) { int offset = 0 ; try { offset = Integer . parseInt ( value ) ; if ( operation == Operation . DECREMENT_OPER ) { offset = - 1 * offset ; } } catch ( NumberFormatException e ) { throw new BuildException ( "Value not an integer on " + key ) ; } currentValue . add ( field , offset ) ; } newValue = fmt . format ( currentValue . getTime ( ) ) ; } private void executeInteger ( String oldValue ) throws BuildException { int currentValue = DEFAULT_INT_VALUE ; int newV = DEFAULT_INT_VALUE ; DecimalFormat fmt = ( pattern != null ) ? new DecimalFormat ( pattern ) : new DecimalFormat ( ) ; try { String curval = getCurrentValue ( oldValue ) ; if ( curval != null ) { currentValue = fmt . parse ( curval ) . intValue ( ) ; } else { currentValue = 0 ; } } catch ( NumberFormatException nfe ) { } catch ( ParseException pe ) { } if ( operation == Operation . EQUALS_OPER ) { newV = currentValue ; } else { int operationValue = 1 ; if ( value != null ) { try { operationValue = fmt . parse ( value ) . intValue ( ) ; } catch ( NumberFormatException nfe ) { } catch ( ParseException pe ) { } } if ( operation == Operation . INCREMENT_OPER ) { newV = currentValue + operationValue ; } else if ( operation == Operation . DECREMENT_OPER ) { newV = currentValue - operationValue ; } } this . newValue = fmt . format ( newV ) ; } private void executeString ( String oldValue ) throws BuildException { String newV = DEFAULT_STRING_VALUE ; String currentValue = getCurrentValue ( oldValue ) ; if ( currentValue == null ) { currentValue = DEFAULT_STRING_VALUE ; } if ( operation == Operation . EQUALS_OPER ) { newV = currentValue ; } else if ( operation == Operation . INCREMENT_OPER ) { newV = currentValue + value ; } this . newValue = newV ; } private void checkParameters ( ) throws BuildException { if ( type == Type . STRING_TYPE && operation == Operation . DECREMENT_OPER ) { throw new BuildException ( "- is not supported for string " + "properties (key:" + key + ")" ) ; } if ( value == null && defaultValue == null ) { throw new BuildException ( "\"value\" and/or \"default\" " + "attribute must be specified (key:" + key + ")" ) ; } if ( key == null ) { throw new BuildException ( "key is mandatory" ) ; } if ( type == Type . STRING_TYPE && pattern != null ) { throw new BuildException ( "pattern is not supported for string " + "properties (key:" + key + ")" ) ; } } private String getCurrentValue ( String oldValue ) { String ret = null ; if ( operation == Operation . EQUALS_OPER ) { if ( value != null && defaultValue == null ) { ret = value ; } if ( value == null && defaultValue != null && oldValue != null ) { ret = oldValue ; } if ( value == null && defaultValue != null && oldValue == null ) { ret = defaultValue ; } if ( value != null && defaultValue != null && oldValue != null ) { ret = value ; } if ( value != null && defaultValue != null && oldValue == null ) { ret = defaultValue ; } } else { ret = ( oldValue == null ) ? defaultValue : oldValue ; } return ret ; } public static class Operation extends EnumeratedAttribute { public static final int INCREMENT_OPER = 0 ; public static final int DECREMENT_OPER = 1 ; public static final int EQUALS_OPER = 2 ; public String [ ] getValues ( ) { return new String [ ] { "+" , "-" , "=" } ; } public static int toOperation ( String oper ) { if ( "+" . equals ( oper ) ) { return INCREMENT_OPER ; } else if ( "-" . equals ( oper ) ) { return DECREMENT_OPER ; } return EQUALS_OPER ; } } public static class Type extends EnumeratedAttribute { public static final int INTEGER_TYPE = 0 ; public static final int DATE_TYPE = 1 ; public static final int STRING_TYPE = 2 ; public String [ ] getValues ( ) { return new String [ ] { "int" , "date" , "string" } ; } public static int toType ( String type ) { if ( "int" . equals ( type ) ) { return INTEGER_TYPE ; } else if ( "date" . equals ( type ) ) { return DATE_TYPE ; } return STRING_TYPE ; } } } public static class Unit extends EnumeratedAttribute { private static final String MILLISECOND = "millisecond" ; private static final String SECOND = "second" ; private static final String MINUTE = "minute" ; private static final String HOUR = "hour" ; private static final String DAY = "day" ; private static final String WEEK = "week" ; private static final String MONTH = "month" ; private static final String YEAR = "year" ; private static final String [ ] UNITS = { MILLISECOND , SECOND , MINUTE , HOUR , DAY , WEEK , MONTH , YEAR } ; private Map calendarFields = new HashMap ( ) ; public Unit ( ) { calendarFields . put ( MILLISECOND , new Integer ( Calendar . MILLISECOND ) ) ; calendarFields . put ( SECOND , new Integer ( Calendar . SECOND ) ) ; calendarFields . put ( MINUTE , new Integer ( Calendar . MINUTE ) ) ; calendarFields . put ( HOUR , new Integer ( Calendar . HOUR_OF_DAY ) ) ; calendarFields . put ( DAY , new Integer ( Calendar . DATE ) ) ; calendarFields . put ( WEEK , new Integer ( Calendar . WEEK_OF_YEAR ) ) ; calendarFields . put ( MONTH , new Integer ( Calendar . MONTH ) ) ; calendarFields . put ( YEAR , new Integer ( Calendar . YEAR ) ) ; } public int getCalendarField ( ) { String key = getValue ( ) . toLowerCase ( ) ; Integer i = ( Integer ) calendarFields . get ( key ) ; return i . intValue ( ) ; } public String [ ] getValues ( ) { return UNITS ; } } } 	0	['10', '3', '0', '5', '41', '21', '0', '5', '5', '0.666666667', '214', '1', '0', '0.804347826', '0.433333333', '0', '0', '20', '2', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . helper . ProjectHelperImpl ; import java . util . Vector ; public class Description extends DataType { public void addText ( String text ) { ProjectHelper ph = ProjectHelper . getProjectHelper ( ) ; if ( ! ( ph instanceof ProjectHelperImpl ) ) { return ; } String currentDescription = getProject ( ) . getDescription ( ) ; if ( currentDescription == null ) { getProject ( ) . setDescription ( text ) ; } else { getProject ( ) . setDescription ( currentDescription + text ) ; } } public static String getDescription ( Project project ) { Vector targets = ( Vector ) project . getReference ( "ant.targets" ) ; if ( targets == null ) { return null ; } StringBuffer description = new StringBuffer ( ) ; for ( int i = 0 ; i < targets . size ( ) ; i ++ ) { Target t = ( Target ) targets . elementAt ( i ) ; concatDescriptions ( project , t , description ) ; } return description . toString ( ) ; } private static void concatDescriptions ( Project project , Target t , StringBuffer description ) { if ( t == null ) { return ; } Vector tasks = findElementInTarget ( project , t , "description" ) ; if ( tasks == null ) { return ; } for ( int i = 0 ; i < tasks . size ( ) ; i ++ ) { Task task = ( Task ) tasks . elementAt ( i ) ; if ( ! ( task instanceof UnknownElement ) ) { continue ; } UnknownElement ue = ( ( UnknownElement ) task ) ; String descComp = ue . getWrapper ( ) . getText ( ) . toString ( ) ; if ( descComp != null ) { description . append ( project . replaceProperties ( descComp ) ) ; } } } private static Vector findElementInTarget ( Project project , Target t , String name ) { Task [ ] tasks = t . getTasks ( ) ; Vector elems = new Vector ( ) ; for ( int i = 0 ; i < tasks . length ; i ++ ) { if ( name . equals ( tasks [ i ] . getTaskName ( ) ) ) { elems . addElement ( tasks [ i ] ) ; } } return elems ; } } 	0	['5', '3', '0', '8', '26', '10', '1', '8', '3', '2', '144', '0', '0', '0.882352941', '0.4', '0', '0', '27.8', '6', '3', '0']
package org . apache . tools . ant . types ; public class FlexInteger { private Integer value ; public FlexInteger ( String value ) { this . value = Integer . decode ( value ) ; } public int intValue ( ) { return value . intValue ( ) ; } public String toString ( ) { return value . toString ( ) ; } } 	0	['3', '1', '0', '0', '7', '0', '0', '0', '3', '0', '19', '1', '0', '0', '0.666666667', '0', '0', '5', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public class Filter extends Task { private String token ; private String value ; private File filtersFile ; public void setToken ( String token ) { this . token = token ; } public void setValue ( String value ) { this . value = value ; } public void setFiltersfile ( File filtersFile ) { this . filtersFile = filtersFile ; } public void execute ( ) throws BuildException { boolean isFiltersFromFile = filtersFile != null && token == null && value == null ; boolean isSingleFilter = filtersFile == null && token != null && value != null ; if ( ! isFiltersFromFile && ! isSingleFilter ) { throw new BuildException ( "both token and value parameters, or " + "only a filtersFile parameter is " + "required" , getLocation ( ) ) ; } if ( isSingleFilter ) { getProject ( ) . getGlobalFilterSet ( ) . addFilter ( token , value ) ; } if ( isFiltersFromFile ) { readFilters ( ) ; } } protected void readFilters ( ) throws BuildException { log ( "Reading filters from " + filtersFile , Project . MSG_VERBOSE ) ; getProject ( ) . getGlobalFilterSet ( ) . readFiltersFromFile ( filtersFile ) ; } } 	0	['6', '3', '0', '5', '17', '5', '0', '5', '5', '0.733333333', '94', '1', '0', '0.880952381', '0.5', '0', '0', '14.16666667', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . FileSet ; public class ExtensionUtil { private ExtensionUtil ( ) { } static ArrayList toExtensions ( final List adapters ) throws BuildException { final ArrayList results = new ArrayList ( ) ; final int size = adapters . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionAdapter adapter = ( ExtensionAdapter ) adapters . get ( i ) ; final Extension extension = adapter . toExtension ( ) ; results . add ( extension ) ; } return results ; } static void extractExtensions ( final Project project , final List libraries , final List fileset ) throws BuildException { if ( ! fileset . isEmpty ( ) ) { final Extension [ ] extensions = getExtensions ( project , fileset ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { libraries . add ( extensions [ i ] ) ; } } } private static Extension [ ] getExtensions ( final Project project , final List libraries ) throws BuildException { final ArrayList extensions = new ArrayList ( ) ; final Iterator iterator = libraries . iterator ( ) ; while ( iterator . hasNext ( ) ) { final FileSet fileSet = ( FileSet ) iterator . next ( ) ; boolean includeImpl = true ; boolean includeURL = true ; if ( fileSet instanceof LibFileSet ) { LibFileSet libFileSet = ( LibFileSet ) fileSet ; includeImpl = libFileSet . isIncludeImpl ( ) ; includeURL = libFileSet . isIncludeURL ( ) ; } final DirectoryScanner scanner = fileSet . getDirectoryScanner ( project ) ; final File basedir = scanner . getBasedir ( ) ; final String [ ] files = scanner . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { final File file = new File ( basedir , files [ i ] ) ; loadExtensions ( file , extensions , includeImpl , includeURL ) ; } } return ( Extension [ ] ) extensions . toArray ( new Extension [ extensions . size ( ) ] ) ; } private static void loadExtensions ( final File file , final List extensionList , final boolean includeImpl , final boolean includeURL ) throws BuildException { try { final JarFile jarFile = new JarFile ( file ) ; final Extension [ ] extensions = Extension . getAvailable ( jarFile . getManifest ( ) ) ; for ( int i = 0 ; i < extensions . length ; i ++ ) { final Extension extension = extensions [ i ] ; addExtension ( extensionList , extension , includeImpl , includeURL ) ; } } catch ( final Exception e ) { throw new BuildException ( e . getMessage ( ) , e ) ; } } private static void addExtension ( final List extensionList , final Extension originalExtension , final boolean includeImpl , final boolean includeURL ) { Extension extension = originalExtension ; if ( ! includeURL && null != extension . getImplementationURL ( ) ) { extension = new Extension ( extension . getExtensionName ( ) , extension . getSpecificationVersion ( ) . toString ( ) , extension . getSpecificationVendor ( ) , extension . getImplementationVersion ( ) . toString ( ) , extension . getImplementationVendor ( ) , extension . getImplementationVendorID ( ) , null ) ; } final boolean hasImplAttributes = null != extension . getImplementationURL ( ) || null != extension . getImplementationVersion ( ) || null != extension . getImplementationVendorID ( ) || null != extension . getImplementationVendor ( ) ; if ( ! includeImpl && hasImplAttributes ) { extension = new Extension ( extension . getExtensionName ( ) , extension . getSpecificationVersion ( ) . toString ( ) , extension . getSpecificationVendor ( ) , null , null , null , extension . getImplementationURL ( ) ) ; } extensionList . add ( extension ) ; } static Manifest getManifest ( final File file ) throws BuildException { try { final JarFile jarFile = new JarFile ( file ) ; Manifest m = jarFile . getManifest ( ) ; if ( m == null ) { throw new BuildException ( file + " doesn't have a MANIFEST" ) ; } return m ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } } } 	0	['7', '1', '0', '12', '46', '21', '4', '8', '0', '2', '264', '0', '0', '0', '0.30952381', '0', '0', '36.71428571', '9', '2', '0']
package org . apache . tools . ant . taskdefs . optional . unix ; import org . apache . tools . ant . BuildException ; public class Chown extends AbstractAccessTask { private boolean haveOwner = false ; public Chown ( ) { super . setExecutable ( "chown" ) ; } public void setOwner ( String owner ) { createArg ( ) . setValue ( owner ) ; haveOwner = true ; } protected void checkConfiguration ( ) { if ( ! haveOwner ) { throw new BuildException ( "Required attribute owner not set in" + " chown" , getLocation ( ) ) ; } super . checkConfiguration ( ) ; } public void setExecutable ( String e ) { throw new BuildException ( getTaskType ( ) + " doesn\'t support the executable" + " attribute" , getLocation ( ) ) ; } } 	0	['4', '6', '0', '4', '16', '0', '0', '4', '3', '0.333333333', '52', '1', '0', '0.973913043', '0.75', '2', '2', '11.75', '2', '1', '0']
package org . apache . tools . ant ; import java . io . PrintStream ; import java . io . PrintWriter ; public class BuildException extends RuntimeException { private Throwable cause ; private Location location = Location . UNKNOWN_LOCATION ; public BuildException ( ) { super ( ) ; } public BuildException ( String message ) { super ( message ) ; } public BuildException ( String message , Throwable cause ) { super ( message ) ; this . cause = cause ; } public BuildException ( String msg , Throwable cause , Location location ) { this ( msg , cause ) ; this . location = location ; } public BuildException ( Throwable cause ) { super ( cause . toString ( ) ) ; this . cause = cause ; } public BuildException ( String message , Location location ) { super ( message ) ; this . location = location ; } public BuildException ( Throwable cause , Location location ) { this ( cause ) ; this . location = location ; } public Throwable getException ( ) { return cause ; } public Throwable getCause ( ) { return getException ( ) ; } public String toString ( ) { return location . toString ( ) + getMessage ( ) ; } public void setLocation ( Location location ) { this . location = location ; } public Location getLocation ( ) { return location ; } public void printStackTrace ( ) { printStackTrace ( System . err ) ; } public void printStackTrace ( PrintStream ps ) { synchronized ( ps ) { super . printStackTrace ( ps ) ; if ( cause != null ) { ps . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( ps ) ; } } } public void printStackTrace ( PrintWriter pw ) { synchronized ( pw ) { super . printStackTrace ( pw ) ; if ( cause != null ) { pw . println ( "--- Nested Exception ---" ) ; cause . printStackTrace ( pw ) ; } } } } 	0	['15', '4', '3', '499', '30', '0', '498', '1', '15', '0.392857143', '153', '1', '1', '0.619047619', '0.322222222', '1', '3', '9.066666667', '2', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; public class ClassFileUtils { public static String convertSlashName ( String name ) { return name . replace ( '\\' , '.' ) . replace ( '/' , '.' ) ; } public static String convertDotName ( String dotName ) { return dotName . replace ( '.' , '/' ) ; } } 	0	['3', '1', '0', '2', '5', '3', '2', '0', '3', '2', '19', '0', '0', '0', '0.5', '0', '0', '5.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; public abstract class EnumeratedAttribute { protected String value ; private int index = - 1 ; public abstract String [ ] getValues ( ) ; protected EnumeratedAttribute ( ) { } public static EnumeratedAttribute getInstance ( Class clazz , String value ) throws BuildException { if ( ! EnumeratedAttribute . class . isAssignableFrom ( clazz ) ) { throw new BuildException ( "You have to provide a subclass from EnumeratedAttribut as clazz-parameter." ) ; } EnumeratedAttribute ea = null ; try { ea = ( EnumeratedAttribute ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } ea . setValue ( value ) ; return ea ; } public final void setValue ( String value ) throws BuildException { int idx = indexOfValue ( value ) ; if ( idx == - 1 ) { throw new BuildException ( value + " is not a legal value for this attribute" ) ; } this . index = idx ; this . value = value ; } public final boolean containsValue ( String value ) { return ( indexOfValue ( value ) != - 1 ) ; } public final int indexOfValue ( String value ) { String [ ] values = getValues ( ) ; if ( values == null || value == null ) { return - 1 ; } for ( int i = 0 ; i < values . length ; i ++ ) { if ( value . equals ( values [ i ] ) ) { return i ; } } return - 1 ; } public final String getValue ( ) { return value ; } public final int getIndex ( ) { return index ; } public String toString ( ) { return getValue ( ) ; } } 	0	['9', '1', '59', '62', '22', '28', '61', '1', '8', '0.75', '130', '0.666666667', '0', '0', '0.481481481', '0', '0', '13.11111111', '5', '1.4444', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import java . io . File ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Java ; import org . apache . tools . ant . taskdefs . optional . jsp . JspC ; import org . apache . tools . ant . taskdefs . optional . jsp . JspMangler ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; public class JasperC extends DefaultJspCompilerAdapter { JspMangler mangler ; public JasperC ( JspMangler mangler ) { this . mangler = mangler ; } public boolean execute ( ) throws BuildException { getJspc ( ) . log ( "Using jasper compiler" , Project . MSG_VERBOSE ) ; CommandlineJava cmd = setupJasperCommand ( ) ; try { Java java = new Java ( owner ) ; Path p = getClasspath ( ) ; if ( getJspc ( ) . getClasspath ( ) != null ) { getProject ( ) . log ( "using user supplied classpath: " + p , Project . MSG_DEBUG ) ; } else { getProject ( ) . log ( "using system classpath: " + p , Project . MSG_DEBUG ) ; } java . setClasspath ( p ) ; java . setDir ( getProject ( ) . getBaseDir ( ) ) ; java . setClassname ( "org.apache.jasper.JspC" ) ; String [ ] args = cmd . getJavaCommand ( ) . getArguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { java . createArg ( ) . setValue ( args [ i ] ) ; } java . setFailonerror ( getJspc ( ) . getFailonerror ( ) ) ; java . setFork ( true ) ; java . setTaskName ( "jasperc" ) ; java . execute ( ) ; return true ; } catch ( Exception ex ) { if ( ex instanceof BuildException ) { throw ( BuildException ) ex ; } else { throw new BuildException ( "Error running jsp compiler: " , ex , getJspc ( ) . getLocation ( ) ) ; } } finally { getJspc ( ) . deleteEmptyJavaFiles ( ) ; } } private CommandlineJava setupJasperCommand ( ) { CommandlineJava cmd = new CommandlineJava ( ) ; JspC jspc = getJspc ( ) ; addArg ( cmd , "-d" , jspc . getDestdir ( ) ) ; addArg ( cmd , "-p" , jspc . getPackage ( ) ) ; if ( ! isTomcat5x ( ) ) { addArg ( cmd , "-v" + jspc . getVerbose ( ) ) ; } else { getProject ( ) . log ( "this task doesn't support Tomcat 5.x properly, " + "please use the Tomcat provided jspc task " + "instead" ) ; } addArg ( cmd , "-uriroot" , jspc . getUriroot ( ) ) ; addArg ( cmd , "-uribase" , jspc . getUribase ( ) ) ; addArg ( cmd , "-ieplugin" , jspc . getIeplugin ( ) ) ; addArg ( cmd , "-webinc" , jspc . getWebinc ( ) ) ; addArg ( cmd , "-webxml" , jspc . getWebxml ( ) ) ; addArg ( cmd , "-die9" ) ; if ( jspc . isMapped ( ) ) { addArg ( cmd , "-mapped" ) ; } if ( jspc . getWebApp ( ) != null ) { File dir = jspc . getWebApp ( ) . getDirectory ( ) ; addArg ( cmd , "-webapp" , dir ) ; } logAndAddFilesToCompile ( getJspc ( ) , getJspc ( ) . getCompileList ( ) , cmd ) ; return cmd ; } public JspMangler createMangler ( ) { return mangler ; } private Path getClasspath ( ) { Path p = getJspc ( ) . getClasspath ( ) ; if ( p == null ) { p = new Path ( getProject ( ) ) ; return p . concatSystemClasspath ( "only" ) ; } else { return p . concatSystemClasspath ( "ignore" ) ; } } private boolean isTomcat5x ( ) { AntClassLoader l = null ; try { l = getProject ( ) . createClassLoader ( getClasspath ( ) ) ; l . loadClass ( "org.apache.jasper.tagplugins.jstl.If" ) ; return true ; } catch ( ClassNotFoundException e ) { return false ; } finally { if ( l != null ) { l . cleanup ( ) ; } } } } 	0	['6', '2', '0', '15', '56', '13', '1', '14', '3', '0.8', '280', '0', '1', '0.615384615', '0.583333333', '0', '0', '45.5', '5', '2.1667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . IOException ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Path ; import org . xml . sax . SAXException ; public class IPlanetEjbcTask extends Task { private File ejbdescriptor ; private File iasdescriptor ; private File dest ; private Path classpath ; private boolean keepgenerated = false ; private boolean debug = false ; private File iashome ; public void setEjbdescriptor ( File ejbdescriptor ) { this . ejbdescriptor = ejbdescriptor ; } public void setIasdescriptor ( File iasdescriptor ) { this . iasdescriptor = iasdescriptor ; } public void setDest ( File dest ) { this . dest = dest ; } public void setClasspath ( Path classpath ) { if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setKeepgenerated ( boolean keepgenerated ) { this . keepgenerated = keepgenerated ; } public void setDebug ( boolean debug ) { this . debug = debug ; } public void setIashome ( File iashome ) { this . iashome = iashome ; } public void execute ( ) throws BuildException { checkConfiguration ( ) ; executeEjbc ( getParser ( ) ) ; } private void checkConfiguration ( ) throws BuildException { if ( ejbdescriptor == null ) { String msg = "The standard EJB descriptor must be specified using " + "the \"ejbdescriptor\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! ejbdescriptor . exists ( ) ) || ( ! ejbdescriptor . isFile ( ) ) ) { String msg = "The standard EJB descriptor (" + ejbdescriptor + ") was not found or isn't a file." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( iasdescriptor == null ) { String msg = "The iAS-speific XML descriptor must be specified using" + " the \"iasdescriptor\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! iasdescriptor . exists ( ) ) || ( ! iasdescriptor . isFile ( ) ) ) { String msg = "The iAS-specific XML descriptor (" + iasdescriptor + ") was not found or isn't a file." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( dest == null ) { String msg = "The destination directory must be specified using " + "the \"dest\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( ! dest . exists ( ) ) || ( ! dest . isDirectory ( ) ) ) { String msg = "The destination directory (" + dest + ") was not " + "found or isn't a directory." ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ( iashome != null ) && ( ! iashome . isDirectory ( ) ) ) { String msg = "If \"iashome\" is specified, it must be a valid " + "directory (it was set to " + iashome + ")." ; throw new BuildException ( msg , getLocation ( ) ) ; } } private SAXParser getParser ( ) throws BuildException { SAXParser saxParser = null ; try { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; saxParserFactory . setValidating ( true ) ; saxParser = saxParserFactory . newSAXParser ( ) ; } catch ( SAXException e ) { String msg = "Unable to create a SAXParser: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( ParserConfigurationException e ) { String msg = "Unable to create a SAXParser: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } return saxParser ; } private void executeEjbc ( SAXParser saxParser ) throws BuildException { IPlanetEjbc ejbc = new IPlanetEjbc ( ejbdescriptor , iasdescriptor , dest , getClasspath ( ) . toString ( ) , saxParser ) ; ejbc . setRetainSource ( keepgenerated ) ; ejbc . setDebugOutput ( debug ) ; if ( iashome != null ) { ejbc . setIasHomeDir ( iashome ) ; } try { ejbc . execute ( ) ; } catch ( IOException e ) { String msg = "An IOException occurred while trying to read the XML " + "descriptor file: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( SAXException e ) { String msg = "A SAXException occurred while trying to read the XML " + "descriptor file: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } catch ( IPlanetEjbc . EjbcException e ) { String msg = "An exception occurred while trying to run the ejbc " + "utility: " + e . getMessage ( ) ; throw new BuildException ( msg , e , getLocation ( ) ) ; } } private Path getClasspath ( ) { Path cp = null ; if ( classpath == null ) { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } else { cp = classpath . concatSystemClasspath ( "ignore" ) ; } return cp ; } } 	0	['14', '3', '0', '7', '43', '57', '0', '7', '10', '0.769230769', '386', '1', '1', '0.74', '0.314285714', '0', '0', '26.07142857', '2', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . javacc ; import java . io . File ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JavaCC extends Task { private static final String LOOKAHEAD = "LOOKAHEAD" ; private static final String CHOICE_AMBIGUITY_CHECK = "CHOICE_AMBIGUITY_CHECK" ; private static final String OTHER_AMBIGUITY_CHECK = "OTHER_AMBIGUITY_CHECK" ; private static final String STATIC = "STATIC" ; private static final String DEBUG_PARSER = "DEBUG_PARSER" ; private static final String DEBUG_LOOKAHEAD = "DEBUG_LOOKAHEAD" ; private static final String DEBUG_TOKEN_MANAGER = "DEBUG_TOKEN_MANAGER" ; private static final String OPTIMIZE_TOKEN_MANAGER = "OPTIMIZE_TOKEN_MANAGER" ; private static final String ERROR_REPORTING = "ERROR_REPORTING" ; private static final String JAVA_UNICODE_ESCAPE = "JAVA_UNICODE_ESCAPE" ; private static final String UNICODE_INPUT = "UNICODE_INPUT" ; private static final String IGNORE_CASE = "IGNORE_CASE" ; private static final String COMMON_TOKEN_ACTION = "COMMON_TOKEN_ACTION" ; private static final String USER_TOKEN_MANAGER = "USER_TOKEN_MANAGER" ; private static final String USER_CHAR_STREAM = "USER_CHAR_STREAM" ; private static final String BUILD_PARSER = "BUILD_PARSER" ; private static final String BUILD_TOKEN_MANAGER = "BUILD_TOKEN_MANAGER" ; private static final String SANITY_CHECK = "SANITY_CHECK" ; private static final String FORCE_LA_CHECK = "FORCE_LA_CHECK" ; private static final String CACHE_TOKENS = "CACHE_TOKENS" ; private static final String KEEP_LINE_COLUMN = "KEEP_LINE_COLUMN" ; private static final String JDK_VERSION = "JDK_VERSION" ; private final Hashtable optionalAttrs = new Hashtable ( ) ; private File outputDirectory = null ; private File targetFile = null ; private File javaccHome = null ; private CommandlineJava cmdl = new CommandlineJava ( ) ; protected static final int TASKDEF_TYPE_JAVACC = 1 ; protected static final int TASKDEF_TYPE_JJTREE = 2 ; protected static final int TASKDEF_TYPE_JJDOC = 3 ; protected static final String [ ] ARCHIVE_LOCATIONS = new String [ ] { "JavaCC.zip" , "bin/lib/JavaCC.zip" , "bin/lib/javacc.jar" , "javacc.jar" , } ; protected static final int [ ] ARCHIVE_LOCATIONS_VS_MAJOR_VERSION = new int [ ] { 1 , 2 , 3 , 3 , } ; protected static final String COM_PACKAGE = "COM.sun.labs." ; protected static final String COM_JAVACC_CLASS = "javacc.Main" ; protected static final String COM_JJTREE_CLASS = "jjtree.Main" ; protected static final String COM_JJDOC_CLASS = "jjdoc.JJDocMain" ; protected static final String ORG_PACKAGE_3_0 = "org.netbeans.javacc." ; protected static final String ORG_PACKAGE_3_1 = "org.javacc." ; protected static final String ORG_JAVACC_CLASS = "parser.Main" ; protected static final String ORG_JJTREE_CLASS = COM_JJTREE_CLASS ; protected static final String ORG_JJDOC_CLASS = COM_JJDOC_CLASS ; public void setLookahead ( int lookahead ) { optionalAttrs . put ( LOOKAHEAD , new Integer ( lookahead ) ) ; } public void setChoiceambiguitycheck ( int choiceAmbiguityCheck ) { optionalAttrs . put ( CHOICE_AMBIGUITY_CHECK , new Integer ( choiceAmbiguityCheck ) ) ; } public void setOtherambiguityCheck ( int otherAmbiguityCheck ) { optionalAttrs . put ( OTHER_AMBIGUITY_CHECK , new Integer ( otherAmbiguityCheck ) ) ; } public void setStatic ( boolean staticParser ) { optionalAttrs . put ( STATIC , staticParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebugparser ( boolean debugParser ) { optionalAttrs . put ( DEBUG_PARSER , debugParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebuglookahead ( boolean debugLookahead ) { optionalAttrs . put ( DEBUG_LOOKAHEAD , debugLookahead ? Boolean . TRUE : Boolean . FALSE ) ; } public void setDebugtokenmanager ( boolean debugTokenManager ) { optionalAttrs . put ( DEBUG_TOKEN_MANAGER , debugTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setOptimizetokenmanager ( boolean optimizeTokenManager ) { optionalAttrs . put ( OPTIMIZE_TOKEN_MANAGER , optimizeTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setErrorreporting ( boolean errorReporting ) { optionalAttrs . put ( ERROR_REPORTING , errorReporting ? Boolean . TRUE : Boolean . FALSE ) ; } public void setJavaunicodeescape ( boolean javaUnicodeEscape ) { optionalAttrs . put ( JAVA_UNICODE_ESCAPE , javaUnicodeEscape ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUnicodeinput ( boolean unicodeInput ) { optionalAttrs . put ( UNICODE_INPUT , unicodeInput ? Boolean . TRUE : Boolean . FALSE ) ; } public void setIgnorecase ( boolean ignoreCase ) { optionalAttrs . put ( IGNORE_CASE , ignoreCase ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCommontokenaction ( boolean commonTokenAction ) { optionalAttrs . put ( COMMON_TOKEN_ACTION , commonTokenAction ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUsertokenmanager ( boolean userTokenManager ) { optionalAttrs . put ( USER_TOKEN_MANAGER , userTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setUsercharstream ( boolean userCharStream ) { optionalAttrs . put ( USER_CHAR_STREAM , userCharStream ? Boolean . TRUE : Boolean . FALSE ) ; } public void setBuildparser ( boolean buildParser ) { optionalAttrs . put ( BUILD_PARSER , buildParser ? Boolean . TRUE : Boolean . FALSE ) ; } public void setBuildtokenmanager ( boolean buildTokenManager ) { optionalAttrs . put ( BUILD_TOKEN_MANAGER , buildTokenManager ? Boolean . TRUE : Boolean . FALSE ) ; } public void setSanitycheck ( boolean sanityCheck ) { optionalAttrs . put ( SANITY_CHECK , sanityCheck ? Boolean . TRUE : Boolean . FALSE ) ; } public void setForcelacheck ( boolean forceLACheck ) { optionalAttrs . put ( FORCE_LA_CHECK , forceLACheck ? Boolean . TRUE : Boolean . FALSE ) ; } public void setCachetokens ( boolean cacheTokens ) { optionalAttrs . put ( CACHE_TOKENS , cacheTokens ? Boolean . TRUE : Boolean . FALSE ) ; } public void setKeeplinecolumn ( boolean keepLineColumn ) { optionalAttrs . put ( KEEP_LINE_COLUMN , keepLineColumn ? Boolean . TRUE : Boolean . FALSE ) ; } public void setJDKversion ( String jdkVersion ) { optionalAttrs . put ( JDK_VERSION , jdkVersion ) ; } public void setOutputdirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public void setTarget ( File targetFile ) { this . targetFile = targetFile ; } public void setJavacchome ( File javaccHome ) { this . javaccHome = javaccHome ; } public JavaCC ( ) { cmdl . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; } public void execute ( ) throws BuildException { Enumeration iter = optionalAttrs . keys ( ) ; while ( iter . hasMoreElements ( ) ) { String name = ( String ) iter . nextElement ( ) ; Object value = optionalAttrs . get ( name ) ; cmdl . createArgument ( ) . setValue ( "-" + name + ":" + value . toString ( ) ) ; } if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputDirectory == null ) { outputDirectory = new File ( targetFile . getParent ( ) ) ; } else if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "Outputdir not a directory." ) ; } cmdl . createArgument ( ) . setValue ( "-OUTPUT_DIRECTORY:" + outputDirectory . getAbsolutePath ( ) ) ; final File javaFile = getOutputJavaFile ( outputDirectory , targetFile ) ; if ( javaFile . exists ( ) && targetFile . lastModified ( ) < javaFile . lastModified ( ) ) { log ( "Target is already built - skipping (" + targetFile + ")" , Project . MSG_VERBOSE ) ; return ; } cmdl . createArgument ( ) . setValue ( targetFile . getAbsolutePath ( ) ) ; final Path classpath = cmdl . createClasspath ( getProject ( ) ) ; final File javaccJar = JavaCC . getArchiveFile ( javaccHome ) ; classpath . createPathElement ( ) . setPath ( javaccJar . getAbsolutePath ( ) ) ; classpath . addJavaRuntime ( ) ; cmdl . setClassname ( JavaCC . getMainClass ( classpath , JavaCC . TASKDEF_TYPE_JAVACC ) ) ; final Commandline . Argument arg = cmdl . createVmArgument ( ) ; arg . setValue ( "-mx140M" ) ; arg . setValue ( "-Dinstall.root=" + javaccHome . getAbsolutePath ( ) ) ; Execute . runCommand ( this , cmdl . getCommandline ( ) ) ; } protected static File getArchiveFile ( File home ) throws BuildException { return new File ( home , ARCHIVE_LOCATIONS [ getArchiveLocationIndex ( home ) ] ) ; } protected static String getMainClass ( File home , int type ) throws BuildException { Path p = new Path ( null ) ; p . createPathElement ( ) . setLocation ( getArchiveFile ( home ) ) ; p . addJavaRuntime ( ) ; return getMainClass ( p , type ) ; } protected static String getMainClass ( Path path , int type ) throws BuildException { String packagePrefix = null ; String mainClass = null ; AntClassLoader l = new AntClassLoader ( ) ; l . setClassPath ( path . concatSystemClasspath ( "ignore" ) ) ; String javaccClass = COM_PACKAGE + COM_JAVACC_CLASS ; InputStream is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = COM_PACKAGE ; switch ( type ) { case TASKDEF_TYPE_JAVACC : mainClass = COM_JAVACC_CLASS ; break ; case TASKDEF_TYPE_JJTREE : mainClass = COM_JJTREE_CLASS ; break ; case TASKDEF_TYPE_JJDOC : mainClass = COM_JJDOC_CLASS ; break ; default : } } else { javaccClass = ORG_PACKAGE_3_1 + ORG_JAVACC_CLASS ; is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = ORG_PACKAGE_3_1 ; } else { javaccClass = ORG_PACKAGE_3_0 + ORG_JAVACC_CLASS ; is = l . getResourceAsStream ( javaccClass . replace ( '.' , '/' ) + ".class" ) ; if ( is != null ) { packagePrefix = ORG_PACKAGE_3_0 ; } } if ( is != null ) { switch ( type ) { case TASKDEF_TYPE_JAVACC : mainClass = ORG_JAVACC_CLASS ; break ; case TASKDEF_TYPE_JJTREE : mainClass = ORG_JJTREE_CLASS ; break ; case TASKDEF_TYPE_JJDOC : mainClass = ORG_JJDOC_CLASS ; break ; default : } } } if ( packagePrefix == null ) { throw new BuildException ( "failed to load JavaCC" ) ; } if ( mainClass == null ) { throw new BuildException ( "unknown task type " + type ) ; } return packagePrefix + mainClass ; } private static int getArchiveLocationIndex ( File home ) throws BuildException { if ( home == null || ! home . isDirectory ( ) ) { throw new BuildException ( "JavaCC home must be a valid directory." ) ; } for ( int i = 0 ; i < ARCHIVE_LOCATIONS . length ; i ++ ) { File f = new File ( home , ARCHIVE_LOCATIONS [ i ] ) ; if ( f . exists ( ) ) { return i ; } } throw new BuildException ( "Could not find a path to JavaCC.zip " + "or javacc.jar from '" + home + "'." ) ; } protected static int getMajorVersionNumber ( File home ) throws BuildException { return ARCHIVE_LOCATIONS_VS_MAJOR_VERSION [ getArchiveLocationIndex ( home ) ] ; } private File getOutputJavaFile ( File outputdir , File srcfile ) { String path = srcfile . getPath ( ) ; int startBasename = path . lastIndexOf ( File . separator ) ; if ( startBasename != - 1 ) { path = path . substring ( startBasename + 1 ) ; } int startExtn = path . lastIndexOf ( '.' ) ; if ( startExtn != - 1 ) { path = path . substring ( 0 , startExtn ) + ".java" ; } else { path += ".java" ; } if ( outputdir != null ) { path = outputdir + File . separator + path ; } return new File ( path ) ; } } 	0	['34', '3', '0', '12', '86', '0', '2', '10', '27', '0.998521803', '822', '1', '1', '0.536231884', '0.308080808', '1', '1', '21.97058824', '4', '1.5588', '0']
package org . apache . tools . ant . util ; import java . io . InputStream ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; public class ConcatResourceInputStream extends InputStream { private static final int EOF = - 1 ; private boolean eof = false ; private Iterator iter ; private InputStream currentStream ; private ProjectComponent managingPc ; private boolean ignoreErrors = false ; public ConcatResourceInputStream ( ResourceCollection rc ) { iter = rc . iterator ( ) ; } public void setIgnoreErrors ( boolean b ) { ignoreErrors = b ; } public boolean isIgnoreErrors ( ) { return ignoreErrors ; } public void close ( ) throws IOException { closeCurrent ( ) ; eof = true ; } public int read ( ) throws IOException { if ( eof ) { return EOF ; } int result = readCurrent ( ) ; if ( result == EOF ) { nextResource ( ) ; result = readCurrent ( ) ; } return result ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { ( loglevel > Project . MSG_WARN ? System . out : System . err ) . println ( message ) ; } } private int readCurrent ( ) throws IOException { return eof || currentStream == null ? EOF : currentStream . read ( ) ; } private void nextResource ( ) throws IOException { closeCurrent ( ) ; while ( iter . hasNext ( ) ) { Resource r = ( Resource ) iter . next ( ) ; if ( ! r . isExists ( ) ) { continue ; } log ( "Concating " + r . toLongString ( ) , Project . MSG_VERBOSE ) ; try { currentStream = new BufferedInputStream ( r . getInputStream ( ) ) ; return ; } catch ( IOException eyeOhEx ) { if ( ! ignoreErrors ) { log ( "Failed to get input stream for " + r , Project . MSG_ERR ) ; throw eyeOhEx ; } } } eof = true ; } private void closeCurrent ( ) { FileUtils . close ( currentStream ) ; currentStream = null ; } } 	0	['10', '2', '0', '6', '26', '9', '2', '4', '7', '0.722222222', '156', '1', '1', '0.5', '0.25', '1', '1', '14', '3', '1.1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . Comparator ; public class EqualComparator implements Comparator { public int compare ( Object o1 , Object o2 ) { if ( o1 == null ) { if ( o2 == null ) { return 1 ; } return 0 ; } return ( o1 . equals ( o2 ) ) ? 0 : 1 ; } public String toString ( ) { return "EqualComparator" ; } } 	0	['3', '1', '0', '1', '5', '3', '1', '0', '3', '2', '24', '0', '0', '0', '0.666666667', '0', '0', '7', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; public class IsFalse extends ProjectComponent implements Condition { private Boolean value = null ; public void setValue ( boolean value ) { this . value = value ? Boolean . TRUE : Boolean . FALSE ; } public boolean eval ( ) throws BuildException { if ( value == null ) { throw new BuildException ( "Nothing to test for falsehood" ) ; } return ! value . booleanValue ( ) ; } } 	0	['3', '2', '0', '4', '6', '0', '1', '3', '3', '0', '34', '1', '0', '0.818181818', '0.666666667', '0', '0', '10', '2', '1', '0']
package org . apache . tools . ant . dispatch ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . UnknownElement ; import org . apache . tools . ant . Task ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class DispatchUtils { public static final void execute ( Object task ) throws BuildException { String methodName = "execute" ; Dispatchable dispatchable = null ; try { if ( task instanceof Dispatchable ) { dispatchable = ( Dispatchable ) task ; } else if ( task instanceof UnknownElement ) { UnknownElement ue = ( UnknownElement ) task ; Object realThing = ue . getRealThing ( ) ; if ( realThing != null && realThing instanceof Dispatchable && realThing instanceof Task ) { dispatchable = ( Dispatchable ) realThing ; } } if ( dispatchable != null ) { String mName = null ; try { final String name = dispatchable . getActionParameterName ( ) ; if ( name != null && name . trim ( ) . length ( ) > 0 ) { mName = "get" + name . trim ( ) . substring ( 0 , 1 ) . toUpperCase ( ) ; if ( name . length ( ) > 1 ) { mName += name . substring ( 1 ) ; } final Class c = dispatchable . getClass ( ) ; final Method actionM = c . getMethod ( mName , new Class [ 0 ] ) ; if ( actionM != null ) { final Object o = actionM . invoke ( dispatchable , ( Object [ ] ) null ) ; if ( o != null ) { final String s = o . toString ( ) ; if ( s != null && s . trim ( ) . length ( ) > 0 ) { methodName = s . trim ( ) ; Method executeM = null ; executeM = dispatchable . getClass ( ) . getMethod ( methodName , new Class [ 0 ] ) ; if ( executeM == null ) { throw new BuildException ( "No public " + methodName + "() in " + dispatchable . getClass ( ) ) ; } executeM . invoke ( dispatchable , ( Object [ ] ) null ) ; if ( task instanceof UnknownElement ) { ( ( UnknownElement ) task ) . setRealThing ( null ) ; } } else { throw new BuildException ( "Dispatchable Task attribute '" + name . trim ( ) + "' not set or value is empty." ) ; } } else { throw new BuildException ( "Dispatchable Task attribute '" + name . trim ( ) + "' not set or value is empty." ) ; } } } else { throw new BuildException ( "Action Parameter Name must not be empty for Dispatchable Task." ) ; } } catch ( NoSuchMethodException nsme ) { throw new BuildException ( "No public " + mName + "() in " + task . getClass ( ) ) ; } } else { Method executeM = null ; executeM = task . getClass ( ) . getMethod ( methodName , new Class [ 0 ] ) ; if ( executeM == null ) { throw new BuildException ( "No public " + methodName + "() in " + task . getClass ( ) ) ; } executeM . invoke ( task , ( Object [ ] ) null ) ; if ( task instanceof UnknownElement ) { ( ( UnknownElement ) task ) . setRealThing ( null ) ; } } } catch ( InvocationTargetException ie ) { Throwable t = ie . getTargetException ( ) ; if ( t instanceof BuildException ) { throw ( ( BuildException ) t ) ; } else { throw new BuildException ( t ) ; } } catch ( NoSuchMethodException e ) { throw new BuildException ( e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( e ) ; } } } 	0	['2', '1', '0', '6', '23', '1', '3', '4', '2', '2', '265', '0', '0', '0', '0.5', '0', '0', '131.5', '1', '0.5', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . tools . ant . BuildException ; public interface Regexp extends RegexpMatcher { int REPLACE_FIRST = 0x00000001 ; int REPLACE_ALL = 0x00000010 ; String substitute ( String input , String argument , int options ) throws BuildException ; } 	0	['1', '1', '0', '13', '1', '0', '11', '2', '1', '2', '3', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Commandline ; public class SOSLabel extends SOS { public void setVersion ( String version ) { super . setInternalVersion ( version ) ; } public void setLabel ( String label ) { super . setInternalLabel ( label ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_LABEL ) ; getRequiredAttributes ( ) ; if ( getLabel ( ) == null ) { throw new BuildException ( "label attribute must be set!" , getLocation ( ) ) ; } commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_LABEL ) ; commandLine . createArgument ( ) . setValue ( getLabel ( ) ) ; commandLine . createArgument ( ) . setValue ( getVerbose ( ) ) ; if ( getComment ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMENT ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; } return commandLine ; } } 	0	['5', '4', '0', '5', '18', '10', '0', '5', '4', '2', '81', '0', '0', '0.948717949', '0.8', '1', '2', '15.2', '3', '1.2', '0']
package org . apache . tools . ant . types . resources . selectors ; import org . apache . tools . ant . types . Resource ; public class Exists implements ResourceSelector { public boolean isSelected ( Resource r ) { return r . isExists ( ) ; } } 	0	['2', '1', '0', '6', '4', '1', '4', '2', '2', '2', '8', '0', '0', '0', '0.75', '0', '0', '3', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . xml . sax . SAXException ; public class EjbJar extends MatchingTask { public static class DTDLocation extends org . apache . tools . ant . types . DTDLocation { } static class Config { public File srcDir ; public File descriptorDir ; public String baseNameTerminator = "-" ; public String baseJarName ; public boolean flatDestDir = false ; public Path classpath ; public List supportFileSets = new ArrayList ( ) ; public ArrayList dtdLocations = new ArrayList ( ) ; public NamingScheme namingScheme ; public File manifest ; public String analyzer ; } public static class NamingScheme extends EnumeratedAttribute { public static final String EJB_NAME = "ejb-name" ; public static final String DIRECTORY = "directory" ; public static final String DESCRIPTOR = "descriptor" ; public static final String BASEJARNAME = "basejarname" ; public String [ ] getValues ( ) { return new String [ ] { EJB_NAME , DIRECTORY , DESCRIPTOR , BASEJARNAME } ; } } public static class CMPVersion extends EnumeratedAttribute { public static final String CMP1_0 = "1.0" ; public static final String CMP2_0 = "2.0" ; public String [ ] getValues ( ) { return new String [ ] { CMP1_0 , CMP2_0 , } ; } } private Config config = new Config ( ) ; private File destDir ; private String genericJarSuffix = "-generic.jar" ; private String cmpVersion = CMPVersion . CMP1_0 ; private ArrayList deploymentTools = new ArrayList ( ) ; protected void addDeploymentTool ( EJBDeploymentTool deploymentTool ) { deploymentTool . setTask ( this ) ; deploymentTools . add ( deploymentTool ) ; } public WeblogicDeploymentTool createWeblogic ( ) { WeblogicDeploymentTool tool = new WeblogicDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public WebsphereDeploymentTool createWebsphere ( ) { WebsphereDeploymentTool tool = new WebsphereDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public BorlandDeploymentTool createBorland ( ) { log ( "Borland deployment tools" , Project . MSG_VERBOSE ) ; BorlandDeploymentTool tool = new BorlandDeploymentTool ( ) ; tool . setTask ( this ) ; deploymentTools . add ( tool ) ; return tool ; } public IPlanetDeploymentTool createIplanet ( ) { log ( "iPlanet Application Server deployment tools" , Project . MSG_VERBOSE ) ; IPlanetDeploymentTool tool = new IPlanetDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public JbossDeploymentTool createJboss ( ) { JbossDeploymentTool tool = new JbossDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public JonasDeploymentTool createJonas ( ) { log ( "JOnAS deployment tools" , Project . MSG_VERBOSE ) ; JonasDeploymentTool tool = new JonasDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public WeblogicTOPLinkDeploymentTool createWeblogictoplink ( ) { log ( "The <weblogictoplink> element is no longer required. Please use " + "the <weblogic> element and set newCMP=\"true\"" , Project . MSG_INFO ) ; WeblogicTOPLinkDeploymentTool tool = new WeblogicTOPLinkDeploymentTool ( ) ; addDeploymentTool ( tool ) ; return tool ; } public Path createClasspath ( ) { if ( config . classpath == null ) { config . classpath = new Path ( getProject ( ) ) ; } return config . classpath . createPath ( ) ; } public DTDLocation createDTD ( ) { DTDLocation dtdLocation = new DTDLocation ( ) ; config . dtdLocations . add ( dtdLocation ) ; return dtdLocation ; } public FileSet createSupport ( ) { FileSet supportFileSet = new FileSet ( ) ; config . supportFileSets . add ( supportFileSet ) ; return supportFileSet ; } public void setManifest ( File manifest ) { config . manifest = manifest ; } public void setSrcdir ( File inDir ) { config . srcDir = inDir ; } public void setDescriptordir ( File inDir ) { config . descriptorDir = inDir ; } public void setDependency ( String analyzer ) { config . analyzer = analyzer ; } public void setBasejarname ( String inValue ) { config . baseJarName = inValue ; if ( config . namingScheme == null ) { config . namingScheme = new NamingScheme ( ) ; config . namingScheme . setValue ( NamingScheme . BASEJARNAME ) ; } else if ( ! config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) ) { throw new BuildException ( "The basejarname attribute is not " + "compatible with the " + config . namingScheme . getValue ( ) + " naming scheme" ) ; } } public void setNaming ( NamingScheme namingScheme ) { config . namingScheme = namingScheme ; if ( ! config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) && config . baseJarName != null ) { throw new BuildException ( "The basejarname attribute is not " + "compatible with the " + config . namingScheme . getValue ( ) + " naming scheme" ) ; } } public File getDestdir ( ) { return this . destDir ; } public void setDestdir ( File inDir ) { this . destDir = inDir ; } public String getCmpversion ( ) { return this . cmpVersion ; } public void setCmpversion ( CMPVersion version ) { this . cmpVersion = version . getValue ( ) ; } public void setClasspath ( Path classpath ) { config . classpath = classpath ; } public void setFlatdestdir ( boolean inValue ) { config . flatDestDir = inValue ; } public void setGenericjarsuffix ( String inString ) { this . genericJarSuffix = inString ; } public void setBasenameterminator ( String inValue ) { config . baseNameTerminator = inValue ; } private void validateConfig ( ) throws BuildException { if ( config . srcDir == null ) { throw new BuildException ( "The srcDir attribute must be specified" ) ; } if ( config . descriptorDir == null ) { config . descriptorDir = config . srcDir ; } if ( config . namingScheme == null ) { config . namingScheme = new NamingScheme ( ) ; config . namingScheme . setValue ( NamingScheme . DESCRIPTOR ) ; } else if ( config . namingScheme . getValue ( ) . equals ( NamingScheme . BASEJARNAME ) && config . baseJarName == null ) { throw new BuildException ( "The basejarname attribute must " + "be specified with the basejarname naming scheme" ) ; } } public void execute ( ) throws BuildException { validateConfig ( ) ; if ( deploymentTools . size ( ) == 0 ) { GenericDeploymentTool genericTool = new GenericDeploymentTool ( ) ; genericTool . setTask ( this ) ; genericTool . setDestdir ( destDir ) ; genericTool . setGenericJarSuffix ( genericJarSuffix ) ; deploymentTools . add ( genericTool ) ; } for ( Iterator i = deploymentTools . iterator ( ) ; i . hasNext ( ) ; ) { EJBDeploymentTool tool = ( EJBDeploymentTool ) i . next ( ) ; tool . configure ( config ) ; tool . validateConfigured ( ) ; } try { SAXParserFactory saxParserFactory = SAXParserFactory . newInstance ( ) ; saxParserFactory . setValidating ( true ) ; SAXParser saxParser = saxParserFactory . newSAXParser ( ) ; DirectoryScanner ds = getDirectoryScanner ( config . descriptorDir ) ; ds . scan ( ) ; String [ ] files = ds . getIncludedFiles ( ) ; log ( files . length + " deployment descriptors located." , Project . MSG_VERBOSE ) ; for ( int index = 0 ; index < files . length ; ++ index ) { for ( Iterator i = deploymentTools . iterator ( ) ; i . hasNext ( ) ; ) { EJBDeploymentTool tool = ( EJBDeploymentTool ) i . next ( ) ; tool . processDescriptor ( files [ index ] , saxParser ) ; } } } catch ( SAXException se ) { String msg = "SAXException while creating parser." + "  Details: " + se . getMessage ( ) ; throw new BuildException ( msg , se ) ; } catch ( ParserConfigurationException pce ) { String msg = "ParserConfigurationException while creating parser. " + "Details: " + pce . getMessage ( ) ; throw new BuildException ( msg , pce ) ; } } } 	0	['28', '4', '0', '20', '78', '142', '1', '20', '26', '0.785185185', '503', '1', '1', '0.742857143', '0.183035714', '2', '2', '16.78571429', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . jdepend ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . util . Vector ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteWatchdog ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . LoaderUtils ; public class JDependTask extends Task { private Path sourcesPath ; private Path classesPath ; private File outputFile ; private File dir ; private Path compileClasspath ; private boolean haltonerror = false ; private boolean fork = false ; private Long timeout = null ; private String jvm = null ; private String format = "text" ; private PatternSet defaultPatterns = new PatternSet ( ) ; private static Constructor packageFilterC ; private static Method setFilter ; private boolean includeRuntime = false ; private Path runtimeClasses = null ; static { try { Class packageFilter = Class . forName ( "jdepend.framework.PackageFilter" ) ; packageFilterC = packageFilter . getConstructor ( new Class [ ] { java . util . Collection . class } ) ; setFilter = jdepend . textui . JDepend . class . getDeclaredMethod ( "setFilter" , new Class [ ] { packageFilter } ) ; } catch ( Throwable t ) { if ( setFilter == null ) { packageFilterC = null ; } } } public void setIncluderuntime ( boolean b ) { includeRuntime = b ; } public void setTimeout ( Long value ) { timeout = value ; } public Long getTimeout ( ) { return timeout ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } public File getOutputFile ( ) { return outputFile ; } public void setHaltonerror ( boolean haltonerror ) { this . haltonerror = haltonerror ; } public boolean getHaltonerror ( ) { return haltonerror ; } public void setFork ( boolean value ) { fork = value ; } public boolean getFork ( ) { return fork ; } public void setJvm ( String value ) { jvm = value ; } public Path createSourcespath ( ) { if ( sourcesPath == null ) { sourcesPath = new Path ( getProject ( ) ) ; } return sourcesPath . createPath ( ) ; } public Path getSourcespath ( ) { return sourcesPath ; } public Path createClassespath ( ) { if ( classesPath == null ) { classesPath = new Path ( getProject ( ) ) ; } return classesPath . createPath ( ) ; } public Path getClassespath ( ) { return classesPath ; } public void setDir ( File dir ) { this . dir = dir ; } public File getDir ( ) { return dir ; } public void setClasspath ( Path classpath ) { if ( compileClasspath == null ) { compileClasspath = classpath ; } else { compileClasspath . append ( classpath ) ; } } public Path getClasspath ( ) { return compileClasspath ; } public Path createClasspath ( ) { if ( compileClasspath == null ) { compileClasspath = new Path ( getProject ( ) ) ; } return compileClasspath . createPath ( ) ; } public Commandline . Argument createJvmarg ( CommandlineJava commandline ) { return commandline . createVmArgument ( ) ; } public void setClasspathRef ( Reference r ) { createClasspath ( ) . setRefid ( r ) ; } public PatternSet . NameEntry createExclude ( ) { return defaultPatterns . createExclude ( ) ; } public PatternSet getExcludes ( ) { return defaultPatterns ; } public void setFormat ( FormatAttribute ea ) { format = ea . getValue ( ) ; } public static class FormatAttribute extends EnumeratedAttribute { private String [ ] formats = new String [ ] { "xml" , "text" } ; public String [ ] getValues ( ) { return formats ; } } private static final int SUCCESS = 0 ; private static final int ERRORS = 1 ; private void addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/jdepend/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; runtimeClasses . createPath ( ) . setLocation ( f ) ; } else { log ( "Couldn\'t find " + resource , Project . MSG_DEBUG ) ; } } public void execute ( ) throws BuildException { CommandlineJava commandline = new CommandlineJava ( ) ; if ( "text" . equals ( format ) ) { commandline . setClassname ( "jdepend.textui.JDepend" ) ; } else if ( "xml" . equals ( format ) ) { commandline . setClassname ( "jdepend.xmlui.JDepend" ) ; } if ( jvm != null ) { commandline . setVm ( jvm ) ; } if ( getSourcespath ( ) == null && getClassespath ( ) == null ) { throw new BuildException ( "Missing classespath required argument" ) ; } else if ( getClassespath ( ) == null ) { String msg = "sourcespath is deprecated in JDepend >= 2.5 " + "- please convert to classespath" ; log ( msg ) ; } int exitValue = JDependTask . ERRORS ; boolean wasKilled = false ; if ( ! getFork ( ) ) { exitValue = executeInVM ( commandline ) ; } else { ExecuteWatchdog watchdog = createWatchdog ( ) ; exitValue = executeAsForked ( commandline , watchdog ) ; if ( watchdog != null ) { wasKilled = watchdog . killedProcess ( ) ; } } boolean errorOccurred = exitValue == JDependTask . ERRORS || wasKilled ; if ( errorOccurred ) { String errorMessage = "JDepend FAILED" + ( wasKilled ? " - Timed out" : "" ) ; if ( getHaltonerror ( ) ) { throw new BuildException ( errorMessage , getLocation ( ) ) ; } else { log ( errorMessage , Project . MSG_ERR ) ; } } } public int executeInVM ( CommandlineJava commandline ) throws BuildException { jdepend . textui . JDepend jdepend ; if ( "xml" . equals ( format ) ) { jdepend = new jdepend . xmlui . JDepend ( ) ; } else { jdepend = new jdepend . textui . JDepend ( ) ; } FileWriter fw = null ; if ( getOutputFile ( ) != null ) { try { fw = new FileWriter ( getOutputFile ( ) . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when creating the output file: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } jdepend . setWriter ( new PrintWriter ( fw ) ) ; log ( "Output to be stored in " + getOutputFile ( ) . getPath ( ) ) ; } try { if ( getClassespath ( ) != null ) { String [ ] cP = getClassespath ( ) . list ( ) ; for ( int i = 0 ; i < cP . length ; i ++ ) { File f = new File ( cP [ i ] ) ; if ( ! f . exists ( ) ) { String msg = "\"" + f . getPath ( ) + "\" does not represent a valid" + " file or directory. JDepend would fail." ; log ( msg ) ; throw new BuildException ( msg ) ; } try { jdepend . addDirectory ( f . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when adding a class directory: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } } } else if ( getSourcespath ( ) != null ) { String [ ] sP = getSourcespath ( ) . list ( ) ; for ( int i = 0 ; i < sP . length ; i ++ ) { File f = new File ( sP [ i ] ) ; if ( ! f . exists ( ) || ! f . isDirectory ( ) ) { String msg = "\"" + f . getPath ( ) + "\" does not represent a valid" + " directory. JDepend would fail." ; log ( msg ) ; throw new BuildException ( msg ) ; } try { jdepend . addDirectory ( f . getPath ( ) ) ; } catch ( IOException e ) { String msg = "JDepend Failed when adding a source directory: " + e . getMessage ( ) ; log ( msg ) ; throw new BuildException ( msg ) ; } } } String [ ] patterns = defaultPatterns . getExcludePatterns ( getProject ( ) ) ; if ( patterns != null && patterns . length > 0 ) { if ( setFilter != null ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < patterns . length ; i ++ ) { v . addElement ( patterns [ i ] ) ; } try { Object o = packageFilterC . newInstance ( new Object [ ] { v } ) ; setFilter . invoke ( jdepend , new Object [ ] { o } ) ; } catch ( Throwable e ) { log ( "excludes will be ignored as JDepend doesn't like me: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } else { log ( "Sorry, your version of JDepend doesn't support excludes" , Project . MSG_WARN ) ; } } jdepend . analyze ( ) ; } finally { FileUtils . close ( fw ) ; } return SUCCESS ; } public int executeAsForked ( CommandlineJava commandline , ExecuteWatchdog watchdog ) throws BuildException { runtimeClasses = new Path ( getProject ( ) ) ; addClasspathEntry ( "/jdepend/textui/JDepend.class" ) ; createClasspath ( ) ; if ( getClasspath ( ) . toString ( ) . length ( ) > 0 ) { createJvmarg ( commandline ) . setValue ( "-classpath" ) ; createJvmarg ( commandline ) . setValue ( getClasspath ( ) . toString ( ) ) ; } if ( includeRuntime ) { Vector v = Execute . getProcEnvironment ( ) ; Enumeration e = v . elements ( ) ; while ( e . hasMoreElements ( ) ) { String s = ( String ) e . nextElement ( ) ; if ( s . startsWith ( "CLASSPATH=" ) ) { commandline . createClasspath ( getProject ( ) ) . createPath ( ) . append ( new Path ( getProject ( ) , s . substring ( "CLASSPATH=" . length ( ) ) ) ) ; } } log ( "Implicitly adding " + runtimeClasses + " to CLASSPATH" , Project . MSG_VERBOSE ) ; commandline . createClasspath ( getProject ( ) ) . createPath ( ) . append ( runtimeClasses ) ; } if ( getOutputFile ( ) != null ) { commandline . createArgument ( ) . setValue ( "-file" ) ; commandline . createArgument ( ) . setValue ( outputFile . getPath ( ) ) ; } if ( getSourcespath ( ) != null ) { String [ ] sP = getSourcespath ( ) . list ( ) ; for ( int i = 0 ; i < sP . length ; i ++ ) { File f = new File ( sP [ i ] ) ; if ( ! f . exists ( ) || ! f . isDirectory ( ) ) { throw new BuildException ( "\"" + f . getPath ( ) + "\" does not represent a valid" + " directory. JDepend would" + " fail." ) ; } commandline . createArgument ( ) . setValue ( f . getPath ( ) ) ; } } if ( getClassespath ( ) != null ) { String [ ] cP = getClassespath ( ) . list ( ) ; for ( int i = 0 ; i < cP . length ; i ++ ) { File f = new File ( cP [ i ] ) ; if ( ! f . exists ( ) ) { throw new BuildException ( "\"" + f . getPath ( ) + "\" does not represent a valid" + " file or directory. JDepend would" + " fail." ) ; } commandline . createArgument ( ) . setValue ( f . getPath ( ) ) ; } } Execute execute = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , watchdog ) ; execute . setCommandline ( commandline . getCommandline ( ) ) ; if ( getDir ( ) != null ) { execute . setWorkingDirectory ( getDir ( ) ) ; execute . setAntRun ( getProject ( ) ) ; } if ( getOutputFile ( ) != null ) { log ( "Output to be stored in " + getOutputFile ( ) . getPath ( ) ) ; } log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { return execute . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( "Process fork failed." , e , getLocation ( ) ) ; } } protected ExecuteWatchdog createWatchdog ( ) throws BuildException { if ( getTimeout ( ) == null ) { return null ; } return new ExecuteWatchdog ( getTimeout ( ) . longValue ( ) ) ; } } 	0	['31', '3', '0', '19', '107', '391', '0', '19', '28', '0.922807018', '977', '0.894736842', '5', '0.560606061', '0.15', '3', '3', '29.90322581', '3', '1.129', '0']
package org . apache . tools . ant . taskdefs . compilers ; import java . io . IOException ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . FileUtils ; public class JavacExternal extends DefaultCompilerAdapter { public boolean execute ( ) throws BuildException { attributes . log ( "Using external javac compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = new Commandline ( ) ; cmd . setExecutable ( getJavac ( ) . getJavacExecutable ( ) ) ; if ( ! assumeJava11 ( ) && ! assumeJava12 ( ) ) { setupModernJavacCommandlineSwitches ( cmd ) ; } else { setupJavacCommandlineSwitches ( cmd , true ) ; } int firstFileName = assumeJava11 ( ) ? - 1 : cmd . size ( ) ; logAndAddFilesToCompile ( cmd ) ; if ( Os . isFamily ( "openvms" ) ) { return execOnVMS ( cmd , firstFileName ) ; } return executeExternalCompile ( cmd . getCommandline ( ) , firstFileName , true ) == 0 ; } private boolean execOnVMS ( Commandline cmd , int firstFileName ) { File vmsFile = null ; try { vmsFile = JavaEnvUtils . createVmsJavaOptionFile ( cmd . getArguments ( ) ) ; String [ ] commandLine = { cmd . getExecutable ( ) , "-V" , vmsFile . getPath ( ) } ; return 0 == executeExternalCompile ( commandLine , firstFileName , true ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to create a temporary file for \"-V\" switch" ) ; } finally { FileUtils . delete ( vmsFile ) ; } } } 	0	['3', '2', '0', '8', '24', '3', '1', '7', '2', '2', '116', '0', '0', '0.92', '0.555555556', '0', '0', '37.66666667', '4', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . BufferedReader ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . LoaderUtils ; import org . apache . tools . ant . util . TeeOutputStream ; import org . apache . tools . ant . util . FileUtils ; public class ANTLR extends Task { private CommandlineJava commandline = new CommandlineJava ( ) ; private File targetFile ; private File outputDirectory ; private File superGrammar ; private boolean html ; private boolean diagnostic ; private boolean trace ; private boolean traceParser ; private boolean traceLexer ; private boolean traceTreeWalker ; private File workingdir = null ; private ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; private boolean debug ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; public ANTLR ( ) { commandline . setVm ( JavaEnvUtils . getJreExecutable ( "java" ) ) ; commandline . setClassname ( "antlr.Tool" ) ; } public void setTarget ( File target ) { log ( "Setting target to: " + target . toString ( ) , Project . MSG_VERBOSE ) ; this . targetFile = target ; } public void setOutputdirectory ( File outputDirectory ) { log ( "Setting output directory to: " + outputDirectory . toString ( ) , Project . MSG_VERBOSE ) ; this . outputDirectory = outputDirectory ; } public void setGlib ( String superGrammar ) { String sg = null ; if ( Os . isFamily ( "dos" ) ) { sg = superGrammar . replace ( '\\' , '/' ) ; } else { sg = superGrammar ; } setGlib ( FILE_UTILS . resolveFile ( getProject ( ) . getBaseDir ( ) , sg ) ) ; } public void setGlib ( File superGrammar ) { this . superGrammar = superGrammar ; } public void setDebug ( boolean enable ) { this . debug = enable ; } public void setHtml ( boolean enable ) { html = enable ; } public void setDiagnostic ( boolean enable ) { diagnostic = enable ; } public void setTrace ( boolean enable ) { trace = enable ; } public void setTraceParser ( boolean enable ) { traceParser = enable ; } public void setTraceLexer ( boolean enable ) { traceLexer = enable ; } public void setTraceTreeWalker ( boolean enable ) { traceTreeWalker = enable ; } public void setFork ( boolean s ) { } public void setDir ( File d ) { this . workingdir = d ; } public Path createClasspath ( ) { return commandline . createClasspath ( getProject ( ) ) . createPath ( ) ; } public Commandline . Argument createJvmarg ( ) { return commandline . createVmArgument ( ) ; } public void init ( ) throws BuildException { addClasspathEntry ( "/antlr/ANTLRGrammarParseBehavior.class" ) ; } protected void addClasspathEntry ( String resource ) { if ( resource . startsWith ( "/" ) ) { resource = resource . substring ( 1 ) ; } else { resource = "org/apache/tools/ant/taskdefs/optional/" + resource ; } File f = LoaderUtils . getResourceSource ( getClass ( ) . getClassLoader ( ) , resource ) ; if ( f != null ) { log ( "Found " + f . getAbsolutePath ( ) , Project . MSG_DEBUG ) ; createClasspath ( ) . setLocation ( f ) ; } else { log ( "Couldn\'t find " + resource , Project . MSG_VERBOSE ) ; } } public void execute ( ) throws BuildException { validateAttributes ( ) ; File generatedFile = getGeneratedFile ( ) ; boolean targetIsOutOfDate = targetFile . lastModified ( ) > generatedFile . lastModified ( ) ; boolean superGrammarIsOutOfDate = superGrammar != null && ( superGrammar . lastModified ( ) > generatedFile . lastModified ( ) ) ; if ( targetIsOutOfDate || superGrammarIsOutOfDate ) { if ( targetIsOutOfDate ) { log ( "Compiling " + targetFile + " as it is newer than " + generatedFile , Project . MSG_VERBOSE ) ; } else if ( superGrammarIsOutOfDate ) { log ( "Compiling " + targetFile + " as " + superGrammar + " is newer than " + generatedFile , Project . MSG_VERBOSE ) ; } populateAttributes ( ) ; commandline . createArgument ( ) . setValue ( targetFile . toString ( ) ) ; log ( commandline . describeCommand ( ) , Project . MSG_VERBOSE ) ; int err = run ( commandline . getCommandline ( ) ) ; if ( err != 0 ) { throw new BuildException ( "ANTLR returned: " + err , getLocation ( ) ) ; } else { String output = bos . toString ( ) ; if ( output . indexOf ( "error:" ) > - 1 ) { throw new BuildException ( "ANTLR signaled an error: " + output , getLocation ( ) ) ; } } } else { log ( "Skipped grammar file. Generated file " + generatedFile + " is newer." , Project . MSG_VERBOSE ) ; } } private void populateAttributes ( ) { commandline . createArgument ( ) . setValue ( "-o" ) ; commandline . createArgument ( ) . setValue ( outputDirectory . toString ( ) ) ; if ( superGrammar != null ) { commandline . createArgument ( ) . setValue ( "-glib" ) ; commandline . createArgument ( ) . setValue ( superGrammar . toString ( ) ) ; } if ( html ) { commandline . createArgument ( ) . setValue ( "-html" ) ; } if ( diagnostic ) { commandline . createArgument ( ) . setValue ( "-diagnostic" ) ; } if ( trace ) { commandline . createArgument ( ) . setValue ( "-trace" ) ; } if ( traceParser ) { commandline . createArgument ( ) . setValue ( "-traceParser" ) ; } if ( traceLexer ) { commandline . createArgument ( ) . setValue ( "-traceLexer" ) ; } if ( traceTreeWalker ) { if ( is272 ( ) ) { commandline . createArgument ( ) . setValue ( "-traceTreeParser" ) ; } else { commandline . createArgument ( ) . setValue ( "-traceTreeWalker" ) ; } } if ( debug ) { commandline . createArgument ( ) . setValue ( "-debug" ) ; } } private void validateAttributes ( ) throws BuildException { if ( targetFile == null || ! targetFile . isFile ( ) ) { throw new BuildException ( "Invalid target: " + targetFile ) ; } if ( outputDirectory == null ) { setOutputdirectory ( new File ( targetFile . getParent ( ) ) ) ; } if ( ! outputDirectory . isDirectory ( ) ) { throw new BuildException ( "Invalid output directory: " + outputDirectory ) ; } } private File getGeneratedFile ( ) throws BuildException { String generatedFileName = null ; try { BufferedReader in = new BufferedReader ( new FileReader ( targetFile ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { int extendsIndex = line . indexOf ( " extends " ) ; if ( line . startsWith ( "class " ) && extendsIndex > - 1 ) { generatedFileName = line . substring ( 6 , extendsIndex ) . trim ( ) ; break ; } } in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Unable to determine generated class" , e ) ; } if ( generatedFileName == null ) { throw new BuildException ( "Unable to determine generated class" ) ; } return new File ( outputDirectory , generatedFileName + ( html ? ".html" : ".java" ) ) ; } private int run ( String [ ] command ) throws BuildException { PumpStreamHandler psh = new PumpStreamHandler ( new LogOutputStream ( this , Project . MSG_INFO ) , new TeeOutputStream ( new LogOutputStream ( this , Project . MSG_WARN ) , bos ) ) ; Execute exe = new Execute ( psh , null ) ; exe . setAntRun ( getProject ( ) ) ; if ( workingdir != null ) { exe . setWorkingDirectory ( workingdir ) ; } exe . setCommandline ( command ) ; try { return exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } finally { FileUtils . close ( bos ) ; } } protected boolean is272 ( ) { AntClassLoader l = null ; try { l = getProject ( ) . createClassLoader ( commandline . getClasspath ( ) ) ; l . loadClass ( "antlr.Version" ) ; return true ; } catch ( ClassNotFoundException e ) { return false ; } finally { if ( l != null ) { l . cleanup ( ) ; } } } } 	0	['25', '3', '0', '18', '91', '218', '0', '18', '18', '0.889880952', '671', '1', '2', '0.616666667', '0.325', '1', '1', '25.28', '10', '1.56', '0']
package org . apache . tools . ant . taskdefs . optional . clearcase ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . types . Commandline ; public class CCMklabel extends ClearCase { private boolean mReplace = false ; private boolean mRecurse = false ; private String mVersion = null ; private String mTypeName = null ; private String mVOB = null ; private String mComment = null ; private String mCfile = null ; public void execute ( ) throws BuildException { Commandline commandLine = new Commandline ( ) ; Project aProj = getProject ( ) ; int result = 0 ; if ( getTypeName ( ) == null ) { throw new BuildException ( "Required attribute TypeName not specified" ) ; } if ( getViewPath ( ) == null ) { setViewPath ( aProj . getBaseDir ( ) . getPath ( ) ) ; } commandLine . setExecutable ( getClearToolCommand ( ) ) ; commandLine . createArgument ( ) . setValue ( COMMAND_MKLABEL ) ; checkOptions ( commandLine ) ; if ( ! getFailOnErr ( ) ) { getProject ( ) . log ( "Ignoring any errors that occur for: " + getViewPathBasename ( ) , Project . MSG_VERBOSE ) ; } result = run ( commandLine ) ; if ( Execute . isFailure ( result ) && getFailOnErr ( ) ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private void checkOptions ( Commandline cmd ) { if ( getReplace ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_REPLACE ) ; } if ( getRecurse ( ) ) { cmd . createArgument ( ) . setValue ( FLAG_RECURSE ) ; } if ( getVersion ( ) != null ) { getVersionCommand ( cmd ) ; } if ( getComment ( ) != null ) { getCommentCommand ( cmd ) ; } else { if ( getCommentFile ( ) != null ) { getCommentFileCommand ( cmd ) ; } else { cmd . createArgument ( ) . setValue ( FLAG_NOCOMMENT ) ; } } if ( getTypeName ( ) != null ) { getTypeCommand ( cmd ) ; } cmd . createArgument ( ) . setValue ( getViewPath ( ) ) ; } public void setReplace ( boolean replace ) { mReplace = replace ; } public boolean getReplace ( ) { return mReplace ; } public void setRecurse ( boolean recurse ) { mRecurse = recurse ; } public boolean getRecurse ( ) { return mRecurse ; } public void setVersion ( String version ) { mVersion = version ; } public String getVersion ( ) { return mVersion ; } public void setComment ( String comment ) { mComment = comment ; } public String getComment ( ) { return mComment ; } public void setCommentFile ( String cfile ) { mCfile = cfile ; } public String getCommentFile ( ) { return mCfile ; } public void setTypeName ( String tn ) { mTypeName = tn ; } public String getTypeName ( ) { return mTypeName ; } public void setVOB ( String vob ) { mVOB = vob ; } public String getVOB ( ) { return mVOB ; } private void getVersionCommand ( Commandline cmd ) { if ( getVersion ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_VERSION ) ; cmd . createArgument ( ) . setValue ( getVersion ( ) ) ; } } private void getCommentCommand ( Commandline cmd ) { if ( getComment ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENT ) ; cmd . createArgument ( ) . setValue ( getComment ( ) ) ; } } private void getCommentFileCommand ( Commandline cmd ) { if ( getCommentFile ( ) != null ) { cmd . createArgument ( ) . setValue ( FLAG_COMMENTFILE ) ; cmd . createArgument ( ) . setValue ( getCommentFile ( ) ) ; } } private void getTypeCommand ( Commandline cmd ) { String typenm = null ; if ( getTypeName ( ) != null ) { typenm = getTypeName ( ) ; if ( getVOB ( ) != null ) { typenm += "@" + getVOB ( ) ; } cmd . createArgument ( ) . setValue ( typenm ) ; } } public static final String FLAG_REPLACE = "-replace" ; public static final String FLAG_RECURSE = "-recurse" ; public static final String FLAG_VERSION = "-version" ; public static final String FLAG_COMMENT = "-c" ; public static final String FLAG_COMMENTFILE = "-cfile" ; public static final String FLAG_NOCOMMENT = "-nc" ; } 	0	['21', '4', '0', '7', '45', '168', '0', '7', '16', '0.923076923', '302', '0.538461538', '0', '0.705882353', '0.392857143', '2', '3', '12.76190476', '7', '1.4762', '0']
package org . apache . tools . ant . util ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; public class UUEncoder { protected static final int DEFAULT_MODE = 644 ; private static final int MAX_CHARS_PER_LINE = 45 ; private OutputStream out ; private String name ; public UUEncoder ( String name ) { this . name = name ; } public void encode ( InputStream is , OutputStream out ) throws IOException { this . out = out ; encodeBegin ( ) ; byte [ ] buffer = new byte [ MAX_CHARS_PER_LINE * 100 ] ; int count ; while ( ( count = is . read ( buffer , 0 , buffer . length ) ) != - 1 ) { int pos = 0 ; while ( count > 0 ) { int num = count > MAX_CHARS_PER_LINE ? MAX_CHARS_PER_LINE : count ; encodeLine ( buffer , pos , num , out ) ; pos += num ; count -= num ; } } out . flush ( ) ; encodeEnd ( ) ; } private void encodeString ( String n ) throws IOException { PrintStream writer = new PrintStream ( out ) ; writer . print ( n ) ; writer . flush ( ) ; } private void encodeBegin ( ) throws IOException { encodeString ( "begin " + DEFAULT_MODE + " " + name + "\n" ) ; } private void encodeEnd ( ) throws IOException { encodeString ( " \nend\n" ) ; } private void encodeLine ( byte [ ] data , int offset , int length , OutputStream out ) throws IOException { out . write ( ( byte ) ( ( length & 0x3F ) + ' ' ) ) ; byte a ; byte b ; byte c ; for ( int i = 0 ; i < length ; ) { b = 1 ; c = 1 ; a = data [ offset + i ++ ] ; if ( i < length ) { b = data [ offset + i ++ ] ; if ( i < length ) { c = data [ offset + i ++ ] ; } } byte d1 = ( byte ) ( ( ( a > > > 2 ) & 0x3F ) + ' ' ) ; byte d2 = ( byte ) ( ( ( ( a << 4 ) & 0x30 ) | ( ( b > > > 4 ) & 0x0F ) ) + ' ' ) ; byte d3 = ( byte ) ( ( ( ( b << 2 ) & 0x3C ) | ( ( c > > > 6 ) & 0x3 ) ) + ' ' ) ; byte d4 = ( byte ) ( ( c & 0x3F ) + ' ' ) ; out . write ( d1 ) ; out . write ( d2 ) ; out . write ( d3 ) ; out . write ( d4 ) ; } out . write ( '\n' ) ; } } 	0	['6', '1', '0', '1', '16', '11', '1', '0', '2', '0.85', '202', '1', '0', '0', '0.361111111', '0', '0', '32', '1', '0.8333', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . CommandlineJava ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Permissions ; import org . apache . tools . ant . util . JavaEnvUtils ; import org . apache . tools . ant . util . TimeoutObserver ; import org . apache . tools . ant . util . Watchdog ; public class ExecuteJava implements Runnable , TimeoutObserver { private Commandline javaCommand = null ; private Path classpath = null ; private CommandlineJava . SysProperties sysProperties = null ; private Permissions perm = null ; private Method main = null ; private Long timeout = null ; private volatile Throwable caught = null ; private volatile boolean timedOut = false ; private Thread thread = null ; public void setJavaCommand ( Commandline javaCommand ) { this . javaCommand = javaCommand ; } public void setClasspath ( Path p ) { classpath = p ; } public void setSystemProperties ( CommandlineJava . SysProperties s ) { sysProperties = s ; } public void setPermissions ( Permissions permissions ) { perm = permissions ; } public void setOutput ( PrintStream out ) { } public void setTimeout ( Long timeout ) { this . timeout = timeout ; } public void execute ( Project project ) throws BuildException { final String classname = javaCommand . getExecutable ( ) ; AntClassLoader loader = null ; try { if ( sysProperties != null ) { sysProperties . setSystem ( ) ; } Class target = null ; try { if ( classpath == null ) { target = Class . forName ( classname ) ; } else { loader = project . createClassLoader ( classpath ) ; loader . setParent ( project . getCoreLoader ( ) ) ; loader . setParentFirst ( false ) ; loader . addJavaLibraries ( ) ; loader . setIsolated ( true ) ; loader . setThreadContextLoader ( ) ; loader . forceLoadClass ( classname ) ; target = Class . forName ( classname , true , loader ) ; } } catch ( ClassNotFoundException e ) { throw new BuildException ( "Could not find " + classname + "." + " Make sure you have it in your" + " classpath" ) ; } main = target . getMethod ( "main" , new Class [ ] { String [ ] . class } ) ; if ( main == null ) { throw new BuildException ( "Could not find main() method in " + classname ) ; } if ( ( main . getModifiers ( ) & Modifier . STATIC ) == 0 ) { throw new BuildException ( "main() method in " + classname + " is not declared static" ) ; } if ( timeout == null ) { run ( ) ; } else { thread = new Thread ( this , "ExecuteJava" ) ; Task currentThreadTask = project . getThreadTask ( Thread . currentThread ( ) ) ; project . registerThreadTask ( thread , currentThreadTask ) ; thread . setDaemon ( true ) ; Watchdog w = new Watchdog ( timeout . longValue ( ) ) ; w . addTimeoutObserver ( this ) ; synchronized ( this ) { thread . start ( ) ; w . start ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { } if ( timedOut ) { project . log ( "Timeout: sub-process interrupted" , Project . MSG_WARN ) ; } else { thread = null ; w . stop ( ) ; } } } if ( caught != null ) { throw caught ; } } catch ( BuildException e ) { throw e ; } catch ( SecurityException e ) { throw e ; } catch ( ThreadDeath e ) { throw e ; } catch ( Throwable e ) { throw new BuildException ( e ) ; } finally { if ( loader != null ) { loader . resetThreadContextLoader ( ) ; loader . cleanup ( ) ; loader = null ; } if ( sysProperties != null ) { sysProperties . restoreSystem ( ) ; } } } public void run ( ) { final Object [ ] argument = { javaCommand . getArguments ( ) } ; try { if ( perm != null ) { perm . setSecurityManager ( ) ; } main . invoke ( null , argument ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( ! ( t instanceof InterruptedException ) ) { caught = t ; } } catch ( Throwable t ) { caught = t ; } finally { if ( perm != null ) { perm . restoreSecurityManager ( ) ; } synchronized ( this ) { notifyAll ( ) ; } } } public synchronized void timeoutOccured ( Watchdog w ) { if ( thread != null ) { timedOut = true ; thread . interrupt ( ) ; } notifyAll ( ) ; } public synchronized boolean killedProcess ( ) { return timedOut ; } public int fork ( ProjectComponent pc ) throws BuildException { CommandlineJava cmdl = new CommandlineJava ( ) ; cmdl . setClassname ( javaCommand . getExecutable ( ) ) ; String [ ] args = javaCommand . getArguments ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) { cmdl . createArgument ( ) . setValue ( args [ i ] ) ; } if ( classpath != null ) { cmdl . createClasspath ( pc . getProject ( ) ) . append ( classpath ) ; } if ( sysProperties != null ) { cmdl . addSysproperties ( sysProperties ) ; } Redirector redirector = new Redirector ( pc ) ; Execute exe = new Execute ( redirector . createHandler ( ) , timeout == null ? null : new ExecuteWatchdog ( timeout . longValue ( ) ) ) ; exe . setAntRun ( pc . getProject ( ) ) ; if ( Os . isFamily ( "openvms" ) ) { setupCommandLineForVMS ( exe , cmdl . getCommandline ( ) ) ; } else { exe . setCommandline ( cmdl . getCommandline ( ) ) ; } try { int rc = exe . execute ( ) ; redirector . complete ( ) ; return rc ; } catch ( IOException e ) { throw new BuildException ( e ) ; } finally { timedOut = exe . killedProcess ( ) ; } } public static void setupCommandLineForVMS ( Execute exe , String [ ] command ) { exe . setVMLauncher ( true ) ; File vmsJavaOptionFile = null ; try { String [ ] args = new String [ command . length - 1 ] ; System . arraycopy ( command , 1 , args , 0 , command . length - 1 ) ; vmsJavaOptionFile = JavaEnvUtils . createVmsJavaOptionFile ( args ) ; vmsJavaOptionFile . deleteOnExit ( ) ; String [ ] vmsCmd = { command [ 0 ] , "-V" , vmsJavaOptionFile . getPath ( ) } ; exe . setCommandline ( vmsCmd ) ; } catch ( IOException e ) { throw new BuildException ( "Failed to create a temporary file for \"-V\" switch" ) ; } } } 	0	['13', '1', '0', '24', '82', '22', '5', '19', '13', '0.783333333', '552', '0.9', '4', '0', '0.147435897', '0', '0', '40.69230769', '6', '1.3846', '0']
package org . apache . tools . ant . taskdefs . condition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . SAXNotRecognizedException ; import org . xml . sax . SAXNotSupportedException ; import org . xml . sax . XMLReader ; public class ParserSupports extends ProjectComponent implements Condition { private String feature ; private String property ; private String value ; public static final String ERROR_BOTH_ATTRIBUTES = "Property and feature attributes are exclusive" ; public static final String FEATURE = "feature" ; public static final String PROPERTY = "property" ; public static final String NOT_RECOGNIZED = " not recognized: " ; public static final String NOT_SUPPORTED = " not supported: " ; public static final String ERROR_NO_ATTRIBUTES = "Neither feature or property are set" ; public static final String ERROR_NO_VALUE = "A value is needed when testing for property support" ; public void setFeature ( String feature ) { this . feature = feature ; } public void setProperty ( String property ) { this . property = property ; } public void setValue ( String value ) { this . value = value ; } public boolean eval ( ) throws BuildException { if ( feature != null && property != null ) { throw new BuildException ( ERROR_BOTH_ATTRIBUTES ) ; } if ( feature == null && property == null ) { throw new BuildException ( ERROR_NO_ATTRIBUTES ) ; } if ( feature != null ) { return evalFeature ( ) ; } if ( value == null ) { throw new BuildException ( ERROR_NO_VALUE ) ; } return evalProperty ( ) ; } private XMLReader getReader ( ) { JAXPUtils . getParser ( ) ; return JAXPUtils . getXMLReader ( ) ; } public boolean evalFeature ( ) { XMLReader reader = getReader ( ) ; if ( value == null ) { value = "true" ; } boolean v = Project . toBoolean ( value ) ; try { reader . setFeature ( feature , v ) ; } catch ( SAXNotRecognizedException e ) { log ( FEATURE + NOT_RECOGNIZED + feature , Project . MSG_VERBOSE ) ; return false ; } catch ( SAXNotSupportedException e ) { log ( FEATURE + NOT_SUPPORTED + feature , Project . MSG_VERBOSE ) ; return false ; } return true ; } public boolean evalProperty ( ) { XMLReader reader = getReader ( ) ; try { reader . setProperty ( property , value ) ; } catch ( SAXNotRecognizedException e ) { log ( PROPERTY + NOT_RECOGNIZED + property , Project . MSG_VERBOSE ) ; return false ; } catch ( SAXNotSupportedException e ) { log ( PROPERTY + NOT_SUPPORTED + property , Project . MSG_VERBOSE ) ; return false ; } return true ; } } 	0	['8', '2', '0', '5', '19', '8', '0', '5', '7', '1', '165', '0.3', '0', '0.5625', '0.6875', '0', '0', '18.375', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . sos ; import org . apache . tools . ant . types . Commandline ; public class SOSCheckin extends SOS { public final void setFile ( String filename ) { super . setInternalFilename ( filename ) ; } public void setRecursive ( boolean recursive ) { super . setInternalRecursive ( recursive ) ; } public void setComment ( String comment ) { super . setInternalComment ( comment ) ; } protected Commandline buildCmdLine ( ) { commandLine = new Commandline ( ) ; if ( getFilename ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKIN_FILE ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_FILE ) ; commandLine . createArgument ( ) . setValue ( getFilename ( ) ) ; } else { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMAND ) ; commandLine . createArgument ( ) . setValue ( SOSCmd . COMMAND_CHECKIN_PROJECT ) ; commandLine . createArgument ( ) . setValue ( getRecursive ( ) ) ; } getRequiredAttributes ( ) ; getOptionalAttributes ( ) ; if ( getComment ( ) != null ) { commandLine . createArgument ( ) . setValue ( SOSCmd . FLAG_COMMENT ) ; commandLine . createArgument ( ) . setValue ( getComment ( ) ) ; } return commandLine ; } } 	0	['5', '4', '0', '3', '17', '10', '0', '3', '4', '2', '87', '0', '0', '0.948717949', '0.533333333', '1', '2', '16.4', '3', '1.2', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . io . File ; public interface Algorithm { boolean isValid ( ) ; String getValue ( File file ) ; } 	0	['2', '1', '0', '4', '2', '1', '4', '0', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . bcel . classfile . ConstantClass ; import org . apache . bcel . classfile . ConstantPool ; import org . apache . bcel . classfile . EmptyVisitor ; import org . apache . bcel . classfile . Field ; import org . apache . bcel . classfile . JavaClass ; import org . apache . bcel . classfile . Method ; import org . apache . bcel . classfile . ConstantNameAndType ; public class DependencyVisitor extends EmptyVisitor { private Hashtable dependencies = new Hashtable ( ) ; private ConstantPool constantPool ; public Enumeration getDependencies ( ) { return dependencies . keys ( ) ; } public void clearDependencies ( ) { dependencies . clear ( ) ; } public void visitConstantPool ( ConstantPool constantPool ) { this . constantPool = constantPool ; } public void visitConstantClass ( ConstantClass constantClass ) { String classname = constantClass . getConstantValue ( constantPool ) . toString ( ) ; addSlashClass ( classname ) ; } public void visitConstantNameAndType ( ConstantNameAndType obj ) { String name = obj . getName ( constantPool ) ; if ( obj . getSignature ( constantPool ) . equals ( "Ljava/lang/Class;" ) && name . startsWith ( "class$" ) ) { String classname = name . substring ( 6 ) . replace ( '$' , '.' ) ; int index = classname . lastIndexOf ( "." ) ; if ( index > 0 ) { char start ; int index2 = classname . lastIndexOf ( "." , index - 1 ) ; if ( index2 != - 1 ) { start = classname . charAt ( index2 + 1 ) ; } else { start = classname . charAt ( 0 ) ; } if ( ( start > 0x40 ) && ( start < 0x5B ) ) { classname = classname . substring ( 0 , index ) + "$" + classname . substring ( index + 1 ) ; addClass ( classname ) ; } else { addClass ( classname ) ; } } else { addClass ( classname ) ; } } } public void visitField ( Field field ) { addClasses ( field . getSignature ( ) ) ; } public void visitJavaClass ( JavaClass javaClass ) { addClass ( javaClass . getClassName ( ) ) ; } public void visitMethod ( Method method ) { String signature = method . getSignature ( ) ; int pos = signature . indexOf ( ")" ) ; addClasses ( signature . substring ( 1 , pos ) ) ; addClasses ( signature . substring ( pos + 1 ) ) ; } void addClass ( String classname ) { dependencies . put ( classname , classname ) ; } private void addClasses ( String string ) { StringTokenizer tokens = new StringTokenizer ( string , ";" ) ; while ( tokens . hasMoreTokens ( ) ) { String descriptor = tokens . nextToken ( ) ; int pos = descriptor . indexOf ( 'L' ) ; if ( pos != - 1 ) { addSlashClass ( descriptor . substring ( pos + 1 ) ) ; } } } private void addSlashClass ( String classname ) { addClass ( classname . replace ( '/' , '.' ) ) ; } } 	0	['12', '2', '0', '8', '41', '48', '1', '7', '9', '0.636363636', '203', '1', '0', '0.744186047', '0.21875', '1', '1', '15.75', '7', '1.5833', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Hashtable ; import java . util . StringTokenizer ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class KeySubst extends Task { private File source = null ; private File dest = null ; private String sep = "*" ; private Hashtable replacements = new Hashtable ( ) ; public void execute ( ) throws BuildException { log ( "!! KeySubst is deprecated. Use Filter + Copy instead. !!" ) ; log ( "Performing Substitutions" ) ; if ( source == null || dest == null ) { log ( "Source and destinations must not be null" ) ; return ; } BufferedReader br = null ; BufferedWriter bw = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; dest . delete ( ) ; bw = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = null ; String newline = null ; line = br . readLine ( ) ; while ( line != null ) { if ( line . length ( ) == 0 ) { bw . newLine ( ) ; } else { newline = KeySubst . replace ( line , replacements ) ; bw . write ( newline ) ; bw . newLine ( ) ; } line = br . readLine ( ) ; } bw . flush ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { if ( bw != null ) { try { bw . close ( ) ; } catch ( IOException e ) { } } if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { } } } } public void setSrc ( File s ) { this . source = s ; } public void setDest ( File dest ) { this . dest = dest ; } public void setSep ( String sep ) { this . sep = sep ; } public void setKeys ( String keys ) { if ( keys != null && keys . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( keys , this . sep , false ) ; while ( tok . hasMoreTokens ( ) ) { String token = tok . nextToken ( ) . trim ( ) ; StringTokenizer itok = new StringTokenizer ( token , "=" , false ) ; String name = itok . nextToken ( ) ; String value = itok . nextToken ( ) ; replacements . put ( name , value ) ; } } } public static void main ( String [ ] args ) { try { Hashtable hash = new Hashtable ( ) ; hash . put ( "VERSION" , "1.0.3" ) ; hash . put ( "b" , "ffff" ) ; System . out . println ( KeySubst . replace ( "$f ${VERSION} f ${b} jj $" , hash ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String replace ( String origString , Hashtable keys ) throws BuildException { StringBuffer finalString = new StringBuffer ( ) ; int index = 0 ; int i = 0 ; String key = null ; while ( ( index = origString . indexOf ( "${" , i ) ) > - 1 ) { key = origString . substring ( index + 2 , origString . indexOf ( "}" , index + 3 ) ) ; finalString . append ( origString . substring ( i , index ) ) ; if ( keys . containsKey ( key ) ) { finalString . append ( keys . get ( key ) ) ; } else { finalString . append ( "${" ) ; finalString . append ( key ) ; finalString . append ( "}" ) ; } i = index + 3 + key . length ( ) ; } finalString . append ( origString . substring ( i ) ) ; return finalString . toString ( ) ; } } 	0	['8', '3', '0', '2', '40', '10', '0', '2', '8', '0.714285714', '281', '1', '0', '0.840909091', '0.325', '1', '1', '33.625', '4', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class NameAndTypeCPInfo extends ConstantPoolEntry { public NameAndTypeCPInfo ( ) { super ( CONSTANT_NAMEANDTYPE , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { nameIndex = cpStream . readUnsignedShort ( ) ; descriptorIndex = cpStream . readUnsignedShort ( ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "Name = " + name + ", type = " + type ; } else { value = "Name index = " + nameIndex + ", descriptor index = " + descriptorIndex ; } return value ; } public void resolve ( ConstantPool constantPool ) { name = ( ( Utf8CPInfo ) constantPool . getEntry ( nameIndex ) ) . getValue ( ) ; type = ( ( Utf8CPInfo ) constantPool . getEntry ( descriptorIndex ) ) . getValue ( ) ; super . resolve ( constantPool ) ; } public String getName ( ) { return name ; } public String getType ( ) { return type ; } private String name ; private String type ; private int nameIndex ; private int descriptorIndex ; } 	0	['6', '2', '0', '6', '16', '1', '5', '3', '6', '0.6', '84', '1', '0', '0.545454545', '0.444444444', '1', '1', '12.33333333', '2', '1', '0']
package org . apache . tools . ant . types . selectors . modifiedselector ; import java . util . zip . Checksum ; import java . util . zip . CRC32 ; import java . util . zip . Adler32 ; import java . util . zip . CheckedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . BufferedInputStream ; import java . security . NoSuchAlgorithmException ; import org . apache . tools . ant . BuildException ; public class ChecksumAlgorithm implements Algorithm { private String algorithm = "CRC" ; private Checksum checksum = null ; public void setAlgorithm ( String algorithm ) { this . algorithm = algorithm ; } public void initChecksum ( ) { if ( checksum != null ) { return ; } if ( "CRC" . equalsIgnoreCase ( algorithm ) ) { checksum = new CRC32 ( ) ; } else if ( "ADLER" . equalsIgnoreCase ( algorithm ) ) { checksum = new Adler32 ( ) ; } else { throw new BuildException ( new NoSuchAlgorithmException ( ) ) ; } } public boolean isValid ( ) { return "CRC" . equalsIgnoreCase ( algorithm ) || "ADLER" . equalsIgnoreCase ( algorithm ) ; } public String getValue ( File file ) { initChecksum ( ) ; String rval = null ; try { if ( file . canRead ( ) ) { checksum . reset ( ) ; FileInputStream fis = new FileInputStream ( file ) ; CheckedInputStream check = new CheckedInputStream ( fis , checksum ) ; BufferedInputStream in = new BufferedInputStream ( check ) ; while ( in . read ( ) != - 1 ) { } rval = Long . toString ( check . getChecksum ( ) . getValue ( ) ) ; in . close ( ) ; } } catch ( Exception e ) { rval = null ; } return rval ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "<ChecksumAlgorithm:" ) ; buf . append ( "algorithm=" ) . append ( algorithm ) ; buf . append ( ">" ) ; return buf . toString ( ) ; } } 	0	['6', '1', '0', '3', '25', '0', '1', '2', '6', '0.3', '135', '1', '0', '0', '0.444444444', '0', '0', '21.16666667', '4', '2', '0']
package org . apache . tools . ant . taskdefs ; public interface XSLTLogger { void log ( String msg ) ; } 	0	['1', '1', '0', '3', '1', '0', '3', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . input ; import java . io . FileInputStream ; import java . io . IOException ; import java . util . Properties ; import org . apache . tools . ant . BuildException ; public class PropertyFileInputHandler implements InputHandler { private Properties props = null ; public static final String FILE_NAME_KEY = "ant.input.properties" ; public PropertyFileInputHandler ( ) { } public void handleInput ( InputRequest request ) throws BuildException { readProps ( ) ; Object o = props . get ( request . getPrompt ( ) ) ; if ( o == null ) { throw new BuildException ( "Unable to find input for \'" + request . getPrompt ( ) + "\'" ) ; } request . setInput ( o . toString ( ) ) ; if ( ! request . isInputValid ( ) ) { throw new BuildException ( "Found invalid input " + o + " for \'" + request . getPrompt ( ) + "\'" ) ; } } private synchronized void readProps ( ) throws BuildException { if ( props == null ) { String propsFile = System . getProperty ( FILE_NAME_KEY ) ; if ( propsFile == null ) { throw new BuildException ( "System property " + FILE_NAME_KEY + " for PropertyFileInputHandler not" + " set" ) ; } props = new Properties ( ) ; try { props . load ( new FileInputStream ( propsFile ) ) ; } catch ( IOException e ) { throw new BuildException ( "Couldn't load " + propsFile , e ) ; } } } } 	0	['3', '1', '0', '4', '19', '0', '1', '3', '2', '0.75', '101', '0.5', '0', '0', '0.666666667', '0', '0', '32', '1', '0.6667', '0']
package org . apache . tools . ant . types ; public class DTDLocation extends ResourceLocation { } 	0	['1', '2', '1', '3', '2', '0', '2', '1', '1', '2', '4', '0', '0', '1', '1', '0', '0', '3', '0', '0', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class P4Sync extends P4Base { String label ; private String syncCmd = "" ; public void setLabel ( String label ) throws BuildException { if ( label == null || label . equals ( "" ) ) { throw new BuildException ( "P4Sync: Labels cannot be Null or Empty" ) ; } this . label = label ; } public void setForce ( String force ) throws BuildException { if ( force == null && ! label . equals ( "" ) ) { throw new BuildException ( "P4Sync: If you want to force, set force to non-null string!" ) ; } P4CmdOpts = "-f" ; } public void execute ( ) throws BuildException { if ( P4View != null ) { syncCmd = P4View ; } if ( label != null && ! label . equals ( "" ) ) { syncCmd = syncCmd + "@" + label ; } log ( "Execing sync " + P4CmdOpts + " " + syncCmd , Project . MSG_VERBOSE ) ; execP4Command ( "-s sync " + P4CmdOpts + " " + syncCmd , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['4', '4', '0', '4', '14', '0', '0', '4', '4', '0.5', '108', '0.5', '0', '0.944444444', '0.75', '3', '3', '25.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public class Deltree extends Task { private File dir ; public void setDir ( File dir ) { this . dir = dir ; } public void execute ( ) throws BuildException { log ( "DEPRECATED - The deltree task is deprecated.  " + "Use delete instead." ) ; if ( dir == null ) { throw new BuildException ( "dir attribute must be set!" , getLocation ( ) ) ; } if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) , getLocation ( ) ) ; } return ; } log ( "Deleting: " + dir . getAbsolutePath ( ) ) ; try { removeDir ( dir ) ; } catch ( IOException ioe ) { String msg = "Unable to delete " + dir . getAbsolutePath ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } } private void removeDir ( File dir ) throws IOException { String [ ] list = dir . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { String s = list [ i ] ; File f = new File ( dir , s ) ; if ( f . isDirectory ( ) ) { removeDir ( f ) ; } else { if ( ! f . delete ( ) ) { throw new BuildException ( "Unable to delete file " + f . getAbsolutePath ( ) ) ; } } } if ( ! dir . delete ( ) ) { throw new BuildException ( "Unable to delete directory " + dir . getAbsolutePath ( ) ) ; } } } 	0	['4', '3', '0', '3', '18', '4', '0', '3', '3', '0.666666667', '147', '1', '0', '0.925', '0.75', '1', '1', '35.5', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . rmic ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . ExecuteJava ; import org . apache . tools . ant . types . Commandline ; public class KaffeRmic extends DefaultRmicAdapter { private static final String [ ] RMIC_CLASSNAMES = new String [ ] { "gnu.classpath.tools.rmi.rmic.RMIC" , "gnu.java.rmi.rmic.RMIC" , "kaffe.rmi.rmic.RMIC" , } ; public static final String COMPILER_NAME = "kaffe" ; public boolean execute ( ) throws BuildException { getRmic ( ) . log ( "Using Kaffe rmic" , Project . MSG_VERBOSE ) ; Commandline cmd = setupRmicCommand ( ) ; Class c = getRmicClass ( ) ; if ( c == null ) { StringBuffer buf = new StringBuffer ( "Cannot use Kaffe rmic, as it" + " is not available.  None" + " of " ) ; for ( int i = 0 ; i < RMIC_CLASSNAMES . length ; i ++ ) { if ( i != 0 ) { buf . append ( ", " ) ; } buf . append ( RMIC_CLASSNAMES [ i ] ) ; } buf . append ( " have been found. A common solution is to set the" + " environment variable JAVA_HOME or CLASSPATH." ) ; throw new BuildException ( buf . toString ( ) , getRmic ( ) . getLocation ( ) ) ; } cmd . setExecutable ( c . getName ( ) ) ; if ( ! c . getName ( ) . equals ( RMIC_CLASSNAMES [ RMIC_CLASSNAMES . length - 1 ] ) ) { cmd . createArgument ( ) . setValue ( "-verbose" ) ; getRmic ( ) . log ( Commandline . describeCommand ( cmd ) ) ; } ExecuteJava ej = new ExecuteJava ( ) ; ej . setJavaCommand ( cmd ) ; return ej . fork ( getRmic ( ) ) == 0 ; } public static boolean isAvailable ( ) { return getRmicClass ( ) != null ; } private static Class getRmicClass ( ) { for ( int i = 0 ; i < RMIC_CLASSNAMES . length ; i ++ ) { try { return Class . forName ( RMIC_CLASSNAMES [ i ] ) ; } catch ( ClassNotFoundException cnfe ) { } } return null ; } } 	0	['5', '2', '0', '9', '25', '4', '1', '8', '3', '0.75', '137', '0.5', '0', '0.8125', '0.5', '0', '0', '26', '2', '1', '0']
package org . apache . tools . ant . input ; public class InputRequest { private String prompt ; private String input ; private String defaultValue ; public InputRequest ( String prompt ) { if ( prompt == null ) { throw new IllegalArgumentException ( "prompt must not be null" ) ; } this . prompt = prompt ; } public String getPrompt ( ) { return prompt ; } public void setInput ( String input ) { this . input = input ; } public boolean isInputValid ( ) { return true ; } public String getInput ( ) { return input ; } public String getDefaultValue ( ) { return defaultValue ; } public void setDefaultValue ( String d ) { defaultValue = d ; } } 	0	['7', '1', '1', '6', '9', '15', '6', '0', '7', '0.833333333', '42', '1', '0', '0', '0.714285714', '0', '0', '4.571428571', '1', '0.8571', '0']
package org . apache . tools . ant ; public class UnsupportedAttributeException extends BuildException { private String attribute ; public UnsupportedAttributeException ( String msg , String attribute ) { super ( msg ) ; this . attribute = attribute ; } public String getAttribute ( ) { return attribute ; } } 	0	['2', '5', '0', '4', '3', '0', '3', '1', '2', '0', '13', '1', '0', '0.954545455', '0.75', '0', '0', '5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . taskdefs . condition . IsSigned ; public class SignedSelector extends DataType implements FileSelector { private IsSigned isSigned = new IsSigned ( ) ; public void setName ( String name ) { isSigned . setName ( name ) ; } public boolean isSelected ( File basedir , String filename , File file ) { if ( file . isDirectory ( ) ) { return false ; } isSigned . setProject ( getProject ( ) ) ; isSigned . setFile ( file ) ; return isSigned . eval ( ) ; } } 	0	['3', '3', '0', '4', '11', '0', '0', '4', '3', '0', '35', '1', '1', '0.9375', '0.666666667', '0', '0', '10.33333333', '2', '1', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . types . Parameter ; public final class PrefixLines extends BaseParamFilterReader implements ChainableReader { private static final String PREFIX_KEY = "prefix" ; private String prefix = null ; private String queuedData = null ; public PrefixLines ( ) { super ( ) ; } public PrefixLines ( final Reader in ) { super ( in ) ; } public int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( queuedData != null && queuedData . length ( ) == 0 ) { queuedData = null ; } if ( queuedData != null ) { ch = queuedData . charAt ( 0 ) ; queuedData = queuedData . substring ( 1 ) ; if ( queuedData . length ( ) == 0 ) { queuedData = null ; } } else { queuedData = readLine ( ) ; if ( queuedData == null ) { ch = - 1 ; } else { if ( prefix != null ) { queuedData = prefix + queuedData ; } return read ( ) ; } } return ch ; } public void setPrefix ( final String prefix ) { this . prefix = prefix ; } private String getPrefix ( ) { return prefix ; } public Reader chain ( final Reader rdr ) { PrefixLines newFilter = new PrefixLines ( rdr ) ; newFilter . setPrefix ( getPrefix ( ) ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { Parameter [ ] params = getParameters ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { if ( PREFIX_KEY . equals ( params [ i ] . getName ( ) ) ) { prefix = params [ i ] . getValue ( ) ; break ; } } } } } 	0	['7', '5', '0', '4', '23', '0', '1', '3', '5', '0.555555556', '150', '1', '0', '0.848484848', '0.476190476', '2', '5', '20', '4', '1.1429', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Commandline ; public class Patch extends Task { private File originalFile ; private File directory ; private boolean havePatchfile = false ; private Commandline cmd = new Commandline ( ) ; public void setOriginalfile ( File file ) { originalFile = file ; } public void setDestfile ( File file ) { if ( file != null ) { cmd . createArgument ( ) . setValue ( "-o" ) ; cmd . createArgument ( ) . setFile ( file ) ; } } public void setPatchfile ( File file ) { if ( ! file . exists ( ) ) { throw new BuildException ( "patchfile " + file + " doesn\'t exist" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-i" ) ; cmd . createArgument ( ) . setFile ( file ) ; havePatchfile = true ; } public void setBackups ( boolean backups ) { if ( backups ) { cmd . createArgument ( ) . setValue ( "-b" ) ; } } public void setIgnorewhitespace ( boolean ignore ) { if ( ignore ) { cmd . createArgument ( ) . setValue ( "-l" ) ; } } public void setStrip ( int num ) throws BuildException { if ( num < 0 ) { throw new BuildException ( "strip has to be >= 0" , getLocation ( ) ) ; } cmd . createArgument ( ) . setValue ( "-p" + num ) ; } public void setQuiet ( boolean q ) { if ( q ) { cmd . createArgument ( ) . setValue ( "-s" ) ; } } public void setReverse ( boolean r ) { if ( r ) { cmd . createArgument ( ) . setValue ( "-R" ) ; } } public void setDir ( File directory ) { this . directory = directory ; } public void execute ( ) throws BuildException { if ( ! havePatchfile ) { throw new BuildException ( "patchfile argument is required" , getLocation ( ) ) ; } Commandline toExecute = ( Commandline ) cmd . clone ( ) ; toExecute . setExecutable ( "patch" ) ; if ( originalFile != null ) { toExecute . createArgument ( ) . setFile ( originalFile ) ; } Execute exe = new Execute ( new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) , null ) ; exe . setCommandline ( toExecute . getCommandline ( ) ) ; if ( directory != null ) { if ( directory . exists ( ) && directory . isDirectory ( ) ) { exe . setWorkingDirectory ( directory ) ; } else if ( ! directory . isDirectory ( ) ) { throw new BuildException ( directory + " is not a directory." , getLocation ( ) ) ; } else { throw new BuildException ( "directory " + directory + " doesn\'t exist" , getLocation ( ) ) ; } } else { exe . setWorkingDirectory ( getProject ( ) . getBaseDir ( ) ) ; } log ( toExecute . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { exe . execute ( ) ; } catch ( IOException e ) { throw new BuildException ( e , getLocation ( ) ) ; } } } 	0	['11', '3', '0', '10', '39', '0', '0', '10', '11', '0.7', '247', '1', '1', '0.787234043', '0.454545455', '1', '1', '21.09090909', '2', '1.4545', '0']
package org . apache . tools . ant . types . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . types . selectors . BaseSelector ; import org . apache . tools . ant . util . ScriptRunnerBase ; import org . apache . tools . ant . util . ScriptRunnerHelper ; public class ScriptSelector extends BaseSelector { private ScriptRunnerHelper helper = new ScriptRunnerHelper ( ) ; private ScriptRunnerBase runner ; private File basedir ; private String filename ; private File file ; private boolean selected ; public void setProject ( Project project ) { super . setProject ( project ) ; helper . setProjectComponent ( this ) ; } public void setManager ( String manager ) { helper . setManager ( manager ) ; } public void setLanguage ( String language ) { helper . setLanguage ( language ) ; } private void init ( ) throws BuildException { if ( runner != null ) { return ; } runner = helper . getScriptRunner ( ) ; } public void setSrc ( File file ) { helper . setSrc ( file ) ; } public void addText ( String text ) { helper . addText ( text ) ; } public void setClasspath ( Path classpath ) { helper . setClasspath ( classpath ) ; } public Path createClasspath ( ) { return helper . createClasspath ( ) ; } public void setClasspathRef ( Reference r ) { helper . setClasspathRef ( r ) ; } public void setSetBeans ( boolean setBeans ) { helper . setSetBeans ( setBeans ) ; } public boolean isSelected ( File basedir , String filename , File file ) { init ( ) ; setSelected ( true ) ; this . file = file ; this . basedir = basedir ; this . filename = filename ; runner . addBean ( "basedir" , basedir ) ; runner . addBean ( "filename" , filename ) ; runner . addBean ( "file" , file ) ; runner . executeScript ( "ant_selector" ) ; return isSelected ( ) ; } public File getBasedir ( ) { return basedir ; } public String getFilename ( ) { return filename ; } public File getFile ( ) { return file ; } public boolean isSelected ( ) { return selected ; } public void setSelected ( boolean selected ) { this . selected = selected ; } } 	0	['17', '4', '0', '8', '32', '16', '0', '8', '16', '0.822916667', '140', '1', '2', '0.68627451', '0.235294118', '1', '1', '6.882352941', '1', '0.9412', '0']
package org . apache . tools . ant . taskdefs . email ; public class EmailAddress { private String name ; private String address ; public EmailAddress ( ) { } public EmailAddress ( String email ) { final int minLen = 9 ; int len = email . length ( ) ; if ( len > minLen ) { if ( ( email . charAt ( 0 ) == '<' || email . charAt ( 1 ) == '<' ) && ( email . charAt ( len - 1 ) == '>' || email . charAt ( len - 2 ) == '>' ) ) { this . address = trim ( email , true ) ; return ; } } int paramDepth = 0 ; int start = 0 ; int end = 0 ; int nStart = 0 ; int nEnd = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = email . charAt ( i ) ; if ( c == '(' ) { paramDepth ++ ; if ( start == 0 ) { end = i ; nStart = i + 1 ; } } else if ( c == ')' ) { paramDepth -- ; if ( end == 0 ) { start = i + 1 ; nEnd = i ; } } else if ( paramDepth == 0 && c == '<' ) { if ( start == 0 ) { nEnd = i ; } start = i + 1 ; } else if ( paramDepth == 0 && c == '>' ) { end = i ; if ( end != len - 1 ) { nStart = i + 1 ; } } } if ( end == 0 ) { end = len ; } if ( nEnd == 0 ) { nEnd = len ; } this . address = trim ( email . substring ( start , end ) , true ) ; this . name = trim ( email . substring ( nStart , nEnd ) , false ) ; if ( this . name . length ( ) + this . address . length ( ) > len ) { this . name = null ; } } private String trim ( String t , boolean trimAngleBrackets ) { int start = 0 ; int end = t . length ( ) ; boolean trim = false ; do { trim = false ; if ( t . charAt ( end - 1 ) == ')' || ( t . charAt ( end - 1 ) == '>' && trimAngleBrackets ) || ( t . charAt ( end - 1 ) == '"' && t . charAt ( end - 2 ) != '\\' ) || t . charAt ( end - 1 ) <= ' ' ) { trim = true ; end -- ; } if ( t . charAt ( start ) == '(' || ( t . charAt ( start ) == '<' && trimAngleBrackets ) || t . charAt ( start ) == '"' || t . charAt ( start ) <= ' ' ) { trim = true ; start ++ ; } } while ( trim ) ; return t . substring ( start , end ) ; } public void setName ( String name ) { this . name = name ; } public void setAddress ( String address ) { this . address = address ; } public String toString ( ) { if ( name == null ) { return address ; } else { return name + " <" + address + ">" ; } } public String getAddress ( ) { return address ; } public String getName ( ) { return name ; } } 	0	['8', '1', '0', '5', '16', '6', '5', '0', '7', '0.571428571', '284', '1', '0', '0', '0.541666667', '0', '0', '34.25', '13', '2.375', '0']
package org . apache . tools . ant . types ; import java . lang . reflect . Method ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Enumeration ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParserFactory ; import javax . xml . transform . Source ; import javax . xml . transform . TransformerException ; import javax . xml . transform . URIResolver ; import javax . xml . transform . sax . SAXSource ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . JAXPUtils ; import org . xml . sax . EntityResolver ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class XMLCatalog extends DataType implements Cloneable , EntityResolver , URIResolver { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Vector elements = new Vector ( ) ; private Path classpath ; private Path catalogPath ; public static final String APACHE_RESOLVER = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver" ; public static final String CATALOG_RESOLVER = "org.apache.xml.resolver.tools.CatalogResolver" ; public XMLCatalog ( ) { setChecked ( false ) ; } private Vector getElements ( ) { return getRef ( ) . elements ; } private Path getClasspath ( ) { return getRef ( ) . classpath ; } public Path createClasspath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . classpath == null ) { this . classpath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } if ( this . classpath == null ) { this . classpath = classpath ; } else { this . classpath . append ( classpath ) ; } setChecked ( false ) ; } public void setClasspathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createClasspath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path createCatalogPath ( ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( this . catalogPath == null ) { this . catalogPath = new Path ( getProject ( ) ) ; } setChecked ( false ) ; return this . catalogPath . createPath ( ) ; } public void setCatalogPathRef ( Reference r ) { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } createCatalogPath ( ) . setRefid ( r ) ; setChecked ( false ) ; } public Path getCatalogPath ( ) { return getRef ( ) . catalogPath ; } public void addDTD ( ResourceLocation dtd ) throws BuildException { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } getElements ( ) . addElement ( dtd ) ; setChecked ( false ) ; } public void addEntity ( ResourceLocation entity ) throws BuildException { addDTD ( entity ) ; } public void addConfiguredXMLCatalog ( XMLCatalog catalog ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } Vector newElements = catalog . getElements ( ) ; Vector ourElements = getElements ( ) ; Enumeration e = newElements . elements ( ) ; while ( e . hasMoreElements ( ) ) { ourElements . addElement ( e . nextElement ( ) ) ; } Path nestedClasspath = catalog . getClasspath ( ) ; createClasspath ( ) . append ( nestedClasspath ) ; Path nestedCatalogPath = catalog . getCatalogPath ( ) ; createCatalogPath ( ) . append ( nestedCatalogPath ) ; setChecked ( false ) ; } public void setRefid ( Reference r ) throws BuildException { if ( ! elements . isEmpty ( ) ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { if ( isReference ( ) ) { return getRef ( ) . resolveEntity ( publicId , systemId ) ; } dieOnCircularReference ( ) ; log ( "resolveEntity: '" + publicId + "': '" + systemId + "'" , Project . MSG_DEBUG ) ; InputSource inputSource = getCatalogResolver ( ) . resolveEntity ( publicId , systemId ) ; if ( inputSource == null ) { log ( "No matching catalog entry found, parser will use: '" + systemId + "'" , Project . MSG_DEBUG ) ; } return inputSource ; } public Source resolve ( String href , String base ) throws TransformerException { if ( isReference ( ) ) { return getRef ( ) . resolve ( href , base ) ; } dieOnCircularReference ( ) ; SAXSource source = null ; String uri = removeFragment ( href ) ; log ( "resolve: '" + uri + "' with base: '" + base + "'" , Project . MSG_DEBUG ) ; source = ( SAXSource ) getCatalogResolver ( ) . resolve ( uri , base ) ; if ( source == null ) { log ( "No matching catalog entry found, parser will use: '" + href + "'" , Project . MSG_DEBUG ) ; source = new SAXSource ( ) ; URL baseURL = null ; try { if ( base == null ) { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } else { baseURL = new URL ( base ) ; } URL url = ( uri . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; source . setInputSource ( new InputSource ( url . toString ( ) ) ) ; } catch ( MalformedURLException ex ) { source . setInputSource ( new InputSource ( uri ) ) ; } } setEntityResolver ( source ) ; return source ; } private XMLCatalog getRef ( ) { if ( ! isReference ( ) ) { return this ; } return ( XMLCatalog ) getCheckedRef ( XMLCatalog . class , "xmlcatalog" ) ; } private CatalogResolver catalogResolver = null ; private CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { AntClassLoader loader = null ; loader = getProject ( ) . createClassLoader ( Path . systemClasspath ) ; try { Class clazz = Class . forName ( APACHE_RESOLVER , true , loader ) ; ClassLoader apacheResolverLoader = clazz . getClassLoader ( ) ; Class baseResolverClass = Class . forName ( CATALOG_RESOLVER , true , apacheResolverLoader ) ; ClassLoader baseResolverLoader = baseResolverClass . getClassLoader ( ) ; clazz = Class . forName ( APACHE_RESOLVER , true , baseResolverLoader ) ; Object obj = clazz . newInstance ( ) ; catalogResolver = new ExternalResolver ( clazz , obj ) ; } catch ( Throwable ex ) { catalogResolver = new InternalResolver ( ) ; if ( getCatalogPath ( ) != null && getCatalogPath ( ) . list ( ) . length != 0 ) { log ( "Warning: XML resolver not found; external catalogs" + " will be ignored" , Project . MSG_WARN ) ; } log ( "Failed to load Apache resolver: " + ex , Project . MSG_DEBUG ) ; } } return catalogResolver ; } private void setEntityResolver ( SAXSource source ) throws TransformerException { XMLReader reader = source . getXMLReader ( ) ; if ( reader == null ) { SAXParserFactory spFactory = SAXParserFactory . newInstance ( ) ; spFactory . setNamespaceAware ( true ) ; try { reader = spFactory . newSAXParser ( ) . getXMLReader ( ) ; } catch ( ParserConfigurationException ex ) { throw new TransformerException ( ex ) ; } catch ( SAXException ex ) { throw new TransformerException ( ex ) ; } } reader . setEntityResolver ( this ) ; source . setXMLReader ( reader ) ; } private ResourceLocation findMatchingEntry ( String publicId ) { Enumeration e = getElements ( ) . elements ( ) ; ResourceLocation element = null ; while ( e . hasMoreElements ( ) ) { Object o = e . nextElement ( ) ; if ( o instanceof ResourceLocation ) { element = ( ResourceLocation ) o ; if ( element . getPublicId ( ) . equals ( publicId ) ) { return element ; } } } return null ; } private String removeFragment ( String uri ) { String result = uri ; int hashPos = uri . indexOf ( "#" ) ; if ( hashPos >= 0 ) { result = uri . substring ( 0 , hashPos ) ; } return result ; } private InputSource filesystemLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; uri = uri . replace ( File . separatorChar , '/' ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { File testFile = new File ( uri ) ; if ( testFile . exists ( ) && testFile . canRead ( ) ) { log ( "uri : '" + uri + "' matches a readable file" , Project . MSG_DEBUG ) ; try { url = FILE_UTILS . getFileURL ( testFile ) ; } catch ( MalformedURLException ex1 ) { throw new BuildException ( "could not find an URL for :" + testFile . getAbsolutePath ( ) ) ; } } else { log ( "uri : '" + uri + "' does not match a readable file" , Project . MSG_DEBUG ) ; } } if ( url != null && url . getProtocol ( ) . equals ( "file" ) ) { String fileName = FILE_UTILS . fromURI ( url . toString ( ) ) ; if ( fileName != null ) { log ( "fileName " + fileName , Project . MSG_DEBUG ) ; File resFile = new File ( fileName ) ; if ( resFile . exists ( ) && resFile . canRead ( ) ) { try { source = new InputSource ( new FileInputStream ( resFile ) ) ; String sysid = JAXPUtils . getSystemId ( resFile ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a readable file: '" + sysid + "'" , Project . MSG_DEBUG ) ; } catch ( IOException ex ) { } } } } return source ; } private InputSource classpathLookup ( ResourceLocation matchingEntry ) { InputSource source = null ; AntClassLoader loader = null ; Path cp = classpath ; if ( cp != null ) { cp = classpath . concatSystemClasspath ( "ignore" ) ; } else { cp = ( new Path ( getProject ( ) ) ) . concatSystemClasspath ( "last" ) ; } loader = getProject ( ) . createClassLoader ( cp ) ; InputStream is = loader . getResourceAsStream ( matchingEntry . getLocation ( ) ) ; if ( is != null ) { source = new InputSource ( is ) ; URL entryURL = loader . getResource ( matchingEntry . getLocation ( ) ) ; String sysid = entryURL . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched a resource in the classpath: '" + sysid + "'" , Project . MSG_DEBUG ) ; } return source ; } private InputSource urlLookup ( ResourceLocation matchingEntry ) { String uri = matchingEntry . getLocation ( ) ; URL baseURL = null ; if ( matchingEntry . getBase ( ) != null ) { baseURL = matchingEntry . getBase ( ) ; } else { try { baseURL = FILE_UTILS . getFileURL ( getProject ( ) . getBaseDir ( ) ) ; } catch ( MalformedURLException ex ) { throw new BuildException ( "Project basedir cannot be converted to a URL" ) ; } } InputSource source = null ; URL url = null ; try { url = new URL ( baseURL , uri ) ; } catch ( MalformedURLException ex ) { } if ( url != null ) { try { InputStream is = url . openStream ( ) ; if ( is != null ) { source = new InputSource ( is ) ; String sysid = url . toExternalForm ( ) ; source . setSystemId ( sysid ) ; log ( "catalog entry matched as a URL: '" + sysid + "'" , Project . MSG_DEBUG ) ; } } catch ( IOException ex ) { } } return source ; } private interface CatalogResolver extends URIResolver , EntityResolver { InputSource resolveEntity ( String publicId , String systemId ) ; Source resolve ( String href , String base ) throws TransformerException ; } private class InternalResolver implements CatalogResolver { public InternalResolver ( ) { log ( "Apache resolver library not found, internal resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { result = urlLookup ( matchingEntry ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source == null ) { source = urlLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } } return result ; } } private class ExternalResolver implements CatalogResolver { private Method setXMLCatalog = null ; private Method parseCatalog = null ; private Method resolveEntity = null ; private Method resolve = null ; private Object resolverImpl = null ; private boolean externalCatalogsProcessed = false ; public ExternalResolver ( Class resolverImplClass , Object resolverImpl ) { this . resolverImpl = resolverImpl ; try { setXMLCatalog = resolverImplClass . getMethod ( "setXMLCatalog" , new Class [ ] { XMLCatalog . class } ) ; parseCatalog = resolverImplClass . getMethod ( "parseCatalog" , new Class [ ] { String . class } ) ; resolveEntity = resolverImplClass . getMethod ( "resolveEntity" , new Class [ ] { String . class , String . class } ) ; resolve = resolverImplClass . getMethod ( "resolve" , new Class [ ] { String . class , String . class } ) ; } catch ( NoSuchMethodException ex ) { throw new BuildException ( ex ) ; } log ( "Apache resolver library found, xml-commons resolver will be used" , Project . MSG_VERBOSE ) ; } public InputSource resolveEntity ( String publicId , String systemId ) { InputSource result = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( publicId ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for publicId: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; result = filesystemLookup ( matchingEntry ) ; if ( result == null ) { result = classpathLookup ( matchingEntry ) ; } if ( result == null ) { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( InputSource ) resolveEntity . invoke ( resolverImpl , new Object [ ] { publicId , systemId } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } public Source resolve ( String href , String base ) throws TransformerException { SAXSource result = null ; InputSource source = null ; processExternalCatalogs ( ) ; ResourceLocation matchingEntry = findMatchingEntry ( href ) ; if ( matchingEntry != null ) { log ( "Matching catalog entry found for uri: '" + matchingEntry . getPublicId ( ) + "' location: '" + matchingEntry . getLocation ( ) + "'" , Project . MSG_DEBUG ) ; ResourceLocation entryCopy = matchingEntry ; if ( base != null ) { try { URL baseURL = new URL ( base ) ; entryCopy = new ResourceLocation ( ) ; entryCopy . setBase ( baseURL ) ; } catch ( MalformedURLException ex ) { } } entryCopy . setPublicId ( matchingEntry . getPublicId ( ) ) ; entryCopy . setLocation ( matchingEntry . getLocation ( ) ) ; source = filesystemLookup ( entryCopy ) ; if ( source == null ) { source = classpathLookup ( entryCopy ) ; } if ( source != null ) { result = new SAXSource ( source ) ; } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } else { try { result = ( SAXSource ) resolve . invoke ( resolverImpl , new Object [ ] { href , base } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } return result ; } private void processExternalCatalogs ( ) { if ( ! externalCatalogsProcessed ) { try { setXMLCatalog . invoke ( resolverImpl , new Object [ ] { XMLCatalog . this } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } Path catPath = getCatalogPath ( ) ; if ( catPath != null ) { log ( "Using catalogpath '" + getCatalogPath ( ) + "'" , Project . MSG_DEBUG ) ; String [ ] catPathList = getCatalogPath ( ) . list ( ) ; for ( int i = 0 ; i < catPathList . length ; i ++ ) { File catFile = new File ( catPathList [ i ] ) ; log ( "Parsing " + catFile , Project . MSG_DEBUG ) ; try { parseCatalog . invoke ( resolverImpl , new Object [ ] { catFile . getPath ( ) } ) ; } catch ( Exception ex ) { throw new BuildException ( ex ) ; } } } } externalCatalogsProcessed = true ; } } } 	0	['28', '3', '0', '17', '105', '344', '7', '12', '13', '0.864197531', '874', '0.555555556', '4', '0.535714286', '0.243386243', '1', '1', '29.89285714', '9', '2.0714', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class Native2AsciiAdapterFactory { public static String getDefault ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { return KaffeNative2Ascii . IMPLEMENTATION_NAME ; } return SunNative2Ascii . IMPLEMENTATION_NAME ; } public static Native2AsciiAdapter getAdapter ( String choice , ProjectComponent log ) throws BuildException { if ( ( JavaEnvUtils . isKaffe ( ) && choice == null ) || KaffeNative2Ascii . IMPLEMENTATION_NAME . equals ( choice ) ) { return new KaffeNative2Ascii ( ) ; } else if ( SunNative2Ascii . IMPLEMENTATION_NAME . equals ( choice ) ) { return new SunNative2Ascii ( ) ; } else if ( choice != null ) { return resolveClassName ( choice ) ; } return new SunNative2Ascii ( ) ; } private static Native2AsciiAdapter resolveClassName ( String className ) throws BuildException { return ( Native2AsciiAdapter ) ClasspathUtils . newInstance ( className , Native2AsciiAdapterFactory . class . getClassLoader ( ) , Native2AsciiAdapter . class ) ; } } 	0	['4', '1', '0', '8', '14', '6', '1', '7', '3', '0.666666667', '79', '0', '0', '0', '0.333333333', '0', '0', '18.25', '2', '1', '0']
package org . apache . tools . bzip2 ; final class CRC { static final int crc32Table [ ] = { 0x00000000 , 0x04c11db7 , 0x09823b6e , 0x0d4326d9 , 0x130476dc , 0x17c56b6b , 0x1a864db2 , 0x1e475005 , 0x2608edb8 , 0x22c9f00f , 0x2f8ad6d6 , 0x2b4bcb61 , 0x350c9b64 , 0x31cd86d3 , 0x3c8ea00a , 0x384fbdbd , 0x4c11db70 , 0x48d0c6c7 , 0x4593e01e , 0x4152fda9 , 0x5f15adac , 0x5bd4b01b , 0x569796c2 , 0x52568b75 , 0x6a1936c8 , 0x6ed82b7f , 0x639b0da6 , 0x675a1011 , 0x791d4014 , 0x7ddc5da3 , 0x709f7b7a , 0x745e66cd , 0x9823b6e0 , 0x9ce2ab57 , 0x91a18d8e , 0x95609039 , 0x8b27c03c , 0x8fe6dd8b , 0x82a5fb52 , 0x8664e6e5 , 0xbe2b5b58 , 0xbaea46ef , 0xb7a96036 , 0xb3687d81 , 0xad2f2d84 , 0xa9ee3033 , 0xa4ad16ea , 0xa06c0b5d , 0xd4326d90 , 0xd0f37027 , 0xddb056fe , 0xd9714b49 , 0xc7361b4c , 0xc3f706fb , 0xceb42022 , 0xca753d95 , 0xf23a8028 , 0xf6fb9d9f , 0xfbb8bb46 , 0xff79a6f1 , 0xe13ef6f4 , 0xe5ffeb43 , 0xe8bccd9a , 0xec7dd02d , 0x34867077 , 0x30476dc0 , 0x3d044b19 , 0x39c556ae , 0x278206ab , 0x23431b1c , 0x2e003dc5 , 0x2ac12072 , 0x128e9dcf , 0x164f8078 , 0x1b0ca6a1 , 0x1fcdbb16 , 0x018aeb13 , 0x054bf6a4 , 0x0808d07d , 0x0cc9cdca , 0x7897ab07 , 0x7c56b6b0 , 0x71159069 , 0x75d48dde , 0x6b93dddb , 0x6f52c06c , 0x6211e6b5 , 0x66d0fb02 , 0x5e9f46bf , 0x5a5e5b08 , 0x571d7dd1 , 0x53dc6066 , 0x4d9b3063 , 0x495a2dd4 , 0x44190b0d , 0x40d816ba , 0xaca5c697 , 0xa864db20 , 0xa527fdf9 , 0xa1e6e04e , 0xbfa1b04b , 0xbb60adfc , 0xb6238b25 , 0xb2e29692 , 0x8aad2b2f , 0x8e6c3698 , 0x832f1041 , 0x87ee0df6 , 0x99a95df3 , 0x9d684044 , 0x902b669d , 0x94ea7b2a , 0xe0b41de7 , 0xe4750050 , 0xe9362689 , 0xedf73b3e , 0xf3b06b3b , 0xf771768c , 0xfa325055 , 0xfef34de2 , 0xc6bcf05f , 0xc27dede8 , 0xcf3ecb31 , 0xcbffd686 , 0xd5b88683 , 0xd1799b34 , 0xdc3abded , 0xd8fba05a , 0x690ce0ee , 0x6dcdfd59 , 0x608edb80 , 0x644fc637 , 0x7a089632 , 0x7ec98b85 , 0x738aad5c , 0x774bb0eb , 0x4f040d56 , 0x4bc510e1 , 0x46863638 , 0x42472b8f , 0x5c007b8a , 0x58c1663d , 0x558240e4 , 0x51435d53 , 0x251d3b9e , 0x21dc2629 , 0x2c9f00f0 , 0x285e1d47 , 0x36194d42 , 0x32d850f5 , 0x3f9b762c , 0x3b5a6b9b , 0x0315d626 , 0x07d4cb91 , 0x0a97ed48 , 0x0e56f0ff , 0x1011a0fa , 0x14d0bd4d , 0x19939b94 , 0x1d528623 , 0xf12f560e , 0xf5ee4bb9 , 0xf8ad6d60 , 0xfc6c70d7 , 0xe22b20d2 , 0xe6ea3d65 , 0xeba91bbc , 0xef68060b , 0xd727bbb6 , 0xd3e6a601 , 0xdea580d8 , 0xda649d6f , 0xc423cd6a , 0xc0e2d0dd , 0xcda1f604 , 0xc960ebb3 , 0xbd3e8d7e , 0xb9ff90c9 , 0xb4bcb610 , 0xb07daba7 , 0xae3afba2 , 0xaafbe615 , 0xa7b8c0cc , 0xa379dd7b , 0x9b3660c6 , 0x9ff77d71 , 0x92b45ba8 , 0x9675461f , 0x8832161a , 0x8cf30bad , 0x81b02d74 , 0x857130c3 , 0x5d8a9099 , 0x594b8d2e , 0x5408abf7 , 0x50c9b640 , 0x4e8ee645 , 0x4a4ffbf2 , 0x470cdd2b , 0x43cdc09c , 0x7b827d21 , 0x7f436096 , 0x7200464f , 0x76c15bf8 , 0x68860bfd , 0x6c47164a , 0x61043093 , 0x65c52d24 , 0x119b4be9 , 0x155a565e , 0x18197087 , 0x1cd86d30 , 0x029f3d35 , 0x065e2082 , 0x0b1d065b , 0x0fdc1bec , 0x3793a651 , 0x3352bbe6 , 0x3e119d3f , 0x3ad08088 , 0x2497d08d , 0x2056cd3a , 0x2d15ebe3 , 0x29d4f654 , 0xc5a92679 , 0xc1683bce , 0xcc2b1d17 , 0xc8ea00a0 , 0xd6ad50a5 , 0xd26c4d12 , 0xdf2f6bcb , 0xdbee767c , 0xe3a1cbc1 , 0xe760d676 , 0xea23f0af , 0xeee2ed18 , 0xf0a5bd1d , 0xf464a0aa , 0xf9278673 , 0xfde69bc4 , 0x89b8fd09 , 0x8d79e0be , 0x803ac667 , 0x84fbdbd0 , 0x9abc8bd5 , 0x9e7d9662 , 0x933eb0bb , 0x97ffad0c , 0xafb010b1 , 0xab710d06 , 0xa6322bdf , 0xa2f33668 , 0xbcb4666d , 0xb8757bda , 0xb5365d03 , 0xb1f740b4 } ; CRC ( ) { initialiseCRC ( ) ; } void initialiseCRC ( ) { globalCrc = 0xffffffff ; } int getFinalCRC ( ) { return ~ globalCrc ; } int getGlobalCRC ( ) { return globalCrc ; } void setGlobalCRC ( int newCrc ) { globalCrc = newCrc ; } void updateCRC ( int inCh ) { int temp = ( globalCrc > > 24 ) ^ inCh ; if ( temp < 0 ) { temp = 256 + temp ; } globalCrc = ( globalCrc << 8 ) ^ CRC . crc32Table [ temp ] ; } void updateCRC ( int inCh , int repeat ) { int globalCrcShadow = this . globalCrc ; while ( repeat -- > 0 ) { int temp = ( globalCrcShadow > > 24 ) ^ inCh ; globalCrcShadow = ( globalCrcShadow << 8 ) ^ crc32Table [ ( temp >= 0 ) ? temp : ( temp + 256 ) ] ; } this . globalCrc = globalCrcShadow ; } int globalCrc ; } 	0	['8', '1', '0', '2', '9', '0', '2', '0', '0', '0.428571429', '1107', '0', '0', '0', '0.714285714', '0', '0', '137.125', '3', '1.125', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Apt ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import java . io . File ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; public class AptCompilerAdapter extends DefaultCompilerAdapter { private static final int APT_COMPILER_SUCCESS = 0 ; public static final String APT_ENTRY_POINT = "com.sun.tools.apt.Main" ; public static final String APT_METHOD_NAME = "process" ; protected Apt getApt ( ) { return ( Apt ) getJavac ( ) ; } static void setAptCommandlineSwitches ( Apt apt , Commandline cmd ) { if ( ! apt . isCompile ( ) ) { cmd . createArgument ( ) . setValue ( "-nocompile" ) ; } String factory = apt . getFactory ( ) ; if ( factory != null ) { cmd . createArgument ( ) . setValue ( "-factory" ) ; cmd . createArgument ( ) . setValue ( factory ) ; } Path factoryPath = apt . getFactoryPath ( ) ; if ( factoryPath != null ) { cmd . createArgument ( ) . setValue ( "-factorypath" ) ; cmd . createArgument ( ) . setPath ( factoryPath ) ; } File preprocessDir = apt . getPreprocessDir ( ) ; if ( preprocessDir != null ) { cmd . createArgument ( ) . setValue ( "-s" ) ; cmd . createArgument ( ) . setFile ( preprocessDir ) ; } Vector options = apt . getOptions ( ) ; Enumeration elements = options . elements ( ) ; Apt . Option opt ; StringBuffer arg = null ; while ( elements . hasMoreElements ( ) ) { opt = ( Apt . Option ) elements . nextElement ( ) ; arg = new StringBuffer ( ) ; arg . append ( "-A" ) . append ( opt . getName ( ) ) ; if ( opt . getValue ( ) != null ) { arg . append ( "=" ) . append ( opt . getValue ( ) ) ; } cmd . createArgument ( ) . setValue ( arg . toString ( ) ) ; } } protected void setAptCommandlineSwitches ( Commandline cmd ) { Apt apt = getApt ( ) ; setAptCommandlineSwitches ( apt , cmd ) ; } public boolean execute ( ) throws BuildException { attributes . log ( "Using apt compiler" , Project . MSG_VERBOSE ) ; Commandline cmd = setupModernJavacCommand ( ) ; setAptCommandlineSwitches ( cmd ) ; try { Class c = Class . forName ( APT_ENTRY_POINT ) ; Object compiler = c . newInstance ( ) ; Method compile = c . getMethod ( APT_METHOD_NAME , new Class [ ] { ( new String [ ] { } ) . getClass ( ) } ) ; int result = ( ( Integer ) compile . invoke ( compiler , new Object [ ] { cmd . getArguments ( ) } ) ) . intValue ( ) ; return ( result == APT_COMPILER_SUCCESS ) ; } catch ( BuildException be ) { throw be ; } catch ( Exception ex ) { throw new BuildException ( "Error starting apt compiler" , ex , location ) ; } } } 	0	['5', '2', '0', '10', '34', '10', '1', '9', '2', '1.25', '171', '0.333333333', '0', '0.851851852', '0.466666667', '0', '0', '32.6', '7', '2', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . GZIPOutputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class GZip extends Pack { protected void pack ( ) { GZIPOutputStream zOut = null ; try { zOut = new GZIPOutputStream ( new FileOutputStream ( zipFile ) ) ; zipResource ( getSrcResource ( ) , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( zOut ) ; } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( GZip . class ) ; } } 	0	['3', '4', '0', '5', '20', '3', '0', '5', '1', '1', '71', '0', '0', '0.961538462', '1', '2', '4', '22.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs . cvslib ; public class CvsTagEntry { private String filename ; private String prevRevision ; private String revision ; public CvsTagEntry ( final String filename ) { this ( filename , null , null ) ; } public CvsTagEntry ( final String filename , final String revision ) { this ( filename , revision , null ) ; } public CvsTagEntry ( final String filename , final String revision , final String prevRevision ) { this . filename = filename ; this . revision = revision ; this . prevRevision = prevRevision ; } public String getFile ( ) { return filename ; } public String getRevision ( ) { return revision ; } public String getPreviousRevision ( ) { return prevRevision ; } public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( filename ) ; if ( ( revision == null ) ) { buffer . append ( " was removed" ) ; if ( prevRevision != null ) { buffer . append ( "; previous revision was " ) . append ( prevRevision ) ; } } else if ( revision != null && prevRevision == null ) { buffer . append ( " is new; current revision is " ) . append ( revision ) ; } else if ( revision != null && prevRevision != null ) { buffer . append ( " has changed from " ) . append ( prevRevision ) . append ( " to " ) . append ( revision ) ; } return buffer . toString ( ) ; } } 	0	['7', '1', '0', '1', '11', '7', '1', '0', '7', '0.333333333', '105', '1', '0', '0', '0.714285714', '0', '0', '13.57142857', '7', '1.4286', '0']
package org . apache . tools . ant . util ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collections ; import org . apache . tools . ant . types . Mapper ; public abstract class ContainerMapper implements FileNameMapper { private List mappers = new ArrayList ( ) ; public void addConfiguredMapper ( Mapper mapper ) { add ( mapper . getImplementation ( ) ) ; } public void addConfigured ( FileNameMapper fileNameMapper ) { add ( fileNameMapper ) ; } public synchronized void add ( FileNameMapper fileNameMapper ) { if ( this == fileNameMapper || ( fileNameMapper instanceof ContainerMapper && ( ( ContainerMapper ) fileNameMapper ) . contains ( this ) ) ) { throw new IllegalArgumentException ( "Circular mapper containment condition detected" ) ; } else { mappers . add ( fileNameMapper ) ; } } protected synchronized boolean contains ( FileNameMapper fileNameMapper ) { boolean foundit = false ; for ( Iterator iter = mappers . iterator ( ) ; iter . hasNext ( ) && ! foundit ; ) { FileNameMapper next = ( FileNameMapper ) ( iter . next ( ) ) ; foundit |= ( next == fileNameMapper || ( next instanceof ContainerMapper && ( ( ContainerMapper ) next ) . contains ( fileNameMapper ) ) ) ; } return foundit ; } public synchronized List getMappers ( ) { return Collections . unmodifiableList ( mappers ) ; } public void setFrom ( String ignore ) { } public void setTo ( String ignore ) { } } 	0	['8', '1', '2', '4', '17', '16', '3', '2', '7', '0.285714286', '89', '1', '0', '0', '0.4375', '0', '0', '10', '6', '1.875', '0']
package org . apache . tools . ant . util ; import org . w3c . dom . Document ; import org . w3c . dom . DocumentFragment ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . apache . tools . ant . DynamicElementNS ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . DynamicConfiguratorNS ; public class XMLFragment extends ProjectComponent implements DynamicElementNS { private Document doc ; private DocumentFragment fragment ; public XMLFragment ( ) { doc = JAXPUtils . getDocumentBuilder ( ) . newDocument ( ) ; fragment = doc . createDocumentFragment ( ) ; } public DocumentFragment getFragment ( ) { return fragment ; } public void addText ( String s ) { addText ( fragment , s ) ; } public Object createDynamicElement ( String uri , String name , String qName ) { Element e = null ; if ( uri . equals ( "" ) ) { e = doc . createElement ( name ) ; } else { e = doc . createElementNS ( uri , qName ) ; } fragment . appendChild ( e ) ; return new Child ( e ) ; } private void addText ( Node n , String s ) { s = getProject ( ) . replaceProperties ( s ) ; if ( s != null && ! s . trim ( ) . equals ( "" ) ) { Text t = doc . createTextNode ( s . trim ( ) ) ; n . appendChild ( t ) ; } } public class Child implements DynamicConfiguratorNS { private Element e ; Child ( Element e ) { this . e = e ; } public void addText ( String s ) { XMLFragment . this . addText ( e , s ) ; } public void setDynamicAttribute ( String uri , String name , String qName , String value ) { if ( uri . equals ( "" ) ) { e . setAttribute ( name , value ) ; } else { e . setAttributeNS ( uri , qName , value ) ; } } public Object createDynamicElement ( String uri , String name , String qName ) { Element e2 = null ; if ( uri . equals ( "" ) ) { e2 = doc . createElement ( name ) ; } else { e2 = doc . createElementNS ( uri , qName ) ; } e . appendChild ( e2 ) ; return new Child ( e2 ) ; } } } 	0	['7', '2', '1', '6', '21', '0', '2', '5', '4', '0.333333333', '90', '1', '0', '0.6', '0.464285714', '0', '0', '11.57142857', '3', '1.2857', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import java . text . NumberFormat ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; public class SummaryJUnitResultFormatter implements JUnitResultFormatter , JUnitTaskMirror . SummaryJUnitResultFormatterMirror { private NumberFormat nf = NumberFormat . getInstance ( ) ; private OutputStream out ; private boolean withOutAndErr = false ; private String systemOutput = null ; private String systemError = null ; public SummaryJUnitResultFormatter ( ) { } public void startTestSuite ( JUnitTest suite ) { String newLine = System . getProperty ( "line.separator" ) ; StringBuffer sb = new StringBuffer ( "Running " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( newLine ) ; try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write summary output" , ioex ) ; } } public void startTest ( Test t ) { } public void endTest ( Test test ) { } public void addFailure ( Test test , Throwable t ) { } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void setWithOutAndErr ( boolean value ) { withOutAndErr = value ; } public void endTestSuite ( JUnitTest suite ) throws BuildException { String newLine = System . getProperty ( "line.separator" ) ; StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( nf . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( newLine ) ; if ( withOutAndErr ) { if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "Output:" ) . append ( newLine ) . append ( systemOutput ) . append ( newLine ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "Error: " ) . append ( newLine ) . append ( systemError ) . append ( newLine ) ; } } try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write summary output" , ioex ) ; } finally { if ( out != System . out && out != System . err ) { try { out . close ( ) ; } catch ( IOException e ) { } } } } } 	0	['12', '1', '1', '8', '31', '46', '2', '6', '12', '0.836363636', '223', '1', '0', '0', '0.270833333', '0', '0', '17.16666667', '1', '0.9167', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class FileResourceIterator implements Iterator { private File basedir ; private String [ ] files ; private int pos = 0 ; public FileResourceIterator ( ) { } public FileResourceIterator ( File f ) { basedir = f ; } public FileResourceIterator ( File f , String [ ] s ) { this ( f ) ; addFiles ( s ) ; } public void addFiles ( String [ ] s ) { int start = ( files == null ) ? 0 : files . length ; String [ ] newfiles = new String [ start + s . length ] ; if ( start > 0 ) { System . arraycopy ( files , 0 , newfiles , 0 , start ) ; } files = newfiles ; System . arraycopy ( s , 0 , files , start , s . length ) ; } public boolean hasNext ( ) { return pos < files . length ; } public Object next ( ) { return nextResource ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public FileResource nextResource ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return new FileResource ( basedir , files [ pos ++ ] ) ; } } 	0	['8', '1', '0', '9', '13', '12', '8', '1', '8', '0.428571429', '109', '1', '0', '0', '0.5', '0', '0', '12.25', '3', '1.125', '0']
package org . apache . tools . ant ; public interface TaskContainer { void addTask ( Task task ) ; } 	0	['1', '1', '0', '14', '1', '0', '13', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class AndSelector extends BaseSelectorContainer { public AndSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{andselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( ! result ) { return false ; } } return true ; } } 	0	['3', '5', '0', '7', '14', '3', '6', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . util . regexp ; import org . apache . oro . text . regex . Perl5Substitution ; import org . apache . oro . text . regex . Substitution ; import org . apache . oro . text . regex . Util ; import org . apache . tools . ant . BuildException ; public class JakartaOroRegexp extends JakartaOroMatcher implements Regexp { public JakartaOroRegexp ( ) { super ( ) ; } public String substitute ( String input , String argument , int options ) throws BuildException { StringBuffer subst = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '$' ) { subst . append ( '\\' ) ; subst . append ( '$' ) ; } else if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { subst . append ( "$" ) . append ( value ) ; } else { subst . append ( c ) ; } } else { subst . append ( '\\' ) ; } } else { subst . append ( c ) ; } } Substitution s = new Perl5Substitution ( subst . toString ( ) , Perl5Substitution . INTERPOLATE_ALL ) ; return Util . substitute ( matcher , getCompiledPattern ( options ) , s , input , getSubsOptions ( options ) ) ; } protected int getSubsOptions ( int options ) { boolean replaceAll = RegexpUtil . hasFlag ( options , REPLACE_ALL ) ; int subsOptions = 1 ; if ( replaceAll ) { subsOptions = Util . SUBSTITUTE_ALL ; } return subsOptions ; } } 	0	['3', '2', '0', '10', '16', '3', '0', '10', '2', '2', '105', '0', '0', '0.8', '0.666666667', '0', '0', '34', '2', '1', '0']
package org . apache . tools . ant . taskdefs . compilers ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . Javac ; public interface CompilerAdapter { void setJavac ( Javac attributes ) ; boolean execute ( ) throws BuildException ; } 	0	['2', '1', '0', '4', '2', '1', '3', '2', '2', '2', '2', '0', '0', '0', '0.75', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import java . io . File ; import java . util . Vector ; import java . util . Enumeration ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . Commandline ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . EnumeratedAttribute ; public abstract class DotnetCompile extends DotnetBaseMatchingTask { private String references ; private boolean includeDefaultReferences = true ; private File win32icon ; private File win32res ; private boolean failOnError ; private Path referenceFiles ; private boolean optimize ; protected Vector definitionList = new Vector ( ) ; protected Vector resources = new Vector ( ) ; protected String executable ; protected static final String REFERENCE_OPTION = "/reference:" ; protected boolean debug ; private int warnLevel ; protected String mainClass ; protected String extraOptions ; protected String targetType ; protected boolean utf8output = false ; protected String additionalModules ; protected Vector referenceFilesets = new Vector ( ) ; private boolean useResponseFile = false ; private static final int AUTOMATIC_RESPONSE_FILE_THRESHOLD = 64 ; public DotnetCompile ( ) { clear ( ) ; setIncludes ( getFilePattern ( ) ) ; } public void clear ( ) { targetType = null ; win32icon = null ; srcDir = null ; mainClass = null ; warnLevel = 3 ; optimize = false ; debug = true ; references = null ; failOnError = true ; additionalModules = null ; includeDefaultReferences = true ; extraOptions = null ; } public void setReferences ( String s ) { references = s ; } protected String getReferencesParameter ( ) { if ( notEmpty ( references ) ) { if ( isWindows ) { return '\"' + REFERENCE_OPTION + references + '\"' ; } else { return REFERENCE_OPTION + references ; } } else { return null ; } } public void setReferenceFiles ( Path path ) { if ( referenceFiles == null ) { referenceFiles = new Path ( this . getProject ( ) ) ; } referenceFiles . append ( path ) ; } public void addReference ( FileSet reference ) { referenceFilesets . add ( reference ) ; } protected String getReferenceFilesParameter ( ) { if ( references == null ) { return null ; } if ( references . length ( ) == 0 ) { return null ; } StringBuffer s = new StringBuffer ( REFERENCE_OPTION ) ; if ( isWindows ) { s . append ( '\"' ) ; } s . append ( references ) ; if ( isWindows ) { s . append ( '\"' ) ; } return s . toString ( ) ; } public void setIncludeDefaultReferences ( boolean f ) { includeDefaultReferences = f ; } public boolean getIncludeDefaultReferences ( ) { return includeDefaultReferences ; } protected String getIncludeDefaultReferencesParameter ( ) { return "/nostdlib" + ( includeDefaultReferences ? "-" : "+" ) ; } public void setOptimize ( boolean f ) { optimize = f ; } public boolean getOptimize ( ) { return optimize ; } protected String getOptimizeParameter ( ) { return "/optimize" + ( optimize ? "+" : "-" ) ; } public void setDebug ( boolean f ) { debug = f ; } public boolean getDebug ( ) { return debug ; } protected String getDebugParameter ( ) { return "/debug" + ( debug ? "+" : "-" ) ; } public void setWarnLevel ( int warnLevel ) { this . warnLevel = warnLevel ; } public int getWarnLevel ( ) { return warnLevel ; } protected String getWarnLevelParameter ( ) { return "/warn:" + warnLevel ; } public void setMainClass ( String mainClass ) { this . mainClass = mainClass ; } public String getMainClass ( ) { return this . mainClass ; } protected String getMainClassParameter ( ) { if ( mainClass != null && mainClass . length ( ) != 0 ) { return "/main:" + mainClass ; } else { return null ; } } public void setExtraOptions ( String extraOptions ) { this . extraOptions = extraOptions ; } public String getExtraOptions ( ) { return this . extraOptions ; } protected String getExtraOptionsParameter ( ) { if ( extraOptions != null && extraOptions . length ( ) != 0 ) { return extraOptions ; } else { return null ; } } protected String [ ] getExtraOptionsParameters ( ) { String extra = getExtraOptionsParameter ( ) ; return extra == null ? null : Commandline . translateCommandline ( extra ) ; } public void setDestDir ( File dirName ) { log ( "DestDir currently unused" , Project . MSG_WARN ) ; } public void setTargetType ( TargetTypes targetType ) { this . targetType = targetType . getValue ( ) ; } public void setTargetType ( String ttype ) throws BuildException { ttype = ttype . toLowerCase ( ) ; if ( ttype . equals ( "exe" ) || ttype . equals ( "library" ) || ttype . equals ( "module" ) || ttype . equals ( "winexe" ) ) { targetType = ttype ; } else { throw new BuildException ( "targetType " + ttype + " is not one of 'exe', 'module', 'winexe' or 'library'" ) ; } } public String getTargetType ( ) { return targetType ; } protected String getTargetTypeParameter ( ) { if ( notEmpty ( targetType ) ) { return "/target:" + targetType ; } else { return null ; } } public void setWin32Icon ( File fileName ) { win32icon = fileName ; } protected String getWin32IconParameter ( ) { if ( win32icon != null ) { return "/win32icon:" + win32icon . toString ( ) ; } else { return null ; } } public void setWin32Res ( File fileName ) { win32res = fileName ; } public File getWin32Res ( ) { return win32res ; } protected String getWin32ResParameter ( ) { if ( win32res != null ) { return "/win32res:" + win32res . toString ( ) ; } else { return null ; } } public void setUtf8Output ( boolean enabled ) { utf8output = enabled ; } protected String getUtf8OutputParameter ( ) { return utf8output ? "/utf8output" : null ; } public void addDefine ( DotnetDefine define ) { definitionList . addElement ( define ) ; } protected String getDefinitionsParameter ( ) throws BuildException { StringBuffer defines = new StringBuffer ( ) ; Enumeration defEnum = definitionList . elements ( ) ; boolean firstDefinition = true ; while ( defEnum . hasMoreElements ( ) ) { DotnetDefine define = ( DotnetDefine ) defEnum . nextElement ( ) ; if ( define . isSet ( this ) ) { if ( ! firstDefinition ) { defines . append ( getDefinitionsDelimiter ( ) ) ; } defines . append ( define . getValue ( this ) ) ; firstDefinition = false ; } } if ( defines . length ( ) == 0 ) { return null ; } else { return "/d:" + defines ; } } public void setAdditionalModules ( String params ) { additionalModules = params ; } protected String getAdditionalModulesParameter ( ) { if ( notEmpty ( additionalModules ) ) { return "/addmodule:" + additionalModules ; } else { return null ; } } protected String getDestFileParameter ( ) { if ( outputFile != null ) { return "/out:" + outputFile . toString ( ) ; } else { return null ; } } public void setFailOnError ( boolean b ) { failOnError = b ; } public boolean getFailOnError ( ) { return failOnError ; } public void addResource ( DotnetResource resource ) { resources . add ( resource ) ; } protected String getExecutable ( ) { return executable ; } public void setExecutable ( String executable ) { this . executable = executable ; } protected boolean notEmpty ( String s ) { return s != null && s . length ( ) != 0 ; } protected void validate ( ) throws BuildException { if ( outputFile != null && outputFile . isDirectory ( ) ) { throw new BuildException ( "destFile cannot be a directory" ) ; } if ( getExecutable ( ) == null ) { throw new BuildException ( "There is no executable defined for this task" ) ; } } public String getFilePattern ( ) { return "**/*." + getFileExtension ( ) ; } public boolean isUseResponseFile ( ) { return useResponseFile ; } public void setUseResponseFile ( boolean useResponseFile ) { this . useResponseFile = useResponseFile ; } public void execute ( ) throws BuildException { log ( "This task is deprecated and will be removed in a future version\n" + "of Ant.  It is now part of the .NET Antlib:\n" + "http://ant.apache.org/antlibs/dotnet/index.html" , Project . MSG_WARN ) ; validate ( ) ; NetCommand command = createNetCommand ( ) ; command . setAutomaticResponseFileThreshold ( AUTOMATIC_RESPONSE_FILE_THRESHOLD ) ; command . setUseResponseFile ( useResponseFile ) ; fillInSharedParameters ( command ) ; addResources ( command ) ; addCompilerSpecificOptions ( command ) ; int referencesOutOfDate = addReferenceFilesets ( command , getOutputFileTimestamp ( ) ) ; boolean forceBuild = referencesOutOfDate > 0 ; addFilesAndExecute ( command , forceBuild ) ; } public abstract String getReferenceDelimiter ( ) ; public abstract String getFileExtension ( ) ; protected void fillInSharedParameters ( NetCommand command ) { command . setFailOnError ( getFailOnError ( ) ) ; command . addArgument ( "/nologo" ) ; command . addArgument ( getAdditionalModulesParameter ( ) ) ; command . addArgument ( getDebugParameter ( ) ) ; command . addArgument ( getDefinitionsParameter ( ) ) ; command . addArguments ( getExtraOptionsParameters ( ) ) ; command . addArgument ( getMainClassParameter ( ) ) ; command . addArgument ( getOptimizeParameter ( ) ) ; command . addArgument ( getDestFileParameter ( ) ) ; command . addArgument ( getReferencesParameter ( ) ) ; command . addArgument ( getTargetTypeParameter ( ) ) ; command . addArgument ( getUtf8OutputParameter ( ) ) ; command . addArgument ( getWin32IconParameter ( ) ) ; command . addArgument ( getWin32ResParameter ( ) ) ; } protected void addResources ( NetCommand command ) { Enumeration e = resources . elements ( ) ; while ( e . hasMoreElements ( ) ) { DotnetResource resource = ( DotnetResource ) e . nextElement ( ) ; createResourceParameter ( command , resource ) ; } } protected abstract void createResourceParameter ( NetCommand command , DotnetResource resource ) ; protected int addReferenceFilesets ( NetCommand command , long outputTimestamp ) { int filesOutOfDate = 0 ; Hashtable filesToBuild = new Hashtable ( ) ; for ( int i = 0 ; i < referenceFilesets . size ( ) ; i ++ ) { FileSet fs = ( FileSet ) referenceFilesets . elementAt ( i ) ; filesOutOfDate += command . scanOneFileset ( fs . getDirectoryScanner ( getProject ( ) ) , filesToBuild , outputTimestamp ) ; } if ( filesToBuild . size ( ) == 0 ) { return 0 ; } Enumeration files = filesToBuild . elements ( ) ; while ( files . hasMoreElements ( ) ) { File file = ( File ) files . nextElement ( ) ; if ( isFileManagedBinary ( file ) ) { if ( isWindows ) { command . addArgument ( '"' + REFERENCE_OPTION + file . toString ( ) + '"' ) ; } else { command . addArgument ( REFERENCE_OPTION + file . toString ( ) ) ; } } else { log ( "ignoring " + file + " as it is not a managed executable" , Project . MSG_VERBOSE ) ; } } return filesOutOfDate ; } protected NetCommand createNetCommand ( ) { NetCommand command = new NetCommand ( this , getTaskName ( ) , getExecutable ( ) ) ; return command ; } protected abstract void addCompilerSpecificOptions ( NetCommand command ) ; public String getDefinitionsDelimiter ( ) { return ";" ; } protected static boolean isFileManagedBinary ( File file ) { String filename = file . toString ( ) . toLowerCase ( ) ; return filename . endsWith ( ".exe" ) || filename . endsWith ( ".dll" ) || filename . endsWith ( ".netmodule" ) ; } public static class TargetTypes extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { "exe" , "library" , "module" , "winexe" } ; } } } 	0	['64', '5', '3', '15', '111', '1836', '3', '12', '38', '0.945578231', '888', '1', '1', '0.58', '0.12109375', '2', '3', '12.546875', '6', '1.4844', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . text . NumberFormat ; import java . util . Hashtable ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . util . StringUtils ; public class PlainJUnitResultFormatter implements JUnitResultFormatter { private NumberFormat nf = NumberFormat . getInstance ( ) ; private Hashtable testStarts = new Hashtable ( ) ; private OutputStream out ; private StringWriter inner ; private PrintWriter wri ; private Hashtable failed = new Hashtable ( ) ; private String systemOutput = null ; private String systemError = null ; public PlainJUnitResultFormatter ( ) { inner = new StringWriter ( ) ; wri = new PrintWriter ( inner ) ; } public void setOutput ( OutputStream out ) { this . out = out ; } public void setSystemOutput ( String out ) { systemOutput = out ; } public void setSystemError ( String err ) { systemError = err ; } public void startTestSuite ( JUnitTest suite ) throws BuildException { if ( out == null ) { return ; } StringBuffer sb = new StringBuffer ( "Testsuite: " ) ; sb . append ( suite . getName ( ) ) ; sb . append ( StringUtils . LINE_SEP ) ; try { out . write ( sb . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ex ) { throw new BuildException ( "Unable to write output" , ex ) ; } } public void endTestSuite ( JUnitTest suite ) throws BuildException { StringBuffer sb = new StringBuffer ( "Tests run: " ) ; sb . append ( suite . runCount ( ) ) ; sb . append ( ", Failures: " ) ; sb . append ( suite . failureCount ( ) ) ; sb . append ( ", Errors: " ) ; sb . append ( suite . errorCount ( ) ) ; sb . append ( ", Time elapsed: " ) ; sb . append ( nf . format ( suite . getRunTime ( ) / 1000.0 ) ) ; sb . append ( " sec" ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( systemOutput != null && systemOutput . length ( ) > 0 ) { sb . append ( "------------- Standard Output ---------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemOutput ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } if ( systemError != null && systemError . length ( ) > 0 ) { sb . append ( "------------- Standard Error -----------------" ) . append ( StringUtils . LINE_SEP ) . append ( systemError ) . append ( "------------- ---------------- ---------------" ) . append ( StringUtils . LINE_SEP ) ; } sb . append ( StringUtils . LINE_SEP ) ; if ( out != null ) { try { out . write ( sb . toString ( ) . getBytes ( ) ) ; wri . close ( ) ; out . write ( inner . toString ( ) . getBytes ( ) ) ; out . flush ( ) ; } catch ( IOException ioex ) { throw new BuildException ( "Unable to write output" , ioex ) ; } finally { if ( out != System . out && out != System . err ) { FileUtils . close ( out ) ; } } } } public void startTest ( Test t ) { testStarts . put ( t , new Long ( System . currentTimeMillis ( ) ) ) ; failed . put ( t , Boolean . FALSE ) ; } public void endTest ( Test test ) { if ( Boolean . TRUE . equals ( failed . get ( test ) ) ) { return ; } synchronized ( wri ) { wri . print ( "Testcase: " + JUnitVersionHelper . getTestCaseName ( test ) ) ; Long l = ( Long ) testStarts . get ( test ) ; double seconds = 0 ; if ( l != null ) { seconds = ( System . currentTimeMillis ( ) - l . longValue ( ) ) / 1000.0 ; } wri . println ( " took " + nf . format ( seconds ) + " sec" ) ; } } public void addFailure ( Test test , Throwable t ) { formatError ( "\tFAILED" , test , t ) ; } public void addFailure ( Test test , AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( Test test , Throwable t ) { formatError ( "\tCaused an ERROR" , test , t ) ; } private void formatError ( String type , Test test , Throwable t ) { synchronized ( wri ) { if ( test != null ) { endTest ( test ) ; failed . put ( test , Boolean . TRUE ) ; } wri . println ( type ) ; wri . println ( t . getMessage ( ) ) ; String strace = JUnitTestRunner . getFilteredTrace ( t ) ; wri . print ( strace ) ; wri . println ( "" ) ; } } } 	0	['12', '1', '0', '9', '46', '34', '0', '9', '11', '0.715909091', '386', '1', '0', '0', '0.333333333', '0', '0', '30.5', '3', '1.1667', '0']
package org . apache . tools . ant . taskdefs ; import java . util . Iterator ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; public class Sequential extends Task implements TaskContainer { private Vector nestedTasks = new Vector ( ) ; public void addTask ( Task nestedTask ) { nestedTasks . addElement ( nestedTask ) ; } public void execute ( ) throws BuildException { for ( Iterator i = nestedTasks . iterator ( ) ; i . hasNext ( ) ; ) { Task nestedTask = ( Task ) i . next ( ) ; nestedTask . perform ( ) ; } } } 	0	['3', '3', '0', '3', '10', '0', '0', '3', '3', '0', '32', '1', '0', '0.948717949', '0.666666667', '0', '0', '9.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class InterfaceMethodRefCPInfo extends ConstantPoolEntry { private String interfaceMethodClassName ; private String interfaceMethodName ; private String interfaceMethodType ; private int classIndex ; private int nameAndTypeIndex ; public InterfaceMethodRefCPInfo ( ) { super ( CONSTANT_INTERFACEMETHODREF , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { classIndex = cpStream . readUnsignedShort ( ) ; nameAndTypeIndex = cpStream . readUnsignedShort ( ) ; } public void resolve ( ConstantPool constantPool ) { ClassCPInfo interfaceMethodClass = ( ClassCPInfo ) constantPool . getEntry ( classIndex ) ; interfaceMethodClass . resolve ( constantPool ) ; interfaceMethodClassName = interfaceMethodClass . getClassName ( ) ; NameAndTypeCPInfo nt = ( NameAndTypeCPInfo ) constantPool . getEntry ( nameAndTypeIndex ) ; nt . resolve ( constantPool ) ; interfaceMethodName = nt . getName ( ) ; interfaceMethodType = nt . getType ( ) ; super . resolve ( constantPool ) ; } public String toString ( ) { String value ; if ( isResolved ( ) ) { value = "InterfaceMethod : Class = " + interfaceMethodClassName + ", name = " + interfaceMethodName + ", type = " + interfaceMethodType ; } else { value = "InterfaceMethod : Class index = " + classIndex + ", name and type index = " + nameAndTypeIndex ; } return value ; } public String getInterfaceMethodClassName ( ) { return interfaceMethodClassName ; } public String getInterfaceMethodName ( ) { return interfaceMethodName ; } public String getInterfaceMethodType ( ) { return interfaceMethodType ; } } 	0	['7', '2', '0', '4', '21', '3', '2', '4', '7', '0.666666667', '108', '1', '0', '0.5', '0.428571429', '1', '1', '13.71428571', '2', '1', '0']
package org . apache . tools . ant ; import java . io . File ; public interface FileScanner { void addDefaultExcludes ( ) ; File getBasedir ( ) ; String [ ] getExcludedDirectories ( ) ; String [ ] getExcludedFiles ( ) ; String [ ] getIncludedDirectories ( ) ; String [ ] getIncludedFiles ( ) ; String [ ] getNotIncludedDirectories ( ) ; String [ ] getNotIncludedFiles ( ) ; void scan ( ) throws IllegalStateException ; void setBasedir ( String basedir ) ; void setBasedir ( File basedir ) ; void setExcludes ( String [ ] excludes ) ; void setIncludes ( String [ ] includes ) ; void setCaseSensitive ( boolean isCaseSensitive ) ; } 	0	['14', '1', '0', '5', '14', '91', '5', '0', '14', '2', '14', '0', '0', '0', '0.271428571', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; public interface EJBDeploymentTool { void processDescriptor ( String descriptorFilename , SAXParser saxParser ) throws BuildException ; void validateConfigured ( ) throws BuildException ; void setTask ( Task task ) ; void configure ( EjbJar . Config config ) ; } 	0	['4', '1', '0', '5', '4', '6', '2', '3', '4', '2', '4', '0', '0', '0', '0.4', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . MagicNames ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; public final class JarLibManifestTask extends Task { private static final String MANIFEST_VERSION = "1.0" ; private static final String CREATED_BY = "Created-By" ; private File destFile ; private Extension extension ; private final ArrayList dependencies = new ArrayList ( ) ; private final ArrayList optionals = new ArrayList ( ) ; private final ArrayList extraAttributes = new ArrayList ( ) ; public void setDestfile ( final File destFile ) { this . destFile = destFile ; } public void addConfiguredExtension ( final ExtensionAdapter extensionAdapter ) throws BuildException { if ( null != extension ) { final String message = "Can not have multiple extensions defined in one library." ; throw new BuildException ( message ) ; } extension = extensionAdapter . toExtension ( ) ; } public void addConfiguredDepends ( final ExtensionSet extensionSet ) { dependencies . add ( extensionSet ) ; } public void addConfiguredOptions ( final ExtensionSet extensionSet ) { optionals . add ( extensionSet ) ; } public void addConfiguredAttribute ( final ExtraAttribute attribute ) { extraAttributes . add ( attribute ) ; } public void execute ( ) throws BuildException { validate ( ) ; final Manifest manifest = new Manifest ( ) ; final Attributes attributes = manifest . getMainAttributes ( ) ; attributes . put ( Attributes . Name . MANIFEST_VERSION , MANIFEST_VERSION ) ; final String createdBy = "Apache Ant " + getProject ( ) . getProperty ( MagicNames . ANT_VERSION ) ; attributes . putValue ( CREATED_BY , createdBy ) ; appendExtraAttributes ( attributes ) ; if ( null != extension ) { Extension . addExtension ( extension , attributes ) ; } final ArrayList depends = toExtensions ( dependencies ) ; appendExtensionList ( attributes , Extension . EXTENSION_LIST , "lib" , depends . size ( ) ) ; appendLibraryList ( attributes , "lib" , depends ) ; final ArrayList option = toExtensions ( optionals ) ; appendExtensionList ( attributes , Extension . OPTIONAL_EXTENSION_LIST , "opt" , option . size ( ) ) ; appendLibraryList ( attributes , "opt" , option ) ; try { final String message = "Generating manifest " + destFile . getAbsoluteFile ( ) ; log ( message , Project . MSG_INFO ) ; writeManifest ( manifest ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } } private void validate ( ) throws BuildException { if ( null == destFile ) { final String message = "Destfile attribute not specified." ; throw new BuildException ( message ) ; } if ( destFile . exists ( ) && ! destFile . isFile ( ) ) { final String message = destFile + " is not a file." ; throw new BuildException ( message ) ; } } private void appendExtraAttributes ( final Attributes attributes ) { final Iterator iterator = extraAttributes . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ExtraAttribute attribute = ( ExtraAttribute ) iterator . next ( ) ; attributes . putValue ( attribute . getName ( ) , attribute . getValue ( ) ) ; } } private void writeManifest ( final Manifest manifest ) throws IOException { FileOutputStream output = null ; try { output = new FileOutputStream ( destFile ) ; manifest . write ( output ) ; output . flush ( ) ; } finally { if ( null != output ) { try { output . close ( ) ; } catch ( IOException e ) { } } } } private void appendLibraryList ( final Attributes attributes , final String listPrefix , final ArrayList extensions ) throws BuildException { final int size = extensions . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final Extension ext = ( Extension ) extensions . get ( i ) ; final String prefix = listPrefix + i + "-" ; Extension . addExtension ( ext , prefix , attributes ) ; } } private void appendExtensionList ( final Attributes attributes , final Attributes . Name extensionKey , final String listPrefix , final int size ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { sb . append ( listPrefix ) ; sb . append ( i ) ; sb . append ( ' ' ) ; } attributes . put ( extensionKey , sb . toString ( ) ) ; } private ArrayList toExtensions ( final ArrayList extensionSets ) throws BuildException { final ArrayList results = new ArrayList ( ) ; final int size = extensionSets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { final ExtensionSet set = ( ExtensionSet ) extensionSets . get ( i ) ; final Extension [ ] extensions = set . toExtensions ( getProject ( ) ) ; for ( int j = 0 ; j < extensions . length ; j ++ ) { results . add ( extensions [ j ] ) ; } } return results ; } } 	0	['13', '3', '0', '7', '52', '48', '0', '7', '7', '0.892857143', '355', '1', '1', '0.755102041', '0.195804196', '1', '1', '25.76923077', '2', '1.0769', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; import java . util . StringTokenizer ; import java . util . jar . Attributes ; import java . util . jar . Manifest ; import org . apache . tools . ant . util . StringUtils ; public final class Extension { public static final Attributes . Name EXTENSION_LIST = new Attributes . Name ( "Extension-List" ) ; public static final Attributes . Name OPTIONAL_EXTENSION_LIST = new Attributes . Name ( "Optional-Extension-List" ) ; public static final Attributes . Name EXTENSION_NAME = new Attributes . Name ( "Extension-Name" ) ; public static final Attributes . Name SPECIFICATION_VERSION = Attributes . Name . SPECIFICATION_VERSION ; public static final Attributes . Name SPECIFICATION_VENDOR = Attributes . Name . SPECIFICATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_VERSION = Attributes . Name . IMPLEMENTATION_VERSION ; public static final Attributes . Name IMPLEMENTATION_VENDOR = Attributes . Name . IMPLEMENTATION_VENDOR ; public static final Attributes . Name IMPLEMENTATION_URL = new Attributes . Name ( "Implementation-URL" ) ; public static final Attributes . Name IMPLEMENTATION_VENDOR_ID = new Attributes . Name ( "Implementation-Vendor-Id" ) ; public static final Compatibility COMPATIBLE = new Compatibility ( "COMPATIBLE" ) ; public static final Compatibility REQUIRE_SPECIFICATION_UPGRADE = new Compatibility ( "REQUIRE_SPECIFICATION_UPGRADE" ) ; public static final Compatibility REQUIRE_VENDOR_SWITCH = new Compatibility ( "REQUIRE_VENDOR_SWITCH" ) ; public static final Compatibility REQUIRE_IMPLEMENTATION_UPGRADE = new Compatibility ( "REQUIRE_IMPLEMENTATION_UPGRADE" ) ; public static final Compatibility INCOMPATIBLE = new Compatibility ( "INCOMPATIBLE" ) ; private String extensionName ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationVendorID ; private String implementationVendor ; private DeweyDecimal implementationVersion ; private String implementationURL ; public static Extension [ ] getAvailable ( final Manifest manifest ) { if ( null == manifest ) { return new Extension [ 0 ] ; } final ArrayList results = new ArrayList ( ) ; final Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( null != mainAttributes ) { final Extension extension = getExtension ( "" , mainAttributes ) ; if ( null != extension ) { results . add ( extension ) ; } } final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; final Extension extension = getExtension ( "" , attributes ) ; if ( null != extension ) { results . add ( extension ) ; } } return ( Extension [ ] ) results . toArray ( new Extension [ results . size ( ) ] ) ; } public static Extension [ ] getRequired ( final Manifest manifest ) { return getListed ( manifest , Attributes . Name . EXTENSION_LIST ) ; } public static Extension [ ] getOptions ( final Manifest manifest ) { return getListed ( manifest , OPTIONAL_EXTENSION_LIST ) ; } public static void addExtension ( final Extension extension , final Attributes attributes ) { addExtension ( extension , "" , attributes ) ; } public static void addExtension ( final Extension extension , final String prefix , final Attributes attributes ) { attributes . putValue ( prefix + EXTENSION_NAME , extension . getExtensionName ( ) ) ; final String specificationVendor = extension . getSpecificationVendor ( ) ; if ( null != specificationVendor ) { attributes . putValue ( prefix + SPECIFICATION_VENDOR , specificationVendor ) ; } final DeweyDecimal specificationVersion = extension . getSpecificationVersion ( ) ; if ( null != specificationVersion ) { attributes . putValue ( prefix + SPECIFICATION_VERSION , specificationVersion . toString ( ) ) ; } final String implementationVendorID = extension . getImplementationVendorID ( ) ; if ( null != implementationVendorID ) { attributes . putValue ( prefix + IMPLEMENTATION_VENDOR_ID , implementationVendorID ) ; } final String implementationVendor = extension . getImplementationVendor ( ) ; if ( null != implementationVendor ) { attributes . putValue ( prefix + IMPLEMENTATION_VENDOR , implementationVendor ) ; } final DeweyDecimal implementationVersion = extension . getImplementationVersion ( ) ; if ( null != implementationVersion ) { attributes . putValue ( prefix + IMPLEMENTATION_VERSION , implementationVersion . toString ( ) ) ; } final String implementationURL = extension . getImplementationURL ( ) ; if ( null != implementationURL ) { attributes . putValue ( prefix + IMPLEMENTATION_URL , implementationURL ) ; } } public Extension ( final String extensionName , final String specificationVersion , final String specificationVendor , final String implementationVersion , final String implementationVendor , final String implementationVendorId , final String implementationURL ) { this . extensionName = extensionName ; this . specificationVendor = specificationVendor ; if ( null != specificationVersion ) { try { this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad specification version format '" + specificationVersion + "' in '" + extensionName + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } this . implementationURL = implementationURL ; this . implementationVendor = implementationVendor ; this . implementationVendorID = implementationVendorId ; if ( null != implementationVersion ) { try { this . implementationVersion = new DeweyDecimal ( implementationVersion ) ; } catch ( final NumberFormatException nfe ) { final String error = "Bad implementation version format '" + implementationVersion + "' in '" + extensionName + "'. (Reason: " + nfe + ")" ; throw new IllegalArgumentException ( error ) ; } } if ( null == this . extensionName ) { throw new NullPointerException ( "extensionName property is null" ) ; } } public String getExtensionName ( ) { return extensionName ; } public String getSpecificationVendor ( ) { return specificationVendor ; } public DeweyDecimal getSpecificationVersion ( ) { return specificationVersion ; } public String getImplementationURL ( ) { return implementationURL ; } public String getImplementationVendor ( ) { return implementationVendor ; } public String getImplementationVendorID ( ) { return implementationVendorID ; } public DeweyDecimal getImplementationVersion ( ) { return implementationVersion ; } public Compatibility getCompatibilityWith ( final Extension required ) { if ( ! extensionName . equals ( required . getExtensionName ( ) ) ) { return INCOMPATIBLE ; } final DeweyDecimal requiredSpecificationVersion = required . getSpecificationVersion ( ) ; if ( null != requiredSpecificationVersion ) { if ( null == specificationVersion || ! isCompatible ( specificationVersion , requiredSpecificationVersion ) ) { return REQUIRE_SPECIFICATION_UPGRADE ; } } final String requiredImplementationVendorID = required . getImplementationVendorID ( ) ; if ( null != requiredImplementationVendorID ) { if ( null == implementationVendorID || ! implementationVendorID . equals ( requiredImplementationVendorID ) ) { return REQUIRE_VENDOR_SWITCH ; } } final DeweyDecimal requiredImplementationVersion = required . getImplementationVersion ( ) ; if ( null != requiredImplementationVersion ) { if ( null == implementationVersion || ! isCompatible ( implementationVersion , requiredImplementationVersion ) ) { return REQUIRE_IMPLEMENTATION_UPGRADE ; } } return COMPATIBLE ; } public boolean isCompatibleWith ( final Extension required ) { return ( COMPATIBLE == getCompatibilityWith ( required ) ) ; } public String toString ( ) { final String brace = ": " ; final StringBuffer sb = new StringBuffer ( EXTENSION_NAME . toString ( ) ) ; sb . append ( brace ) ; sb . append ( extensionName ) ; sb . append ( StringUtils . LINE_SEP ) ; if ( null != specificationVersion ) { sb . append ( SPECIFICATION_VERSION ) ; sb . append ( brace ) ; sb . append ( specificationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != specificationVendor ) { sb . append ( SPECIFICATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( specificationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVersion ) { sb . append ( IMPLEMENTATION_VERSION ) ; sb . append ( brace ) ; sb . append ( implementationVersion ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendorID ) { sb . append ( IMPLEMENTATION_VENDOR_ID ) ; sb . append ( brace ) ; sb . append ( implementationVendorID ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationVendor ) { sb . append ( IMPLEMENTATION_VENDOR ) ; sb . append ( brace ) ; sb . append ( implementationVendor ) ; sb . append ( StringUtils . LINE_SEP ) ; } if ( null != implementationURL ) { sb . append ( IMPLEMENTATION_URL ) ; sb . append ( brace ) ; sb . append ( implementationURL ) ; sb . append ( StringUtils . LINE_SEP ) ; } return sb . toString ( ) ; } private boolean isCompatible ( final DeweyDecimal first , final DeweyDecimal second ) { return first . isGreaterThanOrEqual ( second ) ; } private static Extension [ ] getListed ( final Manifest manifest , final Attributes . Name listKey ) { final ArrayList results = new ArrayList ( ) ; final Attributes mainAttributes = manifest . getMainAttributes ( ) ; if ( null != mainAttributes ) { getExtension ( mainAttributes , results , listKey ) ; } final Map entries = manifest . getEntries ( ) ; final Iterator keys = entries . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { final String key = ( String ) keys . next ( ) ; final Attributes attributes = ( Attributes ) entries . get ( key ) ; getExtension ( attributes , results , listKey ) ; } return ( Extension [ ] ) results . toArray ( new Extension [ results . size ( ) ] ) ; } private static void getExtension ( final Attributes attributes , final ArrayList required , final Attributes . Name listKey ) { final String names = attributes . getValue ( listKey ) ; if ( null == names ) { return ; } final String [ ] extentions = split ( names , " " ) ; for ( int i = 0 ; i < extentions . length ; i ++ ) { final String prefix = extentions [ i ] + "-" ; final Extension extension = getExtension ( prefix , attributes ) ; if ( null != extension ) { required . add ( extension ) ; } } } private static String [ ] split ( final String string , final String onToken ) { final StringTokenizer tokenizer = new StringTokenizer ( string , onToken ) ; final String [ ] result = new String [ tokenizer . countTokens ( ) ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = tokenizer . nextToken ( ) ; } return result ; } private static Extension getExtension ( final String prefix , final Attributes attributes ) { final String nameKey = prefix + EXTENSION_NAME ; final String name = getTrimmedString ( attributes . getValue ( nameKey ) ) ; if ( null == name ) { return null ; } final String specVendorKey = prefix + SPECIFICATION_VENDOR ; final String specVendor = getTrimmedString ( attributes . getValue ( specVendorKey ) ) ; final String specVersionKey = prefix + SPECIFICATION_VERSION ; final String specVersion = getTrimmedString ( attributes . getValue ( specVersionKey ) ) ; final String impVersionKey = prefix + IMPLEMENTATION_VERSION ; final String impVersion = getTrimmedString ( attributes . getValue ( impVersionKey ) ) ; final String impVendorKey = prefix + IMPLEMENTATION_VENDOR ; final String impVendor = getTrimmedString ( attributes . getValue ( impVendorKey ) ) ; final String impVendorIDKey = prefix + IMPLEMENTATION_VENDOR_ID ; final String impVendorId = getTrimmedString ( attributes . getValue ( impVendorIDKey ) ) ; final String impURLKey = prefix + IMPLEMENTATION_URL ; final String impURL = getTrimmedString ( attributes . getValue ( impURLKey ) ) ; return new Extension ( name , specVersion , specVendor , impVersion , impVendor , impVendorId , impURL ) ; } private static String getTrimmedString ( final String value ) { return null == value ? null : value . trim ( ) ; } } 	0	['23', '1', '0', '15', '56', '191', '11', '4', '16', '0.807359307', '850', '0.333333333', '7', '0', '0.1875', '0', '0', '35.04347826', '11', '2.4783', '0']
package org . apache . tools . ant . util ; public class IdentityMapper implements FileNameMapper { public void setFrom ( String from ) { } public void setTo ( String to ) { } public String [ ] mapFileName ( String sourceFileName ) { return new String [ ] { sourceFileName } ; } } 	0	['4', '1', '0', '8', '5', '6', '7', '1', '4', '2', '16', '0', '0', '0', '0.875', '0', '0', '3', '1', '0.75', '0']
package org . apache . tools . ant . util ; import java . io . File ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . FactoryConfigurationError ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import org . apache . tools . ant . BuildException ; import org . xml . sax . Parser ; import org . xml . sax . SAXException ; import org . xml . sax . XMLReader ; public class JAXPUtils { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static SAXParserFactory parserFactory = null ; private static SAXParserFactory nsParserFactory = null ; private static DocumentBuilderFactory builderFactory = null ; public static synchronized SAXParserFactory getParserFactory ( ) throws BuildException { if ( parserFactory == null ) { parserFactory = newParserFactory ( ) ; } return parserFactory ; } public static synchronized SAXParserFactory getNSParserFactory ( ) throws BuildException { if ( nsParserFactory == null ) { nsParserFactory = newParserFactory ( ) ; nsParserFactory . setNamespaceAware ( true ) ; } return nsParserFactory ; } public static SAXParserFactory newParserFactory ( ) throws BuildException { try { return SAXParserFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "XML parser factory has not been " + "configured correctly: " + e . getMessage ( ) , e ) ; } } public static Parser getParser ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getParser ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getXMLReader ( ) throws BuildException { try { return newSAXParser ( getParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static XMLReader getNamespaceXMLReader ( ) throws BuildException { try { return newSAXParser ( getNSParserFactory ( ) ) . getXMLReader ( ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } public static String getSystemId ( File file ) { return FILE_UTILS . toURI ( file . getAbsolutePath ( ) ) ; } public static DocumentBuilder getDocumentBuilder ( ) throws BuildException { try { return getDocumentBuilderFactory ( ) . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( e ) ; } } private static SAXParser newSAXParser ( SAXParserFactory factory ) throws BuildException { try { return factory . newSAXParser ( ) ; } catch ( ParserConfigurationException e ) { throw new BuildException ( "Cannot create parser for the given " + "configuration: " + e . getMessage ( ) , e ) ; } catch ( SAXException e ) { throw convertToBuildException ( e ) ; } } private static BuildException convertToBuildException ( SAXException e ) { Exception nested = e . getException ( ) ; if ( nested != null ) { return new BuildException ( nested ) ; } else { return new BuildException ( e ) ; } } private static synchronized DocumentBuilderFactory getDocumentBuilderFactory ( ) throws BuildException { if ( builderFactory == null ) { try { builderFactory = DocumentBuilderFactory . newInstance ( ) ; } catch ( FactoryConfigurationError e ) { throw new BuildException ( "Document builder factory has not " + "been configured correctly: " + e . getMessage ( ) , e ) ; } } return builderFactory ; } } 	0	['13', '1', '0', '12', '32', '70', '10', '2', '9', '0.833333333', '155', '1', '1', '0', '0.083333333', '0', '0', '10.61538462', '2', '0.9231', '0']
package org . apache . tools . ant . util ; import java . io . File ; public class UnPackageNameMapper extends GlobPatternMapper { protected String extractVariablePart ( String name ) { String var = name . substring ( prefixLength , name . length ( ) - postfixLength ) ; return var . replace ( '.' , File . separatorChar ) ; } } 	0	['2', '2', '0', '1', '6', '1', '0', '1', '1', '2', '20', '0', '0', '0.875', '0.75', '1', '1', '9', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . StringTokenizer ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . PatternSet ; import org . apache . tools . ant . types . selectors . AndSelector ; import org . apache . tools . ant . types . selectors . ContainsRegexpSelector ; import org . apache . tools . ant . types . selectors . ContainsSelector ; import org . apache . tools . ant . types . selectors . DateSelector ; import org . apache . tools . ant . types . selectors . DependSelector ; import org . apache . tools . ant . types . selectors . DepthSelector ; import org . apache . tools . ant . types . selectors . DifferentSelector ; import org . apache . tools . ant . types . selectors . ExtendSelector ; import org . apache . tools . ant . types . selectors . FileSelector ; import org . apache . tools . ant . types . selectors . FilenameSelector ; import org . apache . tools . ant . types . selectors . MajoritySelector ; import org . apache . tools . ant . types . selectors . NoneSelector ; import org . apache . tools . ant . types . selectors . NotSelector ; import org . apache . tools . ant . types . selectors . OrSelector ; import org . apache . tools . ant . types . selectors . PresentSelector ; import org . apache . tools . ant . types . selectors . SelectSelector ; import org . apache . tools . ant . types . selectors . SelectorContainer ; import org . apache . tools . ant . types . selectors . SizeSelector ; import org . apache . tools . ant . types . selectors . TypeSelector ; import org . apache . tools . ant . types . selectors . modifiedselector . ModifiedSelector ; public abstract class MatchingTask extends Task implements SelectorContainer { protected FileSet fileset = new FileSet ( ) ; public void setProject ( Project project ) { super . setProject ( project ) ; fileset . setProject ( project ) ; } public PatternSet . NameEntry createInclude ( ) { return fileset . createInclude ( ) ; } public PatternSet . NameEntry createIncludesFile ( ) { return fileset . createIncludesFile ( ) ; } public PatternSet . NameEntry createExclude ( ) { return fileset . createExclude ( ) ; } public PatternSet . NameEntry createExcludesFile ( ) { return fileset . createExcludesFile ( ) ; } public PatternSet createPatternSet ( ) { return fileset . createPatternSet ( ) ; } public void setIncludes ( String includes ) { fileset . setIncludes ( includes ) ; } public void XsetItems ( String itemString ) { log ( "The items attribute is deprecated. " + "Please use the includes attribute." , Project . MSG_WARN ) ; if ( itemString == null || itemString . equals ( "*" ) || itemString . equals ( "." ) ) { createInclude ( ) . setName ( "**" ) ; } else { StringTokenizer tok = new StringTokenizer ( itemString , ", " ) ; while ( tok . hasMoreTokens ( ) ) { String pattern = tok . nextToken ( ) . trim ( ) ; if ( pattern . length ( ) > 0 ) { createInclude ( ) . setName ( pattern + "/**" ) ; } } } } public void setExcludes ( String excludes ) { fileset . setExcludes ( excludes ) ; } public void XsetIgnore ( String ignoreString ) { log ( "The ignore attribute is deprecated." + "Please use the excludes attribute." , Project . MSG_WARN ) ; if ( ignoreString != null && ignoreString . length ( ) > 0 ) { StringTokenizer tok = new StringTokenizer ( ignoreString , ", " , false ) ; while ( tok . hasMoreTokens ( ) ) { createExclude ( ) . setName ( "**/" + tok . nextToken ( ) . trim ( ) + "/**" ) ; } } } public void setDefaultexcludes ( boolean useDefaultExcludes ) { fileset . setDefaultexcludes ( useDefaultExcludes ) ; } protected DirectoryScanner getDirectoryScanner ( File baseDir ) { fileset . setDir ( baseDir ) ; return fileset . getDirectoryScanner ( getProject ( ) ) ; } public void setIncludesfile ( File includesfile ) { fileset . setIncludesfile ( includesfile ) ; } public void setExcludesfile ( File excludesfile ) { fileset . setExcludesfile ( excludesfile ) ; } public void setCaseSensitive ( boolean isCaseSensitive ) { fileset . setCaseSensitive ( isCaseSensitive ) ; } public void setFollowSymlinks ( boolean followSymlinks ) { fileset . setFollowSymlinks ( followSymlinks ) ; } public boolean hasSelectors ( ) { return fileset . hasSelectors ( ) ; } public int selectorCount ( ) { return fileset . selectorCount ( ) ; } public FileSelector [ ] getSelectors ( Project p ) { return fileset . getSelectors ( p ) ; } public Enumeration selectorElements ( ) { return fileset . selectorElements ( ) ; } public void appendSelector ( FileSelector selector ) { fileset . appendSelector ( selector ) ; } public void addSelector ( SelectSelector selector ) { fileset . addSelector ( selector ) ; } public void addAnd ( AndSelector selector ) { fileset . addAnd ( selector ) ; } public void addOr ( OrSelector selector ) { fileset . addOr ( selector ) ; } public void addNot ( NotSelector selector ) { fileset . addNot ( selector ) ; } public void addNone ( NoneSelector selector ) { fileset . addNone ( selector ) ; } public void addMajority ( MajoritySelector selector ) { fileset . addMajority ( selector ) ; } public void addDate ( DateSelector selector ) { fileset . addDate ( selector ) ; } public void addSize ( SizeSelector selector ) { fileset . addSize ( selector ) ; } public void addFilename ( FilenameSelector selector ) { fileset . addFilename ( selector ) ; } public void addCustom ( ExtendSelector selector ) { fileset . addCustom ( selector ) ; } public void addContains ( ContainsSelector selector ) { fileset . addContains ( selector ) ; } public void addPresent ( PresentSelector selector ) { fileset . addPresent ( selector ) ; } public void addDepth ( DepthSelector selector ) { fileset . addDepth ( selector ) ; } public void addDepend ( DependSelector selector ) { fileset . addDepend ( selector ) ; } public void addContainsRegexp ( ContainsRegexpSelector selector ) { fileset . addContainsRegexp ( selector ) ; } public void addDifferent ( DifferentSelector selector ) { fileset . addDifferent ( selector ) ; } public void addType ( TypeSelector selector ) { fileset . addType ( selector ) ; } public void addModified ( ModifiedSelector selector ) { fileset . addModified ( selector ) ; } public void add ( FileSelector selector ) { fileset . add ( selector ) ; } protected final FileSet getImplicitFileSet ( ) { return fileset ; } } 	0	['42', '3', '21', '47', '98', '0', '21', '26', '40', '0', '327', '1', '1', '0.474358974', '0.073412698', '2', '2', '6.761904762', '6', '1.1667', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Iterator ; import java . util . Set ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import java . util . zip . ZipEntry ; import javax . xml . parsers . SAXParser ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . util . depend . DependencyAnalyzer ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public class GenericDeploymentTool implements EJBDeploymentTool { public static final int DEFAULT_BUFFER_SIZE = 1024 ; public static final int JAR_COMPRESS_LEVEL = 9 ; protected static final String META_DIR = "META-INF/" ; protected static final String MANIFEST = META_DIR + "MANIFEST.MF" ; protected static final String EJB_DD = "ejb-jar.xml" ; public static final String ANALYZER_SUPER = "super" ; public static final String ANALYZER_FULL = "full" ; public static final String ANALYZER_NONE = "none" ; public static final String DEFAULT_ANALYZER = ANALYZER_SUPER ; public static final String ANALYZER_CLASS_SUPER = "org.apache.tools.ant.util.depend.bcel.AncestorAnalyzer" ; public static final String ANALYZER_CLASS_FULL = "org.apache.tools.ant.util.depend.bcel.FullAnalyzer" ; private EjbJar . Config config ; private File destDir ; private Path classpath ; private String genericJarSuffix = "-generic.jar" ; private Task task ; private ClassLoader classpathLoader = null ; private Set addedfiles ; private DescriptorHandler handler ; private DependencyAnalyzer dependencyAnalyzer ; public GenericDeploymentTool ( ) { } public void setDestdir ( File inDir ) { this . destDir = inDir ; } protected File getDestDir ( ) { return destDir ; } public void setTask ( Task task ) { this . task = task ; } protected Task getTask ( ) { return task ; } protected EjbJar . Config getConfig ( ) { return config ; } protected boolean usingBaseJarName ( ) { return config . baseJarName != null ; } public void setGenericJarSuffix ( String inString ) { this . genericJarSuffix = inString ; } public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( task . getProject ( ) ) ; } return classpath . createPath ( ) ; } public void setClasspath ( Path classpath ) { this . classpath = classpath ; } protected Path getCombinedClasspath ( ) { Path combinedPath = classpath ; if ( config . classpath != null ) { if ( combinedPath == null ) { combinedPath = config . classpath ; } else { combinedPath . append ( config . classpath ) ; } } return combinedPath ; } protected void log ( String message , int level ) { getTask ( ) . log ( message , level ) ; } protected Location getLocation ( ) { return getTask ( ) . getLocation ( ) ; } private void createAnalyzer ( ) { String analyzer = config . analyzer ; if ( analyzer == null ) { analyzer = DEFAULT_ANALYZER ; } if ( analyzer . equals ( ANALYZER_NONE ) ) { return ; } String analyzerClassName = null ; if ( analyzer . equals ( ANALYZER_SUPER ) ) { analyzerClassName = ANALYZER_CLASS_SUPER ; } else if ( analyzer . equals ( ANALYZER_FULL ) ) { analyzerClassName = ANALYZER_CLASS_FULL ; } else { analyzerClassName = analyzer ; } try { Class analyzerClass = Class . forName ( analyzerClassName ) ; dependencyAnalyzer = ( DependencyAnalyzer ) analyzerClass . newInstance ( ) ; dependencyAnalyzer . addClassPath ( new Path ( task . getProject ( ) , config . srcDir . getPath ( ) ) ) ; dependencyAnalyzer . addClassPath ( config . classpath ) ; } catch ( NoClassDefFoundError e ) { dependencyAnalyzer = null ; task . log ( "Unable to load dependency analyzer: " + analyzerClassName + " - dependent class not found: " + e . getMessage ( ) , Project . MSG_WARN ) ; } catch ( Exception e ) { dependencyAnalyzer = null ; task . log ( "Unable to load dependency analyzer: " + analyzerClassName + " - exception: " + e . getMessage ( ) , Project . MSG_WARN ) ; } } public void configure ( EjbJar . Config config ) { this . config = config ; createAnalyzer ( ) ; classpathLoader = null ; } protected void addFileToJar ( JarOutputStream jStream , File inputFile , String logicalFilename ) throws BuildException { FileInputStream iStream = null ; try { if ( ! addedfiles . contains ( logicalFilename ) ) { iStream = new FileInputStream ( inputFile ) ; ZipEntry zipEntry = new ZipEntry ( logicalFilename . replace ( '\\' , '/' ) ) ; jStream . putNextEntry ( zipEntry ) ; byte [ ] byteBuffer = new byte [ 2 * DEFAULT_BUFFER_SIZE ] ; int count = 0 ; do { jStream . write ( byteBuffer , 0 , count ) ; count = iStream . read ( byteBuffer , 0 , byteBuffer . length ) ; } while ( count != - 1 ) ; addedfiles . add ( logicalFilename ) ; } } catch ( IOException ioe ) { log ( "WARNING: IOException while adding entry " + logicalFilename + " to jarfile from " + inputFile . getPath ( ) + " " + ioe . getClass ( ) . getName ( ) + "-" + ioe . getMessage ( ) , Project . MSG_WARN ) ; } finally { if ( iStream != null ) { try { iStream . close ( ) ; } catch ( IOException closeException ) { } } } } protected DescriptorHandler getDescriptorHandler ( File srcDir ) { DescriptorHandler h = new DescriptorHandler ( getTask ( ) , srcDir ) ; registerKnownDTDs ( h ) ; for ( Iterator i = getConfig ( ) . dtdLocations . iterator ( ) ; i . hasNext ( ) ; ) { EjbJar . DTDLocation dtdLocation = ( EjbJar . DTDLocation ) i . next ( ) ; h . registerDTD ( dtdLocation . getPublicId ( ) , dtdLocation . getLocation ( ) ) ; } return h ; } protected void registerKnownDTDs ( DescriptorHandler handler ) { } public void processDescriptor ( String descriptorFileName , SAXParser saxParser ) { checkConfiguration ( descriptorFileName , saxParser ) ; try { handler = getDescriptorHandler ( config . srcDir ) ; Hashtable ejbFiles = parseEjbFiles ( descriptorFileName , saxParser ) ; addSupportClasses ( ejbFiles ) ; String baseName = getJarBaseName ( descriptorFileName ) ; String ddPrefix = getVendorDDPrefix ( baseName , descriptorFileName ) ; File manifestFile = getManifestFile ( ddPrefix ) ; if ( manifestFile != null ) { ejbFiles . put ( MANIFEST , manifestFile ) ; } ejbFiles . put ( META_DIR + EJB_DD , new File ( config . descriptorDir , descriptorFileName ) ) ; addVendorFiles ( ejbFiles , ddPrefix ) ; checkAndAddDependants ( ejbFiles ) ; if ( config . flatDestDir && baseName . length ( ) != 0 ) { int startName = baseName . lastIndexOf ( File . separator ) ; if ( startName == - 1 ) { startName = 0 ; } int endName = baseName . length ( ) ; baseName = baseName . substring ( startName , endName ) ; } File jarFile = getVendorOutputJarFile ( baseName ) ; if ( needToRebuild ( ejbFiles , jarFile ) ) { log ( "building " + jarFile . getName ( ) + " with " + String . valueOf ( ejbFiles . size ( ) ) + " files" , Project . MSG_INFO ) ; String publicId = getPublicId ( ) ; writeJar ( baseName , jarFile , ejbFiles , publicId ) ; } else { log ( jarFile . toString ( ) + " is up to date." , Project . MSG_VERBOSE ) ; } } catch ( SAXException se ) { String msg = "SAXException while parsing '" + descriptorFileName + "'. This probably indicates badly-formed XML." + "  Details: " + se . getMessage ( ) ; throw new BuildException ( msg , se ) ; } catch ( IOException ioe ) { String msg = "IOException while parsing'" + descriptorFileName . toString ( ) + "'.  This probably indicates that the descriptor" + " doesn't exist. Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } } protected void checkConfiguration ( String descriptorFileName , SAXParser saxParser ) throws BuildException { } protected Hashtable parseEjbFiles ( String descriptorFileName , SAXParser saxParser ) throws IOException , SAXException { FileInputStream descriptorStream = null ; Hashtable ejbFiles = null ; try { descriptorStream = new FileInputStream ( new File ( config . descriptorDir , descriptorFileName ) ) ; saxParser . parse ( new InputSource ( descriptorStream ) , handler ) ; ejbFiles = handler . getFiles ( ) ; } finally { if ( descriptorStream != null ) { try { descriptorStream . close ( ) ; } catch ( IOException closeException ) { } } } return ejbFiles ; } protected void addSupportClasses ( Hashtable ejbFiles ) { Project project = task . getProject ( ) ; for ( Iterator i = config . supportFileSets . iterator ( ) ; i . hasNext ( ) ; ) { FileSet supportFileSet = ( FileSet ) i . next ( ) ; File supportBaseDir = supportFileSet . getDir ( project ) ; DirectoryScanner supportScanner = supportFileSet . getDirectoryScanner ( project ) ; supportScanner . scan ( ) ; String [ ] supportFiles = supportScanner . getIncludedFiles ( ) ; for ( int j = 0 ; j < supportFiles . length ; ++ j ) { ejbFiles . put ( supportFiles [ j ] , new File ( supportBaseDir , supportFiles [ j ] ) ) ; } } } protected String getJarBaseName ( String descriptorFileName ) { String baseName = "" ; if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . BASEJARNAME ) ) { String canonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int index = canonicalDescriptor . lastIndexOf ( '/' ) ; if ( index != - 1 ) { baseName = descriptorFileName . substring ( 0 , index + 1 ) ; } baseName += config . baseJarName ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { int lastSeparatorIndex = descriptorFileName . lastIndexOf ( File . separator ) ; int endBaseName = - 1 ; if ( lastSeparatorIndex != - 1 ) { endBaseName = descriptorFileName . indexOf ( config . baseNameTerminator , lastSeparatorIndex ) ; } else { endBaseName = descriptorFileName . indexOf ( config . baseNameTerminator ) ; } if ( endBaseName != - 1 ) { baseName = descriptorFileName . substring ( 0 , endBaseName ) ; } else { throw new BuildException ( "Unable to determine jar name " + "from descriptor \"" + descriptorFileName + "\"" ) ; } } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DIRECTORY ) ) { File descriptorFile = new File ( config . descriptorDir , descriptorFileName ) ; String path = descriptorFile . getAbsolutePath ( ) ; int lastSeparatorIndex = path . lastIndexOf ( File . separator ) ; if ( lastSeparatorIndex == - 1 ) { throw new BuildException ( "Unable to determine directory name holding descriptor" ) ; } String dirName = path . substring ( 0 , lastSeparatorIndex ) ; int dirSeparatorIndex = dirName . lastIndexOf ( File . separator ) ; if ( dirSeparatorIndex != - 1 ) { dirName = dirName . substring ( dirSeparatorIndex + 1 ) ; } baseName = dirName ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . EJB_NAME ) ) { baseName = handler . getEjbName ( ) ; } return baseName ; } public String getVendorDDPrefix ( String baseName , String descriptorFileName ) { String ddPrefix = null ; if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DESCRIPTOR ) ) { ddPrefix = baseName + config . baseNameTerminator ; } else if ( config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . BASEJARNAME ) || config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . EJB_NAME ) || config . namingScheme . getValue ( ) . equals ( EjbJar . NamingScheme . DIRECTORY ) ) { String canonicalDescriptor = descriptorFileName . replace ( '\\' , '/' ) ; int index = canonicalDescriptor . lastIndexOf ( '/' ) ; if ( index == - 1 ) { ddPrefix = "" ; } else { ddPrefix = descriptorFileName . substring ( 0 , index + 1 ) ; } } return ddPrefix ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { } File getVendorOutputJarFile ( String baseName ) { return new File ( destDir , baseName + genericJarSuffix ) ; } protected boolean needToRebuild ( Hashtable ejbFiles , File jarFile ) { if ( jarFile . exists ( ) ) { long lastBuild = jarFile . lastModified ( ) ; Iterator fileIter = ejbFiles . values ( ) . iterator ( ) ; while ( fileIter . hasNext ( ) ) { File currentFile = ( File ) fileIter . next ( ) ; if ( lastBuild < currentFile . lastModified ( ) ) { log ( "Build needed because " + currentFile . getPath ( ) + " is out of date" , Project . MSG_VERBOSE ) ; return true ; } } return false ; } return true ; } protected String getPublicId ( ) { return handler . getPublicId ( ) ; } protected File getManifestFile ( String prefix ) { File manifestFile = new File ( getConfig ( ) . descriptorDir , prefix + "manifest.mf" ) ; if ( manifestFile . exists ( ) ) { return manifestFile ; } if ( config . manifest != null ) { return config . manifest ; } return null ; } protected void writeJar ( String baseName , File jarfile , Hashtable files , String publicId ) throws BuildException { JarOutputStream jarStream = null ; try { if ( addedfiles == null ) { addedfiles = new HashSet ( ) ; } else { addedfiles . clear ( ) ; } if ( jarfile . exists ( ) ) { jarfile . delete ( ) ; } jarfile . getParentFile ( ) . mkdirs ( ) ; jarfile . createNewFile ( ) ; InputStream in = null ; Manifest manifest = null ; try { File manifestFile = ( File ) files . get ( MANIFEST ) ; if ( manifestFile != null && manifestFile . exists ( ) ) { in = new FileInputStream ( manifestFile ) ; } else { String defaultManifest = "/org/apache/tools/ant/defaultManifest.mf" ; in = this . getClass ( ) . getResourceAsStream ( defaultManifest ) ; if ( in == null ) { throw new BuildException ( "Could not find " + "default manifest: " + defaultManifest ) ; } } manifest = new Manifest ( in ) ; } catch ( IOException e ) { throw new BuildException ( "Unable to read manifest" , e , getLocation ( ) ) ; } finally { if ( in != null ) { in . close ( ) ; } } jarStream = new JarOutputStream ( new FileOutputStream ( jarfile ) , manifest ) ; jarStream . setMethod ( JarOutputStream . DEFLATED ) ; for ( Iterator entryIterator = files . keySet ( ) . iterator ( ) ; entryIterator . hasNext ( ) ; ) { String entryName = ( String ) entryIterator . next ( ) ; if ( entryName . equals ( MANIFEST ) ) { continue ; } File entryFile = ( File ) files . get ( entryName ) ; log ( "adding file '" + entryName + "'" , Project . MSG_VERBOSE ) ; addFileToJar ( jarStream , entryFile , entryName ) ; InnerClassFilenameFilter flt = new InnerClassFilenameFilter ( entryFile . getName ( ) ) ; File entryDir = entryFile . getParentFile ( ) ; String [ ] innerfiles = entryDir . list ( flt ) ; if ( innerfiles != null ) { for ( int i = 0 , n = innerfiles . length ; i < n ; i ++ ) { int entryIndex = entryName . lastIndexOf ( entryFile . getName ( ) ) - 1 ; if ( entryIndex < 0 ) { entryName = innerfiles [ i ] ; } else { entryName = entryName . substring ( 0 , entryIndex ) + File . separatorChar + innerfiles [ i ] ; } entryFile = new File ( config . srcDir , entryName ) ; log ( "adding innerclass file '" + entryName + "'" , Project . MSG_VERBOSE ) ; addFileToJar ( jarStream , entryFile , entryName ) ; } } } } catch ( IOException ioe ) { String msg = "IOException while processing ejb-jar file '" + jarfile . toString ( ) + "'. Details: " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe ) ; } finally { if ( jarStream != null ) { try { jarStream . close ( ) ; } catch ( IOException closeException ) { } } } } protected void checkAndAddDependants ( Hashtable checkEntries ) throws BuildException { if ( dependencyAnalyzer == null ) { return ; } dependencyAnalyzer . reset ( ) ; Iterator i = checkEntries . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { String entryName = ( String ) i . next ( ) ; if ( entryName . endsWith ( ".class" ) ) { String className = entryName . substring ( 0 , entryName . length ( ) - ".class" . length ( ) ) ; className = className . replace ( File . separatorChar , '/' ) ; className = className . replace ( '/' , '.' ) ; dependencyAnalyzer . addRootClass ( className ) ; } } Enumeration e = dependencyAnalyzer . getClassDependencies ( ) ; while ( e . hasMoreElements ( ) ) { String classname = ( String ) e . nextElement ( ) ; String location = classname . replace ( '.' , File . separatorChar ) + ".class" ; File classFile = new File ( config . srcDir , location ) ; if ( classFile . exists ( ) ) { checkEntries . put ( location , classFile ) ; log ( "dependent class: " + classname + " - " + classFile , Project . MSG_VERBOSE ) ; } } } protected ClassLoader getClassLoaderForBuild ( ) { if ( classpathLoader != null ) { return classpathLoader ; } Path combinedClasspath = getCombinedClasspath ( ) ; if ( combinedClasspath == null ) { classpathLoader = getClass ( ) . getClassLoader ( ) ; } else { classpathLoader = getTask ( ) . getProject ( ) . createClassLoader ( combinedClasspath ) ; } return classpathLoader ; } public void validateConfigured ( ) throws BuildException { if ( ( destDir == null ) || ( ! destDir . isDirectory ( ) ) ) { String msg = "A valid destination directory must be specified " + "using the \"destdir\" attribute." ; throw new BuildException ( msg , getLocation ( ) ) ; } } } 	0	['33', '1', '6', '22', '135', '316', '7', '15', '10', '0.940625', '1367', '0.6', '5', '0', '0.17630854', '0', '0', '39.81818182', '10', '2.0909', '0']
package org . apache . tools . ant . types . resources ; import java . util . List ; import java . util . Iterator ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; public class Union extends BaseResourceCollectionContainer { public static Union getInstance ( ResourceCollection rc ) { return rc instanceof Union ? ( Union ) rc : new Union ( rc ) ; } public Union ( ) { } public Union ( ResourceCollection rc ) { add ( rc ) ; } public String [ ] list ( ) { if ( isReference ( ) ) { return ( ( Union ) getCheckedRef ( ) ) . list ( ) ; } Collection result = getCollection ( true ) ; return ( String [ ] ) ( result . toArray ( new String [ result . size ( ) ] ) ) ; } public Resource [ ] listResources ( ) { if ( isReference ( ) ) { return ( ( Union ) getCheckedRef ( ) ) . listResources ( ) ; } Collection result = getCollection ( ) ; return ( Resource [ ] ) ( result . toArray ( new Resource [ result . size ( ) ] ) ) ; } protected Collection getCollection ( ) { return getCollection ( false ) ; } protected Collection getCollection ( boolean asString ) { List rc = getResourceCollections ( ) ; if ( rc . isEmpty ( ) ) { return Collections . EMPTY_LIST ; } ArrayList union = new ArrayList ( rc . size ( ) * 2 ) ; for ( Iterator rcIter = rc . iterator ( ) ; rcIter . hasNext ( ) ; ) { for ( Iterator r = nextRC ( rcIter ) . iterator ( ) ; r . hasNext ( ) ; ) { Object o = r . next ( ) ; if ( asString ) { o = o . toString ( ) ; } if ( ! ( union . contains ( o ) ) ) { union . add ( o ) ; } } } return union ; } private static ResourceCollection nextRC ( Iterator i ) { return ( ResourceCollection ) i . next ( ) ; } } 	0	['8', '4', '0', '16', '25', '28', '13', '3', '5', '2', '122', '0', '0', '0.88', '0.3125', '1', '1', '14.25', '6', '1.75', '0']
package org . apache . tools . ant . util ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; public abstract class LineOrientedOutputStream extends OutputStream { private static final int INTIAL_SIZE = 132 ; private static final int CR = 0x0d ; private static final int LF = 0x0a ; private ByteArrayOutputStream buffer = new ByteArrayOutputStream ( INTIAL_SIZE ) ; private boolean skip = false ; public final void write ( int cc ) throws IOException { final byte c = ( byte ) cc ; if ( ( c == LF ) || ( c == CR ) ) { if ( ! skip ) { processBuffer ( ) ; } } else { buffer . write ( cc ) ; } skip = ( c == CR ) ; } public final void flush ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } } protected void processBuffer ( ) throws IOException { try { processLine ( buffer . toString ( ) ) ; } finally { buffer . reset ( ) ; } } protected abstract void processLine ( String line ) throws IOException ; public final void close ( ) throws IOException { if ( buffer . size ( ) > 0 ) { processBuffer ( ) ; } super . close ( ) ; } public final void write ( byte [ ] b , int off , int len ) throws IOException { int offset = off ; int blockStartOffset = offset ; int remaining = len ; while ( remaining > 0 ) { while ( remaining > 0 && b [ offset ] != LF && b [ offset ] != CR ) { offset ++ ; remaining -- ; } int blockLength = offset - blockStartOffset ; if ( blockLength > 0 ) { buffer . write ( b , blockStartOffset , blockLength ) ; } while ( remaining > 0 && ( b [ offset ] == LF || b [ offset ] == CR ) ) { write ( b [ offset ] ) ; offset ++ ; remaining -- ; } blockStartOffset = offset ; } } } 	0	['7', '2', '2', '2', '15', '0', '2', '0', '5', '0.866666667', '143', '1', '0', '0.454545455', '0.392857143', '1', '1', '18.71428571', '1', '0.8571', '0']
package org . apache . tools . ant . taskdefs . optional . jsp . compilers ; import org . apache . tools . ant . AntClassLoader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . optional . jsp . JspNameMangler ; import org . apache . tools . ant . taskdefs . optional . jsp . Jasper41Mangler ; public final class JspCompilerAdapterFactory { private JspCompilerAdapterFactory ( ) { } public static JspCompilerAdapter getCompiler ( String compilerType , Task task ) throws BuildException { return getCompiler ( compilerType , task , task . getProject ( ) . createClassLoader ( null ) ) ; } public static JspCompilerAdapter getCompiler ( String compilerType , Task task , AntClassLoader loader ) throws BuildException { if ( compilerType . equalsIgnoreCase ( "jasper" ) ) { return new JasperC ( new JspNameMangler ( ) ) ; } if ( compilerType . equalsIgnoreCase ( "jasper41" ) ) { return new JasperC ( new Jasper41Mangler ( ) ) ; } return resolveClassName ( compilerType , loader ) ; } private static JspCompilerAdapter resolveClassName ( String className , AntClassLoader classloader ) throws BuildException { try { Class c = classloader . findClass ( className ) ; Object o = c . newInstance ( ) ; return ( JspCompilerAdapter ) o ; } catch ( ClassNotFoundException cnfe ) { throw new BuildException ( className + " can\'t be found." , cnfe ) ; } catch ( ClassCastException cce ) { throw new BuildException ( className + " isn\'t the classname of " + "a compiler adapter." , cce ) ; } catch ( Throwable t ) { throw new BuildException ( className + " caused an interesting " + "exception." , t ) ; } } } 	0	['4', '1', '0', '11', '18', '6', '1', '10', '2', '2', '97', '0', '0', '0', '0.5', '0', '0', '23.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . optional . extension ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Reference ; public class ExtensionAdapter extends DataType { private String extensionName ; private DeweyDecimal specificationVersion ; private String specificationVendor ; private String implementationVendorID ; private String implementationVendor ; private DeweyDecimal implementationVersion ; private String implementationURL ; public void setExtensionName ( final String extensionName ) { verifyNotAReference ( ) ; this . extensionName = extensionName ; } public void setSpecificationVersion ( final String specificationVersion ) { verifyNotAReference ( ) ; this . specificationVersion = new DeweyDecimal ( specificationVersion ) ; } public void setSpecificationVendor ( final String specificationVendor ) { verifyNotAReference ( ) ; this . specificationVendor = specificationVendor ; } public void setImplementationVendorId ( final String implementationVendorID ) { verifyNotAReference ( ) ; this . implementationVendorID = implementationVendorID ; } public void setImplementationVendor ( final String implementationVendor ) { verifyNotAReference ( ) ; this . implementationVendor = implementationVendor ; } public void setImplementationVersion ( final String implementationVersion ) { verifyNotAReference ( ) ; this . implementationVersion = new DeweyDecimal ( implementationVersion ) ; } public void setImplementationUrl ( final String implementationURL ) { verifyNotAReference ( ) ; this . implementationURL = implementationURL ; } public void setRefid ( final Reference reference ) throws BuildException { if ( null != extensionName || null != specificationVersion || null != specificationVendor || null != implementationVersion || null != implementationVendorID || null != implementationVendor || null != implementationURL ) { throw tooManyAttributes ( ) ; } Object o = reference . getReferencedObject ( getProject ( ) ) ; if ( o instanceof ExtensionAdapter ) { final ExtensionAdapter other = ( ExtensionAdapter ) o ; extensionName = other . extensionName ; specificationVersion = other . specificationVersion ; specificationVendor = other . specificationVendor ; implementationVersion = other . implementationVersion ; implementationVendorID = other . implementationVendorID ; implementationVendor = other . implementationVendor ; implementationURL = other . implementationURL ; } else { final String message = reference . getRefId ( ) + " doesn\'t refer to a Extension" ; throw new BuildException ( message ) ; } super . setRefid ( reference ) ; } private void verifyNotAReference ( ) throws BuildException { if ( isReference ( ) ) { throw tooManyAttributes ( ) ; } } Extension toExtension ( ) throws BuildException { if ( null == extensionName ) { final String message = "Extension is missing name." ; throw new BuildException ( message ) ; } String specificationVersionString = null ; if ( null != specificationVersion ) { specificationVersionString = specificationVersion . toString ( ) ; } String implementationVersionString = null ; if ( null != implementationVersion ) { implementationVersionString = implementationVersion . toString ( ) ; } return new Extension ( extensionName , specificationVersionString , specificationVendor , implementationVersionString , implementationVendor , implementationVendorID , implementationURL ) ; } public String toString ( ) { return "{" + toExtension ( ) . toString ( ) + "}" ; } } 	0	['12', '3', '0', '11', '28', '36', '5', '6', '10', '0.727272727', '214', '1', '2', '0.731707317', '0.555555556', '1', '1', '16.25', '1', '0.9167', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class ClassCPInfo extends ConstantPoolEntry { private String className ; private int index ; public ClassCPInfo ( ) { super ( CONSTANT_CLASS , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { index = cpStream . readUnsignedShort ( ) ; className = "unresolved" ; } public String toString ( ) { return "Class Constant Pool Entry for " + className + "[" + index + "]" ; } public void resolve ( ConstantPool constantPool ) { className = ( ( Utf8CPInfo ) constantPool . getEntry ( index ) ) . getValue ( ) ; super . resolve ( constantPool ) ; } public String getClassName ( ) { return className ; } } 	0	['5', '2', '0', '7', '14', '0', '6', '3', '5', '0.375', '51', '1', '0', '0.6', '0.466666667', '1', '1', '8.8', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . oro . text . regex . MatchResult ; import org . apache . oro . text . regex . Pattern ; import org . apache . oro . text . regex . Perl5Compiler ; import org . apache . oro . text . regex . Perl5Matcher ; import org . apache . tools . ant . BuildException ; public class JakartaOroMatcher implements RegexpMatcher { private String pattern ; protected final Perl5Compiler compiler = new Perl5Compiler ( ) ; protected final Perl5Matcher matcher = new Perl5Matcher ( ) ; public JakartaOroMatcher ( ) { } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return this . pattern ; } protected Pattern getCompiledPattern ( int options ) throws BuildException { try { Pattern p = compiler . compile ( pattern , getCompilerOptions ( options ) ) ; return p ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { Pattern p = getCompiledPattern ( options ) ; return matcher . contains ( input , p ) ; } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { if ( ! matches ( input , options ) ) { return null ; } Vector v = new Vector ( ) ; MatchResult mr = matcher . getMatch ( ) ; int cnt = mr . groups ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String match = mr . group ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = Perl5Compiler . DEFAULT_MASK ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= Perl5Compiler . CASE_INSENSITIVE_MASK ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= Perl5Compiler . MULTILINE_MASK ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= Perl5Compiler . SINGLELINE_MASK ; } return cOptions ; } } 	0	['9', '1', '1', '8', '21', '22', '1', '7', '7', '0.541666667', '135', '1', '0', '0', '0.666666667', '0', '0', '13.66666667', '4', '1.2222', '0']
package org . apache . tools . ant . types . spi ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . BuildException ; public class Provider extends ProjectComponent { private String type ; public String getClassName ( ) { return type ; } public void setClassName ( String type ) { this . type = type ; } public void check ( ) { if ( type == null ) { throw new BuildException ( "classname attribute must be set for provider element" , getLocation ( ) ) ; } if ( type . length ( ) == 0 ) { throw new BuildException ( "Invalid empty classname" , getLocation ( ) ) ; } } } 	0	['4', '2', '0', '4', '8', '0', '1', '3', '4', '0.333333333', '37', '1', '0', '0.75', '0.625', '0', '0', '8', '3', '1.25', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Have extends P4Base { public void execute ( ) throws BuildException { execP4Command ( "have " + P4CmdOpts + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['2', '4', '0', '4', '8', '1', '0', '4', '2', '2', '25', '0', '0', '0.980769231', '1', '1', '1', '11.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . MatchingTask ; import org . apache . tools . ant . taskdefs . optional . native2ascii . Native2AsciiAdapter ; import org . apache . tools . ant . taskdefs . optional . native2ascii . Native2AsciiAdapterFactory ; import org . apache . tools . ant . types . Mapper ; import org . apache . tools . ant . util . FileNameMapper ; import org . apache . tools . ant . util . IdentityMapper ; import org . apache . tools . ant . util . SourceFileScanner ; import org . apache . tools . ant . util . facade . FacadeTaskHelper ; import org . apache . tools . ant . util . facade . ImplementationSpecificArgument ; public class Native2Ascii extends MatchingTask { private boolean reverse = false ; private String encoding = null ; private File srcDir = null ; private File destDir = null ; private String extension = null ; private Mapper mapper ; private FacadeTaskHelper facade = null ; public Native2Ascii ( ) { facade = new FacadeTaskHelper ( Native2AsciiAdapterFactory . getDefault ( ) ) ; } public void setReverse ( boolean reverse ) { this . reverse = reverse ; } public boolean getReverse ( ) { return reverse ; } public void setEncoding ( String encoding ) { this . encoding = encoding ; } public String getEncoding ( ) { return encoding ; } public void setSrc ( File srcDir ) { this . srcDir = srcDir ; } public void setDest ( File destDir ) { this . destDir = destDir ; } public void setExt ( String ext ) { this . extension = ext ; } public void setImplementation ( String impl ) { if ( "default" . equals ( impl ) ) { facade . setImplementation ( Native2AsciiAdapterFactory . getDefault ( ) ) ; } else { facade . setImplementation ( impl ) ; } } public Mapper createMapper ( ) throws BuildException { if ( mapper != null ) { throw new BuildException ( "Cannot define more than one mapper" , getLocation ( ) ) ; } mapper = new Mapper ( getProject ( ) ) ; return mapper ; } public void add ( FileNameMapper fileNameMapper ) { createMapper ( ) . add ( fileNameMapper ) ; } public ImplementationSpecificArgument createArg ( ) { ImplementationSpecificArgument arg = new ImplementationSpecificArgument ( ) ; facade . addImplementationArgument ( arg ) ; return arg ; } public void execute ( ) throws BuildException { DirectoryScanner scanner = null ; String [ ] files ; if ( srcDir == null ) { srcDir = getProject ( ) . resolveFile ( "." ) ; } if ( destDir == null ) { throw new BuildException ( "The dest attribute must be set." ) ; } if ( srcDir . equals ( destDir ) && extension == null && mapper == null ) { throw new BuildException ( "The ext attribute or a mapper must be set if" + " src and dest dirs are the same." ) ; } FileNameMapper m = null ; if ( mapper == null ) { if ( extension == null ) { m = new IdentityMapper ( ) ; } else { m = new ExtMapper ( ) ; } } else { m = mapper . getImplementation ( ) ; } scanner = getDirectoryScanner ( srcDir ) ; files = scanner . getIncludedFiles ( ) ; SourceFileScanner sfs = new SourceFileScanner ( this ) ; files = sfs . restrict ( files , srcDir , destDir , m ) ; int count = files . length ; if ( count == 0 ) { return ; } String message = "Converting " + count + " file" + ( count != 1 ? "s" : "" ) + " from " ; log ( message + srcDir + " to " + destDir ) ; for ( int i = 0 ; i < files . length ; i ++ ) { convert ( files [ i ] , m . mapFileName ( files [ i ] ) [ 0 ] ) ; } } private void convert ( String srcName , String destName ) throws BuildException { File srcFile ; File destFile ; srcFile = new File ( srcDir , srcName ) ; destFile = new File ( destDir , destName ) ; if ( srcFile . equals ( destFile ) ) { throw new BuildException ( "file " + srcFile + " would overwrite its self" ) ; } String parentName = destFile . getParent ( ) ; if ( parentName != null ) { File parentFile = new File ( parentName ) ; if ( ( ! parentFile . exists ( ) ) && ( ! parentFile . mkdirs ( ) ) ) { throw new BuildException ( "cannot create parent directory " + parentName ) ; } } log ( "converting " + srcName , Project . MSG_VERBOSE ) ; Native2AsciiAdapter ad = Native2AsciiAdapterFactory . getAdapter ( facade . getImplementation ( ) , this ) ; if ( ! ad . convert ( this , srcFile , destFile ) ) { throw new BuildException ( "conversion failed" ) ; } } public String [ ] getCurrentArgs ( ) { return facade . getArgs ( ) ; } private class ExtMapper implements FileNameMapper { public void setFrom ( String s ) { } public void setTo ( String s ) { } public String [ ] mapFileName ( String fileName ) { int lastDot = fileName . lastIndexOf ( '.' ) ; if ( lastDot >= 0 ) { return new String [ ] { fileName . substring ( 0 , lastDot ) + extension } ; } else { return new String [ ] { fileName + extension } ; } } } } 	0	['16', '4', '0', '19', '56', '60', '5', '16', '14', '0.80952381', '362', '1', '2', '0.838709677', '0.25', '3', '3', '21.1875', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . j2ee ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Path ; public abstract class AbstractHotDeploymentTool implements HotDeploymentTool { private ServerDeploy task ; private Path classpath ; private String userName ; private String password ; private String server ; public Path createClasspath ( ) { if ( classpath == null ) { classpath = new Path ( task . getProject ( ) ) ; } return classpath . createPath ( ) ; } protected abstract boolean isActionValid ( ) ; public void validateAttributes ( ) throws BuildException { if ( task . getAction ( ) == null ) { throw new BuildException ( "The \"action\" attribute must be set" ) ; } if ( ! isActionValid ( ) ) { throw new BuildException ( "Invalid action \"" + task . getAction ( ) + "\" passed" ) ; } if ( classpath == null ) { throw new BuildException ( "The classpath attribute must be set" ) ; } } public abstract void deploy ( ) throws BuildException ; public void setTask ( ServerDeploy task ) { this . task = task ; } protected ServerDeploy getTask ( ) { return task ; } public Path getClasspath ( ) { return classpath ; } public void setClasspath ( Path classpath ) { this . classpath = classpath ; } public String getUserName ( ) { return userName ; } public void setUserName ( String userName ) { this . userName = userName ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServer ( ) { return server ; } public void setServer ( String server ) { this . server = server ; } } 	0	['15', '1', '2', '7', '24', '77', '2', '5', '13', '0.871428571', '109', '1', '2', '0', '0.333333333', '0', '0', '5.933333333', '2', '1', '0']
package org . apache . tools . ant ; import java . io . Serializable ; import org . apache . tools . ant . util . FileUtils ; import org . xml . sax . Locator ; public class Location implements Serializable { private String fileName ; private int lineNumber ; private int columnNumber ; public static final Location UNKNOWN_LOCATION = new Location ( ) ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private Location ( ) { this ( null , 0 , 0 ) ; } public Location ( String fileName ) { this ( fileName , 0 , 0 ) ; } public Location ( Locator loc ) { this ( loc . getSystemId ( ) , loc . getLineNumber ( ) , loc . getColumnNumber ( ) ) ; } public Location ( String fileName , int lineNumber , int columnNumber ) { if ( fileName != null && fileName . startsWith ( "file:" ) ) { this . fileName = FILE_UTILS . fromURI ( fileName ) ; } else { this . fileName = fileName ; } this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; } public String getFileName ( ) { return fileName ; } public int getLineNumber ( ) { return lineNumber ; } public int getColumnNumber ( ) { return columnNumber ; } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fileName != null ) { buf . append ( fileName ) ; if ( lineNumber != 0 ) { buf . append ( ":" ) ; buf . append ( lineNumber ) ; } buf . append ( ": " ) ; } return buf . toString ( ) ; } public boolean equals ( Object other ) { if ( this == other ) { return true ; } if ( other == null ) { return false ; } if ( ! ( other . getClass ( ) == getClass ( ) ) ) { return false ; } return toString ( ) . equals ( other . toString ( ) ) ; } public int hashCode ( ) { return toString ( ) . hashCode ( ) ; } } 	0	['11', '1', '0', '150', '26', '41', '149', '1', '9', '0.56', '134', '0.8', '2', '0', '0.3', '1', '1', '10.72727273', '4', '1', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class ZipFileSet extends ArchiveFileSet { private String encoding = null ; public ZipFileSet ( ) { super ( ) ; } protected ZipFileSet ( FileSet fileset ) { super ( fileset ) ; } protected ZipFileSet ( ZipFileSet fileset ) { super ( fileset ) ; encoding = fileset . encoding ; } public void setEncoding ( String enc ) { checkZipFileSetAttributesAllowed ( ) ; this . encoding = enc ; } public String getEncoding ( ) { if ( isReference ( ) ) { AbstractFileSet ref = getRef ( getProject ( ) ) ; if ( ref instanceof ZipFileSet ) { return ( ( ZipFileSet ) ref ) . getEncoding ( ) ; } else { return null ; } } return encoding ; } protected ArchiveScanner newArchiveScanner ( ) { ZipScanner zs = new ZipScanner ( ) ; zs . setEncoding ( encoding ) ; return zs ; } protected AbstractFileSet getRef ( Project p ) { dieOnCircularReference ( p ) ; Object o = getRefid ( ) . getReferencedObject ( p ) ; if ( o instanceof ZipFileSet ) { return ( AbstractFileSet ) o ; } else if ( o instanceof FileSet ) { ZipFileSet zfs = new ZipFileSet ( ( FileSet ) o ) ; configureFileSet ( zfs ) ; return zfs ; } else { String msg = getRefid ( ) . getRefId ( ) + " doesn\'t denote a zipfileset or a fileset" ; throw new BuildException ( msg ) ; } } public Object clone ( ) { if ( isReference ( ) ) { return ( ( ZipFileSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } private void checkZipFileSetAttributesAllowed ( ) { if ( getProject ( ) == null || ( isReference ( ) && ( getRefid ( ) . getReferencedObject ( getProject ( ) ) instanceof ZipFileSet ) ) ) { checkAttributesAllowed ( ) ; } } } 	0	['9', '6', '0', '12', '28', '6', '4', '8', '4', '0.125', '143', '1', '0', '0.953125', '0.288888889', '5', '18', '14.77777778', '4', '1.5556', '0']
package org . apache . tools . ant . taskdefs ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; public class GUnzip extends Unpack { private static final String DEFAULT_EXTENSION = ".gz" ; protected String getDefaultExtension ( ) { return DEFAULT_EXTENSION ; } protected void extract ( ) { if ( source . lastModified ( ) > dest . lastModified ( ) ) { log ( "Expanding " + source . getAbsolutePath ( ) + " to " + dest . getAbsolutePath ( ) ) ; FileOutputStream out = null ; GZIPInputStream zIn = null ; InputStream fis = null ; try { out = new FileOutputStream ( dest ) ; fis = srcResource . getInputStream ( ) ; zIn = new GZIPInputStream ( fis ) ; byte [ ] buffer = new byte [ 8 * 1024 ] ; int count = 0 ; do { out . write ( buffer , 0 , count ) ; count = zIn . read ( buffer , 0 , buffer . length ) ; } while ( count != - 1 ) ; } catch ( IOException ioe ) { String msg = "Problem expanding gzip " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( fis ) ; FileUtils . close ( out ) ; FileUtils . close ( zIn ) ; } } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( GUnzip . class ) ; } } 	0	['4', '4', '0', '5', '26', '6', '0', '5', '1', '1.166666667', '129', '0.5', '0', '0.942307692', '1', '3', '5', '30.75', '5', '2', '0']
package org . apache . tools . ant . util ; import java . io . IOException ; import java . io . PipedInputStream ; import java . io . PipedOutputStream ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . Project ; public class LeadPipeInputStream extends PipedInputStream { private ProjectComponent managingPc ; public LeadPipeInputStream ( ) { super ( ) ; } public LeadPipeInputStream ( int size ) { super ( ) ; setBufferSize ( size ) ; } public LeadPipeInputStream ( PipedOutputStream src ) throws IOException { super ( src ) ; } public LeadPipeInputStream ( PipedOutputStream src , int size ) throws IOException { super ( src ) ; setBufferSize ( size ) ; } public synchronized int read ( ) throws IOException { int result = - 1 ; try { result = super . read ( ) ; } catch ( IOException eyeOhEx ) { if ( "write end dead" . equalsIgnoreCase ( eyeOhEx . getMessage ( ) ) ) { if ( super . in > 0 && super . out < super . buffer . length && super . out > super . in ) { result = super . buffer [ super . out ++ ] & 0xFF ; } } else { log ( "error at LeadPipeInputStream.read():  " + eyeOhEx . getMessage ( ) , Project . MSG_INFO ) ; } } return result ; } public synchronized void setBufferSize ( int size ) { if ( size > buffer . length ) { byte [ ] newBuffer = new byte [ size ] ; if ( in >= 0 ) { if ( in > out ) { System . arraycopy ( buffer , out , newBuffer , out , in - out ) ; } else { int outlen = buffer . length - out ; System . arraycopy ( buffer , out , newBuffer , 0 , outlen ) ; System . arraycopy ( buffer , 0 , newBuffer , outlen , in ) ; in += outlen ; out = 0 ; } } buffer = newBuffer ; } } public void setManagingTask ( Task task ) { setManagingComponent ( task ) ; } public void setManagingComponent ( ProjectComponent pc ) { this . managingPc = pc ; } public void log ( String message , int loglevel ) { if ( managingPc != null ) { managingPc . log ( message , loglevel ) ; } else { if ( loglevel > Project . MSG_WARN ) { System . out . println ( message ) ; } else { System . err . println ( message ) ; } } } } 	0	['9', '3', '0', '3', '20', '34', '1', '2', '9', '0.625', '177', '1', '1', '0.761904762', '0.333333333', '1', '3', '18.55555556', '4', '1.1111', '0']
package org . apache . tools . ant . helper ; import java . io . File ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import org . xml . sax . Locator ; import org . xml . sax . Attributes ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Target ; import org . apache . tools . ant . Location ; import org . apache . tools . ant . RuntimeConfigurable ; public class AntXMLContext { private Project project ; private File buildFile ; private Vector targetVector = new Vector ( ) ; private File buildFileParent ; private String currentProjectName ; private Locator locator ; private Target implicitTarget = new Target ( ) ; private Target currentTarget = null ; private Vector wStack = new Vector ( ) ; private boolean ignoreProjectTag = false ; private Map prefixMapping = new HashMap ( ) ; private Map currentTargets = null ; public AntXMLContext ( Project project ) { this . project = project ; implicitTarget . setProject ( project ) ; implicitTarget . setName ( "" ) ; targetVector . addElement ( implicitTarget ) ; } public void setBuildFile ( File buildFile ) { this . buildFile = buildFile ; this . buildFileParent = new File ( buildFile . getParent ( ) ) ; implicitTarget . setLocation ( new Location ( buildFile . getAbsolutePath ( ) ) ) ; } public File getBuildFile ( ) { return buildFile ; } public File getBuildFileParent ( ) { return buildFileParent ; } public Project getProject ( ) { return project ; } public String getCurrentProjectName ( ) { return currentProjectName ; } public void setCurrentProjectName ( String name ) { this . currentProjectName = name ; } public RuntimeConfigurable currentWrapper ( ) { if ( wStack . size ( ) < 1 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 1 ) ; } public RuntimeConfigurable parentWrapper ( ) { if ( wStack . size ( ) < 2 ) { return null ; } return ( RuntimeConfigurable ) wStack . elementAt ( wStack . size ( ) - 2 ) ; } public void pushWrapper ( RuntimeConfigurable wrapper ) { wStack . addElement ( wrapper ) ; } public void popWrapper ( ) { if ( wStack . size ( ) > 0 ) { wStack . removeElementAt ( wStack . size ( ) - 1 ) ; } } public Vector getWrapperStack ( ) { return wStack ; } public void addTarget ( Target target ) { targetVector . addElement ( target ) ; currentTarget = target ; } public Target getCurrentTarget ( ) { return currentTarget ; } public Target getImplicitTarget ( ) { return implicitTarget ; } public void setCurrentTarget ( Target target ) { this . currentTarget = target ; } public void setImplicitTarget ( Target target ) { this . implicitTarget = target ; } public Vector getTargets ( ) { return targetVector ; } public void configureId ( Object element , Attributes attr ) { String id = attr . getValue ( "id" ) ; if ( id != null ) { project . addIdReference ( id , element ) ; } } public Locator getLocator ( ) { return locator ; } public void setLocator ( Locator locator ) { this . locator = locator ; } public boolean isIgnoringProjectTag ( ) { return ignoreProjectTag ; } public void setIgnoreProjectTag ( boolean flag ) { this . ignoreProjectTag = flag ; } public void startPrefixMapping ( String prefix , String uri ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null ) { list = new ArrayList ( ) ; prefixMapping . put ( prefix , list ) ; } list . add ( uri ) ; } public void endPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return ; } list . remove ( list . size ( ) - 1 ) ; } public String getPrefixMapping ( String prefix ) { List list = ( List ) prefixMapping . get ( prefix ) ; if ( list == null || list . size ( ) == 0 ) { return null ; } return ( String ) list . get ( list . size ( ) - 1 ) ; } public Map getCurrentTargets ( ) { return currentTargets ; } public void setCurrentTargets ( Map currentTargets ) { this . currentTargets = currentTargets ; } } 	0	['28', '1', '0', '11', '52', '282', '7', '4', '28', '0.919753086', '300', '1', '3', '0', '0.13961039', '0', '0', '9.285714286', '3', '1.2857', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . regexp . RE ; import org . apache . regexp . RESyntaxException ; import org . apache . tools . ant . BuildException ; public class JakartaRegexpMatcher implements RegexpMatcher { private String pattern ; public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getPattern ( ) { return pattern ; } protected RE getCompiledPattern ( int options ) throws BuildException { int cOptions = getCompilerOptions ( options ) ; try { RE reg = new RE ( pattern ) ; reg . setMatchFlags ( cOptions ) ; return reg ; } catch ( RESyntaxException e ) { throw new BuildException ( e ) ; } } public boolean matches ( String argument ) throws BuildException { return matches ( argument , MATCH_DEFAULT ) ; } public boolean matches ( String input , int options ) throws BuildException { return matches ( input , getCompiledPattern ( options ) ) ; } private boolean matches ( String input , RE reg ) { return reg . match ( input ) ; } public Vector getGroups ( String argument ) throws BuildException { return getGroups ( argument , MATCH_DEFAULT ) ; } public Vector getGroups ( String input , int options ) throws BuildException { RE reg = getCompiledPattern ( options ) ; if ( ! matches ( input , reg ) ) { return null ; } Vector v = new Vector ( ) ; int cnt = reg . getParenCount ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { String match = reg . getParen ( i ) ; if ( match == null ) { match = "" ; } v . addElement ( match ) ; } return v ; } protected int getCompilerOptions ( int options ) { int cOptions = RE . MATCH_NORMAL ; if ( RegexpUtil . hasFlag ( options , MATCH_CASE_INSENSITIVE ) ) { cOptions |= RE . MATCH_CASEINDEPENDENT ; } if ( RegexpUtil . hasFlag ( options , MATCH_MULTILINE ) ) { cOptions |= RE . MATCH_MULTILINE ; } if ( RegexpUtil . hasFlag ( options , MATCH_SINGLELINE ) ) { cOptions |= RE . MATCH_SINGLELINE ; } return cOptions ; } } 	0	['10', '1', '1', '6', '20', '39', '1', '5', '7', '0.555555556', '129', '1', '0', '0', '0.525', '0', '0', '11.8', '4', '1.2', '0']
package org . apache . tools . ant . util . regexp ; import java . util . Vector ; import org . apache . regexp . RE ; import org . apache . tools . ant . BuildException ; public class JakartaRegexpRegexp extends JakartaRegexpMatcher implements Regexp { public JakartaRegexpRegexp ( ) { super ( ) ; } protected int getSubsOptions ( int options ) { int subsOptions = RE . REPLACE_FIRSTONLY ; if ( RegexpUtil . hasFlag ( options , REPLACE_ALL ) ) { subsOptions = RE . REPLACE_ALL ; } return subsOptions ; } public String substitute ( String input , String argument , int options ) throws BuildException { Vector v = getGroups ( input , options ) ; StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < argument . length ( ) ; i ++ ) { char c = argument . charAt ( i ) ; if ( c == '\\' ) { if ( ++ i < argument . length ( ) ) { c = argument . charAt ( i ) ; int value = Character . digit ( c , 10 ) ; if ( value > - 1 ) { result . append ( ( String ) v . elementAt ( value ) ) ; } else { result . append ( c ) ; } } else { result . append ( '\\' ) ; } } else { result . append ( c ) ; } } argument = result . toString ( ) ; RE reg = getCompiledPattern ( options ) ; int sOptions = getSubsOptions ( options ) ; return reg . subst ( input , argument , sOptions ) ; } } 	0	['3', '2', '0', '5', '16', '3', '0', '5', '2', '2', '95', '0', '0', '0.818181818', '0.666666667', '0', '0', '30.66666667', '2', '1', '0']
package org . apache . tools . ant . taskdefs . optional . pvcs ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . text . MessageFormat ; import java . text . ParseException ; import java . util . Enumeration ; import java . util . Random ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Execute ; import org . apache . tools . ant . taskdefs . ExecuteStreamHandler ; import org . apache . tools . ant . taskdefs . LogOutputStream ; import org . apache . tools . ant . taskdefs . LogStreamHandler ; import org . apache . tools . ant . taskdefs . PumpStreamHandler ; import org . apache . tools . ant . types . Commandline ; public class Pvcs extends org . apache . tools . ant . Task { private static final int POS_1 = 1 ; private static final int POS_2 = 2 ; private static final int POS_3 = 3 ; private String pvcsbin ; private String repository ; private String pvcsProject ; private Vector pvcsProjects ; private String workspace ; private String force ; private String promotiongroup ; private String label ; private String revision ; private boolean ignorerc ; private boolean updateOnly ; private String filenameFormat ; private String lineStart ; private String userId ; private String config ; private static final String PCLI_EXE = "pcli" ; private static final String GET_EXE = "get" ; protected int runCmd ( Commandline cmd , ExecuteStreamHandler out ) { try { Project aProj = getProject ( ) ; Execute exe = new Execute ( out ) ; exe . setAntRun ( aProj ) ; exe . setWorkingDirectory ( aProj . getBaseDir ( ) ) ; exe . setCommandline ( cmd . getCommandline ( ) ) ; return exe . execute ( ) ; } catch ( java . io . IOException e ) { String msg = "Failed executing: " + cmd . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } } private String getExecutable ( String exe ) { StringBuffer correctedExe = new StringBuffer ( ) ; if ( getPvcsbin ( ) != null ) { if ( pvcsbin . endsWith ( File . separator ) ) { correctedExe . append ( pvcsbin ) ; } else { correctedExe . append ( pvcsbin ) . append ( File . separator ) ; } } return correctedExe . append ( exe ) . toString ( ) ; } public void execute ( ) throws org . apache . tools . ant . BuildException { int result = 0 ; if ( repository == null || repository . trim ( ) . equals ( "" ) ) { throw new BuildException ( "Required argument repository not specified" ) ; } Commandline commandLine = new Commandline ( ) ; commandLine . setExecutable ( getExecutable ( PCLI_EXE ) ) ; commandLine . createArgument ( ) . setValue ( "lvf" ) ; commandLine . createArgument ( ) . setValue ( "-z" ) ; commandLine . createArgument ( ) . setValue ( "-aw" ) ; if ( getWorkspace ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-sp" + getWorkspace ( ) ) ; } commandLine . createArgument ( ) . setValue ( "-pr" + getRepository ( ) ) ; String uid = getUserId ( ) ; if ( uid != null ) { commandLine . createArgument ( ) . setValue ( "-id" + uid ) ; } if ( getPvcsproject ( ) == null && getPvcsprojects ( ) . isEmpty ( ) ) { pvcsProject = "/" ; } if ( getPvcsproject ( ) != null ) { commandLine . createArgument ( ) . setValue ( getPvcsproject ( ) ) ; } if ( ! getPvcsprojects ( ) . isEmpty ( ) ) { Enumeration e = getPvcsprojects ( ) . elements ( ) ; while ( e . hasMoreElements ( ) ) { String projectName = ( ( PvcsProject ) e . nextElement ( ) ) . getName ( ) ; if ( projectName == null || ( projectName . trim ( ) ) . equals ( "" ) ) { throw new BuildException ( "name is a required attribute " + "of pvcsproject" ) ; } commandLine . createArgument ( ) . setValue ( projectName ) ; } } File tmp = null ; File tmp2 = null ; try { Random rand = new Random ( System . currentTimeMillis ( ) ) ; tmp = new File ( "pvcs_ant_" + rand . nextLong ( ) + ".log" ) ; FileOutputStream fos = new FileOutputStream ( tmp ) ; tmp2 = new File ( "pvcs_ant_" + rand . nextLong ( ) + ".log" ) ; log ( commandLine . describeCommand ( ) , Project . MSG_VERBOSE ) ; try { result = runCmd ( commandLine , new PumpStreamHandler ( fos , new LogOutputStream ( this , Project . MSG_WARN ) ) ) ; } finally { fos . close ( ) ; } if ( Execute . isFailure ( result ) && ! ignorerc ) { String msg = "Failed executing: " + commandLine . toString ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } if ( ! tmp . exists ( ) ) { throw new BuildException ( "Communication between ant and pvcs " + "failed. No output generated from executing PVCS " + "commandline interface \"pcli\" and \"get\"" ) ; } log ( "Creating folders" , Project . MSG_INFO ) ; createFolders ( tmp ) ; massagePCLI ( tmp , tmp2 ) ; commandLine . clearArgs ( ) ; commandLine . setExecutable ( getExecutable ( GET_EXE ) ) ; if ( getConfig ( ) != null && getConfig ( ) . length ( ) > 0 ) { commandLine . createArgument ( ) . setValue ( "-c" + getConfig ( ) ) ; } if ( getForce ( ) != null && getForce ( ) . equals ( "yes" ) ) { commandLine . createArgument ( ) . setValue ( "-Y" ) ; } else { commandLine . createArgument ( ) . setValue ( "-N" ) ; } if ( getPromotiongroup ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-G" + getPromotiongroup ( ) ) ; } else { if ( getLabel ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-v" + getLabel ( ) ) ; } else { if ( getRevision ( ) != null ) { commandLine . createArgument ( ) . setValue ( "-r" + getRevision ( ) ) ; } } } if ( updateOnly ) { commandLine . createArgument ( ) . setValue ( "-U" ) ; } commandLine . createArgument ( ) . setValue ( "@" + tmp2 . getAbsolutePath ( ) ) ; log ( "Getting files" , Project . MSG_INFO ) ; log ( "Executing " + commandLine . toString ( ) , Project . MSG_VERBOSE ) ; result = runCmd ( commandLine , new LogStreamHandler ( this , Project . MSG_INFO , Project . MSG_WARN ) ) ; if ( result != 0 && ! ignorerc ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Return code was " + result ; throw new BuildException ( msg , getLocation ( ) ) ; } } catch ( FileNotFoundException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } catch ( IOException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } catch ( ParseException e ) { String msg = "Failed executing: " + commandLine . toString ( ) + ". Exception: " + e . getMessage ( ) ; throw new BuildException ( msg , getLocation ( ) ) ; } finally { if ( tmp != null ) { tmp . delete ( ) ; } if ( tmp2 != null ) { tmp2 . delete ( ) ; } } } private void createFolders ( File file ) throws IOException , ParseException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; MessageFormat mf = new MessageFormat ( getFilenameFormat ( ) ) ; String line = in . readLine ( ) ; while ( line != null ) { log ( "Considering \"" + line + "\"" , Project . MSG_VERBOSE ) ; if ( line . startsWith ( "\"\\" ) || line . startsWith ( "\"/" ) || ( line . length ( ) > POS_3 && line . startsWith ( "\"" ) && Character . isLetter ( line . charAt ( POS_1 ) ) && String . valueOf ( line . charAt ( POS_2 ) ) . equals ( ":" ) && String . valueOf ( line . charAt ( POS_3 ) ) . equals ( "\\" ) ) ) { Object [ ] objs = mf . parse ( line ) ; String f = ( String ) objs [ 1 ] ; int index = f . lastIndexOf ( File . separator ) ; if ( index > - 1 ) { File dir = new File ( f . substring ( 0 , index ) ) ; if ( ! dir . exists ( ) ) { log ( "Creating " + dir . getAbsolutePath ( ) , Project . MSG_VERBOSE ) ; if ( dir . mkdirs ( ) ) { log ( "Created " + dir . getAbsolutePath ( ) , Project . MSG_INFO ) ; } else { log ( "Failed to create " + dir . getAbsolutePath ( ) , Project . MSG_INFO ) ; } } else { log ( dir . getAbsolutePath ( ) + " exists. Skipping" , Project . MSG_VERBOSE ) ; } } else { log ( "File separator problem with " + line , Project . MSG_WARN ) ; } } else { log ( "Skipped \"" + line + "\"" , Project . MSG_VERBOSE ) ; } line = in . readLine ( ) ; } } finally { if ( in != null ) { in . close ( ) ; } } } private void massagePCLI ( File in , File out ) throws IOException { BufferedReader inReader = null ; BufferedWriter outWriter = null ; try { inReader = new BufferedReader ( new FileReader ( in ) ) ; outWriter = new BufferedWriter ( new FileWriter ( out ) ) ; String s = null ; while ( ( s = inReader . readLine ( ) ) != null ) { String sNormal = s . replace ( '\\' , '/' ) ; outWriter . write ( sNormal ) ; outWriter . newLine ( ) ; } } finally { if ( inReader != null ) { inReader . close ( ) ; } if ( outWriter != null ) { outWriter . close ( ) ; } } } public String getRepository ( ) { return repository ; } public String getFilenameFormat ( ) { return filenameFormat ; } public void setFilenameFormat ( String f ) { filenameFormat = f ; } public String getLineStart ( ) { return lineStart ; } public void setLineStart ( String l ) { lineStart = l ; } public void setRepository ( String repo ) { repository = repo ; } public String getPvcsproject ( ) { return pvcsProject ; } public void setPvcsproject ( String prj ) { pvcsProject = prj ; } public Vector getPvcsprojects ( ) { return pvcsProjects ; } public String getWorkspace ( ) { return workspace ; } public void setWorkspace ( String ws ) { workspace = ws ; } public String getPvcsbin ( ) { return pvcsbin ; } public void setPvcsbin ( String bin ) { pvcsbin = bin ; } public String getForce ( ) { return force ; } public void setForce ( String f ) { if ( f != null && f . equalsIgnoreCase ( "yes" ) ) { force = "yes" ; } else { force = "no" ; } } public String getPromotiongroup ( ) { return promotiongroup ; } public void setPromotiongroup ( String w ) { promotiongroup = w ; } public String getLabel ( ) { return label ; } public void setLabel ( String l ) { label = l ; } public String getRevision ( ) { return revision ; } public void setRevision ( String r ) { revision = r ; } public boolean getIgnoreReturnCode ( ) { return ignorerc ; } public void setIgnoreReturnCode ( boolean b ) { ignorerc = b ; } public void addPvcsproject ( PvcsProject p ) { pvcsProjects . addElement ( p ) ; } public boolean getUpdateOnly ( ) { return updateOnly ; } public void setUpdateOnly ( boolean l ) { updateOnly = l ; } public String getConfig ( ) { return config ; } public void setConfig ( File f ) { config = f . toString ( ) ; } public String getUserId ( ) { return userId ; } public void setUserId ( String u ) { userId = u ; } public Pvcs ( ) { super ( ) ; pvcsProject = null ; pvcsProjects = new Vector ( ) ; workspace = null ; repository = null ; pvcsbin = null ; force = null ; promotiongroup = null ; label = null ; ignorerc = false ; updateOnly = false ; lineStart = "\"P:" ; filenameFormat = "{0}-arc({1})" ; } } 	0	['36', '3', '0', '12', '111', '528', '0', '12', '32', '0.947142857', '1006', '1', '0', '0.513888889', '0.222222222', '2', '2', '26.38888889', '3', '1.0833', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import java . util . Enumeration ; public class NoneSelector extends BaseSelectorContainer { public NoneSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( hasSelectors ( ) ) { buf . append ( "{noneselect: " ) ; buf . append ( super . toString ( ) ) ; buf . append ( "}" ) ; } return buf . toString ( ) ; } public boolean isSelected ( File basedir , String filename , File file ) { validate ( ) ; Enumeration e = selectorElements ( ) ; boolean result ; while ( e . hasMoreElements ( ) ) { result = ( ( FileSelector ) e . nextElement ( ) ) . isSelected ( basedir , filename , file ) ; if ( result ) { return false ; } } return true ; } } 	0	['3', '5', '1', '9', '14', '3', '8', '2', '3', '2', '52', '0', '0', '0.96875', '0.555555556', '1', '1', '16.33333333', '3', '1.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; public interface FileSelector { boolean isSelected ( File basedir , String filename , File file ) throws BuildException ; } 	0	['1', '1', '0', '22', '1', '0', '21', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs . condition ; import java . util . Enumeration ; import org . apache . tools . ant . BuildException ; public class Or extends ConditionBase implements Condition { public boolean eval ( ) throws BuildException { Enumeration e = getConditions ( ) ; while ( e . hasMoreElements ( ) ) { Condition c = ( Condition ) e . nextElement ( ) ; if ( c . eval ( ) ) { return true ; } } return false ; } } 	0	['2', '3', '0', '3', '7', '1', '1', '3', '2', '2', '23', '0', '0', '0.96969697', '1', '0', '0', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . types . selectors ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Parameter ; import org . apache . tools . ant . types . RegularExpression ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . FileResource ; import org . apache . tools . ant . types . resources . selectors . ResourceSelector ; import org . apache . tools . ant . util . regexp . Regexp ; public class ContainsRegexpSelector extends BaseExtendSelector implements ResourceSelector { private String userProvidedExpression = null ; private RegularExpression myRegExp = null ; private Regexp myExpression = null ; public static final String EXPRESSION_KEY = "expression" ; public ContainsRegexpSelector ( ) { } public String toString ( ) { StringBuffer buf = new StringBuffer ( "{containsregexpselector expression: " ) ; buf . append ( userProvidedExpression ) ; buf . append ( "}" ) ; return buf . toString ( ) ; } public void setExpression ( String theexpression ) { this . userProvidedExpression = theexpression ; } public void setParameters ( Parameter [ ] parameters ) { super . setParameters ( parameters ) ; if ( parameters != null ) { for ( int i = 0 ; i < parameters . length ; i ++ ) { String paramname = parameters [ i ] . getName ( ) ; if ( EXPRESSION_KEY . equalsIgnoreCase ( paramname ) ) { setExpression ( parameters [ i ] . getValue ( ) ) ; } else { setError ( "Invalid parameter " + paramname ) ; } } } } public void verifySettings ( ) { if ( userProvidedExpression == null ) { setError ( "The expression attribute is required" ) ; } } public boolean isSelected ( File basedir , String filename , File file ) { return isSelected ( new FileResource ( file ) ) ; } public boolean isSelected ( Resource r ) { String teststr = null ; BufferedReader in = null ; validate ( ) ; if ( r . isDirectory ( ) ) { return true ; } if ( myRegExp == null ) { myRegExp = new RegularExpression ( ) ; myRegExp . setPattern ( userProvidedExpression ) ; myExpression = myRegExp . getRegexp ( getProject ( ) ) ; } try { in = new BufferedReader ( new InputStreamReader ( r . getInputStream ( ) ) ) ; } catch ( Exception e ) { throw new BuildException ( "Could not get InputStream from " + r . toLongString ( ) , e ) ; } try { teststr = in . readLine ( ) ; while ( teststr != null ) { if ( myExpression . matches ( teststr ) ) { return true ; } teststr = in . readLine ( ) ; } return false ; } catch ( IOException ioe ) { throw new BuildException ( "Could not read " + r . toLongString ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( Exception e ) { throw new BuildException ( "Could not close " + r . toLongString ( ) ) ; } } } } } 	0	['7', '5', '0', '15', '32', '1', '6', '9', '7', '0.625', '209', '0.75', '2', '0.863636364', '0.342857143', '1', '4', '28.28571429', '9', '2.5714', '0']
package org . apache . tools . ant . types . resources ; import java . io . InputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . tools . bzip2 . CBZip2InputStream ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2Resource extends CompressedResource { private static final char [ ] MAGIC = new char [ ] { 'B' , 'Z' } ; public BZip2Resource ( ) { } public BZip2Resource ( org . apache . tools . ant . types . ResourceCollection other ) { super ( other ) ; } protected InputStream wrapStream ( InputStream in ) throws IOException { for ( int i = 0 ; i < MAGIC . length ; i ++ ) { if ( in . read ( ) != MAGIC [ i ] ) { throw new IOException ( "Invalid bz2 stream." ) ; } } return new CBZip2InputStream ( in ) ; } protected OutputStream wrapStream ( OutputStream out ) throws IOException { for ( int i = 0 ; i < MAGIC . length ; i ++ ) { out . write ( MAGIC [ i ] ) ; } return new CBZip2OutputStream ( out ) ; } protected String getCompressionName ( ) { return "Bzip2" ; } } 	0	['6', '5', '0', '4', '13', '9', '0', '4', '2', '0.6', '70', '1', '0', '0.961538462', '0.4', '1', '2', '10.5', '1', '0.5', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . ChannelSftp ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . SftpException ; import com . jcraft . jsch . SftpProgressMonitor ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Iterator ; public class ScpToMessageBySftp extends ScpToMessage { private File localFile ; private String remotePath ; private List directoryList ; public ScpToMessageBySftp ( boolean verbose , Session session , File aLocalFile , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . localFile = aLocalFile ; } public ScpToMessageBySftp ( boolean verbose , Session session , List aDirectoryList , String aRemotePath ) { this ( verbose , session , aRemotePath ) ; this . directoryList = aDirectoryList ; } private ScpToMessageBySftp ( boolean verbose , Session session , String aRemotePath ) { super ( verbose , session ) ; this . remotePath = aRemotePath ; } public ScpToMessageBySftp ( Session session , File aLocalFile , String aRemotePath ) { this ( false , session , aLocalFile , aRemotePath ) ; } public ScpToMessageBySftp ( Session session , List aDirectoryList , String aRemotePath ) { this ( false , session , aDirectoryList , aRemotePath ) ; } public void execute ( ) throws IOException , JSchException { if ( directoryList != null ) { doMultipleTransfer ( ) ; } if ( localFile != null ) { doSingleTransfer ( ) ; } log ( "done.\n" ) ; } private void doSingleTransfer ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { sendFileToRemote ( channel , localFile , remotePath ) ; } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void doMultipleTransfer ( ) throws IOException , JSchException { ChannelSftp channel = openSftpChannel ( ) ; try { channel . connect ( ) ; try { channel . cd ( remotePath ) ; for ( Iterator i = directoryList . iterator ( ) ; i . hasNext ( ) ; ) { Directory current = ( Directory ) i . next ( ) ; sendDirectory ( channel , current ) ; } } catch ( SftpException e ) { throw new JSchException ( e . toString ( ) ) ; } } finally { if ( channel != null ) { channel . disconnect ( ) ; } } } private void sendDirectory ( ChannelSftp channel , Directory current ) throws IOException , SftpException { for ( Iterator fileIt = current . filesIterator ( ) ; fileIt . hasNext ( ) ; ) { sendFileToRemote ( channel , ( File ) fileIt . next ( ) , null ) ; } for ( Iterator dirIt = current . directoryIterator ( ) ; dirIt . hasNext ( ) ; ) { Directory dir = ( Directory ) dirIt . next ( ) ; sendDirectoryToRemote ( channel , dir ) ; } } private void sendDirectoryToRemote ( ChannelSftp channel , Directory directory ) throws IOException , SftpException { String dir = directory . getDirectory ( ) . getName ( ) ; try { channel . stat ( dir ) ; } catch ( SftpException e ) { if ( e . id == ChannelSftp . SSH_FX_NO_SUCH_FILE ) { channel . mkdir ( dir ) ; } } channel . cd ( dir ) ; sendDirectory ( channel , directory ) ; channel . cd ( ".." ) ; } private void sendFileToRemote ( ChannelSftp channel , File localFile , String remotePath ) throws IOException , SftpException { long filesize = localFile . length ( ) ; if ( remotePath == null ) { remotePath = localFile . getName ( ) ; } long startTime = System . currentTimeMillis ( ) ; long totalLength = filesize ; boolean trackProgress = getVerbose ( ) && filesize > 102400 ; SftpProgressMonitor monitor = null ; if ( trackProgress ) { monitor = getProgressMonitor ( ) ; } try { if ( this . getVerbose ( ) ) { log ( "Sending: " + localFile . getName ( ) + " : " + filesize ) ; } channel . put ( localFile . getAbsolutePath ( ) , remotePath , monitor ) ; } finally { if ( this . getVerbose ( ) ) { long endTime = System . currentTimeMillis ( ) ; logStats ( startTime , endTime , ( int ) totalLength ) ; } } } public File getLocalFile ( ) { return localFile ; } public String getRemotePath ( ) { return remotePath ; } } 	0	['13', '3', '0', '9', '41', '48', '1', '8', '7', '0.583333333', '285', '1', '0', '0.703703704', '0.355769231', '2', '3', '20.69230769', '1', '0.6154', '0']
package org . apache . tools . ant . types ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; public class Assertions extends DataType implements Cloneable { private Boolean enableSystemAssertions ; private ArrayList assertionList = new ArrayList ( ) ; public void addEnable ( EnabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void addDisable ( DisabledAssertion assertion ) { checkChildrenAllowed ( ) ; assertionList . add ( assertion ) ; } public void setEnableSystemAssertions ( Boolean enableSystemAssertions ) { checkAttributesAllowed ( ) ; this . enableSystemAssertions = enableSystemAssertions ; } public void setRefid ( Reference ref ) { if ( assertionList . size ( ) > 0 || enableSystemAssertions != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( ref ) ; } private Assertions getFinalReference ( ) { if ( getRefid ( ) == null ) { return this ; } else { Object o = getRefid ( ) . getReferencedObject ( getProject ( ) ) ; if ( ! ( o instanceof Assertions ) ) { throw new BuildException ( "reference is of wrong type" ) ; } return ( Assertions ) o ; } } public int size ( ) { Assertions clause = getFinalReference ( ) ; return clause . getFinalSize ( ) ; } private int getFinalSize ( ) { return assertionList . size ( ) + ( enableSystemAssertions != null ? 1 : 0 ) ; } public void applyAssertions ( List commandList ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandList . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandList . add ( arg ) ; } } public void applyAssertions ( CommandlineJava command ) { Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { addVmArgument ( command , "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; addVmArgument ( command , arg ) ; } } public void applyAssertions ( final ListIterator commandIterator ) { getProject ( ) . log ( "Applying assertions" , Project . MSG_DEBUG ) ; Assertions clause = getFinalReference ( ) ; if ( Boolean . TRUE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "Enabling system assertions" , Project . MSG_DEBUG ) ; commandIterator . add ( "-enablesystemassertions" ) ; } else if ( Boolean . FALSE . equals ( clause . enableSystemAssertions ) ) { getProject ( ) . log ( "disabling system assertions" , Project . MSG_DEBUG ) ; commandIterator . add ( "-disablesystemassertions" ) ; } Iterator it = clause . assertionList . iterator ( ) ; while ( it . hasNext ( ) ) { BaseAssertion assertion = ( BaseAssertion ) it . next ( ) ; String arg = assertion . toCommand ( ) ; getProject ( ) . log ( "adding assertion " + arg , Project . MSG_DEBUG ) ; commandIterator . add ( arg ) ; } } private static void addVmArgument ( CommandlineJava command , String arg ) { Commandline . Argument argument ; argument = command . createVmArgument ( ) ; argument . setValue ( arg ) ; } public Object clone ( ) throws CloneNotSupportedException { Assertions that = ( Assertions ) super . clone ( ) ; that . assertionList = ( ArrayList ) assertionList . clone ( ) ; return that ; } public abstract static class BaseAssertion { private String packageName ; private String className ; public void setClass ( String className ) { this . className = className ; } public void setPackage ( String packageName ) { this . packageName = packageName ; } protected String getClassName ( ) { return className ; } protected String getPackageName ( ) { return packageName ; } public abstract String getCommandPrefix ( ) ; public String toCommand ( ) { if ( getPackageName ( ) != null && getClassName ( ) != null ) { throw new BuildException ( "Both package and class have been set" ) ; } StringBuffer command = new StringBuffer ( getCommandPrefix ( ) ) ; if ( getPackageName ( ) != null ) { command . append ( ':' ) ; command . append ( getPackageName ( ) ) ; if ( ! command . toString ( ) . endsWith ( "..." ) ) { command . append ( "..." ) ; } } else if ( getClassName ( ) != null ) { command . append ( ':' ) ; command . append ( getClassName ( ) ) ; } return command . toString ( ) ; } } public static class EnabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-ea" ; } } public static class DisabledAssertion extends BaseAssertion { public String getCommandPrefix ( ) { return "-da" ; } } } 	0	['13', '3', '0', '11', '40', '0', '3', '9', '10', '0.375', '289', '1', '0', '0.714285714', '0.179487179', '2', '3', '21.07692308', '4', '2', '0']
package org . apache . tools . ant . taskdefs . optional . junit ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . Iterator ; import java . util . List ; import java . util . Vector ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . taskdefs . XSLTProcess ; import org . apache . tools . ant . taskdefs . Delete ; import org . apache . tools . ant . taskdefs . TempFile ; import org . apache . tools . ant . util . JAXPUtils ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . ant . types . EnumeratedAttribute ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . resources . URLResource ; import org . apache . tools . ant . types . resources . FileResource ; import org . w3c . dom . Document ; public class AggregateTransformer { public static final String FRAMES = "frames" ; public static final String NOFRAMES = "noframes" ; public static class Format extends EnumeratedAttribute { public String [ ] getValues ( ) { return new String [ ] { FRAMES , NOFRAMES } ; } } protected Task task ; protected Document document ; protected File styleDir ; protected File toDir ; private List params ; private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static int counter = 0 ; protected String format = FRAMES ; private static DocumentBuilderFactory privateDBFactory ; protected static DocumentBuilderFactory dbfactory ; static { privateDBFactory = DocumentBuilderFactory . newInstance ( ) ; dbfactory = privateDBFactory ; } public AggregateTransformer ( Task task ) { this . task = task ; params = new Vector ( ) ; } protected static DocumentBuilderFactory getDocumentBuilderFactory ( ) { return privateDBFactory ; } public void setFormat ( Format format ) { this . format = format . getValue ( ) ; } public void setXmlDocument ( Document doc ) { this . document = doc ; } protected void setXmlfile ( File xmlfile ) throws BuildException { try { DocumentBuilder builder = privateDBFactory . newDocumentBuilder ( ) ; InputStream in = new FileInputStream ( xmlfile ) ; try { Document doc = builder . parse ( in ) ; setXmlDocument ( doc ) ; } finally { in . close ( ) ; } } catch ( Exception e ) { throw new BuildException ( "Error while parsing document: " + xmlfile , e ) ; } } public void setStyledir ( File styledir ) { this . styleDir = styledir ; } public void setTodir ( File todir ) { this . toDir = todir ; } public void setExtension ( String ext ) { task . log ( "extension is not used anymore" , Project . MSG_WARN ) ; } public XSLTProcess . Param createParam ( ) { XSLTProcess . Param p = new XSLTProcess . Param ( ) ; params . add ( p ) ; return p ; } public void transform ( ) throws BuildException { checkOptions ( ) ; Project project = task . getProject ( ) ; TempFile tempFileTask = new TempFile ( ) ; tempFileTask . bindToOwner ( task ) ; XSLTProcess xsltTask = new XSLTProcess ( ) ; xsltTask . bindToOwner ( task ) ; xsltTask . setXslResource ( getStylesheet ( ) ) ; xsltTask . setIn ( ( ( XMLResultAggregator ) task ) . getDestinationFile ( ) ) ; File outputFile = null ; if ( format . equals ( FRAMES ) ) { String tempFileProperty = getClass ( ) . getName ( ) + String . valueOf ( counter ++ ) ; File tmp = FILE_UTILS . resolveFile ( project . getBaseDir ( ) , project . getProperty ( "java.io.tmpdir" ) ) ; tempFileTask . setDestDir ( tmp ) ; tempFileTask . setProperty ( tempFileProperty ) ; tempFileTask . execute ( ) ; outputFile = new File ( project . getProperty ( tempFileProperty ) ) ; } else { outputFile = new File ( toDir , "junit-noframes.html" ) ; } xsltTask . setOut ( outputFile ) ; for ( Iterator i = params . iterator ( ) ; i . hasNext ( ) ; ) { XSLTProcess . Param param = ( XSLTProcess . Param ) i . next ( ) ; XSLTProcess . Param newParam = xsltTask . createParam ( ) ; newParam . setProject ( task . getProject ( ) ) ; newParam . setName ( param . getName ( ) ) ; newParam . setExpression ( param . getExpression ( ) ) ; } XSLTProcess . Param paramx = xsltTask . createParam ( ) ; paramx . setProject ( task . getProject ( ) ) ; paramx . setName ( "output.dir" ) ; paramx . setExpression ( toDir . getAbsolutePath ( ) ) ; final long t0 = System . currentTimeMillis ( ) ; try { xsltTask . execute ( ) ; } catch ( Exception e ) { throw new BuildException ( "Errors while applying transformations: " + e . getMessage ( ) , e ) ; } final long dt = System . currentTimeMillis ( ) - t0 ; task . log ( "Transform time: " + dt + "ms" ) ; if ( format . equals ( FRAMES ) ) { Delete delete = new Delete ( ) ; delete . bindToOwner ( task ) ; delete . setFile ( outputFile ) ; delete . execute ( ) ; } } protected Resource getStylesheet ( ) { String xslname = "junit-frames.xsl" ; if ( NOFRAMES . equals ( format ) ) { xslname = "junit-noframes.xsl" ; } if ( styleDir == null ) { URLResource stylesheet = new URLResource ( ) ; URL stylesheetURL = getClass ( ) . getClassLoader ( ) . getResource ( "org/apache/tools/ant/taskdefs/optional/junit/xsl/" + xslname ) ; stylesheet . setURL ( stylesheetURL ) ; return stylesheet ; } FileResource stylesheet = new FileResource ( ) ; File stylesheetFile = new File ( styleDir , xslname ) ; stylesheet . setFile ( stylesheetFile ) ; return stylesheet ; } protected void checkOptions ( ) throws BuildException { if ( toDir == null ) { toDir = task . getProject ( ) . resolveFile ( "." ) ; } else if ( ! toDir . isAbsolute ( ) ) { toDir = task . getProject ( ) . resolveFile ( toDir . getPath ( ) ) ; } } protected String getStylesheetSystemId ( ) throws IOException { String xslname = "junit-frames.xsl" ; if ( NOFRAMES . equals ( format ) ) { xslname = "junit-noframes.xsl" ; } if ( styleDir == null ) { URL url = getClass ( ) . getResource ( "xsl/" + xslname ) ; if ( url == null ) { throw new FileNotFoundException ( "Could not find jar resource " + xslname ) ; } return url . toExternalForm ( ) ; } File file = new File ( styleDir , xslname ) ; if ( ! file . exists ( ) ) { throw new FileNotFoundException ( "Could not find file '" + file + "'" ) ; } return JAXPUtils . getSystemId ( file ) ; } } 	0	['14', '1', '0', '16', '86', '41', '3', '14', '8', '0.891025641', '451', '0.833333333', '2', '0', '0.243589744', '0', '0', '30.35714286', '3', '1', '0']
package org . apache . tools . ant . util . depend . bcel ; import java . io . File ; import java . io . IOException ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Vector ; import org . apache . bcel . classfile . ClassParser ; import org . apache . bcel . classfile . DescendingVisitor ; import org . apache . bcel . classfile . JavaClass ; import org . apache . tools . ant . util . depend . AbstractAnalyzer ; public class FullAnalyzer extends AbstractAnalyzer { public FullAnalyzer ( ) { try { new ClassParser ( "force" ) ; } catch ( IOException e ) { } } protected void determineDependencies ( Vector files , Vector classes ) { Hashtable dependencies = new Hashtable ( ) ; Hashtable containers = new Hashtable ( ) ; Hashtable toAnalyze = new Hashtable ( ) ; for ( Enumeration e = getRootClasses ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; toAnalyze . put ( classname , classname ) ; } int count = 0 ; int maxCount = isClosureRequired ( ) ? MAX_LOOPS : 2 ; while ( toAnalyze . size ( ) != 0 && count ++ < maxCount ) { DependencyVisitor dependencyVisitor = new DependencyVisitor ( ) ; for ( Enumeration e = toAnalyze . keys ( ) ; e . hasMoreElements ( ) ; ) { String classname = ( String ) e . nextElement ( ) ; dependencies . put ( classname , classname ) ; try { File container = getClassContainer ( classname ) ; if ( container == null ) { continue ; } containers . put ( container , container ) ; ClassParser parser = null ; if ( container . getName ( ) . endsWith ( ".class" ) ) { parser = new ClassParser ( container . getPath ( ) ) ; } else { parser = new ClassParser ( container . getPath ( ) , classname . replace ( '.' , '/' ) + ".class" ) ; } JavaClass javaClass = parser . parse ( ) ; DescendingVisitor traverser = new DescendingVisitor ( javaClass , dependencyVisitor ) ; traverser . visit ( ) ; } catch ( IOException ioe ) { } } toAnalyze . clear ( ) ; Enumeration depsEnum = dependencyVisitor . getDependencies ( ) ; while ( depsEnum . hasMoreElements ( ) ) { String className = ( String ) depsEnum . nextElement ( ) ; if ( ! dependencies . containsKey ( className ) ) { toAnalyze . put ( className , className ) ; } } } files . removeAllElements ( ) ; for ( Enumeration e = containers . keys ( ) ; e . hasMoreElements ( ) ; ) { files . addElement ( ( File ) e . nextElement ( ) ) ; } classes . removeAllElements ( ) ; for ( Enumeration e = dependencies . keys ( ) ; e . hasMoreElements ( ) ; ) { classes . addElement ( ( String ) e . nextElement ( ) ) ; } } protected boolean supportsFileDependencies ( ) { return true ; } } 	0	['3', '2', '0', '6', '32', '3', '0', '6', '1', '2', '185', '0', '0', '0.882352941', '0.666666667', '1', '2', '60.66666667', '12', '4.3333', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; public interface LogListener { void log ( String message ) ; } 	0	['1', '1', '0', '4', '1', '0', '4', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . taskdefs ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Enumeration ; import java . util . Vector ; class ProcessDestroyer implements Runnable { private Vector processes = new Vector ( ) ; private Method addShutdownHookMethod ; private Method removeShutdownHookMethod ; private ProcessDestroyerImpl destroyProcessThread = null ; private boolean added = false ; private boolean running = false ; private class ProcessDestroyerImpl extends Thread { private boolean shouldDestroy = true ; public ProcessDestroyerImpl ( ) { super ( "ProcessDestroyer Shutdown Hook" ) ; } public void run ( ) { if ( shouldDestroy ) { ProcessDestroyer . this . run ( ) ; } } public void setShouldDestroy ( boolean shouldDestroy ) { this . shouldDestroy = shouldDestroy ; } } public ProcessDestroyer ( ) { try { Class [ ] paramTypes = { Thread . class } ; addShutdownHookMethod = Runtime . class . getMethod ( "addShutdownHook" , paramTypes ) ; removeShutdownHookMethod = Runtime . class . getMethod ( "removeShutdownHook" , paramTypes ) ; } catch ( NoSuchMethodException e ) { } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void addShutdownHook ( ) { if ( addShutdownHookMethod != null && ! running ) { destroyProcessThread = new ProcessDestroyerImpl ( ) ; Object [ ] args = { destroyProcessThread } ; try { addShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; added = true ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t != null && t . getClass ( ) == IllegalStateException . class ) { running = true ; } else { e . printStackTrace ( ) ; } } } } private void removeShutdownHook ( ) { if ( removeShutdownHookMethod != null && added && ! running ) { Object [ ] args = { destroyProcessThread } ; try { Boolean removed = ( Boolean ) removeShutdownHookMethod . invoke ( Runtime . getRuntime ( ) , args ) ; if ( ! removed . booleanValue ( ) ) { System . err . println ( "Could not remove shutdown hook" ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; if ( t != null && t . getClass ( ) == IllegalStateException . class ) { running = true ; } else { e . printStackTrace ( ) ; } } destroyProcessThread . setShouldDestroy ( false ) ; if ( ! destroyProcessThread . getThreadGroup ( ) . isDestroyed ( ) ) { destroyProcessThread . start ( ) ; } try { destroyProcessThread . join ( 20000 ) ; } catch ( InterruptedException ie ) { } destroyProcessThread = null ; added = false ; } } public boolean isAddedAsShutdownHook ( ) { return added ; } public boolean add ( Process process ) { synchronized ( processes ) { if ( processes . size ( ) == 0 ) { addShutdownHook ( ) ; } processes . addElement ( process ) ; return processes . contains ( process ) ; } } public boolean remove ( Process process ) { synchronized ( processes ) { boolean processRemoved = processes . removeElement ( process ) ; if ( processRemoved && processes . size ( ) == 0 ) { removeShutdownHook ( ) ; } return processRemoved ; } } public void run ( ) { synchronized ( processes ) { running = true ; Enumeration e = processes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ( ( Process ) e . nextElement ( ) ) . destroy ( ) ; } } } } 	0	['7', '1', '0', '2', '36', '0', '2', '1', '5', '0.555555556', '335', '0.666666667', '1', '0', '0.642857143', '0', '0', '45.57142857', '9', '3.2857', '0']
package org . apache . tools . ant . types . resources . comparators ; import org . apache . tools . ant . types . Resource ; public class Name extends ResourceComparator { protected int resourceCompare ( Resource foo , Resource bar ) { return foo . getName ( ) . compareTo ( bar . getName ( ) ) ; } } 	0	['2', '4', '0', '2', '5', '1', '0', '2', '1', '2', '11', '0', '0', '0.971428571', '0.75', '1', '1', '4.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; public class EscapeUnicode extends BaseParamFilterReader implements ChainableReader { private StringBuffer unicodeBuf ; public EscapeUnicode ( ) { super ( ) ; unicodeBuf = new StringBuffer ( ) ; } public EscapeUnicode ( final Reader in ) { super ( in ) ; unicodeBuf = new StringBuffer ( ) ; } public final int read ( ) throws IOException { if ( ! getInitialized ( ) ) { initialize ( ) ; setInitialized ( true ) ; } int ch = - 1 ; if ( unicodeBuf . length ( ) == 0 ) { ch = in . read ( ) ; if ( ch != - 1 ) { char achar = ( char ) ch ; if ( achar >= '' ) { unicodeBuf = new StringBuffer ( "u0000" ) ; String s = Integer . toHexString ( ch ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { unicodeBuf . setCharAt ( unicodeBuf . length ( ) - s . length ( ) + i , s . charAt ( i ) ) ; } ch = '\\' ; } } } else { ch = ( int ) unicodeBuf . charAt ( 0 ) ; unicodeBuf . deleteCharAt ( 0 ) ; } return ch ; } public final Reader chain ( final Reader rdr ) { EscapeUnicode newFilter = new EscapeUnicode ( rdr ) ; newFilter . setInitialized ( true ) ; return newFilter ; } private void initialize ( ) { } } 	0	['5', '5', '0', '3', '19', '4', '1', '2', '4', '0.25', '107', '1', '0', '0.903225806', '0.7', '2', '5', '20.2', '1', '0.6', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public abstract class DefaultNative2Ascii implements Native2AsciiAdapter { public DefaultNative2Ascii ( ) { } public final boolean convert ( Native2Ascii args , File srcFile , File destFile ) throws BuildException { Commandline cmd = new Commandline ( ) ; setup ( cmd , args ) ; addFiles ( cmd , args , srcFile , destFile ) ; return run ( cmd , args ) ; } protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getEncoding ( ) != null ) { cmd . createArgument ( ) . setValue ( "-encoding" ) ; cmd . createArgument ( ) . setValue ( args . getEncoding ( ) ) ; } cmd . addArguments ( args . getCurrentArgs ( ) ) ; } protected void addFiles ( Commandline cmd , ProjectComponent log , File src , File dest ) throws BuildException { cmd . createArgument ( ) . setFile ( src ) ; cmd . createArgument ( ) . setFile ( dest ) ; } protected abstract boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException ; } 	0	['5', '1', '2', '8', '13', '10', '2', '6', '2', '2', '53', '0', '0', '0', '0.56', '0', '0', '9.6', '1', '0.8', '0']
package org . apache . tools . ant . util . regexp ; public class RegexpUtil { public static boolean hasFlag ( int options , int flag ) { return ( ( options & flag ) > 0 ) ; } public static int removeFlag ( int options , int flag ) { return ( options & ( 0xFFFFFFFF - flag ) ) ; } } 	0	['3', '1', '0', '6', '4', '3', '6', '0', '3', '2', '20', '0', '0', '0', '0.5', '0', '0', '5.666666667', '2', '1', '0']
package org . apache . tools . ant . util ; import java . io . ByteArrayOutputStream ; import org . apache . tools . ant . Project ; public class PropertyOutputStream extends ByteArrayOutputStream { private Project project ; private String property ; private boolean trim ; public PropertyOutputStream ( Project p , String s ) { this ( p , s , true ) ; } public PropertyOutputStream ( Project p , String s , boolean b ) { project = p ; property = s ; trim = b ; } public void close ( ) { if ( project != null && property != null ) { String s = new String ( toByteArray ( ) ) ; project . setNewProperty ( property , trim ? s . trim ( ) : s ) ; } } } 	0	['3', '3', '0', '3', '8', '1', '2', '1', '3', '0', '49', '1', '1', '0.9375', '0.666666667', '0', '0', '14.33333333', '4', '1.3333', '0']
package org . apache . tools . ant . taskdefs . optional . extension . resolvers ; import java . io . File ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . taskdefs . Ant ; import org . apache . tools . ant . taskdefs . optional . extension . Extension ; import org . apache . tools . ant . taskdefs . optional . extension . ExtensionResolver ; public class AntResolver implements ExtensionResolver { private File antfile ; private File destfile ; private String target ; public void setAntfile ( final File antfile ) { this . antfile = antfile ; } public void setDestfile ( final File destfile ) { this . destfile = destfile ; } public void setTarget ( final String target ) { this . target = target ; } public File resolve ( final Extension extension , final Project project ) throws BuildException { validate ( ) ; final Ant ant = new Ant ( ) ; ant . setProject ( project ) ; ant . setInheritAll ( false ) ; ant . setAntfile ( antfile . getName ( ) ) ; try { final File dir = antfile . getParentFile ( ) . getCanonicalFile ( ) ; ant . setDir ( dir ) ; } catch ( final IOException ioe ) { throw new BuildException ( ioe . getMessage ( ) , ioe ) ; } if ( null != target ) { ant . setTarget ( target ) ; } ant . execute ( ) ; return destfile ; } private void validate ( ) { if ( null == antfile ) { final String message = "Must specify Buildfile" ; throw new BuildException ( message ) ; } if ( null == destfile ) { final String message = "Must specify destination file" ; throw new BuildException ( message ) ; } } public String toString ( ) { return "Ant[" + antfile + "==>" + destfile + "]" ; } } 	0	['7', '1', '0', '6', '25', '1', '1', '5', '6', '0.611111111', '104', '1', '0', '0', '0.342857143', '0', '0', '13.42857143', '3', '1.1429', '0']
package org . apache . tools . ant . taskdefs . optional . ssh ; import com . jcraft . jsch . JSchException ; import com . jcraft . jsch . Session ; import com . jcraft . jsch . JSch ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public abstract class SSHBase extends Task implements LogListener { private static final int SSH_PORT = 22 ; private String host ; private String knownHosts ; private int port = SSH_PORT ; private boolean failOnError = true ; private boolean verbose ; private SSHUserInfo userInfo ; public SSHBase ( ) { super ( ) ; userInfo = new SSHUserInfo ( ) ; } public void setHost ( String host ) { this . host = host ; } public String getHost ( ) { return host ; } public void setFailonerror ( boolean failure ) { failOnError = failure ; } public boolean getFailonerror ( ) { return failOnError ; } public void setVerbose ( boolean verbose ) { this . verbose = verbose ; } public boolean getVerbose ( ) { return verbose ; } public void setUsername ( String username ) { userInfo . setName ( username ) ; } public void setPassword ( String password ) { userInfo . setPassword ( password ) ; } public void setKeyfile ( String keyfile ) { userInfo . setKeyfile ( keyfile ) ; } public void setPassphrase ( String passphrase ) { userInfo . setPassphrase ( passphrase ) ; } public void setKnownhosts ( String knownHosts ) { this . knownHosts = knownHosts ; } public void setTrust ( boolean yesOrNo ) { userInfo . setTrust ( yesOrNo ) ; } public void setPort ( int port ) { this . port = port ; } public int getPort ( ) { return port ; } public void init ( ) throws BuildException { super . init ( ) ; this . knownHosts = System . getProperty ( "user.home" ) + "/.ssh/known_hosts" ; this . port = SSH_PORT ; } protected Session openSession ( ) throws JSchException { JSch jsch = new JSch ( ) ; if ( null != userInfo . getKeyfile ( ) ) { jsch . addIdentity ( userInfo . getKeyfile ( ) ) ; } if ( ! userInfo . getTrust ( ) && knownHosts != null ) { log ( "Using known hosts: " + knownHosts , Project . MSG_DEBUG ) ; jsch . setKnownHosts ( knownHosts ) ; } Session session = jsch . getSession ( userInfo . getName ( ) , host , port ) ; session . setUserInfo ( userInfo ) ; log ( "Connecting to " + host + ":" + port ) ; session . connect ( ) ; return session ; } protected SSHUserInfo getUserInfo ( ) { return userInfo ; } } 	0	['18', '3', '2', '10', '43', '61', '2', '8', '16', '0.857142857', '184', '1', '1', '0.685185185', '0.388888889', '0', '0', '8.833333333', '1', '0.9444', '0']
package org . apache . tools . ant . taskdefs . optional . dotnet ; import org . apache . tools . ant . BuildException ; import java . io . File ; import java . util . ArrayList ; import org . apache . tools . ant . types . FileSet ; import java . util . Iterator ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . DirectoryScanner ; public class DotnetResource { private File file ; private boolean embed = true ; private Boolean isPublic = null ; private String name = null ; private ArrayList fileSets = new ArrayList ( ) ; private String namespace = null ; public boolean isEmbed ( ) { return embed ; } public void setEmbed ( boolean embed ) { this . embed = embed ; } public File getFile ( ) { return file ; } public void setFile ( File file ) { this . file = file ; } public Boolean getPublic ( ) { return isPublic ; } public void setPublic ( Boolean aPublic ) { isPublic = aPublic ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { if ( namespace == null ) { this . namespace = null ; } else { this . namespace = ( namespace . length ( ) == 0 || namespace . endsWith ( "." ) ? namespace : namespace + '.' ) ; } } private void checkParameters ( ) { if ( hasFilesets ( ) ) { if ( getName ( ) != null ) { throw new BuildException ( "Cannot use <resource name=\"...\"> attribute with filesets" ) ; } if ( getFile ( ) != null ) { throw new BuildException ( "Cannot use <resource file=\"...\"> attribute with filesets" ) ; } } else { if ( getNamespace ( ) != null ) { throw new BuildException ( "Cannot use <resource namespace=\"...\"> attribute without filesets" ) ; } } } public void getParameters ( Project p , NetCommand command , boolean csharpStyle ) { checkParameters ( ) ; if ( hasFilesets ( ) ) { for ( Iterator listIter = fileSets . iterator ( ) ; listIter . hasNext ( ) ; ) { FileSet fs = ( FileSet ) listIter . next ( ) ; String baseDirectory = fs . getDir ( p ) . toString ( ) ; String namespace = getNamespace ( ) ; DirectoryScanner ds = fs . getDirectoryScanner ( p ) ; String [ ] files = ds . getIncludedFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { String file = files [ i ] ; command . addArgument ( getParameter ( baseDirectory + File . separatorChar + file , ( namespace == null ? null : namespace + file . replace ( File . separatorChar , '.' ) ) , csharpStyle ) ) ; } } } else { command . addArgument ( getParameter ( getFile ( ) . toString ( ) , getName ( ) , csharpStyle ) ) ; } } private String getParameter ( String fileName , String name , boolean csharpStyle ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( isEmbed ( ) ? "/resource" : "/linkresource" ) ; buffer . append ( ':' ) ; buffer . append ( fileName ) ; if ( name != null ) { buffer . append ( ',' ) ; buffer . append ( name ) ; if ( csharpStyle ) { if ( getPublic ( ) != null ) { throw new BuildException ( "This compiler does not support the " + "public/private option." ) ; } else { if ( getPublic ( ) != null ) { buffer . append ( ',' ) ; buffer . append ( getPublic ( ) . booleanValue ( ) ? "public" : "private" ) ; } } } else if ( getPublic ( ) != null ) { throw new BuildException ( "You cannot have a public or private " + "option without naming the resource" ) ; } } return buffer . toString ( ) ; } public void addFileset ( FileSet fileset ) { fileSets . add ( fileset ) ; } public boolean hasFilesets ( ) { return fileSets . size ( ) > 0 ; } } 	0	['16', '1', '0', '9', '39', '82', '4', '5', '14', '0.766666667', '297', '1', '0', '0', '0.2109375', '0', '0', '17.1875', '8', '2.125', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class LongCPInfo extends ConstantCPInfo { public LongCPInfo ( ) { super ( CONSTANT_LONG , 2 ) ; } public void read ( DataInputStream cpStream ) throws IOException { setValue ( new Long ( cpStream . readLong ( ) ) ) ; } public String toString ( ) { return "Long Constant Pool Entry: " + getValue ( ) ; } } 	0	['3', '3', '0', '2', '11', '3', '1', '1', '3', '2', '25', '0', '0', '0.8', '0.666666667', '2', '2', '7.333333333', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import java . io . BufferedOutputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . util . FileUtils ; import org . apache . tools . bzip2 . CBZip2OutputStream ; public class BZip2 extends Pack { protected void pack ( ) { CBZip2OutputStream zOut = null ; try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( zipFile ) ) ; bos . write ( 'B' ) ; bos . write ( 'Z' ) ; zOut = new CBZip2OutputStream ( bos ) ; zipResource ( getSrcResource ( ) , zOut ) ; } catch ( IOException ioe ) { String msg = "Problem creating bzip2 " + ioe . getMessage ( ) ; throw new BuildException ( msg , ioe , getLocation ( ) ) ; } finally { FileUtils . close ( zOut ) ; } } protected boolean supportsNonFileResources ( ) { return getClass ( ) . equals ( BZip2 . class ) ; } } 	0	['3', '4', '0', '6', '22', '3', '0', '6', '1', '1', '82', '0', '0', '0.961538462', '1', '2', '4', '26', '3', '1.6667', '0']
package org . apache . tools . ant . taskdefs . optional . depend . constantpool ; import java . io . DataInputStream ; import java . io . IOException ; public class StringCPInfo extends ConstantCPInfo { public StringCPInfo ( ) { super ( CONSTANT_STRING , 1 ) ; } public void read ( DataInputStream cpStream ) throws IOException { index = cpStream . readUnsignedShort ( ) ; setValue ( "unresolved" ) ; } public String toString ( ) { return "String Constant Pool Entry for " + getValue ( ) + "[" + index + "]" ; } public void resolve ( ConstantPool constantPool ) { setValue ( ( ( Utf8CPInfo ) constantPool . getEntry ( index ) ) . getValue ( ) ) ; super . resolve ( constantPool ) ; } private int index ; } 	0	['4', '3', '0', '4', '16', '0', '1', '4', '4', '0.333333333', '46', '1', '0', '0.727272727', '0.5', '2', '3', '10.25', '1', '0.75', '0']
package org . apache . tools . ant . taskdefs . cvslib ; import org . apache . tools . ant . util . LineOrientedOutputStream ; class RedirectingOutputStream extends LineOrientedOutputStream { private final ChangeLogParser parser ; public RedirectingOutputStream ( final ChangeLogParser parser ) { this . parser = parser ; } protected void processLine ( final String line ) { parser . stdout ( line ) ; } } 	0	['2', '3', '0', '3', '4', '0', '1', '2', '1', '0', '14', '1', '1', '0.916666667', '0.666666667', '1', '1', '5.5', '1', '0.5', '0']
package org . apache . tools . ant . filters ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . util . FileUtils ; public abstract class BaseFilterReader extends FilterReader { private static final int BUFFER_SIZE = 8192 ; private boolean initialized = false ; private Project project = null ; public BaseFilterReader ( ) { super ( new StringReader ( "" ) ) ; FileUtils . close ( this ) ; } public BaseFilterReader ( final Reader in ) { super ( in ) ; } public final int read ( final char [ ] cbuf , final int off , final int len ) throws IOException { for ( int i = 0 ; i < len ; i ++ ) { final int ch = read ( ) ; if ( ch == - 1 ) { if ( i == 0 ) { return - 1 ; } else { return i ; } } cbuf [ off + i ] = ( char ) ch ; } return len ; } public final long skip ( final long n ) throws IOException , IllegalArgumentException { if ( n < 0L ) { throw new IllegalArgumentException ( "skip value is negative" ) ; } for ( long i = 0 ; i < n ; i ++ ) { if ( read ( ) == - 1 ) { return i ; } } return n ; } protected final void setInitialized ( final boolean initialized ) { this . initialized = initialized ; } protected final boolean getInitialized ( ) { return initialized ; } public final void setProject ( final Project project ) { this . project = project ; } protected final Project getProject ( ) { return project ; } protected final String readLine ( ) throws IOException { int ch = in . read ( ) ; if ( ch == - 1 ) { return null ; } StringBuffer line = new StringBuffer ( ) ; while ( ch != - 1 ) { line . append ( ( char ) ch ) ; if ( ch == '\n' ) { break ; } ch = in . read ( ) ; } return line . toString ( ) ; } protected final String readFully ( ) throws IOException { return FileUtils . readFully ( in , BUFFER_SIZE ) ; } } 	0	['10', '3', '6', '9', '20', '21', '7', '2', '5', '0.814814815', '146', '1', '1', '0.692307692', '0.228571429', '1', '2', '13.3', '1', '0.8', '0']
package org . apache . tools . ant . types ; import java . util . Iterator ; import org . apache . tools . ant . DirectoryScanner ; import org . apache . tools . ant . types . resources . FileResourceIterator ; public class DirSet extends AbstractFileSet implements ResourceCollection { public DirSet ( ) { super ( ) ; } protected DirSet ( DirSet dirset ) { super ( dirset ) ; } public Object clone ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . clone ( ) ; } else { return super . clone ( ) ; } } public Iterator iterator ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . iterator ( ) ; } return new FileResourceIterator ( getDir ( getProject ( ) ) , getDirectoryScanner ( getProject ( ) ) . getIncludedDirectories ( ) ) ; } public int size ( ) { if ( isReference ( ) ) { return ( ( DirSet ) getRef ( getProject ( ) ) ) . size ( ) ; } return getDirectoryScanner ( getProject ( ) ) . getIncludedDirsCount ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } public String toString ( ) { DirectoryScanner ds = getDirectoryScanner ( getProject ( ) ) ; String [ ] dirs = ds . getIncludedDirectories ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( i > 0 ) { sb . append ( ';' ) ; } sb . append ( dirs [ i ] ) ; } return sb . toString ( ) ; } } 	0	['7', '4', '0', '9', '22', '21', '4', '5', '6', '2', '103', '0', '0', '0.945652174', '0.571428571', '3', '5', '13.71428571', '3', '1.4286', '0']
package org . apache . tools . ant . taskdefs . optional . native2ascii ; import java . lang . reflect . Method ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . taskdefs . optional . Native2Ascii ; import org . apache . tools . ant . types . Commandline ; public final class SunNative2Ascii extends DefaultNative2Ascii { public static final String IMPLEMENTATION_NAME = "sun" ; protected void setup ( Commandline cmd , Native2Ascii args ) throws BuildException { if ( args . getReverse ( ) ) { cmd . createArgument ( ) . setValue ( "-reverse" ) ; } super . setup ( cmd , args ) ; } protected boolean run ( Commandline cmd , ProjectComponent log ) throws BuildException { try { Class n2aMain = Class . forName ( "sun.tools.native2ascii.Main" ) ; Class [ ] param = new Class [ ] { String [ ] . class } ; Method convert = n2aMain . getMethod ( "convert" , param ) ; if ( convert == null ) { throw new BuildException ( "Could not find convert() method in " + "sun.tools.native2ascii.Main" ) ; } Object o = n2aMain . newInstance ( ) ; return ( ( Boolean ) convert . invoke ( o , new Object [ ] { cmd . getArguments ( ) } ) ) . booleanValue ( ) ; } catch ( BuildException ex ) { throw ex ; } catch ( Exception ex ) { throw new BuildException ( "Error starting Sun's native2ascii: " , ex ) ; } } } 	0	['3', '2', '0', '7', '18', '3', '1', '6', '1', '1.25', '82', '0', '0', '0.666666667', '0.583333333', '1', '2', '25.66666667', '1', '0.6667', '0']
package org . apache . tools . ant . taskdefs ; import org . apache . tools . ant . AntTypeDefinition ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ComponentHelper ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . ProjectHelper ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . TaskContainer ; import org . apache . tools . ant . UnknownElement ; public class PreSetDef extends AntlibDefinition implements TaskContainer { private UnknownElement nestedTask ; private String name ; public void setName ( String name ) { this . name = name ; } public void addTask ( Task nestedTask ) { if ( this . nestedTask != null ) { throw new BuildException ( "Only one nested element allowed" ) ; } if ( ! ( nestedTask instanceof UnknownElement ) ) { throw new BuildException ( "addTask called with a task that is not an unknown element" ) ; } this . nestedTask = ( UnknownElement ) nestedTask ; } public void execute ( ) { if ( nestedTask == null ) { throw new BuildException ( "Missing nested element" ) ; } if ( name == null ) { throw new BuildException ( "Name not specified" ) ; } name = ProjectHelper . genComponentName ( getURI ( ) , name ) ; ComponentHelper helper = ComponentHelper . getComponentHelper ( getProject ( ) ) ; String componentName = ProjectHelper . genComponentName ( nestedTask . getNamespace ( ) , nestedTask . getTag ( ) ) ; AntTypeDefinition def = helper . getDefinition ( componentName ) ; if ( def == null ) { throw new BuildException ( "Unable to find typedef " + componentName ) ; } PreSetDefinition newDef = new PreSetDefinition ( def , nestedTask ) ; newDef . setName ( name ) ; helper . addDataTypeDefinition ( newDef ) ; log ( "defining preset " + name , Project . MSG_VERBOSE ) ; } public static class PreSetDefinition extends AntTypeDefinition { private AntTypeDefinition parent ; private UnknownElement element ; public PreSetDefinition ( AntTypeDefinition parent , UnknownElement el ) { if ( parent instanceof PreSetDefinition ) { PreSetDefinition p = ( PreSetDefinition ) parent ; el . applyPreSet ( p . element ) ; parent = p . parent ; } this . parent = parent ; this . element = el ; } public void setClass ( Class clazz ) { throw new BuildException ( "Not supported" ) ; } public void setClassName ( String className ) { throw new BuildException ( "Not supported" ) ; } public String getClassName ( ) { return parent . getClassName ( ) ; } public void setAdapterClass ( Class adapterClass ) { throw new BuildException ( "Not supported" ) ; } public void setAdaptToClass ( Class adaptToClass ) { throw new BuildException ( "Not supported" ) ; } public void setClassLoader ( ClassLoader classLoader ) { throw new BuildException ( "Not supported" ) ; } public ClassLoader getClassLoader ( ) { return parent . getClassLoader ( ) ; } public Class getExposedClass ( Project project ) { return parent . getExposedClass ( project ) ; } public Class getTypeClass ( Project project ) { return parent . getTypeClass ( project ) ; } public void checkClass ( Project project ) { parent . checkClass ( project ) ; } public Object createObject ( Project project ) { return parent . create ( project ) ; } public UnknownElement getPreSets ( ) { return element ; } public Object create ( Project project ) { return this ; } public boolean sameDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) == getClass ( ) && parent != null && parent . sameDefinition ( ( ( PreSetDefinition ) other ) . parent , project ) && element . similar ( ( ( PreSetDefinition ) other ) . element ) ) ; } public boolean similarDefinition ( AntTypeDefinition other , Project project ) { return ( other != null && other . getClass ( ) . getName ( ) . equals ( getClass ( ) . getName ( ) ) && parent != null && parent . similarDefinition ( ( ( PreSetDefinition ) other ) . parent , project ) && element . similar ( ( ( PreSetDefinition ) other ) . element ) ) ; } } } 	0	['4', '4', '0', '10', '20', '2', '0', '10', '4', '0.666666667', '112', '1', '1', '0.931818182', '0.5', '1', '1', '26.5', '4', '2', '0']
package org . apache . tools . ant . taskdefs . optional . javah ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . ProjectComponent ; import org . apache . tools . ant . util . ClasspathUtils ; import org . apache . tools . ant . util . JavaEnvUtils ; public class JavahAdapterFactory { public static String getDefault ( ) { if ( JavaEnvUtils . isKaffe ( ) ) { return Kaffeh . IMPLEMENTATION_NAME ; } return SunJavah . IMPLEMENTATION_NAME ; } public static JavahAdapter getAdapter ( String choice , ProjectComponent log ) throws BuildException { if ( ( JavaEnvUtils . isKaffe ( ) && choice == null ) || Kaffeh . IMPLEMENTATION_NAME . equals ( choice ) ) { return new Kaffeh ( ) ; } else if ( SunJavah . IMPLEMENTATION_NAME . equals ( choice ) ) { return new SunJavah ( ) ; } else if ( choice != null ) { return resolveClassName ( choice ) ; } return new SunJavah ( ) ; } private static JavahAdapter resolveClassName ( String className ) throws BuildException { return ( JavahAdapter ) ClasspathUtils . newInstance ( className , JavahAdapterFactory . class . getClassLoader ( ) , JavahAdapter . class ) ; } } 	0	['4', '1', '0', '8', '14', '6', '1', '7', '3', '0.666666667', '79', '0', '0', '0', '0.333333333', '0', '0', '18.25', '2', '1', '0']
package org . apache . tools . ant . types . resources . comparators ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . types . DataType ; import org . apache . tools . ant . types . Resource ; public class DelegatedResourceComparator extends ResourceComparator { private Vector v = null ; public synchronized void add ( ResourceComparator c ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( c == null ) { return ; } v = ( v == null ) ? new Vector ( ) : v ; v . add ( c ) ; } public synchronized boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( o ) ; } if ( ! ( o instanceof DelegatedResourceComparator ) ) { return false ; } Vector ov = ( ( DelegatedResourceComparator ) o ) . v ; return v == null ? ov == null : v . equals ( ov ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return v == null ? 0 : v . hashCode ( ) ; } protected synchronized int resourceCompare ( Resource foo , Resource bar ) { if ( v == null || v . isEmpty ( ) ) { return foo . compareTo ( bar ) ; } int result = 0 ; for ( Iterator i = v . iterator ( ) ; result == 0 && i . hasNext ( ) ; ) { result = ( ( ResourceComparator ) i . next ( ) ) . resourceCompare ( foo , bar ) ; } return result ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { if ( ! ( v == null || v . isEmpty ( ) ) ) { for ( Iterator i = v . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } } setChecked ( true ) ; } } } 	0	['6', '4', '0', '7', '27', '0', '2', '5', '4', '0', '169', '1', '0', '0.871794872', '0.305555556', '3', '7', '27', '6', '3.1667', '0']
package org . apache . tools . ant . util ; import java . util . StringTokenizer ; public class DeweyDecimal { private int [ ] components ; public DeweyDecimal ( final int [ ] components ) { this . components = new int [ components . length ] ; for ( int i = 0 ; i < components . length ; i ++ ) { this . components [ i ] = components [ i ] ; } } public DeweyDecimal ( final String string ) throws NumberFormatException { final StringTokenizer tokenizer = new StringTokenizer ( string , "." , true ) ; final int size = tokenizer . countTokens ( ) ; components = new int [ ( size + 1 ) / 2 ] ; for ( int i = 0 ; i < components . length ; i ++ ) { final String component = tokenizer . nextToken ( ) ; if ( component . equals ( "" ) ) { throw new NumberFormatException ( "Empty component in string" ) ; } components [ i ] = Integer . parseInt ( component ) ; if ( tokenizer . hasMoreTokens ( ) ) { tokenizer . nextToken ( ) ; if ( ! tokenizer . hasMoreTokens ( ) ) { throw new NumberFormatException ( "DeweyDecimal ended in a '.'" ) ; } } } } public int getSize ( ) { return components . length ; } public int get ( final int index ) { return components [ index ] ; } public boolean isEqual ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 != component1 ) { return false ; } } return true ; } public boolean isLessThan ( final DeweyDecimal other ) { return ! isGreaterThanOrEqual ( other ) ; } public boolean isLessThanOrEqual ( final DeweyDecimal other ) { return ! isGreaterThan ( other ) ; } public boolean isGreaterThan ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 > component1 ) { return false ; } if ( component2 < component1 ) { return true ; } } return false ; } public boolean isGreaterThanOrEqual ( final DeweyDecimal other ) { final int max = Math . max ( other . components . length , components . length ) ; for ( int i = 0 ; i < max ; i ++ ) { final int component1 = ( i < components . length ) ? components [ i ] : 0 ; final int component2 = ( i < other . components . length ) ? other . components [ i ] : 0 ; if ( component2 > component1 ) { return false ; } if ( component2 < component1 ) { return true ; } } return true ; } public String toString ( ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < components . length ; i ++ ) { if ( i != 0 ) { sb . append ( '.' ) ; } sb . append ( components [ i ] ) ; } return sb . toString ( ) ; } } 	0	['10', '1', '1', '4', '23', '0', '4', '0', '10', '0', '298', '1', '0', '0', '0.36', '0', '0', '28.7', '6', '2.6', '0']
package org . apache . tools . ant . filters ; import java . io . Reader ; public interface ChainableReader { Reader chain ( Reader rdr ) ; } 	0	['1', '1', '0', '23', '1', '0', '23', '0', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0']
package org . apache . tools . ant . types . resources ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . net . MalformedURLException ; import java . net . JarURLConnection ; import java . util . jar . JarFile ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . Reference ; import org . apache . tools . ant . util . FileUtils ; public class URLResource extends Resource { private static final FileUtils FILE_UTILS = FileUtils . getFileUtils ( ) ; private static final int NULL_URL = Resource . getMagicNumber ( "null URL" . getBytes ( ) ) ; private URL url ; private URLConnection conn ; public URLResource ( ) { } public URLResource ( URL u ) { setURL ( u ) ; } public URLResource ( File f ) { setFile ( f ) ; } public URLResource ( String u ) { this ( newURL ( u ) ) ; } public synchronized void setURL ( URL u ) { checkAttributesAllowed ( ) ; url = u ; } public synchronized void setFile ( File f ) { try { setURL ( FILE_UTILS . getFileURL ( f ) ) ; } catch ( MalformedURLException e ) { throw new BuildException ( e ) ; } } public synchronized URL getURL ( ) { if ( isReference ( ) ) { return ( ( URLResource ) getCheckedRef ( ) ) . getURL ( ) ; } return url ; } public synchronized void setRefid ( Reference r ) { if ( url != null ) { throw tooManyAttributes ( ) ; } super . setRefid ( r ) ; } public synchronized String getName ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . getName ( ) : getURL ( ) . getFile ( ) . substring ( 1 ) ; } public synchronized String toString ( ) { return isReference ( ) ? getCheckedRef ( ) . toString ( ) : String . valueOf ( getURL ( ) ) ; } public synchronized boolean isExists ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . isExists ( ) ; } return isExists ( false ) ; } private synchronized boolean isExists ( boolean closeConnection ) { if ( getURL ( ) == null ) { return false ; } try { connect ( ) ; return true ; } catch ( IOException e ) { return false ; } finally { if ( closeConnection ) { close ( ) ; } } } public synchronized long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } if ( ! isExists ( false ) ) { return 0L ; } return conn . getLastModified ( ) ; } public synchronized boolean isDirectory ( ) { return isReference ( ) ? ( ( Resource ) getCheckedRef ( ) ) . isDirectory ( ) : getName ( ) . endsWith ( "/" ) ; } public synchronized long getSize ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getSize ( ) ; } if ( ! isExists ( false ) ) { return 0L ; } try { connect ( ) ; long contentlength = conn . getContentLength ( ) ; close ( ) ; return contentlength ; } catch ( IOException e ) { return UNKNOWN_SIZE ; } } public synchronized boolean equals ( Object another ) { if ( this == another ) { return true ; } if ( isReference ( ) ) { return getCheckedRef ( ) . equals ( another ) ; } if ( ! ( another . getClass ( ) . equals ( getClass ( ) ) ) ) { return false ; } URLResource otheru = ( URLResource ) another ; return getURL ( ) == null ? otheru . getURL ( ) == null : getURL ( ) . equals ( otheru . getURL ( ) ) ; } public synchronized int hashCode ( ) { if ( isReference ( ) ) { return getCheckedRef ( ) . hashCode ( ) ; } return MAGIC * ( ( getURL ( ) == null ) ? NULL_URL : getURL ( ) . hashCode ( ) ) ; } public synchronized InputStream getInputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getInputStream ( ) ; } connect ( ) ; try { return conn . getInputStream ( ) ; } finally { conn = null ; } } public synchronized OutputStream getOutputStream ( ) throws IOException { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getOutputStream ( ) ; } connect ( ) ; try { return conn . getOutputStream ( ) ; } finally { conn = null ; } } protected synchronized void connect ( ) throws IOException { URL u = getURL ( ) ; if ( u == null ) { throw new BuildException ( "URL not set" ) ; } if ( conn == null ) { try { conn = u . openConnection ( ) ; conn . connect ( ) ; } catch ( IOException e ) { log ( e . toString ( ) , Project . MSG_ERR ) ; conn = null ; throw e ; } } } private synchronized void close ( ) { if ( conn != null ) { try { if ( conn instanceof JarURLConnection ) { JarURLConnection juc = ( JarURLConnection ) conn ; JarFile jf = juc . getJarFile ( ) ; jf . close ( ) ; jf = null ; } else if ( conn instanceof HttpURLConnection ) { ( ( HttpURLConnection ) conn ) . disconnect ( ) ; } } catch ( IOException exc ) { } finally { conn = null ; } } } private static URL newURL ( String u ) { try { return new URL ( u ) ; } catch ( MalformedURLException e ) { throw new BuildException ( e ) ; } } } 	0	['23', '4', '0', '6', '64', '213', '2', '4', '18', '0.738636364', '409', '1', '1', '0.746478873', '0.194805195', '2', '13', '16.60869565', '6', '1.9565', '0']
package org . apache . tools . ant . listener ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogConfigurationException ; import org . apache . commons . logging . LogFactory ; import org . apache . tools . ant . BuildListener ; import org . apache . tools . ant . BuildLogger ; import org . apache . tools . ant . BuildEvent ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . UnknownElement ; import java . io . PrintStream ; public class CommonsLoggingListener implements BuildListener , BuildLogger { private boolean initialized = false ; private LogFactory logFactory ; public static final String TARGET_LOG = "org.apache.tools.ant.Target" ; public static final String PROJECT_LOG = "org.apache.tools.ant.Project" ; public CommonsLoggingListener ( ) { } private Log getLog ( String cat , String suffix ) { if ( suffix != null ) { suffix = suffix . replace ( '.' , '-' ) ; suffix = suffix . replace ( ' ' , '-' ) ; cat = cat + "." + suffix ; } PrintStream tmpOut = System . out ; PrintStream tmpErr = System . err ; System . setOut ( out ) ; System . setErr ( err ) ; if ( ! initialized ) { try { logFactory = LogFactory . getFactory ( ) ; } catch ( LogConfigurationException e ) { e . printStackTrace ( System . err ) ; return null ; } } initialized = true ; Log log = logFactory . getInstance ( cat ) ; System . setOut ( tmpOut ) ; System . setErr ( tmpErr ) ; return log ; } public void buildStarted ( BuildEvent event ) { String categoryString = PROJECT_LOG ; Log log = getLog ( categoryString , null ) ; if ( initialized ) { realLog ( log , "Build started." , Project . MSG_INFO , null ) ; } } public void buildFinished ( BuildEvent event ) { if ( initialized ) { String categoryString = PROJECT_LOG ; Log log = getLog ( categoryString , event . getProject ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { realLog ( log , "Build finished." , Project . MSG_INFO , null ) ; } else { realLog ( log , "Build finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void targetStarted ( BuildEvent event ) { if ( initialized ) { Log log = getLog ( TARGET_LOG , event . getTarget ( ) . getName ( ) ) ; realLog ( log , "Start: " + event . getTarget ( ) . getName ( ) , Project . MSG_VERBOSE , null ) ; } } public void targetFinished ( BuildEvent event ) { if ( initialized ) { String targetName = event . getTarget ( ) . getName ( ) ; Log log = getLog ( TARGET_LOG , event . getTarget ( ) . getName ( ) ) ; if ( event . getException ( ) == null ) { realLog ( log , "Target end: " + targetName , Project . MSG_DEBUG , null ) ; } else { realLog ( log , "Target \"" + targetName + "\" finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void taskStarted ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Object real = task ; if ( task instanceof UnknownElement ) { Object realObj = ( ( UnknownElement ) task ) . getTask ( ) ; if ( realObj != null ) { real = realObj ; } } Log log = getLog ( real . getClass ( ) . getName ( ) , null ) ; if ( log . isTraceEnabled ( ) ) { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" started " , Project . MSG_VERBOSE , null ) ; } } } public void taskFinished ( BuildEvent event ) { if ( initialized ) { Task task = event . getTask ( ) ; Object real = task ; if ( task instanceof UnknownElement ) { Object realObj = ( ( UnknownElement ) task ) . getTask ( ) ; if ( realObj != null ) { real = realObj ; } } Log log = getLog ( real . getClass ( ) . getName ( ) , null ) ; if ( event . getException ( ) == null ) { if ( log . isTraceEnabled ( ) ) { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" finished." , Project . MSG_VERBOSE , null ) ; } } else { realLog ( log , "Task \"" + task . getTaskName ( ) + "\" finished with error." , Project . MSG_ERR , event . getException ( ) ) ; } } } public void messageLogged ( BuildEvent event ) { if ( initialized ) { Object categoryObject = event . getTask ( ) ; String categoryString = null ; String categoryDetail = null ; if ( categoryObject == null ) { categoryObject = event . getTarget ( ) ; if ( categoryObject == null ) { categoryObject = event . getProject ( ) ; categoryString = PROJECT_LOG ; categoryDetail = event . getProject ( ) . getName ( ) ; } else { categoryString = TARGET_LOG ; categoryDetail = event . getTarget ( ) . getName ( ) ; } } else { if ( event . getTarget ( ) != null ) { categoryString = categoryObject . getClass ( ) . getName ( ) ; categoryDetail = event . getTarget ( ) . getName ( ) ; } else { categoryString = categoryObject . getClass ( ) . getName ( ) ; } } Log log = getLog ( categoryString , categoryDetail ) ; int priority = event . getPriority ( ) ; String message = event . getMessage ( ) ; realLog ( log , message , priority , null ) ; } } private void realLog ( Log log , String message , int priority , Throwable t ) { PrintStream tmpOut = System . out ; PrintStream tmpErr = System . err ; System . setOut ( out ) ; System . setErr ( err ) ; switch ( priority ) { case Project . MSG_ERR : if ( t == null ) { log . error ( message ) ; } else { log . error ( message , t ) ; } break ; case Project . MSG_WARN : if ( t == null ) { log . warn ( message ) ; } else { log . warn ( message , t ) ; } break ; case Project . MSG_INFO : if ( t == null ) { log . info ( message ) ; } else { log . info ( message , t ) ; } break ; case Project . MSG_VERBOSE : log . debug ( message ) ; break ; case Project . MSG_DEBUG : log . debug ( message ) ; break ; default : log . error ( message ) ; break ; } System . setOut ( tmpOut ) ; System . setErr ( tmpErr ) ; } PrintStream out = System . out ; PrintStream err = System . err ; public void setMessageOutputLevel ( int level ) { } public void setOutputPrintStream ( PrintStream output ) { this . out = output ; } public void setEmacsMode ( boolean emacsMode ) { } public void setErrorPrintStream ( PrintStream err ) { this . err = err ; } } 	0	['14', '1', '0', '10', '45', '3', '0', '10', '12', '0.576923077', '459', '0.333333333', '0', '0', '0.267857143', '0', '0', '31.35714286', '6', '2.7143', '0']
package org . apache . tools . ant ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . InvocationTargetException ; import java . io . InputStream ; import java . io . IOException ; import java . io . File ; import java . io . StringWriter ; import java . io . PrintWriter ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Properties ; import java . util . Set ; import java . util . Stack ; import org . apache . tools . ant . taskdefs . Typedef ; import org . apache . tools . ant . taskdefs . Definer ; import org . apache . tools . ant . launch . Launcher ; import org . apache . tools . ant . util . FileUtils ; public class ComponentHelper { private AntTypeTable antTypeTable ; private Hashtable taskClassDefinitions = new Hashtable ( ) ; private boolean rebuildTaskClassDefinitions = true ; private Hashtable typeClassDefinitions = new Hashtable ( ) ; private boolean rebuildTypeClassDefinitions = true ; private Set checkedNamespaces = new HashSet ( ) ; private Stack antLibStack = new Stack ( ) ; private String antLibCurrentUri = null ; private ComponentHelper next ; private Project project ; private static final String ERROR_NO_TASK_LIST_LOAD = "Can't load default task list" ; private static final String ERROR_NO_TYPE_LIST_LOAD = "Can't load default type list" ; public static final String COMPONENT_HELPER_REFERENCE = "ant.ComponentHelper" ; private static final String BUILD_SYSCLASSPATH_ONLY = "only" ; private static final String ANT_PROPERTY_TASK = "property" ; private static Properties [ ] defaultDefinitions = new Properties [ 2 ] ; public static ComponentHelper getComponentHelper ( Project project ) { if ( project == null ) { return null ; } ComponentHelper ph = ( ComponentHelper ) project . getReference ( COMPONENT_HELPER_REFERENCE ) ; if ( ph != null ) { return ph ; } ph = new ComponentHelper ( ) ; ph . setProject ( project ) ; project . addReference ( COMPONENT_HELPER_REFERENCE , ph ) ; return ph ; } protected ComponentHelper ( ) { } public void setNext ( ComponentHelper next ) { this . next = next ; } public ComponentHelper getNext ( ) { return next ; } public void setProject ( Project project ) { this . project = project ; antTypeTable = new AntTypeTable ( project ) ; } public void initSubProject ( ComponentHelper helper ) { AntTypeTable typeTable = helper . antTypeTable ; for ( Iterator i = typeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; antTypeTable . put ( def . getName ( ) , def ) ; } for ( Iterator i = helper . checkedNamespaces . iterator ( ) ; i . hasNext ( ) ; ) { checkedNamespaces . add ( i . next ( ) ) ; } } public Object createComponent ( UnknownElement ue , String ns , String componentType ) throws BuildException { Object component = createComponent ( componentType ) ; if ( component instanceof Task ) { Task task = ( Task ) component ; task . setLocation ( ue . getLocation ( ) ) ; task . setTaskType ( componentType ) ; task . setTaskName ( ue . getTaskName ( ) ) ; task . setOwningTarget ( ue . getOwningTarget ( ) ) ; task . init ( ) ; } return component ; } public Object createComponent ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; return ( def == null ) ? null : def . create ( project ) ; } public Class getComponentClass ( String componentName ) { AntTypeDefinition def = getDefinition ( componentName ) ; return ( def == null ) ? null : def . getExposedClass ( project ) ; } public AntTypeDefinition getDefinition ( String componentName ) { checkNamespace ( componentName ) ; return antTypeTable . getDefinition ( componentName ) ; } public void initDefaultDefinitions ( ) { initTasks ( ) ; initTypes ( ) ; } public void addTaskDefinition ( String taskName , Class taskClass ) { checkTaskClass ( taskClass ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( taskName ) ; def . setClassLoader ( taskClass . getClassLoader ( ) ) ; def . setClass ( taskClass ) ; def . setAdapterClass ( TaskAdapter . class ) ; def . setClassName ( taskClass . getName ( ) ) ; def . setAdaptToClass ( Task . class ) ; updateDataTypeDefinition ( def ) ; } public void checkTaskClass ( final Class taskClass ) throws BuildException { if ( ! Modifier . isPublic ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is not public" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( Modifier . isAbstract ( taskClass . getModifiers ( ) ) ) { final String message = taskClass + " is abstract" ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } try { taskClass . getConstructor ( ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { final String message = "No public no-arg constructor in " + taskClass ; project . log ( message , Project . MSG_ERR ) ; throw new BuildException ( message ) ; } if ( ! Task . class . isAssignableFrom ( taskClass ) ) { TaskAdapter . checkTaskClass ( taskClass , project ) ; } } public Hashtable getTaskDefinitions ( ) { synchronized ( taskClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTaskClassDefinitions ) { taskClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( Task . class . isAssignableFrom ( clazz ) ) { taskClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTaskClassDefinitions = false ; } } } return taskClassDefinitions ; } public Hashtable getDataTypeDefinitions ( ) { synchronized ( typeClassDefinitions ) { synchronized ( antTypeTable ) { if ( rebuildTypeClassDefinitions ) { typeClassDefinitions . clear ( ) ; for ( Iterator i = antTypeTable . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String name = ( String ) i . next ( ) ; Class clazz = antTypeTable . getExposedClass ( name ) ; if ( clazz == null ) { continue ; } if ( ! ( Task . class . isAssignableFrom ( clazz ) ) ) { typeClassDefinitions . put ( name , antTypeTable . getTypeClass ( name ) ) ; } } rebuildTypeClassDefinitions = false ; } } } return typeClassDefinitions ; } public void addDataTypeDefinition ( String typeName , Class typeClass ) { AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( typeName ) ; def . setClass ( typeClass ) ; updateDataTypeDefinition ( def ) ; project . log ( " +User datatype: " + typeName + "     " + typeClass . getName ( ) , Project . MSG_DEBUG ) ; } public void addDataTypeDefinition ( AntTypeDefinition def ) { updateDataTypeDefinition ( def ) ; } public Hashtable getAntTypeTable ( ) { return antTypeTable ; } public Task createTask ( String taskType ) throws BuildException { Task task = createNewTask ( taskType ) ; if ( task == null && taskType . equals ( ANT_PROPERTY_TASK ) ) { addTaskDefinition ( ANT_PROPERTY_TASK , org . apache . tools . ant . taskdefs . Property . class ) ; task = createNewTask ( taskType ) ; } return task ; } private Task createNewTask ( String taskType ) throws BuildException { Class c = getComponentClass ( taskType ) ; if ( c == null || ! ( Task . class . isAssignableFrom ( c ) ) ) { return null ; } Object obj = createComponent ( taskType ) ; if ( obj == null ) { return null ; } if ( ! ( obj instanceof Task ) ) { throw new BuildException ( "Expected a Task from '" + taskType + "' but got an instance of " + obj . getClass ( ) . getName ( ) + " instead" ) ; } Task task = ( Task ) obj ; task . setTaskType ( taskType ) ; task . setTaskName ( taskType ) ; project . log ( "   +Task: " + taskType , Project . MSG_DEBUG ) ; return task ; } public Object createDataType ( String typeName ) throws BuildException { return createComponent ( typeName ) ; } public String getElementName ( Object element ) { return getElementName ( element , false ) ; } public String getElementName ( Object o , boolean brief ) { Class elementClass = o . getClass ( ) ; String elementClassname = elementClass . getName ( ) ; for ( Iterator i = antTypeTable . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { AntTypeDefinition def = ( AntTypeDefinition ) i . next ( ) ; if ( elementClassname . equals ( def . getClassName ( ) ) && ( elementClass == def . getExposedClass ( project ) ) ) { String name = def . getName ( ) ; return brief ? name : "The <" + name + "> type" ; } } return getUnmappedElementName ( o . getClass ( ) , brief ) ; } public static String getElementName ( Project p , Object o , boolean brief ) { if ( p == null ) { p = getProject ( o ) ; } return p == null ? getUnmappedElementName ( o . getClass ( ) , brief ) : getComponentHelper ( p ) . getElementName ( o , brief ) ; } private static String getUnmappedElementName ( Class c , boolean brief ) { if ( brief ) { String name = c . getName ( ) ; return name . substring ( name . lastIndexOf ( '.' ) + 1 ) ; } return c . toString ( ) ; } private static Project getProject ( Object o ) { if ( o instanceof ProjectComponent ) { return ( ( ProjectComponent ) o ) . getProject ( ) ; } try { Method m = o . getClass ( ) . getMethod ( "getProject" , ( Class [ ] ) null ) ; if ( Project . class == m . getReturnType ( ) ) { return ( Project ) m . invoke ( o , ( Object [ ] ) null ) ; } } catch ( Exception e ) { } return null ; } private boolean validDefinition ( AntTypeDefinition def ) { return ! ( def . getTypeClass ( project ) == null || def . getExposedClass ( project ) == null ) ; } private boolean sameDefinition ( AntTypeDefinition def , AntTypeDefinition old ) { boolean defValid = validDefinition ( def ) ; boolean sameValidity = ( defValid == validDefinition ( old ) ) ; return sameValidity && ( ! defValid || def . sameDefinition ( old , project ) ) ; } private void updateDataTypeDefinition ( AntTypeDefinition def ) { String name = def . getName ( ) ; synchronized ( antTypeTable ) { rebuildTaskClassDefinitions = true ; rebuildTypeClassDefinitions = true ; AntTypeDefinition old = antTypeTable . getDefinition ( name ) ; if ( old != null ) { if ( sameDefinition ( def , old ) ) { return ; } Class oldClass = antTypeTable . getExposedClass ( name ) ; boolean isTask = ( oldClass != null && Task . class . isAssignableFrom ( oldClass ) ) ; project . log ( "Trying to override old definition of " + ( isTask ? "task " : "datatype " ) + name , ( def . similarDefinition ( old , project ) ) ? Project . MSG_VERBOSE : Project . MSG_WARN ) ; } project . log ( " +Datatype " + name + " " + def . getClassName ( ) , Project . MSG_DEBUG ) ; antTypeTable . put ( name , def ) ; } } public void enterAntLib ( String uri ) { antLibCurrentUri = uri ; antLibStack . push ( uri ) ; } public String getCurrentAntlibUri ( ) { return antLibCurrentUri ; } public void exitAntLib ( ) { antLibStack . pop ( ) ; antLibCurrentUri = ( antLibStack . size ( ) == 0 ) ? null : ( String ) antLibStack . peek ( ) ; } private void initTasks ( ) { ClassLoader classLoader = getClassLoader ( null ) ; Properties props = getDefaultDefinitions ( false ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; def . setAdaptToClass ( Task . class ) ; def . setAdapterClass ( TaskAdapter . class ) ; antTypeTable . put ( name , def ) ; } } private ClassLoader getClassLoader ( ClassLoader classLoader ) { String buildSysclasspath = project . getProperty ( MagicNames . BUILD_SYSCLASSPATH ) ; if ( project . getCoreLoader ( ) != null && ! ( BUILD_SYSCLASSPATH_ONLY . equals ( buildSysclasspath ) ) ) { classLoader = project . getCoreLoader ( ) ; } return classLoader ; } private static synchronized Properties getDefaultDefinitions ( boolean type ) throws BuildException { int idx = type ? 1 : 0 ; if ( defaultDefinitions [ idx ] == null ) { String resource = type ? MagicNames . TYPEDEFS_PROPERTIES_RESOURCE : MagicNames . TASKDEF_PROPERTIES_RESOURCE ; String errorString = type ? ERROR_NO_TYPE_LIST_LOAD : ERROR_NO_TASK_LIST_LOAD ; InputStream in = null ; try { in = ComponentHelper . class . getResourceAsStream ( resource ) ; if ( in == null ) { throw new BuildException ( errorString ) ; } Properties p = new Properties ( ) ; p . load ( in ) ; defaultDefinitions [ idx ] = p ; } catch ( IOException e ) { throw new BuildException ( errorString , e ) ; } finally { FileUtils . close ( in ) ; } } return defaultDefinitions [ idx ] ; } private void initTypes ( ) { ClassLoader classLoader = getClassLoader ( null ) ; Properties props = getDefaultDefinitions ( true ) ; Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String name = ( String ) e . nextElement ( ) ; String className = props . getProperty ( name ) ; AntTypeDefinition def = new AntTypeDefinition ( ) ; def . setName ( name ) ; def . setClassName ( className ) ; def . setClassLoader ( classLoader ) ; antTypeTable . put ( name , def ) ; } } private synchronized void checkNamespace ( String componentName ) { String uri = ProjectHelper . extractUriFromComponentName ( componentName ) ; if ( "" . equals ( uri ) ) { uri = ProjectHelper . ANT_CORE_URI ; } if ( ! uri . startsWith ( ProjectHelper . ANTLIB_URI ) ) { return ; } if ( checkedNamespaces . contains ( uri ) ) { return ; } checkedNamespaces . add ( uri ) ; Typedef definer = new Typedef ( ) ; definer . setProject ( project ) ; definer . init ( ) ; definer . setURI ( uri ) ; definer . setTaskName ( uri ) ; definer . setResource ( Definer . makeResourceFromURI ( uri ) ) ; definer . setOnError ( new Typedef . OnError ( Typedef . OnError . POLICY_IGNORE ) ) ; definer . execute ( ) ; } public String diagnoseCreationFailure ( String componentName , String type ) { StringWriter errorText = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( errorText ) ; out . println ( "Problem: failed to create " + type + " " + componentName ) ; boolean lowlevel = false ; boolean jars = false ; boolean definitions = false ; boolean antTask ; String home = System . getProperty ( Launcher . USER_HOMEDIR ) ; File libDir = new File ( home , Launcher . USER_LIBDIR ) ; String antHomeLib ; boolean probablyIDE = false ; String anthome = System . getProperty ( MagicNames . ANT_HOME ) ; if ( anthome != null ) { File antHomeLibDir = new File ( anthome , "lib" ) ; antHomeLib = antHomeLibDir . getAbsolutePath ( ) ; } else { probablyIDE = true ; antHomeLib = "ANT_HOME" + File . separatorChar + "lib" ; } StringBuffer dirListingText = new StringBuffer ( ) ; final String tab = "        -" ; dirListingText . append ( tab ) ; dirListingText . append ( antHomeLib ) ; dirListingText . append ( '\n' ) ; if ( probablyIDE ) { dirListingText . append ( tab ) ; dirListingText . append ( "the IDE Ant configuration dialogs" ) ; } else { dirListingText . append ( tab ) ; dirListingText . append ( libDir ) ; dirListingText . append ( '\n' ) ; dirListingText . append ( tab ) ; dirListingText . append ( "a directory added on the command line with the -lib argument" ) ; } String dirListing = dirListingText . toString ( ) ; AntTypeDefinition def = getDefinition ( componentName ) ; if ( def == null ) { boolean isAntlib = componentName . indexOf ( MagicNames . ANTLIB_PREFIX ) == 0 ; out . println ( "Cause: The name is undefined." ) ; out . println ( "Action: Check the spelling." ) ; out . println ( "Action: Check that any custom tasks/types have been declared." ) ; out . println ( "Action: Check that any <presetdef>/<macrodef>" + " declarations have taken place." ) ; if ( isAntlib ) { out . println ( ) ; out . println ( "This appears to be an antlib declaration. " ) ; out . println ( "Action: Check that the implementing library exists in one of:" ) ; out . println ( dirListing ) ; } definitions = true ; } else { final String classname = def . getClassName ( ) ; antTask = classname . startsWith ( "org.apache.tools.ant." ) ; boolean optional = classname . startsWith ( "org.apache.tools.ant.taskdefs.optional" ) ; optional |= classname . startsWith ( "org.apache.tools.ant.types.optional" ) ; Class clazz = null ; try { clazz = def . innerGetTypeClass ( ) ; } catch ( ClassNotFoundException e ) { out . println ( "Cause: the class " + classname + " was not found." ) ; jars = true ; if ( optional ) { out . println ( "        This looks like one of Ant's optional components." ) ; out . println ( "Action: Check that the appropriate optional JAR exists in" ) ; out . println ( dirListing ) ; } else { out . println ( "Action: Check that the component has been correctly declared" ) ; out . println ( "        and that the implementing JAR is in one of:" ) ; out . println ( dirListing ) ; definitions = true ; } } catch ( NoClassDefFoundError ncdfe ) { jars = true ; out . println ( "Cause: Could not load a dependent class " + ncdfe . getMessage ( ) ) ; if ( optional ) { out . println ( "       It is not enough to have Ant's optional JARs" ) ; out . println ( "       you need the JAR files that the" + " optional tasks depend upon." ) ; out . println ( "       Ant's optional task dependencies are" + " listed in the manual." ) ; } else { out . println ( "       This class may be in a separate JAR" + " that is not installed." ) ; } out . println ( "Action: Determine what extra JAR files are" + " needed, and place them in one of:" ) ; out . println ( dirListing ) ; } if ( clazz != null ) { try { def . innerCreateAndSet ( clazz , project ) ; out . println ( "The component could be instantiated." ) ; } catch ( NoSuchMethodException e ) { lowlevel = true ; out . println ( "Cause: The class " + classname + " has no compatible constructor." ) ; } catch ( InstantiationException e ) { lowlevel = true ; out . println ( "Cause: The class " + classname + " is abstract and cannot be instantiated." ) ; } catch ( IllegalAccessException e ) { lowlevel = true ; out . println ( "Cause: The constructor for " + classname + " is private and cannot be invoked." ) ; } catch ( InvocationTargetException ex ) { lowlevel = true ; Throwable t = ex . getTargetException ( ) ; out . println ( "Cause: The constructor threw the exception" ) ; out . println ( t . toString ( ) ) ; t . printStackTrace ( out ) ; } catch ( NoClassDefFoundError ncdfe ) { jars = true ; out . println ( "Cause:  A class needed by class " + classname + " cannot be found: " ) ; out . println ( "       " + ncdfe . getMessage ( ) ) ; out . println ( "Action: Determine what extra JAR files are" + " needed, and place them in:" ) ; out . println ( dirListing ) ; } } out . println ( ) ; out . println ( "Do not panic, this is a common problem." ) ; if ( definitions ) { out . println ( "It may just be a typographical error in the build file " + "or the task/type declaration." ) ; } if ( jars ) { out . println ( "The commonest cause is a missing JAR." ) ; } if ( lowlevel ) { out . println ( "This is quite a low level problem, which may need " + "consultation with the author of the task." ) ; if ( antTask ) { out . println ( "This may be the Ant team. Please file a " + "defect or contact the developer team." ) ; } else { out . println ( "This does not appear to be a task bundled with Ant." ) ; out . println ( "Please take it up with the supplier of the third-party " + type + "." ) ; out . println ( "If you have written it yourself, you probably have a bug to fix." ) ; } } else { out . println ( ) ; out . println ( "This is not a bug; it is a configuration problem" ) ; } } out . flush ( ) ; out . close ( ) ; return errorText . toString ( ) ; } private static class AntTypeTable extends Hashtable { private Project project ; AntTypeTable ( Project project ) { this . project = project ; } AntTypeDefinition getDefinition ( String key ) { return ( AntTypeDefinition ) ( super . get ( key ) ) ; } public Object get ( Object key ) { return getTypeClass ( ( String ) key ) ; } Object create ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . create ( project ) ; } Class getTypeClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . getTypeClass ( project ) ; } Class getExposedClass ( String name ) { AntTypeDefinition def = getDefinition ( name ) ; return ( def == null ) ? null : def . getExposedClass ( project ) ; } public boolean contains ( Object clazz ) { boolean found = false ; if ( clazz instanceof Class ) { for ( Iterator i = values ( ) . iterator ( ) ; i . hasNext ( ) && ! found ; ) { found |= ( ( ( AntTypeDefinition ) ( i . next ( ) ) ) . getExposedClass ( project ) == clazz ) ; } } return found ; } public boolean containsValue ( Object value ) { return contains ( value ) ; } } } 	0	['39', '1', '0', '26', '154', '449', '13', '16', '26', '0.878446115', '1711', '0.714285714', '3', '0', '0.178947368', '0', '0', '42.33333333', '13', '2.5641', '0']
package org . apache . tools . mail ; import java . io . InputStream ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class SmtpResponseReader { protected BufferedReader reader = null ; private StringBuffer result = new StringBuffer ( ) ; public SmtpResponseReader ( InputStream in ) { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } public String getResponse ( ) throws IOException { result . setLength ( 0 ) ; String line = reader . readLine ( ) ; if ( line != null && line . length ( ) >= 3 ) { result . append ( line . substring ( 0 , 3 ) ) ; result . append ( " " ) ; } while ( line != null ) { append ( line ) ; if ( ! hasMoreLines ( line ) ) { break ; } line = reader . readLine ( ) ; } return result . toString ( ) . trim ( ) ; } public void close ( ) throws IOException { reader . close ( ) ; } protected boolean hasMoreLines ( String line ) { return line . length ( ) > 3 && line . charAt ( 3 ) == '-' ; } private void append ( String line ) { if ( line . length ( ) > 4 ) { result . append ( line . substring ( 4 ) ) ; result . append ( " " ) ; } } } 	0	['5', '1', '0', '1', '19', '0', '1', '0', '3', '0.5', '108', '1', '0', '0', '0.533333333', '0', '0', '20.2', '3', '1.4', '0']
package org . apache . tools . ant . filters ; import java . io . IOException ; import java . io . Reader ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . condition . Os ; import org . apache . tools . ant . types . EnumeratedAttribute ; public final class FixCrLfFilter extends BaseParamFilterReader implements ChainableReader { private static final char CTRLZ = '' ; private int tabLength = 8 ; private CrLf eol ; private AddAsisRemove ctrlz ; private AddAsisRemove tabs ; private boolean javafiles = false ; private boolean fixlast = true ; private boolean initialized = false ; public FixCrLfFilter ( ) { super ( ) ; } public FixCrLfFilter ( final Reader in ) throws IOException { super ( in ) ; } { tabs = AddAsisRemove . ASIS ; if ( Os . isFamily ( "mac" ) && ! Os . isFamily ( "unix" ) ) { ctrlz = AddAsisRemove . REMOVE ; setEol ( CrLf . MAC ) ; } else if ( Os . isFamily ( "dos" ) ) { ctrlz = AddAsisRemove . ASIS ; setEol ( CrLf . DOS ) ; } else { ctrlz = AddAsisRemove . REMOVE ; setEol ( CrLf . UNIX ) ; } } public Reader chain ( final Reader rdr ) { try { FixCrLfFilter newFilter = new FixCrLfFilter ( rdr ) ; newFilter . setJavafiles ( getJavafiles ( ) ) ; newFilter . setEol ( getEol ( ) ) ; newFilter . setTab ( getTab ( ) ) ; newFilter . setTablength ( getTablength ( ) ) ; newFilter . setEof ( getEof ( ) ) ; newFilter . setFixlast ( getFixlast ( ) ) ; newFilter . initInternalFilters ( ) ; return newFilter ; } catch ( IOException e ) { throw new BuildException ( e ) ; } } public AddAsisRemove getEof ( ) { return ctrlz . newInstance ( ) ; } public CrLf getEol ( ) { return eol . newInstance ( ) ; } public boolean getFixlast ( ) { return fixlast ; } public boolean getJavafiles ( ) { return javafiles ; } public AddAsisRemove getTab ( ) { return tabs . newInstance ( ) ; } public int getTablength ( ) { return tabLength ; } private static String calculateEolString ( CrLf eol ) { if ( eol == CrLf . ASIS ) { return System . getProperty ( "line.separator" ) ; } if ( eol == CrLf . CR || eol == CrLf . MAC ) { return "\r" ; } if ( eol == CrLf . CRLF || eol == CrLf . DOS ) { return "\r\n" ; } return "\n" ; } private void initInternalFilters ( ) { in = ( ctrlz == AddAsisRemove . REMOVE ) ? new RemoveEofFilter ( in ) : in ; in = new NormalizeEolFilter ( in , calculateEolString ( eol ) , getFixlast ( ) ) ; if ( tabs != AddAsisRemove . ASIS ) { if ( getJavafiles ( ) ) { in = new MaskJavaTabLiteralsFilter ( in ) ; } in = ( tabs == AddAsisRemove . ADD ) ? ( Reader ) new AddTabFilter ( in , getTablength ( ) ) : ( Reader ) new RemoveTabFilter ( in , getTablength ( ) ) ; } in = ( ctrlz == AddAsisRemove . ADD ) ? new AddEofFilter ( in ) : in ; initialized = true ; } public synchronized int read ( ) throws IOException { if ( ! initialized ) { initInternalFilters ( ) ; } return in . read ( ) ; } public void setEof ( AddAsisRemove attr ) { ctrlz = attr . resolve ( ) ; } public void setEol ( CrLf attr ) { eol = attr . resolve ( ) ; } public void setFixlast ( boolean fixlast ) { this . fixlast = fixlast ; } public void setJavafiles ( boolean javafiles ) { this . javafiles = javafiles ; } public void setTab ( AddAsisRemove attr ) { tabs = attr . resolve ( ) ; } public void setTablength ( int tabLength ) throws IOException { if ( tabLength < 2 || tabLength > 80 ) { throw new IOException ( "tablength must be between 2 and 80" ) ; } this . tabLength = tabLength ; } private static class SimpleFilterReader extends Reader { private Reader in ; private int [ ] preempt = new int [ 16 ] ; private int preemptIndex = 0 ; public SimpleFilterReader ( Reader in ) { this . in = in ; } public void push ( char c ) { push ( ( int ) c ) ; } public void push ( int c ) { try { preempt [ preemptIndex ++ ] = c ; } catch ( ArrayIndexOutOfBoundsException e ) { int [ ] p2 = new int [ preempt . length * 2 ] ; System . arraycopy ( preempt , 0 , p2 , 0 , preempt . length ) ; preempt = p2 ; push ( c ) ; } } public void push ( char [ ] cs , int start , int length ) { for ( int i = start + length - 1 ; i >= start ; ) { push ( cs [ i -- ] ) ; } } public void push ( char [ ] cs ) { push ( cs , 0 , cs . length ) ; } public void push ( String s ) { push ( s . toCharArray ( ) ) ; } public boolean editsBlocked ( ) { return in instanceof SimpleFilterReader && ( ( SimpleFilterReader ) in ) . editsBlocked ( ) ; } public int read ( ) throws java . io . IOException { return preemptIndex > 0 ? preempt [ -- preemptIndex ] : in . read ( ) ; } public void close ( ) throws java . io . IOException { in . close ( ) ; } public void reset ( ) throws IOException { in . reset ( ) ; } public boolean markSupported ( ) { return in . markSupported ( ) ; } public boolean ready ( ) throws java . io . IOException { return in . ready ( ) ; } public void mark ( int i ) throws java . io . IOException { in . mark ( i ) ; } public long skip ( long i ) throws java . io . IOException { return in . skip ( i ) ; } public int read ( char [ ] buf ) throws java . io . IOException { return read ( buf , 0 , buf . length ) ; } public int read ( char [ ] buf , int start , int length ) throws java . io . IOException { int count = 0 ; int c = 0 ; while ( length -- > 0 && ( c = this . read ( ) ) != - 1 ) { buf [ start ++ ] = ( char ) c ; count ++ ; } return ( count == 0 && c == - 1 ) ? - 1 : count ; } } private static class MaskJavaTabLiteralsFilter extends SimpleFilterReader { private boolean editsBlocked = false ; private static final int JAVA = 1 ; private static final int IN_CHAR_CONST = 2 ; private static final int IN_STR_CONST = 3 ; private static final int IN_SINGLE_COMMENT = 4 ; private static final int IN_MULTI_COMMENT = 5 ; private static final int TRANS_TO_COMMENT = 6 ; private static final int TRANS_FROM_MULTI = 8 ; private int state ; public MaskJavaTabLiteralsFilter ( Reader in ) { super ( in ) ; state = JAVA ; } public boolean editsBlocked ( ) { return editsBlocked || super . editsBlocked ( ) ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; editsBlocked = ( state == IN_CHAR_CONST || state == IN_STR_CONST ) ; switch ( state ) { case JAVA : switch ( thisChar ) { case '\'' : state = IN_CHAR_CONST ; break ; case '"' : state = IN_STR_CONST ; break ; case '/' : state = TRANS_TO_COMMENT ; break ; default : } break ; case IN_CHAR_CONST : switch ( thisChar ) { case '\'' : state = JAVA ; break ; default : } break ; case IN_STR_CONST : switch ( thisChar ) { case '"' : state = JAVA ; break ; default : } break ; case IN_SINGLE_COMMENT : switch ( thisChar ) { case '\n' : case '\r' : state = JAVA ; break ; default : } break ; case IN_MULTI_COMMENT : switch ( thisChar ) { case '*' : state = TRANS_FROM_MULTI ; break ; default : } break ; case TRANS_TO_COMMENT : switch ( thisChar ) { case '*' : state = IN_MULTI_COMMENT ; break ; case '/' : state = IN_SINGLE_COMMENT ; break ; case '\'' : state = IN_CHAR_CONST ; break ; case '"' : state = IN_STR_CONST ; break ; default : state = JAVA ; } break ; case TRANS_FROM_MULTI : switch ( thisChar ) { case '/' : state = JAVA ; break ; default : } break ; default : } return thisChar ; } } private static class NormalizeEolFilter extends SimpleFilterReader { private boolean previousWasEOL ; private boolean fixLast ; private int normalizedEOL = 0 ; private char [ ] eol = null ; public NormalizeEolFilter ( Reader in , String eolString , boolean fixLast ) { super ( in ) ; eol = eolString . toCharArray ( ) ; this . fixLast = fixLast ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; if ( normalizedEOL == 0 ) { int numEOL = 0 ; boolean atEnd = false ; switch ( thisChar ) { case CTRLZ : int c = super . read ( ) ; if ( c == - 1 ) { atEnd = true ; if ( fixLast && ! previousWasEOL ) { numEOL = 1 ; push ( thisChar ) ; } } else { push ( c ) ; } break ; case - 1 : atEnd = true ; if ( fixLast && ! previousWasEOL ) { numEOL = 1 ; } break ; case '\n' : numEOL = 1 ; break ; case '\r' : numEOL = 1 ; int c1 = super . read ( ) ; int c2 = super . read ( ) ; if ( c1 == '\r' && c2 == '\n' ) { } else if ( c1 == '\r' ) { numEOL = 2 ; push ( c2 ) ; } else if ( c1 == '\n' ) { push ( c2 ) ; } else { push ( c2 ) ; push ( c1 ) ; } default : } if ( numEOL > 0 ) { while ( numEOL -- > 0 ) { push ( eol ) ; normalizedEOL += eol . length ; } previousWasEOL = true ; thisChar = read ( ) ; } else if ( ! atEnd ) { previousWasEOL = false ; } } else { normalizedEOL -- ; } return thisChar ; } } private static class AddEofFilter extends SimpleFilterReader { private int lastChar = - 1 ; public AddEofFilter ( Reader in ) { super ( in ) ; } public int read ( ) throws IOException { int thisChar = super . read ( ) ; if ( thisChar == - 1 ) { if ( lastChar != CTRLZ ) { lastChar = CTRLZ ; return lastChar ; } } else { lastChar = thisChar ; } return thisChar ; } } private static class RemoveEofFilter extends SimpleFilterReader { private int lookAhead = - 1 ; public RemoveEofFilter ( Reader in ) { super ( in ) ; try { lookAhead = in . read ( ) ; } catch ( IOException e ) { lookAhead = - 1 ; } } public int read ( ) throws IOException { int lookAhead2 = super . read ( ) ; if ( lookAhead2 == - 1 && lookAhead == CTRLZ ) { return - 1 ; } int i = lookAhead ; lookAhead = lookAhead2 ; return i ; } } private static class AddTabFilter extends SimpleFilterReader { private int columnNumber = 0 ; private int tabLength = 0 ; public AddTabFilter ( Reader in , int tabLength ) { super ( in ) ; this . tabLength = tabLength ; } public int read ( ) throws IOException { int c = super . read ( ) ; switch ( c ) { case '\r' : case '\n' : columnNumber = 0 ; break ; case ' ' : columnNumber ++ ; if ( ! editsBlocked ( ) ) { int colNextTab = ( ( columnNumber + tabLength - 1 ) / tabLength ) * tabLength ; int countSpaces = 1 ; int numTabs = 0 ; scanWhitespace : while ( ( c = super . read ( ) ) != - 1 ) { switch ( c ) { case ' ' : if ( ++ columnNumber == colNextTab ) { numTabs ++ ; countSpaces = 0 ; colNextTab += tabLength ; } else { countSpaces ++ ; } break ; case '\t' : columnNumber = colNextTab ; numTabs ++ ; countSpaces = 0 ; colNextTab += tabLength ; break ; default : push ( c ) ; break scanWhitespace ; } } while ( countSpaces -- > 0 ) { push ( ' ' ) ; columnNumber -- ; } while ( numTabs -- > 0 ) { push ( '\t' ) ; columnNumber -= tabLength ; } c = super . read ( ) ; switch ( c ) { case ' ' : columnNumber ++ ; break ; case '\t' : columnNumber += tabLength ; break ; default : } } break ; case '\t' : columnNumber = ( ( columnNumber + tabLength - 1 ) / tabLength ) * tabLength ; break ; default : columnNumber ++ ; } return c ; } } private static class RemoveTabFilter extends SimpleFilterReader { private int columnNumber = 0 ; private int tabLength = 0 ; public RemoveTabFilter ( Reader in , int tabLength ) { super ( in ) ; this . tabLength = tabLength ; } public int read ( ) throws IOException { int c = super . read ( ) ; switch ( c ) { case '\r' : case '\n' : columnNumber = 0 ; break ; case '\t' : int width = tabLength - columnNumber % tabLength ; if ( ! editsBlocked ( ) ) { for ( ; width > 1 ; width -- ) { push ( ' ' ) ; } c = ' ' ; } columnNumber += width ; break ; default : columnNumber ++ ; } return c ; } } public static class AddAsisRemove extends EnumeratedAttribute { private static final AddAsisRemove ASIS = newInstance ( "asis" ) ; private static final AddAsisRemove ADD = newInstance ( "add" ) ; private static final AddAsisRemove REMOVE = newInstance ( "remove" ) ; public String [ ] getValues ( ) { return new String [ ] { "add" , "asis" , "remove" } ; } public boolean equals ( Object other ) { return other instanceof AddAsisRemove && getIndex ( ) == ( ( AddAsisRemove ) other ) . getIndex ( ) ; } public int hashCode ( ) { return getIndex ( ) ; } AddAsisRemove resolve ( ) throws IllegalStateException { if ( this . equals ( ASIS ) ) { return ASIS ; } if ( this . equals ( ADD ) ) { return ADD ; } if ( this . equals ( REMOVE ) ) { return REMOVE ; } throw new IllegalStateException ( "No replacement for " + this ) ; } private AddAsisRemove newInstance ( ) { return newInstance ( getValue ( ) ) ; } public static AddAsisRemove newInstance ( String value ) { AddAsisRemove a = new AddAsisRemove ( ) ; a . setValue ( value ) ; return a ; } } public static class CrLf extends EnumeratedAttribute { private static final CrLf ASIS = newInstance ( "asis" ) ; private static final CrLf CR = newInstance ( "cr" ) ; private static final CrLf CRLF = newInstance ( "crlf" ) ; private static final CrLf DOS = newInstance ( "dos" ) ; private static final CrLf LF = newInstance ( "lf" ) ; private static final CrLf MAC = newInstance ( "mac" ) ; private static final CrLf UNIX = newInstance ( "unix" ) ; public String [ ] getValues ( ) { return new String [ ] { "asis" , "cr" , "lf" , "crlf" , "mac" , "unix" , "dos" } ; } public boolean equals ( Object other ) { return other instanceof CrLf && getIndex ( ) == ( ( CrLf ) other ) . getIndex ( ) ; } public int hashCode ( ) { return getIndex ( ) ; } CrLf resolve ( ) { if ( this . equals ( ASIS ) ) { return ASIS ; } if ( this . equals ( CR ) || this . equals ( MAC ) ) { return CR ; } if ( this . equals ( CRLF ) || this . equals ( DOS ) ) { return CRLF ; } if ( this . equals ( LF ) || this . equals ( UNIX ) ) { return LF ; } throw new IllegalStateException ( "No replacement for " + this ) ; } private CrLf newInstance ( ) { return newInstance ( getValue ( ) ) ; } public static CrLf newInstance ( String value ) { CrLf c = new CrLf ( ) ; c . setValue ( value ) ; return c ; } } } 	0	['18', '5', '0', '14', '44', '77', '2', '12', '16', '0.713235294', '331', '1', '3', '0.636363636', '0.240740741', '2', '8', '16.94444444', '6', '1.4444', '0']
package org . apache . tools . ant . taskdefs ; import java . io . File ; import java . util . Enumeration ; import java . util . Vector ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Task ; import org . apache . tools . ant . types . Environment ; import org . apache . tools . ant . types . FileSet ; import org . apache . tools . ant . types . Path ; import org . apache . tools . ant . types . RedirectorElement ; import org . apache . tools . ant . util . JavaEnvUtils ; public abstract class AbstractJarSignerTask extends Task { protected File jar ; protected String alias ; protected String keystore ; protected String storepass ; protected String storetype ; protected String keypass ; protected boolean verbose ; protected String maxMemory ; protected Vector filesets = new Vector ( ) ; protected static final String JARSIGNER_COMMAND = "jarsigner" ; private RedirectorElement redirector ; private Environment sysProperties = new Environment ( ) ; public static final String ERROR_NO_SOURCE = "jar must be set through jar attribute " + "or nested filesets" ; private Path path = null ; public void setMaxmemory ( String max ) { maxMemory = max ; } public void setJar ( final File jar ) { this . jar = jar ; } public void setAlias ( final String alias ) { this . alias = alias ; } public void setKeystore ( final String keystore ) { this . keystore = keystore ; } public void setStorepass ( final String storepass ) { this . storepass = storepass ; } public void setStoretype ( final String storetype ) { this . storetype = storetype ; } public void setKeypass ( final String keypass ) { this . keypass = keypass ; } public void setVerbose ( final boolean verbose ) { this . verbose = verbose ; } public void addFileset ( final FileSet set ) { filesets . addElement ( set ) ; } public void addSysproperty ( Environment . Variable sysp ) { sysProperties . addVariable ( sysp ) ; } public Path createPath ( ) { if ( path == null ) { path = new Path ( getProject ( ) ) ; } return path . createPath ( ) ; } protected void beginExecution ( ) { redirector = createRedirector ( ) ; } protected void endExecution ( ) { redirector = null ; } private RedirectorElement createRedirector ( ) { RedirectorElement result = new RedirectorElement ( ) ; if ( storepass != null ) { StringBuffer input = new StringBuffer ( storepass ) . append ( '\n' ) ; if ( keypass != null ) { input . append ( keypass ) . append ( '\n' ) ; } result . setInputString ( input . toString ( ) ) ; result . setLogInputString ( false ) ; } return result ; } public RedirectorElement getRedirector ( ) { return redirector ; } protected void setCommonOptions ( final ExecTask cmd ) { if ( maxMemory != null ) { addValue ( cmd , "-J-Xmx" + maxMemory ) ; } if ( verbose ) { addValue ( cmd , "-verbose" ) ; } Vector props = sysProperties . getVariablesVector ( ) ; Enumeration e = props . elements ( ) ; while ( e . hasMoreElements ( ) ) { Environment . Variable variable = ( Environment . Variable ) e . nextElement ( ) ; declareSysProperty ( cmd , variable ) ; } } protected void declareSysProperty ( ExecTask cmd , Environment . Variable property ) throws BuildException { addValue ( cmd , "-J-D" + property . getContent ( ) ) ; } protected void bindToKeystore ( final ExecTask cmd ) { if ( null != keystore ) { addValue ( cmd , "-keystore" ) ; String loc ; File keystoreFile = getProject ( ) . resolveFile ( keystore ) ; if ( keystoreFile . exists ( ) ) { loc = keystoreFile . getPath ( ) ; } else { loc = keystore ; } addValue ( cmd , loc ) ; } if ( null != storetype ) { addValue ( cmd , "-storetype" ) ; addValue ( cmd , storetype ) ; } } protected ExecTask createJarSigner ( ) { final ExecTask cmd = new ExecTask ( this ) ; cmd . setExecutable ( JavaEnvUtils . getJdkExecutable ( JARSIGNER_COMMAND ) ) ; cmd . setTaskType ( JARSIGNER_COMMAND ) ; cmd . setFailonerror ( true ) ; cmd . addConfiguredRedirector ( redirector ) ; return cmd ; } protected Vector createUnifiedSources ( ) { Vector sources = ( Vector ) filesets . clone ( ) ; if ( jar != null ) { FileSet sourceJar = new FileSet ( ) ; sourceJar . setProject ( getProject ( ) ) ; sourceJar . setFile ( jar ) ; sourceJar . setDir ( jar . getParentFile ( ) ) ; sources . add ( sourceJar ) ; } return sources ; } protected Path createUnifiedSourcePath ( ) { Path p = path == null ? new Path ( getProject ( ) ) : ( Path ) path . clone ( ) ; Vector s = createUnifiedSources ( ) ; Enumeration e = s . elements ( ) ; while ( e . hasMoreElements ( ) ) { p . add ( ( FileSet ) e . nextElement ( ) ) ; } return p ; } protected boolean hasResources ( ) { return path != null || filesets . size ( ) > 0 ; } protected void addValue ( final ExecTask cmd , String value ) { cmd . createArg ( ) . setValue ( value ) ; } } 	0	['24', '3', '2', '14', '65', '222', '2', '12', '13', '0.937888199', '348', '0.928571429', '3', '0.616666667', '0.238095238', '0', '0', '12.91666667', '4', '1.5417', '0']
package org . apache . tools . ant . taskdefs . optional . ejb ; import java . io . File ; import java . util . Hashtable ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . Project ; public class JbossDeploymentTool extends GenericDeploymentTool { protected static final String JBOSS_DD = "jboss.xml" ; protected static final String JBOSS_CMP10D = "jaws.xml" ; protected static final String JBOSS_CMP20D = "jbosscmp-jdbc.xml" ; private String jarSuffix = ".jar" ; public void setSuffix ( String inString ) { jarSuffix = inString ; } protected void addVendorFiles ( Hashtable ejbFiles , String ddPrefix ) { File jbossDD = new File ( getConfig ( ) . descriptorDir , ddPrefix + JBOSS_DD ) ; if ( jbossDD . exists ( ) ) { ejbFiles . put ( META_DIR + JBOSS_DD , jbossDD ) ; } else { log ( "Unable to locate jboss deployment descriptor. " + "It was expected to be in " + jbossDD . getPath ( ) , Project . MSG_WARN ) ; return ; } String descriptorFileName = JBOSS_CMP10D ; if ( EjbJar . CMPVersion . CMP2_0 . equals ( getParent ( ) . getCmpversion ( ) ) ) { descriptorFileName = JBOSS_CMP20D ; } File jbossCMPD = new File ( getConfig ( ) . descriptorDir , ddPrefix + descriptorFileName ) ; if ( jbossCMPD . exists ( ) ) { ejbFiles . put ( META_DIR + descriptorFileName , jbossCMPD ) ; } else { log ( "Unable to locate jboss cmp descriptor. " + "It was expected to be in " + jbossCMPD . getPath ( ) , Project . MSG_VERBOSE ) ; return ; } } File getVendorOutputJarFile ( String baseName ) { if ( getDestDir ( ) == null && getParent ( ) . getDestdir ( ) == null ) { throw new BuildException ( "DestDir not specified" ) ; } if ( getDestDir ( ) == null ) { return new File ( getParent ( ) . getDestdir ( ) , baseName + jarSuffix ) ; } else { return new File ( getDestDir ( ) , baseName + jarSuffix ) ; } } public void validateConfigured ( ) throws BuildException { } private EjbJar getParent ( ) { return ( EjbJar ) this . getTask ( ) ; } } 	0	['6', '2', '0', '5', '23', '9', '1', '5', '3', '1.05', '160', '1', '0', '0.864864865', '0.555555556', '2', '3', '25', '4', '1.8333', '0']
package org . apache . tools . ant . taskdefs . optional . perforce ; import org . apache . tools . ant . BuildException ; public class P4Reopen extends P4Base { private String toChange = "" ; public void setToChange ( String toChange ) throws BuildException { if ( toChange == null || toChange . equals ( "" ) ) { throw new BuildException ( "P4Reopen: tochange cannot be null or empty" ) ; } this . toChange = toChange ; } public void execute ( ) throws BuildException { if ( P4View == null ) { throw new BuildException ( "No view specified to reopen" ) ; } execP4Command ( "-s reopen -c " + toChange + " " + P4View , new SimpleP4OutputHandler ( this ) ) ; } } 	0	['3', '4', '0', '4', '11', '0', '0', '4', '3', '0', '53', '1', '0', '0.962264151', '0.666666667', '1', '1', '16.33333333', '1', '0.6667', '0']
package org . apache . tools . ant . types . selectors ; import java . io . File ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public abstract class BaseSelector extends DataType implements FileSelector { private String errmsg = null ; public BaseSelector ( ) { } public void setError ( String msg ) { if ( errmsg == null ) { errmsg = msg ; } } public String getError ( ) { return errmsg ; } public void verifySettings ( ) { if ( isReference ( ) ) { ( ( BaseSelector ) getCheckedRef ( ) ) . verifySettings ( ) ; } } public void validate ( ) { if ( getError ( ) == null ) { verifySettings ( ) ; } if ( getError ( ) != null ) { throw new BuildException ( errmsg ) ; } } public abstract boolean isSelected ( File basedir , String filename , File file ) ; } 	0	['6', '3', '6', '10', '10', '3', '7', '3', '6', '0.4', '46', '1', '0', '0.857142857', '0.5', '0', '0', '6.5', '3', '1.5', '0']
package org . apache . tools . ant . types . resources . selectors ; import java . util . Stack ; import java . util . Vector ; import java . util . Iterator ; import java . util . Collections ; import org . apache . tools . ant . Project ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . types . DataType ; public class ResourceSelectorContainer extends DataType { private Vector v = new Vector ( ) ; public ResourceSelectorContainer ( ) { } public ResourceSelectorContainer ( ResourceSelector [ ] r ) { for ( int i = 0 ; i < r . length ; i ++ ) { add ( r [ i ] ) ; } } public void add ( ResourceSelector s ) { if ( isReference ( ) ) { throw noChildrenAllowed ( ) ; } if ( s == null ) { return ; } v . add ( s ) ; setChecked ( false ) ; } public boolean hasSelectors ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . hasSelectors ( ) ; } dieOnCircularReference ( ) ; return ! v . isEmpty ( ) ; } public int selectorCount ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . selectorCount ( ) ; } dieOnCircularReference ( ) ; return v . size ( ) ; } public Iterator getSelectors ( ) { if ( isReference ( ) ) { return ( ( ResourceSelectorContainer ) getCheckedRef ( ) ) . getSelectors ( ) ; } dieOnCircularReference ( ) ; return Collections . unmodifiableList ( v ) . iterator ( ) ; } protected void dieOnCircularReference ( Stack stk , Project p ) throws BuildException { if ( isChecked ( ) ) { return ; } if ( isReference ( ) ) { super . dieOnCircularReference ( stk , p ) ; } else { for ( Iterator i = v . iterator ( ) ; i . hasNext ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof DataType ) { stk . push ( o ) ; invokeCircularReferenceCheck ( ( DataType ) o , stk , p ) ; } } setChecked ( true ) ; } } } 	0	['7', '3', '5', '9', '26', '0', '5', '4', '6', '0', '141', '1', '0', '0.857142857', '0.314285714', '1', '3', '19', '3', '1.5714', '0']
package org . apache . tools . ant . taskdefs . optional . depend ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; public class JarFileIterator implements ClassFileIterator { private ZipInputStream jarStream ; public JarFileIterator ( InputStream stream ) throws IOException { super ( ) ; jarStream = new ZipInputStream ( stream ) ; } public ClassFile getNextClassFile ( ) { ZipEntry jarEntry ; ClassFile nextElement = null ; try { jarEntry = jarStream . getNextEntry ( ) ; while ( nextElement == null && jarEntry != null ) { String entryName = jarEntry . getName ( ) ; if ( ! jarEntry . isDirectory ( ) && entryName . endsWith ( ".class" ) ) { ClassFile javaClass = new ClassFile ( ) ; javaClass . read ( jarStream ) ; nextElement = javaClass ; } else { jarEntry = jarStream . getNextEntry ( ) ; } } } catch ( IOException e ) { String message = e . getMessage ( ) ; String text = e . getClass ( ) . getName ( ) ; if ( message != null ) { text += ": " + message ; } throw new RuntimeException ( "Problem reading JAR file: " + text ) ; } return nextElement ; } } 	0	['2', '1', '0', '2', '18', '0', '0', '2', '2', '0', '83', '1', '0', '0', '0.75', '0', '0', '40', '6', '3', '0']
