package org . apache . camel ; import java . util . Map ; public interface Message { String getMessageId ( ) ; void setMessageId ( String messageId ) ; Exchange getExchange ( ) ; Object getHeader ( String name ) ; < T > T getHeader ( String name , Class < T > type ) ; void setHeader ( String name , Object value ) ; Map < String , Object > getHeaders ( ) ; void setHeaders ( Map < String , Object > headers ) ; public Object getBody ( ) ; public < T > T getBody ( Class < T > type ) ; public void setBody ( Object body ) ; public < T > void setBody ( Object body , Class < T > type ) ; Message copy ( ) ; } 	1	['13', '1', '0', '66', '13', '78', '66', '1', '13', '2', '13', '0', '0', '0', '0.369230769', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . file ; import org . apache . camel . Exchange ; import org . apache . camel . Producer ; import org . apache . camel . impl . DefaultProducer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; public class FileProducer extends DefaultProducer { private static final transient Log log = LogFactory . getLog ( FileProducer . class ) ; private final FileEndpoint endpoint ; public FileProducer ( FileEndpoint endpoint ) { super ( endpoint ) ; this . endpoint = endpoint ; } public void process ( Exchange exchange ) { process ( endpoint . toExchangeType ( exchange ) ) ; } public void process ( FileExchange exchange ) { String fileName = exchange . getIn ( ) . getMessageId ( ) ; ByteBuffer payload = exchange . getIn ( ) . getBody ( ByteBuffer . class ) ; payload . flip ( ) ; File file = null ; if ( endpoint . getFile ( ) != null && endpoint . getFile ( ) . isDirectory ( ) ) { file = new File ( endpoint . getFile ( ) , fileName ) ; } else { file = new File ( fileName ) ; } buildDirectory ( file ) ; try { FileChannel fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . position ( fc . size ( ) ) ; fc . write ( payload ) ; fc . close ( ) ; } catch ( Throwable e ) { log . error ( "Failed to write to File: " + file , e ) ; } } private void buildDirectory ( File file ) { String dirName = file . getAbsolutePath ( ) ; int index = dirName . lastIndexOf ( File . separatorChar ) ; if ( index > 0 ) { dirName = dirName . substring ( 0 , index ) ; File dir = new File ( dirName ) ; dir . mkdirs ( ) ; } } } 	1	['5', '3', '0', '8', '31', '2', '1', '8', '3', '0.5', '122', '1', '1', '0.8', '0.4', '0', '0', '23', '3', '1.2', '2']
package org . apache . camel ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; public interface CamelContext extends Service { void addComponent ( String componentName , Component component ) ; Component getComponent ( String componentName ) ; < T extends Component > T getComponent ( String name , Class < T > componentType ) ; Component removeComponent ( String componentName ) ; Component getOrCreateComponent ( String componentName , Callable < Component > factory ) ; Endpoint getEndpoint ( String uri ) ; < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) ; Collection < Endpoint > getSingletonEndpoints ( ) ; Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception ; Endpoint removeSingletonEndpoint ( String uri ) throws Exception ; List < Route > getRoutes ( ) ; void setRoutes ( List < Route > routes ) ; void addRoutes ( Collection < Route > routes ) throws Exception ; void addRoutes ( RouteBuilder builder ) throws Exception ; ExchangeConverter getExchangeConverter ( ) ; TypeConverter getTypeConverter ( ) ; Injector getInjector ( ) ; } 	1	['17', '1', '0', '84', '17', '136', '80', '7', '17', '2', '17', '0', '0', '0', '0.222222222', '0', '0', '0', '1', '1', '1']
package org . apache . camel . component . file ; import org . apache . camel . Consumer ; import org . apache . camel . Processor ; import org . apache . camel . Producer ; import org . apache . camel . impl . ScheduledPollEndpoint ; import java . io . File ; public class FileEndpoint extends ScheduledPollEndpoint < FileExchange > { private File file ; private boolean autoCreate = true ; protected FileEndpoint ( File file , String endpointUri , FileComponent component ) { super ( endpointUri , component ) ; this . file = file ; } public Producer < FileExchange > createProducer ( ) throws Exception { Producer < FileExchange > result = new FileProducer ( this ) ; return result ; } public Consumer < FileExchange > createConsumer ( Processor file ) throws Exception { Consumer < FileExchange > result = new FileConsumer ( this , file ) ; configureConsumer ( result ) ; return result ; } public FileExchange createExchange ( File file ) { return new FileExchange ( getContext ( ) , file ) ; } public FileExchange createExchange ( ) { return createExchange ( getFile ( ) ) ; } public File getFile ( ) { if ( autoCreate && ! file . exists ( ) ) { file . mkdirs ( ) ; } return file ; } public boolean isSingleton ( ) { return true ; } public boolean isAutoCreate ( ) { return this . autoCreate ; } public void setAutoCreate ( boolean autoCreate ) { this . autoCreate = autoCreate ; } } 	1	['10', '3', '0', '11', '17', '33', '3', '11', '9', '0.555555556', '79', '1', '0', '0.666666667', '0.266666667', '1', '1', '6.7', '3', '1.1', '1']
package org . apache . camel . impl ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; public abstract class MessageSupport implements Message { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; private Exchange exchange ; private Object body ; private String messageId = defaultIdGenerator . generateId ( ) ; public Object getBody ( ) { if ( body == null ) { body = createBody ( ) ; } return body ; } @ SuppressWarnings ( { "unchecked" } ) public < T > T getBody ( Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { return e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , getBody ( ) ) ; } return ( T ) getBody ( ) ; } public void setBody ( Object body ) { this . body = body ; } public < T > void setBody ( Object body , Class < T > type ) { Exchange e = getExchange ( ) ; if ( e != null ) { T value = e . getContext ( ) . getTypeConverter ( ) . convertTo ( type , body ) ; if ( value != null ) { body = value ; } } setBody ( body ) ; } public Message copy ( ) { Message answer = newInstance ( ) ; answer . setMessageId ( getMessageId ( ) ) ; answer . setBody ( getBody ( ) ) ; answer . getHeaders ( ) . putAll ( getHeaders ( ) ) ; return answer ; } public Exchange getExchange ( ) { return exchange ; } public void setExchange ( Exchange exchange ) { this . exchange = exchange ; } public abstract Message newInstance ( ) ; protected Object createBody ( ) { return null ; } public String getMessageId ( ) { return this . messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } } 	1	['13', '1', '1', '7', '24', '66', '2', '5', '11', '0.770833333', '113', '1', '2', '0', '0.3', '0', '0', '7.384615385', '3', '1.1538', '1']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Exchange ; import org . apache . camel . Message ; import org . apache . camel . util . UuidGenerator ; import java . util . HashMap ; import java . util . Map ; public class DefaultExchange implements Exchange { private static final UuidGenerator defaultIdGenerator = new UuidGenerator ( ) ; protected final CamelContext context ; private Map < String , Object > headers ; private Message in ; private Message out ; private Message fault ; private Throwable exception ; private String exchangeId = DefaultExchange . defaultIdGenerator . generateId ( ) ; public DefaultExchange ( CamelContext context ) { this . context = context ; } @ Override public String toString ( ) { return "Exchange[" + in + "]" ; } public Exchange copy ( ) { Exchange exchange = newInstance ( ) ; exchange . copyFrom ( this ) ; return exchange ; } public void copyFrom ( Exchange exchange ) { if ( exchange == this ) { return ; } setHeaders ( safeCopy ( exchange . getProperties ( ) ) ) ; setIn ( safeCopy ( exchange . getIn ( ) ) ) ; setOut ( safeCopy ( exchange . getOut ( ) ) ) ; setFault ( safeCopy ( exchange . getFault ( ) ) ) ; setException ( exchange . getException ( ) ) ; } static private Map < String , Object > safeCopy ( Map < String , Object > properties ) { if ( properties == null ) return null ; return new HashMap < String , Object > ( properties ) ; } static private Message safeCopy ( Message message ) { if ( message == null ) return null ; return message . copy ( ) ; } public Exchange newInstance ( ) { return new DefaultExchange ( context ) ; } public CamelContext getContext ( ) { return context ; } public Object getProperty ( String name ) { if ( headers != null ) { return headers . get ( name ) ; } return null ; } public < T > T getProperty ( String name , Class < T > type ) { Object value = getProperty ( name ) ; return getContext ( ) . getTypeConverter ( ) . convertTo ( type , value ) ; } public void setProperty ( String name , Object value ) { getProperties ( ) . put ( name , value ) ; } public Map < String , Object > getProperties ( ) { if ( headers == null ) { headers = new HashMap < String , Object > ( ) ; } return headers ; } public void setHeaders ( Map < String , Object > headers ) { this . headers = headers ; } public Message getIn ( ) { if ( in == null ) { in = createInMessage ( ) ; configureMessage ( in ) ; } return in ; } public void setIn ( Message in ) { this . in = in ; configureMessage ( in ) ; } public Message getOut ( ) { return getOut ( true ) ; } public Message getOut ( boolean lazyCreate ) { if ( out == null && lazyCreate ) { out = createOutMessage ( ) ; configureMessage ( out ) ; } return out ; } public void setOut ( Message out ) { this . out = out ; configureMessage ( out ) ; } public Throwable getException ( ) { return exception ; } public void setException ( Throwable exception ) { this . exception = exception ; } public Message getFault ( ) { return fault ; } public void setFault ( Message fault ) { this . fault = fault ; configureMessage ( fault ) ; } public String getExchangeId ( ) { return exchangeId ; } public void setExchangeId ( String id ) { this . exchangeId = id ; } protected Message createInMessage ( ) { return new DefaultMessage ( ) ; } protected Message createOutMessage ( ) { return new DefaultMessage ( ) ; } protected void configureMessage ( Message message ) { if ( message instanceof MessageSupport ) { MessageSupport messageSupport = ( MessageSupport ) message ; messageSupport . setExchange ( this ) ; } } } 	1	['28', '1', '11', '23', '50', '346', '16', '7', '22', '0.888888889', '258', '1', '5', '0', '0.155555556', '0', '0', '7.928571429', '3', '1.25', '1']
package org . apache . camel . builder . xml ; import org . apache . camel . Exchange ; import org . apache . camel . ExpectedBodyTypeException ; import org . apache . camel . Message ; import org . apache . camel . Processor ; import org . apache . camel . RuntimeTransformException ; import org . apache . camel . converter . jaxp . XmlConverter ; import static org . apache . camel . util . ObjectHelper . notNull ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Result ; import javax . xml . transform . Source ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . stream . StreamSource ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class XsltBuilder implements Processor { private Map < String , Object > parameters = new HashMap < String , Object > ( ) ; private XmlConverter converter = new XmlConverter ( ) ; private Transformer transformer ; private ResultHandler resultHandler = new StringResultHandler ( ) ; private boolean failOnNullBody = true ; public XsltBuilder ( ) { } public XsltBuilder ( Transformer transformer ) { this . transformer = transformer ; } @ Override public String toString ( ) { return "XSLT[" + transformer + "]" ; } public synchronized void process ( Exchange exchange ) throws Exception { Transformer transformer = getTransformer ( ) ; if ( transformer == null ) { throw new IllegalArgumentException ( "No transformer configured!" ) ; } configureTransformer ( transformer , exchange ) ; Source source = getSource ( exchange ) ; Result result = resultHandler . getResult ( ) ; transformer . transform ( source , result ) ; resultHandler . setBody ( exchange . getIn ( ) ) ; } public static XsltBuilder xslt ( Transformer transformer ) { return new XsltBuilder ( transformer ) ; } public static XsltBuilder xslt ( Source xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; XsltBuilder answer = new XsltBuilder ( ) ; answer . setTransformerSource ( xslt ) ; return answer ; } public static XsltBuilder xslt ( File xslt ) throws TransformerConfigurationException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public static XsltBuilder xslt ( URL xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( xslt . openStream ( ) ) ; } public static XsltBuilder xslt ( InputStream xslt ) throws TransformerConfigurationException , IOException { notNull ( xslt , "xslt" ) ; return xslt ( new StreamSource ( xslt ) ) ; } public XsltBuilder outputBytes ( ) { setResultHandler ( new StreamResultHandler ( ) ) ; return this ; } public XsltBuilder outputString ( ) { setResultHandler ( new StringResultHandler ( ) ) ; return this ; } public XsltBuilder outputDOM ( ) { setResultHandler ( new DomResultHandler ( ) ) ; return this ; } public XsltBuilder parameter ( String name , Object value ) { parameters . put ( name , value ) ; return this ; } public Map < String , Object > getParameters ( ) { return parameters ; } public void setParameters ( Map < String , Object > parameters ) { this . parameters = parameters ; } public Transformer getTransformer ( ) { return transformer ; } public void setTransformer ( Transformer transformer ) { this . transformer = transformer ; } public boolean isFailOnNullBody ( ) { return failOnNullBody ; } public void setFailOnNullBody ( boolean failOnNullBody ) { this . failOnNullBody = failOnNullBody ; } public ResultHandler getResultHandler ( ) { return resultHandler ; } public void setResultHandler ( ResultHandler resultHandler ) { this . resultHandler = resultHandler ; } public void setTransformerSource ( Source source ) throws TransformerConfigurationException { setTransformer ( converter . getTransformerFactory ( ) . newTransformer ( source ) ) ; } protected Source getSource ( Exchange exchange ) { Message in = exchange . getIn ( ) ; Source source = in . getBody ( Source . class ) ; if ( source == null ) { if ( isFailOnNullBody ( ) ) { throw new ExpectedBodyTypeException ( exchange , Source . class ) ; } else { try { source = converter . toSource ( converter . createDocument ( ) ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeTransformException ( e ) ; } } } return source ; } protected void configureTransformer ( Transformer transformer , Exchange exchange ) { transformer . clearParameters ( ) ; addParameters ( transformer , exchange . getProperties ( ) ) ; addParameters ( transformer , exchange . getIn ( ) . getHeaders ( ) ) ; addParameters ( transformer , getParameters ( ) ) ; transformer . setParameter ( "exchange" , exchange ) ; transformer . setParameter ( "in" , exchange . getIn ( ) ) ; transformer . setParameter ( "out" , exchange . getOut ( ) ) ; } protected void addParameters ( Transformer transformer , Map < String , Object > map ) { Set < Map . Entry < String , Object > > propertyEntries = map . entrySet ( ) ; for ( Map . Entry < String , Object > entry : propertyEntries ) { transformer . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } 	1	['25', '1', '0', '11', '63', '230', '0', '11', '22', '0.65', '316', '1', '2', '0', '0.13', '0', '0', '11.44', '3', '1.04', '1']
package org . apache . camel ; public interface Processor { void process ( Exchange exchange ) throws Exception ; } 	1	['1', '1', '0', '126', '1', '0', '125', '1', '1', '2', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '1']
package org . apache . camel . converter ; import org . apache . camel . Converter ; import java . io . * ; import java . nio . ByteBuffer ; @ Converter public class NIOConverter { @ Converter public static byte [ ] toByteArray ( ByteBuffer buffer ) { return buffer . array ( ) ; } @ Converter public static ByteBuffer toByteBuffer ( byte [ ] data ) { return ByteBuffer . wrap ( data ) ; } @ Converter public static ByteBuffer toByteBuffer ( String value ) { ByteBuffer buf = ByteBuffer . allocate ( value . length ( ) ) ; byte [ ] bytes = value . getBytes ( ) ; buf . put ( bytes ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Short value ) { ByteBuffer buf = ByteBuffer . allocate ( 2 ) ; buf . putShort ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Integer value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Float value ) { ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putFloat ( value ) ; return buf ; } @ Converter public static ByteBuffer toByteBuffer ( Double value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putDouble ( value ) ; return buf ; } } 	1	['9', '1', '0', '1', '26', '36', '1', '0', '9', '2', '81', '0', '0', '0', '0.111111111', '0', '0', '8', '1', '0.8889', '1']
package org . apache . camel . component . file ; import org . apache . camel . Processor ; import org . apache . camel . impl . ScheduledPollConsumer ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . channels . FileChannel ; public class FileConsumer extends ScheduledPollConsumer < FileExchange > { private static final transient Log log = LogFactory . getLog ( FileConsumer . class ) ; private final FileEndpoint endpoint ; private boolean recursive = true ; private boolean attemptFileLock = false ; private String regexPattern = "" ; private long lastPollTime = 0l ; public FileConsumer ( final FileEndpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; this . endpoint = endpoint ; } protected void poll ( ) throws Exception { pollFileOrDirectory ( endpoint . getFile ( ) , isRecursive ( ) ) ; lastPollTime = System . currentTimeMillis ( ) ; } protected void pollFileOrDirectory ( File fileOrDirectory , boolean processDir ) { if ( ! fileOrDirectory . isDirectory ( ) ) { pollFile ( fileOrDirectory ) ; } else if ( processDir ) { log . debug ( "Polling directory " + fileOrDirectory ) ; File [ ] files = fileOrDirectory . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { pollFileOrDirectory ( files [ i ] , isRecursive ( ) ) ; } } else { log . debug ( "Skipping directory " + fileOrDirectory ) ; } } protected void pollFile ( final File file ) { if ( file . exists ( ) && file . lastModified ( ) > lastPollTime ) { if ( isValidFile ( file ) ) { processFile ( file ) ; } } } protected void processFile ( File file ) { try { getProcessor ( ) . process ( endpoint . createExchange ( file ) ) ; } catch ( Throwable e ) { handleException ( e ) ; } } protected boolean isValidFile ( File file ) { boolean result = false ; if ( file != null && file . exists ( ) ) { if ( isMatched ( file ) ) { if ( isAttemptFileLock ( ) ) { FileChannel fc = null ; try { fc = new RandomAccessFile ( file , "rw" ) . getChannel ( ) ; fc . lock ( ) ; result = true ; } catch ( Throwable e ) { log . debug ( "Failed to get the lock on file: " + file , e ) ; } finally { if ( fc != null ) { try { fc . close ( ) ; } catch ( IOException e ) { } } } } else { result = true ; } } } return result ; } protected boolean isMatched ( File file ) { boolean result = true ; if ( regexPattern != null && regexPattern . length ( ) > 0 ) { result = file . getName ( ) . matches ( getRegexPattern ( ) ) ; } return result ; } public boolean isRecursive ( ) { return this . recursive ; } public void setRecursive ( boolean recursive ) { this . recursive = recursive ; } public boolean isAttemptFileLock ( ) { return this . attemptFileLock ; } public void setAttemptFileLock ( boolean attemptFileLock ) { this . attemptFileLock = attemptFileLock ; } public String getRegexPattern ( ) { return this . regexPattern ; } public void setRegexPattern ( String regexPattern ) { this . regexPattern = regexPattern ; } } 	1	['14', '4', '0', '8', '39', '51', '1', '8', '7', '0.730769231', '240', '1', '1', '0.692307692', '0.307692308', '1', '1', '15.71428571', '6', '1.7143', '1']
package org . apache . camel . impl ; import java . util . concurrent . atomic . AtomicBoolean ; import org . apache . camel . Service ; public abstract class ServiceSupport implements Service { private AtomicBoolean started = new AtomicBoolean ( false ) ; private AtomicBoolean stopping = new AtomicBoolean ( false ) ; private AtomicBoolean stopped = new AtomicBoolean ( false ) ; public void start ( ) throws Exception { if ( started . compareAndSet ( false , true ) ) { doStart ( ) ; } } public void stop ( ) throws Exception { if ( stopped . compareAndSet ( false , true ) ) { stopping . set ( true ) ; try { doStop ( ) ; } finally { stopped . set ( true ) ; started . set ( false ) ; stopping . set ( false ) ; } } } public boolean isStarted ( ) { return started . get ( ) ; } public boolean isStopping ( ) { return stopping . get ( ) ; } public boolean isStopped ( ) { return stopped . get ( ) ; } protected abstract void doStart ( ) throws Exception ; protected abstract void doStop ( ) throws Exception ; } 	1	['8', '1', '25', '26', '13', '8', '25', '1', '6', '0.666666667', '94', '1', '0', '0', '1', '0', '0', '10.375', '1', '0.875', '1']
package org . apache . camel . impl ; import org . apache . camel . CamelContext ; import org . apache . camel . Component ; import org . apache . camel . Endpoint ; import org . apache . camel . Exchange ; import org . apache . camel . ResolveEndpointFailedException ; import org . apache . camel . Route ; import org . apache . camel . RuntimeCamelException ; import org . apache . camel . Service ; import org . apache . camel . TypeConverter ; import org . apache . camel . builder . RouteBuilder ; import org . apache . camel . impl . converter . DefaultTypeConverter ; import org . apache . camel . spi . ComponentResolver ; import org . apache . camel . spi . ExchangeConverter ; import org . apache . camel . spi . Injector ; import org . apache . camel . util . FactoryFinder ; import org . apache . camel . util . NoFactoryAvailableException ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ServiceHelper . startServices ; import static org . apache . camel . util . ServiceHelper . stopServices ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultCamelContext extends ServiceSupport implements CamelContext , Service { private Map < String , Endpoint > endpoints = new HashMap < String , Endpoint > ( ) ; private Map < String , Component > components = new HashMap < String , Component > ( ) ; private List < Route > routes ; private List < Service > servicesToClose = new ArrayList < Service > ( ) ; private TypeConverter typeConverter ; private ExchangeConverter exchangeConverter ; private Injector injector ; private ComponentResolver componentResolver ; private boolean autoCreateComponents = true ; public void addComponent ( String componentName , final Component component ) { if ( component == null ) { throw new IllegalArgumentException ( "Component cannot be null" ) ; } synchronized ( components ) { if ( components . containsKey ( componentName ) ) { throw new IllegalArgumentException ( "Component previously added: " + componentName ) ; } component . setCamelContext ( this ) ; components . put ( componentName , component ) ; } } public Component getComponent ( String name ) { synchronized ( components ) { Component component = components . get ( name ) ; if ( component == null && autoCreateComponents ) { try { component = getComponentResolver ( ) . resolveComponent ( name , this ) ; if ( component != null ) { addComponent ( name , component ) ; if ( isStarted ( ) ) { startServices ( component ) ; } } } catch ( Exception e ) { throw new RuntimeCamelException ( "Could not auto create component: " + name , e ) ; } } return component ; } } public < T extends Component > T getComponent ( String name , Class < T > componentType ) { Component component = getComponent ( name ) ; if ( componentType . isInstance ( component ) ) { return componentType . cast ( component ) ; } else { throw new IllegalArgumentException ( "The component is not of type: " + componentType + " but is: " + component ) ; } } public Component removeComponent ( String componentName ) { synchronized ( components ) { return components . remove ( componentName ) ; } } public Component getOrCreateComponent ( String componentName , Callable < Component > factory ) { synchronized ( components ) { Component component = components . get ( componentName ) ; if ( component == null ) { try { component = factory . call ( ) ; if ( component == null ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component, it returned null." ) ; } components . put ( componentName , component ) ; component . setCamelContext ( this ) ; } catch ( Exception e ) { throw new RuntimeCamelException ( "Factory failed to create the " + componentName + " component" , e ) ; } } return component ; } } public Collection < Endpoint > getSingletonEndpoints ( ) { synchronized ( endpoints ) { return new ArrayList < Endpoint > ( endpoints . values ( ) ) ; } } public Endpoint addSingletonEndpoint ( String uri , Endpoint endpoint ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { startServices ( endpoint ) ; oldEndpoint = endpoints . remove ( uri ) ; endpoints . put ( uri , endpoint ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint removeSingletonEndpoint ( String uri ) throws Exception { Endpoint oldEndpoint ; synchronized ( endpoints ) { oldEndpoint = endpoints . remove ( uri ) ; stopServices ( oldEndpoint ) ; } return oldEndpoint ; } public Endpoint getEndpoint ( String uri ) { Endpoint answer ; synchronized ( endpoints ) { answer = endpoints . get ( uri ) ; if ( answer == null ) { try { String splitURI [ ] = ObjectHelper . splitOnCharacter ( uri , ":" , 2 ) ; if ( splitURI [ 1 ] == null ) { throw new IllegalArgumentException ( "Invalid URI, it did not contain a scheme: " + uri ) ; } String scheme = splitURI [ 0 ] ; Component component = getComponent ( scheme ) ; if ( component != null ) { answer = component . createEndpoint ( uri ) ; if ( answer != null && answer . isSingleton ( ) ) { if ( answer != null ) { startServices ( answer ) ; endpoints . put ( uri , answer ) ; } } } } catch ( Exception e ) { throw new ResolveEndpointFailedException ( uri , e ) ; } } } return answer ; } public < T extends Endpoint > T getEndpoint ( String name , Class < T > endpointType ) { Endpoint endpoint = getEndpoint ( name ) ; if ( endpointType . isInstance ( endpoint ) ) { return endpointType . cast ( endpoint ) ; } else { throw new IllegalArgumentException ( "The endpoint is not of type: " + endpointType + " but is: " + endpoint ) ; } } public List < Route > getRoutes ( ) { return routes ; } public void setRoutes ( List < Route > routes ) { this . routes = routes ; } public void addRoutes ( Collection < Route > routes ) throws Exception { if ( this . routes == null ) { this . routes = new ArrayList < Route > ( routes ) ; } else { this . routes . addAll ( routes ) ; } if ( isStarted ( ) ) { startRoutes ( routes ) ; } } public void addRoutes ( RouteBuilder builder ) throws Exception { builder . setContext ( this ) ; addRoutes ( builder . getRouteList ( ) ) ; } public ExchangeConverter getExchangeConverter ( ) { if ( exchangeConverter == null ) { exchangeConverter = createExchangeConverter ( ) ; } return exchangeConverter ; } public void setExchangeConverter ( ExchangeConverter exchangeConverter ) { this . exchangeConverter = exchangeConverter ; } public TypeConverter getTypeConverter ( ) { if ( typeConverter == null ) { typeConverter = createTypeConverter ( ) ; } return typeConverter ; } public void setTypeConverter ( TypeConverter typeConverter ) { this . typeConverter = typeConverter ; } public Injector getInjector ( ) { if ( injector == null ) { injector = createInjector ( ) ; } return injector ; } public void setInjector ( Injector injector ) { this . injector = injector ; } public ComponentResolver getComponentResolver ( ) { if ( componentResolver == null ) { componentResolver = createComponentResolver ( ) ; } return componentResolver ; } public void setComponentResolver ( ComponentResolver componentResolver ) { this . componentResolver = componentResolver ; } protected void doStart ( ) throws Exception { if ( components != null ) { for ( Component component : components . values ( ) ) { startServices ( component ) ; } } startRoutes ( routes ) ; } protected void doStop ( ) throws Exception { stopServices ( servicesToClose ) ; if ( components != null ) { for ( Component component : components . values ( ) ) { stopServices ( component ) ; } } } protected void startRoutes ( Collection < Route > routeList ) throws Exception { if ( routeList != null ) { for ( Route < Exchange > route : routeList ) { List < Service > services = route . getServicesForRoute ( ) ; servicesToClose . addAll ( services ) ; startServices ( services ) ; } } } protected ExchangeConverter createExchangeConverter ( ) { return new DefaultExchangeConverter ( ) ; } protected TypeConverter createTypeConverter ( ) { return new DefaultTypeConverter ( ) ; } protected Injector createInjector ( ) { FactoryFinder finder = new FactoryFinder ( ) ; try { return ( Injector ) finder . newInstance ( "Injector" ) ; } catch ( NoFactoryAvailableException e ) { return new ReflectionInjector ( ) ; } catch ( IllegalAccessException e ) { throw new RuntimeCamelException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeCamelException ( e ) ; } catch ( IOException e ) { throw new RuntimeCamelException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeCamelException ( e ) ; } } protected ComponentResolver createComponentResolver ( ) { return new DefaultComponentResolver ( ) ; } public boolean isAutoCreateComponents ( ) { return autoCreateComponents ; } public void setAutoCreateComponents ( boolean autoCreateComponents ) { this . autoCreateComponents = autoCreateComponents ; } } 	1	['32', '2', '1', '22', '76', '400', '2', '21', '25', '0.867383513', '718', '1', '4', '0.184210526', '0.122767857', '1', '1', '21.15625', '3', '1.4063', '1']
package org . apache . camel . builder ; import static org . apache . camel . util . ObjectHelper . compare ; import org . apache . camel . Exchange ; import org . apache . camel . Expression ; import org . apache . camel . Predicate ; import org . apache . camel . impl . PredicateSupport ; import org . apache . camel . impl . BinaryPredicateSupport ; import org . apache . camel . util . ObjectHelper ; import static org . apache . camel . util . ObjectHelper . notNull ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PredicateBuilder { public static < E extends Exchange > Predicate < E > and ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) && right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") and (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > or ( final Predicate < E > left , final Predicate < E > right ) { notNull ( left , "left" ) ; notNull ( right , "right" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { return left . matches ( exchange ) || right . matches ( exchange ) ; } @ Override public String toString ( ) { return "(" + left + ") or (" + right + ")" ; } } ; } public static < E extends Exchange > Predicate < E > isEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isNotEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ! ObjectHelper . equals ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "==" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return "<" ; } } ; } public static < E extends Exchange > Predicate < E > isLessThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) <= 0 ; } protected String getOperationText ( ) { return "<=" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThan ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) > 0 ; } protected String getOperationText ( ) { return ">" ; } } ; } public static < E extends Exchange > Predicate < E > isGreaterThanOrEqualTo ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return compare ( leftValue , rightValue ) < 0 ; } protected String getOperationText ( ) { return ">=" ; } } ; } public static < E extends Exchange > Predicate < E > contains ( final Expression < E > left , final Expression < E > right ) { return new BinaryPredicateSupport < E > ( left , right ) { protected boolean matches ( E exchange , Object leftValue , Object rightValue ) { return ObjectHelper . contains ( leftValue , rightValue ) ; } protected String getOperationText ( ) { return "contains" ; } } ; } public static < E extends Exchange > Predicate < E > isNull ( final Expression < E > expression ) { return isEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isNotNull ( final Expression < E > expression ) { return isNotEqualTo ( expression , ExpressionBuilder . < E > constantExpression ( null ) ) ; } public static < E extends Exchange > Predicate < E > isInstanceOf ( final Expression < E > expression , final Class type ) { notNull ( expression , "expression" ) ; notNull ( type , "type" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; return type . isInstance ( value ) ; } @ Override public String toString ( ) { return expression + " instanceof " + type . getName ( ) ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final String regex ) { return regex ( expression , Pattern . compile ( regex ) ) ; } public static < E extends Exchange > Predicate < E > regex ( final Expression < E > expression , final Pattern pattern ) { notNull ( expression , "expression" ) ; notNull ( pattern , "pattern" ) ; return new PredicateSupport < E > ( ) { public boolean matches ( E exchange ) { Object value = expression . evaluate ( exchange ) ; if ( value != null ) { Matcher matcher = pattern . matcher ( value . toString ( ) ) ; return matcher . matches ( ) ; } return false ; } @ Override public String toString ( ) { return expression + ".matches(" + pattern + ")" ; } @ Override protected String assertionFailureMessage ( E exchange ) { return super . assertionFailureMessage ( exchange ) + " for <" + expression . evaluate ( exchange ) + ">" ; } } ; } } 	1	['15', '1', '0', '17', '30', '105', '2', '15', '15', '2', '123', '0', '0', '0', '0.2', '0', '0', '7.2', '1', '0.9333', '1']
